{"sha": "68b433a089deff105063feaad598a1635615eb1a", "node_id": "C_kwDOAAsO6NoAKDY4YjQzM2EwODlkZWZmMTA1MDYzZmVhYWQ1OThhMTYzNTYxNWViMWE", "commit": {"author": {"name": "A\u00efssata", "email": "aimaiga2@gmail.com", "date": "2022-07-12T12:17:58Z"}, "committer": {"name": "A\u00efssata", "email": "aimaiga2@gmail.com", "date": "2022-07-25T13:33:44Z"}, "message": "Lighten up const_prop_lint, reusing const_prop", "tree": {"sha": "6ef0159d68ff427289404a4e90315faebed39c1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ef0159d68ff427289404a4e90315faebed39c1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68b433a089deff105063feaad598a1635615eb1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68b433a089deff105063feaad598a1635615eb1a", "html_url": "https://github.com/rust-lang/rust/commit/68b433a089deff105063feaad598a1635615eb1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68b433a089deff105063feaad598a1635615eb1a/comments", "author": {"login": "Dajamante", "id": 40670675, "node_id": "MDQ6VXNlcjQwNjcwNjc1", "avatar_url": "https://avatars.githubusercontent.com/u/40670675?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dajamante", "html_url": "https://github.com/Dajamante", "followers_url": "https://api.github.com/users/Dajamante/followers", "following_url": "https://api.github.com/users/Dajamante/following{/other_user}", "gists_url": "https://api.github.com/users/Dajamante/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dajamante/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dajamante/subscriptions", "organizations_url": "https://api.github.com/users/Dajamante/orgs", "repos_url": "https://api.github.com/users/Dajamante/repos", "events_url": "https://api.github.com/users/Dajamante/events{/privacy}", "received_events_url": "https://api.github.com/users/Dajamante/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dajamante", "id": 40670675, "node_id": "MDQ6VXNlcjQwNjcwNjc1", "avatar_url": "https://avatars.githubusercontent.com/u/40670675?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dajamante", "html_url": "https://github.com/Dajamante", "followers_url": "https://api.github.com/users/Dajamante/followers", "following_url": "https://api.github.com/users/Dajamante/following{/other_user}", "gists_url": "https://api.github.com/users/Dajamante/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dajamante/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dajamante/subscriptions", "organizations_url": "https://api.github.com/users/Dajamante/orgs", "repos_url": "https://api.github.com/users/Dajamante/repos", "events_url": "https://api.github.com/users/Dajamante/events{/privacy}", "received_events_url": "https://api.github.com/users/Dajamante/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f320a224e827b400be25966755a621779f797cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f320a224e827b400be25966755a621779f797cc", "html_url": "https://github.com/rust-lang/rust/commit/2f320a224e827b400be25966755a621779f797cc"}], "stats": {"total": 241, "additions": 19, "deletions": 222}, "files": [{"sha": "a756f1d8f408c4a91b19b60c3735a25625fd0e54", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68b433a089deff105063feaad598a1635615eb1a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b433a089deff105063feaad598a1635615eb1a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=68b433a089deff105063feaad598a1635615eb1a", "patch": "@@ -155,18 +155,18 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n     }\n }\n \n-struct ConstPropMachine<'mir, 'tcx> {\n+pub struct ConstPropMachine<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx>>,\n     /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n-    written_only_inside_own_block_locals: FxHashSet<Local>,\n+    pub written_only_inside_own_block_locals: FxHashSet<Local>,\n     /// Locals that need to be cleared after every block terminates.\n-    only_propagate_inside_block_locals: BitSet<Local>,\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n+    pub only_propagate_inside_block_locals: BitSet<Local>,\n+    pub can_const_prop: IndexVec<Local, ConstPropMode>,\n }\n \n impl ConstPropMachine<'_, '_> {\n-    fn new(\n+    pub fn new(\n         only_propagate_inside_block_locals: BitSet<Local>,\n         can_const_prop: IndexVec<Local, ConstPropMode>,\n     ) -> Self {\n@@ -816,7 +816,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n /// The mode that `ConstProp` is allowed to run in for a given `Local`.\n #[derive(Clone, Copy, Debug, PartialEq)]\n-enum ConstPropMode {\n+pub enum ConstPropMode {\n     /// The `Local` can be propagated into and reads of this `Local` can also be propagated.\n     FullConstProp,\n     /// The `Local` can only be propagated into and from its own block."}, {"sha": "61aee011005b789557e1c23cf90a4f69db2f1f64", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 13, "deletions": 216, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/68b433a089deff105063feaad598a1635615eb1a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b433a089deff105063feaad598a1635615eb1a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=68b433a089deff105063feaad598a1635615eb1a", "patch": "@@ -1,19 +1,23 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use std::cell::Cell;\n-\n-use rustc_ast::Mutability;\n-use rustc_data_structures::fx::FxHashSet;\n+use crate::const_prop::ConstPropMachine;\n+use crate::const_prop::ConstPropMode;\n+use crate::MirLint;\n+use rustc_const_eval::const_eval::ConstEvalErr;\n+use rustc_const_eval::interpret::{\n+    self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar,\n+    ScalarMaybeUninit, StackPopCleanup,\n+};\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    AssertKind, BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind,\n-    Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n-    StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n+    AssertKind, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind, Location,\n+    Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind,\n+    Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -22,42 +26,15 @@ use rustc_middle::ty::{\n     TypeVisitable,\n };\n use rustc_session::lint;\n-use rustc_span::{def_id::DefId, Span};\n+use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n-use rustc_target::spec::abi::Abi as CallAbi;\n use rustc_trait_selection::traits;\n-\n-use crate::MirLint;\n-use rustc_const_eval::const_eval::ConstEvalErr;\n-use rustc_const_eval::interpret::{\n-    self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalState, LocalValue, MemoryKind, OpTy, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n-    StackPopCleanup, StackPopUnwind,\n-};\n+use std::cell::Cell;\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n /// Needed for #66397, because otherwise we eval into large places and that can cause OOM or just\n /// Severely regress performance.\n const MAX_ALLOC_LIMIT: u64 = 1024;\n-\n-/// Macro for machine-specific `InterpError` without allocation.\n-/// (These will never be shown to the user, but they help diagnose ICEs.)\n-macro_rules! throw_machine_stop_str {\n-    ($($tt:tt)*) => {{\n-        // We make a new local type for it. The type itself does not carry any information,\n-        // but its vtable (for the `MachineStopType` trait) does.\n-        struct Zst;\n-        // Printing this type shows the desired string.\n-        impl std::fmt::Display for Zst {\n-            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-                write!(f, $($tt)*)\n-            }\n-        }\n-        impl rustc_middle::mir::interpret::MachineStopType for Zst {}\n-        throw_machine_stop!(Zst)\n-    }};\n-}\n-\n pub struct ConstProp;\n \n impl<'tcx> MirLint<'tcx> for ConstProp {\n@@ -151,172 +128,6 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n     }\n }\n \n-struct ConstPropMachine<'mir, 'tcx> {\n-    /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx>>,\n-    /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n-    written_only_inside_own_block_locals: FxHashSet<Local>,\n-    /// Locals that need to be cleared after every block terminates.\n-    only_propagate_inside_block_locals: BitSet<Local>,\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n-}\n-\n-impl ConstPropMachine<'_, '_> {\n-    fn new(\n-        only_propagate_inside_block_locals: BitSet<Local>,\n-        can_const_prop: IndexVec<Local, ConstPropMode>,\n-    ) -> Self {\n-        Self {\n-            stack: Vec::new(),\n-            written_only_inside_own_block_locals: Default::default(),\n-            only_propagate_inside_block_locals,\n-            can_const_prop,\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx> {\n-    compile_time_machine!(<'mir, 'tcx>);\n-    const PANIC_ON_ALLOC_FAIL: bool = true; // all allocations are small (see `MAX_ALLOC_LIMIT`)\n-\n-    type MemoryKind = !;\n-\n-    fn load_mir(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        _instance: ty::InstanceDef<'tcx>,\n-    ) -> InterpResult<'tcx, &'tcx Body<'tcx>> {\n-        throw_machine_stop_str!(\"calling functions isn't supported in ConstProp\")\n-    }\n-\n-    fn find_mir_or_eval_fn(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _abi: CallAbi,\n-        _args: &[OpTy<'tcx>],\n-        _destination: &PlaceTy<'tcx>,\n-        _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n-        Ok(None)\n-    }\n-\n-    fn call_intrinsic(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _args: &[OpTy<'tcx>],\n-        _destination: &PlaceTy<'tcx>,\n-        _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx> {\n-        throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n-    }\n-\n-    fn assert_panic(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _msg: &rustc_middle::mir::AssertMessage<'tcx>,\n-        _unwind: Option<rustc_middle::mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        bug!(\"panics terminators are not evaluated in ConstProp\")\n-    }\n-\n-    fn binary_ptr_op(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        _bin_op: BinOp,\n-        _left: &ImmTy<'tcx>,\n-        _right: &ImmTy<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        // We can't do this because aliasing of memory can differ between const eval and llvm\n-        throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n-    }\n-\n-    fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n-        local: Local,\n-    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::Provenance>> {\n-        let l = &frame.locals[local];\n-\n-        if matches!(\n-            l.value,\n-            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n-        ) {\n-            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n-            // So stop here.\n-            throw_machine_stop_str!(\"tried to access a local with unknown value\")\n-        }\n-\n-        l.access()\n-    }\n-\n-    fn access_local_mut<'a>(\n-        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-        frame: usize,\n-        local: Local,\n-    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::Provenance>> {\n-        if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n-            throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n-        }\n-        if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n-            trace!(\n-                \"mutating local {:?} which is restricted to its block. \\\n-                Will remove it from const-prop after block is finished.\",\n-                local\n-            );\n-            ecx.machine.written_only_inside_own_block_locals.insert(local);\n-        }\n-        ecx.machine.stack[frame].locals[local].access_mut()\n-    }\n-\n-    fn before_access_global(\n-        _tcx: TyCtxt<'tcx>,\n-        _machine: &Self,\n-        _alloc_id: AllocId,\n-        alloc: ConstAllocation<'tcx, Self::Provenance, Self::AllocExtra>,\n-        _static_def_id: Option<DefId>,\n-        is_write: bool,\n-    ) -> InterpResult<'tcx> {\n-        if is_write {\n-            throw_machine_stop_str!(\"can't write to global\");\n-        }\n-        // If the static allocation is mutable, then we can't const prop it as its content\n-        // might be different at runtime.\n-        if alloc.inner().mutability == Mutability::Mut {\n-            throw_machine_stop_str!(\"can't access mutable globals in ConstProp\");\n-        }\n-\n-        Ok(())\n-    }\n-\n-    #[inline(always)]\n-    fn expose_ptr(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _ptr: Pointer<AllocId>,\n-    ) -> InterpResult<'tcx> {\n-        throw_machine_stop_str!(\"exposing pointers isn't supported in ConstProp\")\n-    }\n-\n-    #[inline(always)]\n-    fn init_frame_extra(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        frame: Frame<'mir, 'tcx>,\n-    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n-        Ok(frame)\n-    }\n-\n-    #[inline(always)]\n-    fn stack<'a>(\n-        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a [Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>] {\n-        &ecx.machine.stack\n-    }\n-\n-    #[inline(always)]\n-    fn stack_mut<'a>(\n-        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>> {\n-        &mut ecx.machine.stack\n-    }\n-}\n-\n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n@@ -711,20 +522,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n }\n \n-/// The mode that `ConstProp` is allowed to run in for a given `Local`.\n-#[derive(Clone, Copy, Debug, PartialEq)]\n-enum ConstPropMode {\n-    /// The `Local` can be propagated into and reads of this `Local` can also be propagated.\n-    FullConstProp,\n-    /// The `Local` can only be propagated into and from its own block.\n-    OnlyInsideOwnBlock,\n-    /// The `Local` can be propagated into but reads cannot be propagated.\n-    OnlyPropagateInto,\n-    /// The `Local` cannot be part of propagation at all. Any statement\n-    /// referencing it either for reading or writing will not get propagated.\n-    NoPropagation,\n-}\n-\n struct CanConstProp {\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     // False at the beginning. Once set, no more assignments are allowed to that local."}]}