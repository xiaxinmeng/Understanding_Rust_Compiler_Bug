{"sha": "6174f9a4d9dc48f9988cd252f4fea8b319020298", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNzRmOWE0ZDlkYzQ4Zjk5ODhjZDI1MmY0ZmVhOGIzMTkwMjAyOTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-18T01:59:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-22T21:16:52Z"}, "message": "std: Move change_dir_locked to unstable. #7870", "tree": {"sha": "4ae693685d847ab5d00a0c6dbff6eb950ae7769c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ae693685d847ab5d00a0c6dbff6eb950ae7769c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6174f9a4d9dc48f9988cd252f4fea8b319020298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6174f9a4d9dc48f9988cd252f4fea8b319020298", "html_url": "https://github.com/rust-lang/rust/commit/6174f9a4d9dc48f9988cd252f4fea8b319020298", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6174f9a4d9dc48f9988cd252f4fea8b319020298/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4beda4e582e4fe008aaf866a5f3ad6a20dec9876", "url": "https://api.github.com/repos/rust-lang/rust/commits/4beda4e582e4fe008aaf866a5f3ad6a20dec9876", "html_url": "https://github.com/rust-lang/rust/commit/4beda4e582e4fe008aaf866a5f3ad6a20dec9876"}], "stats": {"total": 100, "additions": 57, "deletions": 43}, "files": [{"sha": "c5fb4b9292e344df075d734c0fb9aa958a13ac06", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6174f9a4d9dc48f9988cd252f4fea8b319020298/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174f9a4d9dc48f9988cd252f4fea8b319020298/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=6174f9a4d9dc48f9988cd252f4fea8b319020298", "patch": "@@ -48,10 +48,11 @@ mod tests {\n     fn recursive_mkdir_rel() {\n         use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n         use std::os;\n+        use std::unstable::change_dir_locked;\n \n         let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel\").\n             expect(\"recursive_mkdir_rel\");\n-        assert!(do os::change_dir_locked(&root) {\n+        assert!(do change_dir_locked(&root) {\n             let path = Path(\"frob\");\n             debug!(\"recursive_mkdir_rel: Making: %s in cwd %s [%?]\", path.to_str(),\n                    os::getcwd().to_str(),\n@@ -78,10 +79,11 @@ mod tests {\n     fn recursive_mkdir_rel_2() {\n         use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n         use std::os;\n+        use std::unstable::change_dir_locked;\n \n         let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel_2\").\n             expect(\"recursive_mkdir_rel_2\");\n-        assert!(do os::change_dir_locked(&root) {\n+        assert!(do change_dir_locked(&root) {\n             let path = Path(\"./frob/baz\");\n             debug!(\"recursive_mkdir_rel_2: Making: %s in cwd %s [%?]\", path.to_str(),\n                    os::getcwd().to_str(), os::path_exists(&path));"}, {"sha": "286b1f84802c3298eaec4541ab5306a605350916", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6174f9a4d9dc48f9988cd252f4fea8b319020298/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174f9a4d9dc48f9988cd252f4fea8b319020298/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=6174f9a4d9dc48f9988cd252f4fea8b319020298", "patch": "@@ -791,12 +791,14 @@ fn rust_path_test() {\n \n #[test]\n fn rust_path_contents() {\n+    use std::unstable::change_dir_locked;\n+\n     let dir = mkdtemp(&os::tmpdir(), \"rust_path\").expect(\"rust_path_contents failed\");\n     let abc = &dir.push(\"A\").push(\"B\").push(\"C\");\n     assert!(os::mkdir_recursive(&abc.push(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.pop().push(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.pop().pop().push(\".rust\"), U_RWX));\n-    assert!(do os::change_dir_locked(&dir.push(\"A\").push(\"B\").push(\"C\")) {\n+    assert!(do change_dir_locked(&dir.push(\"A\").push(\"B\").push(\"C\")) {\n         let p = rust_path();\n         let cwd = os::getcwd().push(\".rust\");\n         let parent = cwd.pop().pop().push(\".rust\");"}, {"sha": "5981926fce30c618d292d1beb798c45755d6aef2", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6174f9a4d9dc48f9988cd252f4fea8b319020298/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174f9a4d9dc48f9988cd252f4fea8b319020298/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=6174f9a4d9dc48f9988cd252f4fea8b319020298", "patch": "@@ -863,46 +863,6 @@ pub fn change_dir(p: &Path) -> bool {\n     }\n }\n \n-/// Changes the current working directory to the specified\n-/// path while acquiring a global lock, then calls `action`.\n-/// If the change is successful, releases the lock and restores the\n-/// CWD to what it was before, returning true.\n-/// Returns false if the directory doesn't exist or if the directory change\n-/// is otherwise unsuccessful.\n-/// FIXME #7870 This probably shouldn't be part of the public API\n-pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n-    use task;\n-    use unstable::finally::Finally;\n-\n-    unsafe {\n-        // This is really sketchy. Using a pthread mutex so descheduling\n-        // in the `action` callback can cause deadlock. Doing it in\n-        // `task::atomically` to try to avoid that, but ... I don't know\n-        // this is all bogus.\n-        return do task::atomically {\n-            rust_take_change_dir_lock();\n-\n-            do (||{\n-                let old_dir = os::getcwd();\n-                if change_dir(p) {\n-                    action();\n-                    change_dir(&old_dir)\n-                }\n-                else {\n-                    false\n-                }\n-            }).finally {\n-                rust_drop_change_dir_lock();\n-            }\n-        }\n-    }\n-\n-    extern {\n-        fn rust_take_change_dir_lock();\n-        fn rust_drop_change_dir_lock();\n-    }\n-}\n-\n /// Copies a file from one location to another\n pub fn copy_file(from: &Path, to: &Path) -> bool {\n     return do_copy_file(from, to);"}, {"sha": "e6313a10db1abc962f4516214779308df3b2a66c", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6174f9a4d9dc48f9988cd252f4fea8b319020298/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6174f9a4d9dc48f9988cd252f4fea8b319020298/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=6174f9a4d9dc48f9988cd252f4fea8b319020298", "patch": "@@ -79,3 +79,53 @@ extern {\n     fn rust_raw_thread_start(f: &(&fn())) -> *raw_thread;\n     fn rust_raw_thread_join_delete(thread: *raw_thread);\n }\n+\n+\n+/// Changes the current working directory to the specified\n+/// path while acquiring a global lock, then calls `action`.\n+/// If the change is successful, releases the lock and restores the\n+/// CWD to what it was before, returning true.\n+/// Returns false if the directory doesn't exist or if the directory change\n+/// is otherwise unsuccessful.\n+///\n+/// This is used by test cases to avoid cwd races.\n+///\n+/// # Safety Note\n+///\n+/// This uses a pthread mutex so descheduling in the action callback\n+/// can lead to deadlock. Calling change_dir_locked recursively will\n+/// also deadlock.\n+pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n+    use os;\n+    use os::change_dir;\n+    use task;\n+    use unstable::finally::Finally;\n+\n+    unsafe {\n+        // This is really sketchy. Using a pthread mutex so descheduling\n+        // in the `action` callback can cause deadlock. Doing it in\n+        // `task::atomically` to try to avoid that, but ... I don't know\n+        // this is all bogus.\n+        return do task::atomically {\n+            rust_take_change_dir_lock();\n+\n+            do (||{\n+                let old_dir = os::getcwd();\n+                if change_dir(p) {\n+                    action();\n+                    change_dir(&old_dir)\n+                }\n+                else {\n+                    false\n+                }\n+            }).finally {\n+                rust_drop_change_dir_lock();\n+            }\n+        }\n+    }\n+\n+    extern {\n+        fn rust_take_change_dir_lock();\n+        fn rust_drop_change_dir_lock();\n+    }\n+}"}]}