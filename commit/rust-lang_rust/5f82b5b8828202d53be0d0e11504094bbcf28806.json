{"sha": "5f82b5b8828202d53be0d0e11504094bbcf28806", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmODJiNWI4ODI4MjAyZDUzYmUwZDBlMTE1MDQwOTRiYmNmMjg4MDY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-24T03:16:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-24T03:16:17Z"}, "message": "Rollup merge of #56278 - eddyb:mir-debuginfo-proof, r=nikomatsakis\n\nFuture-proof MIR for dedicated debuginfo.\n\nThis is #56231 without the last commit (the one that actually moves to `VarDebuginfo`).\nNothing should be broken, but it should no longer depend on debuginfo for anything else.\n\nr? @nikomatsakis", "tree": {"sha": "040b41d47b305d9c3c82539fd9221a1b6885763a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/040b41d47b305d9c3c82539fd9221a1b6885763a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f82b5b8828202d53be0d0e11504094bbcf28806", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcv9UBCRBK7hj4Ov3rIwAAdHIIAD4gOxVMmjo893r8SfsVFuA5\n07sYbjafR0VXW9GK1+sraB1Mk/fJeXK+uJBx2gwag1DMnhwQffYEiHlLFBLc33Ra\nxA3znIghf7/bNbcsFMhHbRHuhRXs/dzNCWlA98+yENPSFTcGvPDSJZG71i7JplBH\nKdxlfx1mQamqohTcjZXODtRJZENn0gDkoBDoKtDjKxdDtTE68+4I0MkzZawkyCMW\njDGo3GgNgY0mwR4U2IZptz15Fd43J3rDSqOSBtnQ0Arml1AoY9YTXJ9/pmBNaYOt\n0xEbVTdhYauyyV814zPZNkfIhh5cIiAPG2R9rJWLmfc9bCz5kwKhzDJXp6z0wuM=\n=wjXJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 040b41d47b305d9c3c82539fd9221a1b6885763a\nparent 0928511d3a11ecc9703c3c34f0fe36282dd9b171\nparent c3ca9a35be01934df917debca60bbc834f5c0653\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556075777 +0200\ncommitter GitHub <noreply@github.com> 1556075777 +0200\n\nRollup merge of #56278 - eddyb:mir-debuginfo-proof, r=nikomatsakis\n\nFuture-proof MIR for dedicated debuginfo.\n\nThis is #56231 without the last commit (the one that actually moves to `VarDebuginfo`).\nNothing should be broken, but it should no longer depend on debuginfo for anything else.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f82b5b8828202d53be0d0e11504094bbcf28806", "html_url": "https://github.com/rust-lang/rust/commit/5f82b5b8828202d53be0d0e11504094bbcf28806", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f82b5b8828202d53be0d0e11504094bbcf28806/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0928511d3a11ecc9703c3c34f0fe36282dd9b171", "url": "https://api.github.com/repos/rust-lang/rust/commits/0928511d3a11ecc9703c3c34f0fe36282dd9b171", "html_url": "https://github.com/rust-lang/rust/commit/0928511d3a11ecc9703c3c34f0fe36282dd9b171"}, {"sha": "c3ca9a35be01934df917debca60bbc834f5c0653", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ca9a35be01934df917debca60bbc834f5c0653", "html_url": "https://github.com/rust-lang/rust/commit/c3ca9a35be01934df917debca60bbc834f5c0653"}], "stats": {"total": 572, "additions": 318, "deletions": 254}, "files": [{"sha": "bf2a1eaafd664fad79ba942d98cac64b8fcb715c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -4,7 +4,7 @@\n \n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n-use crate::hir::{self, HirId, InlineAsm as HirInlineAsm};\n+use crate::hir::{self, InlineAsm as HirInlineAsm};\n use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n@@ -138,16 +138,20 @@ pub struct Mir<'tcx> {\n     /// If this MIR was built for a constant, this will be 0.\n     pub arg_count: usize,\n \n-    /// Names and capture modes of all the closure upvars, assuming\n-    /// the first argument is either the closure or a reference to it.\n-    pub upvar_decls: Vec<UpvarDecl>,\n-\n     /// Mark an argument local (which must be a tuple) as getting passed as\n     /// its individual components at the LLVM level.\n     ///\n     /// This is used for the \"rust-call\" ABI.\n     pub spread_arg: Option<Local>,\n \n+    /// Names and capture modes of all the closure upvars, assuming\n+    /// the first argument is either the closure or a reference to it.\n+    // NOTE(eddyb) This is *strictly* a temporary hack for codegen\n+    // debuginfo generation, and will be removed at some point.\n+    // Do **NOT** use it for anything else, upvar information should not be\n+    // in the MIR, please rely on local crate HIR or other side-channels.\n+    pub __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+\n     /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n     /// `||` expression into `&` or `|` respectively. This is problematic because if we ever stop\n     /// this conversion from happening and use short circuiting, we will cause the following code\n@@ -173,7 +177,7 @@ impl<'tcx> Mir<'tcx> {\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n-        upvar_decls: Vec<UpvarDecl>,\n+        __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n     ) -> Self {\n@@ -197,7 +201,7 @@ impl<'tcx> Mir<'tcx> {\n             local_decls,\n             user_type_annotations,\n             arg_count,\n-            upvar_decls,\n+            __upvar_debuginfo_codegen_only_do_not_use,\n             spread_arg: None,\n             span,\n             cache: cache::Cache::new(),\n@@ -431,7 +435,7 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     local_decls,\n     user_type_annotations,\n     arg_count,\n-    upvar_decls,\n+    __upvar_debuginfo_codegen_only_do_not_use,\n     spread_arg,\n     control_flow_destroyed,\n     span,\n@@ -983,16 +987,11 @@ impl<'tcx> LocalDecl<'tcx> {\n \n /// A closure capture, with its name and mode.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UpvarDecl {\n+pub struct UpvarDebuginfo {\n     pub debug_name: Name,\n \n-    /// `HirId` of the captured variable\n-    pub var_hir_id: ClearCrossCrate<HirId>,\n-\n     /// If true, the capture is behind a reference.\n     pub by_ref: bool,\n-\n-    pub mutability: Mutability,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -3156,7 +3155,7 @@ CloneTypeFoldableAndLiftImpls! {\n     MirPhase,\n     Mutability,\n     SourceInfo,\n-    UpvarDecl,\n+    UpvarDebuginfo,\n     FakeReadCause,\n     RetagKind,\n     SourceScope,\n@@ -3178,7 +3177,7 @@ BraceStructTypeFoldableImpl! {\n         local_decls,\n         user_type_annotations,\n         arg_count,\n-        upvar_decls,\n+        __upvar_debuginfo_codegen_only_do_not_use,\n         spread_arg,\n         control_flow_destroyed,\n         span,"}, {"sha": "04b763f773d9ed089656ceaf854e877dc3117170", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -133,41 +133,6 @@ impl<'tcx> Place<'tcx> {\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }\n-\n-    /// If this is a field projection, and the field is being projected from a closure type,\n-    /// then returns the index of the field being projected. Note that this closure will always\n-    /// be `self` in the current MIR, because that is the only time we directly access the fields\n-    /// of a closure type.\n-    pub fn is_upvar_field_projection<'cx, 'gcx>(&self, mir: &'cx Mir<'tcx>,\n-                                                tcx: &TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Field> {\n-        let (place, by_ref) = if let Place::Projection(ref proj) = self {\n-            if let ProjectionElem::Deref = proj.elem {\n-                (&proj.base, true)\n-            } else {\n-                (self, false)\n-            }\n-        } else {\n-            (self, false)\n-        };\n-\n-        match place {\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _ty) => {\n-                    let base_ty = proj.base.ty(mir, *tcx).ty;\n-\n-                    if (base_ty.is_closure() || base_ty.is_generator()) &&\n-                        (!by_ref || mir.upvar_decls[field.index()].by_ref)\n-                    {\n-                        Some(field)\n-                    } else {\n-                        None\n-                    }\n-                },\n-                _ => None,\n-            }\n-            _ => None,\n-        }\n-    }\n }\n \n pub enum RvalueInitializationState {"}, {"sha": "cb00cca0f9c960f7b491d63ac493726722ec5505", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -542,7 +542,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         finalize(self)\n     }\n \n-    fn debuginfo_upvar_decls_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4] {\n+    fn debuginfo_upvar_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4] {\n         unsafe {\n             [llvm::LLVMRustDIBuilderCreateOpDeref(),\n              llvm::LLVMRustDIBuilderCreateOpPlusUconst(),"}, {"sha": "621c4e5d4488e77dc49e047220a182bb7d2c6002", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -598,9 +598,10 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                 tmp\n             }\n         };\n+        let upvar_debuginfo = &mir.__upvar_debuginfo_codegen_only_do_not_use;\n         arg_scope.map(|scope| {\n             // Is this a regular argument?\n-            if arg_index > 0 || mir.upvar_decls.is_empty() {\n+            if arg_index > 0 || upvar_debuginfo.is_empty() {\n                 // The Rust ABI passes indirect variables using a pointer and a manual copy, so we\n                 // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n                 // byval attribute, for which LLVM always does the deref itself,\n@@ -638,16 +639,16 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             let (def_id, upvar_substs) = match closure_layout.ty.sty {\n                 ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n                 ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-                _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_layout.ty)\n+                _ => bug!(\"upvar debuginfo with non-closure arg0 type `{}`\", closure_layout.ty)\n             };\n             let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n \n             let extra_locals = {\n-                let upvars = mir.upvar_decls\n+                let upvars = upvar_debuginfo\n                     .iter()\n                     .zip(upvar_tys)\n                     .enumerate()\n-                    .map(|(i, (decl, ty))| (i, decl.debug_name, decl.by_ref, ty));\n+                    .map(|(i, (upvar, ty))| (i, upvar.debug_name, upvar.by_ref, ty));\n \n                 let generator_fields = mir.generator_layout.as_ref().map(|generator_layout| {\n                     let (def_id, gen_substs) = match closure_layout.ty.sty {\n@@ -656,7 +657,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                     };\n                     let state_tys = gen_substs.state_tys(def_id, tcx);\n \n-                    let upvar_count = mir.upvar_decls.len();\n+                    let upvar_count = upvar_debuginfo.len();\n                     generator_layout.fields\n                         .iter()\n                         .zip(state_tys)\n@@ -673,7 +674,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             for (field, name, by_ref, ty) in extra_locals {\n                 let byte_offset_of_var_in_env = closure_layout.fields.offset(field).bytes();\n \n-                let ops = bx.debuginfo_upvar_decls_ops_sequence(byte_offset_of_var_in_env);\n+                let ops = bx.debuginfo_upvar_ops_sequence(byte_offset_of_var_in_env);\n \n                 // The environment and the capture can each be indirect.\n                 let mut ops = if env_ref { &ops[..] } else { &ops[1..] };"}, {"sha": "aadffc5932ba856d8d2dc790687ce271d8d96858", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -37,7 +37,7 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         defining_crate: CrateNum,\n     ) -> Self::DIScope;\n     fn debuginfo_finalize(&self);\n-    fn debuginfo_upvar_decls_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4];\n+    fn debuginfo_upvar_ops_sequence(&self, byte_offset_of_var_in_env: u64) -> [i64; 4];\n }\n \n pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {"}, {"sha": "12dcea7bd5981d619e16fad91602587925e3afb6", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -1088,7 +1088,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n                         LocalKind::Var => \"local variable \",\n                         LocalKind::Arg\n-                        if !self.mir.upvar_decls.is_empty()\n+                        if !self.upvars.is_empty()\n                             && local == Local::new(1) => {\n                             \"variable captured by `move` \"\n                         }\n@@ -1632,11 +1632,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n+                            self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n-                            if self.mir.upvar_decls[var_index].by_ref {\n+                            let name = self.upvars[var_index].name.to_string();\n+                            if self.upvars[var_index].by_ref {\n                                 buf.push_str(&name);\n                             } else {\n                                 buf.push_str(&format!(\"*{}\", &name));\n@@ -1694,10 +1694,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         autoderef = true;\n \n                         let upvar_field_projection =\n-                            place.is_upvar_field_projection(self.mir, &self.infcx.tcx);\n+                            self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n+                            let name = self.upvars[var_index].name.to_string();\n                             buf.push_str(&name);\n                         } else {\n                             let field_name = self.describe_field(&proj.base, field);"}, {"sha": "14cafdef67d7de8b2cf931f3f22a66bf0009b3e5", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 94, "deletions": 16, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -1,7 +1,7 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n-use rustc::hir;\n+use rustc::hir::{self, HirId};\n use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -27,6 +27,7 @@ use std::collections::BTreeMap;\n use std::mem;\n use std::rc::Rc;\n \n+use syntax::ast::Name;\n use syntax_pos::{Span, DUMMY_SP};\n \n use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n@@ -63,6 +64,19 @@ mod used_muts;\n \n pub(crate) mod nll;\n \n+// FIXME(eddyb) perhaps move this somewhere more centrally.\n+#[derive(Debug)]\n+crate struct Upvar {\n+    name: Name,\n+\n+    var_hir_id: HirId,\n+\n+    /// If true, the capture is behind a reference.\n+    by_ref: bool,\n+\n+    mutability: Mutability,\n+}\n+\n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         mir_borrowck,\n@@ -126,6 +140,36 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         .as_local_hir_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n+    // Gather the upvars of a closure, if any.\n+    let tables = tcx.typeck_tables_of(def_id);\n+    let upvars: Vec<_> = tables\n+        .upvar_list\n+        .get(&def_id)\n+        .into_iter()\n+        .flatten()\n+        .map(|upvar_id| {\n+            let var_hir_id = upvar_id.var_path.hir_id;\n+            let var_node_id = tcx.hir().hir_to_node_id(var_hir_id);\n+            let capture = tables.upvar_capture(*upvar_id);\n+            let by_ref = match capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => true,\n+            };\n+            let mut upvar = Upvar {\n+                name: tcx.hir().name(var_node_id),\n+                var_hir_id,\n+                by_ref,\n+                mutability: Mutability::Not,\n+            };\n+            let bm = *tables.pat_binding_modes().get(var_hir_id)\n+                .expect(\"missing binding mode\");\n+            if bm == ty::BindByValue(hir::MutMutable) {\n+                upvar.mutability = Mutability::Mut;\n+            }\n+            upvar\n+        })\n+        .collect();\n+\n     // Replace all regions with fresh inference variables. This\n     // requires first making our own copy of the MIR. This copy will\n     // be modified (in place) to contain non-lexical lifetimes. It\n@@ -168,6 +212,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         def_id,\n         free_regions,\n         mir,\n+        &upvars,\n         location_table,\n         param_env,\n         &mut flow_inits,\n@@ -240,6 +285,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         used_mut_upvars: SmallVec::new(),\n         borrow_set,\n         dominators,\n+        upvars,\n     };\n \n     let mut state = Flows::new(\n@@ -475,6 +521,9 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n \n     /// Dominators for MIR\n     dominators: Dominators<BasicBlock>,\n+\n+    /// Information about upvars not necessarily preserved in types or MIR\n+    upvars: Vec<Upvar>,\n }\n \n // Check that:\n@@ -1287,8 +1336,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n             match *place {\n                 Place::Projection { .. } => {\n-                    if let Some(field) = place.is_upvar_field_projection(\n-                            this.mir, &this.infcx.tcx) {\n+                    if let Some(field) = this.is_upvar_field_projection(place) {\n                         this.used_mut_upvars.push(field);\n                     }\n                 }\n@@ -2057,7 +2105,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 place: place @ Place::Projection(_),\n                 is_local_mutation_allowed: _,\n             } => {\n-                if let Some(field) = place.is_upvar_field_projection(self.mir, &self.infcx.tcx) {\n+                if let Some(field) = self.is_upvar_field_projection(place) {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n@@ -2127,13 +2175,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match place.is_upvar_field_projection(\n-                                            self.mir, &self.infcx.tcx)\n-                                        {\n+                                        let mode = match self.is_upvar_field_projection(place) {\n                                             Some(field)\n-                                                if {\n-                                                    self.mir.upvar_decls[field.index()].by_ref\n-                                                } =>\n+                                                if self.upvars[field.index()].by_ref =>\n                                             {\n                                                 is_local_mutation_allowed\n                                             }\n@@ -2173,15 +2217,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n-                        let upvar_field_projection = place.is_upvar_field_projection(\n-                            self.mir, &self.infcx.tcx);\n+                        let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n-                            let decl = &self.mir.upvar_decls[field.index()];\n+                            let upvar = &self.upvars[field.index()];\n                             debug!(\n-                                \"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n-                                decl, is_local_mutation_allowed, place\n+                                \"upvar.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n+                                upvar, is_local_mutation_allowed, place\n                             );\n-                            match (decl.mutability, is_local_mutation_allowed) {\n+                            match (upvar.mutability, is_local_mutation_allowed) {\n                                 (Mutability::Not, LocalMutationIsAllowed::No)\n                                 | (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars) => {\n                                     Err(place)\n@@ -2229,6 +2272,41 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    /// If `place` is a field projection, and the field is being projected from a closure type,\n+    /// then returns the index of the field being projected. Note that this closure will always\n+    /// be `self` in the current MIR, because that is the only time we directly access the fields\n+    /// of a closure type.\n+    pub fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n+        let (place, by_ref) = if let Place::Projection(ref proj) = place {\n+            if let ProjectionElem::Deref = proj.elem {\n+                (&proj.base, true)\n+            } else {\n+                (place, false)\n+            }\n+        } else {\n+            (place, false)\n+        };\n+\n+        match place {\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(field, _ty) => {\n+                    let tcx = self.infcx.tcx;\n+                    let base_ty = proj.base.ty(self.mir, tcx).ty;\n+\n+                    if (base_ty.is_closure() || base_ty.is_generator()) &&\n+                        (!by_ref || self.upvars[field.index()].by_ref)\n+                    {\n+                        Some(field)\n+                    } else {\n+                        None\n+                    }\n+                },\n+                _ => None,\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "a7bad44c42c7f500f9b85a2894dabb4506ebfc55", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             let origin = Origin::Mir;\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n-                   original_path.is_upvar_field_projection(self.mir, &self.infcx.tcx));\n+                   self.is_upvar_field_projection(original_path));\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n@@ -269,16 +269,15 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         let ty = place.ty(self.mir, self.infcx.tcx).ty;\n                         let is_upvar_field_projection =\n                             self.prefixes(&original_path, PrefixSet::All)\n-                            .any(|p| p.is_upvar_field_projection(self.mir, &self.infcx.tcx)\n-                                 .is_some());\n+                            .any(|p| self.is_upvar_field_projection(p).is_some());\n                         debug!(\"report: ty={:?}\", ty);\n                         match ty.sty {\n                             ty::Array(..) | ty::Slice(..) =>\n                                 self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n                                     span, ty, None, origin\n                                 ),\n                             ty::Closure(def_id, closure_substs)\n-                                if !self.mir.upvar_decls.is_empty() && is_upvar_field_projection\n+                                if def_id == self.mir_def_id && is_upvar_field_projection\n                             => {\n                                 let closure_kind_ty =\n                                     closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n@@ -303,11 +302,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                     span, place_description, origin);\n \n                                 for prefix in self.prefixes(&original_path, PrefixSet::All) {\n-                                    if let Some(field) = prefix.is_upvar_field_projection(\n-                                            self.mir, &self.infcx.tcx) {\n-                                        let upvar_decl = &self.mir.upvar_decls[field.index()];\n-                                        let upvar_hir_id =\n-                                            upvar_decl.var_hir_id.assert_crate_local();\n+                                    if let Some(field) = self.is_upvar_field_projection(prefix) {\n+                                        let upvar_hir_id = self.upvars[field.index()].var_hir_id;\n                                         let upvar_span = self.infcx.tcx.hir().span_by_hir_id(\n                                             upvar_hir_id);\n                                         diag.span_label(upvar_span, \"captured outer variable\");"}, {"sha": "c5ad2b18c23fcf634b31a2ea7c61dd3e58a1d4e6", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -68,10 +68,10 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if access_place.is_upvar_field_projection(self.mir, &self.infcx.tcx).is_some() {\n+                if self.is_upvar_field_projection(access_place).is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n-                    let name = self.mir.upvar_decls[upvar_index.index()].debug_name;\n+                    let name = self.upvars[upvar_index.index()].name;\n                     reason = format!(\", as `{}` is not declared as mutable\", name);\n                 }\n             }\n@@ -81,15 +81,14 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Deref,\n             }) => {\n                 if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n-                    !self.mir.upvar_decls.is_empty() {\n+                    !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n                         the_place_err.ty(self.mir, self.infcx.tcx).ty\n                     ));\n \n-                    reason = if access_place.is_upvar_field_projection(self.mir,\n-                                                                       &self.infcx.tcx).is_some() {\n+                    reason = if self.is_upvar_field_projection(access_place).is_some() {\n                         \", as it is a captured variable in a `Fn` closure\".to_string()\n                     } else {\n                         \", as `Fn` closures cannot mutate their captured variables\".to_string()\n@@ -309,9 +308,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n-                let upvar_hir_id = self.mir.upvar_decls[upvar_index.index()]\n-                    .var_hir_id\n-                    .assert_crate_local();\n+                let upvar_hir_id = self.upvars[upvar_index.index()].var_hir_id;\n                 let upvar_node_id = self.infcx.tcx.hir().hir_to_node_id(upvar_hir_id);\n                 if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n@@ -452,7 +449,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 base,\n                 elem: ProjectionElem::Deref,\n             }) if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n-                  !self.mir.upvar_decls.is_empty() =>\n+                  !self.upvars.is_empty() =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help("}, {"sha": "89f85a941d386107e1ae427cabd3c08ee8ab16f5", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -273,11 +273,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 if mir.local_decls[local].name.is_some() {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n                         if let Place::Base(PlaceBase::Local(borrowed_local)) = place {\n-                            let dropped_local_scope = mir.local_decls[local].visibility_scope;\n-                            let borrowed_local_scope =\n-                                mir.local_decls[*borrowed_local].visibility_scope;\n-\n-                            if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope)\n+                             if mir.local_decls[*borrowed_local].name.is_some()\n                                 && local != *borrowed_local\n                             {\n                                 should_note_order = true;\n@@ -298,6 +294,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     let (category, from_closure, span, region_name) =\n                         self.nonlexical_regioncx.free_region_constraint_info(\n                             self.mir,\n+                        &self.upvars,\n                             self.mir_def_id,\n                             self.infcx,\n                             borrow_region_vid,"}, {"sha": "ad43c8ef66f42b5ecf5bc6d52ea46d618745d65a", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -8,6 +8,7 @@ use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::MirSource;\n+use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n@@ -72,6 +73,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n+    upvars: &[Upvar],\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n@@ -187,7 +189,8 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     });\n \n     // Solve the region constraints.\n-    let closure_region_requirements = regioncx.solve(infcx, &mir, def_id, errors_buffer);\n+    let closure_region_requirements =\n+        regioncx.solve(infcx, &mir, upvars, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging."}, {"sha": "abb30d042ca4cd8e819ee4a9ffb3f868e5d60a7a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -4,6 +4,7 @@ use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ConstraintDescription;\n use crate::util::borrowck_errors::{BorrowckErrors, Origin};\n+use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n@@ -237,6 +238,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn report_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -273,6 +275,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n                 self.report_fnmut_error(\n                     mir,\n+                    upvars,\n                     infcx,\n                     mir_def_id,\n                     fr,\n@@ -284,6 +287,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => self.report_escaping_data_error(\n                 mir,\n+                upvars,\n                 infcx,\n                 mir_def_id,\n                 fr,\n@@ -294,6 +298,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             ),\n             _ => self.report_general_error(\n                 mir,\n+                upvars,\n                 infcx,\n                 mir_def_id,\n                 fr,\n@@ -353,6 +358,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_fnmut_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         _fr: RegionVid,\n@@ -377,7 +383,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         diag.span_label(span, message);\n \n-        match self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, &mut 1).unwrap().source {\n+        match self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_fr, &mut 1)\n+            .unwrap().source\n+        {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -415,6 +423,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_escaping_data_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -423,9 +432,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        let fr_name_and_span = self.get_var_name_and_span_for_region(infcx.tcx, mir, fr);\n+        let fr_name_and_span =\n+            self.get_var_name_and_span_for_region(infcx.tcx, mir, upvars, fr);\n         let outlived_fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, mir, outlived_fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, mir, upvars, outlived_fr);\n \n         let escapes_from = match self.universal_regions.defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n@@ -442,6 +452,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         {\n             return self.report_general_error(\n                 mir,\n+                upvars,\n                 infcx,\n                 mir_def_id,\n                 fr,\n@@ -504,6 +515,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_general_error(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -520,10 +532,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(infcx, mir, mir_def_id, fr, counter).unwrap();\n+        let fr_name = self.give_region_a_name(infcx, mir, upvars, mir_def_id, fr, counter).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n         let outlived_fr_name =\n-            self.give_region_a_name(infcx, mir, mir_def_id, outlived_fr, counter).unwrap();\n+            self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_fr, counter).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         let mir_def_name = if infcx.tcx.is_closure(mir_def_id) {\n@@ -656,6 +668,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn free_region_constraint_info(\n         &self,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         borrow_region: RegionVid,\n@@ -664,7 +677,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let (category, from_closure, span) =\n             self.best_blame_constraint(mir, borrow_region, |r| r == outlived_region);\n         let outlived_fr_name =\n-            self.give_region_a_name(infcx, mir, mir_def_id, outlived_region, &mut 1);\n+            self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_region, &mut 1);\n         (category, from_closure, span, outlived_fr_name)\n     }\n "}, {"sha": "680e7ce576af04ef6addfb05fb4e43869237da9e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -2,6 +2,7 @@ use std::fmt::{self, Display};\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ToRegionVid;\n+use crate::borrow_check::Upvar;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -144,6 +145,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -160,7 +162,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_upvars(\n-                    infcx.tcx, mir, fr, counter,\n+                    infcx.tcx, upvars, fr, counter,\n                 )\n             })\n             .or_else(|| {\n@@ -639,13 +641,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_anonymous_region_appears_in_upvars(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         fr: RegionVid,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n-            self.get_upvar_name_and_span_for_region(tcx, mir, upvar_index);\n+            self.get_upvar_name_and_span_for_region(tcx, upvars, upvar_index);\n         let region_name = self.synthesize_region_name(counter);\n \n         Some(RegionName {"}, {"sha": "d8f34233839b9796d77f437ff6a2fb7603a84235", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -1,5 +1,6 @@\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::ToRegionVid;\n+use crate::borrow_check::Upvar;\n use rustc::mir::{Local, Mir};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -11,6 +12,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n         debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n@@ -19,7 +21,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n         self.get_upvar_index_for_region(tcx, fr)\n             .map(|index| {\n-                let (name, span) = self.get_upvar_name_and_span_for_region(tcx, mir, index);\n+                let (name, span) =\n+                    self.get_upvar_name_and_span_for_region(tcx, upvars, index);\n                 (Some(name), span)\n             })\n             .or_else(|| {\n@@ -67,10 +70,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_upvar_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n-        let upvar_hir_id = mir.upvar_decls[upvar_index].var_hir_id.assert_crate_local();\n+        let upvar_hir_id = upvars[upvar_index].var_hir_id;\n         debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n \n         let upvar_name = tcx.hir().name_by_hir_id(upvar_hir_id);"}, {"sha": "9dd18ab76a5f2268a7d908e255afb2f1e694e148", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -4,6 +4,7 @@ use crate::borrow_check::nll::constraints::{ConstraintSccIndex, ConstraintSet, O\n use crate::borrow_check::nll::region_infer::values::{\n     PlaceholderIndices, RegionElement, ToElementIndex\n };\n+use crate::borrow_check::Upvar;\n use crate::borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use crate::borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n@@ -400,21 +401,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n         common::time_ext(\n             infcx.tcx.sess.time_extended(),\n             Some(infcx.tcx.sess),\n             &format!(\"solve_nll_region_constraints({:?})\", mir_def_id),\n-            || self.solve_inner(infcx, mir, mir_def_id, errors_buffer),\n+            || self.solve_inner(infcx, mir, upvars, mir_def_id, errors_buffer),\n         )\n     }\n \n     fn solve_inner<'gcx>(\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n@@ -442,6 +445,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.check_universal_regions(\n             infcx,\n             mir,\n+            upvars,\n             mir_def_id,\n             outlives_requirements.as_mut(),\n             errors_buffer,\n@@ -1102,6 +1106,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -1115,6 +1120,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_universal_region(\n                         infcx,\n                         mir,\n+                        upvars,\n                         mir_def_id,\n                         fr,\n                         &mut propagated_outlives_requirements,\n@@ -1145,6 +1151,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -1177,6 +1184,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 representative,\n                 infcx,\n                 mir,\n+                upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n@@ -1192,6 +1200,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 shorter_fr,\n                 infcx,\n                 mir,\n+                upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n@@ -1208,6 +1217,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         shorter_fr: RegionVid,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        upvars: &[Upvar],\n         mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -1265,7 +1275,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //\n         // Note: in this case, we use the unapproximated regions to report the\n         // error. This gives better error messages in some cases.\n-        self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        self.report_error(mir, upvars, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n         Some(ErrorReported)\n     }\n "}, {"sha": "d3cef46b4022d860d77cd9d4808a4d9fb530284c", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> DefiningTy<'tcx> {\n     /// Returns a list of all the upvar types for this MIR. If this is\n     /// not a closure or generator, there are no upvars, and hence it\n     /// will be an empty list. The order of types in this list will\n-    /// match up with the `upvar_decls` field of `Mir`.\n+    /// match up with the upvar order in the HIR, typesystem, and MIR.\n     pub fn upvar_tys(self, tcx: TyCtxt<'_, '_, 'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         match self {\n             DefiningTy::Closure(def_id, substs) => Either::Left(substs.upvar_tys(def_id, tcx)),"}, {"sha": "c58b570d8fc9fb74710378ef83a8338836cd8245", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -556,10 +556,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n                 // Not in a closure\n                 debug_assert!(\n-                    this.upvar_decls.len() > upvar_index.index(),\n+                    this.upvar_mutbls.len() > upvar_index.index(),\n                     \"Unexpected capture place\"\n                 );\n-                this.upvar_decls[upvar_index.index()].mutability\n+                this.upvar_mutbls[upvar_index.index()]\n             }\n             _ => bug!(\"Unexpected capture place\"),\n         };"}, {"sha": "5e15d98e246b7935ca9fefbfc0a14e3b959dca54", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -505,14 +505,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             UserTypeProjections::none(),\n             &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n                 if visibility_scope.is_none() {\n-                    visibility_scope =\n-                        Some(this.new_source_scope(scope_span, LintLevel::Inherited, None));\n                     // If we have lints, create a new source scope\n                     // that marks the lints for the locals. See the comment\n                     // on the `source_info` field for why this is needed.\n                     if lint_level.is_explicit() {\n                         scope = this.new_source_scope(scope_span, lint_level, None);\n                     }\n+                visibility_scope = Some(this.new_source_scope(scope_span,\n+                                                           LintLevel::Inherited,\n+                                                           None));\n                 }\n                 let source_info = SourceInfo { span, scope };\n                 let visibility_scope = visibility_scope.unwrap();"}, {"sha": "79e1d5daae1942ed92cb515eb1fcd5684da31287", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -375,7 +375,8 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     var_indices: HirIdMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n-    upvar_decls: Vec<UpvarDecl>,\n+    __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+    upvar_mutbls: Vec<Mutability>,\n     unit_temp: Option<Place<'tcx>>,\n \n     /// Cached block with the `RESUME` terminator; this is created\n@@ -625,11 +626,12 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let fn_def_id = tcx_hir.local_def_id_from_hir_id(fn_id);\n \n     // Gather the upvars of a closure, if any.\n+    let mut upvar_mutbls = vec![];\n     // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n     // closure and we stored in a map called upvar_list in TypeckTables indexed\n     // with the closure's DefId. Here, we run through that vec of UpvarIds for\n     // the given closure and use the necessary information to create UpvarDecl.\n-    let upvar_decls: Vec<_> = hir_tables\n+    let upvar_debuginfo: Vec<_> = hir_tables\n         .upvar_list\n         .get(&fn_def_id)\n         .into_iter()\n@@ -642,27 +644,27 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 ty::UpvarCapture::ByValue => false,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n-            let mut decl = UpvarDecl {\n+            let mut debuginfo = UpvarDebuginfo {\n                 debug_name: keywords::Invalid.name(),\n-                var_hir_id: ClearCrossCrate::Set(var_hir_id),\n                 by_ref,\n-                mutability: Mutability::Not,\n             };\n+            let mut mutability = Mutability::Not;\n             if let Some(Node::Binding(pat)) = tcx_hir.find(var_node_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n-                    decl.debug_name = ident.name;\n+                    debuginfo.debug_name = ident.name;\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n                         if bm == ty::BindByValue(hir::MutMutable) {\n-                            decl.mutability = Mutability::Mut;\n+                            mutability = Mutability::Mut;\n                         } else {\n-                            decl.mutability = Mutability::Not;\n+                            mutability = Mutability::Not;\n                         }\n                     } else {\n                         tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                     }\n                 }\n             }\n-            decl\n+            upvar_mutbls.push(mutability);\n+            debuginfo\n         })\n         .collect();\n \n@@ -672,7 +674,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         safety,\n         return_ty,\n         return_ty_span,\n-        upvar_decls);\n+        upvar_debuginfo,\n+        upvar_mutbls);\n \n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,\n@@ -734,7 +737,7 @@ fn construct_const<'a, 'gcx, 'tcx>(\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir().body_owner(body_id);\n     let span = tcx.hir().span(owner_id);\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, ty_span,vec![]);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, ty_span, vec![], vec![]);\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n@@ -762,7 +765,7 @@ fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let owner_id = hir.tcx().hir().body_owner(body_id);\n     let span = hir.tcx().hir().span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, vec![]);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, vec![], vec![]);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     builder.finish(None)\n@@ -775,7 +778,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n            safety: Safety,\n            return_ty: Ty<'tcx>,\n            return_span: Span,\n-           upvar_decls: Vec<UpvarDecl>)\n+           __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n+           upvar_mutbls: Vec<Mutability>)\n            -> Builder<'a, 'gcx, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n@@ -797,7 +801,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 1,\n             ),\n             canonical_user_type_annotations: IndexVec::new(),\n-            upvar_decls,\n+            __upvar_debuginfo_codegen_only_do_not_use,\n+            upvar_mutbls,\n             var_indices: Default::default(),\n             unit_temp: None,\n             cached_resume_block: None,\n@@ -832,7 +837,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.local_decls,\n             self.canonical_user_type_annotations,\n             self.arg_count,\n-            self.upvar_decls,\n+            self.__upvar_debuginfo_codegen_only_do_not_use,\n             self.fn_span,\n             self.hir.control_flow_destroyed(),\n         )"}, {"sha": "bd6f005e8736c992de7605eb6a60481934f47a10", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -3,6 +3,7 @@ use std::hash::Hash;\n use std::ops::RangeInclusive;\n \n use syntax_pos::symbol::Symbol;\n+use rustc::hir;\n use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n@@ -165,13 +166,28 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n         match layout.ty.sty {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                if let Some(upvar) = self.ecx.tcx.optimized_mir(def_id).upvar_decls.get(field) {\n-                    PathElem::ClosureVar(upvar.debug_name)\n-                } else {\n-                    // Sometimes the index is beyond the number of freevars (seen\n-                    // for a generator).\n-                    PathElem::ClosureVar(Symbol::intern(&field.to_string()))\n+                let mut name = None;\n+                if def_id.is_local() {\n+                    let tables = self.ecx.tcx.typeck_tables_of(def_id);\n+                    if let Some(upvars) = tables.upvar_list.get(&def_id) {\n+                        // Sometimes the index is beyond the number of freevars (seen\n+                        // for a generator).\n+                        if let Some(upvar_id) = upvars.get(field) {\n+                            let var_hir_id = upvar_id.var_path.hir_id;\n+                            let var_node_id = self.ecx.tcx.hir().hir_to_node_id(var_hir_id);\n+                            if let hir::Node::Binding(pat) = self.ecx.tcx.hir().get(var_node_id) {\n+                                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                                    name = Some(ident.name);\n+                                }\n+                            }\n+                        }\n+                    }\n                 }\n+\n+                PathElem::ClosureVar(name.unwrap_or_else(|| {\n+                    // Fall back to showing the field index.\n+                    Symbol::intern(&field.to_string())\n+                }))\n             }\n \n             // tuples"}, {"sha": "2b909feb9603f0c675745ba02383c09610a5421a", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -490,7 +490,7 @@ fn locals_live_across_suspend_points(\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             source: MirSource<'tcx>,\n-                            upvars: Vec<Ty<'tcx>>,\n+                            upvars: &Vec<Ty<'tcx>>,\n                             interior: Ty<'tcx>,\n                             movable: bool,\n                             mir: &mut Mir<'tcx>)\n@@ -505,7 +505,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                                             movable);\n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n-    let allowed_upvars = tcx.erase_regions(&upvars);\n+    let allowed_upvars = tcx.erase_regions(upvars);\n     let allowed = match interior.sty {\n         ty::GeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n         _ => bug!(),\n@@ -528,7 +528,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let upvar_len = mir.upvar_decls.len();\n+    let upvar_len = upvars.len();\n     let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), mir.span);\n \n     // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n@@ -917,12 +917,12 @@ impl MirPass for StateTransform {\n         let (remap, layout, storage_liveness) = compute_layout(\n             tcx,\n             source,\n-            upvars,\n+            &upvars,\n             interior,\n             movable,\n             mir);\n \n-        let state_field = mir.upvar_decls.len();\n+        let state_field = upvars.len();\n \n         // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`."}, {"sha": "e96a40ad2f036f1be0a4180a45d9773ef8869c66", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -222,10 +222,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         debug!(\"should_inline({:?})\", callsite);\n         let tcx = self.tcx;\n \n-        // Don't inline closures that have captures\n+        // Don't inline closures that have capture debuginfo\n         // FIXME: Handle closures better\n-        if callee_mir.upvar_decls.len() > 0 {\n-            debug!(\"    upvar decls present - not inlining\");\n+        if callee_mir.__upvar_debuginfo_codegen_only_do_not_use.len() > 0 {\n+            debug!(\"    upvar debuginfo present - not inlining\");\n             return false;\n         }\n "}, {"sha": "1f55a728f9c720c01a6bd27d9f330791cba5f148", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 52, "deletions": 74, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -461,9 +461,7 @@ fn comment(tcx: TyCtxt<'_, '_, '_>, SourceInfo { span, scope }: SourceInfo) -> S\n     )\n }\n \n-/// Prints user-defined variables in a scope tree.\n-///\n-/// Returns the total number of variables printed.\n+/// Prints local variables in a scope tree.\n fn write_scope_tree(\n     tcx: TyCtxt<'_, '_, '_>,\n     mir: &Mir<'_>,\n@@ -474,57 +472,64 @@ fn write_scope_tree(\n ) -> io::Result<()> {\n     let indent = depth * INDENT.len();\n \n+    // Local variable types (including the user's name in a comment).\n+    for (local, local_decl) in mir.local_decls.iter_enumerated() {\n+        if (1..mir.arg_count+1).contains(&local.index()) {\n+            // Skip over argument locals, they're printed in the signature.\n+            continue;\n+        }\n+\n+        if local_decl.source_info.scope != parent {\n+            // Not declared in this scope.\n+            continue;\n+        }\n+\n+        let mut_str = if local_decl.mutability == Mutability::Mut {\n+            \"mut \"\n+        } else {\n+            \"\"\n+        };\n+\n+        let mut indented_decl = format!(\n+            \"{0:1$}let {2}{3:?}: {4:?}\",\n+            INDENT,\n+            indent,\n+            mut_str,\n+            local,\n+            local_decl.ty\n+        );\n+        for user_ty in local_decl.user_ty.projections() {\n+            write!(indented_decl, \" as {:?}\", user_ty).unwrap();\n+        }\n+        indented_decl.push_str(\";\");\n+\n+        let local_name = if local == RETURN_PLACE {\n+            format!(\" return place\")\n+        } else if let Some(name) = local_decl.name {\n+            format!(\" \\\"{}\\\"\", name)\n+        } else {\n+            String::new()\n+        };\n+\n+        writeln!(\n+            w,\n+            \"{0:1$} //{2} in {3}\",\n+            indented_decl,\n+            ALIGN,\n+            local_name,\n+            comment(tcx, local_decl.source_info),\n+        )?;\n+    }\n+\n     let children = match scope_tree.get(&parent) {\n-        Some(children) => children,\n+        Some(childs) => childs,\n         None => return Ok(()),\n     };\n \n     for &child in children {\n-        let data = &mir.source_scopes[child];\n-        assert_eq!(data.parent_scope, Some(parent));\n+        assert_eq!(mir.source_scopes[child].parent_scope, Some(parent));\n         writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n-\n-        // User variable types (including the user's name in a comment).\n-        for local in mir.vars_iter() {\n-            let var = &mir.local_decls[local];\n-            let (name, source_info) = if var.source_info.scope == child {\n-                (var.name.unwrap(), var.source_info)\n-            } else {\n-                // Not a variable or not declared in this scope.\n-                continue;\n-            };\n-\n-            let mut_str = if var.mutability == Mutability::Mut {\n-                \"mut \"\n-            } else {\n-                \"\"\n-            };\n-\n-            let indent = indent + INDENT.len();\n-            let mut indented_var = format!(\n-                \"{0:1$}let {2}{3:?}: {4:?}\",\n-                INDENT,\n-                indent,\n-                mut_str,\n-                local,\n-                var.ty\n-            );\n-            for user_ty in var.user_ty.projections() {\n-                write!(indented_var, \" as {:?}\", user_ty).unwrap();\n-            }\n-            indented_var.push_str(\";\");\n-            writeln!(\n-                w,\n-                \"{0:1$} // \\\"{2}\\\" in {3}\",\n-                indented_var,\n-                ALIGN,\n-                name,\n-                comment(tcx, source_info)\n-            )?;\n-        }\n-\n         write_scope_tree(tcx, mir, scope_tree, w, child, depth + 1)?;\n-\n         writeln!(w, \"{0:1$}}}\", \"\", depth * INDENT.len())?;\n     }\n \n@@ -556,19 +561,8 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n         }\n     }\n \n-    // Print return place\n-    let indented_retptr = format!(\"{}let mut {:?}: {};\",\n-                                  INDENT,\n-                                  RETURN_PLACE,\n-                                  mir.local_decls[RETURN_PLACE].ty);\n-    writeln!(w, \"{0:1$} // return place\",\n-             indented_retptr,\n-             ALIGN)?;\n-\n     write_scope_tree(tcx, mir, &scope_tree, w, OUTERMOST_SOURCE_SCOPE, 1)?;\n \n-    write_temp_decls(mir, w)?;\n-\n     // Add an empty line before the first block is printed.\n     writeln!(w, \"\")?;\n \n@@ -632,22 +626,6 @@ fn write_mir_sig(\n     Ok(())\n }\n \n-fn write_temp_decls(mir: &Mir<'_>, w: &mut dyn Write) -> io::Result<()> {\n-    // Compiler-introduced temporary types.\n-    for temp in mir.temps_iter() {\n-        writeln!(\n-            w,\n-            \"{}let {}{:?}: {};\",\n-            INDENT,\n-            if mir.local_decls[temp].mutability == Mutability::Mut {\"mut \"} else {\"\"},\n-            temp,\n-            mir.local_decls[temp].ty\n-        )?;\n-    }\n-\n-    Ok(())\n-}\n-\n fn write_user_type_annotations(mir: &Mir<'_>, w: &mut dyn Write) -> io::Result<()> {\n     if !mir.user_type_annotations.is_empty() {\n         writeln!(w, \"| User Type Annotations\")?;"}, {"sha": "d4852db6d475e39736104ebc1de375729077b62e", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -22,15 +22,14 @@ impl Drop for S {\n // END RUST SOURCE\n // START rustc.main.ElaborateDrops.before.mir\n //     let mut _0: ();\n+//     let mut _2: std::boxed::Box<S>;\n+//     let mut _3: ();\n+//     let mut _4: std::boxed::Box<S>;\n //     scope 1 {\n+//         let _1: std::boxed::Box<S>;\n //     }\n //     scope 2 {\n-//         let _1: std::boxed::Box<S>;\n //     }\n-//     let mut _2: std::boxed::Box<S>;\n-//     let mut _3: ();\n-//     let mut _4: std::boxed::Box<S>;\n-//\n //     bb0: {\n //         StorageLive(_1);\n //         StorageLive(_2);"}, {"sha": "023440af0eb10d014549346c9008271b594b7dbe", "filename": "src/test/mir-opt/issue-41110.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41110.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -29,27 +29,28 @@ impl S {\n // END RUST SOURCE\n // START rustc.main.ElaborateDrops.after.mir\n //    let mut _0: ();\n-//    scope 1 {\n-//    }\n-//    scope 2 {\n-//        let _1: ();\n-//    }\n //    let mut _2: S;\n //    let mut _3: S;\n //    let mut _4: S;\n //    let mut _5: bool;\n+//    scope 1 {\n+//        let _1: ();\n+//    }\n+//    scope 2 {\n+//    }\n+//    ...\n //    bb0: {\n // END rustc.main.ElaborateDrops.after.mir\n // START rustc.test.ElaborateDrops.after.mir\n //    let mut _0: ();\n-//    ...\n-//    let mut _2: S;\n-//    ...\n-//    let _1: S;\n-//    ...\n //    let mut _3: ();\n //    let mut _4: S;\n //    let mut _5: S;\n //    let mut _6: bool;\n+//    ...\n+//    let _1: S;\n+//    ...\n+//    let mut _2: S;\n+//    ...\n //    bb0: {\n // END rustc.test.ElaborateDrops.after.mir"}, {"sha": "29446d2ecc23e5d9180ee6f47957cbde30d42977", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -17,16 +17,16 @@ fn main() {\n // START rustc.main.mir_map.0.mir\n // fn main() -> (){\n //     let mut _0: ();\n-//     scope 1 {\n-//     }\n-//     scope 2 {\n-//         let _2: i32;\n-//     }\n //     let mut _1: ();\n //     let mut _3: bool;\n //     let mut _4: !;\n //     let mut _5: ();\n //     let mut _6: &i32;\n+//     scope 1 {\n+//         let _2: i32;\n+//     }\n+//     scope 2 {\n+//     }\n //     bb0: {\n //         goto -> bb1;\n //     }"}, {"sha": "bb27461bb1e0fc1570d7b6e2c36fc9871f6f99d4", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -27,10 +27,10 @@ fn main() {\n // | '_#4r    | U0 | {bb2[4..=5], bb3[0..=1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n-// let _6: &'_#4r usize;\n-// ...\n // let _2: &'_#3r usize;\n // ...\n+// let _6: &'_#4r usize;\n+// ...\n // _2 = &'_#2r _1[_3];\n // ...\n // _6 = _2;"}, {"sha": "7e8c58e64c28d60d2689682e094f927291c0da75", "filename": "src/test/mir-opt/packed-struct-drop-aligned.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f82b5b8828202d53be0d0e11504094bbcf28806/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fpacked-struct-drop-aligned.rs?ref=5f82b5b8828202d53be0d0e11504094bbcf28806", "patch": "@@ -18,16 +18,16 @@ impl Drop for Droppy {\n // START rustc.main.EraseRegions.before.mir\n // fn main() -> () {\n //     let mut _0: ();\n-//     scope 1 {\n-//     }\n-//     scope 2 {\n-//         let mut _1: Packed;\n-//     }\n //     let mut _2: Aligned;\n //     let mut _3: Droppy;\n //     let mut _4: Aligned;\n //     let mut _5: Droppy;\n //     let mut _6: Aligned;\n+//     scope 1 {\n+//         let mut _1: Packed;\n+//     }\n+//     scope 2 {\n+//     }\n //\n //     bb0: {\n //         StorageLive(_1);"}]}