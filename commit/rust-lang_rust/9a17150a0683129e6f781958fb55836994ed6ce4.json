{"sha": "9a17150a0683129e6f781958fb55836994ed6ce4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMTcxNTBhMDY4MzEyOWU2Zjc4MTk1OGZiNTU4MzY5OTRlZDZjZTQ=", "commit": {"author": {"name": "Laura Peskin", "email": "laura.peskin@gmail.com", "date": "2017-09-19T00:10:33Z"}, "committer": {"name": "Laura Peskin", "email": "laura.peskin@gmail.com", "date": "2017-09-24T19:40:17Z"}, "message": "refactor, add spans to warnings, add tests", "tree": {"sha": "bad99be3f99a9ae6e272548ce1dd402792343307", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bad99be3f99a9ae6e272548ce1dd402792343307"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a17150a0683129e6f781958fb55836994ed6ce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a17150a0683129e6f781958fb55836994ed6ce4", "html_url": "https://github.com/rust-lang/rust/commit/9a17150a0683129e6f781958fb55836994ed6ce4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a17150a0683129e6f781958fb55836994ed6ce4/comments", "author": {"login": "lpesk", "id": 7589231, "node_id": "MDQ6VXNlcjc1ODkyMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/7589231?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lpesk", "html_url": "https://github.com/lpesk", "followers_url": "https://api.github.com/users/lpesk/followers", "following_url": "https://api.github.com/users/lpesk/following{/other_user}", "gists_url": "https://api.github.com/users/lpesk/gists{/gist_id}", "starred_url": "https://api.github.com/users/lpesk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lpesk/subscriptions", "organizations_url": "https://api.github.com/users/lpesk/orgs", "repos_url": "https://api.github.com/users/lpesk/repos", "events_url": "https://api.github.com/users/lpesk/events{/privacy}", "received_events_url": "https://api.github.com/users/lpesk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lpesk", "id": 7589231, "node_id": "MDQ6VXNlcjc1ODkyMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/7589231?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lpesk", "html_url": "https://github.com/lpesk", "followers_url": "https://api.github.com/users/lpesk/followers", "following_url": "https://api.github.com/users/lpesk/following{/other_user}", "gists_url": "https://api.github.com/users/lpesk/gists{/gist_id}", "starred_url": "https://api.github.com/users/lpesk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lpesk/subscriptions", "organizations_url": "https://api.github.com/users/lpesk/orgs", "repos_url": "https://api.github.com/users/lpesk/repos", "events_url": "https://api.github.com/users/lpesk/events{/privacy}", "received_events_url": "https://api.github.com/users/lpesk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0eff10a7c3837e447f73864fd61478c7bfbd591", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0eff10a7c3837e447f73864fd61478c7bfbd591", "html_url": "https://github.com/rust-lang/rust/commit/d0eff10a7c3837e447f73864fd61478c7bfbd591"}], "stats": {"total": 115, "additions": 76, "deletions": 39}, "files": [{"sha": "522e0ae79c02f3030930e70292e7d9f512c6bdfb", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9a17150a0683129e6f781958fb55836994ed6ce4/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a17150a0683129e6f781958fb55836994ed6ce4/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=9a17150a0683129e6f781958fb55836994ed6ce4", "patch": "@@ -7,8 +7,9 @@ use rustc::hir::map::Node::{NodeBlock, NodeExpr, NodeStmt};\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n-use rustc::middle::region::CodeExtent;\n+// use rustc::middle::region::CodeExtent;\n use rustc::middle::expr_use_visitor::*;\n+use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::cmt;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::{Subst, Substs};\n@@ -1308,31 +1309,35 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     }\n }\n \n-// TODO: clippy builds, but the `mutate` method of `Delegate` is never called when compiling `tests/run-pass/mut_range_bound_tmp.rs`. what's wrong? \n-\n struct MutateDelegate<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    node_id: NodeId,\n-    was_mutated: bool\n+    node_id_low: Option<NodeId>,\n+    node_id_high: Option<NodeId>,\n+    span_low: Option<Span>,\n+    span_high: Option<Span>,\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for MutateDelegate<'a, 'tcx> {\n-    fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n+    fn consume(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: ConsumeMode) {\n     }\n   \n-    fn matched_pat(&mut self, matched_pat: &Pat, cmt: cmt<'tcx>, mode: MatchMode) {\n+    fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {\n     }\n \n-    fn consume_pat(&mut self, consume_pat: &Pat, cmt: cmt<'tcx>, mode: ConsumeMode) {\n+    fn consume_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: ConsumeMode) {\n     }\n \n     fn borrow(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: ty::Region, _: ty::BorrowKind, _: LoanCause) {        \n     }\n \n-    fn mutate(&mut self, assignment_id: NodeId, sp: Span, _: cmt<'tcx>, _: MutateMode) {\n-        self.cx.sess().span_note_without_error(sp, \"mutates!\");\n-        if assignment_id == self.node_id {\n-            self.was_mutated = true;\n+    fn mutate(&mut self, _: NodeId, sp: Span, cmt: cmt<'tcx>, _: MutateMode) {\n+        if let Categorization::Local(id) = cmt.cat {\n+            if Some(id) == self.node_id_low {\n+                self.span_low = Some(sp)\n+            }\n+            if Some(id) == self.node_id_high {\n+                self.span_high = Some(sp)\n+            }\n         }\n     }\n \n@@ -1341,31 +1346,34 @@ impl<'a, 'tcx> Delegate<'tcx> for MutateDelegate<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutateDelegate<'a, 'tcx> {\n-    fn bound_was_mutated(&self) -> bool {\n-        self.was_mutated\n+    fn mutation_span(&self) -> (Option<Span>, Option<Span>) {\n+        (self.span_low, self.span_high)\n     }\n }\n \n fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr,  expr: &Expr) {\n     if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(arg) {\n-        let bounds = vec![start, end];\n-        for bound in &bounds {\n-            if check_for_mutation(cx, body, bound) {\n-                span_lint(cx, MUT_RANGE_BOUND, expr.span, \"you are looping over a range where at least one bound was defined as a mutable variable. keep in mind that mutating this variable inside the loop will not affect the range\");   \n-                return;\n-            }\n+        let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n+        if mut_ids[0].is_some() || mut_ids[1].is_some() {\n+            let (span_low, span_high) = check_for_mutation(cx, body, mut_ids);\n+            mut_warn_with_span(cx, span_low);\n+            mut_warn_with_span(cx, span_high);\n         }\n     }\n }\n \n-fn check_for_mutation(cx: &LateContext, body: &Expr, bound: &Expr) -> bool {\n+fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n+    if let Some(sp) = span {\n+        span_lint(cx, MUT_RANGE_BOUND, sp, \"attempt to mutate range bound within loop; note that the range of the loop is unchanged\");\n+    }\n+}\n+\n+fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n     if_let_chain! {[\n         let ExprPath(ref qpath) = bound.node,\n         let QPath::Resolved(None, ref path) = *qpath,\n     ], {\n         let def = cx.tables.qpath_def(qpath, bound.hir_id);\n-\n-                    cx.sess().span_note_without_error(body.span, \"loop\");\n         match def {\n             Def::Local(..) | Def::Upvar(..) => {\n                 let def_id = def.def_id();\n@@ -1375,18 +1383,35 @@ fn check_for_mutation(cx: &LateContext, body: &Expr, bound: &Expr) -> bool {\n                     let map::Node::NodeBinding(pat) = node_str,\n                     let PatKind::Binding(bind_ann, _, _, _) = pat.node,\n                     let BindingAnnotation::Mutable = bind_ann,\n-                    \n-                ], {\n-                    let mut delegate = MutateDelegate { cx: cx, node_id: node_id, was_mutated: false };\n-                    let region_maps = &cx.tcx.region_maps(def_id); // is this the correct argument?\n-                    ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_maps, cx.tables).walk_expr(body);\n-                    return delegate.bound_was_mutated();\n+                ], { \n+                    return Some(node_id); \n                 }}\n-            },\n-            _ => (),\n-        }}\n+            }\n+            _ => ()\n+        }\n+    }}\n+    return None;\n+}\n+\n+fn check_for_mutation(cx: &LateContext, body: &Expr, bound_ids: Vec<Option<NodeId>>) -> (Option<Span>, Option<Span>) {\n+    let mut delegate = MutateDelegate { cx: cx, node_id_low: bound_ids[0], node_id_high: bound_ids[1], span_low: None, span_high: None };\n+    if let Some(id) = get_id_if_some(&bound_ids) {\n+        let def_id = cx.tcx.hir.local_def_id(id);\n+        let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n+        ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_scope_tree, cx.tables).walk_expr(body);\n+        return delegate.mutation_span();\n+    } else {\n+        return (None, None);\n+    }\n+}\n+\n+fn get_id_if_some(bound_ids: &Vec<Option<NodeId>>) -> Option<NodeId> {\n+    for id in bound_ids.into_iter() {\n+        if id.is_some() {\n+            return *id;\n+        }\n     }\n-    return false;\n+    return None;\n }\n \n /// Return true if the pattern is a `PatWild` or an ident prefixed with `'_'`."}, {"sha": "c13c0c0ae8538b9092932256468a9497bc175bae", "filename": "tests/run-pass/mut_range_bound_tmp.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a17150a0683129e6f781958fb55836994ed6ce4/tests%2Frun-pass%2Fmut_range_bound_tmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a17150a0683129e6f781958fb55836994ed6ce4/tests%2Frun-pass%2Fmut_range_bound_tmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmut_range_bound_tmp.rs?ref=9a17150a0683129e6f781958fb55836994ed6ce4", "patch": "@@ -7,28 +7,40 @@ fn main() {\n     mut_range_bound_upper();\n     mut_range_bound_lower();\n     mut_range_bound_both();\n+    mut_range_bound_no_mutation();\n     immut_range_bound();\n }\n \n fn mut_range_bound_upper() {\n     let mut m = 4;\n-    for i in 0..m { \n-\n-        m = 5;\n-        continue; } // WARNING the range upper bound is mutable\n+    for i in 0..m { m = 5; } // warning    \n }\n \n fn mut_range_bound_lower() {\n     let mut m = 4;\n-    for i in m..10 { continue; } // WARNING the range lower bound is mutable\n+    for i in m..10 { m *= 2; } // warning\n }\n \n fn mut_range_bound_both() {\n     let mut m = 4;\n     let mut n = 6;\n-    for i in m..n { continue; } // WARNING both bounds are mutable (should get just one warning for this)\n+    for i in m..n { m = 5; n = 7; } // warning (1 for each mutated bound)\n+}\n+\n+fn mut_range_bound_no_mutation() {\n+    let mut m = 4;\n+    for i in 0..m { continue; } // no warning\n }\n \n+fn mut_borrow_range_bound() {\n+    let mut m = 4;\n+    for i in 0..m {\n+        let n = &mut m;\n+        *n += 1;\n+    }\n+}\n+\n+\n fn immut_range_bound() {\n     let m = 4;\n     for i in 0..m { continue; } // no warning"}]}