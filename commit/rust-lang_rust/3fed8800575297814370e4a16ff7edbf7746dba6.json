{"sha": "3fed8800575297814370e4a16ff7edbf7746dba6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZWQ4ODAwNTc1Mjk3ODE0MzcwZTRhMTZmZjdlZGJmNzc0NmRiYTY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-11-11T20:43:57Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-16T11:04:34Z"}, "message": "[WIP] Set local DW_AT_location", "tree": {"sha": "03c595b7ecffa7d6e34ddf4cb04d3627c072e3b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03c595b7ecffa7d6e34ddf4cb04d3627c072e3b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fed8800575297814370e4a16ff7edbf7746dba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fed8800575297814370e4a16ff7edbf7746dba6", "html_url": "https://github.com/rust-lang/rust/commit/3fed8800575297814370e4a16ff7edbf7746dba6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fed8800575297814370e4a16ff7edbf7746dba6/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21f0dfd014fc5996b6f88b9565656f63b2f65c99", "url": "https://api.github.com/repos/rust-lang/rust/commits/21f0dfd014fc5996b6f88b9565656f63b2f65c99", "html_url": "https://github.com/rust-lang/rust/commit/21f0dfd014fc5996b6f88b9565656f63b2f65c99"}], "stats": {"total": 128, "additions": 122, "deletions": 6}, "files": [{"sha": "7530c7c21e1ecf8f8de479227edfb93c1541f76a", "filename": "src/debuginfo.rs", "status": "modified", "additions": 122, "deletions": 6, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/3fed8800575297814370e4a16ff7edbf7746dba6/src%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fed8800575297814370e4a16ff7edbf7746dba6/src%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo.rs?ref=3fed8800575297814370e4a16ff7edbf7746dba6", "patch": "@@ -6,11 +6,15 @@ use std::marker::PhantomData;\n \n use syntax::source_map::FileName;\n \n+use cranelift::codegen::ir::{StackSlots, ValueLoc};\n+use cranelift::codegen::isa::RegUnit;\n+\n use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, EndianVec, FileId, LineProgram, LineString,\n-    LineStringTable, Range, RangeList, Result, Sections, UnitEntryId, Writer,\n+    self, Address, AttributeValue, DwarfUnit, EndianVec, Expression, FileId, LineProgram,\n+    LineString, LineStringTable, Location, LocationList, Range, RangeList, Result, Sections,\n+    UnitEntryId, Writer,\n };\n-use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, SectionId};\n+use gimli::{Encoding, Format, LineEncoding, Register, RunTimeEndian, SectionId, X86_64};\n \n fn target_endian(tcx: TyCtxt) -> RunTimeEndian {\n     use rustc::ty::layout::Endian;\n@@ -380,9 +384,9 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n                     .chain(\n                         value_loc_ranges\n                             .iter()\n-                            .map(|val_loc_range| Range::OffsetPair {\n-                                begin: u64::from(val_loc_range.start),\n-                                end: u64::from(val_loc_range.end),\n+                            .map(|value_loc_range| Range::OffsetPair {\n+                                begin: u64::from(value_loc_range.start),\n+                                end: u64::from(value_loc_range.end),\n                             }),\n                     )\n                     .collect(),\n@@ -415,6 +419,34 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n                     gimli::DW_AT_type,\n                     AttributeValue::ThisUnitEntryRef(local_type),\n                 );\n+\n+\n+                let loc_list = LocationList(\n+                    Some(Location::BaseAddress {\n+                        address: Address::Symbol {\n+                            symbol: self.symbol,\n+                            addend: 0,\n+                        },\n+                    })\n+                    .into_iter()\n+                    .chain(\n+                        value_loc_ranges\n+                            .iter()\n+                            .map(|value_loc_range| Location::OffsetPair {\n+                                begin: u64::from(value_loc_range.start),\n+                                end: u64::from(value_loc_range.end),\n+                                data: Expression(translate_loc(value_loc_range.loc, &context.func.stack_slots).unwrap()),\n+                            }),\n+                    )\n+                    .collect(),\n+                );\n+                let loc_list_id = self.debug_context.dwarf.unit.locations.add(loc_list);\n+\n+                let var_entry = self.debug_context.dwarf.unit.get_mut(var_id);\n+                var_entry.set(\n+                    gimli::DW_AT_location,\n+                    AttributeValue::LocationListRef(loc_list_id),\n+                );\n             }\n         }\n \n@@ -510,3 +542,87 @@ impl Writer for WriterRelocate {\n         self.write_udata_at(offset, 0, size)\n     }\n }\n+\n+\n+\n+\n+\n+\n+// Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n+\n+fn map_reg(reg: RegUnit) -> Register {\n+    static mut REG_X86_MAP: Option<HashMap<RegUnit, Register>> = None;\n+    // FIXME lazy initialization?\n+    unsafe {\n+        if REG_X86_MAP.is_none() {\n+            REG_X86_MAP = Some(HashMap::new());\n+        }\n+        if let Some(val) = REG_X86_MAP.as_mut().unwrap().get(&reg) {\n+            return *val;\n+        }\n+        let result = match reg {\n+            0 => X86_64::RAX,\n+            1 => X86_64::RCX,\n+            2 => X86_64::RDX,\n+            3 => X86_64::RBX,\n+            4 => X86_64::RSP,\n+            5 => X86_64::RBP,\n+            6 => X86_64::RSI,\n+            7 => X86_64::RDI,\n+            8 => X86_64::R8,\n+            9 => X86_64::R9,\n+            10 => X86_64::R10,\n+            11 => X86_64::R11,\n+            12 => X86_64::R12,\n+            13 => X86_64::R13,\n+            14 => X86_64::R14,\n+            15 => X86_64::R15,\n+            16 => X86_64::XMM0,\n+            17 => X86_64::XMM1,\n+            18 => X86_64::XMM2,\n+            19 => X86_64::XMM3,\n+            20 => X86_64::XMM4,\n+            21 => X86_64::XMM5,\n+            22 => X86_64::XMM6,\n+            23 => X86_64::XMM7,\n+            24 => X86_64::XMM8,\n+            25 => X86_64::XMM9,\n+            26 => X86_64::XMM10,\n+            27 => X86_64::XMM11,\n+            28 => X86_64::XMM12,\n+            29 => X86_64::XMM13,\n+            30 => X86_64::XMM14,\n+            31 => X86_64::XMM15,\n+            _ => panic!(\"unknown x86_64 register {}\", reg),\n+        };\n+        REG_X86_MAP.as_mut().unwrap().insert(reg, result);\n+        result\n+    }\n+}\n+\n+fn translate_loc(loc: ValueLoc, stack_slots: &StackSlots) -> Option<Vec<u8>> {\n+    match loc {\n+        ValueLoc::Reg(reg) => {\n+            let machine_reg = map_reg(reg).0 as u8;\n+            assert!(machine_reg <= 32); // FIXME\n+            Some(vec![gimli::constants::DW_OP_reg0.0 + machine_reg])\n+        }\n+        ValueLoc::Stack(ss) => {\n+            if let Some(ss_offset) = stack_slots[ss].offset {\n+                let endian = gimli::RunTimeEndian::Little;\n+                let mut writer = write::EndianVec::new(endian);\n+                writer\n+                    .write_u8(gimli::constants::DW_OP_breg0.0 + X86_64::RBP.0 as u8)\n+                    .expect(\"bp wr\");\n+                writer.write_sleb128(ss_offset as i64 + 16).expect(\"ss wr\");\n+                writer\n+                    .write_u8(gimli::constants::DW_OP_deref.0 as u8)\n+                    .expect(\"bp wr\");\n+                let buf = writer.into_vec();\n+                return Some(buf);\n+            }\n+            None\n+        }\n+        _ => None,\n+    }\n+}"}]}