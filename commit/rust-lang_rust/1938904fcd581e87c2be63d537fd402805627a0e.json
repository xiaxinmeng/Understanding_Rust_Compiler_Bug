{"sha": "1938904fcd581e87c2be63d537fd402805627a0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5Mzg5MDRmY2Q1ODFlODdjMmJlNjNkNTM3ZmQ0MDI4MDU2MjdhMGU=", "commit": {"author": {"name": "Owen Sanchez", "email": "pengowen816@gmail.com", "date": "2017-02-05T03:12:55Z"}, "committer": {"name": "Owen Sanchez", "email": "pengowen816@gmail.com", "date": "2017-02-11T01:12:32Z"}, "message": "Change large_enum_variant to lint against size differences rather than size", "tree": {"sha": "a8d5dc67c19d521f30779b6c01a95c95ee1a6dd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8d5dc67c19d521f30779b6c01a95c95ee1a6dd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1938904fcd581e87c2be63d537fd402805627a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1938904fcd581e87c2be63d537fd402805627a0e", "html_url": "https://github.com/rust-lang/rust/commit/1938904fcd581e87c2be63d537fd402805627a0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1938904fcd581e87c2be63d537fd402805627a0e/comments", "author": {"login": "pengowen123", "id": 12902948, "node_id": "MDQ6VXNlcjEyOTAyOTQ4", "avatar_url": "https://avatars.githubusercontent.com/u/12902948?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pengowen123", "html_url": "https://github.com/pengowen123", "followers_url": "https://api.github.com/users/pengowen123/followers", "following_url": "https://api.github.com/users/pengowen123/following{/other_user}", "gists_url": "https://api.github.com/users/pengowen123/gists{/gist_id}", "starred_url": "https://api.github.com/users/pengowen123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pengowen123/subscriptions", "organizations_url": "https://api.github.com/users/pengowen123/orgs", "repos_url": "https://api.github.com/users/pengowen123/repos", "events_url": "https://api.github.com/users/pengowen123/events{/privacy}", "received_events_url": "https://api.github.com/users/pengowen123/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pengowen123", "id": 12902948, "node_id": "MDQ6VXNlcjEyOTAyOTQ4", "avatar_url": "https://avatars.githubusercontent.com/u/12902948?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pengowen123", "html_url": "https://github.com/pengowen123", "followers_url": "https://api.github.com/users/pengowen123/followers", "following_url": "https://api.github.com/users/pengowen123/following{/other_user}", "gists_url": "https://api.github.com/users/pengowen123/gists{/gist_id}", "starred_url": "https://api.github.com/users/pengowen123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pengowen123/subscriptions", "organizations_url": "https://api.github.com/users/pengowen123/orgs", "repos_url": "https://api.github.com/users/pengowen123/repos", "events_url": "https://api.github.com/users/pengowen123/events{/privacy}", "received_events_url": "https://api.github.com/users/pengowen123/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e4b633417fe4886d35c11d38b28b3f98ff4e373", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e4b633417fe4886d35c11d38b28b3f98ff4e373", "html_url": "https://github.com/rust-lang/rust/commit/7e4b633417fe4886d35c11d38b28b3f98ff4e373"}], "stats": {"total": 144, "additions": 87, "deletions": 57}, "files": [{"sha": "1363183cb810d0807973da0eee41be067a12a80e", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 52, "deletions": 38, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1938904fcd581e87c2be63d537fd402805627a0e/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1938904fcd581e87c2be63d537fd402805627a0e/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=1938904fcd581e87c2be63d537fd402805627a0e", "patch": "@@ -1,4 +1,4 @@\n-//! lint when there are large variants on an enum\n+//! lint when there is a large size difference between variants on an enum\n \n use rustc::lint::*;\n use rustc::hir::*;\n@@ -7,7 +7,7 @@ use rustc::ty::layout::TargetDataLayout;\n use rustc::ty::TypeFoldable;\n use rustc::traits::Reveal;\n \n-/// **What it does:** Checks for large variants on `enum`s.\n+/// **What it does:** Checks for large size differences between variants on `enum`s.\n ///\n /// **Why is this bad?** Enum size is bounded by the largest variant. Having a large variant\n /// can penalize the memory layout of that enum.\n@@ -24,17 +24,17 @@ use rustc::traits::Reveal;\n declare_lint! {\n     pub LARGE_ENUM_VARIANT,\n     Warn,\n-    \"large variants on an enum\"\n+    \"large size difference between variants on an enum\"\n }\n \n #[derive(Copy,Clone)]\n pub struct LargeEnumVariant {\n-    maximum_variant_size_allowed: u64,\n+    maximum_size_difference_allowed: u64,\n }\n \n impl LargeEnumVariant {\n-    pub fn new(maximum_variant_size_allowed: u64) -> Self {\n-        LargeEnumVariant { maximum_variant_size_allowed: maximum_variant_size_allowed }\n+    pub fn new(maximum_size_difference_allowed: u64) -> Self {\n+        LargeEnumVariant { maximum_size_difference_allowed: maximum_size_difference_allowed }\n     }\n }\n \n@@ -50,7 +50,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n         if let ItemEnum(ref def, _) = item.node {\n             let ty = cx.tcx.item_type(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n-            for (i, variant) in adt.variants.iter().enumerate() {\n+\n+            let mut sizes = Vec::new();\n+            let mut variants = Vec::new();\n+\n+            for variant in &adt.variants {\n                 let data_layout = TargetDataLayout::parse(cx.sess());\n                 cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                     let size: u64 = variant.fields\n@@ -68,39 +72,49 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n                         })\n                         .sum();\n \n-                    use std::io::Write;\n-                    let mut f = ::std::fs::File::create(\"log\").unwrap();\n-\n-                    writeln!(f, \"size, max size: {}, {}\", size, self.maximum_variant_size_allowed).unwrap();\n-                    if size > self.maximum_variant_size_allowed {\n-                        writeln!(f, \"size > max\").unwrap();\n-                        // panic!(\"foo\");\n-\n-                        span_lint_and_then(cx,\n-                                           LARGE_ENUM_VARIANT,\n-                                           def.variants[i].span,\n-                                           \"large enum variant found\",\n-                                           |db| {\n-                            if variant.fields.len() == 1 {\n-                                let span = match def.variants[i].node.data {\n-                                    VariantData::Struct(ref fields, _) |\n-                                    VariantData::Tuple(ref fields, _) => fields[0].ty.span,\n-                                    VariantData::Unit(_) => unreachable!(),\n-                                };\n-                                if let Some(snip) = snippet_opt(cx, span) {\n-                                    db.span_suggestion(span,\n-                                                       \"consider boxing the large fields to reduce the total size of \\\n-                                                        the enum\",\n-                                                       format!(\"Box<{}>\", snip));\n-                                    return;\n-                                }\n-                            }\n-                            db.span_help(def.variants[i].span,\n-                                         \"consider boxing the large fields to reduce the total size of the enum\");\n-                        });\n-                    }\n+                    sizes.push(size);\n+                    variants.push(variant);\n                 });\n             }\n+\n+            let mut grouped = sizes.into_iter().zip(variants.into_iter().enumerate()).collect::<Vec<_>>();\n+\n+            grouped.sort_by_key(|g| g.0);\n+\n+            let smallest_variant = grouped.first();\n+            let largest_variant = grouped.last();\n+\n+            if let (Some(smallest), Some(largest)) = (smallest_variant, largest_variant) {\n+                let difference = largest.0 - smallest.0;\n+\n+                if difference > self.maximum_size_difference_allowed {\n+                    let (i, variant) = largest.1;\n+\n+                    span_lint_and_then(cx,\n+                                       LARGE_ENUM_VARIANT,\n+                                       def.variants[i].span,\n+                                       \"large size difference between variants\",\n+                                       |db| {\n+                        if variant.fields.len() == 1 {\n+                            let span = match def.variants[i].node.data {\n+                                VariantData::Struct(ref fields, _) |\n+                                VariantData::Tuple(ref fields, _) => fields[0].ty.span,\n+                                VariantData::Unit(_) => unreachable!(),\n+                            };\n+                            if let Some(snip) = snippet_opt(cx, span) {\n+                                db.span_suggestion(span,\n+                                                   \"consider boxing the large fields to reduce the total size of the \\\n+                                                    enum\",\n+                                                   format!(\"Box<{}>\", snip));\n+                                return;\n+                            }\n+                        }\n+                        db.span_help(def.variants[i].span,\n+                                     \"consider boxing the large fields to reduce the total size of the enum\");\n+                    });\n+                }\n+            }\n+\n         }\n     }\n }"}, {"sha": "0cbafc978894941950709493c75e6274b2e3c62a", "filename": "log", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e4b633417fe4886d35c11d38b28b3f98ff4e373/log", "raw_url": "https://github.com/rust-lang/rust/raw/7e4b633417fe4886d35c11d38b28b3f98ff4e373/log", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/log?ref=7e4b633417fe4886d35c11d38b28b3f98ff4e373", "patch": "@@ -1 +0,0 @@\n-size, max size: 0, 200"}, {"sha": "26ba883b1baa6051c801d3af7ddb3ca1ea06725f", "filename": "tests/ui/large_enum_variant.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1938904fcd581e87c2be63d537fd402805627a0e/tests%2Fui%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1938904fcd581e87c2be63d537fd402805627a0e/tests%2Fui%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.rs?ref=1938904fcd581e87c2be63d537fd402805627a0e", "patch": "@@ -7,19 +7,21 @@\n \n enum LargeEnum {\n     A(i32),\n-    B([i32; 8000]),\n-\n+    B([i32; 8000]), //~ ERROR large size difference between variants\n+    //~^ HELP consider boxing the large fields to reduce the total size of the enum\n+    //~| SUGGESTION Box<[i32; 8000]>\n+}\n \n+enum GenericEnumOk<T> {\n+    A(i32),\n+    B([T; 8000]),\n }\n \n-enum GenericEnum<T> {\n+enum GenericEnum2<T> {\n     A(i32),\n     B([i32; 8000]),\n-\n-\n-    C([T; 8000]),\n-    D(T, [i32; 8000]),\n-\n+    C(T, [i32; 8000]), //~ ERROR large size difference between variants\n+    //~^ HELP consider boxing the large fields to reduce the total size of the enum\n }\n \n trait SomeTrait {\n@@ -30,24 +32,39 @@ enum LargeEnumGeneric<A: SomeTrait> {\n     Var(A::Item), // regression test, this used to ICE\n }\n \n-enum AnotherLargeEnum {\n+enum LargeEnum2 {\n     VariantOk(i32, u32),\n-    ContainingLargeEnum(LargeEnum),\n-\n-\n-    ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n-\n+    ContainingLargeEnum(LargeEnum), //~ ERROR large size difference between variants\n+    //~^ HELP consider boxing the large fields to reduce the total size of the enum\n+    //~| SUGGESTION Box<LargeEnum>\n+}\n+enum LargeEnum3 {\n+    ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]), //~ ERROR large size difference between variants\n+    //~^ HELP consider boxing the large fields to reduce the total size of the enum\n     VoidVariant,\n     StructLikeLittle { x: i32, y: i32 },\n-    StructLikeLarge { x: [i32; 8000], y: i32 },\n+}\n \n-    StructLikeLarge2 {\n-        x:\n-        [i32; 8000]\n+enum LargeEnum4 {\n+    VariantOk(i32, u32),\n+    StructLikeLarge { x: [i32; 8000], y: i32 }, //~ ERROR large size difference between variants\n+    //~^ HELP consider boxing the large fields to reduce the total size of the enum\n+}\n \n+enum LargeEnum5 {\n+    VariantOk(i32, u32),\n+    StructLikeLarge2 { //~ ERROR large size difference between variants\n+        x:\n+        [i32; 8000] //~ SUGGESTION Box<[i32; 8000]>\n+        //~^ HELP consider boxing the large fields to reduce the total size of the enum\n     },\n }\n \n+enum LargeEnumOk {\n+    LargeA([i32; 8000]),\n+    LargeB([i32; 8001]),\n+}\n+\n fn main() {\n \n }"}]}