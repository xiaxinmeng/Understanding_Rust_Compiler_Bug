{"sha": "880246618b6c28adc76e5e68247aa5a9302320f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MDI0NjYxOGI2YzI4YWRjNzZlNWU2ODI0N2FhNWE5MzAyMzIwZjg=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-31T19:56:18Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-01T20:52:37Z"}, "message": "Relax some atomic barriers. Loosen up all that tension. There, doesn't that feel good?", "tree": {"sha": "0e78b928d7fdc3483213d39813eb91af1c8c1caf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e78b928d7fdc3483213d39813eb91af1c8c1caf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/880246618b6c28adc76e5e68247aa5a9302320f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/880246618b6c28adc76e5e68247aa5a9302320f8", "html_url": "https://github.com/rust-lang/rust/commit/880246618b6c28adc76e5e68247aa5a9302320f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/880246618b6c28adc76e5e68247aa5a9302320f8/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "479809a267dbbcc3e2ec87da677c63430d3d229a", "url": "https://api.github.com/repos/rust-lang/rust/commits/479809a267dbbcc3e2ec87da677c63430d3d229a", "html_url": "https://github.com/rust-lang/rust/commit/479809a267dbbcc3e2ec87da677c63430d3d229a"}], "stats": {"total": 45, "additions": 23, "deletions": 22}, "files": [{"sha": "11ba42f805b55b9c1ec52eaa7c69a94fba6b415c", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/880246618b6c28adc76e5e68247aa5a9302320f8/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880246618b6c28adc76e5e68247aa5a9302320f8/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=880246618b6c28adc76e5e68247aa5a9302320f8", "patch": "@@ -18,7 +18,7 @@ use kinds::Send;\n use rt::sched::Scheduler;\n use rt::local::Local;\n use rt::select::{Select, SelectPort};\n-use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Release, SeqCst};\n+use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Relaxed, SeqCst};\n use unstable::sync::UnsafeAtomicRcBox;\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n@@ -216,15 +216,15 @@ impl<T> Select for PortOne<T> {\n                 }\n                 STATE_ONE => {\n                     // Re-record that we are the only owner of the packet.\n-                    // Release barrier needed in case the task gets reawoken\n-                    // on a different core (this is analogous to writing a\n-                    // payload; a barrier in enqueueing the task protects it).\n+                    // No barrier needed, even if the task gets reawoken\n+                    // on a different core -- this is analogous to writing a\n+                    // payload; a barrier in enqueueing the task protects it.\n                     // NB(#8132). This *must* occur before the enqueue below.\n                     // FIXME(#6842, #8130) This is usually only needed for the\n                     // assertion in recv_ready, except in the case of select().\n                     // This won't actually ever have cacheline contention, but\n                     // maybe should be optimized out with a cfg(test) anyway?\n-                    (*self.packet()).state.store(STATE_ONE, Release);\n+                    (*self.packet()).state.store(STATE_ONE, Relaxed);\n \n                     rtdebug!(\"rendezvous recv\");\n                     sched.metrics.rendezvous_recvs += 1;\n@@ -299,7 +299,7 @@ impl<T> SelectPort<T> for PortOne<T> {\n         unsafe {\n             // See corresponding store() above in block_on for rationale.\n             // FIXME(#8130) This can happen only in test builds.\n-            assert!((*packet).state.load(Acquire) == STATE_ONE);\n+            assert!((*packet).state.load(Relaxed) == STATE_ONE);\n \n             let payload = (*packet).payload.take();\n "}, {"sha": "729c682dbd114602369b63baa202bcbcb608ba85", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/880246618b6c28adc76e5e68247aa5a9302320f8/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880246618b6c28adc76e5e68247aa5a9302320f8/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=880246618b6c28adc76e5e68247aa5a9302320f8", "patch": "@@ -17,7 +17,7 @@ use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n use to_bytes::IterBytes;\n-use unstable::atomics::{AtomicUint, Acquire, SeqCst};\n+use unstable::atomics::{AtomicUint, Relaxed};\n use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n use util;\n \n@@ -95,7 +95,7 @@ impl Drop for KillFlag {\n     // Letting a KillFlag with a task inside get dropped would leak the task.\n     // We could free it here, but the task should get awoken by hand somehow.\n     fn drop(&self) {\n-        match self.load(Acquire) {\n+        match self.load(Relaxed) {\n             KILL_RUNNING | KILL_KILLED => { },\n             _ => rtabort!(\"can't drop kill flag with a blocked task inside!\"),\n         }\n@@ -124,7 +124,7 @@ impl BlockedTask {\n             Unkillable(task) => Some(task),\n             Killable(flag_arc) => {\n                 let flag = unsafe { &mut **flag_arc.get() };\n-                match flag.swap(KILL_RUNNING, SeqCst) {\n+                match flag.swap(KILL_RUNNING, Relaxed) {\n                     KILL_RUNNING => None, // woken from select(), perhaps\n                     KILL_KILLED  => None, // a killer stole it already\n                     task_ptr     =>\n@@ -159,7 +159,7 @@ impl BlockedTask {\n                 let flag     = &mut **flag_arc.get();\n                 let task_ptr = cast::transmute(task);\n                 // Expect flag to contain RUNNING. If KILLED, it should stay KILLED.\n-                match flag.compare_and_swap(KILL_RUNNING, task_ptr, SeqCst) {\n+                match flag.compare_and_swap(KILL_RUNNING, task_ptr, Relaxed) {\n                     KILL_RUNNING => Right(Killable(flag_arc)),\n                     KILL_KILLED  => Left(revive_task_ptr(task_ptr, Some(flag_arc))),\n                     x            => rtabort!(\"can't block task! kill flag = %?\", x),\n@@ -257,7 +257,7 @@ impl KillHandle {\n         let inner = unsafe { &mut *self.get() };\n         // Expect flag to contain RUNNING. If KILLED, it should stay KILLED.\n         // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n-        match inner.unkillable.compare_and_swap(KILL_RUNNING, KILL_UNKILLABLE, SeqCst) {\n+        match inner.unkillable.compare_and_swap(KILL_RUNNING, KILL_UNKILLABLE, Relaxed) {\n             KILL_RUNNING    => { }, // normal case\n             KILL_KILLED     => if !already_failing { fail!(KILLED_MSG) },\n             _               => rtabort!(\"inhibit_kill: task already unkillable\"),\n@@ -270,7 +270,7 @@ impl KillHandle {\n         let inner = unsafe { &mut *self.get() };\n         // Expect flag to contain UNKILLABLE. If KILLED, it should stay KILLED.\n         // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n-        match inner.unkillable.compare_and_swap(KILL_UNKILLABLE, KILL_RUNNING, SeqCst) {\n+        match inner.unkillable.compare_and_swap(KILL_UNKILLABLE, KILL_RUNNING, Relaxed) {\n             KILL_UNKILLABLE => { }, // normal case\n             KILL_KILLED     => if !already_failing { fail!(KILLED_MSG) },\n             _               => rtabort!(\"allow_kill: task already killable\"),\n@@ -281,10 +281,10 @@ impl KillHandle {\n     // if it was blocked and needs punted awake. To be called by other tasks.\n     pub fn kill(&mut self) -> Option<~Task> {\n         let inner = unsafe { &mut *self.get() };\n-        if inner.unkillable.swap(KILL_KILLED, SeqCst) == KILL_RUNNING {\n+        if inner.unkillable.swap(KILL_KILLED, Relaxed) == KILL_RUNNING {\n             // Got in. Allowed to try to punt the task awake.\n             let flag = unsafe { &mut *inner.killed.get() };\n-            match flag.swap(KILL_KILLED, SeqCst) {\n+            match flag.swap(KILL_KILLED, Relaxed) {\n                 // Task either not blocked or already taken care of.\n                 KILL_RUNNING | KILL_KILLED => None,\n                 // Got ownership of the blocked task.\n@@ -306,8 +306,11 @@ impl KillHandle {\n         // is unkillable with a kill signal pending.\n         let inner = unsafe { &*self.get() };\n         let flag  = unsafe { &*inner.killed.get() };\n-        // FIXME(#6598): can use relaxed ordering (i think)\n-        flag.load(Acquire) == KILL_KILLED\n+        // A barrier-related concern here is that a task that gets killed\n+        // awake needs to see the killer's write of KILLED to this flag. This\n+        // is analogous to receiving a pipe payload; the appropriate barrier\n+        // should happen when enqueueing the task.\n+        flag.load(Relaxed) == KILL_KILLED\n     }\n \n     pub fn notify_immediate_failure(&mut self) {"}, {"sha": "04ada5ec07be699f8a2db74b69040c780fac359c", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/880246618b6c28adc76e5e68247aa5a9302320f8/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880246618b6c28adc76e5e68247aa5a9302320f8/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=880246618b6c28adc76e5e68247aa5a9302320f8", "patch": "@@ -16,7 +16,7 @@ use ptr;\n use option::*;\n use either::{Either, Left, Right};\n use task;\n-use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,SeqCst};\n+use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,Relaxed,SeqCst};\n use unstable::finally::Finally;\n use ops::Drop;\n use clone::Clone;\n@@ -95,8 +95,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n     pub fn get(&self) -> *mut T {\n         unsafe {\n             let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-            // FIXME(#6598) Change Acquire to Relaxed.\n-            assert!(data.count.load(Acquire) > 0);\n+            assert!(data.count.load(Relaxed) > 0);\n             let r: *mut T = data.data.get_mut_ref();\n             cast::forget(data);\n             return r;\n@@ -107,7 +106,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n     pub fn get_immut(&self) -> *T {\n         unsafe {\n             let data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-            assert!(data.count.load(Acquire) > 0); // no barrier is really needed\n+            assert!(data.count.load(Relaxed) > 0);\n             let r: *T = data.data.get_ref();\n             cast::forget(data);\n             return r;\n@@ -130,8 +129,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n                 // Try to put our server end in the unwrapper slot.\n                 // This needs no barrier -- it's protected by the release barrier on\n                 // the xadd, and the acquire+release barrier in the destructor's xadd.\n-                // FIXME(#6598) Change Acquire to Relaxed.\n-                if data.unwrapper.fill(~(c1,p2), Acquire).is_none() {\n+                if data.unwrapper.fill(~(c1,p2), Relaxed).is_none() {\n                     // Got in. Tell this handle's destructor not to run (we are now it).\n                     this.data = ptr::mut_null();\n                     // Drop our own reference."}]}