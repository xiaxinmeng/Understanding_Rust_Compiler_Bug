{"sha": "5b54363961c6adac7b2acc1aade81c0173797e52", "node_id": "C_kwDOAAsO6NoAKDViNTQzNjM5NjFjNmFkYWM3YjJhY2MxYWFkZTgxYzAxNzM3OTdlNTI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-17T07:08:36Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-23T23:40:15Z"}, "message": "Optimize the code produced by `derive(Debug)`.\n\nThis commit adds new methods that combine sequences of existing\nformatting methods.\n- `Formatter::debug_{tuple,struct}_field[12345]_finish`, equivalent to a\n  `Formatter::debug_{tuple,struct}` + N x `Debug{Tuple,Struct}::field` +\n  `Debug{Tuple,Struct}::finish` call sequence.\n- `Formatter::debug_{tuple,struct}_fields_finish` is similar, but can\n  handle any number of fields by using arrays.\n\nThese new methods are all marked as `doc(hidden)` and unstable. They are\nintended for the compiler's own use.\n\nSpecial-casing up to 5 fields gives significantly better performance\nresults than always using arrays (as was tried in #95637).\n\nThe commit also changes the `Debug` deriving code to use these new methods. For\nexample, where the old `Debug` code for a struct with two fields would be like\nthis:\n```\nfn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n    match *self {\n\tSelf {\n\t    f1: ref __self_0_0,\n\t    f2: ref __self_0_1,\n\t} => {\n\t    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, \"S2\");\n\t    let _ = ::core::fmt::DebugStruct::field(debug_trait_builder, \"f1\", &&(*__self_0_0));\n\t    let _ = ::core::fmt::DebugStruct::field(debug_trait_builder, \"f2\", &&(*__self_0_1));\n\t    ::core::fmt::DebugStruct::finish(debug_trait_builder)\n\t}\n    }\n}\n```\nthe new code is like this:\n```\nfn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n    match *self {\n\tSelf {\n\t    f1: ref __self_0_0,\n\t    f2: ref __self_0_1,\n\t} => ::core::fmt::Formatter::debug_struct_field2_finish(\n\t    f,\n\t    \"S2\",\n\t    \"f1\",\n\t    &&(*__self_0_0),\n\t    \"f2\",\n\t    &&(*__self_0_1),\n\t),\n    }\n}\n```\nThis shrinks the code produced for `Debug` instances\nconsiderably, reducing compile times and binary sizes.\n\nCo-authored-by: Scott McMurray <scottmcm@users.noreply.github.com>", "tree": {"sha": "07e013d9d30dce3cc32e4ea6a37f7667336b3a61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07e013d9d30dce3cc32e4ea6a37f7667336b3a61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b54363961c6adac7b2acc1aade81c0173797e52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b54363961c6adac7b2acc1aade81c0173797e52", "html_url": "https://github.com/rust-lang/rust/commit/5b54363961c6adac7b2acc1aade81c0173797e52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b54363961c6adac7b2acc1aade81c0173797e52/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7586e79af8771639e57c7d207b51fb9096e5359a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7586e79af8771639e57c7d207b51fb9096e5359a", "html_url": "https://github.com/rust-lang/rust/commit/7586e79af8771639e57c7d207b51fb9096e5359a"}], "stats": {"total": 456, "additions": 366, "deletions": 90}, "files": [{"sha": "1fffd6f9727d7de0c07c08c434cbb1539bf53ef2", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 117, "deletions": 88, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/5b54363961c6adac7b2acc1aade81c0173797e52/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b54363961c6adac7b2acc1aade81c0173797e52/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=5b54363961c6adac7b2acc1aade81c0173797e52", "patch": "@@ -3,14 +3,10 @@ use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Expr, LocalKind, MetaItem};\n+use rustc_ast::{self as ast, Expr, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Ident};\n-use rustc_span::{Span, DUMMY_SP};\n-\n-fn make_mut_borrow(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<Expr>) -> P<Expr> {\n-    cx.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Mut, expr))\n-}\n+use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::Span;\n \n pub fn expand_deriving_debug(\n     cx: &mut ExtCtxt<'_>,\n@@ -49,11 +45,7 @@ pub fn expand_deriving_debug(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-/// We use the debug builders to do the heavy lifting here\n fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    // build fmt.debug_struct(<name>).field(<fieldname>, &<fieldval>)....build()\n-    // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n-    // based on the \"shape\".\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n         EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n@@ -67,93 +59,130 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n     let fmt = substr.nonself_args[0].clone();\n \n-    // Special fast path for unit variants. In the common case of an enum that is entirely unit\n-    // variants (i.e. a C-like enum), this fast path allows LLVM to eliminate the entire switch in\n-    // favor of a lookup table.\n-    if let ast::VariantData::Unit(..) = vdata {\n-        let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n-        let expr = cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n-        let stmts = vec![cx.stmt_expr(expr)];\n-        let block = cx.block(span, stmts);\n-        return cx.expr_block(block);\n-    }\n-\n-    let builder = Ident::new(sym::debug_trait_builder, span);\n-    let builder_expr = cx.expr_ident(span, builder);\n-\n-    let mut stmts = Vec::with_capacity(fields.len() + 2);\n-    let fn_path_finish;\n-    match vdata {\n+    // Struct and tuples are similar enough that we use the same code for both,\n+    // with some extra pieces for structs due to the field names.\n+    let (is_struct, args_per_field) = match vdata {\n         ast::VariantData::Unit(..) => {\n-            cx.span_bug(span, \"unit variants should have been handled above\");\n+            // Special fast path for unit variants.\n+            //let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n+            //return cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]);\n+            assert!(fields.is_empty());\n+            (false, 0)\n         }\n-        ast::VariantData::Tuple(..) => {\n-            // tuple struct/\"normal\" variant\n-            let fn_path_debug_tuple = cx.std_path(&[sym::fmt, sym::Formatter, sym::debug_tuple]);\n-            let expr = cx.expr_call_global(span, fn_path_debug_tuple, vec![fmt, name]);\n-            let expr = make_mut_borrow(cx, span, expr);\n-            stmts.push(cx.stmt_let(span, false, builder, expr));\n-\n-            for field in fields {\n-                // Use double indirection to make sure this works for unsized types\n-                let field = cx.expr_addr_of(field.span, field.self_.clone());\n-                let field = cx.expr_addr_of(field.span, field);\n-\n-                let fn_path_field = cx.std_path(&[sym::fmt, sym::DebugTuple, sym::field]);\n-                let expr =\n-                    cx.expr_call_global(span, fn_path_field, vec![builder_expr.clone(), field]);\n-\n-                // Use `let _ = expr;` to avoid triggering the\n-                // unused_results lint.\n-                stmts.push(stmt_let_underscore(cx, span, expr));\n-            }\n+        ast::VariantData::Tuple(..) => (false, 1),\n+        ast::VariantData::Struct(..) => (true, 2),\n+    };\n \n-            fn_path_finish = cx.std_path(&[sym::fmt, sym::DebugTuple, sym::finish]);\n-        }\n-        ast::VariantData::Struct(..) => {\n-            // normal struct/struct variant\n-            let fn_path_debug_struct = cx.std_path(&[sym::fmt, sym::Formatter, sym::debug_struct]);\n-            let expr = cx.expr_call_global(span, fn_path_debug_struct, vec![fmt, name]);\n-            let expr = make_mut_borrow(cx, span, expr);\n-            stmts.push(cx.stmt_let(DUMMY_SP, false, builder, expr));\n-\n-            for field in fields {\n+    // The number of fields that can be handled without an array.\n+    const CUTOFF: usize = 5;\n+\n+    if fields.is_empty() {\n+        // Special case for no fields.\n+        let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n+        cx.expr_call_global(span, fn_path_write_str, vec![fmt, name])\n+    } else if fields.len() <= CUTOFF {\n+        // Few enough fields that we can use a specific-length method.\n+        let debug = if is_struct {\n+            format!(\"debug_struct_field{}_finish\", fields.len())\n+        } else {\n+            format!(\"debug_tuple_field{}_finish\", fields.len())\n+        };\n+        let fn_path_debug = cx.std_path(&[sym::fmt, sym::Formatter, Symbol::intern(&debug)]);\n+\n+        let mut args = Vec::with_capacity(2 + fields.len() * args_per_field);\n+        args.extend([fmt, name]);\n+        for i in 0..fields.len() {\n+            let field = &fields[i];\n+            if is_struct {\n                 let name = cx.expr_lit(\n                     field.span,\n                     ast::LitKind::Str(field.name.unwrap().name, ast::StrStyle::Cooked),\n                 );\n-\n-                // Use double indirection to make sure this works for unsized types\n-                let fn_path_field = cx.std_path(&[sym::fmt, sym::DebugStruct, sym::field]);\n-                let field = cx.expr_addr_of(field.span, field.self_.clone());\n-                let field = cx.expr_addr_of(field.span, field);\n-                let expr = cx.expr_call_global(\n-                    span,\n-                    fn_path_field,\n-                    vec![builder_expr.clone(), name, field],\n-                );\n-                stmts.push(stmt_let_underscore(cx, span, expr));\n+                args.push(name);\n             }\n-            fn_path_finish = cx.std_path(&[sym::fmt, sym::DebugStruct, sym::finish]);\n+            // Use double indirection to make sure this works for unsized types\n+            let field = cx.expr_addr_of(field.span, field.self_.clone());\n+            let field = cx.expr_addr_of(field.span, field);\n+            args.push(field);\n         }\n-    }\n+        cx.expr_call_global(span, fn_path_debug, args)\n+    } else {\n+        // Enough fields that we must use the any-length method.\n+        let mut name_exprs = Vec::with_capacity(fields.len());\n+        let mut value_exprs = Vec::with_capacity(fields.len());\n+\n+        for field in fields {\n+            if is_struct {\n+                name_exprs.push(cx.expr_lit(\n+                    field.span,\n+                    ast::LitKind::Str(field.name.unwrap().name, ast::StrStyle::Cooked),\n+                ));\n+            }\n \n-    let expr = cx.expr_call_global(span, fn_path_finish, vec![builder_expr]);\n+            // Use double indirection to make sure this works for unsized types\n+            let value_ref = cx.expr_addr_of(field.span, field.self_.clone());\n+            value_exprs.push(cx.expr_addr_of(field.span, value_ref));\n+        }\n \n-    stmts.push(cx.stmt_expr(expr));\n-    let block = cx.block(span, stmts);\n-    cx.expr_block(block)\n-}\n+        // `let names: &'static _ = &[\"field1\", \"field2\"];`\n+        let names_let = if is_struct {\n+            let lt_static = Some(cx.lifetime_static(span));\n+            let ty_static_ref =\n+                cx.ty_rptr(span, cx.ty_infer(span), lt_static, ast::Mutability::Not);\n+            Some(cx.stmt_let_ty(\n+                span,\n+                false,\n+                Ident::new(sym::names, span),\n+                Some(ty_static_ref),\n+                cx.expr_array_ref(span, name_exprs),\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        // `let values: &[&dyn Debug] = &[&&self.field1, &&self.field2];`\n+        let path_debug = cx.path_global(span, cx.std_path(&[sym::fmt, sym::Debug]));\n+        let ty_dyn_debug = cx.ty(\n+            span,\n+            ast::TyKind::TraitObject(vec![cx.trait_bound(path_debug)], ast::TraitObjectSyntax::Dyn),\n+        );\n+        let ty_slice = cx.ty(\n+            span,\n+            ast::TyKind::Slice(cx.ty_rptr(span, ty_dyn_debug, None, ast::Mutability::Not)),\n+        );\n+        let values_let = cx.stmt_let_ty(\n+            span,\n+            false,\n+            Ident::new(sym::values, span),\n+            Some(cx.ty_rptr(span, ty_slice, None, ast::Mutability::Not)),\n+            cx.expr_array_ref(span, value_exprs),\n+        );\n+\n+        // `fmt::Formatter::debug_struct_fields_finish(fmt, name, names, values)` or\n+        // `fmt::Formatter::debug_tuple_fields_finish(fmt, name, values)`\n+        let sym_debug = if is_struct {\n+            sym::debug_struct_fields_finish\n+        } else {\n+            sym::debug_tuple_fields_finish\n+        };\n+        let fn_path_debug_internal = cx.std_path(&[sym::fmt, sym::Formatter, sym_debug]);\n+\n+        let mut args = Vec::with_capacity(4);\n+        args.push(fmt);\n+        args.push(name);\n+        if is_struct {\n+            args.push(cx.expr_ident(span, Ident::new(sym::names, span)));\n+        }\n+        args.push(cx.expr_ident(span, Ident::new(sym::values, span)));\n+        let expr = cx.expr_call_global(span, fn_path_debug_internal, args);\n \n-fn stmt_let_underscore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast::Stmt {\n-    let local = P(ast::Local {\n-        pat: cx.pat_wild(sp),\n-        ty: None,\n-        id: ast::DUMMY_NODE_ID,\n-        kind: LocalKind::Init(expr),\n-        span: sp,\n-        attrs: ast::AttrVec::new(),\n-        tokens: None,\n-    });\n-    ast::Stmt { id: ast::DUMMY_NODE_ID, kind: ast::StmtKind::Local(local), span: sp }\n+        let mut stmts = Vec::with_capacity(3);\n+        if is_struct {\n+            stmts.push(names_let.unwrap());\n+        }\n+        stmts.push(values_let);\n+        stmts.push(cx.stmt_expr(expr));\n+\n+        cx.expr_block(cx.block(span, stmts))\n+    }\n }"}, {"sha": "1694a8865dde2d98ead7d6079d136a586a3324d0", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5b54363961c6adac7b2acc1aade81c0173797e52/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b54363961c6adac7b2acc1aade81c0173797e52/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=5b54363961c6adac7b2acc1aade81c0173797e52", "patch": "@@ -57,6 +57,10 @@ impl<'a> ExtCtxt<'a> {\n         P(ast::Ty { id: ast::DUMMY_NODE_ID, span, kind, tokens: None })\n     }\n \n+    pub fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n+        self.ty(span, ast::TyKind::Infer)\n+    }\n+\n     pub fn ty_path(&self, path: ast::Path) -> P<ast::Ty> {\n         self.ty(path.span, ast::TyKind::Path(None, path))\n     }\n@@ -140,11 +144,26 @@ impl<'a> ExtCtxt<'a> {\n         ast::Lifetime { id: ast::DUMMY_NODE_ID, ident: ident.with_span_pos(span) }\n     }\n \n+    pub fn lifetime_static(&self, span: Span) -> ast::Lifetime {\n+        self.lifetime(span, Ident::new(kw::StaticLifetime, span))\n+    }\n+\n     pub fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n         ast::Stmt { id: ast::DUMMY_NODE_ID, span: expr.span, kind: ast::StmtKind::Expr(expr) }\n     }\n \n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: Ident, ex: P<ast::Expr>) -> ast::Stmt {\n+        self.stmt_let_ty(sp, mutbl, ident, None, ex)\n+    }\n+\n+    pub fn stmt_let_ty(\n+        &self,\n+        sp: Span,\n+        mutbl: bool,\n+        ident: Ident,\n+        ty: Option<P<ast::Ty>>,\n+        ex: P<ast::Expr>,\n+    ) -> ast::Stmt {\n         let pat = if mutbl {\n             let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mut);\n             self.pat_ident_binding_mode(sp, ident, binding_mode)\n@@ -153,7 +172,7 @@ impl<'a> ExtCtxt<'a> {\n         };\n         let local = P(ast::Local {\n             pat,\n-            ty: None,\n+            ty,\n             id: ast::DUMMY_NODE_ID,\n             kind: LocalKind::Init(ex),\n             span: sp,"}, {"sha": "48766c6791096b543fd51b87bbe061dd31dbe777", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b54363961c6adac7b2acc1aade81c0173797e52/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b54363961c6adac7b2acc1aade81c0173797e52/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=5b54363961c6adac7b2acc1aade81c0173797e52", "patch": "@@ -567,8 +567,10 @@ symbols! {\n         debug_assert_ne_macro,\n         debug_assertions,\n         debug_struct,\n+        debug_struct_fields_finish,\n         debug_trait_builder,\n         debug_tuple,\n+        debug_tuple_fields_finish,\n         debugger_visualizer,\n         decl_macro,\n         declare_lint_pass,"}, {"sha": "1d4be42b4a213d2692a92dfa673b8d4c1d62bff0", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 227, "deletions": 1, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/5b54363961c6adac7b2acc1aade81c0173797e52/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b54363961c6adac7b2acc1aade81c0173797e52/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=5b54363961c6adac7b2acc1aade81c0173797e52", "patch": "@@ -4,6 +4,7 @@\n \n use crate::cell::{Cell, Ref, RefCell, RefMut, SyncUnsafeCell, UnsafeCell};\n use crate::char::EscapeDebugExtArgs;\n+use crate::iter;\n use crate::marker::PhantomData;\n use crate::mem;\n use crate::num::fmt as numfmt;\n@@ -693,7 +694,7 @@ pub(crate) mod macros {\n     /// Derive macro generating an impl of the trait `Debug`.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-    #[allow_internal_unstable(core_intrinsics)]\n+    #[allow_internal_unstable(core_intrinsics, fmt_helpers_for_derive)]\n     pub macro Debug($item:item) {\n         /* compiler built-in */\n     }\n@@ -1964,6 +1965,129 @@ impl<'a> Formatter<'a> {\n         builders::debug_struct_new(self, name)\n     }\n \n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 1 field.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field1_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 2 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field2_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+        name2: &str,\n+        value2: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.field(name2, value2);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 3 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field3_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+        name2: &str,\n+        value2: &dyn Debug,\n+        name3: &str,\n+        value3: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.field(name2, value2);\n+        builder.field(name3, value3);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 4 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field4_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+        name2: &str,\n+        value2: &dyn Debug,\n+        name3: &str,\n+        value3: &dyn Debug,\n+        name4: &str,\n+        value4: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.field(name2, value2);\n+        builder.field(name3, value3);\n+        builder.field(name4, value4);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_struct_fields_finish` is more general, but this is faster for 5 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_field5_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        name1: &str,\n+        value1: &dyn Debug,\n+        name2: &str,\n+        value2: &dyn Debug,\n+        name3: &str,\n+        value3: &dyn Debug,\n+        name4: &str,\n+        value4: &dyn Debug,\n+        name5: &str,\n+        value5: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_struct_new(self, name);\n+        builder.field(name1, value1);\n+        builder.field(name2, value2);\n+        builder.field(name3, value3);\n+        builder.field(name4, value4);\n+        builder.field(name5, value5);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// For the cases not covered by `debug_struct_field[12345]_finish`.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_struct_fields_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        names: &[&str],\n+        values: &[&dyn Debug],\n+    ) -> Result {\n+        assert_eq!(names.len(), values.len());\n+        let mut builder = builders::debug_struct_new(self, name);\n+        for (name, value) in iter::zip(names, values) {\n+            builder.field(name, value);\n+        }\n+        builder.finish()\n+    }\n+\n     /// Creates a `DebugTuple` builder designed to assist with creation of\n     /// `fmt::Debug` implementations for tuple structs.\n     ///\n@@ -1995,6 +2119,108 @@ impl<'a> Formatter<'a> {\n         builders::debug_tuple_new(self, name)\n     }\n \n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 1 field.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field1_finish<'b>(&'b mut self, name: &str, value1: &dyn Debug) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 2 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field2_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        value1: &dyn Debug,\n+        value2: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.field(value2);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 3 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field3_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        value1: &dyn Debug,\n+        value2: &dyn Debug,\n+        value3: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.field(value2);\n+        builder.field(value3);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 4 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field4_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        value1: &dyn Debug,\n+        value2: &dyn Debug,\n+        value3: &dyn Debug,\n+        value4: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.field(value2);\n+        builder.field(value3);\n+        builder.field(value4);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// `debug_tuple_fields_finish` is more general, but this is faster for 5 fields.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_field5_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        value1: &dyn Debug,\n+        value2: &dyn Debug,\n+        value3: &dyn Debug,\n+        value4: &dyn Debug,\n+        value5: &dyn Debug,\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        builder.field(value1);\n+        builder.field(value2);\n+        builder.field(value3);\n+        builder.field(value4);\n+        builder.field(value5);\n+        builder.finish()\n+    }\n+\n+    /// Used to shrink `derive(Debug)` code, for faster compilation and smaller binaries.\n+    /// For the cases not covered by `debug_tuple_field[12345]_finish`.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"fmt_helpers_for_derive\", issue = \"none\")]\n+    pub fn debug_tuple_fields_finish<'b>(\n+        &'b mut self,\n+        name: &str,\n+        values: &[&dyn Debug],\n+    ) -> Result {\n+        let mut builder = builders::debug_tuple_new(self, name);\n+        for value in values {\n+            builder.field(value);\n+        }\n+        builder.finish()\n+    }\n+\n     /// Creates a `DebugList` builder designed to assist with creation of\n     /// `fmt::Debug` implementations for list-like structures.\n     ///"}]}