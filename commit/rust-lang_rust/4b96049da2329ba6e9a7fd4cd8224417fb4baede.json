{"sha": "4b96049da2329ba6e9a7fd4cd8224417fb4baede", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiOTYwNDlkYTIzMjliYTZlOWE3ZmQ0Y2Q4MjI0NDE3ZmI0YmFlZGU=", "commit": {"author": {"name": "Jacob Hughes", "email": "j@jacobhughes.me", "date": "2020-10-12T12:44:53Z"}, "committer": {"name": "Jacob Hughes", "email": "j@jacobhughes.me", "date": "2020-10-12T12:44:53Z"}, "message": "BTreeMap: refactor Entry out of map.rs into its own file\n\nbtree/map.rs is approaching the 3000 line mark, splitting out the entry\ncode buys about 500 lines of headroom", "tree": {"sha": "57b92d551870ad4af9943cc7e677bd71348a9fa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57b92d551870ad4af9943cc7e677bd71348a9fa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b96049da2329ba6e9a7fd4cd8224417fb4baede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b96049da2329ba6e9a7fd4cd8224417fb4baede", "html_url": "https://github.com/rust-lang/rust/commit/4b96049da2329ba6e9a7fd4cd8224417fb4baede", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b96049da2329ba6e9a7fd4cd8224417fb4baede/comments", "author": {"login": "exrook", "id": 534850, "node_id": "MDQ6VXNlcjUzNDg1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/534850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/exrook", "html_url": "https://github.com/exrook", "followers_url": "https://api.github.com/users/exrook/followers", "following_url": "https://api.github.com/users/exrook/following{/other_user}", "gists_url": "https://api.github.com/users/exrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/exrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/exrook/subscriptions", "organizations_url": "https://api.github.com/users/exrook/orgs", "repos_url": "https://api.github.com/users/exrook/repos", "events_url": "https://api.github.com/users/exrook/events{/privacy}", "received_events_url": "https://api.github.com/users/exrook/received_events", "type": "User", "site_admin": false}, "committer": {"login": "exrook", "id": 534850, "node_id": "MDQ6VXNlcjUzNDg1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/534850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/exrook", "html_url": "https://github.com/exrook", "followers_url": "https://api.github.com/users/exrook/followers", "following_url": "https://api.github.com/users/exrook/following{/other_user}", "gists_url": "https://api.github.com/users/exrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/exrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/exrook/subscriptions", "organizations_url": "https://api.github.com/users/exrook/orgs", "repos_url": "https://api.github.com/users/exrook/repos", "events_url": "https://api.github.com/users/exrook/events{/privacy}", "received_events_url": "https://api.github.com/users/exrook/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8d6da3f57f9cc85ddbe1d73e72e3523de7ac245", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d6da3f57f9cc85ddbe1d73e72e3523de7ac245", "html_url": "https://github.com/rust-lang/rust/commit/a8d6da3f57f9cc85ddbe1d73e72e3523de7ac245"}], "stats": {"total": 948, "additions": 480, "deletions": 468}, "files": [{"sha": "92cbce96054b886ed636d91eff9720b1b988f7db", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 5, "deletions": 468, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/4b96049da2329ba6e9a7fd4cd8224417fb4baede/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b96049da2329ba6e9a7fd4cd8224417fb4baede/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=4b96049da2329ba6e9a7fd4cd8224417fb4baede", "patch": "@@ -9,13 +9,16 @@ use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n use super::borrow::DormantMutRef;\n-use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n+use super::node::{self, marker, ForceResult::*, Handle, NodeRef};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n \n-use Entry::*;\n use UnderflowResult::*;\n \n+mod entry;\n+pub use entry::{Entry, OccupiedEntry, VacantEntry};\n+use Entry::*;\n+\n /// A map based on a B-Tree.\n ///\n /// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n@@ -452,69 +455,6 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     }\n }\n \n-/// A view into a single entry in a map, which may either be vacant or occupied.\n-///\n-/// This `enum` is constructed from the [`entry`] method on [`BTreeMap`].\n-///\n-/// [`entry`]: BTreeMap::entry\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Entry<'a, K: 'a, V: 'a> {\n-    /// A vacant entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n-\n-    /// An occupied entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n-}\n-\n-#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n-            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n-        }\n-    }\n-}\n-\n-/// A view into a vacant entry in a `BTreeMap`.\n-/// It is part of the [`Entry`] enum.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VacantEntry<'a, K: 'a, V: 'a> {\n-    key: K,\n-    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n-\n-    // Be invariant in `K` and `V`\n-    _marker: PhantomData<&'a mut (K, V)>,\n-}\n-\n-#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n-    }\n-}\n-\n-/// A view into an occupied entry in a `BTreeMap`.\n-/// It is part of the [`Entry`] enum.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n-    dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n-\n-    // Be invariant in `K` and `V`\n-    _marker: PhantomData<&'a mut (K, V)>,\n-}\n-\n-#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"OccupiedEntry\").field(\"key\", self.key()).field(\"value\", self.get()).finish()\n-    }\n-}\n-\n // An iterator for merging two sorted sequences into one\n struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n     left: Peekable<I>,\n@@ -2310,409 +2250,6 @@ impl<K, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    /// Ensures a value is in the entry by inserting the default if empty, and returns\n-    /// a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or_insert(self, default: V) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default),\n-        }\n-    }\n-\n-    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n-    /// and returns a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n-    /// let s = \"hoho\".to_string();\n-    ///\n-    /// map.entry(\"poneyland\").or_insert_with(|| s);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default()),\n-        }\n-    }\n-\n-    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n-    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n-    /// which takes the key as its argument, and returns a mutable reference to the value in the\n-    /// entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(or_insert_with_key)]\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 9);\n-    /// ```\n-    #[inline]\n-    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => {\n-                let value = default(entry.key());\n-                entry.insert(value)\n-            }\n-        }\n-    }\n-\n-    /// Returns a reference to this entry's key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n-    pub fn key(&self) -> &K {\n-        match *self {\n-            Occupied(ref entry) => entry.key(),\n-            Vacant(ref entry) => entry.key(),\n-        }\n-    }\n-\n-    /// Provides in-place mutable access to an occupied entry before any\n-    /// potential inserts into the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// map.entry(\"poneyland\")\n-    ///    .and_modify(|e| { *e += 1 })\n-    ///    .or_insert(42);\n-    /// assert_eq!(map[\"poneyland\"], 42);\n-    ///\n-    /// map.entry(\"poneyland\")\n-    ///    .and_modify(|e| { *e += 1 })\n-    ///    .or_insert(42);\n-    /// assert_eq!(map[\"poneyland\"], 43);\n-    /// ```\n-    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n-    pub fn and_modify<F>(self, f: F) -> Self\n-    where\n-        F: FnOnce(&mut V),\n-    {\n-        match self {\n-            Occupied(mut entry) => {\n-                f(entry.get_mut());\n-                Occupied(entry)\n-            }\n-            Vacant(entry) => Vacant(entry),\n-        }\n-    }\n-}\n-\n-impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n-    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n-    /// Ensures a value is in the entry by inserting the default value if empty,\n-    /// and returns a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_default();\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], None);\n-    /// ```\n-    pub fn or_default(self) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(Default::default()),\n-        }\n-    }\n-}\n-\n-impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n-    /// Gets a reference to the key that would be used when inserting a value\n-    /// through the VacantEntry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n-    pub fn key(&self) -> &K {\n-        &self.key\n-    }\n-\n-    /// Take ownership of the key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n-    ///     v.into_key();\n-    /// }\n-    /// ```\n-    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n-    pub fn into_key(self) -> K {\n-        self.key\n-    }\n-\n-    /// Sets the value of the entry with the `VacantEntry`'s key,\n-    /// and returns a mutable reference to it.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n-    ///\n-    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n-    ///     o.insert(37);\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 37);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n-        let out_ptr = match self.handle.insert_recursing(self.key, value) {\n-            (Fit(_), val_ptr) => {\n-                // Safety: We have consumed self.handle and the handle returned.\n-                let map = unsafe { self.dormant_map.awaken() };\n-                map.length += 1;\n-                val_ptr\n-            }\n-            (Split(ins), val_ptr) => {\n-                drop(ins.left);\n-                // Safety: We have consumed self.handle and the reference returned.\n-                let map = unsafe { self.dormant_map.awaken() };\n-                let root = map.root.as_mut().unwrap();\n-                root.push_internal_level().push(ins.k, ins.v, ins.right);\n-                map.length += 1;\n-                val_ptr\n-            }\n-        };\n-        // Now that we have finished growing the tree using borrowed references,\n-        // dereference the pointer to a part of it, that we picked up along the way.\n-        unsafe { &mut *out_ptr }\n-    }\n-}\n-\n-impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n-    /// Gets a reference to the key in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n-    pub fn key(&self) -> &K {\n-        self.handle.reborrow().into_kv().0\n-    }\n-\n-    /// Take ownership of the key and value from the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     // We delete the entry from the map.\n-    ///     o.remove_entry();\n-    /// }\n-    ///\n-    /// // If now try to get the value, it will panic:\n-    /// // println!(\"{}\", map[\"poneyland\"]);\n-    /// ```\n-    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n-    pub fn remove_entry(self) -> (K, V) {\n-        self.remove_kv()\n-    }\n-\n-    /// Gets a reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.get(), &12);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> &V {\n-        self.handle.reborrow().into_kv().1\n-    }\n-\n-    /// Gets a mutable reference to the value in the entry.\n-    ///\n-    /// If you need a reference to the `OccupiedEntry` that may outlive the\n-    /// destruction of the `Entry` value, see [`into_mut`].\n-    ///\n-    /// [`into_mut`]: OccupiedEntry::into_mut\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///     *o.get_mut() += 10;\n-    ///     assert_eq!(*o.get(), 22);\n-    ///\n-    ///     // We can use the same Entry multiple times.\n-    ///     *o.get_mut() += 2;\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 24);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut V {\n-        self.handle.kv_mut().1\n-    }\n-\n-    /// Converts the entry into a mutable reference to its value.\n-    ///\n-    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n-    ///\n-    /// [`get_mut`]: OccupiedEntry::get_mut\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     *o.into_mut() += 10;\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 22);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_mut(self) -> &'a mut V {\n-        self.handle.into_val_mut()\n-    }\n-\n-    /// Sets the value of the entry with the `OccupiedEntry`'s key,\n-    /// and returns the entry's old value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.insert(15), 12);\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 15);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: V) -> V {\n-        mem::replace(self.get_mut(), value)\n-    }\n-\n-    /// Takes the value of the entry out of the map, and returns it.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.remove(), 12);\n-    /// }\n-    /// // If we try to get \"poneyland\"'s value, it'll panic:\n-    /// // println!(\"{}\", map[\"poneyland\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(self) -> V {\n-        self.remove_kv().1\n-    }\n-\n-    // Body of `remove_entry`, separate to keep the above implementations short.\n-    fn remove_kv(self) -> (K, V) {\n-        let mut emptied_internal_root = false;\n-        let (old_kv, _) = self.handle.remove_kv_tracking(|| emptied_internal_root = true);\n-        // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n-        let map = unsafe { self.dormant_map.awaken() };\n-        map.length -= 1;\n-        if emptied_internal_root {\n-            let root = map.root.as_mut().unwrap();\n-            root.pop_internal_level();\n-        }\n-        old_kv\n-    }\n-}\n-\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Removes a key/value-pair from the map, and returns that pair, as well as\n     /// the leaf edge corresponding to that former pair."}, {"sha": "73a0ca21f6733f919d3ac12beae88d3c82caa19a", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/4b96049da2329ba6e9a7fd4cd8224417fb4baede/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b96049da2329ba6e9a7fd4cd8224417fb4baede/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=4b96049da2329ba6e9a7fd4cd8224417fb4baede", "patch": "@@ -0,0 +1,475 @@\n+use core::fmt::{self, Debug};\n+use core::marker::PhantomData;\n+use core::mem;\n+\n+use super::super::borrow::DormantMutRef;\n+use super::super::node::{marker, Handle, InsertResult::*, NodeRef};\n+use super::BTreeMap;\n+\n+use Entry::*;\n+\n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+///\n+/// This `enum` is constructed from the [`entry`] method on [`BTreeMap`].\n+///\n+/// [`entry`]: BTreeMap::entry\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Entry<'a, K: 'a, V: 'a> {\n+    /// A vacant entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n+\n+    /// An occupied entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n+}\n+\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n+impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n+            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n+        }\n+    }\n+}\n+\n+/// A view into a vacant entry in a `BTreeMap`.\n+/// It is part of the [`Entry`] enum.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n+    pub(super) key: K,\n+    pub(super) handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n+\n+    // Be invariant in `K` and `V`\n+    pub(super) _marker: PhantomData<&'a mut (K, V)>,\n+}\n+\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n+impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n+    }\n+}\n+\n+/// A view into an occupied entry in a `BTreeMap`.\n+/// It is part of the [`Entry`] enum.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n+    pub(super) handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n+    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n+\n+    // Be invariant in `K` and `V`\n+    pub(super) _marker: PhantomData<&'a mut (K, V)>,\n+}\n+\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n+impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"OccupiedEntry\").field(\"key\", self.key()).field(\"value\", self.get()).finish()\n+    }\n+}\n+\n+impl<'a, K: Ord, V> Entry<'a, K, V> {\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_insert(self, default: V) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(default),\n+        }\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n+    /// let s = \"hoho\".to_string();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(default()),\n+        }\n+    }\n+\n+    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n+    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n+    /// which takes the key as its argument, and returns a mutable reference to the value in the\n+    /// entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(or_insert_with_key)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 9);\n+    /// ```\n+    #[inline]\n+    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => {\n+                let value = default(entry.key());\n+                entry.insert(value)\n+            }\n+        }\n+    }\n+\n+    /// Returns a reference to this entry's key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n+    pub fn key(&self) -> &K {\n+        match *self {\n+            Occupied(ref entry) => entry.key(),\n+            Vacant(ref entry) => entry.key(),\n+        }\n+    }\n+\n+    /// Provides in-place mutable access to an occupied entry before any\n+    /// potential inserts into the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 42);\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 43);\n+    /// ```\n+    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n+    pub fn and_modify<F>(self, f: F) -> Self\n+    where\n+        F: FnOnce(&mut V),\n+    {\n+        match self {\n+            Occupied(mut entry) => {\n+                f(entry.get_mut());\n+                Occupied(entry)\n+            }\n+            Vacant(entry) => Vacant(entry),\n+        }\n+    }\n+}\n+\n+impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n+    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n+    /// Ensures a value is in the entry by inserting the default value if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_default();\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], None);\n+    /// ```\n+    pub fn or_default(self) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(Default::default()),\n+        }\n+    }\n+}\n+\n+impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n+    /// Gets a reference to the key that would be used when inserting a value\n+    /// through the VacantEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n+    pub fn key(&self) -> &K {\n+        &self.key\n+    }\n+\n+    /// Take ownership of the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n+    ///     v.into_key();\n+    /// }\n+    /// ```\n+    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n+    pub fn into_key(self) -> K {\n+        self.key\n+    }\n+\n+    /// Sets the value of the entry with the `VacantEntry`'s key,\n+    /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 37);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        let out_ptr = match self.handle.insert_recursing(self.key, value) {\n+            (Fit(_), val_ptr) => {\n+                // Safety: We have consumed self.handle and the handle returned.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                map.length += 1;\n+                val_ptr\n+            }\n+            (Split(ins), val_ptr) => {\n+                drop(ins.left);\n+                // Safety: We have consumed self.handle and the reference returned.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                let root = map.root.as_mut().unwrap();\n+                root.push_internal_level().push(ins.k, ins.v, ins.right);\n+                map.length += 1;\n+                val_ptr\n+            }\n+        };\n+        // Now that we have finished growing the tree using borrowed references,\n+        // dereference the pointer to a part of it, that we picked up along the way.\n+        unsafe { &mut *out_ptr }\n+    }\n+}\n+\n+impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n+    pub fn key(&self) -> &K {\n+        self.handle.reborrow().into_kv().0\n+    }\n+\n+    /// Take ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_entry();\n+    /// }\n+    ///\n+    /// // If now try to get the value, it will panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n+    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n+    pub fn remove_entry(self) -> (K, V) {\n+        self.remove_kv()\n+    }\n+\n+    /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get(&self) -> &V {\n+        self.handle.reborrow().into_kv().1\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// If you need a reference to the `OccupiedEntry` that may outlive the\n+    /// destruction of the `Entry` value, see [`into_mut`].\n+    ///\n+    /// [`into_mut`]: OccupiedEntry::into_mut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     *o.get_mut() += 10;\n+    ///     assert_eq!(*o.get(), 22);\n+    ///\n+    ///     // We can use the same Entry multiple times.\n+    ///     *o.get_mut() += 2;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 24);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.handle.kv_mut().1\n+    }\n+\n+    /// Converts the entry into a mutable reference to its value.\n+    ///\n+    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n+    ///\n+    /// [`get_mut`]: OccupiedEntry::get_mut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.handle.into_val_mut()\n+    }\n+\n+    /// Sets the value of the entry with the `OccupiedEntry`'s key,\n+    /// and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(&mut self, value: V) -> V {\n+        mem::replace(self.get_mut(), value)\n+    }\n+\n+    /// Takes the value of the entry out of the map, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    /// // If we try to get \"poneyland\"'s value, it'll panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn remove(self) -> V {\n+        self.remove_kv().1\n+    }\n+\n+    // Body of `remove_entry`, separate to keep the above implementations short.\n+    pub(super) fn remove_kv(self) -> (K, V) {\n+        let mut emptied_internal_root = false;\n+        let (old_kv, _) = self.handle.remove_kv_tracking(|| emptied_internal_root = true);\n+        // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n+        let map = unsafe { self.dormant_map.awaken() };\n+        map.length -= 1;\n+        if emptied_internal_root {\n+            let root = map.root.as_mut().unwrap();\n+            root.pop_internal_level();\n+        }\n+        old_kv\n+    }\n+}"}]}