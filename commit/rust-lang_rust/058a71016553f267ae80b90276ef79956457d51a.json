{"sha": "058a71016553f267ae80b90276ef79956457d51a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1OGE3MTAxNjU1M2YyNjdhZTgwYjkwMjc2ZWY3OTk1NjQ1N2Q1MWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-12T22:58:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-12T22:58:42Z"}, "message": "Auto merge of #79670 - Nadrieril:uninhabited-query, r=estebank\n\nTurn type inhabitedness into a query to fix `exhaustive_patterns` perf\n\nWe measured in https://github.com/rust-lang/rust/pull/79394 that enabling the [`exhaustive_patterns` feature](https://github.com/rust-lang/rust/issues/51085) causes significant perf degradation. It was conjectured that the culprit is type inhabitedness checking, and [I hypothesized](https://github.com/rust-lang/rust/pull/79394#issuecomment-733861149) that turning this computation into a query would solve most of the problem.\n\nThis PR turns `tcx.is_ty_uninhabited_from` into a query, and I measured a 25% perf gain on the benchmark that stress-tests `exhaustiveness_patterns`. This more than compensates for the 30% perf hit I measured [when creating it](https://github.com/rust-lang/rustc-perf/pull/801). We'll have to measure enabling the feature again, but I suspect this fixes the perf regression entirely.\nI'd like a perf run on this PR obviously.\nI made small atomic commits to help reviewing. The first one is just me discovering the \"revisions\" feature of the testing framework.\n\nI believe there's a push to move things out of `rustc_middle` because it's huge. I guess `inhabitedness/mod.rs` could be moved out, but it's quite small. `DefIdForest` might be movable somewhere too. I don't know what the policy is for that.\n\nPing `@camelid` since you were interested in following along\n`@rustbot` modify labels: +A-exhaustiveness-checking", "tree": {"sha": "9cd990416b0821aaa898a16bca44205fd92a4bba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cd990416b0821aaa898a16bca44205fd92a4bba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/058a71016553f267ae80b90276ef79956457d51a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/058a71016553f267ae80b90276ef79956457d51a", "html_url": "https://github.com/rust-lang/rust/commit/058a71016553f267ae80b90276ef79956457d51a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/058a71016553f267ae80b90276ef79956457d51a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a9b552cb1621c9c57898d147228aab32b65a7c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a9b552cb1621c9c57898d147228aab32b65a7c3", "html_url": "https://github.com/rust-lang/rust/commit/7a9b552cb1621c9c57898d147228aab32b65a7c3"}, {"sha": "e608d8f4e5e8e33b5d480323596d2aeabd129e4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e608d8f4e5e8e33b5d480323596d2aeabd129e4f", "html_url": "https://github.com/rust-lang/rust/commit/e608d8f4e5e8e33b5d480323596d2aeabd129e4f"}], "stats": {"total": 1073, "additions": 557, "deletions": 516}, "files": [{"sha": "8bfa76b6e2e72addb7b4c69cf30521b3b17f8c58", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -1319,6 +1319,15 @@ rustc_queries! {\n             eval_always\n             desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n         }\n+\n+        /// Computes the set of modules from which this type is visibly uninhabited.\n+        /// To check whether a type is uninhabited at all (not just from a given module), you could\n+        /// check whether the forest is empty.\n+        query type_uninhabited_from(\n+            key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n+        ) -> ty::inhabitedness::DefIdForest {\n+            desc { \"computing the inhabitedness of `{:?}`\", key }\n+        }\n     }\n \n     Other {"}, {"sha": "03c8963b0907e7f8585c8e6111426b265431c51a", "filename": "compiler/rustc_middle/src/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 77, "deletions": 43, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -3,6 +3,9 @@ use crate::ty::{DefId, DefIdTree};\n use rustc_hir::CRATE_HIR_ID;\n use smallvec::SmallVec;\n use std::mem;\n+use std::sync::Arc;\n+\n+use DefIdForest::*;\n \n /// Represents a forest of `DefId`s closed under the ancestor relation. That is,\n /// if a `DefId` representing a module is contained in the forest then all\n@@ -11,45 +14,77 @@ use std::mem;\n ///\n /// This is used to represent a set of modules in which a type is visibly\n /// uninhabited.\n-#[derive(Clone)]\n-pub struct DefIdForest {\n-    /// The minimal set of `DefId`s required to represent the whole set.\n-    /// If A and B are DefIds in the `DefIdForest`, and A is a descendant\n-    /// of B, then only B will be in `root_ids`.\n-    /// We use a `SmallVec` here because (for its use for caching inhabitedness)\n-    /// it's rare that this will contain even two IDs.\n-    root_ids: SmallVec<[DefId; 1]>,\n+///\n+/// We store the minimal set of `DefId`s required to represent the whole set. If A and B are\n+/// `DefId`s in the `DefIdForest`, and A is a parent of B, then only A will be stored. When this is\n+/// used with `type_uninhabited_from`, there will very rarely be more than one `DefId` stored.\n+#[derive(Clone, HashStable)]\n+pub enum DefIdForest {\n+    Empty,\n+    Single(DefId),\n+    /// This variant is very rare.\n+    /// Invariant: >1 elements\n+    /// We use `Arc` because this is used in the output of a query.\n+    Multiple(Arc<[DefId]>),\n+}\n+\n+/// Tests whether a slice of roots contains a given DefId.\n+#[inline]\n+fn slice_contains(tcx: TyCtxt<'tcx>, slice: &[DefId], id: DefId) -> bool {\n+    slice.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n }\n \n impl<'tcx> DefIdForest {\n     /// Creates an empty forest.\n     pub fn empty() -> DefIdForest {\n-        DefIdForest { root_ids: SmallVec::new() }\n+        DefIdForest::Empty\n     }\n \n     /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n     pub fn full(tcx: TyCtxt<'tcx>) -> DefIdForest {\n-        let crate_id = tcx.hir().local_def_id(CRATE_HIR_ID);\n-        DefIdForest::from_id(crate_id.to_def_id())\n+        DefIdForest::from_id(tcx.hir().local_def_id(CRATE_HIR_ID).to_def_id())\n     }\n \n     /// Creates a forest containing a `DefId` and all its descendants.\n     pub fn from_id(id: DefId) -> DefIdForest {\n-        let mut root_ids = SmallVec::new();\n-        root_ids.push(id);\n-        DefIdForest { root_ids }\n+        DefIdForest::Single(id)\n+    }\n+\n+    fn as_slice(&self) -> &[DefId] {\n+        match self {\n+            Empty => &[],\n+            Single(id) => std::slice::from_ref(id),\n+            Multiple(root_ids) => root_ids,\n+        }\n+    }\n+\n+    // Only allocates in the rare `Multiple` case.\n+    fn from_slice(root_ids: &[DefId]) -> DefIdForest {\n+        match root_ids {\n+            [] => Empty,\n+            [id] => Single(*id),\n+            _ => DefIdForest::Multiple(root_ids.into()),\n+        }\n     }\n \n     /// Tests whether the forest is empty.\n     pub fn is_empty(&self) -> bool {\n-        self.root_ids.is_empty()\n+        match self {\n+            Empty => true,\n+            Single(..) | Multiple(..) => false,\n+        }\n+    }\n+\n+    /// Iterate over the set of roots.\n+    fn iter(&self) -> impl Iterator<Item = DefId> + '_ {\n+        self.as_slice().iter().copied()\n     }\n \n     /// Tests whether the forest contains a given DefId.\n     pub fn contains(&self, tcx: TyCtxt<'tcx>, id: DefId) -> bool {\n-        self.root_ids.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n+        slice_contains(tcx, self.as_slice(), id)\n     }\n \n     /// Calculate the intersection of a collection of forests.\n@@ -58,56 +93,55 @@ impl<'tcx> DefIdForest {\n         I: IntoIterator<Item = DefIdForest>,\n     {\n         let mut iter = iter.into_iter();\n-        let mut ret = if let Some(first) = iter.next() {\n-            first\n+        let mut ret: SmallVec<[_; 1]> = if let Some(first) = iter.next() {\n+            SmallVec::from_slice(first.as_slice())\n         } else {\n             return DefIdForest::full(tcx);\n         };\n \n-        let mut next_ret = SmallVec::new();\n-        let mut old_ret: SmallVec<[DefId; 1]> = SmallVec::new();\n+        let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n         for next_forest in iter {\n             // No need to continue if the intersection is already empty.\n-            if ret.is_empty() {\n-                break;\n+            if ret.is_empty() || next_forest.is_empty() {\n+                return DefIdForest::empty();\n             }\n \n-            for id in ret.root_ids.drain(..) {\n-                if next_forest.contains(tcx, id) {\n-                    next_ret.push(id);\n-                } else {\n-                    old_ret.push(id);\n-                }\n-            }\n-            ret.root_ids.extend(old_ret.drain(..));\n+            // We keep the elements in `ret` that are also in `next_forest`.\n+            next_ret.extend(ret.iter().copied().filter(|&id| next_forest.contains(tcx, id)));\n+            // We keep the elements in `next_forest` that are also in `ret`.\n+            next_ret.extend(next_forest.iter().filter(|&id| slice_contains(tcx, &ret, id)));\n \n-            next_ret.extend(next_forest.root_ids.into_iter().filter(|&id| ret.contains(tcx, id)));\n-\n-            mem::swap(&mut next_ret, &mut ret.root_ids);\n-            next_ret.drain(..);\n+            mem::swap(&mut next_ret, &mut ret);\n+            next_ret.clear();\n         }\n-        ret\n+        DefIdForest::from_slice(&ret)\n     }\n \n     /// Calculate the union of a collection of forests.\n     pub fn union<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest\n     where\n         I: IntoIterator<Item = DefIdForest>,\n     {\n-        let mut ret = DefIdForest::empty();\n-        let mut next_ret = SmallVec::new();\n+        let mut ret: SmallVec<[_; 1]> = SmallVec::new();\n+        let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n         for next_forest in iter {\n-            next_ret.extend(ret.root_ids.drain(..).filter(|&id| !next_forest.contains(tcx, id)));\n+            // Union with the empty set is a no-op.\n+            if next_forest.is_empty() {\n+                continue;\n+            }\n \n-            for id in next_forest.root_ids {\n-                if !next_ret.contains(&id) {\n+            // We add everything in `ret` that is not in `next_forest`.\n+            next_ret.extend(ret.iter().copied().filter(|&id| !next_forest.contains(tcx, id)));\n+            // We add everything in `next_forest` that we haven't added yet.\n+            for id in next_forest.iter() {\n+                if !slice_contains(tcx, &next_ret, id) {\n                     next_ret.push(id);\n                 }\n             }\n \n-            mem::swap(&mut next_ret, &mut ret.root_ids);\n-            next_ret.drain(..);\n+            mem::swap(&mut next_ret, &mut ret);\n+            next_ret.clear();\n         }\n-        ret\n+        DefIdForest::from_slice(&ret)\n     }\n }"}, {"sha": "119cb135046dbf84e6a0cb8bb4da1880f995c571", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -6,7 +6,6 @@ use crate::ty::TyKind::*;\n use crate::ty::{AdtDef, FieldDef, Ty, TyS, VariantDef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::{DefId, SubstsRef};\n-use rustc_data_structures::stack::ensure_sufficient_stack;\n \n mod def_id_forest;\n \n@@ -187,34 +186,46 @@ impl<'tcx> FieldDef {\n \n impl<'tcx> TyS<'tcx> {\n     /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> DefIdForest {\n-        match *self.kind() {\n-            Adt(def, substs) => {\n-                ensure_sufficient_stack(|| def.uninhabited_from(tcx, substs, param_env))\n-            }\n+    fn uninhabited_from(\n+        &'tcx self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> DefIdForest {\n+        tcx.type_uninhabited_from(param_env.and(self))\n+    }\n+}\n \n-            Never => DefIdForest::full(tcx),\n+// Query provider for `type_uninhabited_from`.\n+pub(crate) fn type_uninhabited_from<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> DefIdForest {\n+    let ty = key.value;\n+    let param_env = key.param_env;\n+    match *ty.kind() {\n+        Adt(def, substs) => def.uninhabited_from(tcx, substs, param_env),\n \n-            Tuple(ref tys) => DefIdForest::union(\n-                tcx,\n-                tys.iter().map(|ty| ty.expect_ty().uninhabited_from(tcx, param_env)),\n-            ),\n+        Never => DefIdForest::full(tcx),\n \n-            Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n-                Some(0) | None => DefIdForest::empty(),\n-                // If the array is definitely non-empty, it's uninhabited if\n-                // the type of its elements is uninhabited.\n-                Some(1..) => ty.uninhabited_from(tcx, param_env),\n-            },\n+        Tuple(ref tys) => DefIdForest::union(\n+            tcx,\n+            tys.iter().map(|ty| ty.expect_ty().uninhabited_from(tcx, param_env)),\n+        ),\n \n-            // References to uninitialised memory are valid for any type, including\n-            // uninhabited types, in unsafe code, so we treat all references as\n-            // inhabited.\n-            // The precise semantics of inhabitedness with respect to references is currently\n-            // undecided.\n-            Ref(..) => DefIdForest::empty(),\n+        Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n+            Some(0) | None => DefIdForest::empty(),\n+            // If the array is definitely non-empty, it's uninhabited if\n+            // the type of its elements is uninhabited.\n+            Some(1..) => ty.uninhabited_from(tcx, param_env),\n+        },\n \n-            _ => DefIdForest::empty(),\n-        }\n+        // References to uninitialised memory are valid for any type, including\n+        // uninhabited types, in unsafe code, so we treat all references as\n+        // inhabited.\n+        // The precise semantics of inhabitedness with respect to references is currently\n+        // undecided.\n+        Ref(..) => DefIdForest::empty(),\n+\n+        _ => DefIdForest::empty(),\n     }\n }"}, {"sha": "9666affdbdf616288206a3ce8eefb90e43c71a24", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -3155,6 +3155,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         all_local_trait_impls: trait_def::all_local_trait_impls,\n+        type_uninhabited_from: inhabitedness::type_uninhabited_from,\n         ..*providers\n     };\n }"}, {"sha": "29a03c9e8b50c3cbaf39e5495591d060475dbdcc", "filename": "src/test/ui/pattern/usefulness/auxiliary/empty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fauxiliary%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fauxiliary%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fauxiliary%2Fempty.rs?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -1,2 +1,10 @@\n #![crate_type = \"rlib\"]\n pub enum EmptyForeignEnum {}\n+\n+pub struct VisiblyUninhabitedForeignStruct {\n+    pub field: EmptyForeignEnum,\n+}\n+\n+pub struct SecretlyUninhabitedForeignStruct {\n+    _priv: EmptyForeignEnum,\n+}"}, {"sha": "b99386e74020e8da394e86cf987b490000c32ffe", "filename": "src/test/ui/pattern/usefulness/empty-match.exhaustive_patterns.stderr", "status": "renamed", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -1,257 +1,257 @@\n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:52:9\n+  --> $DIR/empty-match.rs:37:9\n    |\n LL |         _ => {},\n    |         ^\n    |\n note: the lint level is defined here\n-  --> $DIR/match-empty-exhaustive_patterns.rs:5:9\n+  --> $DIR/empty-match.rs:8:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:55:9\n+  --> $DIR/empty-match.rs:40:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:62:9\n+  --> $DIR/empty-match.rs:47:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:65:9\n+  --> $DIR/empty-match.rs:50:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:72:9\n+  --> $DIR/empty-match.rs:57:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:75:9\n+  --> $DIR/empty-match.rs:60:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n-error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:82:9\n+error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n+  --> $DIR/empty-match.rs:78:20\n    |\n-LL |         Some(_) => {}\n-   |         ^^^^^^^\n-\n-error: unreachable pattern\n-  --> $DIR/match-empty-exhaustive_patterns.rs:86:9\n+LL |     match_no_arms!(0u8);\n+   |                    ^^^\n    |\n-LL |         Some(_) => {}\n-   |         ^^^^^^^\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n-  --> $DIR/match-empty-exhaustive_patterns.rs:89:18\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n+  --> $DIR/empty-match.rs:79:20\n    |\n-LL |     match_empty!(0u8);\n-   |                  ^^^\n+LL | struct NonEmptyStruct1;\n+   | ----------------------- `NonEmptyStruct1` defined here\n+...\n+LL |     match_no_arms!(NonEmptyStruct1);\n+   |                    ^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `u8`\n+   = note: the matched value is of type `NonEmptyStruct1`\n \n-error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n-  --> $DIR/match-empty-exhaustive_patterns.rs:91:18\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n+  --> $DIR/empty-match.rs:80:20\n    |\n-LL | struct NonEmptyStruct(bool);\n-   | ---------------------------- `NonEmptyStruct` defined here\n+LL | struct NonEmptyStruct2(bool);\n+   | ----------------------------- `NonEmptyStruct2` defined here\n ...\n-LL |     match_empty!(NonEmptyStruct(true));\n-   |                  ^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!(NonEmptyStruct2(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `NonEmptyStruct`\n+   = note: the matched value is of type `NonEmptyStruct2`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n-  --> $DIR/match-empty-exhaustive_patterns.rs:93:18\n+  --> $DIR/empty-match.rs:81:20\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n LL | | }\n    | |_- `NonEmptyUnion1` defined here\n ...\n-LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       match_no_arms!((NonEmptyUnion1 { foo: () }));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n-  --> $DIR/match-empty-exhaustive_patterns.rs:95:18\n+  --> $DIR/empty-match.rs:82:20\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n LL | |     bar: (),\n LL | | }\n    | |_- `NonEmptyUnion2` defined here\n ...\n-LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       match_no_arms!((NonEmptyUnion2 { foo: () }));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:97:18\n+  --> $DIR/empty-match.rs:83:20\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum1` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |       match_no_arms!(NonEmptyEnum1::Foo(true));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:99:18\n+  --> $DIR/empty-match.rs:84:20\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | |     Bar,\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum2` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |       match_no_arms!(NonEmptyEnum2::Foo(true));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:101:18\n+  --> $DIR/empty-match.rs:85:20\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n LL | | }\n    | |_- `NonEmptyEnum5` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |       match_no_arms!(NonEmptyEnum5::V1);\n+   |                      ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:104:18\n+  --> $DIR/empty-match.rs:87:24\n    |\n-LL |     match_false!(0u8);\n-   |                  ^^^ pattern `_` not covered\n+LL |     match_guarded_arm!(0u8);\n+   |                        ^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:106:18\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n+  --> $DIR/empty-match.rs:88:24\n+   |\n+LL | struct NonEmptyStruct1;\n+   | ----------------------- `NonEmptyStruct1` defined here\n+...\n+LL |     match_guarded_arm!(NonEmptyStruct1);\n+   |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct1`\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n+  --> $DIR/empty-match.rs:89:24\n    |\n-LL | struct NonEmptyStruct(bool);\n-   | ---------------------------- `NonEmptyStruct` defined here\n+LL | struct NonEmptyStruct2(bool);\n+   | ----------------------------- `NonEmptyStruct2` defined here\n ...\n-LL |     match_false!(NonEmptyStruct(true));\n-   |                  ^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct(_)` not covered\n+LL |     match_guarded_arm!(NonEmptyStruct2(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `NonEmptyStruct`\n+   = note: the matched value is of type `NonEmptyStruct2`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:108:18\n+  --> $DIR/empty-match.rs:90:24\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n LL | | }\n    | |_- `NonEmptyUnion1` defined here\n ...\n-LL |       match_false!((NonEmptyUnion1 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+LL |       match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:110:18\n+  --> $DIR/empty-match.rs:91:24\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n LL | |     bar: (),\n LL | | }\n    | |_- `NonEmptyUnion2` defined here\n ...\n-LL |       match_false!((NonEmptyUnion2 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+LL |       match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:112:18\n+  --> $DIR/empty-match.rs:92:24\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum1` defined here\n ...\n-LL |       match_false!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |       match_guarded_arm!(NonEmptyEnum1::Foo(true));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:114:18\n+  --> $DIR/empty-match.rs:93:24\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | |     Bar,\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum2` defined here\n ...\n-LL |       match_false!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |       match_guarded_arm!(NonEmptyEnum2::Foo(true));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty-exhaustive_patterns.rs:116:18\n+  --> $DIR/empty-match.rs:94:24\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n LL | | }\n    | |_- `NonEmptyEnum5` defined here\n ...\n-LL |       match_false!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |       match_guarded_arm!(NonEmptyEnum5::V1);\n+   |                          ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`", "previous_filename": "src/test/ui/pattern/usefulness/match-empty-exhaustive_patterns.stderr"}, {"sha": "b99386e74020e8da394e86cf987b490000c32ffe", "filename": "src/test/ui/pattern/usefulness/empty-match.normal.stderr", "status": "renamed", "additions": 82, "deletions": 70, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -1,249 +1,261 @@\n error: unreachable pattern\n-  --> $DIR/match-empty.rs:51:9\n+  --> $DIR/empty-match.rs:37:9\n    |\n LL |         _ => {},\n    |         ^\n    |\n note: the lint level is defined here\n-  --> $DIR/match-empty.rs:4:9\n+  --> $DIR/empty-match.rs:8:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-empty.rs:54:9\n+  --> $DIR/empty-match.rs:40:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/match-empty.rs:61:9\n+  --> $DIR/empty-match.rs:47:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/match-empty.rs:64:9\n+  --> $DIR/empty-match.rs:50:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/match-empty.rs:71:9\n+  --> $DIR/empty-match.rs:57:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/match-empty.rs:74:9\n+  --> $DIR/empty-match.rs:60:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n-  --> $DIR/match-empty.rs:89:18\n+  --> $DIR/empty-match.rs:78:20\n    |\n-LL |     match_empty!(0u8);\n-   |                  ^^^\n+LL |     match_no_arms!(0u8);\n+   |                    ^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n-  --> $DIR/match-empty.rs:91:18\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n+  --> $DIR/empty-match.rs:79:20\n    |\n-LL | struct NonEmptyStruct(bool);\n-   | ---------------------------- `NonEmptyStruct` defined here\n+LL | struct NonEmptyStruct1;\n+   | ----------------------- `NonEmptyStruct1` defined here\n ...\n-LL |     match_empty!(NonEmptyStruct(true));\n-   |                  ^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!(NonEmptyStruct1);\n+   |                    ^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `NonEmptyStruct`\n+   = note: the matched value is of type `NonEmptyStruct1`\n+\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n+  --> $DIR/empty-match.rs:80:20\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   | ----------------------------- `NonEmptyStruct2` defined here\n+...\n+LL |     match_no_arms!(NonEmptyStruct2(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct2`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n-  --> $DIR/match-empty.rs:93:18\n+  --> $DIR/empty-match.rs:81:20\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n LL | | }\n    | |_- `NonEmptyUnion1` defined here\n ...\n-LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       match_no_arms!((NonEmptyUnion1 { foo: () }));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n-  --> $DIR/match-empty.rs:95:18\n+  --> $DIR/empty-match.rs:82:20\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n LL | |     bar: (),\n LL | | }\n    | |_- `NonEmptyUnion2` defined here\n ...\n-LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       match_no_arms!((NonEmptyUnion2 { foo: () }));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty.rs:97:18\n+  --> $DIR/empty-match.rs:83:20\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum1` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |       match_no_arms!(NonEmptyEnum1::Foo(true));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty.rs:99:18\n+  --> $DIR/empty-match.rs:84:20\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | |     Bar,\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum2` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |       match_no_arms!(NonEmptyEnum2::Foo(true));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty.rs:101:18\n+  --> $DIR/empty-match.rs:85:20\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n LL | | }\n    | |_- `NonEmptyEnum5` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |       match_no_arms!(NonEmptyEnum5::V1);\n+   |                      ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/match-empty.rs:104:18\n+  --> $DIR/empty-match.rs:87:24\n    |\n-LL |     match_false!(0u8);\n-   |                  ^^^ pattern `_` not covered\n+LL |     match_guarded_arm!(0u8);\n+   |                        ^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n-  --> $DIR/match-empty.rs:106:18\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n+  --> $DIR/empty-match.rs:88:24\n+   |\n+LL | struct NonEmptyStruct1;\n+   | ----------------------- `NonEmptyStruct1` defined here\n+...\n+LL |     match_guarded_arm!(NonEmptyStruct1);\n+   |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct1`\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n+  --> $DIR/empty-match.rs:89:24\n    |\n-LL | struct NonEmptyStruct(bool);\n-   | ---------------------------- `NonEmptyStruct` defined here\n+LL | struct NonEmptyStruct2(bool);\n+   | ----------------------------- `NonEmptyStruct2` defined here\n ...\n-LL |     match_false!(NonEmptyStruct(true));\n-   |                  ^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct(_)` not covered\n+LL |     match_guarded_arm!(NonEmptyStruct2(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `NonEmptyStruct`\n+   = note: the matched value is of type `NonEmptyStruct2`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n-  --> $DIR/match-empty.rs:108:18\n+  --> $DIR/empty-match.rs:90:24\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n LL | | }\n    | |_- `NonEmptyUnion1` defined here\n ...\n-LL |       match_false!((NonEmptyUnion1 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+LL |       match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n-  --> $DIR/match-empty.rs:110:18\n+  --> $DIR/empty-match.rs:91:24\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n LL | |     bar: (),\n LL | | }\n    | |_- `NonEmptyUnion2` defined here\n ...\n-LL |       match_false!((NonEmptyUnion2 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+LL |       match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/match-empty.rs:112:18\n+  --> $DIR/empty-match.rs:92:24\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum1` defined here\n ...\n-LL |       match_false!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |       match_guarded_arm!(NonEmptyEnum1::Foo(true));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/match-empty.rs:114:18\n+  --> $DIR/empty-match.rs:93:24\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | |     Bar,\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum2` defined here\n ...\n-LL |       match_false!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |       match_guarded_arm!(NonEmptyEnum2::Foo(true));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/match-empty.rs:116:18\n+  --> $DIR/empty-match.rs:94:24\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n LL | | }\n    | |_- `NonEmptyEnum5` defined here\n ...\n-LL |       match_false!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |       match_guarded_arm!(NonEmptyEnum5::V1);\n+   |                          ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 22 previous errors\n \n For more information about this error, try `rustc --explain E0004`.", "previous_filename": "src/test/ui/pattern/usefulness/match-empty.stderr"}, {"sha": "8110ec013d7c1bd7ffc03951f8f764f1337ab770", "filename": "src/test/ui/pattern/usefulness/empty-match.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -0,0 +1,95 @@\n+// aux-build:empty.rs\n+// revisions: normal exhaustive_patterns\n+//\n+// This tests a match with no arms on various types.\n+#![feature(never_type)]\n+#![feature(never_type_fallback)]\n+#![cfg_attr(exhaustive_patterns, feature(exhaustive_patterns))]\n+#![deny(unreachable_patterns)]\n+\n+extern crate empty;\n+\n+enum EmptyEnum {}\n+\n+struct NonEmptyStruct1;\n+struct NonEmptyStruct2(bool);\n+union NonEmptyUnion1 {\n+    foo: (),\n+}\n+union NonEmptyUnion2 {\n+    foo: (),\n+    bar: (),\n+}\n+enum NonEmptyEnum1 {\n+    Foo(bool),\n+}\n+enum NonEmptyEnum2 {\n+    Foo(bool),\n+    Bar,\n+}\n+enum NonEmptyEnum5 {\n+    V1, V2, V3, V4, V5,\n+}\n+\n+fn empty_enum(x: EmptyEnum) {\n+    match x {} // ok\n+    match x {\n+        _ => {}, //~ ERROR unreachable pattern\n+    }\n+    match x {\n+        _ if false => {}, //~ ERROR unreachable pattern\n+    }\n+}\n+\n+fn empty_foreign_enum(x: empty::EmptyForeignEnum) {\n+    match x {} // ok\n+    match x {\n+        _ => {}, //~ ERROR unreachable pattern\n+    }\n+    match x {\n+        _ if false => {}, //~ ERROR unreachable pattern\n+    }\n+}\n+\n+fn never(x: !) {\n+    match x {} // ok\n+    match x {\n+        _ => {}, //~ ERROR unreachable pattern\n+    }\n+    match x {\n+        _ if false => {}, //~ ERROR unreachable pattern\n+    }\n+}\n+\n+macro_rules! match_no_arms {\n+    ($e:expr) => {\n+        match $e {}\n+    };\n+}\n+macro_rules! match_guarded_arm {\n+    ($e:expr) => {\n+        match $e {\n+            _ if false => {}\n+        }\n+    };\n+}\n+\n+fn main() {\n+    match_no_arms!(0u8); //~ ERROR type `u8` is non-empty\n+    match_no_arms!(NonEmptyStruct1); //~ ERROR type `NonEmptyStruct1` is non-empty\n+    match_no_arms!(NonEmptyStruct2(true)); //~ ERROR type `NonEmptyStruct2` is non-empty\n+    match_no_arms!((NonEmptyUnion1 { foo: () })); //~ ERROR type `NonEmptyUnion1` is non-empty\n+    match_no_arms!((NonEmptyUnion2 { foo: () })); //~ ERROR type `NonEmptyUnion2` is non-empty\n+    match_no_arms!(NonEmptyEnum1::Foo(true)); //~ ERROR `Foo(_)` not covered\n+    match_no_arms!(NonEmptyEnum2::Foo(true)); //~ ERROR `Foo(_)` and `Bar` not covered\n+    match_no_arms!(NonEmptyEnum5::V1); //~ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+\n+    match_guarded_arm!(0u8); //~ ERROR `_` not covered\n+    match_guarded_arm!(NonEmptyStruct1); //~ ERROR `NonEmptyStruct1` not covered\n+    match_guarded_arm!(NonEmptyStruct2(true)); //~ ERROR `NonEmptyStruct2(_)` not covered\n+    match_guarded_arm!((NonEmptyUnion1 { foo: () })); //~ ERROR `NonEmptyUnion1 { .. }` not covered\n+    match_guarded_arm!((NonEmptyUnion2 { foo: () })); //~ ERROR `NonEmptyUnion2 { .. }` not covered\n+    match_guarded_arm!(NonEmptyEnum1::Foo(true)); //~ ERROR `Foo(_)` not covered\n+    match_guarded_arm!(NonEmptyEnum2::Foo(true)); //~ ERROR `Foo(_)` and `Bar` not covered\n+    match_guarded_arm!(NonEmptyEnum5::V1); //~ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+}"}, {"sha": "9292f22e09e05fe01d01b4b94c67b5eb288d4543", "filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int-deny.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7a9b552cb1621c9c57898d147228aab32b65a7c3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int-deny.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9b552cb1621c9c57898d147228aab32b65a7c3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int-deny.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int-deny.rs?ref=7a9b552cb1621c9c57898d147228aab32b65a7c3", "patch": "@@ -1,48 +0,0 @@\n-#![feature(exclusive_range_pattern)]\n-\n-macro_rules! m {\n-    ($s:expr, $($t:tt)+) => {\n-        match $s { $($t)+ => {} }\n-    }\n-}\n-\n-fn main() {\n-    match 0usize {\n-        //~^ ERROR non-exhaustive patterns\n-        0 ..= usize::MAX => {}\n-    }\n-\n-    match 0isize {\n-        //~^ ERROR non-exhaustive patterns\n-        isize::MIN ..= isize::MAX => {}\n-    }\n-\n-    m!(0usize, 0..=usize::MAX);\n-    //~^ ERROR non-exhaustive patterns\n-    m!(0usize, 0..5 | 5..=usize::MAX);\n-    //~^ ERROR non-exhaustive patterns\n-    m!(0usize, 0..usize::MAX | usize::MAX);\n-    //~^ ERROR non-exhaustive patterns\n-    m!((0usize, true), (0..5, true) | (5..=usize::MAX, true) | (0..=usize::MAX, false));\n-    //~^ ERROR non-exhaustive patterns\n-\n-    m!(0isize, isize::MIN..=isize::MAX);\n-    //~^ ERROR non-exhaustive patterns\n-    m!(0isize, isize::MIN..5 | 5..=isize::MAX);\n-    //~^ ERROR non-exhaustive patterns\n-    m!(0isize, isize::MIN..isize::MAX | isize::MAX);\n-    //~^ ERROR non-exhaustive patterns\n-    m!((0isize, true), (isize::MIN..5, true)\n-        | (5..=isize::MAX, true) | (isize::MIN..=isize::MAX, false));\n-    //~^^ ERROR non-exhaustive patterns\n-\n-    match 0isize {\n-        //~^ ERROR non-exhaustive patterns\n-        isize::MIN ..= -1 => {}\n-        0 => {}\n-        1 ..= isize::MAX => {}\n-    }\n-\n-    match 7usize {}\n-    //~^ ERROR non-exhaustive patterns\n-}"}, {"sha": "2563293458379588806282642f8ba03488a4b968", "filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int.allow.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.allow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.allow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.allow.stderr?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: type `usize` is non-empty\n-  --> $DIR/pointer-sized-int-allow.rs:36:11\n+  --> $DIR/pointer-sized-int.rs:48:11\n    |\n LL |     match 7usize {}\n    |           ^^^^^^", "previous_filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int-allow.stderr"}, {"sha": "e8ac9f3cfe15633697828c909169053894fd1950", "filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int.deny.stderr", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.deny.stderr?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:10:11\n+  --> $DIR/pointer-sized-int.rs:12:11\n    |\n LL |     match 0usize {\n    |           ^^^^^^ pattern `_` not covered\n@@ -10,7 +10,7 @@ LL |     match 0usize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:15:11\n+  --> $DIR/pointer-sized-int.rs:17:11\n    |\n LL |     match 0isize {\n    |           ^^^^^^ pattern `_` not covered\n@@ -21,7 +21,7 @@ LL |     match 0isize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:20:8\n+  --> $DIR/pointer-sized-int.rs:22:8\n    |\n LL |     m!(0usize, 0..=usize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n@@ -32,7 +32,7 @@ LL |     m!(0usize, 0..=usize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:22:8\n+  --> $DIR/pointer-sized-int.rs:24:8\n    |\n LL |     m!(0usize, 0..5 | 5..=usize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n@@ -43,7 +43,7 @@ LL |     m!(0usize, 0..5 | 5..=usize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:24:8\n+  --> $DIR/pointer-sized-int.rs:26:8\n    |\n LL |     m!(0usize, 0..usize::MAX | usize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n@@ -54,7 +54,7 @@ LL |     m!(0usize, 0..usize::MAX | usize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `usize` matching\n \n error[E0004]: non-exhaustive patterns: `(_, _)` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:26:8\n+  --> $DIR/pointer-sized-int.rs:28:8\n    |\n LL |     m!((0usize, true), (0..5, true) | (5..=usize::MAX, true) | (0..=usize::MAX, false));\n    |        ^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n@@ -63,7 +63,7 @@ LL |     m!((0usize, true), (0..5, true) | (5..=usize::MAX, true) | (0..=usize::\n    = note: the matched value is of type `(usize, bool)`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:29:8\n+  --> $DIR/pointer-sized-int.rs:31:8\n    |\n LL |     m!(0isize, isize::MIN..=isize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n@@ -74,7 +74,7 @@ LL |     m!(0isize, isize::MIN..=isize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:31:8\n+  --> $DIR/pointer-sized-int.rs:33:8\n    |\n LL |     m!(0isize, isize::MIN..5 | 5..=isize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n@@ -85,7 +85,7 @@ LL |     m!(0isize, isize::MIN..5 | 5..=isize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:33:8\n+  --> $DIR/pointer-sized-int.rs:35:8\n    |\n LL |     m!(0isize, isize::MIN..isize::MAX | isize::MAX);\n    |        ^^^^^^ pattern `_` not covered\n@@ -96,7 +96,7 @@ LL |     m!(0isize, isize::MIN..isize::MAX | isize::MAX);\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n \n error[E0004]: non-exhaustive patterns: `(_, _)` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:35:8\n+  --> $DIR/pointer-sized-int.rs:37:8\n    |\n LL |     m!((0isize, true), (isize::MIN..5, true)\n    |        ^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n@@ -105,7 +105,7 @@ LL |     m!((0isize, true), (isize::MIN..5, true)\n    = note: the matched value is of type `(isize, bool)`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/pointer-sized-int-deny.rs:39:11\n+  --> $DIR/pointer-sized-int.rs:41:11\n    |\n LL |     match 0isize {\n    |           ^^^^^^ pattern `_` not covered\n@@ -116,7 +116,7 @@ LL |     match 0isize {\n    = help: add `#![feature(precise_pointer_size_matching)]` to the crate attributes to enable precise `isize` matching\n \n error[E0004]: non-exhaustive patterns: type `usize` is non-empty\n-  --> $DIR/pointer-sized-int-deny.rs:46:11\n+  --> $DIR/pointer-sized-int.rs:48:11\n    |\n LL |     match 7usize {}\n    |           ^^^^^^", "previous_filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int-deny.stderr"}, {"sha": "1ed18c26763582709b0bf34f4a75598bdf759b14", "filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int.rs", "status": "renamed", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Fpointer-sized-int.rs?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -1,5 +1,6 @@\n-#![feature(precise_pointer_size_matching)]\n+// revisions: allow deny\n #![feature(exclusive_range_pattern)]\n+#![cfg_attr(allow, feature(precise_pointer_size_matching))]\n \n macro_rules! m {\n     ($s:expr, $($t:tt)+) => {\n@@ -9,25 +10,36 @@ macro_rules! m {\n \n fn main() {\n     match 0usize {\n+        //[deny]~^ ERROR non-exhaustive patterns\n         0 ..= usize::MAX => {}\n     }\n \n     match 0isize {\n+        //[deny]~^ ERROR non-exhaustive patterns\n         isize::MIN ..= isize::MAX => {}\n     }\n \n     m!(0usize, 0..=usize::MAX);\n+    //[deny]~^ ERROR non-exhaustive patterns\n     m!(0usize, 0..5 | 5..=usize::MAX);\n+    //[deny]~^ ERROR non-exhaustive patterns\n     m!(0usize, 0..usize::MAX | usize::MAX);\n+    //[deny]~^ ERROR non-exhaustive patterns\n     m!((0usize, true), (0..5, true) | (5..=usize::MAX, true) | (0..=usize::MAX, false));\n+    //[deny]~^ ERROR non-exhaustive patterns\n \n     m!(0isize, isize::MIN..=isize::MAX);\n+    //[deny]~^ ERROR non-exhaustive patterns\n     m!(0isize, isize::MIN..5 | 5..=isize::MAX);\n+    //[deny]~^ ERROR non-exhaustive patterns\n     m!(0isize, isize::MIN..isize::MAX | isize::MAX);\n+    //[deny]~^ ERROR non-exhaustive patterns\n     m!((0isize, true), (isize::MIN..5, true)\n         | (5..=isize::MAX, true) | (isize::MIN..=isize::MAX, false));\n+    //[deny]~^^ ERROR non-exhaustive patterns\n \n     match 0isize {\n+        //[deny]~^ ERROR non-exhaustive patterns\n         isize::MIN ..= -1 => {}\n         0 => {}\n         1 ..= isize::MAX => {}", "previous_filename": "src/test/ui/pattern/usefulness/integer-ranges/pointer-sized-int-allow.rs"}, {"sha": "c5c3a214f9aff1d4f8a566040b2c12e597d0c2b5", "filename": "src/test/ui/pattern/usefulness/match-empty-exhaustive_patterns.rs", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7a9b552cb1621c9c57898d147228aab32b65a7c3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9b552cb1621c9c57898d147228aab32b65a7c3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.rs?ref=7a9b552cb1621c9c57898d147228aab32b65a7c3", "patch": "@@ -1,118 +0,0 @@\n-// aux-build:empty.rs\n-#![feature(never_type)]\n-#![feature(never_type_fallback)]\n-#![feature(exhaustive_patterns)]\n-#![deny(unreachable_patterns)]\n-\n-extern crate empty;\n-\n-enum EmptyEnum {}\n-\n-struct NonEmptyStruct(bool); //~ `NonEmptyStruct` defined here\n-union NonEmptyUnion1 { //~ `NonEmptyUnion1` defined here\n-    foo: (),\n-}\n-union NonEmptyUnion2 { //~ `NonEmptyUnion2` defined here\n-    foo: (),\n-    bar: (),\n-}\n-enum NonEmptyEnum1 { //~ `NonEmptyEnum1` defined here\n-    Foo(bool),\n-    //~^ not covered\n-    //~| not covered\n-}\n-enum NonEmptyEnum2 { //~ `NonEmptyEnum2` defined here\n-    Foo(bool),\n-    //~^ not covered\n-    //~| not covered\n-    Bar,\n-    //~^ not covered\n-    //~| not covered\n-}\n-enum NonEmptyEnum5 { //~ `NonEmptyEnum5` defined here\n-    V1, V2, V3, V4, V5,\n-}\n-\n-macro_rules! match_empty {\n-    ($e:expr) => {\n-        match $e {}\n-    };\n-}\n-macro_rules! match_false {\n-    ($e:expr) => {\n-        match $e {\n-            _ if false => {}\n-        }\n-    };\n-}\n-\n-fn empty_enum(x: EmptyEnum) {\n-    match x {} // ok\n-    match x {\n-        _ => {}, //~ ERROR unreachable pattern\n-    }\n-    match x {\n-        _ if false => {}, //~ ERROR unreachable pattern\n-    }\n-}\n-\n-fn empty_foreign_enum(x: empty::EmptyForeignEnum) {\n-    match x {} // ok\n-    match x {\n-        _ => {}, //~ ERROR unreachable pattern\n-    }\n-    match x {\n-        _ if false => {}, //~ ERROR unreachable pattern\n-    }\n-}\n-\n-fn never(x: !) {\n-    match x {} // ok\n-    match x {\n-        _ => {}, //~ ERROR unreachable pattern\n-    }\n-    match x {\n-        _ if false => {}, //~ ERROR unreachable pattern\n-    }\n-}\n-\n-fn main() {\n-    match None::<!> {\n-        None => {}\n-        Some(_) => {} //~ ERROR unreachable pattern\n-    }\n-    match None::<EmptyEnum> {\n-        None => {}\n-        Some(_) => {} //~ ERROR unreachable pattern\n-    }\n-\n-    match_empty!(0u8);\n-    //~^ ERROR type `u8` is non-empty\n-    match_empty!(NonEmptyStruct(true));\n-    //~^ ERROR type `NonEmptyStruct` is non-empty\n-    match_empty!((NonEmptyUnion1 { foo: () }));\n-    //~^ ERROR type `NonEmptyUnion1` is non-empty\n-    match_empty!((NonEmptyUnion2 { foo: () }));\n-    //~^ ERROR type `NonEmptyUnion2` is non-empty\n-    match_empty!(NonEmptyEnum1::Foo(true));\n-    //~^ ERROR `Foo(_)` not covered\n-    match_empty!(NonEmptyEnum2::Foo(true));\n-    //~^ ERROR `Foo(_)` and `Bar` not covered\n-    match_empty!(NonEmptyEnum5::V1);\n-    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n-\n-    match_false!(0u8);\n-    //~^ ERROR `_` not covered\n-    match_false!(NonEmptyStruct(true));\n-    //~^ ERROR `NonEmptyStruct(_)` not covered\n-    match_false!((NonEmptyUnion1 { foo: () }));\n-    //~^ ERROR `NonEmptyUnion1 { .. }` not covered\n-    match_false!((NonEmptyUnion2 { foo: () }));\n-    //~^ ERROR `NonEmptyUnion2 { .. }` not covered\n-    match_false!(NonEmptyEnum1::Foo(true));\n-    //~^ ERROR `Foo(_)` not covered\n-    match_false!(NonEmptyEnum2::Foo(true));\n-    //~^ ERROR `Foo(_)` and `Bar` not covered\n-    match_false!(NonEmptyEnum5::V1);\n-    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n-}"}, {"sha": "10ea2a10406e367079f73c60ac4dd2bf17640fb4", "filename": "src/test/ui/pattern/usefulness/match-empty.rs", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7a9b552cb1621c9c57898d147228aab32b65a7c3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9b552cb1621c9c57898d147228aab32b65a7c3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs?ref=7a9b552cb1621c9c57898d147228aab32b65a7c3", "patch": "@@ -1,118 +0,0 @@\n-// aux-build:empty.rs\n-#![feature(never_type)]\n-#![feature(never_type_fallback)]\n-#![deny(unreachable_patterns)]\n-\n-extern crate empty;\n-\n-enum EmptyEnum {}\n-\n-struct NonEmptyStruct(bool); //~ `NonEmptyStruct` defined here\n-union NonEmptyUnion1 { //~ `NonEmptyUnion1` defined here\n-    foo: (),\n-}\n-union NonEmptyUnion2 { //~ `NonEmptyUnion2` defined here\n-    foo: (),\n-    bar: (),\n-}\n-enum NonEmptyEnum1 { //~ `NonEmptyEnum1` defined here\n-    Foo(bool),\n-    //~^ not covered\n-    //~| not covered\n-}\n-enum NonEmptyEnum2 { //~ `NonEmptyEnum2` defined here\n-    Foo(bool),\n-    //~^ not covered\n-    //~| not covered\n-    Bar,\n-    //~^ not covered\n-    //~| not covered\n-}\n-enum NonEmptyEnum5 { //~ `NonEmptyEnum5` defined here\n-    V1, V2, V3, V4, V5,\n-}\n-\n-macro_rules! match_empty {\n-    ($e:expr) => {\n-        match $e {}\n-    };\n-}\n-macro_rules! match_false {\n-    ($e:expr) => {\n-        match $e {\n-            _ if false => {}\n-        }\n-    };\n-}\n-\n-fn empty_enum(x: EmptyEnum) {\n-    match x {} // ok\n-    match x {\n-        _ => {}, //~ ERROR unreachable pattern\n-    }\n-    match x {\n-        _ if false => {}, //~ ERROR unreachable pattern\n-    }\n-}\n-\n-fn empty_foreign_enum(x: empty::EmptyForeignEnum) {\n-    match x {} // ok\n-    match x {\n-        _ => {}, //~ ERROR unreachable pattern\n-    }\n-    match x {\n-        _ if false => {}, //~ ERROR unreachable pattern\n-    }\n-}\n-\n-fn never(x: !) {\n-    match x {} // ok\n-    match x {\n-        _ => {}, //~ ERROR unreachable pattern\n-    }\n-    match x {\n-        _ if false => {}, //~ ERROR unreachable pattern\n-    }\n-}\n-\n-fn main() {\n-    // `exhaustive_patterns` is not on, so uninhabited branches are not detected as unreachable.\n-    match None::<!> {\n-        None => {}\n-        Some(_) => {}\n-    }\n-    match None::<EmptyEnum> {\n-        None => {}\n-        Some(_) => {}\n-    }\n-\n-    match_empty!(0u8);\n-    //~^ ERROR type `u8` is non-empty\n-    match_empty!(NonEmptyStruct(true));\n-    //~^ ERROR type `NonEmptyStruct` is non-empty\n-    match_empty!((NonEmptyUnion1 { foo: () }));\n-    //~^ ERROR type `NonEmptyUnion1` is non-empty\n-    match_empty!((NonEmptyUnion2 { foo: () }));\n-    //~^ ERROR type `NonEmptyUnion2` is non-empty\n-    match_empty!(NonEmptyEnum1::Foo(true));\n-    //~^ ERROR `Foo(_)` not covered\n-    match_empty!(NonEmptyEnum2::Foo(true));\n-    //~^ ERROR `Foo(_)` and `Bar` not covered\n-    match_empty!(NonEmptyEnum5::V1);\n-    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n-\n-    match_false!(0u8);\n-    //~^ ERROR `_` not covered\n-    match_false!(NonEmptyStruct(true));\n-    //~^ ERROR `NonEmptyStruct(_)` not covered\n-    match_false!((NonEmptyUnion1 { foo: () }));\n-    //~^ ERROR `NonEmptyUnion1 { .. }` not covered\n-    match_false!((NonEmptyUnion2 { foo: () }));\n-    //~^ ERROR `NonEmptyUnion2 { .. }` not covered\n-    match_false!(NonEmptyEnum1::Foo(true));\n-    //~^ ERROR `Foo(_)` not covered\n-    match_false!(NonEmptyEnum2::Foo(true));\n-    //~^ ERROR `Foo(_)` and `Bar` not covered\n-    match_false!(NonEmptyEnum5::V1);\n-    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n-}"}, {"sha": "77cd0f4005e95426cb21496f8589eff4485bec98", "filename": "src/test/ui/pattern/usefulness/uninhabited.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funinhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/058a71016553f267ae80b90276ef79956457d51a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funinhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funinhabited.rs?ref=058a71016553f267ae80b90276ef79956457d51a", "patch": "@@ -0,0 +1,143 @@\n+// check-pass\n+// aux-build:empty.rs\n+//\n+// This tests plays with matching and uninhabited types. This also serves as a test for the\n+// `tcx.is_ty_uninhabited_from()` function.\n+#![feature(never_type)]\n+#![feature(never_type_fallback)]\n+#![feature(exhaustive_patterns)]\n+#![deny(unreachable_patterns)]\n+\n+macro_rules! assert_empty {\n+    ($ty:ty) => {\n+        const _: () = {\n+            fn assert_empty(x: $ty) {\n+                match x {}\n+                match Some(x) {\n+                    None => {}\n+                }\n+            }\n+        };\n+    };\n+}\n+macro_rules! assert_non_empty {\n+    ($ty:ty) => {\n+        const _: () = {\n+            fn assert_non_empty(x: $ty) {\n+                match x {\n+                    _ => {}\n+                }\n+                match Some(x) {\n+                    None => {}\n+                    Some(_) => {}\n+                }\n+            }\n+        };\n+    };\n+}\n+\n+extern crate empty;\n+assert_empty!(empty::EmptyForeignEnum);\n+assert_empty!(empty::VisiblyUninhabitedForeignStruct);\n+assert_non_empty!(empty::SecretlyUninhabitedForeignStruct);\n+\n+enum Void {}\n+assert_empty!(Void);\n+\n+enum Enum2 {\n+    Foo(Void),\n+    Bar(!),\n+}\n+assert_empty!(Enum2);\n+\n+enum Enum3 {\n+    Foo(Void),\n+    Bar {\n+        x: u64,\n+        y: !,\n+    },\n+}\n+assert_empty!(Enum3);\n+\n+enum Enum4 {\n+    Foo(u64),\n+    Bar(!),\n+}\n+assert_non_empty!(Enum4);\n+\n+struct Struct1(empty::EmptyForeignEnum);\n+assert_empty!(Struct1);\n+\n+struct Struct2 {\n+    x: u64,\n+    y: !,\n+}\n+assert_empty!(Struct2);\n+\n+union Union {\n+    foo: !,\n+}\n+assert_non_empty!(Union);\n+\n+assert_empty!((!, String));\n+\n+assert_non_empty!(&'static !);\n+assert_non_empty!(&'static Struct1);\n+assert_non_empty!(&'static &'static &'static !);\n+\n+assert_empty!([!; 1]);\n+assert_empty!([Void; 2]);\n+assert_non_empty!([!; 0]);\n+assert_non_empty!(&'static [!]);\n+\n+mod visibility {\n+    /// This struct can only be seen to be inhabited in modules `b`, `c` or `d`, because otherwise\n+    /// the uninhabitedness of both `SecretlyUninhabited` structs is hidden.\n+    struct SometimesEmptyStruct {\n+        x: a::b::SecretlyUninhabited,\n+        y: c::AlsoSecretlyUninhabited,\n+    }\n+\n+    /// This enum can only be seen to be inhabited in module `d`.\n+    enum SometimesEmptyEnum {\n+        X(c::AlsoSecretlyUninhabited),\n+        Y(c::d::VerySecretlyUninhabited),\n+    }\n+\n+    mod a {\n+        use super::*;\n+        pub mod b {\n+            use super::*;\n+            pub struct SecretlyUninhabited {\n+                _priv: !,\n+            }\n+            assert_empty!(SometimesEmptyStruct);\n+        }\n+\n+        assert_non_empty!(SometimesEmptyStruct);\n+        assert_non_empty!(SometimesEmptyEnum);\n+    }\n+\n+    mod c {\n+        use super::*;\n+        pub struct AlsoSecretlyUninhabited {\n+            _priv: ::Struct1,\n+        }\n+        assert_empty!(SometimesEmptyStruct);\n+        assert_non_empty!(SometimesEmptyEnum);\n+\n+        pub mod d {\n+            use super::*;\n+            pub struct VerySecretlyUninhabited {\n+                _priv: !,\n+            }\n+            assert_empty!(SometimesEmptyStruct);\n+            assert_empty!(SometimesEmptyEnum);\n+        }\n+    }\n+\n+    assert_non_empty!(SometimesEmptyStruct);\n+    assert_non_empty!(SometimesEmptyEnum);\n+}\n+\n+fn main() {}"}]}