{"sha": "be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f", "node_id": "C_kwDOAAsO6NoAKGJlNWI3Nzc4YzgwMzAzYmNiOWI4ZTgyNTFmOWJmNWJlOGVkM2M1N2Y", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-11-18T00:52:28Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-11-18T01:01:05Z"}, "message": "Replace try_upvars_resolved with try_to_place", "tree": {"sha": "814a0479ca533218d7754e09abe53834c2ed29f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/814a0479ca533218d7754e09abe53834c2ed29f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f", "html_url": "https://github.com/rust-lang/rust/commit/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c819792a7a5252989024592ea8a17c4da42056c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c819792a7a5252989024592ea8a17c4da42056c", "html_url": "https://github.com/rust-lang/rust/commit/1c819792a7a5252989024592ea8a17c4da42056c"}], "stats": {"total": 86, "additions": 35, "deletions": 51}, "files": [{"sha": "4466ae595f88cac2d87e3cadbee4996d757c596f", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f", "patch": "@@ -267,14 +267,13 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         }\n     }\n \n-    pub(in crate::build) fn try_upvars_resolved(\n-        self,\n-        cx: &Builder<'_, 'tcx>,\n-    ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-        match self.base {\n-            PlaceBase::Local(_) => Ok(self),\n-            PlaceBase::Upvar { .. } => self.resolve_upvar(cx).ok_or(self),\n-        }\n+    /// Creates a `Place` or returns `None` if an upvar cannot be resolved\n+    pub(in crate::build) fn try_to_place(&self, cx: &Builder<'_, 'tcx>) -> Option<Place<'tcx>> {\n+        let resolved = self.resolve_upvar(cx);\n+        let builder = resolved.as_ref().unwrap_or(self);\n+        let PlaceBase::Local(local) = builder.base else { return None };\n+        let projection = cx.tcx.intern_place_elems(&builder.projection);\n+        Some(Place { local, projection })\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`."}, {"sha": "9f80f34b56633021db895930180e6a30d10049e4", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f", "patch": "@@ -369,8 +369,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let place_builder =\n                         unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n \n-                    if let Ok(place_builder_resolved) = place_builder.try_upvars_resolved(this) {\n-                        let mir_place = place_builder_resolved.into_place(this);\n+                    if let Some(mir_place) = place_builder.try_to_place(this) {\n                         this.cfg.push_fake_read(\n                             block,\n                             this.source_info(this.tcx.hir().span(*hir_id)),"}, {"sha": "a7d89db8baab712e4c85562fcfc105a5c2800ceb", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f", "patch": "@@ -220,8 +220,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let cause_matched_place = FakeReadCause::ForMatchedPlace(None);\n         let source_info = self.source_info(scrutinee_span);\n \n-        if let Ok(scrutinee_builder) = scrutinee_place_builder.clone().try_upvars_resolved(self) {\n-            let scrutinee_place = scrutinee_builder.into_place(self);\n+        if let Some(scrutinee_place) = scrutinee_place_builder.try_to_place(self) {\n             self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n         }\n \n@@ -334,7 +333,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let arm_scope = (arm.scope, arm_source_info);\n                 let match_scope = self.local_scope();\n                 self.in_scope(arm_scope, arm.lint_level, |this| {\n-                    // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                    // `try_to_place` may fail if it is unable to resolve the given\n                     // `PlaceBuilder` inside a closure. In this case, we don't want to include\n                     // a scrutinee place. `scrutinee_place_builder` will fail to be resolved\n                     // if the only match arm is a wildcard (`_`).\n@@ -345,14 +344,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     //    match foo { _ => () };\n                     // };\n                     // ```\n-                    let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n-                    let scrutinee_place: Place<'tcx>;\n-                    if let Ok(scrutinee_builder) =\n-                        scrutinee_place_builder.clone().try_upvars_resolved(this)\n-                    {\n-                        scrutinee_place = scrutinee_builder.into_place(this);\n-                        opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n-                    }\n+                    let scrutinee_place = scrutinee_place_builder.try_to_place(this);\n+                    let opt_scrutinee_place =\n+                        scrutinee_place.as_ref().map(|place| (Some(place), scrutinee_span));\n                     let scope = this.declare_bindings(\n                         None,\n                         arm.span,\n@@ -591,7 +585,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             while let Some(next) = {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n-                    // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                    // `try_to_place` may fail if it is unable to resolve the given\n                     // `PlaceBuilder` inside a closure. In this case, we don't want to include\n                     // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n                     // assignments. This is because a closure only captures the precise places\n@@ -605,9 +599,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     //    let (v1, v2) = foo;\n                     // };\n                     // ```\n-                    if let Ok(match_pair_resolved) = initializer.clone().try_upvars_resolved(self) {\n-                        let place = match_pair_resolved.into_place(self);\n-\n+                    if let Some(place) = initializer.try_to_place(self) {\n                         let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                             VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n                         )))) = self.local_decls[local].local_info else {\n@@ -1594,10 +1586,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         // Insert a Shallow borrow of any places that is switched on.\n-        if let Some(fb) = fake_borrows && let Ok(match_place_resolved) =\n-            match_place.clone().try_upvars_resolved(self)\n+        if let Some(fb) = fake_borrows\n+            && let Some(resolved_place) = match_place.try_to_place(self)\n         {\n-            let resolved_place = match_place_resolved.into_place(self);\n             fb.insert(resolved_place);\n         }\n \n@@ -1788,12 +1779,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             false,\n             &mut [&mut guard_candidate, &mut otherwise_candidate],\n         );\n-        let mut opt_expr_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n-        let expr_place: Place<'tcx>;\n-        if let Ok(expr_builder) = expr_place_builder.try_upvars_resolved(self) {\n-            expr_place = expr_builder.into_place(self);\n-            opt_expr_place = Some((Some(&expr_place), expr_span));\n-        }\n+        let expr_place = expr_place_builder.try_to_place(self);\n+        let opt_expr_place = expr_place.as_ref().map(|place| (Some(place), expr_span));\n         let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n         self.break_for_else(otherwise_post_guard_block, else_target, self.source_info(expr_span));\n "}, {"sha": "55a00758de1ba88fc1ec6d32ca9275d95e35623d", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f", "patch": "@@ -156,10 +156,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription: thir::Ascription { ref annotation, variance },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n-                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n+                if let Some(source) = match_pair.place.try_to_place(self) {\n                     candidate.ascriptions.push(Ascription {\n                         annotation: annotation.clone(),\n-                        source: place_resolved.into_place(self),\n+                        source,\n                         variance,\n                     });\n                 }\n@@ -183,10 +183,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ref subpattern,\n                 is_primary: _,\n             } => {\n-                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n+                if let Some(source) = match_pair.place.try_to_place(self) {\n                     candidate.bindings.push(Binding {\n                         span: match_pair.pattern.span,\n-                        source: place_resolved.into_place(self),\n+                        source,\n                         var_id: var,\n                         binding_mode: mode,\n                     });"}, {"sha": "72ee8cf97593e5e5f7d34110a6ddc647bcf3d075", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=be5b7778c80303bcb9b8e8251f9bf5be8ed3c57f", "patch": "@@ -33,15 +33,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         suffix: &'pat [Box<Pat<'tcx>>],\n     ) {\n         let tcx = self.tcx;\n-        let (min_length, exact_size) =\n-            if let Ok(place_resolved) = place.clone().try_upvars_resolved(self) {\n-                match place_resolved.into_place(self).ty(&self.local_decls, tcx).ty.kind() {\n-                    ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n-                    _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n-                }\n-            } else {\n-                ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n-            };\n+        let (min_length, exact_size) = if let Some(place_resolved) = place.try_to_place(self) {\n+            match place_resolved.ty(&self.local_decls, tcx).ty.kind() {\n+                ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n+                _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n+            }\n+        } else {\n+            ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n+        };\n \n         match_pairs.extend(prefix.iter().enumerate().map(|(idx, subpattern)| {\n             let elem =\n@@ -97,15 +96,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n     pub(in crate::build) fn new(\n-        place: PlaceBuilder<'tcx>,\n+        mut place: PlaceBuilder<'tcx>,\n         pattern: &'pat Pat<'tcx>,\n         cx: &Builder<'_, 'tcx>,\n     ) -> MatchPair<'pat, 'tcx> {\n         // Force the place type to the pattern's type.\n         // FIXME(oli-obk): can we use this to simplify slice/array pattern hacks?\n-        let mut place = match place.try_upvars_resolved(cx) {\n-            Ok(val) | Err(val) => val,\n-        };\n+        if let Some(resolved) = place.resolve_upvar(cx) {\n+            place = resolved;\n+        }\n \n         // Only add the OpaqueCast projection if the given place is an opaque type and the\n         // expected type from the pattern is not."}]}