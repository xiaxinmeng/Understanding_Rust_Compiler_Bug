{"sha": "75ef735d4a2e159e083889a22902a40d8265fced", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZWY3MzVkNGEyZTE1OWUwODM4ODlhMjI5MDJhNDBkODI2NWZjZWQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-16T20:36:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-16T20:36:43Z"}, "message": "Rollup merge of #77855 - davidtwco:pr-77341-follow-up-non-constructable-variants, r=estebank\n\nresolve: further improvements to \"try using the enum's variant\" diagnostic\n\nFollow-up on https://github.com/rust-lang/rust/pull/77341#issuecomment-702738281.\n\nThis PR improves the diagnostic modified in #77341 to suggest not only those variants which do not have fields, but those with fields (by suggesting with placeholders). In addition, the wording of the tuple-variant-only case is improved slightly.\n\nI've not made further changes to the tuple-variant-only case (e.g. to only suggest variants with the correct number of fields) because I don't think I have enough information to do so reliably (e.g. in the case where there is an attempt to construct a tuple variant, I have no information on how many fields were provided; and in the case of pattern matching, I only have a slice of spans and would need to check for things like `..` in those spans, which doesn't seem worth it).\n\nr? @estebank", "tree": {"sha": "b6a9052f9bb2b16d9d21b97d6b0eef7d60d80a3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6a9052f9bb2b16d9d21b97d6b0eef7d60d80a3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75ef735d4a2e159e083889a22902a40d8265fced", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfigRbCRBK7hj4Ov3rIwAAdHIIALK8PyWEmOYZoAZ/cZXItrDo\nhV+Hz9aETCsQQ4xStmzYmBUShvZjeijwvSxyXEFIAKHKs/lRYFyiYg0zb5kESg1B\n22dlF65jsVBqjj997Dy9fN664vEXSVxJWPg2aGAY1/EM2o8+4DHDQeCJktoaKgAo\nO5bQ7TAs4e3Ibs+UVRXZsACDCC7wve0MzFOsetMp37hmd+y5xMGnDp4nVobH2ENs\nPRTrr9R1Jp7shzi8W8wOKvM5JuliXW29B3LSbGXQ2lO/Cl5Z5kLiQ/SAV2qLtV13\nh8SURf5nvp6Tpt3IjwHcc/XjdDwm+tC3iRviwvazsUdb37/dRX2jjcQsF9jBeuQ=\n=jA7A\n-----END PGP SIGNATURE-----\n", "payload": "tree b6a9052f9bb2b16d9d21b97d6b0eef7d60d80a3e\nparent 8c4d8555f3071fd481a37db50c7b647dcf3ed34a\nparent f897162f3efc841461adce9510bb627cea9bac45\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1602880603 +0900\ncommitter GitHub <noreply@github.com> 1602880603 +0900\n\nRollup merge of #77855 - davidtwco:pr-77341-follow-up-non-constructable-variants, r=estebank\n\nresolve: further improvements to \"try using the enum's variant\" diagnostic\n\nFollow-up on https://github.com/rust-lang/rust/pull/77341#issuecomment-702738281.\n\nThis PR improves the diagnostic modified in #77341 to suggest not only those variants which do not have fields, but those with fields (by suggesting with placeholders). In addition, the wording of the tuple-variant-only case is improved slightly.\n\nI've not made further changes to the tuple-variant-only case (e.g. to only suggest variants with the correct number of fields) because I don't think I have enough information to do so reliably (e.g. in the case where there is an attempt to construct a tuple variant, I have no information on how many fields were provided; and in the case of pattern matching, I only have a slice of spans and would need to check for things like `..` in those spans, which doesn't seem worth it).\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75ef735d4a2e159e083889a22902a40d8265fced", "html_url": "https://github.com/rust-lang/rust/commit/75ef735d4a2e159e083889a22902a40d8265fced", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75ef735d4a2e159e083889a22902a40d8265fced/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c4d8555f3071fd481a37db50c7b647dcf3ed34a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4d8555f3071fd481a37db50c7b647dcf3ed34a", "html_url": "https://github.com/rust-lang/rust/commit/8c4d8555f3071fd481a37db50c7b647dcf3ed34a"}, {"sha": "f897162f3efc841461adce9510bb627cea9bac45", "url": "https://api.github.com/repos/rust-lang/rust/commits/f897162f3efc841461adce9510bb627cea9bac45", "html_url": "https://github.com/rust-lang/rust/commit/f897162f3efc841461adce9510bb627cea9bac45"}], "stats": {"total": 403, "additions": 318, "deletions": 85}, "files": [{"sha": "c24b383f3b81171d39eea893f9137cad1f19d333", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 88, "deletions": 62, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/75ef735d4a2e159e083889a22902a40d8265fced/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ef735d4a2e159e083889a22902a40d8265fced/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=75ef735d4a2e159e083889a22902a40d8265fced", "patch": "@@ -1330,58 +1330,17 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         let suggest_only_tuple_variants =\n             matches!(source, PathSource::TupleStruct(..)) || source.is_call();\n-        let mut suggestable_variants = if suggest_only_tuple_variants {\n+        if suggest_only_tuple_variants {\n             // Suggest only tuple variants regardless of whether they have fields and do not\n             // suggest path with added parenthesis.\n-            variants\n+            let mut suggestable_variants = variants\n                 .iter()\n                 .filter(|(.., kind)| *kind == CtorKind::Fn)\n                 .map(|(variant, ..)| path_names_to_string(variant))\n-                .collect::<Vec<_>>()\n-        } else {\n-            variants\n-                .iter()\n-                .filter(|(_, def_id, kind)| {\n-                    // Suggest only variants that have no fields (these can definitely\n-                    // be constructed).\n-                    let has_fields =\n-                        self.r.field_names.get(&def_id).map(|f| f.is_empty()).unwrap_or(false);\n-                    match kind {\n-                        CtorKind::Const => true,\n-                        CtorKind::Fn | CtorKind::Fictive if has_fields => true,\n-                        _ => false,\n-                    }\n-                })\n-                .map(|(variant, _, kind)| (path_names_to_string(variant), kind))\n-                .map(|(variant_str, kind)| {\n-                    // Add constructor syntax where appropriate.\n-                    match kind {\n-                        CtorKind::Const => variant_str,\n-                        CtorKind::Fn => format!(\"({}())\", variant_str),\n-                        CtorKind::Fictive => format!(\"({} {{}})\", variant_str),\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-        };\n-\n-        let non_suggestable_variant_count = variants.len() - suggestable_variants.len();\n+                .collect::<Vec<_>>();\n \n-        if !suggestable_variants.is_empty() {\n-            let msg = if non_suggestable_variant_count == 0 && suggestable_variants.len() == 1 {\n-                \"try using the enum's variant\"\n-            } else {\n-                \"try using one of the enum's variants\"\n-            };\n+            let non_suggestable_variant_count = variants.len() - suggestable_variants.len();\n \n-            err.span_suggestions(\n-                span,\n-                msg,\n-                suggestable_variants.drain(..),\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-\n-        if suggest_only_tuple_variants {\n             let source_msg = if source.is_call() {\n                 \"to construct\"\n             } else if matches!(source, PathSource::TupleStruct(..)) {\n@@ -1390,6 +1349,21 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 unreachable!()\n             };\n \n+            if !suggestable_variants.is_empty() {\n+                let msg = if non_suggestable_variant_count == 0 && suggestable_variants.len() == 1 {\n+                    format!(\"try {} the enum's variant\", source_msg)\n+                } else {\n+                    format!(\"try {} one of the enum's variants\", source_msg)\n+                };\n+\n+                err.span_suggestions(\n+                    span,\n+                    &msg,\n+                    suggestable_variants.drain(..),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n             // If the enum has no tuple variants..\n             if non_suggestable_variant_count == variants.len() {\n                 err.help(&format!(\"the enum has no tuple variants {}\", source_msg));\n@@ -1408,24 +1382,76 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 ));\n             }\n         } else {\n-            let made_suggestion = non_suggestable_variant_count != variants.len();\n-            if made_suggestion {\n-                if non_suggestable_variant_count == 1 {\n-                    err.help(\n-                        \"you might have meant to use the enum's other variant that has fields\",\n-                    );\n-                } else if non_suggestable_variant_count >= 1 {\n-                    err.help(\n-                        \"you might have meant to use one of the enum's other variants that \\\n-                         have fields\",\n-                    );\n-                }\n-            } else {\n-                if non_suggestable_variant_count == 1 {\n-                    err.help(\"you might have meant to use the enum's variant\");\n-                } else if non_suggestable_variant_count >= 1 {\n-                    err.help(\"you might have meant to use one of the enum's variants\");\n+            let needs_placeholder = |def_id: DefId, kind: CtorKind| {\n+                let has_no_fields =\n+                    self.r.field_names.get(&def_id).map(|f| f.is_empty()).unwrap_or(false);\n+                match kind {\n+                    CtorKind::Const => false,\n+                    CtorKind::Fn | CtorKind::Fictive if has_no_fields => false,\n+                    _ => true,\n                 }\n+            };\n+\n+            let mut suggestable_variants = variants\n+                .iter()\n+                .filter(|(_, def_id, kind)| !needs_placeholder(*def_id, *kind))\n+                .map(|(variant, _, kind)| (path_names_to_string(variant), kind))\n+                .map(|(variant, kind)| match kind {\n+                    CtorKind::Const => variant,\n+                    CtorKind::Fn => format!(\"({}())\", variant),\n+                    CtorKind::Fictive => format!(\"({} {{}})\", variant),\n+                })\n+                .collect::<Vec<_>>();\n+\n+            if !suggestable_variants.is_empty() {\n+                let msg = if suggestable_variants.len() == 1 {\n+                    \"you might have meant to use the following enum variant\"\n+                } else {\n+                    \"you might have meant to use one of the following enum variants\"\n+                };\n+\n+                err.span_suggestions(\n+                    span,\n+                    msg,\n+                    suggestable_variants.drain(..),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n+            let mut suggestable_variants_with_placeholders = variants\n+                .iter()\n+                .filter(|(_, def_id, kind)| needs_placeholder(*def_id, *kind))\n+                .map(|(variant, _, kind)| (path_names_to_string(variant), kind))\n+                .filter_map(|(variant, kind)| match kind {\n+                    CtorKind::Fn => Some(format!(\"({}(/* fields */))\", variant)),\n+                    CtorKind::Fictive => Some(format!(\"({} {{ /* fields */ }})\", variant)),\n+                    _ => None,\n+                })\n+                .collect::<Vec<_>>();\n+\n+            if !suggestable_variants_with_placeholders.is_empty() {\n+                let msg = match (\n+                    suggestable_variants.is_empty(),\n+                    suggestable_variants_with_placeholders.len(),\n+                ) {\n+                    (true, 1) => \"the following enum variant is available\",\n+                    (true, _) => \"the following enum variants are available\",\n+                    (false, 1) => \"alternatively, the following enum variant is available\",\n+                    (false, _) => \"alternatively, the following enum variants are also available\",\n+                };\n+\n+                err.span_suggestions(\n+                    span,\n+                    msg,\n+                    suggestable_variants_with_placeholders.drain(..),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+        };\n+\n+        if def_id.is_local() {\n+            if let Some(span) = self.def_span(def_id) {\n+                err.span_note(span, \"the enum is defined here\");\n             }\n         }\n     }"}, {"sha": "bca493e67d5431a152685ad4302b93da8ec180ce", "filename": "src/test/ui/did_you_mean/issue-43871-enum-instead-of-variant.stderr", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/75ef735d4a2e159e083889a22902a40d8265fced/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-43871-enum-instead-of-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ef735d4a2e159e083889a22902a40d8265fced/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-43871-enum-instead-of-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-43871-enum-instead-of-variant.stderr?ref=75ef735d4a2e159e083889a22902a40d8265fced", "patch": "@@ -2,25 +2,30 @@ error[E0423]: expected function, tuple struct or tuple variant, found enum `Opti\n   --> $DIR/issue-43871-enum-instead-of-variant.rs:19:13\n    |\n LL |     let x = Option(1);\n-   |             ^^^^^^ help: try using one of the enum's variants: `std::option::Option::Some`\n+   |             ^^^^^^ help: try to construct one of the enum's variants: `std::option::Option::Some`\n    |\n    = help: you might have meant to construct the enum's non-tuple variant\n \n error[E0532]: expected tuple struct or tuple variant, found enum `Option`\n   --> $DIR/issue-43871-enum-instead-of-variant.rs:21:12\n    |\n LL |     if let Option(_) = x {\n-   |            ^^^^^^ help: try using one of the enum's variants: `std::option::Option::Some`\n+   |            ^^^^^^ help: try to match against one of the enum's variants: `std::option::Option::Some`\n    |\n    = help: you might have meant to match against the enum's non-tuple variant\n \n error[E0532]: expected tuple struct or tuple variant, found enum `Example`\n   --> $DIR/issue-43871-enum-instead-of-variant.rs:27:12\n    |\n LL |     if let Example(_) = y {\n-   |            ^^^^^^^ help: try using one of the enum's variants: `Example::Ex`\n+   |            ^^^^^^^ help: try to match against one of the enum's variants: `Example::Ex`\n    |\n    = help: you might have meant to match against the enum's non-tuple variant\n+note: the enum is defined here\n+  --> $DIR/issue-43871-enum-instead-of-variant.rs:1:1\n+   |\n+LL | enum Example { Ex(String), NotEx }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0423]: expected function, tuple struct or tuple variant, found enum `Void`\n   --> $DIR/issue-43871-enum-instead-of-variant.rs:31:13\n@@ -29,6 +34,11 @@ LL |     let y = Void();\n    |             ^^^^\n    |\n    = help: the enum has no tuple variants to construct\n+note: the enum is defined here\n+  --> $DIR/issue-43871-enum-instead-of-variant.rs:3:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^^^^\n \n error[E0423]: expected function, tuple struct or tuple variant, found enum `ManyVariants`\n   --> $DIR/issue-43871-enum-instead-of-variant.rs:33:13\n@@ -38,6 +48,17 @@ LL |     let z = ManyVariants();\n    |\n    = help: the enum has no tuple variants to construct\n    = help: you might have meant to construct one of the enum's non-tuple variants\n+note: the enum is defined here\n+  --> $DIR/issue-43871-enum-instead-of-variant.rs:5:1\n+   |\n+LL | / enum ManyVariants {\n+LL | |     One,\n+LL | |     Two,\n+LL | |     Three,\n+...  |\n+LL | |     Ten,\n+LL | | }\n+   | |_^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "cd128c1ea0b488d470d99f88c6facdcf595035c3", "filename": "src/test/ui/glob-resolve1.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75ef735d4a2e159e083889a22902a40d8265fced/src%2Ftest%2Fui%2Fglob-resolve1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ef735d4a2e159e083889a22902a40d8265fced/src%2Ftest%2Fui%2Fglob-resolve1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fglob-resolve1.stderr?ref=75ef735d4a2e159e083889a22902a40d8265fced", "patch": "@@ -24,7 +24,17 @@ error[E0423]: expected value, found enum `B`\n   --> $DIR/glob-resolve1.rs:24:5\n    |\n LL |     B;\n-   |     ^ help: try using the enum's variant: `B::B1`\n+   |     ^\n+   |\n+note: the enum is defined here\n+  --> $DIR/glob-resolve1.rs:12:5\n+   |\n+LL |     pub enum B { B1 }\n+   |     ^^^^^^^^^^^^^^^^^\n+help: you might have meant to use the following enum variant\n+   |\n+LL |     B::B1;\n+   |     ^^^^^\n \n error[E0425]: cannot find value `C` in this scope\n   --> $DIR/glob-resolve1.rs:25:5"}, {"sha": "4b5f65b346174668b8979d4d36cb76639f4cbd49", "filename": "src/test/ui/issues/issue-73427.stderr", "status": "modified", "additions": 93, "deletions": 9, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/75ef735d4a2e159e083889a22902a40d8265fced/src%2Ftest%2Fui%2Fissues%2Fissue-73427.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ef735d4a2e159e083889a22902a40d8265fced/src%2Ftest%2Fui%2Fissues%2Fissue-73427.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-73427.stderr?ref=75ef735d4a2e159e083889a22902a40d8265fced", "patch": "@@ -4,39 +4,101 @@ error[E0423]: expected value, found enum `A`\n LL |     A.foo();\n    |     ^\n    |\n-   = help: you might have meant to use one of the enum's other variants that have fields\n-help: try using one of the enum's variants\n+note: the enum is defined here\n+  --> $DIR/issue-73427.rs:1:1\n+   |\n+LL | / enum A {\n+LL | |     StructWithFields { x: () },\n+LL | |     TupleWithFields(()),\n+LL | |     Struct {},\n+LL | |     Tuple(),\n+LL | |     Unit,\n+LL | | }\n+   | |_^\n+help: you might have meant to use one of the following enum variants\n    |\n LL |     (A::Struct {}).foo();\n    |     ^^^^^^^^^^^^^^\n LL |     (A::Tuple()).foo();\n    |     ^^^^^^^^^^^^\n LL |     A::Unit.foo();\n    |     ^^^^^^^\n+help: the following enum variants are available\n+   |\n+LL |     (A::StructWithFields { /* fields */ }).foo();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     (A::TupleWithFields(/* fields */)).foo();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0423]: expected value, found enum `B`\n   --> $DIR/issue-73427.rs:31:5\n    |\n LL |     B.foo();\n    |     ^\n    |\n-   = help: you might have meant to use one of the enum's variants\n+note: the enum is defined here\n+  --> $DIR/issue-73427.rs:9:1\n+   |\n+LL | / enum B {\n+LL | |     StructWithFields { x: () },\n+LL | |     TupleWithFields(()),\n+LL | | }\n+   | |_^\n+help: the following enum variants are available\n+   |\n+LL |     (B::StructWithFields { /* fields */ }).foo();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     (B::TupleWithFields(/* fields */)).foo();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0423]: expected value, found enum `C`\n   --> $DIR/issue-73427.rs:33:5\n    |\n LL |     C.foo();\n-   |     ^ help: try using one of the enum's variants: `C::Unit`\n+   |     ^\n+   |\n+note: the enum is defined here\n+  --> $DIR/issue-73427.rs:14:1\n+   |\n+LL | / enum C {\n+LL | |     StructWithFields { x: () },\n+LL | |     TupleWithFields(()),\n+LL | |     Unit,\n+LL | | }\n+   | |_^\n+help: you might have meant to use the following enum variant\n+   |\n+LL |     C::Unit.foo();\n+   |     ^^^^^^^\n+help: the following enum variants are available\n    |\n-   = help: you might have meant to use one of the enum's other variants that have fields\n+LL |     (C::StructWithFields { /* fields */ }).foo();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     (C::TupleWithFields(/* fields */)).foo();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0423]: expected value, found enum `D`\n   --> $DIR/issue-73427.rs:35:5\n    |\n LL |     D.foo();\n-   |     ^ help: try using one of the enum's variants: `D::Unit`\n+   |     ^\n+   |\n+note: the enum is defined here\n+  --> $DIR/issue-73427.rs:20:1\n+   |\n+LL | / enum D {\n+LL | |     TupleWithFields(()),\n+LL | |     Unit,\n+LL | | }\n+   | |_^\n+help: you might have meant to use the following enum variant\n    |\n-   = help: you might have meant to use the enum's other variant that has fields\n+LL |     D::Unit.foo();\n+   |     ^^^^^^^\n+help: the following enum variant is available\n+   |\n+LL |     (D::TupleWithFields(/* fields */)).foo();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0423]: expected function, tuple struct or tuple variant, found enum `A`\n   --> $DIR/issue-73427.rs:40:13\n@@ -45,7 +107,18 @@ LL |     let x = A(3);\n    |             ^\n    |\n    = help: you might have meant to construct one of the enum's non-tuple variants\n-help: try using one of the enum's variants\n+note: the enum is defined here\n+  --> $DIR/issue-73427.rs:1:1\n+   |\n+LL | / enum A {\n+LL | |     StructWithFields { x: () },\n+LL | |     TupleWithFields(()),\n+LL | |     Struct {},\n+LL | |     Tuple(),\n+LL | |     Unit,\n+LL | | }\n+   | |_^\n+help: try to construct one of the enum's variants\n    |\n LL |     let x = A::TupleWithFields(3);\n    |             ^^^^^^^^^^^^^^^^^^\n@@ -59,7 +132,18 @@ LL |     if let A(3) = x { }\n    |            ^\n    |\n    = help: you might have meant to match against one of the enum's non-tuple variants\n-help: try using one of the enum's variants\n+note: the enum is defined here\n+  --> $DIR/issue-73427.rs:1:1\n+   |\n+LL | / enum A {\n+LL | |     StructWithFields { x: () },\n+LL | |     TupleWithFields(()),\n+LL | |     Struct {},\n+LL | |     Tuple(),\n+LL | |     Unit,\n+LL | | }\n+   | |_^\n+help: try to match against one of the enum's variants\n    |\n LL |     if let A::TupleWithFields(3) = x { }\n    |            ^^^^^^^^^^^^^^^^^^"}, {"sha": "807dadf417bf5c2a0d3b535c1a23101ce8a83eba", "filename": "src/test/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 102, "deletions": 10, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/75ef735d4a2e159e083889a22902a40d8265fced/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75ef735d4a2e159e083889a22902a40d8265fced/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=75ef735d4a2e159e083889a22902a40d8265fced", "patch": "@@ -2,17 +2,57 @@ error[E0423]: expected value, found enum `n::Z`\n   --> $DIR/privacy-enum-ctor.rs:23:9\n    |\n LL |         n::Z;\n-   |         ^^^^ help: try using one of the enum's variants: `m::Z::Unit`\n+   |         ^^^^\n    |\n-   = help: you might have meant to use one of the enum's other variants that have fields\n+note: the enum is defined here\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n+   |\n+LL | /         pub(in m) enum Z {\n+LL | |             Fn(u8),\n+LL | |             Struct {\n+LL | |                 s: u8,\n+LL | |             },\n+LL | |             Unit,\n+LL | |         }\n+   | |_________^\n+help: you might have meant to use the following enum variant\n+   |\n+LL |         m::Z::Unit;\n+   |         ^^^^^^^^^^\n+help: the following enum variants are available\n+   |\n+LL |         (m::Z::Fn(/* fields */));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         (m::Z::Struct { /* fields */ });\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0423]: expected value, found enum `Z`\n   --> $DIR/privacy-enum-ctor.rs:25:9\n    |\n LL |         Z;\n-   |         ^ help: try using one of the enum's variants: `m::Z::Unit`\n+   |         ^\n+   |\n+note: the enum is defined here\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n    |\n-   = help: you might have meant to use one of the enum's other variants that have fields\n+LL | /         pub(in m) enum Z {\n+LL | |             Fn(u8),\n+LL | |             Struct {\n+LL | |                 s: u8,\n+LL | |             },\n+LL | |             Unit,\n+LL | |         }\n+   | |_________^\n+help: you might have meant to use the following enum variant\n+   |\n+LL |         m::Z::Unit;\n+   |         ^^^^^^^^^^\n+help: the following enum variants are available\n+   |\n+LL |         (m::Z::Fn(/* fields */));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         (m::Z::Struct { /* fields */ });\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0423]: expected value, found struct variant `Z::Struct`\n   --> $DIR/privacy-enum-ctor.rs:29:20\n@@ -34,11 +74,27 @@ LL |     fn f() {\n LL |     let _: E = m::E;\n    |                ^^^^\n    |\n-   = help: you might have meant to use one of the enum's other variants that have fields\n-help: try using one of the enum's variants\n+note: the enum is defined here\n+  --> $DIR/privacy-enum-ctor.rs:2:5\n+   |\n+LL | /     pub enum E {\n+LL | |         Fn(u8),\n+LL | |         Struct {\n+LL | |             s: u8,\n+LL | |         },\n+LL | |         Unit,\n+LL | |     }\n+   | |_____^\n+help: you might have meant to use the following enum variant\n    |\n LL |     let _: E = E::Unit;\n    |                ^^^^^^^\n+help: the following enum variants are available\n+   |\n+LL |     let _: E = (E::Fn(/* fields */));\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _: E = (E::Struct { /* fields */ });\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: a function with a similar name exists\n    |\n LL |     let _: E = m::f;\n@@ -67,11 +123,27 @@ error[E0423]: expected value, found enum `E`\n LL |     let _: E = E;\n    |                ^\n    |\n-   = help: you might have meant to use one of the enum's other variants that have fields\n-help: try using one of the enum's variants\n+note: the enum is defined here\n+  --> $DIR/privacy-enum-ctor.rs:2:5\n+   |\n+LL | /     pub enum E {\n+LL | |         Fn(u8),\n+LL | |         Struct {\n+LL | |             s: u8,\n+LL | |         },\n+LL | |         Unit,\n+LL | |     }\n+   | |_____^\n+help: you might have meant to use the following enum variant\n    |\n LL |     let _: E = E::Unit;\n    |                ^^^^^^^\n+help: the following enum variants are available\n+   |\n+LL |     let _: E = (E::Fn(/* fields */));\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _: E = (E::Struct { /* fields */ });\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: consider importing one of these items instead\n    |\n LL | use std::f32::consts::E;\n@@ -112,9 +184,29 @@ error[E0423]: expected value, found enum `m::n::Z`\n   --> $DIR/privacy-enum-ctor.rs:57:16\n    |\n LL |     let _: Z = m::n::Z;\n-   |                ^^^^^^^ help: try using one of the enum's variants: `m::Z::Unit`\n+   |                ^^^^^^^\n+   |\n+note: the enum is defined here\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n+   |\n+LL | /         pub(in m) enum Z {\n+LL | |             Fn(u8),\n+LL | |             Struct {\n+LL | |                 s: u8,\n+LL | |             },\n+LL | |             Unit,\n+LL | |         }\n+   | |_________^\n+help: you might have meant to use the following enum variant\n+   |\n+LL |     let _: Z = m::Z::Unit;\n+   |                ^^^^^^^^^^\n+help: the following enum variants are available\n    |\n-   = help: you might have meant to use one of the enum's other variants that have fields\n+LL |     let _: Z = (m::Z::Fn(/* fields */));\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _: Z = (m::Z::Struct { /* fields */ });\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0412]: cannot find type `Z` in this scope\n   --> $DIR/privacy-enum-ctor.rs:61:12"}]}