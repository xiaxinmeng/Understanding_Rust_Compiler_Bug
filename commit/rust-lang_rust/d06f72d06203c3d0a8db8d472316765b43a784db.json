{"sha": "d06f72d06203c3d0a8db8d472316765b43a784db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNmY3MmQwNjIwM2MzZDBhOGRiOGQ0NzIzMTY3NjViNDNhNzg0ZGI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-02-27T23:27:19Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-02-27T23:27:19Z"}, "message": "Apply the same transformation to every types", "tree": {"sha": "a37dd488522b0b047a92d8c88d3513f2bf228f7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a37dd488522b0b047a92d8c88d3513f2bf228f7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d06f72d06203c3d0a8db8d472316765b43a784db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d06f72d06203c3d0a8db8d472316765b43a784db", "html_url": "https://github.com/rust-lang/rust/commit/d06f72d06203c3d0a8db8d472316765b43a784db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d06f72d06203c3d0a8db8d472316765b43a784db/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ac7a035af0f13b351a6e0ec9f889874d08e725d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac7a035af0f13b351a6e0ec9f889874d08e725d", "html_url": "https://github.com/rust-lang/rust/commit/5ac7a035af0f13b351a6e0ec9f889874d08e725d"}], "stats": {"total": 103, "additions": 65, "deletions": 38}, "files": [{"sha": "23507dc889b710be084cb53985f9575d7ba87dc3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d06f72d06203c3d0a8db8d472316765b43a784db/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06f72d06203c3d0a8db8d472316765b43a784db/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d06f72d06203c3d0a8db8d472316765b43a784db", "patch": "@@ -90,6 +90,16 @@ impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     }\n }\n \n+impl<'a, T: fmt::Debug> fmt::Debug for CommaSep<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for (i, item) in self.0.iter().enumerate() {\n+            if i != 0 { write!(f, \", \")?; }\n+            fmt::Debug::fmt(item, f)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'a> fmt::Display for TyParamBounds<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &TyParamBounds(bounds) = self;\n@@ -165,7 +175,7 @@ impl<'a> fmt::Display for WhereClause<'a> {\n         if f.alternate() {\n             clause.push_str(\" where \");\n         } else {\n-            clause.push_str(\" <span class='where fmt-newline'>where \");\n+            clause.push_str(\" <span class=\\\"where fmt-newline\\\">where \");\n         }\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n@@ -449,8 +459,8 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                     } else {\n                         root.push_str(&seg.name);\n                         root.push_str(\"/\");\n-                        write!(w, \"<a class='mod'\n-                                       href='{}index.html'>{}</a>::\",\n+                        write!(w, \"<a class=\\\"mod\\\"\n+                                       href=\\\"{}index.html\\\">{}</a>::\",\n                                  root,\n                                  seg.name)?;\n                     }\n@@ -491,7 +501,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n             Some(&def_id) if def_id.is_local() => {\n                 let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n                 let len = if len == 0 {0} else {len - 1};\n-                write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n+                write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}primitive.{}.html\\\">\",\n                        repeat(\"../\").take(len).collect::<String>(),\n                        prim.to_url_str())?;\n                 needs_termination = true;\n@@ -508,7 +518,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                     (.., render::Unknown) => None,\n                 };\n                 if let Some((cname, root)) = loc {\n-                    write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n+                    write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}{}/primitive.{}.html\\\">\",\n                            root,\n                            cname,\n                            prim.to_url_str())?;\n@@ -550,7 +560,7 @@ impl<'a> fmt::Display for HRef<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match href(self.did) {\n             Some((url, shortty, fqp)) => if !f.alternate() {\n-                write!(f, \"<a class='{}' href='{}' title='{} {}'>{}</a>\",\n+                write!(f, \"<a class=\\\"{}\\\" href=\\\"{}\\\" title=\\\"{} {}\\\">{}</a>\",\n                        shortty, url, shortty, fqp.join(\"::\"), self.text)\n             } else {\n                 write!(f, \"{}\", self.text)\n@@ -599,21 +609,21 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                     fmt::Display::fmt(one, f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n-                &[ref one] => write!(f, \"({},)\", one),\n+                &[ref one] => write!(f, \"({:?},)\", one),\n                 many if is_not_debug => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     fmt::Display::fmt(&CommaSep(&many), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n-                many => write!(f, \"({})\", &CommaSep(&many)),\n+                many => write!(f, \"({:?})\", &CommaSep(&many)),\n             }\n         }\n         clean::Vector(ref t) if is_not_debug => {\n             primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n         }\n-        clean::Vector(ref t) => write!(f, \"[{}]\", t),\n+        clean::Vector(ref t) => write!(f, \"[{:?}]\", t),\n         clean::FixedVector(ref t, ref s) if is_not_debug => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n@@ -627,9 +637,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n         }\n         clean::FixedVector(ref t, ref s) => {\n             if f.alternate() {\n-                write!(f, \"[{}; {}]\", t, s)\n+                write!(f, \"[{:?}; {}]\", t, s)\n             } else {\n-                write!(f, \"[{}; {}]\", t, Escape(s))\n+                write!(f, \"[{:?}; {}]\", t, Escape(s))\n             }\n         }\n         clean::Never => f.write_str(\"!\"),\n@@ -646,9 +656,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                 }\n                 clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n                     if f.alternate() {\n-                        write!(f, \"*{}{:#}\", RawMutableSpace(m), t)\n+                        write!(f, \"*{}{:#?}\", RawMutableSpace(m), t)\n                     } else {\n-                        write!(f, \"*{}{}\", RawMutableSpace(m), t)\n+                        write!(f, \"*{}{:?}\", RawMutableSpace(m), t)\n                     }\n                 }\n                 _ if is_not_debug => {\n@@ -657,7 +667,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                     fmt::Display::fmt(t, f)\n                 }\n                 _ => {\n-                    write!(f, \"*{}{}\", RawMutableSpace(m), t)\n+                    write!(f, \"*{}{:?}\", RawMutableSpace(m), t)\n                 }\n             }\n         }\n@@ -681,9 +691,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                         }\n                         clean::Generic(_) => {\n                             if f.alternate() {\n-                                write!(f, \"&{}{}[{:#}]\", lt, m, **bt)\n+                                write!(f, \"&{}{}[{:#?}]\", lt, m, **bt)\n                             } else {\n-                                write!(f, \"&{}{}[{}]\", lt, m, **bt)\n+                                write!(f, \"&{}{}[{:?}]\", lt, m, **bt)\n                             }\n                         }\n                         _ if is_not_debug => {\n@@ -700,9 +710,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                         }\n                         _ => {\n                             if f.alternate() {\n-                                write!(f, \"&{}{}[{:#}]\", lt, m, **bt)\n+                                write!(f, \"&{}{}[{:#?}]\", lt, m, **bt)\n                             } else {\n-                                write!(f, \"&{}{}[{}]\", lt, m, **bt)\n+                                write!(f, \"&{}{}[{:?}]\", lt, m, **bt)\n                             }\n                         }\n                     }\n@@ -765,12 +775,16 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n             if f.alternate() {\n-                write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                if is_not_debug {\n+                    write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                } else {\n+                    write!(f, \"<{:#?} as {:#?}>::{}\", self_type, trait_, name)\n+                }\n             } else {\n                 if is_not_debug {\n                     write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n                 } else {\n-                    write!(f, \"<{} as {}>::{}\", self_type, trait_, name)\n+                    write!(f, \"<{:?} as {:?}>::{}\", self_type, trait_, name)\n                 }\n             }\n         }"}, {"sha": "46db2d538a6529ee4775e909095191aed92efeda", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d06f72d06203c3d0a8db8d472316765b43a784db/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06f72d06203c3d0a8db8d472316765b43a784db/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=d06f72d06203c3d0a8db8d472316765b43a784db", "patch": "@@ -144,12 +144,12 @@ impl<U: Write> Writer for U {\n                           -> io::Result<()> {\n         match klass {\n             Class::None => write!(self, \"{}\", text),\n-            klass => write!(self, \"<span class='{}'>{}</span>\", klass.rustdoc_class(), text),\n+            klass => write!(self, \"<span class=\\\"{}\\\">{}</span>\", klass.rustdoc_class(), text),\n         }\n     }\n \n     fn enter_span(&mut self, klass: Class) -> io::Result<()> {\n-        write!(self, \"<span class='{}'>\", klass.rustdoc_class())\n+        write!(self, \"<span class=\\\"{}\\\">\", klass.rustdoc_class())\n     }\n \n     fn exit_span(&mut self) -> io::Result<()> {\n@@ -363,7 +363,7 @@ fn write_header(class: Option<&str>,\n     if let Some(id) = id {\n         write!(out, \"id='{}' \", id)?;\n     }\n-    write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\"))\n+    write!(out, \"class=\\\"rust {}\\\">\\n\", class.unwrap_or(\"\"))\n }\n \n fn write_footer(out: &mut Write) -> io::Result<()> {"}, {"sha": "ead913b57be50dd1e89a6cca1465b167f237f050", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d06f72d06203c3d0a8db8d472316765b43a784db/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06f72d06203c3d0a8db8d472316765b43a784db/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d06f72d06203c3d0a8db8d472316765b43a784db", "patch": "@@ -1547,7 +1547,7 @@ impl<'a> fmt::Display for Item<'a> {\n                        component)?;\n             }\n         }\n-        write!(fmt, \"<a class='{}' href=''>{}</a>\",\n+        write!(fmt, \"<a class=\\\"{}\\\" href=''>{}</a>\",\n                self.item.type_(), self.item.name.as_ref().unwrap())?;\n \n         write!(fmt, \"</span>\")?; // in-band\n@@ -1667,8 +1667,20 @@ fn md_render_assoc_item(item: &clean::Item) -> String {\n     }\n }\n \n+fn get_doc_value(item: &clean::Item) -> Option<&str> {\n+    let x = item.doc_value();\n+    if x.is_none() {\n+        match item.inner {\n+            clean::AssociatedConstItem(_, _) => Some(\"\"),\n+            _ => None,\n+        }\n+    } else {\n+        x\n+    }\n+}\n+\n fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n-    if let Some(s) = item.doc_value() {\n+    if let Some(s) = get_doc_value(item) {\n         write!(w, \"<div class='docblock'>{}</div>\",\n                Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n     }\n@@ -1831,7 +1843,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 let doc_value = myitem.doc_value().unwrap_or(\"\");\n                 write!(w, \"\n                        <tr class='{stab} module-item'>\n-                           <td><a class='{class}' href='{href}'\n+                           <td><a class=\\\"{class}\\\" href=\\\"{href}\\\"\n                                   title='{title_type} {title}'>{name}</a>{unsafety_flag}</td>\n                            <td class='docblock-short'>\n                                {stab_docs} {docs}\n@@ -2228,20 +2240,21 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n \n fn assoc_const(w: &mut fmt::Formatter,\n                it: &clean::Item,\n-               _ty: &clean::Type,\n+               ty: &clean::Type,\n                _default: Option<&String>,\n                link: AssocItemLink) -> fmt::Result {\n-    write!(w, \"const <a href='{}' class='constant'><b>{}</b></a>\",\n+    write!(w, \"const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n            naive_assoc_href(it, link),\n-           it.name.as_ref().unwrap())?;\n+           it.name.as_ref().unwrap(),\n+           ty)?;\n     Ok(())\n }\n \n fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               bounds: &Vec<clean::TyParamBound>,\n               default: Option<&clean::Type>,\n               link: AssocItemLink) -> fmt::Result {\n-    write!(w, \"type <a href='{}' class='type'>{}</a>\",\n+    write!(w, \"type <a href='{}' class=\\\"type\\\">{}</a>\",\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap())?;\n     if !bounds.is_empty() {\n@@ -2384,7 +2397,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 let ns_id = derive_id(format!(\"{}.{}\",\n                                               field.name.as_ref().unwrap(),\n                                               ItemType::StructField.name_space()));\n-                write!(w, \"<span id='{id}' class='{item_type}'>\n+                write!(w, \"<span id='{id}' class=\\\"{item_type}\\\">\n                            <span id='{ns_id}' class='invisible'>\n                            <code>{name}: {ty}</code>\n                            </span></span>\",\n@@ -2426,7 +2439,7 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     if fields.peek().is_some() {\n         write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n         for (field, ty) in fields {\n-            write!(w, \"<span id='{shortty}.{name}' class='{shortty}'><code>{name}: {ty}</code>\n+            write!(w, \"<span id='{shortty}.{name}' class=\\\"{shortty}\\\"><code>{name}: {ty}</code>\n                        </span>\",\n                    shortty = ItemType::StructField,\n                    name = field.name.as_ref().unwrap(),\n@@ -2911,7 +2924,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 if render_method_item {\n                     let id = derive_id(format!(\"{}.{}\", item_type, name));\n                     let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                    write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                    write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                     write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n                     write!(w, \"<code>\")?;\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl)?;\n@@ -2923,31 +2936,31 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::ConstantItem(ref c) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, &c.type_, Some(&c.expr), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n@@ -2965,7 +2978,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         // We need the stability of the item from the trait\n                         // because impls can't have a stability.\n                         document_stability(w, cx, it)?;\n-                        if item.doc_value().is_some() {\n+                        if get_doc_value(item).is_some() {\n                             document_full(w, item)?;\n                         } else {\n                             // In case the item isn't documented,"}]}