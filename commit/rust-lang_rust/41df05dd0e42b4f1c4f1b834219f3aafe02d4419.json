{"sha": "41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZGYwNWRkMGU0MmI0ZjFjNGYxYjgzNDIxOWYzYWFmZTAyZDQ0MTk=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-29T21:18:41Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-03T14:34:04Z"}, "message": "core: use assoc types in Iterator et al", "tree": {"sha": "07a7cd8ca889e6d663ffdfd2013cc4e2a0ced306", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07a7cd8ca889e6d663ffdfd2013cc4e2a0ced306"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "html_url": "https://github.com/rust-lang/rust/commit/41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/comments", "author": null, "committer": null, "parents": [{"sha": "fc2ba13939aa9672d886beb06efde7aeda2d5f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2ba13939aa9672d886beb06efde7aeda2d5f7f", "html_url": "https://github.com/rust-lang/rust/commit/fc2ba13939aa9672d886beb06efde7aeda2d5f7f"}], "stats": {"total": 789, "additions": 500, "deletions": 289}, "files": [{"sha": "aa6028a19b323fed8da1aae3416200786d9a5397", "filename": "src/libcore/char.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "patch": "@@ -446,7 +446,9 @@ enum EscapeUnicodeState {\n     Done,\n }\n \n-impl Iterator<char> for EscapeUnicode {\n+impl Iterator for EscapeUnicode {\n+    type Item = char;\n+\n     fn next(&mut self) -> Option<char> {\n         match self.state {\n             EscapeUnicodeState::Backslash => {\n@@ -501,7 +503,9 @@ enum EscapeDefaultState {\n     Unicode(EscapeUnicode),\n }\n \n-impl Iterator<char> for EscapeDefault {\n+impl Iterator for EscapeDefault {\n+    type Item = char;\n+\n     fn next(&mut self) -> Option<char> {\n         match self.state {\n             EscapeDefaultState::Backslash(c) => {"}, {"sha": "c4b3531d539263afbf99006359bb92b85d2d8341", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 363, "deletions": 215, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "patch": "@@ -82,9 +82,11 @@ use uint;\n /// else.\n #[lang=\"iterator\"]\n #[unstable = \"just split up for object safety\"]\n-pub trait Iterator<A> {\n+pub trait Iterator {\n+    type Item;\n+\n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n-    fn next(&mut self) -> Option<A>;\n+    fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n@@ -98,19 +100,19 @@ pub trait Iterator<A> {\n #[unstable = \"may be replaced by a more general conversion trait\"]\n pub trait FromIterator<A> {\n     /// Build a container with elements from an external iterator.\n-    fn from_iter<T: Iterator<A>>(iterator: T) -> Self;\n+    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n /// A type growable from an `Iterator` implementation\n #[unstable = \"just renamed as part of collections reform\"]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n-    fn extend<T: Iterator<A>>(&mut self, iterator: T);\n+    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n }\n \n #[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n-pub trait IteratorExt<A>: Iterator<A> + Sized {\n+pub trait IteratorExt: Iterator + Sized {\n     /// Chain this iterator with another, returning a new iterator that will\n     /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n@@ -127,7 +129,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn chain<U: Iterator<A>>(self, other: U) -> Chain<Self, U> {\n+    fn chain<U>(self, other: U) -> Chain<Self, U> where\n+        U: Iterator<Item=<Self as Iterator>::Item>,\n+    {\n         Chain{a: self, b: other, flag: false}\n     }\n \n@@ -148,7 +152,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U> {\n+    fn zip<B, U>(self, other: U) -> Zip<Self, U> where\n+        U: Iterator<Item=B>,\n+    {\n         Zip{a: self, b: other}\n     }\n \n@@ -166,7 +172,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn map<B, F: FnMut(A) -> B>(self, f: F) -> Map<A, B, Self, F> {\n+    fn map<B, F>(self, f: F) -> Map< <Self as Iterator>::Item, B, Self, F> where\n+        F: FnMut(<Self as Iterator>::Item) -> B,\n+    {\n         Map{iter: self, f: f}\n     }\n \n@@ -184,7 +192,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn filter<P>(self, predicate: P) -> Filter<A, Self, P> where P: FnMut(&A) -> bool {\n+    fn filter<P>(self, predicate: P) -> Filter< <Self as Iterator>::Item, Self, P> where\n+        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    {\n         Filter{iter: self, predicate: predicate}\n     }\n \n@@ -202,7 +212,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn filter_map<B, F>(self, f: F) -> FilterMap<A, B, Self, F> where F: FnMut(A) -> Option<B> {\n+    fn filter_map<B, F>(self, f: F) -> FilterMap< <Self as Iterator>::Item, B, Self, F> where\n+        F: FnMut(<Self as Iterator>::Item) -> Option<B>,\n+    {\n         FilterMap { iter: self, f: f }\n     }\n \n@@ -244,7 +256,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn peekable(self) -> Peekable<A, Self> {\n+    fn peekable(self) -> Peekable< <Self as Iterator>::Item, Self> {\n         Peekable{iter: self, peeked: None}\n     }\n \n@@ -264,7 +276,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn skip_while<P>(self, predicate: P) -> SkipWhile<A, Self, P> where P: FnMut(&A) -> bool {\n+    fn skip_while<P>(self, predicate: P) -> SkipWhile< <Self as Iterator>::Item, Self, P> where\n+        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -283,7 +297,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, may want to require peek\"]\n-    fn take_while<P>(self, predicate: P) -> TakeWhile<A, Self, P> where P: FnMut(&A) -> bool {\n+    fn take_while<P>(self, predicate: P) -> TakeWhile< <Self as Iterator>::Item, Self, P> where\n+        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -346,8 +362,12 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<A, B, Self, St, F> where\n-        F: FnMut(&mut St, A) -> Option<B>,\n+    fn scan<St, B, F>(\n+        self,\n+        initial_state: St,\n+        f: F,\n+    ) -> Scan< <Self as Iterator>::Item, B, Self, St, F> where\n+        F: FnMut(&mut St, <Self as Iterator>::Item) -> Option<B>,\n     {\n         Scan{iter: self, f: f, state: initial_state}\n     }\n@@ -372,9 +392,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn flat_map<B, U, F>(self, f: F) -> FlatMap<A, B, Self, U, F> where\n-        U: Iterator<B>,\n-        F: FnMut(A) -> U,\n+    fn flat_map<B, U, F>(self, f: F) -> FlatMap< <Self as Iterator>::Item, B, Self, U, F> where\n+        U: Iterator<Item=B>,\n+        F: FnMut(<Self as Iterator>::Item) -> U,\n     {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n@@ -386,7 +406,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// fn process<U: Iterator<int>>(it: U) -> int {\n+    /// fn process<U: Iterator<Item=int>>(it: U) -> int {\n     ///     let mut it = it.fuse();\n     ///     let mut sum = 0;\n     ///     for x in it {\n@@ -432,7 +452,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn inspect<F>(self, f: F) -> Inspect<A, Self, F> where F: FnMut(&A) {\n+    fn inspect<F>(self, f: F) -> Inspect< <Self as Iterator>::Item, Self, F> where\n+        F: FnMut(&<Self as Iterator>::Item),\n+    {\n         Inspect{iter: self, f: f}\n     }\n \n@@ -468,7 +490,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for general conversion traits, just changed to take self by value\"]\n-    fn collect<B: FromIterator<A>>(self) -> B {\n+    fn collect<B: FromIterator< <Self as Iterator>::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n \n@@ -485,7 +507,8 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[unstable = \"recently added as part of collections reform\"]\n     fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n-        B: Default + Extend<A>, F: FnMut(&A) -> bool\n+        B: Default + Extend< <Self as Iterator>::Item>,\n+        F: FnMut(&<Self as Iterator>::Item) -> bool\n     {\n         let mut left: B = Default::default();\n         let mut right: B = Default::default();\n@@ -514,7 +537,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn nth(&mut self, mut n: uint) -> Option<A> {\n+    fn nth(&mut self, mut n: uint) -> Option< <Self as Iterator>::Item> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n             n -= 1;\n@@ -533,7 +556,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"just changed to take self by value\"]\n-    fn last(mut self) -> Option<A> {\n+    fn last(mut self) -> Option< <Self as Iterator>::Item> {\n         let mut last = None;\n         for x in self { last = Some(x); }\n         last\n@@ -550,7 +573,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B where F: FnMut(B, A) -> B {\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n+        F: FnMut(B, <Self as Iterator>::Item) -> B,\n+    {\n         let mut accum = init;\n         for x in self {\n             accum = f(accum, x);\n@@ -584,7 +609,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(A) -> bool {\n+    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n     }\n@@ -602,7 +627,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(A) -> bool {\n+    fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n     }\n@@ -612,7 +637,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<A> where P: FnMut(&A) -> bool {\n+    fn find<P>(&mut self, mut predicate: P) -> Option< <Self as Iterator>::Item> where\n+        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    {\n         for x in *self {\n             if predicate(&x) { return Some(x) }\n         }\n@@ -622,7 +649,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn position<P>(&mut self, mut predicate: P) -> Option<uint> where P: FnMut(A) -> bool {\n+    fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n+        P: FnMut(<Self as Iterator>::Item) -> bool,\n+    {\n         let mut i = 0;\n         for x in *self {\n             if predicate(x) {\n@@ -646,8 +675,10 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn max_by<B: Ord, F>(self, mut f: F) -> Option<A> where F: FnMut(&A) -> B {\n-        self.fold(None, |max: Option<(A, B)>, x| {\n+    fn max_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n+        F: FnMut(&<Self as Iterator>::Item) -> B,\n+    {\n+        self.fold(None, |max: Option<(<Self as Iterator>::Item, B)>, x| {\n             let x_val = f(&x);\n             match max {\n                 None             => Some((x, x_val)),\n@@ -673,8 +704,10 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn min_by<B: Ord, F>(self, mut f: F) -> Option<A> where F: FnMut(&A) -> B {\n-        self.fold(None, |min: Option<(A, B)>, x| {\n+    fn min_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n+        F: FnMut(&<Self as Iterator>::Item) -> B,\n+    {\n+        self.fold(None, |min: Option<(<Self as Iterator>::Item, B)>, x| {\n             let x_val = f(&x);\n             match min {\n                 None             => Some((x, x_val)),\n@@ -689,11 +722,11 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I> IteratorExt<A> for I where I: Iterator<A> {}\n+impl<I> IteratorExt for I where I: Iterator {}\n \n /// Extention trait for iterators of pairs.\n #[unstable = \"newly added trait, likely to be merged with IteratorExt\"]\n-pub trait IteratorPairExt<A, B>: Iterator<(A, B)> + Sized {\n+pub trait IteratorPairExt<A, B>: Iterator<Item=(A, B)> + Sized {\n     /// Converts an iterator of pairs into a pair of containers.\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n@@ -702,7 +735,9 @@ pub trait IteratorPairExt<A, B>: Iterator<(A, B)> + Sized {\n         FromA: Default + Extend<A>, FromB: Default + Extend<B>\n     {\n         struct SizeHint<A>(uint, Option<uint>);\n-        impl<A> Iterator<A> for SizeHint<A> {\n+        impl<A> Iterator for SizeHint<A> {\n+            type Item = A;\n+\n             fn next(&mut self) -> Option<A> { None }\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 (self.0, self.1)\n@@ -725,21 +760,21 @@ pub trait IteratorPairExt<A, B>: Iterator<(A, B)> + Sized {\n     }\n }\n \n-impl<A, B, I> IteratorPairExt<A, B> for I where I: Iterator<(A, B)> {}\n+impl<A, B, I> IteratorPairExt<A, B> for I where I: Iterator<Item=(A, B)> {}\n \n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n /// elements from the *same* range, and do not work independently of each other.\n #[unstable = \"recently split into two traits\"]\n-pub trait DoubleEndedIterator<A>: Iterator<A> {\n+pub trait DoubleEndedIterator: Iterator {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    fn next_back(&mut self) -> Option<A>;\n+    fn next_back(&mut self) -> Option< <Self as Iterator>::Item>;\n }\n \n /// Extension methods for double-ended iterators.\n #[unstable = \"new extension trait convention\"]\n-pub trait DoubleEndedIteratorExt<A>: DoubleEndedIterator<A> + Sized {\n+pub trait DoubleEndedIteratorExt: DoubleEndedIterator + Sized {\n     /// Change the direction of the iterator\n     ///\n     /// The flipped iterator swaps the ends on an iterator that can already\n@@ -760,7 +795,7 @@ pub trait DoubleEndedIteratorExt<A>: DoubleEndedIterator<A> + Sized {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I> DoubleEndedIteratorExt<A> for I where I: DoubleEndedIterator<A> {}\n+impl<I> DoubleEndedIteratorExt for I where I: DoubleEndedIterator {}\n \n /// A double-ended iterator yielding mutable references\n #[experimental = \"not widely used\"]\n@@ -771,7 +806,9 @@ pub trait MutableDoubleEndedIterator {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, A:'a, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for T {\n+impl<'a, T:'a, I> MutableDoubleEndedIterator for I where\n+    I: DoubleEndedIterator + Iterator<Item=&'a mut T>,\n+{\n     // FIXME: #5898: should be called `reverse`\n     /// Use an iterator to reverse a container in-place\n     fn reverse_(&mut self) {\n@@ -792,13 +829,13 @@ impl<'a, A:'a, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for\n /// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n /// after `it.next()` is called.\n #[experimental = \"not widely used, may be better decomposed into Index and ExactSizeIterator\"]\n-pub trait RandomAccessIterator<A>: Iterator<A> {\n+pub trait RandomAccessIterator: Iterator {\n     /// Return the number of indexable elements. At most `std::uint::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n     fn indexable(&self) -> uint;\n \n     /// Return an element at an index, or `None` if the index is out of bounds\n-    fn idx(&mut self, index: uint) -> Option<A>;\n+    fn idx(&mut self, index: uint) -> Option< <Self as Iterator>::Item>;\n }\n \n /// An iterator that knows its exact length\n@@ -809,12 +846,14 @@ pub trait RandomAccessIterator<A>: Iterator<A> {\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `uint`.\n #[unstable = \"could move DoubleEndedIterator bound onto rposition with method-level where clauses\"]\n-pub trait ExactSizeIterator<A> : DoubleEndedIterator<A> {\n+pub trait ExactSizeIterator: DoubleEndedIterator {\n     /// Return the index of the last element satisfying the specified predicate\n     ///\n     /// If no element matches, None is returned.\n     #[inline]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where P: FnMut(A) -> bool {\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n+        P: FnMut(<Self as Iterator>::Item) -> bool,\n+    {\n         let len = self.len();\n         for i in range(0, len).rev() {\n             if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n@@ -840,22 +879,21 @@ pub trait ExactSizeIterator<A> : DoubleEndedIterator<A> {\n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n #[unstable = \"trait is unstable\"]\n-impl<A, T: ExactSizeIterator<A>> ExactSizeIterator<(uint, A)> for Enumerate<T> {}\n+impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n #[unstable = \"trait is unstable\"]\n-impl<A, I, F> ExactSizeIterator<A> for Inspect<A, I, F> where\n-    I: ExactSizeIterator<A>,\n+impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n+    I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n {}\n #[unstable = \"trait is unstable\"]\n-impl<A, T: ExactSizeIterator<A>> ExactSizeIterator<A> for Rev<T> {}\n+impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator {}\n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> ExactSizeIterator<B> for Map<A, B, I, F> where\n-    I: ExactSizeIterator<A>,\n+impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n+    I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n #[unstable = \"trait is unstable\"]\n-impl<A, B, T, U> ExactSizeIterator<(A, B)> for Zip<T, U>\n-    where T: ExactSizeIterator<A>, U: ExactSizeIterator<B> {}\n+impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n #[deriving(Clone)]\n@@ -866,26 +904,27 @@ pub struct Rev<T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: DoubleEndedIterator<A>> Iterator<A> for Rev<T> {\n+impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.iter.next_back() }\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next_back() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Rev<T> {\n+impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.iter.next() }\n+    fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next() }\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n-    for Rev<T> {\n+impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint { self.iter.indexable() }\n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         let amt = self.indexable();\n         self.iter.idx(amt - index - 1)\n     }\n@@ -894,22 +933,24 @@ impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterato\n /// A mutable reference to an iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct ByRef<'a, T:'a> {\n-    iter: &'a mut T\n+pub struct ByRef<'a, I:'a> {\n+    iter: &'a mut I,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: Iterator<A>+'a> Iterator<A> for ByRef<'a, T> {\n+impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.iter.next() }\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: DoubleEndedIterator<A>+'a> DoubleEndedIterator<A> for ByRef<'a, T> {\n+impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next_back() }\n }\n \n /// A trait for iterators over elements which can be added together\n@@ -932,7 +973,7 @@ pub trait AdditiveIterator<A> {\n macro_rules! impl_additive {\n     ($A:ty, $init:expr) => {\n         #[experimental = \"trait is experimental\"]\n-        impl<T: Iterator<$A>> AdditiveIterator<$A> for T {\n+        impl<T: Iterator<Item=$A>> AdditiveIterator<$A> for T {\n             #[inline]\n             fn sum(self) -> $A {\n                 self.fold($init, |acc, x| acc + x)\n@@ -976,7 +1017,7 @@ pub trait MultiplicativeIterator<A> {\n macro_rules! impl_multiplicative {\n     ($A:ty, $init:expr) => {\n         #[experimental = \"trait is experimental\"]\n-        impl<T: Iterator<$A>> MultiplicativeIterator<$A> for T {\n+        impl<T: Iterator<Item=$A>> MultiplicativeIterator<$A> for T {\n             #[inline]\n             fn product(self) -> $A {\n                 self.fold($init, |acc, x| acc * x)\n@@ -1057,9 +1098,9 @@ pub trait IteratorOrdExt<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Ord, T: Iterator<A>> IteratorOrdExt<A> for T {\n+impl<T, I> IteratorOrdExt<T> for I where I: Iterator<Item=T>, T: Ord {\n     #[inline]\n-    fn max(self) -> Option<A> {\n+    fn max(self) -> Option<T> {\n         self.fold(None, |max, x| {\n             match max {\n                 None    => Some(x),\n@@ -1069,7 +1110,7 @@ impl<A: Ord, T: Iterator<A>> IteratorOrdExt<A> for T {\n     }\n \n     #[inline]\n-    fn min(self) -> Option<A> {\n+    fn min(self) -> Option<T> {\n         self.fold(None, |min, x| {\n             match min {\n                 None    => Some(x),\n@@ -1078,7 +1119,7 @@ impl<A: Ord, T: Iterator<A>> IteratorOrdExt<A> for T {\n         })\n     }\n \n-    fn min_max(mut self) -> MinMaxResult<A> {\n+    fn min_max(mut self) -> MinMaxResult<T> {\n         let (mut min, mut max) = match self.next() {\n             None => return NoElements,\n             Some(x) => {\n@@ -1175,7 +1216,11 @@ pub trait IteratorCloneExt<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> IteratorCloneExt<A> for I {\n+impl<T, D, I> IteratorCloneExt<T> for I where\n+    T: Clone,\n+    D: Deref<Target=T>,\n+    I: Iterator<Item=D>,\n+{\n     fn cloned(self) -> Cloned<I> {\n         Cloned { it: self }\n     }\n@@ -1186,8 +1231,14 @@ pub struct Cloned<I> {\n     it: I,\n }\n \n-impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n-    fn next(&mut self) -> Option<A> {\n+impl<T, D, I> Iterator for Cloned<I> where\n+    T: Clone,\n+    D: Deref<Target=T>,\n+    I: Iterator<Item=D>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n         self.it.next().cloned()\n     }\n \n@@ -1196,15 +1247,22 @@ impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n     }\n }\n \n-impl<A: Clone, D: Deref<Target=A>, I: DoubleEndedIterator<D>>\n-        DoubleEndedIterator<A> for Cloned<I> {\n-    fn next_back(&mut self) -> Option<A> {\n+impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n+    T: Clone,\n+    D: Deref<Target=T>,\n+    I: DoubleEndedIterator + Iterator<Item=D>,\n+{\n+    fn next_back(&mut self) -> Option<T> {\n         self.it.next_back().cloned()\n     }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone, D: Deref<Target=A>, I: ExactSizeIterator<D>> ExactSizeIterator<A> for Cloned<I> {}\n+impl<T, D, I> ExactSizeIterator for Cloned<I> where\n+    T: Clone,\n+    D: Deref<Target=T>,\n+    I: ExactSizeIterator + Iterator<Item=D>,\n+{}\n \n #[unstable = \"recently renamed for extension trait conventions\"]\n /// An extension trait for cloneable iterators.\n@@ -1225,7 +1283,7 @@ pub trait CloneIteratorExt {\n     fn cycle(self) -> Cycle<Self>;\n }\n \n-impl<A, I> CloneIteratorExt for I where I: Iterator<A> + Clone {\n+impl<I> CloneIteratorExt for I where I: Iterator + Clone {\n     #[inline]\n     fn cycle(self) -> Cycle<I> {\n         Cycle{orig: self.clone(), iter: self}\n@@ -1236,14 +1294,16 @@ impl<A, I> CloneIteratorExt for I where I: Iterator<A> + Clone {\n #[deriving(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Cycle<T> {\n-    orig: T,\n-    iter: T,\n+pub struct Cycle<I> {\n+    orig: I,\n+    iter: I,\n }\n \n-impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n+impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n         match self.iter.next() {\n             None => { self.iter = self.orig.clone(); self.iter.next() }\n             y => y\n@@ -1262,7 +1322,9 @@ impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T> {\n+impl<I> RandomAccessIterator for Cycle<I> where\n+    I: Clone + RandomAccessIterator,\n+{\n     #[inline]\n     fn indexable(&self) -> uint {\n         if self.orig.indexable() > 0 {\n@@ -1273,7 +1335,7 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         let liter = self.iter.indexable();\n         let lorig = self.orig.indexable();\n         if lorig == 0 {\n@@ -1290,16 +1352,18 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Chain<T, U> {\n-    a: T,\n-    b: U,\n+pub struct Chain<A, B> {\n+    a: A,\n+    b: B,\n     flag: bool,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n+impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n+    type Item = T;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<T> {\n         if self.flag {\n             self.b.next()\n         } else {\n@@ -1329,10 +1393,12 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: DoubleEndedIterator<A>, U: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n-for Chain<T, U> {\n+impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n+    A: DoubleEndedIterator + Iterator<Item=T>,\n+    B: DoubleEndedIterator + Iterator<Item=T>,\n+{\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option<T> {\n         match self.b.next_back() {\n             Some(x) => Some(x),\n             None => self.a.next_back()\n@@ -1341,16 +1407,18 @@ for Chain<T, U> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>, U: RandomAccessIterator<A>> RandomAccessIterator<A>\n-for Chain<T, U> {\n+impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n+    A: RandomAccessIterator + Iterator<Item=T>,\n+    B: RandomAccessIterator + Iterator<Item=T>,\n+{\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (a, b) = (self.a.indexable(), self.b.indexable());\n         a.saturating_add(b)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option<T> {\n         let len = self.a.indexable();\n         if index < len {\n             self.a.idx(index)\n@@ -1364,15 +1432,20 @@ for Chain<T, U> {\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Zip<T, U> {\n-    a: T,\n-    b: U\n+pub struct Zip<A, B> {\n+    a: A,\n+    b: B\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n+impl<T, U, A, B> Iterator for Zip<A, B> where\n+    A: Iterator<Item = T>,\n+    B: Iterator<Item = U>,\n+{\n+    type Item = (T, U);\n+\n     #[inline]\n-    fn next(&mut self) -> Option<(A, B)> {\n+    fn next(&mut self) -> Option<(T, U)> {\n         match self.a.next() {\n             None => None,\n             Some(x) => match self.b.next() {\n@@ -1401,10 +1474,12 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, T: ExactSizeIterator<A>, U: ExactSizeIterator<B>> DoubleEndedIterator<(A, B)>\n-for Zip<T, U> {\n+impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n+    A: ExactSizeIterator + Iterator<Item=T>,\n+    B: ExactSizeIterator + Iterator<Item=U>,\n+{\n     #[inline]\n-    fn next_back(&mut self) -> Option<(A, B)> {\n+    fn next_back(&mut self) -> Option<(T, U)> {\n         let a_sz = self.a.len();\n         let b_sz = self.b.len();\n         if a_sz != b_sz {\n@@ -1424,15 +1499,17 @@ for Zip<T, U> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, B, T: RandomAccessIterator<A>, U: RandomAccessIterator<B>>\n-RandomAccessIterator<(A, B)> for Zip<T, U> {\n+impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n+    A: RandomAccessIterator + Iterator<Item=T>,\n+    B: RandomAccessIterator + Iterator<Item=U>,\n+{\n     #[inline]\n     fn indexable(&self) -> uint {\n         cmp::min(self.a.indexable(), self.b.indexable())\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<(A, B)> {\n+    fn idx(&mut self, index: uint) -> Option<(T, U)> {\n         match self.a.idx(index) {\n             None => None,\n             Some(x) => match self.b.idx(index) {\n@@ -1446,15 +1523,15 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n /// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Map<A, B, I: Iterator<A>, F: FnMut(A) -> B> {\n+pub struct Map<A, B, I: Iterator<Item=A>, F: FnMut(A) -> B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, B, I, F> Clone for Map<A, B, I, F> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> B,\n {\n     fn clone(&self) -> Map<A, B, I, F> {\n@@ -1465,7 +1542,7 @@ impl<A, B, I, F> Clone for Map<A, B, I, F> where\n     }\n }\n \n-impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n+impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     #[inline]\n     fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n         match elt {\n@@ -1476,7 +1553,9 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> Iterator<B> for Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n+impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n+    type Item = B;\n+\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         let next = self.iter.next();\n@@ -1490,8 +1569,8 @@ impl<A, B, I, F> Iterator<B> for Map<A, B, I, F> where I: Iterator<A>, F: FnMut(\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> DoubleEndedIterator<B> for Map<A, B, I, F> where\n-    I: DoubleEndedIterator<A>,\n+impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n {\n     #[inline]\n@@ -1502,8 +1581,8 @@ impl<A, B, I, F> DoubleEndedIterator<B> for Map<A, B, I, F> where\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, B, I, F> RandomAccessIterator<B> for Map<A, B, I, F> where\n-    I: RandomAccessIterator<A>,\n+impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n+    I: RandomAccessIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n {\n     #[inline]\n@@ -1521,15 +1600,15 @@ impl<A, B, I, F> RandomAccessIterator<B> for Map<A, B, I, F> where\n /// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+pub struct Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, I, P> Clone for Filter<A, I, P> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n {\n     fn clone(&self) -> Filter<A, I, P> {\n@@ -1541,7 +1620,9 @@ impl<A, I, P> Clone for Filter<A, I, P> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, P> Iterator<A> for Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         for x in self.iter {\n@@ -1562,8 +1643,8 @@ impl<A, I, P> Iterator<A> for Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A)\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, P> DoubleEndedIterator<A> for Filter<A, I, P> where\n-    I: DoubleEndedIterator<A>,\n+impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n     P: FnMut(&A) -> bool,\n {\n     #[inline]\n@@ -1580,15 +1661,15 @@ impl<A, I, P> DoubleEndedIterator<A> for Filter<A, I, P> where\n /// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct FilterMap<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> Option<B> {\n+pub struct FilterMap<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> Option<B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> Option<B>,\n {\n     fn clone(&self) -> FilterMap<A, B, I, F> {\n@@ -1600,10 +1681,12 @@ impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> Iterator<B> for FilterMap<A, B, I, F> where\n-    I: Iterator<A>,\n+impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n+    I: Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n {\n+    type Item = B;\n+\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         for x in self.iter {\n@@ -1623,8 +1706,8 @@ impl<A, B, I, F> Iterator<B> for FilterMap<A, B, I, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> DoubleEndedIterator<B> for FilterMap<A, B, I, F> where\n-    I: DoubleEndedIterator<A>,\n+impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n {\n     #[inline]\n@@ -1643,15 +1726,17 @@ impl<A, B, I, F> DoubleEndedIterator<B> for FilterMap<A, B, I, F> where\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Enumerate<T> {\n-    iter: T,\n+pub struct Enumerate<I> {\n+    iter: I,\n     count: uint\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>> Iterator<(uint, A)> for Enumerate<T> {\n+impl<I> Iterator for Enumerate<I> where I: Iterator {\n+    type Item = (uint, <I as Iterator>::Item);\n+\n     #[inline]\n-    fn next(&mut self) -> Option<(uint, A)> {\n+    fn next(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n         match self.iter.next() {\n             Some(a) => {\n                 let ret = Some((self.count, a));\n@@ -1669,9 +1754,9 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for Enumerate<T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: ExactSizeIterator<A>> DoubleEndedIterator<(uint, A)> for Enumerate<T> {\n+impl<I> DoubleEndedIterator for Enumerate<I> where I: ExactSizeIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, A)> {\n+    fn next_back(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n         match self.iter.next_back() {\n             Some(a) => {\n                 let len = self.iter.len();\n@@ -1683,14 +1768,14 @@ impl<A, T: ExactSizeIterator<A>> DoubleEndedIterator<(uint, A)> for Enumerate<T>\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerate<T> {\n+impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<(uint, A)> {\n+    fn idx(&mut self, index: uint) -> Option<(uint, <I as Iterator>::Item)> {\n         match self.iter.idx(index) {\n             Some(a) => Some((self.count + index, a)),\n             _ => None,\n@@ -1702,14 +1787,16 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerat\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n #[deriving(Copy)]\n-pub struct Peekable<A, T> {\n-    iter: T,\n-    peeked: Option<A>,\n+pub struct Peekable<T, I> where I: Iterator<Item=T> {\n+    iter: I,\n+    peeked: Option<T>,\n }\n \n-impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n+impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n+    type Item = T;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<T> {\n         if self.peeked.is_some() { self.peeked.take() }\n         else { self.iter.next() }\n     }\n@@ -1731,11 +1818,11 @@ impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n }\n \n #[stable]\n-impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n+impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n     /// or None if the iterator is exhausted.\n     #[inline]\n-    pub fn peek(&'a mut self) -> Option<&'a A> {\n+    pub fn peek(&mut self) -> Option<&T> {\n         if self.peeked.is_none() {\n             self.peeked = self.iter.next();\n         }\n@@ -1755,7 +1842,7 @@ impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n /// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+pub struct SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n@@ -1764,7 +1851,7 @@ pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, I, P> Clone for SkipWhile<A, I, P> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n {\n     fn clone(&self) -> SkipWhile<A, I, P> {\n@@ -1777,7 +1864,9 @@ impl<A, I, P> Clone for SkipWhile<A, I, P> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         for x in self.iter {\n@@ -1799,7 +1888,7 @@ impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(\n /// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+pub struct TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n@@ -1808,7 +1897,7 @@ pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, I, P> Clone for TakeWhile<A, I, P> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n {\n     fn clone(&self) -> TakeWhile<A, I, P> {\n@@ -1821,7 +1910,9 @@ impl<A, I, P> Clone for TakeWhile<A, I, P> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.flag {\n@@ -1852,15 +1943,17 @@ impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Skip<T> {\n-    iter: T,\n+pub struct Skip<I> {\n+    iter: I,\n     n: uint\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n+impl<I> Iterator for Skip<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n         let mut next = self.iter.next();\n         if self.n == 0 {\n             next\n@@ -1900,14 +1993,14 @@ impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n+impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable().saturating_sub(self.n)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         if index >= self.indexable() {\n             None\n         } else {\n@@ -1920,15 +2013,17 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Take<T> {\n-    iter: T,\n+pub struct Take<I> {\n+    iter: I,\n     n: uint\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n+impl<I> Iterator for Take<I> where I: Iterator{\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n         if self.n != 0 {\n             self.n -= 1;\n             self.iter.next()\n@@ -1953,14 +2048,14 @@ impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n+impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n         cmp::min(self.iter.indexable(), self.n)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         if index >= self.n {\n             None\n         } else {\n@@ -1973,7 +2068,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable = \"waiting for unboxed closures\"]\n-pub struct Scan<A, B, I, St, F> where I: Iterator<A>, F: FnMut(&mut St, A) -> Option<B> {\n+pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n     iter: I,\n     f: F,\n \n@@ -1984,7 +2079,7 @@ pub struct Scan<A, B, I, St, F> where I: Iterator<A>, F: FnMut(&mut St, A) -> Op\n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     St: Clone,\n     F: Clone + FnMut(&mut St, A) -> Option<B>,\n {\n@@ -1998,10 +2093,12 @@ impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, St, F> Iterator<B> for Scan<A, B, I, St, F> where\n-    I: Iterator<A>,\n+impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n+    I: Iterator<Item=A>,\n     F: FnMut(&mut St, A) -> Option<B>,\n {\n+    type Item = B;\n+\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n@@ -2019,7 +2116,11 @@ impl<A, B, I, St, F> Iterator<B> for Scan<A, B, I, St, F> where\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable = \"waiting for unboxed closures\"]\n-pub struct FlatMap<A, B, I, U, F> where I: Iterator<A>, U: Iterator<B>, F: FnMut(A) -> U {\n+pub struct FlatMap<A, B, I, U, F> where\n+    I: Iterator<Item=A>,\n+    U: Iterator<Item=B>,\n+    F: FnMut(A) -> U,\n+{\n     iter: I,\n     f: F,\n     frontiter: Option<U>,\n@@ -2029,8 +2130,8 @@ pub struct FlatMap<A, B, I, U, F> where I: Iterator<A>, U: Iterator<B>, F: FnMut\n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n-    I: Clone + Iterator<A>,\n-    U: Clone + Iterator<B>,\n+    I: Clone + Iterator<Item=A>,\n+    U: Clone + Iterator<Item=B>,\n     F: Clone + FnMut(A) -> U,\n {\n     fn clone(&self) -> FlatMap<A, B, I, U, F> {\n@@ -2044,11 +2145,13 @@ impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, U, F> Iterator<B> for FlatMap<A, B, I, U, F> where\n-    I: Iterator<A>,\n-    U: Iterator<B>,\n+impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n+    I: Iterator<Item=A>,\n+    U: Iterator<Item=B>,\n     F: FnMut(A) -> U,\n {\n+    type Item = B;\n+\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n@@ -2077,9 +2180,9 @@ impl<A, B, I, U, F> Iterator<B> for FlatMap<A, B, I, U, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, U, F> DoubleEndedIterator<B> for FlatMap<A, B, I, U, F> where\n-    I: DoubleEndedIterator<A>,\n-    U: DoubleEndedIterator<B>,\n+impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n+    U: DoubleEndedIterator + Iterator<Item=B>,\n     F: FnMut(A) -> U,\n {\n     #[inline]\n@@ -2104,15 +2207,17 @@ impl<A, B, I, U, F> DoubleEndedIterator<B> for FlatMap<A, B, I, U, F> where\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Fuse<T> {\n-    iter: T,\n+pub struct Fuse<I> {\n+    iter: I,\n     done: bool\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>> Iterator<A> for Fuse<T> {\n+impl<I> Iterator for Fuse<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n         if self.done {\n             None\n         } else {\n@@ -2137,9 +2242,9 @@ impl<A, T: Iterator<A>> Iterator<A> for Fuse<T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Fuse<T> {\n+impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option< <I as Iterator>::Item> {\n         if self.done {\n             None\n         } else {\n@@ -2156,20 +2261,20 @@ impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Fuse<T> {\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Fuse<T> {\n+impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         self.iter.idx(index)\n     }\n }\n \n #[experimental = \"seems marginal\"]\n-impl<T> Fuse<T> {\n+impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n@@ -2182,15 +2287,15 @@ impl<T> Fuse<T> {\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable = \"waiting for unboxed closures\"]\n-pub struct Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n+pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, I, F> Clone for Inspect<A, I, F> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(&A),\n {\n     fn clone(&self) -> Inspect<A, I, F> {\n@@ -2201,7 +2306,7 @@ impl<A, I, F> Clone for Inspect<A, I, F> where\n     }\n }\n \n-impl<A, I, F> Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n+impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     #[inline]\n     fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n         match elt {\n@@ -2214,7 +2319,9 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, F> Iterator<A> for Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n+impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let next = self.iter.next();\n@@ -2228,8 +2335,8 @@ impl<A, I, F> Iterator<A> for Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, F> DoubleEndedIterator<A> for Inspect<A, I, F> where\n-    I: DoubleEndedIterator<A>,\n+impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n {\n     #[inline]\n@@ -2240,8 +2347,8 @@ impl<A, I, F> DoubleEndedIterator<A> for Inspect<A, I, F> where\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, I, F> RandomAccessIterator<A> for Inspect<A, I, F> where\n-    I: RandomAccessIterator<A>,\n+impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n+    I: RandomAccessIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n {\n     #[inline]\n@@ -2323,7 +2430,9 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n }\n \n #[experimental]\n-impl<A, St, F> Iterator<A> for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         (self.f)(&mut self.state)\n@@ -2355,7 +2464,9 @@ pub fn count<A>(start: A, step: A) -> Counter<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n+impl<A: Add<A, A> + Clone> Iterator for Counter<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let result = self.state.clone();\n@@ -2402,7 +2513,9 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n \n // FIXME: #10414: Unfortunate type bound\n #[unstable = \"trait is unstable\"]\n-impl<A: Int + ToPrimitive> Iterator<A> for Range<A> {\n+impl<A: Int + ToPrimitive> Iterator for Range<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.state < self.stop {\n@@ -2450,7 +2563,7 @@ impl<A: Int + ToPrimitive> Iterator<A> for Range<A> {\n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n #[unstable = \"trait is unstable\"]\n-impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n+impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.stop > self.state {\n@@ -2481,7 +2594,9 @@ pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Int + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n+impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         match self.range.next() {\n@@ -2514,7 +2629,7 @@ impl<A: Int + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for RangeInclusive<A> {\n+impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.range.stop > self.range.state {\n@@ -2549,7 +2664,9 @@ pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Int> Iterator<A> for RangeStep<A> {\n+impl<A: Int> Iterator for RangeStep<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if (self.rev && self.state > self.stop) || (!self.rev && self.state < self.stop) {\n@@ -2591,7 +2708,9 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Int> Iterator<A> for RangeStepInclusive<A> {\n+impl<A: Int> Iterator for RangeStepInclusive<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if !self.done && ((self.rev && self.state >= self.stop) ||\n@@ -2683,21 +2802,23 @@ impl<A: Clone> Repeat<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone> Iterator<A> for Repeat<A> {\n+impl<A: Clone> Iterator for Repeat<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.idx(0) }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone> DoubleEndedIterator<A> for Repeat<A> {\n+impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n+impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> uint { uint::MAX }\n     #[inline]\n@@ -2766,7 +2887,11 @@ pub mod order {\n     use super::Iterator;\n \n     /// Compare `a` and `b` for equality using `Eq`\n-    pub fn equals<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn equals<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: Eq,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2777,7 +2902,11 @@ pub mod order {\n     }\n \n     /// Order `a` and `b` lexicographically using `Ord`\n-    pub fn cmp<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> cmp::Ordering {\n+    pub fn cmp<A, T, S>(mut a: T, mut b: S) -> cmp::Ordering where\n+        A: Ord,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return Equal,\n@@ -2792,8 +2921,11 @@ pub mod order {\n     }\n \n     /// Order `a` and `b` lexicographically using `PartialOrd`\n-    pub fn partial_cmp<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S)\n-            -> Option<cmp::Ordering> {\n+    pub fn partial_cmp<A, T, S>(mut a: T, mut b: S) -> Option<cmp::Ordering> where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return Some(Equal),\n@@ -2810,8 +2942,8 @@ pub mod order {\n     /// Compare `a` and `b` for equality (Using partial equality, `PartialEq`)\n     pub fn eq<A, B, L, R>(mut a: L, mut b: R) -> bool where\n         A: PartialEq<B>,\n-        L: Iterator<A>,\n-        R: Iterator<B>,\n+        L: Iterator<Item=A>,\n+        R: Iterator<Item=B>,\n     {\n         loop {\n             match (a.next(), b.next()) {\n@@ -2825,8 +2957,8 @@ pub mod order {\n     /// Compare `a` and `b` for nonequality (Using partial equality, `PartialEq`)\n     pub fn ne<A, B, L, R>(mut a: L, mut b: R) -> bool where\n         A: PartialEq<B>,\n-        L: Iterator<A>,\n-        R: Iterator<B>,\n+        L: Iterator<Item=A>,\n+        R: Iterator<Item=B>,\n     {\n         loop {\n             match (a.next(), b.next()) {\n@@ -2838,7 +2970,11 @@ pub mod order {\n     }\n \n     /// Return `a` < `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn lt<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn lt<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2850,7 +2986,11 @@ pub mod order {\n     }\n \n     /// Return `a` <= `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn le<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn le<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2862,7 +3002,11 @@ pub mod order {\n     }\n \n     /// Return `a` > `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn gt<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn gt<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2874,7 +3018,11 @@ pub mod order {\n     }\n \n     /// Return `a` >= `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn ge<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn ge<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,"}, {"sha": "c5441359ad0c4bbd831dd91fdecb16a98fb49228", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "patch": "@@ -789,7 +789,9 @@ pub struct Range<Idx> {\n \n // FIXME(#19391) needs a snapshot\n //impl<Idx: Clone + Step<T=uint>> Iterator<Idx> for Range<Idx> {\n-impl<Idx: Clone + Step> Iterator<Idx> for Range<Idx> {\n+impl<Idx: Clone + Step> Iterator for Range<Idx> {\n+    type Item = Idx;\n+\n     #[inline]\n     fn next(&mut self) -> Option<Idx> {\n         if self.start < self.end {\n@@ -811,7 +813,7 @@ impl<Idx: Clone + Step> Iterator<Idx> for Range<Idx> {\n     }\n }\n \n-impl<Idx: Clone + Step> DoubleEndedIterator<Idx> for Range<Idx> {\n+impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     #[inline]\n     fn next_back(&mut self) -> Option<Idx> {\n         if self.start < self.end {\n@@ -823,7 +825,7 @@ impl<Idx: Clone + Step> DoubleEndedIterator<Idx> for Range<Idx> {\n     }\n }\n \n-impl<Idx: Clone + Step> ExactSizeIterator<Idx> for Range<Idx> {}\n+impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n \n /// A range which is only bounded below.\n #[deriving(Copy)]\n@@ -833,7 +835,9 @@ pub struct RangeFrom<Idx> {\n     pub start: Idx,\n }\n \n-impl<Idx: Clone + Step> Iterator<Idx> for RangeFrom<Idx> {\n+impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n+    type Item = Idx;\n+\n     #[inline]\n     fn next(&mut self) -> Option<Idx> {\n         // Deliberately overflow so we loop forever."}, {"sha": "92209b937d9271da06ba923ee835571c81d478c1", "filename": "src/libcore/option.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "patch": "@@ -777,7 +777,9 @@ struct Item<A> {\n     opt: Option<A>\n }\n \n-impl<A> Iterator<A> for Item<A> {\n+impl<A> Iterator for Item<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         self.opt.take()\n@@ -792,32 +794,34 @@ impl<A> Iterator<A> for Item<A> {\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for Item<A> {\n+impl<A> DoubleEndedIterator for Item<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         self.opt.take()\n     }\n }\n \n-impl<A> ExactSizeIterator<A> for Item<A> {}\n+impl<A> ExactSizeIterator for Item<A> {}\n \n /// An iterator over a reference of the contained item in an Option.\n #[stable]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n \n-impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n+impl<'a, A> Iterator for Iter<'a, A> {\n+    type Item = &'a A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n+impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n+impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n #[stable]\n impl<'a, A> Clone for Iter<'a, A> {\n@@ -830,37 +834,41 @@ impl<'a, A> Clone for Iter<'a, A> {\n #[stable]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n \n-impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n+impl<'a, A> Iterator for IterMut<'a, A> {\n+    type Item = &'a mut A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n+impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n+impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an Option.\n #[stable]\n pub struct IntoIter<A> { inner: Item<A> }\n \n-impl<A> Iterator<A> for IntoIter<A> {\n+impl<A> Iterator for IntoIter<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n+impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n }\n \n-impl<A> ExactSizeIterator<A> for IntoIter<A> {}\n+impl<A> ExactSizeIterator for IntoIter<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n@@ -887,7 +895,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn from_iter<I: Iterator<Option<A>>>(iter: I) -> Option<V> {\n+    fn from_iter<I: Iterator<Item=Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n@@ -896,7 +904,9 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n             found_none: bool,\n         }\n \n-        impl<T, Iter: Iterator<Option<T>>> Iterator<T> for Adapter<Iter> {\n+        impl<T, Iter: Iterator<Item=Option<T>>> Iterator for Adapter<Iter> {\n+            type Item = T;\n+\n             #[inline]\n             fn next(&mut self) -> Option<T> {\n                 match self.iter.next() {"}, {"sha": "b0ee5672e060dafe7f4d27025a024b0498f3a09d", "filename": "src/libcore/result.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "patch": "@@ -807,7 +807,9 @@ impl<T, E> AsSlice<T> for Result<T, E> {\n #[stable]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n-impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.inner.take() }\n     #[inline]\n@@ -817,12 +819,12 @@ impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n@@ -832,7 +834,9 @@ impl<'a, T> Clone for Iter<'a, T> {\n #[stable]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n-impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }\n     #[inline]\n@@ -842,18 +846,20 @@ impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n+impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An iterator over the value in a `Ok` variant of a `Result`.\n #[stable]\n pub struct IntoIter<T> { inner: Option<T> }\n \n-impl<T> Iterator<T> for IntoIter<T> {\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.inner.take() }\n     #[inline]\n@@ -863,12 +869,12 @@ impl<T> Iterator<T> for IntoIter<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.inner.take() }\n }\n \n-impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n@@ -894,7 +900,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// assert!(res == Ok(vec!(2u, 3u)));\n     /// ```\n     #[inline]\n-    fn from_iter<I: Iterator<Result<A, E>>>(iter: I) -> Result<V, E> {\n+    fn from_iter<I: Iterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n@@ -903,7 +909,9 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n             err: Option<E>,\n         }\n \n-        impl<T, E, Iter: Iterator<Result<T, E>>> Iterator<T> for Adapter<Iter, E> {\n+        impl<T, E, Iter: Iterator<Item=Result<T, E>>> Iterator for Adapter<Iter, E> {\n+            type Item = T;\n+\n             #[inline]\n             fn next(&mut self) -> Option<T> {\n                 match self.iter.next() {\n@@ -941,7 +949,7 @@ pub fn fold<T,\n             V,\n             E,\n             F: FnMut(V, T) -> V,\n-            Iter: Iterator<Result<T, E>>>(\n+            Iter: Iterator<Item=Result<T, E>>>(\n             mut iterator: Iter,\n             mut init: V,\n             mut f: F)"}, {"sha": "bc4e8d32887e2b458548c1bb4c36623396a3622a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "patch": "@@ -647,7 +647,9 @@ impl<'a, T> Default for &'a [T] {\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         #[experimental = \"needs review\"]\n-        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n+        impl<'a, T> Iterator for $name<'a, T> {\n+            type Item = $elem;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n@@ -683,7 +685,7 @@ macro_rules! iterator {\n         }\n \n         #[experimental = \"needs review\"]\n-        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n+        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n@@ -766,15 +768,15 @@ impl<'a,T> Copy for Iter<'a,T> {}\n iterator!{struct Iter -> *const T, &'a T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (exact, _) = self.size_hint();\n@@ -860,14 +862,14 @@ impl<'a, T> IterMut<'a, T> {\n iterator!{struct IterMut -> *mut T, &'a mut T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n+impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An internal abstraction over the splitting iterators, so that\n /// splitn, splitn_mut etc can be implemented once.\n-trait SplitIter<E>: DoubleEndedIterator<E> {\n+trait SplitIter: DoubleEndedIterator {\n     /// Mark the underlying iterator as complete, extracting the remaining\n     /// portion of the slice.\n-    fn finish(&mut self) -> Option<E>;\n+    fn finish(&mut self) -> Option< <Self as Iterator>::Item>;\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n@@ -892,7 +894,9 @@ impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -918,7 +922,7 @@ impl<'a, T, P> Iterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -934,7 +938,7 @@ impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&\n     }\n }\n \n-impl<'a, T, P> SplitIter<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a [T]> {\n         if self.finished { None } else { self.finished = true; Some(self.v) }\n@@ -950,7 +954,7 @@ pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     finished: bool\n }\n \n-impl<'a, T, P> SplitIter<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a mut [T]> {\n         if self.finished {\n@@ -963,7 +967,9 @@ impl<'a, T, P> SplitIter<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T)\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a mut [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -996,7 +1002,7 @@ impl<'a, T, P> Iterator<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for SplitMut<'a, T, P> where\n+impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n     #[inline]\n@@ -1029,9 +1035,11 @@ struct GenericSplitN<I> {\n }\n \n #[experimental = \"needs review\"]\n-impl<E, I: SplitIter<E>> Iterator<E> for GenericSplitN<I> {\n+impl<T, I: SplitIter + Iterator<Item=T>> Iterator for GenericSplitN<I> {\n+    type Item = T;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<E> {\n+    fn next(&mut self) -> Option<T> {\n         if self.count == 0 {\n             self.iter.finish()\n         } else {\n@@ -1075,9 +1083,11 @@ pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n \n macro_rules! forward_iterator {\n     ($name:ident: $elem:ident, $iter_of:ty) => {\n-        impl<'a, $elem, P> Iterator<$iter_of> for $name<'a, $elem, P> where\n+        impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n             P: FnMut(&T) -> bool\n         {\n+            type Item = $iter_of;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$iter_of> {\n                 self.inner.next()\n@@ -1104,7 +1114,9 @@ pub struct Windows<'a, T:'a> {\n     size: uint\n }\n \n-impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n+impl<'a, T> Iterator for Windows<'a, T> {\n+    type Item = &'a [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.size > self.v.len() {\n@@ -1140,7 +1152,9 @@ pub struct Chunks<'a, T:'a> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n+impl<'a, T> Iterator for Chunks<'a, T> {\n+    type Item = &'a [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.v.len() == 0 {\n@@ -1167,7 +1181,7 @@ impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n+impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.v.len() == 0 {\n@@ -1183,7 +1197,7 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n+impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n@@ -1213,7 +1227,9 @@ pub struct ChunksMut<'a, T:'a> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a mut [T]> for ChunksMut<'a, T> {\n+impl<'a, T> Iterator for ChunksMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -1241,7 +1257,7 @@ impl<'a, T> Iterator<&'a mut [T]> for ChunksMut<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for ChunksMut<'a, T> {\n+impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {"}, {"sha": "8df072c9d466f9c335ffff1179563de13ba9d68b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41df05dd0e42b4f1c4f1b834219f3aafe02d4419/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=41df05dd0e42b4f1c4f1b834219f3aafe02d4419", "patch": "@@ -37,7 +37,7 @@ use uint;\n macro_rules! delegate_iter {\n     (exact $te:ty in $ti:ty) => {\n         delegate_iter!{$te in $ti}\n-        impl<'a> ExactSizeIterator<$te> for $ti {\n+        impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n             fn rposition<P>(&mut self, predicate: P) -> Option<uint> where P: FnMut($te) -> bool{\n                 self.0.rposition(predicate)\n@@ -49,7 +49,9 @@ macro_rules! delegate_iter {\n         }\n     };\n     ($te:ty in $ti:ty) => {\n-        impl<'a> Iterator<$te> for $ti {\n+        impl<'a> Iterator for $ti {\n+            type Item = $te;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$te> {\n                 self.0.next()\n@@ -59,15 +61,17 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        impl<'a> DoubleEndedIterator<$te> for $ti {\n+        impl<'a> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n                 self.0.next_back()\n             }\n         }\n     };\n     (pattern $te:ty in $ti:ty) => {\n-        impl<'a, P: CharEq> Iterator<$te> for $ti {\n+        impl<'a, P: CharEq> Iterator for $ti {\n+            type Item = $te;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$te> {\n                 self.0.next()\n@@ -77,15 +81,17 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        impl<'a, P: CharEq> DoubleEndedIterator<$te> for $ti {\n+        impl<'a, P: CharEq> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n                 self.0.next_back()\n             }\n         }\n     };\n     (pattern forward $te:ty in $ti:ty) => {\n-        impl<'a, P: CharEq> Iterator<$te> for $ti {\n+        impl<'a, P: CharEq> Iterator for $ti {\n+            type Item = $te;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$te> {\n                 self.0.next()\n@@ -275,7 +281,9 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n     }\n }\n \n-impl<'a> Iterator<char> for Chars<'a> {\n+impl<'a> Iterator for Chars<'a> {\n+    type Item = char;\n+\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         // Decode UTF-8, using the valid UTF-8 invariant\n@@ -318,7 +326,7 @@ impl<'a> Iterator<char> for Chars<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n+impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n         let w = match self.iter.next_back() {\n@@ -359,7 +367,9 @@ pub struct CharIndices<'a> {\n     iter: Chars<'a>,\n }\n \n-impl<'a> Iterator<(uint, char)> for CharIndices<'a> {\n+impl<'a> Iterator for CharIndices<'a> {\n+    type Item = (uint, char);\n+\n     #[inline]\n     fn next(&mut self) -> Option<(uint, char)> {\n         let (pre_len, _) = self.iter.iter.size_hint();\n@@ -380,7 +390,7 @@ impl<'a> Iterator<(uint, char)> for CharIndices<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<(uint, char)> for CharIndices<'a> {\n+impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         match self.iter.next_back() {\n@@ -463,7 +473,9 @@ impl<'a, Sep> CharSplits<'a, Sep> {\n     }\n }\n \n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n+impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n@@ -495,8 +507,7 @@ impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n     }\n }\n \n-impl<'a, Sep: CharEq> DoubleEndedIterator<&'a str>\n-for CharSplits<'a, Sep> {\n+impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n@@ -537,7 +548,9 @@ for CharSplits<'a, Sep> {\n     }\n }\n \n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitsN<'a, Sep> {\n+impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.count != 0 {\n@@ -864,7 +877,9 @@ pub struct SplitStr<'a> {\n #[deprecated = \"Type is now named `SplitStr`\"]\n pub type StrSplits<'a> = SplitStr<'a>;\n \n-impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n+impl<'a> Iterator for MatchIndices<'a> {\n+    type Item = (uint, uint);\n+\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n         match self.searcher {\n@@ -878,7 +893,9 @@ impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n     }\n }\n \n-impl<'a> Iterator<&'a str> for SplitStr<'a> {\n+impl<'a> Iterator for SplitStr<'a> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None; }\n@@ -1672,23 +1689,27 @@ impl<'a> Default for &'a str {\n     fn default() -> &'a str { \"\" }\n }\n \n-impl<'a> Iterator<&'a str> for Lines<'a> {\n+impl<'a> Iterator for Lines<'a> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a> DoubleEndedIterator<&'a str> for Lines<'a> {\n+impl<'a> DoubleEndedIterator for Lines<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }\n-impl<'a> Iterator<&'a str> for LinesAny<'a> {\n+impl<'a> Iterator for LinesAny<'a> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a> DoubleEndedIterator<&'a str> for LinesAny<'a> {\n+impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }"}]}