{"sha": "9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZjYyZjcxYmM1ZTE4NDRhMmI2M2E3N2MyYzBiNGMxZDY3ZmFmOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-30T14:06:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-30T14:06:42Z"}, "message": "auto merge of #10727 : erickt/rust/json, r=huonw\n\nThis PR does some small modernizations to the json library. First is to remove the `@` boxes, second is to rename the constructors to `new`.", "tree": {"sha": "b63b79addfd1a3482f50db13a293c597b66a7d68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b63b79addfd1a3482f50db13a293c597b66a7d68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "html_url": "https://github.com/rust-lang/rust/commit/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eeaf2e1ddc65e8307fd1ef7ad84ee51396c4d56e", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeaf2e1ddc65e8307fd1ef7ad84ee51396c4d56e", "html_url": "https://github.com/rust-lang/rust/commit/eeaf2e1ddc65e8307fd1ef7ad84ee51396c4d56e"}, {"sha": "a7b311ac614ea15f7261eb2ddca56072c18b3cba", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7b311ac614ea15f7261eb2ddca56072c18b3cba", "html_url": "https://github.com/rust-lang/rust/commit/a7b311ac614ea15f7261eb2ddca56072c18b3cba"}], "stats": {"total": 395, "additions": 200, "deletions": 195}, "files": [{"sha": "30288a08c79df5c48f7c9370864495f6809a55ac", "filename": "src/libextra/json.rs", "status": "modified", "additions": 173, "deletions": 173, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "patch": "@@ -54,7 +54,7 @@ pub struct Error {\n     /// The column number at which the error occurred\n     priv col: uint,\n     /// A message describing the type of the error\n-    priv msg: @~str,\n+    priv msg: ~str,\n }\n \n fn escape_str(s: &str) -> ~str {\n@@ -84,17 +84,19 @@ fn spaces(n: uint) -> ~str {\n }\n \n /// A structure for implementing serialization to JSON.\n-pub struct Encoder {\n-    priv wr: @mut io::Writer,\n+pub struct Encoder<'self> {\n+    priv wr: &'self mut io::Writer,\n }\n \n-/// Creates a new JSON encoder whose output will be written to the writer\n-/// specified.\n-pub fn Encoder(wr: @mut io::Writer) -> Encoder {\n-    Encoder { wr: wr }\n+impl<'self> Encoder<'self> {\n+    /// Creates a new JSON encoder whose output will be written to the writer\n+    /// specified.\n+    pub fn init<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n+        Encoder { wr: wr }\n+    }\n }\n \n-impl serialize::Encoder for Encoder {\n+impl<'self> serialize::Encoder for Encoder<'self> {\n     fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n@@ -127,13 +129,13 @@ impl serialize::Encoder for Encoder {\n         write!(self.wr, \"{}\", escape_str(v))\n     }\n \n-    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder|) { f(self) }\n+    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'self>|) { f(self) }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _id: uint,\n                          cnt: uint,\n-                         f: |&mut Encoder|) {\n+                         f: |&mut Encoder<'self>|) {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n@@ -148,7 +150,7 @@ impl serialize::Encoder for Encoder {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n@@ -159,18 +161,18 @@ impl serialize::Encoder for Encoder {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: |&mut Encoder|) {\n+                                f: |&mut Encoder<'self>|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: |&mut Encoder|) {\n+                                      f: |&mut Encoder<'self>|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder|) {\n+    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'self>|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n@@ -179,79 +181,81 @@ impl serialize::Encoder for Encoder {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: |&mut Encoder|) {\n+                         f: |&mut Encoder<'self>|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         write!(self.wr, \"{}:\", escape_str(name));\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder|) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'self>|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _name: &str,\n                          len: uint,\n-                         f: |&mut Encoder|) {\n+                         f: |&mut Encoder<'self>|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut Encoder|) { f(self); }\n+    fn emit_option(&mut self, f: |&mut Encoder<'self>|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut Encoder|) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut Encoder<'self>|) { f(self); }\n \n-    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder|) {\n+    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'self>|) {\n         write!(self.wr, \"[\");\n         f(self);\n         write!(self.wr, \"]\");\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n         f(self)\n     }\n \n-    fn emit_map(&mut self, _len: uint, f: |&mut Encoder|) {\n+    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'self>|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         f(self)\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder|) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'self>|) {\n         write!(self.wr, \":\");\n         f(self)\n     }\n }\n \n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n-pub struct PrettyEncoder {\n-    priv wr: @mut io::Writer,\n+pub struct PrettyEncoder<'self> {\n+    priv wr: &'self mut io::Writer,\n     priv indent: uint,\n }\n \n-/// Creates a new encoder whose output will be written to the specified writer\n-pub fn PrettyEncoder(wr: @mut io::Writer) -> PrettyEncoder {\n-    PrettyEncoder {\n-        wr: wr,\n-        indent: 0,\n+impl<'self> PrettyEncoder<'self> {\n+    /// Creates a new encoder whose output will be written to the specified writer\n+    pub fn init<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+        PrettyEncoder {\n+            wr: wr,\n+            indent: 0,\n+        }\n     }\n }\n \n-impl serialize::Encoder for PrettyEncoder {\n+impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n     fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n@@ -282,15 +286,15 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) { write!(self.wr, \"{}\", escape_str(v)); }\n \n-    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder|) {\n+    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'self>|) {\n         f(self)\n     }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _: uint,\n                          cnt: uint,\n-                         f: |&mut PrettyEncoder|) {\n+                         f: |&mut PrettyEncoder<'self>|) {\n         if cnt == 0 {\n             write!(self.wr, \"{}\", escape_str(name));\n         } else {\n@@ -304,7 +308,7 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n-                             f: |&mut PrettyEncoder|) {\n+                             f: |&mut PrettyEncoder<'self>|) {\n         if idx != 0 {\n             write!(self.wr, \",\\n\");\n         }\n@@ -316,22 +320,22 @@ impl serialize::Encoder for PrettyEncoder {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: |&mut PrettyEncoder|) {\n+                                f: |&mut PrettyEncoder<'self>|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: |&mut PrettyEncoder|) {\n+                                      f: |&mut PrettyEncoder<'self>|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n     fn emit_struct(&mut self,\n                    _: &str,\n                    len: uint,\n-                   f: |&mut PrettyEncoder|) {\n+                   f: |&mut PrettyEncoder<'self>|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -346,7 +350,7 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: |&mut PrettyEncoder|) {\n+                         f: |&mut PrettyEncoder<'self>|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -356,30 +360,30 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder<'self>|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder<'self>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _: &str,\n                          len: uint,\n-                         f: |&mut PrettyEncoder|) {\n+                         f: |&mut PrettyEncoder<'self>|) {\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg(&mut self,\n                              idx: uint,\n-                             f: |&mut PrettyEncoder|) {\n+                             f: |&mut PrettyEncoder<'self>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut PrettyEncoder|) { f(self); }\n+    fn emit_option(&mut self, f: |&mut PrettyEncoder<'self>|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut PrettyEncoder|) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'self>|) { f(self); }\n \n-    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'self>|) {\n         if len == 0 {\n             write!(self.wr, \"[]\");\n         } else {\n@@ -391,7 +395,7 @@ impl serialize::Encoder for PrettyEncoder {\n         }\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'self>|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -401,7 +405,7 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self)\n     }\n \n-    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'self>|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -413,7 +417,7 @@ impl serialize::Encoder for PrettyEncoder {\n         }\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'self>|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -423,7 +427,7 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self);\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'self>|) {\n         write!(self.wr, \": \");\n         f(self);\n     }\n@@ -444,43 +448,45 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n \n impl Json{\n     /// Encodes a json value into a io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: @mut io::Writer) {\n-        let mut encoder = Encoder(wr);\n+    pub fn to_writer(&self, wr: &mut io::Writer) {\n+        let mut encoder = Encoder::init(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: @mut io::Writer) {\n-        let mut encoder = PrettyEncoder(wr);\n+    pub fn to_pretty_writer(&self, wr: &mut io::Writer) {\n+        let mut encoder = PrettyEncoder::init(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a string\n     pub fn to_pretty_str(&self) -> ~str {\n-        let s = @mut MemWriter::new();\n-        self.to_pretty_writer(s as @mut io::Writer);\n-        str::from_utf8(s.inner_ref().as_slice())\n+        let mut s = MemWriter::new();\n+        self.to_pretty_writer(&mut s as &mut io::Writer);\n+        str::from_utf8_owned(s.inner())\n     }\n }\n \n pub struct Parser<T> {\n-    priv rdr: ~T,\n+    priv rdr: T,\n     priv ch: char,\n     priv line: uint,\n     priv col: uint,\n }\n \n-/// Decode a json value from an Iterator<char>\n-pub fn Parser<T : Iterator<char>>(rdr: ~T) -> Parser<T> {\n-    let mut p = Parser {\n-        rdr: rdr,\n-        ch: '\\x00',\n-        line: 1,\n-        col: 0,\n-    };\n-    p.bump();\n-    p\n+impl<T: Iterator<char>> Parser<T> {\n+    /// Decode a json value from an Iterator<char>\n+    pub fn init(rdr: T) -> Parser<T> {\n+        let mut p = Parser {\n+            rdr: rdr,\n+            ch: '\\x00',\n+            line: 1,\n+            col: 0,\n+        };\n+        p.bump();\n+        p\n+    }\n }\n \n impl<T: Iterator<char>> Parser<T> {\n@@ -525,7 +531,7 @@ impl<T : Iterator<char>> Parser<T> {\n     }\n \n     fn error<T>(&self, msg: ~str) -> Result<T, Error> {\n-        Err(Error { line: self.line, col: self.col, msg: @msg })\n+        Err(Error { line: self.line, col: self.col, msg: msg })\n     }\n \n     fn parse_value(&mut self) -> Result<Json, Error> {\n@@ -841,14 +847,14 @@ impl<T : Iterator<char>> Parser<T> {\n \n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n-    let s = str::from_utf8(rdr.read_to_end());\n-    let mut parser = Parser(~s.chars());\n+    let s = str::from_utf8_owned(rdr.read_to_end());\n+    let mut parser = Parser::init(s.chars());\n     parser.parse()\n }\n \n /// Decodes a json value from a string\n pub fn from_str(s: &str) -> Result<Json, Error> {\n-    let mut parser = Parser(~s.chars());\n+    let mut parser = Parser::init(s.chars());\n     parser.parse()\n }\n \n@@ -857,10 +863,12 @@ pub struct Decoder {\n     priv stack: ~[Json],\n }\n \n-/// Creates a new decoder instance for decoding the specified JSON value.\n-pub fn Decoder(json: Json) -> Decoder {\n-    Decoder {\n-        stack: ~[json]\n+impl Decoder {\n+    /// Creates a new decoder instance for decoding the specified JSON value.\n+    pub fn init(json: Json) -> Decoder {\n+        Decoder {\n+            stack: ~[json]\n+        }\n     }\n }\n \n@@ -1195,10 +1203,6 @@ impl ToJson for Json {\n     fn to_json(&self) -> Json { (*self).clone() }\n }\n \n-impl ToJson for @Json {\n-    fn to_json(&self) -> Json { (**self).to_json() }\n-}\n-\n impl ToJson for int {\n     fn to_json(&self) -> Json { Number(*self as f64) }\n }\n@@ -1259,10 +1263,6 @@ impl ToJson for ~str {\n     fn to_json(&self) -> Json { String((*self).clone()) }\n }\n \n-impl ToJson for @~str {\n-    fn to_json(&self) -> Json { String((**self).clone()) }\n-}\n-\n impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n     fn to_json(&self) -> Json {\n         match *self {\n@@ -1319,15 +1319,15 @@ impl<A:ToJson> ToJson for Option<A> {\n impl to_str::ToStr for Json {\n     /// Encodes a json value into a string\n     fn to_str(&self) -> ~str {\n-        let s = @mut MemWriter::new();\n-        self.to_writer(s as @mut io::Writer);\n-        str::from_utf8(s.inner_ref().as_slice())\n+        let mut s = MemWriter::new();\n+        self.to_writer(&mut s as &mut io::Writer);\n+        str::from_utf8_owned(s.inner())\n     }\n }\n \n impl to_str::ToStr for Error {\n     fn to_str(&self) -> ~str {\n-        format!(\"{}:{}: {}\", self.line, self.col, *self.msg)\n+        format!(\"{}:{}: {}\", self.line, self.col, self.msg)\n     }\n }\n \n@@ -1507,29 +1507,29 @@ mod tests {\n         assert_eq!(a.clone(), from_str(a.to_pretty_str()).unwrap());\n     }\n \n-    fn with_str_writer(f: |@mut io::Writer|) -> ~str {\n+    fn with_str_writer(f: |&mut io::Writer|) -> ~str {\n         use std::io::mem::MemWriter;\n         use std::io::Decorator;\n         use std::str;\n \n-        let m = @mut MemWriter::new();\n-        f(m as @mut io::Writer);\n-        str::from_utf8(*m.inner_ref())\n+        let mut m = MemWriter::new();\n+        f(&mut m as &mut io::Writer);\n+        str::from_utf8_owned(m.inner())\n     }\n \n     #[test]\n     fn test_write_enum() {\n         let animal = Dog;\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = Encoder(wr);\n+                let mut encoder = Encoder::init(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder(wr);\n+                let mut encoder = PrettyEncoder::init(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\"Dog\\\"\"\n@@ -1538,14 +1538,14 @@ mod tests {\n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = Encoder(wr);\n+                let mut encoder = Encoder::init(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder(wr);\n+                let mut encoder = PrettyEncoder::init(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\n@@ -1561,14 +1561,14 @@ mod tests {\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder(wr);\n+            let mut encoder = Encoder::init(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n-            let mut encoder = PrettyEncoder(wr);\n+            let mut encoder = PrettyEncoder::init(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n@@ -1578,13 +1578,13 @@ mod tests {\n     fn test_write_none() {\n         let value: Option<~str> = None;\n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder(wr);\n+            let mut encoder = Encoder::init(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"null\");\n \n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder(wr);\n+            let mut encoder = Encoder::init(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"null\");\n@@ -1593,35 +1593,35 @@ mod tests {\n     #[test]\n     fn test_trailing_characters() {\n         assert_eq!(from_str(\"nulla\"),\n-            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n+            Err(Error {line: 1u, col: 5u, msg: ~\"trailing characters\"}));\n         assert_eq!(from_str(\"truea\"),\n-            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n+            Err(Error {line: 1u, col: 5u, msg: ~\"trailing characters\"}));\n         assert_eq!(from_str(\"falsea\"),\n-            Err(Error {line: 1u, col: 6u, msg: @~\"trailing characters\"}));\n+            Err(Error {line: 1u, col: 6u, msg: ~\"trailing characters\"}));\n         assert_eq!(from_str(\"1a\"),\n-            Err(Error {line: 1u, col: 2u, msg: @~\"trailing characters\"}));\n+            Err(Error {line: 1u, col: 2u, msg: ~\"trailing characters\"}));\n         assert_eq!(from_str(\"[]a\"),\n-            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n+            Err(Error {line: 1u, col: 3u, msg: ~\"trailing characters\"}));\n         assert_eq!(from_str(\"{}a\"),\n-            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n+            Err(Error {line: 1u, col: 3u, msg: ~\"trailing characters\"}));\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n         assert_eq!(from_str(\"n\"),\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n         assert_eq!(from_str(\"nul\"),\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n+            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n \n         assert_eq!(from_str(\"t\"),\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n         assert_eq!(from_str(\"truz\"),\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n+            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n \n         assert_eq!(from_str(\"f\"),\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n         assert_eq!(from_str(\"faz\"),\n-            Err(Error {line: 1u, col: 3u, msg: @~\"invalid syntax\"}));\n+            Err(Error {line: 1u, col: 3u, msg: ~\"invalid syntax\"}));\n \n         assert_eq!(from_str(\"null\"), Ok(Null));\n         assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n@@ -1633,36 +1633,36 @@ mod tests {\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let mut decoder = Decoder(from_str(\"null\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"null\").unwrap());\n         let v: () = Decodable::decode(&mut decoder);\n         assert_eq!(v, ());\n \n-        let mut decoder = Decoder(from_str(\"true\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"true\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, true);\n \n-        let mut decoder = Decoder(from_str(\"false\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"false\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, false);\n     }\n \n     #[test]\n     fn test_read_number() {\n         assert_eq!(from_str(\"+\"),\n-            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n+            Err(Error {line: 1u, col: 1u, msg: ~\"invalid syntax\"}));\n         assert_eq!(from_str(\".\"),\n-            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n+            Err(Error {line: 1u, col: 1u, msg: ~\"invalid syntax\"}));\n \n         assert_eq!(from_str(\"-\"),\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid number\"}));\n         assert_eq!(from_str(\"00\"),\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid number\"}));\n         assert_eq!(from_str(\"1.\"),\n-            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n+            Err(Error {line: 1u, col: 3u, msg: ~\"invalid number\"}));\n         assert_eq!(from_str(\"1e\"),\n-            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n+            Err(Error {line: 1u, col: 3u, msg: ~\"invalid number\"}));\n         assert_eq!(from_str(\"1e+\"),\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"}));\n+            Err(Error {line: 1u, col: 4u, msg: ~\"invalid number\"}));\n \n         assert_eq!(from_str(\"3\"), Ok(Number(3.0)));\n         assert_eq!(from_str(\"3.1\"), Ok(Number(3.1)));\n@@ -1676,42 +1676,42 @@ mod tests {\n \n     #[test]\n     fn test_decode_numbers() {\n-        let mut decoder = Decoder(from_str(\"3\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"3\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.0);\n \n-        let mut decoder = Decoder(from_str(\"3.1\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"3.1\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.1);\n \n-        let mut decoder = Decoder(from_str(\"-1.2\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"-1.2\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, -1.2);\n \n-        let mut decoder = Decoder(from_str(\"0.4\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"0.4\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4);\n \n-        let mut decoder = Decoder(from_str(\"0.4e5\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"0.4e5\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e5);\n \n-        let mut decoder = Decoder(from_str(\"0.4e15\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"0.4e15\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e15);\n \n-        let mut decoder = Decoder(from_str(\"0.4e-01\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"0.4e-01\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e-01);\n     }\n \n     #[test]\n     fn test_read_str() {\n         assert_eq!(from_str(\"\\\"\"),\n-            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing string\"\n+            Err(Error {line: 1u, col: 2u, msg: ~\"EOF while parsing string\"\n         }));\n         assert_eq!(from_str(\"\\\"lol\"),\n-            Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing string\"\n+            Err(Error {line: 1u, col: 5u, msg: ~\"EOF while parsing string\"\n         }));\n \n         assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(~\"\")));\n@@ -1728,55 +1728,55 @@ mod tests {\n \n     #[test]\n     fn test_decode_str() {\n-        let mut decoder = Decoder(from_str(\"\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"foo\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"foo\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"foo\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\\"\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\b\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\b\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\x08\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\n\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\n\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\n\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\r\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\r\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\r\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\t\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\t\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\t\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\u12ab\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\uAB12\");\n     }\n \n     #[test]\n     fn test_read_list() {\n         assert_eq!(from_str(\"[\"),\n-            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing value\"}));\n+            Err(Error {line: 1u, col: 2u, msg: ~\"EOF while parsing value\"}));\n         assert_eq!(from_str(\"[1\"),\n-            Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing list\"}));\n+            Err(Error {line: 1u, col: 3u, msg: ~\"EOF while parsing list\"}));\n         assert_eq!(from_str(\"[1,\"),\n-            Err(Error {line: 1u, col: 4u, msg: @~\"EOF while parsing value\"}));\n+            Err(Error {line: 1u, col: 4u, msg: ~\"EOF while parsing value\"}));\n         assert_eq!(from_str(\"[1,]\"),\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n+            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n         assert_eq!(from_str(\"[6 7]\"),\n-            Err(Error {line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"}));\n+            Err(Error {line: 1u, col: 4u, msg: ~\"expected `,` or `]`\"}));\n \n         assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n         assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n@@ -1793,27 +1793,27 @@ mod tests {\n \n     #[test]\n     fn test_decode_list() {\n-        let mut decoder = Decoder(from_str(\"[]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[]);\n \n-        let mut decoder = Decoder(from_str(\"[null]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[null]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[()]);\n \n-        let mut decoder = Decoder(from_str(\"[true]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder(from_str(\"[true]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder(from_str(\"[3, 1]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[3, 1]\").unwrap());\n         let v: ~[int] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[3, 1]);\n \n-        let mut decoder = Decoder(from_str(\"[[3], [1, 2]]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[[3], [1, 2]]\").unwrap());\n         let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[~[3], ~[1, 2]]);\n     }\n@@ -1824,49 +1824,49 @@ mod tests {\n             Err(Error {\n                 line: 1u,\n                 col: 2u,\n-                msg: @~\"EOF while parsing object\"}));\n+                msg: ~\"EOF while parsing object\"}));\n         assert_eq!(from_str(\"{ \"),\n             Err(Error {\n                 line: 1u,\n                 col: 3u,\n-                msg: @~\"EOF while parsing object\"}));\n+                msg: ~\"EOF while parsing object\"}));\n         assert_eq!(from_str(\"{1\"),\n             Err(Error {\n                 line: 1u,\n                 col: 2u,\n-                msg: @~\"key must be a string\"}));\n+                msg: ~\"key must be a string\"}));\n         assert_eq!(from_str(\"{ \\\"a\\\"\"),\n             Err(Error {\n                 line: 1u,\n                 col: 6u,\n-                msg: @~\"EOF while parsing object\"}));\n+                msg: ~\"EOF while parsing object\"}));\n         assert_eq!(from_str(\"{\\\"a\\\"\"),\n             Err(Error {\n                 line: 1u,\n                 col: 5u,\n-                msg: @~\"EOF while parsing object\"}));\n+                msg: ~\"EOF while parsing object\"}));\n         assert_eq!(from_str(\"{\\\"a\\\" \"),\n             Err(Error {\n                 line: 1u,\n                 col: 6u,\n-                msg: @~\"EOF while parsing object\"}));\n+                msg: ~\"EOF while parsing object\"}));\n \n         assert_eq!(from_str(\"{\\\"a\\\" 1\"),\n-            Err(Error {line: 1u, col: 6u, msg: @~\"expected `:`\"}));\n+            Err(Error {line: 1u, col: 6u, msg: ~\"expected `:`\"}));\n         assert_eq!(from_str(\"{\\\"a\\\":\"),\n-            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing value\"}));\n+            Err(Error {line: 1u, col: 6u, msg: ~\"EOF while parsing value\"}));\n         assert_eq!(from_str(\"{\\\"a\\\":1\"),\n             Err(Error {\n                 line: 1u,\n                 col: 7u,\n-                msg: @~\"EOF while parsing object\"}));\n+                msg: ~\"EOF while parsing object\"}));\n         assert_eq!(from_str(\"{\\\"a\\\":1 1\"),\n-            Err(Error {line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"}));\n+            Err(Error {line: 1u, col: 8u, msg: ~\"expected `,` or `}`\"}));\n         assert_eq!(from_str(\"{\\\"a\\\":1,\"),\n             Err(Error {\n                 line: 1u,\n                 col: 8u,\n-                msg: @~\"EOF while parsing object\"}));\n+                msg: ~\"EOF while parsing object\"}));\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n@@ -1915,7 +1915,7 @@ mod tests {\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n         }\";\n-        let mut decoder = Decoder(from_str(s).unwrap());\n+        let mut decoder = Decoder::init(from_str(s).unwrap());\n         let v: Outer = Decodable::decode(&mut decoder);\n         assert_eq!(\n             v,\n@@ -1929,31 +1929,31 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let mut decoder = Decoder(from_str(\"null\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"null\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, None);\n \n-        let mut decoder = Decoder(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let mut decoder = Decoder(from_str(\"\\\"Dog\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"Dog\\\"\").unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Dog);\n \n-        let mut decoder =\n-            Decoder(from_str(\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\").unwrap());\n+        let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n+        let mut decoder = Decoder::init(from_str(s).unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut decoder = Decoder(from_str(s).unwrap());\n+        let mut decoder = Decoder::init(from_str(s).unwrap());\n         let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder);\n \n         assert_eq!(map.pop(&~\"a\"), Some(Dog));\n@@ -1966,7 +1966,7 @@ mod tests {\n             Err(Error {\n                 line: 3u,\n                 col: 8u,\n-                msg: @~\"EOF while parsing object\"}));\n+                msg: ~\"EOF while parsing object\"}));\n     }\n \n     #[deriving(Decodable)]\n@@ -1990,7 +1990,7 @@ mod tests {\n             match from_str(to_parse) {\n                 Err(e) => Some(e.to_str()),\n                 Ok(json) => {\n-                    let _: T = Decodable::decode(&mut Decoder(json));\n+                    let _: T = Decodable::decode(&mut Decoder::init(json));\n                     None\n                 }\n             }"}, {"sha": "93ffb8f9fde5eeda21b76aa670c93ad73c442ca9", "filename": "src/libextra/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "patch": "@@ -945,8 +945,9 @@ impl MetricMap {\n     /// Load MetricDiff from a file.\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(p.exists());\n-        let f = @mut File::open(p) as @mut io::Reader;\n-        let mut decoder = json::Decoder(json::from_reader(f).unwrap());\n+        let mut f = File::open(p);\n+        let value = json::from_reader(&mut f as &mut io::Reader).unwrap();\n+        let mut decoder = json::Decoder::init(value);\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n "}, {"sha": "ab36defe5221418f28e6aa49114c8e09ef49b9b1", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "patch": "@@ -191,7 +191,7 @@ impl Database {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n-                        let mut decoder = json::Decoder(r);\n+                        let mut decoder = json::Decoder::init(r);\n                         self.db_cache = Decodable::decode(&mut decoder);\n                     }\n             }\n@@ -256,9 +256,9 @@ enum Work<'self, T> {\n     WorkFromTask(&'self Prep<'self>, PortOne<(Exec, T)>),\n }\n \n-fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    let writer = @mut MemWriter::new();\n-    let mut encoder = json::Encoder(writer as @mut io::Writer);\n+fn json_encode<'self, T:Encodable<json::Encoder<'self>>>(t: &T) -> ~str {\n+    let mut writer = MemWriter::new();\n+    let mut encoder = json::Encoder::init(&mut writer as &mut io::Writer);\n     t.encode(&mut encoder);\n     str::from_utf8(writer.inner_ref().as_slice())\n }\n@@ -267,7 +267,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     debug!(\"json decoding: {}\", s);\n     let j = json::from_str(s).unwrap();\n-    let mut decoder = json::Decoder(j);\n+    let mut decoder = json::Decoder::init(j);\n     Decodable::decode(&mut decoder)\n }\n \n@@ -396,15 +396,15 @@ impl<'self> Prep<'self> {\n         return true;\n     }\n \n-    pub fn exec<T:Send +\n-        Encodable<json::Encoder> +\n+    pub fn exec<'self, T:Send +\n+        Encodable<json::Encoder<'self>> +\n         Decodable<json::Decoder>>(\n             &'self self, blk: proc(&mut Exec) -> T) -> T {\n         self.exec_work(blk).unwrap()\n     }\n \n-    fn exec_work<T:Send +\n-        Encodable<json::Encoder> +\n+    fn exec_work<'self, T:Send +\n+        Encodable<json::Encoder<'self>> +\n         Decodable<json::Decoder>>( // FIXME(#5121)\n             &'self self, blk: proc(&mut Exec) -> T) -> Work<'self, T> {\n         let mut bo = Some(blk);\n@@ -449,7 +449,7 @@ impl<'self> Prep<'self> {\n }\n \n impl<'self, T:Send +\n-       Encodable<json::Encoder> +\n+       Encodable<json::Encoder<'self>> +\n        Decodable<json::Decoder>>\n     Work<'self, T> { // FIXME(#5121)\n "}, {"sha": "e699aa2edeff986111be8c3885e082e871ab1409", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "patch": "@@ -283,7 +283,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n             }\n             let crate = match obj.pop(&~\"crate\") {\n                 Some(json) => {\n-                    let mut d = json::Decoder(json);\n+                    let mut d = json::Decoder::init(json);\n                     Decodable::decode(&mut d)\n                 }\n                 None => return Err(~\"malformed json\"),\n@@ -312,9 +312,12 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n     let crate_json_str = {\n-        let w = @mut MemWriter::new();\n-        crate.encode(&mut json::Encoder(w as @mut io::Writer));\n-        str::from_utf8(*w.inner_ref())\n+        let mut w = MemWriter::new();\n+        {\n+            let mut encoder = json::Encoder::init(&mut w as &mut io::Writer);\n+            crate.encode(&mut encoder);\n+        }\n+        str::from_utf8_owned(w.inner())\n     };\n     let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,"}, {"sha": "54a3dad94959d2ae523362d5d17a963aaf91f337", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "patch": "@@ -341,11 +341,12 @@ mod test {\n     use util::parser_testing::{string_to_expr, string_to_item};\n     use util::parser_testing::string_to_stmt;\n \n-    #[cfg(test)] fn to_json_str<E : Encodable<extra::json::Encoder>>(val: @E) -> ~str {\n-        let writer = @mut MemWriter::new();\n-        let mut encoder = extra::json::Encoder(writer as @mut io::Writer);\n+    #[cfg(test)]\n+    fn to_json_str<'a, E: Encodable<extra::json::Encoder<'a>>>(val: &E) -> ~str {\n+        let mut writer = MemWriter::new();\n+        let mut encoder = extra::json::Encoder::init(&mut writer as &mut io::Writer);\n         val.encode(&mut encoder);\n-        str::from_utf8(*writer.inner_ref())\n+        str::from_utf8_owned(writer.inner())\n     }\n \n     // produce a codemap::span"}, {"sha": "578d210a6fc3f179f9e4d780f1d7f3994a197175", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "patch": "@@ -18,7 +18,7 @@ trait JD : Decodable<json::Decoder> { }\n \n fn exec<T: JD>() {\n     let doc = json::from_str(\"\").unwrap();\n-    let mut decoder = json::Decoder(doc);\n+    let mut decoder = json::Decoder::init(doc);\n     let _v: T = Decodable::decode(&mut decoder);\n     fail!()\n }"}, {"sha": "bd3ca844263510ce261b9f7f1e68abd68d9a7104", "filename": "src/test/run-pass/issue-4036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4036.rs?ref=9bf62f71bc5e1844a2b63a77c2c0b4c1d67faf91", "patch": "@@ -17,6 +17,6 @@ use self::extra::serialize;\n \n pub fn main() {\n     let json = json::from_str(\"[1]\").unwrap();\n-    let mut decoder = json::Decoder(json);\n+    let mut decoder = json::Decoder::init(json);\n     let _x: ~[int] = serialize::Decodable::decode(&mut decoder);\n }"}]}