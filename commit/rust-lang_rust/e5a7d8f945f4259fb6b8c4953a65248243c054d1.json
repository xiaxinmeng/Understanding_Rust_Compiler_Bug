{"sha": "e5a7d8f945f4259fb6b8c4953a65248243c054d1", "node_id": "C_kwDOAAsO6NoAKGU1YTdkOGY5NDVmNDI1OWZiNmI4YzQ5NTNhNjUyNDgyNDNjMDU0ZDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-31T13:26:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-31T13:26:27Z"}, "message": "Auto merge of #99979 - Dylan-DPC:rollup-ikkejgy, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #99186 (Use LocalDefId for closures more)\n - #99741 (Use `impl`'s generics when suggesting fix on bad `impl Copy`)\n - #99844 (Introduce an ArchiveBuilderBuilder)\n - #99921 (triagebot.yml: CC Enselic when rustdoc-json-types changes)\n - #99974 (Suggest removing a semicolon and boxing the expressions for if-else)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "00c56cd7266df82399b9982b57ac9f5485618692", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00c56cd7266df82399b9982b57ac9f5485618692"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5a7d8f945f4259fb6b8c4953a65248243c054d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a7d8f945f4259fb6b8c4953a65248243c054d1", "html_url": "https://github.com/rust-lang/rust/commit/e5a7d8f945f4259fb6b8c4953a65248243c054d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5a7d8f945f4259fb6b8c4953a65248243c054d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76822a28780a9a93be04409e52c5df21663aab97", "url": "https://api.github.com/repos/rust-lang/rust/commits/76822a28780a9a93be04409e52c5df21663aab97", "html_url": "https://github.com/rust-lang/rust/commit/76822a28780a9a93be04409e52c5df21663aab97"}, {"sha": "990bce4da0a02a15a11abb22b00aacc5d329ce42", "url": "https://api.github.com/repos/rust-lang/rust/commits/990bce4da0a02a15a11abb22b00aacc5d329ce42", "html_url": "https://github.com/rust-lang/rust/commit/990bce4da0a02a15a11abb22b00aacc5d329ce42"}], "stats": {"total": 1090, "additions": 697, "deletions": 393}, "files": [{"sha": "eae162fe479ee0f52880179d866d3269b712d243", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -6,7 +6,6 @@ use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -21,6 +20,7 @@ use rustc_middle::ty::{\n     self, subst::Subst, suggest_constraining_type_params, EarlyBinder, PredicateKind, Ty,\n };\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, Span, Symbol};\n@@ -2223,7 +2223,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let ty = self.infcx.tcx.type_of(self.mir_def_id());\n                 match ty.kind() {\n                     ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n-                        self.mir_def_id().to_def_id(),\n+                        self.mir_def_id(),\n                         self.infcx.tcx.fn_sig(self.mir_def_id()),\n                     ),\n                     _ => None,\n@@ -2267,8 +2267,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Check if our `target` was captured by a closure.\n                         if let Rvalue::Aggregate(\n                             box AggregateKind::Closure(def_id, substs),\n-                            operands,\n-                        ) = rvalue\n+                            ref operands,\n+                        ) = *rvalue\n                         {\n                             for operand in operands {\n                                 let (Operand::Copy(assigned_from) | Operand::Move(assigned_from)) = operand else {\n@@ -2292,7 +2292,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 // into a place then we should annotate the closure in\n                                 // case it ends up being assigned into the return place.\n                                 annotated_closure =\n-                                    self.annotate_fn_sig(*def_id, substs.as_closure().sig());\n+                                    self.annotate_fn_sig(def_id, substs.as_closure().sig());\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: \\\n                                      annotated_closure={:?} assigned_from_local={:?} \\\n@@ -2414,12 +2414,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// references.\n     fn annotate_fn_sig(\n         &self,\n-        did: DefId,\n+        did: LocalDefId,\n         sig: ty::PolyFnSig<'tcx>,\n     ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n-        let is_closure = self.infcx.tcx.is_closure(did);\n-        let fn_hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did.as_local()?);\n+        let is_closure = self.infcx.tcx.is_closure(did.to_def_id());\n+        let fn_hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(fn_hir_id)?;\n \n         // We need to work out which arguments to highlight. We do this by looking"}, {"sha": "0300180f80a80275af945920f33d232c35d192c6", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -5,16 +5,17 @@ use rustc_const_eval::util::{call_kind, CallDesugaringKind};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::GeneratorKind;\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::{\n     AggregateKind, Constant, FakeReadCause, Field, Local, LocalInfo, LocalKind, Location, Operand,\n     Place, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions;\n@@ -41,7 +42,6 @@ pub(crate) use outlives_suggestion::OutlivesSuggestionBuilder;\n pub(crate) use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n pub(crate) use region_name::{RegionName, RegionNameSource};\n pub(crate) use rustc_const_eval::util::CallKind;\n-use rustc_middle::mir::tcx::PlaceTy;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -325,10 +325,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // so it's safe to call `expect_local`.\n                     //\n                     // We know the field exists so it's safe to call operator[] and `unwrap` here.\n+                    let def_id = def_id.expect_local();\n                     let var_id = self\n                         .infcx\n                         .tcx\n-                        .typeck(def_id.expect_local())\n+                        .typeck(def_id)\n                         .closure_min_captures_flattened(def_id)\n                         .nth(field.index())\n                         .unwrap()\n@@ -715,12 +716,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n         if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            match kind {\n-                box AggregateKind::Closure(def_id, _)\n-                | box AggregateKind::Generator(def_id, _, _) => {\n+            match **kind {\n+                AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) => {\n                     debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n                     if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n-                        self.closure_span(*def_id, moved_place, places)\n+                        self.closure_span(def_id, moved_place, places)\n                     {\n                         return ClosureUse {\n                             generator_kind,\n@@ -847,7 +847,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) =\n                 stmt.kind\n             {\n-                let (def_id, is_generator) = match kind {\n+                let (&def_id, is_generator) = match kind {\n                     box AggregateKind::Closure(def_id, _) => (def_id, false),\n                     box AggregateKind::Generator(def_id, _, _) => (def_id, true),\n                     _ => continue,\n@@ -858,7 +858,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     def_id, is_generator, places\n                 );\n                 if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n-                    self.closure_span(*def_id, Place::from(target).as_ref(), places)\n+                    self.closure_span(def_id, Place::from(target).as_ref(), places)\n                 {\n                     return ClosureUse { generator_kind, args_span, capture_kind_span, path_span };\n                 } else {\n@@ -879,25 +879,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// The second span is the location the use resulting in the captured path of the capture\n     fn closure_span(\n         &self,\n-        def_id: DefId,\n+        def_id: LocalDefId,\n         target_place: PlaceRef<'tcx>,\n         places: &[Operand<'tcx>],\n     ) -> Option<(Span, Option<GeneratorKind>, Span, Span)> {\n         debug!(\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n             def_id, target_place, places\n         );\n-        let local_did = def_id.as_local()?;\n-        let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(local_did);\n+        let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(def_id);\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }) = expr {\n-            for (captured_place, place) in self\n-                .infcx\n-                .tcx\n-                .typeck(def_id.expect_local())\n-                .closure_min_captures_flattened(def_id)\n-                .zip(places)\n+            for (captured_place, place) in\n+                self.infcx.tcx.typeck(def_id).closure_min_captures_flattened(def_id).zip(places)\n             {\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)"}, {"sha": "0ad4abbce2063d47b3f11a76cb47305dcf587786", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -343,7 +343,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 );\n                 let tcx = self.infcx.tcx;\n                 if let ty::Closure(id, _) = *the_place_err.ty(self.body, tcx).ty.kind() {\n-                    self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n+                    self.show_mutating_upvar(tcx, id.expect_local(), the_place_err, &mut err);\n                 }\n             }\n \n@@ -382,7 +382,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let ty::Ref(_, ty, Mutability::Mut) = the_place_err.ty(self.body, tcx).ty.kind()\n                     && let ty::Closure(id, _) = *ty.kind()\n                 {\n-                    self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n+                    self.show_mutating_upvar(tcx, id.expect_local(), the_place_err, &mut err);\n                 }\n             }\n \n@@ -685,11 +685,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn show_mutating_upvar(\n         &self,\n         tcx: TyCtxt<'_>,\n-        id: hir::def_id::DefId,\n+        closure_local_def_id: hir::def_id::LocalDefId,\n         the_place_err: PlaceRef<'tcx>,\n         err: &mut Diagnostic,\n     ) {\n-        let closure_local_def_id = id.expect_local();\n         let tables = tcx.typeck(closure_local_def_id);\n         let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_local_def_id);\n         if let Some((span, closure_kind_origin)) =\n@@ -699,7 +698,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let upvar = ty::place_to_string_for_capture(tcx, closure_kind_origin);\n                 let root_hir_id = upvar_id.var_path.hir_id;\n                 // we have an origin for this closure kind starting at this root variable so it's safe to unwrap here\n-                let captured_places = tables.closure_min_captures[&id].get(&root_hir_id).unwrap();\n+                let captured_places =\n+                    tables.closure_min_captures[&closure_local_def_id].get(&root_hir_id).unwrap();\n \n                 let origin_projection = closure_kind_origin\n                     .projections"}, {"sha": "f68358ecfe6d203de81ac6945addce03da4de1ee", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -189,7 +189,7 @@ impl Display for RegionName {\n \n impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     pub(crate) fn mir_def_id(&self) -> hir::def_id::LocalDefId {\n-        self.body.source.def_id().as_local().unwrap()\n+        self.body.source.def_id().expect_local()\n     }\n \n     pub(crate) fn mir_hir_id(&self) -> hir::HirId {"}, {"sha": "4f2a7bccefb683948d516e8d88b4c2305767cfe8", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -189,7 +189,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         errors.set_tainted_by_errors();\n     }\n     let upvars: Vec<_> = tables\n-        .closure_min_captures_flattened(def.did.to_def_id())\n+        .closure_min_captures_flattened(def.did)\n         .map(|captured_place| {\n             let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n@@ -1295,7 +1295,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 match **aggregate_kind {\n                     AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) => {\n                         let BorrowCheckResult { used_mut_upvars, .. } =\n-                            self.infcx.tcx.mir_borrowck(def_id.expect_local());\n+                            self.infcx.tcx.mir_borrowck(def_id);\n                         debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n                         for field in used_mut_upvars {\n                             self.propagate_closure_used_mut_upvar(&operands[field.index()]);"}, {"sha": "f7d35da02597d8f65a7f4e7a1d858c377476b2ca", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -1847,14 +1847,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     let tcx = self.tcx();\n                     let def_id = uv.def.def_id_for_type_of();\n                     if tcx.def_kind(def_id) == DefKind::InlineConst {\n-                        let predicates = self.prove_closure_bounds(\n-                            tcx,\n-                            def_id.expect_local(),\n-                            uv.substs,\n-                            location,\n-                        );\n+                        let def_id = def_id.expect_local();\n+                        let predicates =\n+                            self.prove_closure_bounds(tcx, def_id, uv.substs, location);\n                         self.normalize_and_prove_instantiated_predicates(\n-                            def_id,\n+                            def_id.to_def_id(),\n                             predicates,\n                             location.to_locations(),\n                         );\n@@ -2514,9 +2511,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             aggregate_kind, location\n         );\n \n-        let (def_id, instantiated_predicates) = match aggregate_kind {\n+        let (def_id, instantiated_predicates) = match *aggregate_kind {\n             AggregateKind::Adt(adt_did, _, substs, _, _) => {\n-                (*adt_did, tcx.predicates_of(*adt_did).instantiate(tcx, substs))\n+                (adt_did, tcx.predicates_of(adt_did).instantiate(tcx, substs))\n             }\n \n             // For closures, we have some **extra requirements** we\n@@ -2541,7 +2538,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // clauses on the struct.\n             AggregateKind::Closure(def_id, substs)\n             | AggregateKind::Generator(def_id, substs, _) => {\n-                (*def_id, self.prove_closure_bounds(tcx, def_id.expect_local(), substs, location))\n+                (def_id.to_def_id(), self.prove_closure_bounds(tcx, def_id, substs, location))\n             }\n \n             AggregateKind::Array(_) | AggregateKind::Tuple => {"}, {"sha": "b4c790961707900f839ad4977a89d5e725cf9f69", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -5,7 +5,7 @@ use std::fs::File;\n use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::Session;\n \n use object::read::archive::ArchiveFile;\n@@ -17,9 +17,34 @@ enum ArchiveEntry {\n     File(PathBuf),\n }\n \n+pub(crate) struct ArArchiveBuilderBuilder;\n+\n+impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n+        Box::new(ArArchiveBuilder {\n+            sess,\n+            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n+            // FIXME fix builtin ranlib on macOS\n+            no_builtin_ranlib: sess.target.is_like_osx,\n+\n+            src_archives: vec![],\n+            entries: vec![],\n+        })\n+    }\n+\n+    fn create_dll_import_lib(\n+        &self,\n+        _sess: &Session,\n+        _lib_name: &str,\n+        _dll_imports: &[rustc_session::cstore::DllImport],\n+        _tmpdir: &Path,\n+    ) -> PathBuf {\n+        bug!(\"creating dll imports is not supported\");\n+    }\n+}\n+\n pub(crate) struct ArArchiveBuilder<'a> {\n     sess: &'a Session,\n-    dst: PathBuf,\n     use_gnu_style_archive: bool,\n     no_builtin_ranlib: bool,\n \n@@ -30,30 +55,18 @@ pub(crate) struct ArArchiveBuilder<'a> {\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn new(sess: &'a Session, output: &Path) -> Self {\n-        ArArchiveBuilder {\n-            sess,\n-            dst: output.to_path_buf(),\n-            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n-            // FIXME fix builtin ranlib on macOS\n-            no_builtin_ranlib: sess.target.is_like_osx,\n-\n-            src_archives: vec![],\n-            entries: vec![],\n-        }\n-    }\n-\n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n             ArchiveEntry::File(file.to_owned()),\n         ));\n     }\n \n-    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n+    fn add_archive(\n+        &mut self,\n+        archive_path: &Path,\n+        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> std::io::Result<()> {\n         let read_cache = ReadCache::new(std::fs::File::open(&archive_path)?);\n         let archive = ArchiveFile::parse(&read_cache).unwrap();\n         let archive_index = self.src_archives.len();\n@@ -74,7 +87,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn build(mut self) -> bool {\n+    fn build(mut self: Box<Self>, output: &Path) -> bool {\n         enum BuilderKind {\n             Bsd(ar::Builder<File>),\n             Gnu(ar::GnuBuilder<File>),\n@@ -163,7 +176,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         let mut builder = if self.use_gnu_style_archive {\n             BuilderKind::Gnu(\n                 ar::GnuBuilder::new(\n-                    File::create(&self.dst).unwrap_or_else(|err| {\n+                    File::create(output).unwrap_or_else(|err| {\n                         sess.fatal(&format!(\n                             \"error opening destination during archive building: {}\",\n                             err\n@@ -178,7 +191,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         } else {\n             BuilderKind::Bsd(\n                 ar::Builder::new(\n-                    File::create(&self.dst).unwrap_or_else(|err| {\n+                    File::create(output).unwrap_or_else(|err| {\n                         sess.fatal(&format!(\n                             \"error opening destination during archive building: {}\",\n                             err\n@@ -209,7 +222,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n             // Run ranlib to be able to link the archive\n             let status = std::process::Command::new(ranlib)\n-                .arg(self.dst)\n+                .arg(output)\n                 .status()\n                 .expect(\"Couldn't run ranlib\");\n \n@@ -220,17 +233,4 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n         any_members\n     }\n-\n-    fn sess(&self) -> &Session {\n-        self.sess\n-    }\n-\n-    fn create_dll_import_lib(\n-        _sess: &Session,\n-        _lib_name: &str,\n-        _dll_imports: &[rustc_session::cstore::DllImport],\n-        _tmpdir: &Path,\n-    ) -> PathBuf {\n-        bug!(\"creating dll imports is not supported\");\n-    }\n }"}, {"sha": "bb0793b1deb2e8e75262648ebc89ab6b1d1e76e5", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -226,7 +226,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     ) -> Result<(), ErrorGuaranteed> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        link_binary::<crate::archive::ArArchiveBuilder<'_>>(sess, &codegen_results, outputs)\n+        link_binary(sess, &crate::archive::ArArchiveBuilderBuilder, &codegen_results, outputs)\n     }\n }\n "}, {"sha": "f863abdcc97ec12739924bc026ac9d8e1849b928", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -1,14 +1,13 @@\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::Session;\n \n use rustc_session::cstore::DllImport;\n \n struct ArchiveConfig<'a> {\n     sess: &'a Session,\n-    dst: PathBuf,\n     use_native_ar: bool,\n     use_gnu_style_archive: bool,\n }\n@@ -22,42 +21,56 @@ enum ArchiveEntry {\n     File(PathBuf),\n }\n \n-pub struct ArArchiveBuilder<'a> {\n-    config: ArchiveConfig<'a>,\n-    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(String, ArchiveEntry)>,\n-}\n+pub struct ArArchiveBuilderBuilder;\n \n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn new(sess: &'a Session, output: &Path) -> Self {\n+impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n         let config = ArchiveConfig {\n             sess,\n-            dst: output.to_path_buf(),\n             use_native_ar: false,\n             // FIXME test for linux and System V derivatives instead\n             use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n         };\n \n-        ArArchiveBuilder {\n+        Box::new(ArArchiveBuilder {\n             config,\n             src_archives: vec![],\n             entries: vec![],\n-        }\n+        })\n+    }\n+\n+    fn create_dll_import_lib(\n+        &self,\n+        _sess: &Session,\n+        _lib_name: &str,\n+        _dll_imports: &[DllImport],\n+        _tmpdir: &Path,\n+    ) -> PathBuf {\n+        unimplemented!();\n     }\n+}\n \n+pub struct ArArchiveBuilder<'a> {\n+    config: ArchiveConfig<'a>,\n+    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n+    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n+    // the end of an archive for linkers to not get confused.\n+    entries: Vec<(String, ArchiveEntry)>,\n+}\n+\n+impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string(),\n             ArchiveEntry::File(file.to_owned()),\n         ));\n     }\n \n-    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n+    fn add_archive(\n+        &mut self,\n+        archive_path: &Path,\n+        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> std::io::Result<()> {\n         let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n         let archive_index = self.src_archives.len();\n \n@@ -77,7 +90,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn build(mut self) -> bool {\n+    fn build(mut self: Box<Self>, output: &Path) -> bool {\n         use std::process::Command;\n \n         fn add_file_using_ar(archive: &Path, file: &Path) {\n@@ -97,17 +110,17 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         }\n \n         let mut builder = if self.config.use_native_ar {\n-            BuilderKind::NativeAr(&self.config.dst)\n+            BuilderKind::NativeAr(output)\n         } else if self.config.use_gnu_style_archive {\n             BuilderKind::Gnu(ar::GnuBuilder::new(\n-                File::create(&self.config.dst).unwrap(),\n+                File::create(output).unwrap(),\n                 self.entries\n                     .iter()\n                     .map(|(name, _)| name.as_bytes().to_vec())\n                     .collect(),\n             ))\n         } else {\n-            BuilderKind::Bsd(ar::Builder::new(File::create(&self.config.dst).unwrap()))\n+            BuilderKind::Bsd(ar::Builder::new(File::create(output).unwrap()))\n         };\n \n         let any_members = !self.entries.is_empty();\n@@ -164,28 +177,13 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         std::mem::drop(builder);\n \n         // Run ranlib to be able to link the archive\n-        let status = std::process::Command::new(\"ranlib\")\n-            .arg(self.config.dst)\n-            .status()\n-            .expect(\"Couldn't run ranlib\");\n+        let status =\n+            std::process::Command::new(\"ranlib\").arg(output).status().expect(\"Couldn't run ranlib\");\n \n         if !status.success() {\n             self.config.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n         }\n \n         any_members\n     }\n-\n-    fn sess(&self) -> &Session {\n-        self.config.sess\n-    }\n-\n-    fn create_dll_import_lib(\n-        _sess: &Session,\n-        _lib_name: &str,\n-        _dll_imports: &[DllImport],\n-        _tmpdir: &Path,\n-    ) -> PathBuf {\n-        unimplemented!();\n-    }\n }"}, {"sha": "8a206c0368fcb0ec2c7e5ad9bdecac3b99e87c16", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -133,8 +133,9 @@ impl CodegenBackend for GccCodegenBackend {\n     fn link(&self, sess: &Session, codegen_results: CodegenResults, outputs: &OutputFilenames) -> Result<(), ErrorGuaranteed> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n+        link_binary(\n             sess,\n+            &crate::archive::ArArchiveBuilderBuilder,\n             &codegen_results,\n             outputs,\n         )"}, {"sha": "27039cda253825f5fca016bd63e5c9c398d63988", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -10,15 +10,14 @@ use std::str;\n \n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::cstore::{DllCallingConvention, DllImport};\n use rustc_session::Session;\n \n /// Helper for adding many files to an archive.\n #[must_use = \"must call build() to finish building the archive\"]\n pub struct LlvmArchiveBuilder<'a> {\n     sess: &'a Session,\n-    dst: PathBuf,\n     additions: Vec<Addition>,\n }\n \n@@ -54,16 +53,11 @@ fn llvm_machine_type(cpu: &str) -> LLVMMachineType {\n }\n \n impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n-    /// Creates a new static archive, ready for modifying the archive specified\n-    /// by `config`.\n-    fn new(sess: &'a Session, output: &Path) -> LlvmArchiveBuilder<'a> {\n-        LlvmArchiveBuilder { sess, dst: output.to_path_buf(), additions: Vec::new() }\n-    }\n-\n-    fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n+    fn add_archive(\n+        &mut self,\n+        archive: &Path,\n+        skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> io::Result<()> {\n         let archive_ro = match ArchiveRO::open(archive) {\n             Ok(ar) => ar,\n             Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n@@ -88,18 +82,23 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n \n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n-    fn build(mut self) -> bool {\n-        match self.build_with_llvm() {\n+    fn build(mut self: Box<Self>, output: &Path) -> bool {\n+        match self.build_with_llvm(output) {\n             Ok(any_members) => any_members,\n             Err(e) => self.sess.fatal(&format!(\"failed to build archive: {}\", e)),\n         }\n     }\n+}\n+\n+pub struct LlvmArchiveBuilderBuilder;\n \n-    fn sess(&self) -> &Session {\n-        self.sess\n+impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n+        Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n     }\n \n     fn create_dll_import_lib(\n+        &self,\n         sess: &Session,\n         lib_name: &str,\n         dll_imports: &[DllImport],\n@@ -241,7 +240,7 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n }\n \n impl<'a> LlvmArchiveBuilder<'a> {\n-    fn build_with_llvm(&mut self) -> io::Result<bool> {\n+    fn build_with_llvm(&mut self, output: &Path) -> io::Result<bool> {\n         let kind = &*self.sess.target.archive_format;\n         let kind = kind.parse::<ArchiveKind>().map_err(|_| kind).unwrap_or_else(|kind| {\n             self.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind))\n@@ -251,7 +250,7 @@ impl<'a> LlvmArchiveBuilder<'a> {\n         let mut strings = Vec::new();\n         let mut members = Vec::new();\n \n-        let dst = CString::new(self.dst.to_str().unwrap())?;\n+        let dst = CString::new(output.to_str().unwrap())?;\n \n         unsafe {\n             for addition in &mut additions {"}, {"sha": "eeb1ed61f288f9245a9b497794c25d294da72d9e", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -370,12 +370,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n         codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorGuaranteed> {\n-        use crate::back::archive::LlvmArchiveBuilder;\n+        use crate::back::archive::LlvmArchiveBuilderBuilder;\n         use rustc_codegen_ssa::back::link::link_binary;\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        link_binary::<LlvmArchiveBuilder<'_>>(sess, &codegen_results, outputs)\n+        link_binary(sess, &LlvmArchiveBuilderBuilder, &codegen_results, outputs)\n     }\n }\n "}, {"sha": "0d2aa483d3d4a03c45d6a3d3b53b69b4ff691a5f", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -1,4 +1,3 @@\n-use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_session::cstore::DllImport;\n use rustc_session::Session;\n \n@@ -40,48 +39,31 @@ pub(super) fn find_library(\n     ));\n }\n \n-pub trait ArchiveBuilder<'a> {\n-    fn new(sess: &'a Session, output: &Path) -> Self;\n-\n-    fn add_file(&mut self, path: &Path);\n-\n-    fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static;\n-\n-    fn build(self) -> bool;\n-\n-    fn sess(&self) -> &Session;\n+pub trait ArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a>;\n \n     /// Creates a DLL Import Library <https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-creation#creating-an-import-library>.\n     /// and returns the path on disk to that import library.\n     /// This functions doesn't take `self` so that it can be called from\n     /// `linker_with_args`, which is specialized on `ArchiveBuilder` but\n     /// doesn't take or create an instance of that type.\n     fn create_dll_import_lib(\n+        &self,\n         sess: &Session,\n         lib_name: &str,\n         dll_imports: &[DllImport],\n         tmpdir: &Path,\n     ) -> PathBuf;\n+}\n \n-    /// Creates a DLL Import Library <https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-creation#creating-an-import-library>\n-    /// and adds it to the current compilation's set of archives.\n-    fn inject_dll_import_lib(\n+pub trait ArchiveBuilder<'a> {\n+    fn add_file(&mut self, path: &Path);\n+\n+    fn add_archive(\n         &mut self,\n-        lib_name: &str,\n-        dll_imports: &[DllImport],\n-        tmpdir: &MaybeTempDir,\n-    ) {\n-        let output_path =\n-            Self::create_dll_import_lib(self.sess(), lib_name, dll_imports, tmpdir.as_ref());\n+        archive: &Path,\n+        skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> io::Result<()>;\n \n-        self.add_archive(&output_path, |_| false).unwrap_or_else(|e| {\n-            self.sess().fatal(&format!(\n-                \"failed to add native library {}: {}\",\n-                output_path.display(),\n-                e\n-            ));\n-        });\n-    }\n+    fn build(self: Box<Self>, output: &Path) -> bool;\n }"}, {"sha": "13a7b6be947ec9e4c443fbcdf0542a1a76810e59", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 111, "deletions": 70, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -24,7 +24,7 @@ use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n-use super::archive::{find_library, ArchiveBuilder};\n+use super::archive::{find_library, ArchiveBuilder, ArchiveBuilderBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n use super::metadata::{create_rmeta_file, MetadataPosition};\n@@ -56,8 +56,9 @@ pub fn ensure_removed(diag_handler: &Handler, path: &Path) {\n \n /// Performs the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n-pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n+pub fn link_binary<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     outputs: &OutputFilenames,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -101,21 +102,29 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n             match crate_type {\n                 CrateType::Rlib => {\n                     let _timer = sess.timer(\"link_rlib\");\n-                    link_rlib::<B>(\n+                    info!(\"preparing rlib to {:?}\", out_filename);\n+                    link_rlib(\n                         sess,\n+                        archive_builder_builder,\n                         codegen_results,\n                         RlibFlavor::Normal,\n-                        &out_filename,\n                         &path,\n                     )?\n-                    .build();\n+                    .build(&out_filename);\n                 }\n                 CrateType::Staticlib => {\n-                    link_staticlib::<B>(sess, codegen_results, &out_filename, &path)?;\n+                    link_staticlib(\n+                        sess,\n+                        archive_builder_builder,\n+                        codegen_results,\n+                        &out_filename,\n+                        &path,\n+                    )?;\n                 }\n                 _ => {\n-                    link_natively::<B>(\n+                    link_natively(\n                         sess,\n+                        archive_builder_builder,\n                         crate_type,\n                         &out_filename,\n                         codegen_results,\n@@ -245,18 +254,16 @@ pub fn each_linked_rlib(\n /// the object file of the crate, but it also contains all of the object files from native\n /// libraries. This is done by unzipping native libraries and inserting all of the contents into\n /// this archive.\n-fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n+fn link_rlib<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     flavor: RlibFlavor,\n-    out_filename: &Path,\n     tmpdir: &MaybeTempDir,\n-) -> Result<B, ErrorGuaranteed> {\n-    info!(\"preparing rlib to {:?}\", out_filename);\n-\n+) -> Result<Box<dyn ArchiveBuilder<'a> + 'a>, ErrorGuaranteed> {\n     let lib_search_paths = archive_search_paths(sess);\n \n-    let mut ab = <B as ArchiveBuilder>::new(sess, out_filename);\n+    let mut ab = archive_builder_builder.new_archive_builder(sess);\n \n     let trailing_metadata = match flavor {\n         RlibFlavor::Normal => {\n@@ -342,7 +349,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n         if let Some(name) = lib.name {\n             let location =\n                 find_library(name.as_str(), lib.verbatim.unwrap_or(false), &lib_search_paths, sess);\n-            ab.add_archive(&location, |_| false).unwrap_or_else(|e| {\n+            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|e| {\n                 sess.fatal(&format!(\n                     \"failed to add native library {}: {}\",\n                     location.to_string_lossy(),\n@@ -355,7 +362,16 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     for (raw_dylib_name, raw_dylib_imports) in\n         collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n     {\n-        ab.inject_dll_import_lib(&raw_dylib_name, &raw_dylib_imports, tmpdir);\n+        let output_path = archive_builder_builder.create_dll_import_lib(\n+            sess,\n+            &raw_dylib_name,\n+            &raw_dylib_imports,\n+            tmpdir.as_ref(),\n+        );\n+\n+        ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|e| {\n+            sess.fatal(&format!(\"failed to add native library {}: {}\", output_path.display(), e));\n+        });\n     }\n \n     if let Some(trailing_metadata) = trailing_metadata {\n@@ -446,14 +462,21 @@ fn collate_raw_dylibs(\n ///\n /// There's no need to include metadata in a static archive, so ensure to not link in the metadata\n /// object file (and also don't prepare the archive with a metadata file).\n-fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n+fn link_staticlib<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     out_filename: &Path,\n     tempdir: &MaybeTempDir,\n ) -> Result<(), ErrorGuaranteed> {\n-    let mut ab =\n-        link_rlib::<B>(sess, codegen_results, RlibFlavor::StaticlibBase, out_filename, tempdir)?;\n+    info!(\"preparing staticlib to {:?}\", out_filename);\n+    let mut ab = link_rlib(\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        RlibFlavor::StaticlibBase,\n+        tempdir,\n+    )?;\n     let mut all_native_libs = vec![];\n \n     let res = each_linked_rlib(&codegen_results.crate_info, &mut |cnum, path| {\n@@ -487,26 +510,29 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n         // might be also an extra name suffix\n         let obj_start = name.as_str().to_owned();\n \n-        ab.add_archive(path, move |fname: &str| {\n-            // Ignore metadata files, no matter the name.\n-            if fname == METADATA_FILENAME {\n-                return true;\n-            }\n+        ab.add_archive(\n+            path,\n+            Box::new(move |fname: &str| {\n+                // Ignore metadata files, no matter the name.\n+                if fname == METADATA_FILENAME {\n+                    return true;\n+                }\n \n-            // Don't include Rust objects if LTO is enabled\n-            if lto && looks_like_rust_object_file(fname) {\n-                return true;\n-            }\n+                // Don't include Rust objects if LTO is enabled\n+                if lto && looks_like_rust_object_file(fname) {\n+                    return true;\n+                }\n \n-            // Otherwise if this is *not* a rust object and we're skipping\n-            // objects then skip this file\n-            if skip_object_files && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n-                return true;\n-            }\n+                // Otherwise if this is *not* a rust object and we're skipping\n+                // objects then skip this file\n+                if skip_object_files && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n+                    return true;\n+                }\n \n-            // ok, don't skip this\n-            false\n-        })\n+                // ok, don't skip this\n+                false\n+            }),\n+        )\n         .unwrap();\n \n         all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n@@ -515,7 +541,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n         sess.fatal(&e);\n     }\n \n-    ab.build();\n+    ab.build(out_filename);\n \n     if !all_native_libs.is_empty() {\n         if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n@@ -645,19 +671,21 @@ fn link_dwarf_object<'a>(\n ///\n /// This will invoke the system linker/cc to create the resulting file. This links to all upstream\n /// files as well.\n-fn link_natively<'a, B: ArchiveBuilder<'a>>(\n+fn link_natively<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     crate_type: CrateType,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n     tmpdir: &Path,\n ) -> Result<(), ErrorGuaranteed> {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let (linker_path, flavor) = linker_and_flavor(sess);\n-    let mut cmd = linker_with_args::<B>(\n+    let mut cmd = linker_with_args(\n         &linker_path,\n         flavor,\n         sess,\n+        archive_builder_builder,\n         crate_type,\n         tmpdir,\n         out_filename,\n@@ -1844,10 +1872,11 @@ fn add_rpath_args(\n /// to the linking process as a whole.\n /// Order-independent options may still override each other in order-dependent fashion,\n /// e.g `--foo=yes --foo=no` may be equivalent to `--foo=no`.\n-fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n+fn linker_with_args<'a>(\n     path: &Path,\n     flavor: LinkerFlavor,\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     crate_type: CrateType,\n     tmpdir: &Path,\n     out_filename: &Path,\n@@ -1948,7 +1977,14 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // Upstream rust libraries and their non-bundled static libraries\n-    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n+    add_upstream_rust_crates(\n+        cmd,\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        crate_type,\n+        tmpdir,\n+    );\n \n     // Upstream dynamic native libraries linked with `#[link]` attributes at and `-l`\n     // command line options.\n@@ -1963,7 +1999,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     for (raw_dylib_name, raw_dylib_imports) in\n         collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n     {\n-        cmd.add_object(&B::create_dll_import_lib(\n+        cmd.add_object(&archive_builder_builder.create_dll_import_lib(\n             sess,\n             &raw_dylib_name,\n             &raw_dylib_imports,\n@@ -2256,9 +2292,10 @@ fn add_local_native_libraries(\n ///\n /// Rust crates are not considered at all when creating an rlib output. All dependencies will be\n /// linked when producing the final output (instead of the intermediate rlib version).\n-fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n+fn add_upstream_rust_crates<'a>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     crate_type: CrateType,\n     tmpdir: &Path,\n@@ -2347,7 +2384,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n             _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+                add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n             }\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n@@ -2357,7 +2394,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n             }\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n-                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+                add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n \n                 // Link static native libs with \"-bundle\" modifier only if the crate they originate from\n                 // is being linked statically to the current crate.  If it's linked dynamically\n@@ -2431,7 +2468,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n-        add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+        add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -2457,9 +2494,10 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     // Note, however, that if we're not doing LTO we can just pass the rlib\n     // blindly to the linker (fast) because it's fine if it's not actually\n     // included as we're at the end of the dependency chain.\n-    fn add_static_crate<'a, B: ArchiveBuilder<'a>>(\n+    fn add_static_crate<'a>(\n         cmd: &mut dyn Linker,\n         sess: &'a Session,\n+        archive_builder_builder: &dyn ArchiveBuilderBuilder,\n         codegen_results: &CodegenResults,\n         tmpdir: &Path,\n         cnum: CrateNum,\n@@ -2499,38 +2537,41 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n             let is_builtins = sess.target.no_builtins\n                 || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n-            let mut archive = <B as ArchiveBuilder>::new(sess, &dst);\n-            if let Err(e) = archive.add_archive(cratepath, move |f| {\n-                if f == METADATA_FILENAME {\n-                    return true;\n-                }\n+            let mut archive = archive_builder_builder.new_archive_builder(sess);\n+            if let Err(e) = archive.add_archive(\n+                cratepath,\n+                Box::new(move |f| {\n+                    if f == METADATA_FILENAME {\n+                        return true;\n+                    }\n \n-                let canonical = f.replace('-', \"_\");\n+                    let canonical = f.replace('-', \"_\");\n \n-                let is_rust_object =\n-                    canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n+                    let is_rust_object =\n+                        canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n \n-                // If we've been requested to skip all native object files\n-                // (those not generated by the rust compiler) then we can skip\n-                // this file. See above for why we may want to do this.\n-                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+                    // If we've been requested to skip all native object files\n+                    // (those not generated by the rust compiler) then we can skip\n+                    // this file. See above for why we may want to do this.\n+                    let skip_because_cfg_say_so = skip_native && !is_rust_object;\n \n-                // If we're performing LTO and this is a rust-generated object\n-                // file, then we don't need the object file as it's part of the\n-                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                // though, so we let that object file slide.\n-                let skip_because_lto =\n-                    upstream_rust_objects_already_included && is_rust_object && is_builtins;\n+                    // If we're performing LTO and this is a rust-generated object\n+                    // file, then we don't need the object file as it's part of the\n+                    // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                    // though, so we let that object file slide.\n+                    let skip_because_lto =\n+                        upstream_rust_objects_already_included && is_rust_object && is_builtins;\n \n-                if skip_because_cfg_say_so || skip_because_lto {\n-                    return true;\n-                }\n+                    if skip_because_cfg_say_so || skip_because_lto {\n+                        return true;\n+                    }\n \n-                false\n-            }) {\n+                    false\n+                }),\n+            ) {\n                 sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n             }\n-            if archive.build() {\n+            if archive.build(&dst) {\n                 link_upstream(&dst);\n             }\n         });"}, {"sha": "6f6717721fb5a0df81c15a0e101c43dd3c95c7e1", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -238,7 +238,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 if let Some(local_def_id) = def_id.as_local() {\n                     let tables = self.ecx.tcx.typeck(local_def_id);\n                     if let Some(captured_place) =\n-                        tables.closure_min_captures_flattened(*def_id).nth(field)\n+                        tables.closure_min_captures_flattened(local_def_id).nth(field)\n                     {\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator)."}, {"sha": "20864c657ffd7b2425bebbe43f7e3cfe109dc413", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -712,7 +712,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 opt_suggest_box_span,\n             }) => {\n                 let then_span = self.find_block_span_from_hir_id(then_id);\n-                let else_span = self.find_block_span_from_hir_id(then_id);\n+                let else_span = self.find_block_span_from_hir_id(else_id);\n                 err.span_label(then_span, \"expected because of this\");\n                 if let Some(sp) = outer_span {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n@@ -760,11 +760,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         second_ty: Ty<'tcx>,\n         second_span: Span,\n     ) {\n-        let remove_semicolon =\n-            [(first_id, second_ty), (second_id, first_ty)].into_iter().find_map(|(id, ty)| {\n-                let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n-                self.could_remove_semicolon(blk, ty)\n-            });\n+        let remove_semicolon = [\n+            (first_id, self.resolve_vars_if_possible(second_ty)),\n+            (second_id, self.resolve_vars_if_possible(first_ty)),\n+        ]\n+        .into_iter()\n+        .find_map(|(id, ty)| {\n+            let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n+            self.could_remove_semicolon(blk, ty)\n+        });\n         match remove_semicolon {\n             Some((sp, StatementAsExpression::NeedsBoxing)) => {\n                 err.multipart_suggestion("}, {"sha": "64e158ba348fcb6327c8dfbab17a27f370b92df7", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -1983,53 +1983,45 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }\n \n                     AggregateKind::Closure(def_id, substs) => ty::tls::with(|tcx| {\n-                        if let Some(def_id) = def_id.as_local() {\n-                            let name = if tcx.sess.opts.unstable_opts.span_free_formats {\n-                                let substs = tcx.lift(substs).unwrap();\n-                                format!(\n-                                    \"[closure@{}]\",\n-                                    tcx.def_path_str_with_substs(def_id.to_def_id(), substs),\n-                                )\n-                            } else {\n-                                let span = tcx.def_span(def_id);\n-                                format!(\n-                                    \"[closure@{}]\",\n-                                    tcx.sess.source_map().span_to_diagnostic_string(span)\n-                                )\n-                            };\n-                            let mut struct_fmt = fmt.debug_struct(&name);\n-\n-                            // FIXME(project-rfc-2229#48): This should be a list of capture names/places\n-                            if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n-                                for (&var_id, place) in iter::zip(upvars.keys(), places) {\n-                                    let var_name = tcx.hir().name(var_id);\n-                                    struct_fmt.field(var_name.as_str(), place);\n-                                }\n-                            }\n-\n-                            struct_fmt.finish()\n+                        let name = if tcx.sess.opts.unstable_opts.span_free_formats {\n+                            let substs = tcx.lift(substs).unwrap();\n+                            format!(\n+                                \"[closure@{}]\",\n+                                tcx.def_path_str_with_substs(def_id.to_def_id(), substs),\n+                            )\n                         } else {\n-                            write!(fmt, \"[closure]\")\n+                            let span = tcx.def_span(def_id);\n+                            format!(\n+                                \"[closure@{}]\",\n+                                tcx.sess.source_map().span_to_diagnostic_string(span)\n+                            )\n+                        };\n+                        let mut struct_fmt = fmt.debug_struct(&name);\n+\n+                        // FIXME(project-rfc-2229#48): This should be a list of capture names/places\n+                        if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n+                            for (&var_id, place) in iter::zip(upvars.keys(), places) {\n+                                let var_name = tcx.hir().name(var_id);\n+                                struct_fmt.field(var_name.as_str(), place);\n+                            }\n                         }\n+\n+                        struct_fmt.finish()\n                     }),\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n-                        if let Some(def_id) = def_id.as_local() {\n-                            let name = format!(\"[generator@{:?}]\", tcx.def_span(def_id));\n-                            let mut struct_fmt = fmt.debug_struct(&name);\n-\n-                            // FIXME(project-rfc-2229#48): This should be a list of capture names/places\n-                            if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n-                                for (&var_id, place) in iter::zip(upvars.keys(), places) {\n-                                    let var_name = tcx.hir().name(var_id);\n-                                    struct_fmt.field(var_name.as_str(), place);\n-                                }\n+                        let name = format!(\"[generator@{:?}]\", tcx.def_span(def_id));\n+                        let mut struct_fmt = fmt.debug_struct(&name);\n+\n+                        // FIXME(project-rfc-2229#48): This should be a list of capture names/places\n+                        if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n+                            for (&var_id, place) in iter::zip(upvars.keys(), places) {\n+                                let var_name = tcx.hir().name(var_id);\n+                                struct_fmt.field(var_name.as_str(), place);\n                             }\n-\n-                            struct_fmt.finish()\n-                        } else {\n-                            write!(fmt, \"[generator]\")\n                         }\n+\n+                        struct_fmt.finish()\n                     }),\n                 }\n             }"}, {"sha": "8e3c2283efc6d4413fc1ed21f63c4f015311c1a5", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -18,6 +18,7 @@ use rustc_hir::{self, GeneratorKind};\n use rustc_target::abi::VariantIdx;\n \n use rustc_ast::Mutability;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n@@ -340,8 +341,11 @@ pub enum FakeReadCause {\n     /// If a closure pattern matches a Place starting with an Upvar, then we introduce a\n     /// FakeRead for that Place outside the closure, in such a case this option would be\n     /// Some(closure_def_id).\n-    /// Otherwise, the value of the optional DefId will be None.\n-    ForMatchedPlace(Option<DefId>),\n+    /// Otherwise, the value of the optional LocalDefId will be None.\n+    //\n+    // We can use LocaDefId here since fake read statements are removed\n+    // before codegen in the `CleanupNonCodegenStatements` pass.\n+    ForMatchedPlace(Option<LocalDefId>),\n \n     /// A fake read of the RefWithinGuard version of a bind-by-value variable\n     /// in a match guard to ensure that its value hasn't change by the time\n@@ -365,7 +369,7 @@ pub enum FakeReadCause {\n     /// FakeRead for that Place outside the closure, in such a case this option would be\n     /// Some(closure_def_id).\n     /// Otherwise, the value of the optional DefId will be None.\n-    ForLet(Option<DefId>),\n+    ForLet(Option<LocalDefId>),\n \n     /// If we have an index expression like\n     ///\n@@ -1095,8 +1099,10 @@ pub enum AggregateKind<'tcx> {\n     /// active field index would identity the field `c`\n     Adt(DefId, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n \n-    Closure(DefId, SubstsRef<'tcx>),\n-    Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n+    // Note: We can use LocalDefId since closures and generators a deaggregated\n+    // before codegen.\n+    Closure(LocalDefId, SubstsRef<'tcx>),\n+    Generator(LocalDefId, SubstsRef<'tcx>, hir::Movability),\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]"}, {"sha": "405003156c40e9f2087f465eab58b48db6171cbc", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -205,9 +205,9 @@ impl<'tcx> Rvalue<'tcx> {\n                 AggregateKind::Adt(did, _, substs, _, _) => {\n                     tcx.bound_type_of(did).subst(tcx, substs)\n                 }\n-                AggregateKind::Closure(did, substs) => tcx.mk_closure(did, substs),\n+                AggregateKind::Closure(did, substs) => tcx.mk_closure(did.to_def_id(), substs),\n                 AggregateKind::Generator(did, substs, movability) => {\n-                    tcx.mk_generator(did, substs, movability)\n+                    tcx.mk_generator(did.to_def_id(), substs, movability)\n                 }\n             },\n             Rvalue::ShallowInitBox(_, ty) => tcx.mk_box(ty),"}, {"sha": "ffa66b79dbf825fcb2a21f7cb4034a156413ee4a", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -413,12 +413,12 @@ rustc_queries! {\n     }\n \n     query symbols_for_closure_captures(\n-        key: (LocalDefId, DefId)\n+        key: (LocalDefId, LocalDefId)\n     ) -> Vec<rustc_span::Symbol> {\n         storage(ArenaCacheSelector<'tcx>)\n         desc {\n             |tcx| \"symbols for captures of closure `{}` in `{}`\",\n-            tcx.def_path_str(key.1),\n+            tcx.def_path_str(key.1.to_def_id()),\n             tcx.def_path_str(key.0.to_def_id())\n         }\n     }"}, {"sha": "8b27ca570469766bb7732919bf594694abb02240", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -27,6 +27,7 @@ use rustc_span::{Span, Symbol, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n \n+use rustc_span::def_id::LocalDefId;\n use std::fmt;\n use std::ops::Index;\n \n@@ -405,7 +406,7 @@ pub enum ExprKind<'tcx> {\n     },\n     /// A closure definition.\n     Closure {\n-        closure_id: DefId,\n+        closure_id: LocalDefId,\n         substs: UpvarSubsts<'tcx>,\n         upvars: Box<[ExprId]>,\n         movability: Option<hir::Movability>,"}, {"sha": "0d6c26a582246b532de2a5c36be35a5198bb2f7f", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -59,7 +59,7 @@ pub type UpvarCaptureMap = FxHashMap<UpvarId, UpvarCapture>;\n \n /// Given the closure DefId this map provides a map of root variables to minimum\n /// set of `CapturedPlace`s that need to be tracked to support all captures of that closure.\n-pub type MinCaptureInformationMap<'tcx> = FxHashMap<DefId, RootVariableMinCaptureList<'tcx>>;\n+pub type MinCaptureInformationMap<'tcx> = FxHashMap<LocalDefId, RootVariableMinCaptureList<'tcx>>;\n \n /// Part of `MinCaptureInformationMap`; Maps a root variable to the list of `CapturedPlace`.\n /// Used to track the minimum set of `Place`s that need to be captured to support all\n@@ -253,7 +253,7 @@ impl<'tcx> CapturedPlace<'tcx> {\n \n fn symbols_for_closure_captures<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: (LocalDefId, DefId),\n+    def_id: (LocalDefId, LocalDefId),\n ) -> Vec<Symbol> {\n     let typeck_results = tcx.typeck(def_id.0);\n     let captures = typeck_results.closure_min_captures_flattened(def_id.1);"}, {"sha": "2714493b9fc611592acb8e446552faaa76c979f4", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -570,7 +570,7 @@ pub struct TypeckResults<'tcx> {\n     /// we never capture `t`. This becomes an issue when we build MIR as we require\n     /// information on `t` in order to create place `t.0` and `t.1`. We can solve this\n     /// issue by fake reading `t`.\n-    pub closure_fake_reads: FxHashMap<DefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n+    pub closure_fake_reads: FxHashMap<LocalDefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n \n     /// Tracks the rvalue scoping rules which defines finer scoping for rvalue expressions\n     /// by applying extended parameter rules.\n@@ -589,7 +589,7 @@ pub struct TypeckResults<'tcx> {\n \n     /// Contains the data for evaluating the effect of feature `capture_disjoint_fields`\n     /// on closure size.\n-    pub closure_size_eval: FxHashMap<DefId, ClosureSizeProfileData<'tcx>>,\n+    pub closure_size_eval: FxHashMap<LocalDefId, ClosureSizeProfileData<'tcx>>,\n }\n \n impl<'tcx> TypeckResults<'tcx> {\n@@ -811,7 +811,7 @@ impl<'tcx> TypeckResults<'tcx> {\n     /// by the closure.\n     pub fn closure_min_captures_flattened(\n         &self,\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n     ) -> impl Iterator<Item = &ty::CapturedPlace<'tcx>> {\n         self.closure_min_captures\n             .get(&closure_def_id)"}, {"sha": "0c06aad4e44d50a2c515b8a8290afbbe330b15f9", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -3,7 +3,7 @@\n use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::hir::place::Projection as HirProjection;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n@@ -58,7 +58,7 @@ pub(crate) enum PlaceBase {\n         /// HirId of the upvar\n         var_hir_id: LocalVarId,\n         /// DefId of the closure\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n         /// The trait closure implements, `Fn`, `FnMut`, `FnOnce`\n         closure_kind: ty::ClosureKind,\n     },\n@@ -176,7 +176,7 @@ fn compute_capture_idx<'tcx>(\n fn find_capture_matching_projections<'a, 'tcx>(\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     var_hir_id: LocalVarId,\n-    closure_def_id: DefId,\n+    closure_def_id: LocalDefId,\n     projections: &[PlaceElem<'tcx>],\n ) -> Option<(usize, &'a ty::CapturedPlace<'tcx>)> {\n     let closure_min_captures = typeck_results.closure_min_captures.get(&closure_def_id)?;\n@@ -242,7 +242,7 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n             };\n \n             // We won't be building MIR if the closure wasn't local\n-            let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+            let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id);\n             let closure_ty = typeck_results.node_type(closure_hir_id);\n \n             let substs = match closure_ty.kind() {\n@@ -626,11 +626,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_captured_upvar(\n         &mut self,\n         block: BasicBlock,\n-        closure_expr_id: LocalDefId,\n+        closure_def_id: LocalDefId,\n         var_hir_id: LocalVarId,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         let closure_ty =\n-            self.typeck_results.node_type(self.tcx.hir().local_def_id_to_hir_id(closure_expr_id));\n+            self.typeck_results.node_type(self.tcx.hir().local_def_id_to_hir_id(closure_def_id));\n \n         let closure_kind = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n             self.infcx.closure_kind(closure_substs).unwrap()\n@@ -639,11 +639,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ty::ClosureKind::FnOnce\n         };\n \n-        block.and(PlaceBuilder::from(PlaceBase::Upvar {\n-            var_hir_id,\n-            closure_def_id: closure_expr_id.to_def_id(),\n-            closure_kind,\n-        }))\n+        block.and(PlaceBuilder::from(PlaceBase::Upvar { var_hir_id, closure_def_id, closure_kind }))\n     }\n \n     /// Lower an index expression"}, {"sha": "12b8ceede0fe2a6a92986b9ca740b9227918a171", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -672,7 +672,7 @@ where\n                 Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n                     builder.args_and_body(\n                         START_BLOCK,\n-                        fn_def.did.to_def_id(),\n+                        fn_def.did,\n                         &arguments,\n                         arg_scope,\n                         &thir[expr],\n@@ -895,7 +895,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn args_and_body(\n         &mut self,\n         mut block: BasicBlock,\n-        fn_def_id: DefId,\n+        fn_def_id: LocalDefId,\n         arguments: &[ArgInfo<'tcx>],\n         argument_scope: region::Scope,\n         expr: &Expr<'tcx>,"}, {"sha": "864caf0ba3197b9975da2d8f039bf7308aa9caf1", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -408,7 +408,6 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                 movability: _,\n                 fake_reads: _,\n             } => {\n-                let closure_id = closure_id.expect_local();\n                 let closure_def = if let Some((did, const_param_id)) =\n                     ty::WithOptConstParam::try_lookup(closure_id, self.tcx)\n                 {"}, {"sha": "985601712c4f09a7c2f5d3114102f1fb66fd99da", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -523,6 +523,7 @@ impl<'tcx> Cx<'tcx> {\n                         span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                     }\n                 };\n+                let def_id = def_id.expect_local();\n \n                 let upvars = self\n                     .typeck_results"}, {"sha": "d564f48016626670b648eb5f8d0060f25a1fdf00", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -129,7 +129,7 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n                 }\n                 &AggregateKind::Closure(def_id, _) | &AggregateKind::Generator(def_id, _, _) => {\n                     let UnsafetyCheckResult { violations, used_unsafe_blocks, .. } =\n-                        self.tcx.unsafety_check_result(def_id.expect_local());\n+                        self.tcx.unsafety_check_result(def_id);\n                     self.register_violations(\n                         violations,\n                         used_unsafe_blocks.iter().map(|(&h, &d)| (h, d)),"}, {"sha": "847e64dc2a2f1c3469187c30c1dba8569b50e933", "filename": "compiler/rustc_monomorphize/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -17,8 +17,8 @@ pub(crate) fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: In\n         return;\n     };\n \n-    let closure_def_id = closure_instance.def_id();\n-    let typeck_results = tcx.typeck(closure_def_id.expect_local());\n+    let closure_def_id = closure_instance.def_id().expect_local();\n+    let typeck_results = tcx.typeck(closure_def_id);\n \n     if typeck_results.closure_size_eval.contains_key(&closure_def_id) {\n         let param_env = ty::ParamEnv::reveal_all();"}, {"sha": "461dd52b9f2f5c734021e4ab37c89e08fef4ea4a", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -519,7 +519,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn new(ir: &'a mut IrMaps<'tcx>, body_owner: LocalDefId) -> Liveness<'a, 'tcx> {\n         let typeck_results = ir.tcx.typeck(body_owner);\n         let param_env = ir.tcx.param_env(body_owner);\n-        let closure_min_captures = typeck_results.closure_min_captures.get(&body_owner.to_def_id());\n+        let closure_min_captures = typeck_results.closure_min_captures.get(&body_owner);\n         let closure_ln = ir.add_live_node(ClosureNode);\n         let exit_ln = ir.add_live_node(ExitNode);\n "}, {"sha": "49175e97f41711407d452e8f6928d63e26438ad4", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -191,6 +191,16 @@ impl Key for (LocalDefId, DefId) {\n     }\n }\n \n+impl Key for (LocalDefId, LocalDefId) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n impl Key for (DefId, Option<Ident>) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "75f5aced85577ad2209fcd508d918acff5799dce", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -5,7 +5,7 @@ use crate::type_error_struct;\n use rustc_errors::{struct_span_err, Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{self, Namespace, Res};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::DefId;\n use rustc_infer::{\n     infer,\n     traits::{self, Obligation},\n@@ -19,11 +19,13 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+\n use std::iter;\n \n /// Checks that it is legal to call methods of the trait corresponding\n@@ -59,7 +61,7 @@ pub fn check_legal_trait_for_method_call(\n \n enum CallStep<'tcx> {\n     Builtin(Ty<'tcx>),\n-    DeferredClosure(DefId, ty::FnSig<'tcx>),\n+    DeferredClosure(LocalDefId, ty::FnSig<'tcx>),\n     /// E.g., enum variant constructors.\n     Overloaded(MethodCallee<'tcx>),\n }\n@@ -145,7 +147,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             ty::Closure(def_id, substs) => {\n-                assert_eq!(def_id.krate, LOCAL_CRATE);\n+                let def_id = def_id.expect_local();\n \n                 // Check whether this is a call to a closure where we\n                 // haven't yet decided on whether the closure is fn vs\n@@ -558,7 +560,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call_expr: &'tcx hir::Expr<'tcx>,\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n         fn_sig: ty::FnSig<'tcx>,\n     ) -> Ty<'tcx> {\n         // `fn_sig` is the *signature* of the closure being called. We\n@@ -581,7 +583,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             arg_exprs,\n             fn_sig.c_variadic,\n             TupleArgumentsFlag::TupleArguments,\n-            Some(closure_def_id),\n+            Some(closure_def_id.to_def_id()),\n         );\n \n         fn_sig.output()"}, {"sha": "22087219667b21df772b0e5ddf3a153e4d1bc83f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -29,6 +29,7 @@ use rustc_middle::ty::{\n     ToPredicate, Ty, UserType,\n };\n use rustc_session::lint;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n@@ -114,7 +115,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(in super::super) fn record_deferred_call_resolution(\n         &self,\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n         r: DeferredCallResolution<'tcx>,\n     ) {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n@@ -123,7 +124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(in super::super) fn remove_deferred_call_resolutions(\n         &self,\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n     ) -> Vec<DeferredCallResolution<'tcx>> {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.remove(&closure_def_id).unwrap_or_default()"}, {"sha": "cd152eb97f1bfae437a9a7ddc27254e0e3a1ab89", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -2,13 +2,14 @@ use super::callee::DeferredCallResolution;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefIdMap, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n use rustc_infer::infer;\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::def_id::LocalDefIdMap;\n use rustc_span::{self, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, TraitEngine, TraitEngineExt};\n@@ -46,7 +47,7 @@ pub struct Inherited<'a, 'tcx> {\n     // decision. We keep these deferred resolutions grouped by the\n     // def-id of the closure, so that once we decide, we can easily go\n     // back and process them.\n-    pub(super) deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolution<'tcx>>>>,\n+    pub(super) deferred_call_resolutions: RefCell<LocalDefIdMap<Vec<DeferredCallResolution<'tcx>>>>,\n \n     pub(super) deferred_cast_checks: RefCell<Vec<super::cast::CastCheck<'tcx>>>,\n "}, {"sha": "dd8f943b985ffecb56859814bb43d25e4e9f10ea", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -35,7 +35,6 @@ use super::FnCtxt;\n use crate::expr_use_visitor as euv;\n use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_infer::infer::UpvarRegion;\n@@ -186,27 +185,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n         };\n+        let closure_def_id = closure_def_id.expect_local();\n \n         let infer_kind = if let UpvarSubsts::Closure(closure_substs) = substs {\n             self.closure_kind(closure_substs).is_none().then_some(closure_substs)\n         } else {\n             None\n         };\n \n-        let local_def_id = closure_def_id.expect_local();\n-\n-        let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n-        assert_eq!(body_owner_def_id.to_def_id(), closure_def_id);\n+        assert_eq!(self.tcx.hir().body_owner_def_id(body.id()), closure_def_id);\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n-            closure_def_id: local_def_id,\n+            closure_def_id,\n             capture_information: Default::default(),\n             fake_reads: Default::default(),\n         };\n         euv::ExprUseVisitor::new(\n             &mut delegate,\n             &self.infcx,\n-            body_owner_def_id,\n+            closure_def_id,\n             self.param_env,\n             &self.typeck_results.borrow(),\n         )\n@@ -224,7 +221,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.compute_min_captures(closure_def_id, capture_information, span);\n \n-        let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(closure_def_id);\n \n         if should_do_rust_2021_incompatible_closure_captures_analysis(self.tcx, closure_hir_id) {\n             self.perform_2229_migration_anaysis(closure_def_id, body_id, capture_clause, span);\n@@ -239,7 +236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n                 for var_hir_id in upvars.keys() {\n-                    let place = self.place_for_root_variable(local_def_id, *var_hir_id);\n+                    let place = self.place_for_root_variable(closure_def_id, *var_hir_id);\n \n                     debug!(\"seed place {:?}\", place);\n \n@@ -333,7 +330,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     // Returns a list of `Ty`s for each upvar.\n-    fn final_upvar_tys(&self, closure_id: DefId) -> Vec<Ty<'tcx>> {\n+    fn final_upvar_tys(&self, closure_id: LocalDefId) -> Vec<Ty<'tcx>> {\n         self.typeck_results\n             .borrow()\n             .closure_min_captures_flattened(closure_id)\n@@ -511,7 +508,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     fn compute_min_captures(\n         &self,\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n         capture_information: InferredCaptureInformation<'tcx>,\n         closure_span: Span,\n     ) {\n@@ -730,7 +727,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// `disjoint_capture_drop_reorder` if needed.\n     fn perform_2229_migration_anaysis(\n         &self,\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n         body_id: hir::BodyId,\n         capture_clause: hir::CaptureBy,\n         span: Span,\n@@ -746,8 +743,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let (migration_string, migrated_variables_concat) =\n                 migration_suggestion_for_2229(self.tcx, &need_migrations);\n \n-            let closure_hir_id =\n-                self.tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+            let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(closure_def_id);\n             let closure_head_span = self.tcx.def_span(closure_def_id);\n             self.tcx.struct_span_lint_hir(\n                 lint::builtin::RUST_2021_INCOMPATIBLE_CLOSURE_CAPTURES,\n@@ -1058,15 +1054,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn compute_2229_migrations_for_drop(\n         &self,\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n         closure_span: Span,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n         closure_clause: hir::CaptureBy,\n         var_hir_id: hir::HirId,\n     ) -> Option<FxHashSet<UpvarMigrationInfo>> {\n         let ty = self.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n-        if !ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n+        if !ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id)) {\n             debug!(\"does not have significant drop\");\n             return None;\n         }\n@@ -1160,7 +1156,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn compute_2229_migrations(\n         &self,\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n         closure_span: Span,\n         closure_clause: hir::CaptureBy,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n@@ -1343,14 +1339,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// implements Drop which will be affected since `y` isn't completely captured.\n     fn has_significant_drop_outside_of_captures(\n         &self,\n-        closure_def_id: DefId,\n+        closure_def_id: LocalDefId,\n         closure_span: Span,\n         base_path_ty: Ty<'tcx>,\n         captured_by_move_projs: Vec<&[Projection<'tcx>]>,\n     ) -> bool {\n-        let needs_drop = |ty: Ty<'tcx>| {\n-            ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local()))\n-        };\n+        let needs_drop =\n+            |ty: Ty<'tcx>| ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id));\n \n         let is_drop_defined_for_ty = |ty: Ty<'tcx>| {\n             let drop_trait = self.tcx.require_lang_item(hir::LangItem::Drop, Some(closure_span));\n@@ -1360,7 +1355,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     drop_trait,\n                     ty,\n                     ty_params,\n-                    self.tcx.param_env(closure_def_id.expect_local()),\n+                    self.tcx.param_env(closure_def_id),\n                 )\n                 .must_apply_modulo_regions()\n         };\n@@ -1518,13 +1513,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn should_log_capture_analysis(&self, closure_def_id: DefId) -> bool {\n-        self.tcx.has_attr(closure_def_id, sym::rustc_capture_analysis)\n+    fn should_log_capture_analysis(&self, closure_def_id: LocalDefId) -> bool {\n+        self.tcx.has_attr(closure_def_id.to_def_id(), sym::rustc_capture_analysis)\n     }\n \n     fn log_capture_analysis_first_pass(\n         &self,\n-        closure_def_id: rustc_hir::def_id::DefId,\n+        closure_def_id: LocalDefId,\n         capture_information: &InferredCaptureInformation<'tcx>,\n         closure_span: Span,\n     ) {\n@@ -1543,7 +1538,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn log_closure_min_capture_info(&self, closure_def_id: DefId, closure_span: Span) {\n+    fn log_closure_min_capture_info(&self, closure_def_id: LocalDefId, closure_span: Span) {\n         if self.should_log_capture_analysis(closure_def_id) {\n             if let Some(min_captures) =\n                 self.typeck_results.borrow().closure_min_captures.get(&closure_def_id)"}, {"sha": "f549807c39c91c7626dd99f2e4dc1e5003809d92", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -8,7 +8,6 @@ use hir::def_id::LocalDefId;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::InferCtxt;\n@@ -348,14 +347,13 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n \n impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn eval_closure_size(&mut self) {\n-        let mut res: FxHashMap<DefId, ClosureSizeProfileData<'tcx>> = Default::default();\n-        for (closure_def_id, data) in self.fcx.typeck_results.borrow().closure_size_eval.iter() {\n-            let closure_hir_id =\n-                self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+        let mut res: FxHashMap<LocalDefId, ClosureSizeProfileData<'tcx>> = Default::default();\n+        for (&closure_def_id, data) in self.fcx.typeck_results.borrow().closure_size_eval.iter() {\n+            let closure_hir_id = self.tcx().hir().local_def_id_to_hir_id(closure_def_id);\n \n             let data = self.resolve(*data, &closure_hir_id);\n \n-            res.insert(*closure_def_id, data);\n+            res.insert(closure_def_id, data);\n         }\n \n         self.typeck_results.closure_size_eval = res;\n@@ -365,7 +363,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             self.fcx.typeck_results.borrow().closure_min_captures.len(),\n             Default::default(),\n         );\n-        for (closure_def_id, root_min_captures) in\n+        for (&closure_def_id, root_min_captures) in\n             self.fcx.typeck_results.borrow().closure_min_captures.iter()\n         {\n             let mut root_var_map_wb = ty::RootVariableMinCaptureList::with_capacity_and_hasher(\n@@ -377,37 +375,36 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     .iter()\n                     .map(|captured_place| {\n                         let locatable = captured_place.info.path_expr_id.unwrap_or_else(|| {\n-                            self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local())\n+                            self.tcx().hir().local_def_id_to_hir_id(closure_def_id)\n                         });\n \n                         self.resolve(captured_place.clone(), &locatable)\n                     })\n                     .collect();\n                 root_var_map_wb.insert(*var_hir_id, min_list_wb);\n             }\n-            min_captures_wb.insert(*closure_def_id, root_var_map_wb);\n+            min_captures_wb.insert(closure_def_id, root_var_map_wb);\n         }\n \n         self.typeck_results.closure_min_captures = min_captures_wb;\n     }\n \n     fn visit_fake_reads_map(&mut self) {\n         let mut resolved_closure_fake_reads: FxHashMap<\n-            DefId,\n+            LocalDefId,\n             Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>,\n         > = Default::default();\n-        for (closure_def_id, fake_reads) in\n+        for (&closure_def_id, fake_reads) in\n             self.fcx.typeck_results.borrow().closure_fake_reads.iter()\n         {\n             let mut resolved_fake_reads = Vec::<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>::new();\n             for (place, cause, hir_id) in fake_reads.iter() {\n-                let locatable =\n-                    self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+                let locatable = self.tcx().hir().local_def_id_to_hir_id(closure_def_id);\n \n                 let resolved_fake_read = self.resolve(place.clone(), &locatable);\n                 resolved_fake_reads.push((resolved_fake_read, *cause, *hir_id));\n             }\n-            resolved_closure_fake_reads.insert(*closure_def_id, resolved_fake_reads);\n+            resolved_closure_fake_reads.insert(closure_def_id, resolved_fake_reads);\n         }\n         self.typeck_results.closure_fake_reads = resolved_closure_fake_reads;\n     }"}, {"sha": "c23cbd71723a060194add68f932c104ba3fb8975", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -94,14 +94,6 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n \n             // We'll try to suggest constraining type parameters to fulfill the requirements of\n             // their `Copy` implementation.\n-            let mut generics = None;\n-            if let ty::Adt(def, _substs) = self_type.kind() {\n-                let self_def_id = def.did();\n-                if let Some(local) = self_def_id.as_local() {\n-                    let self_item = tcx.hir().expect_item(local);\n-                    generics = self_item.kind.generics();\n-                }\n-            }\n             let mut errors: BTreeMap<_, Vec<_>> = Default::default();\n             let mut bounds = vec![];\n \n@@ -163,16 +155,14 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                     &format!(\"the `Copy` impl for `{}` requires that `{}`\", ty, error_predicate),\n                 );\n             }\n-            if let Some(generics) = generics {\n-                suggest_constraining_type_params(\n-                    tcx,\n-                    generics,\n-                    &mut err,\n-                    bounds.iter().map(|(param, constraint, def_id)| {\n-                        (param.as_str(), constraint.as_str(), *def_id)\n-                    }),\n-                );\n-            }\n+            suggest_constraining_type_params(\n+                tcx,\n+                tcx.hir().get_generics(impl_did).expect(\"impls always have generics\"),\n+                &mut err,\n+                bounds.iter().map(|(param, constraint, def_id)| {\n+                    (param.as_str(), constraint.as_str(), *def_id)\n+                }),\n+            );\n             err.emit();\n         }\n         Err(CopyImplementationError::NotAnAdt) => {"}, {"sha": "74a5b6e42c30a8a417dce88f60b75322227c08b5", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -468,7 +468,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             self.borrow_expr(discr, ty::ImmBorrow);\n         } else {\n             let closure_def_id = match discr_place.place.base {\n-                PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n+                PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id),\n                 _ => None,\n             };\n \n@@ -642,7 +642,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     fn walk_arm(&mut self, discr_place: &PlaceWithHirId<'tcx>, arm: &hir::Arm<'_>) {\n         let closure_def_id = match discr_place.place.base {\n-            PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n+            PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id),\n             _ => None,\n         };\n \n@@ -666,7 +666,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// let binding, and *not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n         let closure_def_id = match discr_place.place.base {\n-            PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n+            PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id),\n             _ => None,\n         };\n \n@@ -763,7 +763,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let tcx = self.tcx();\n-        let closure_def_id = tcx.hir().local_def_id(closure_expr.hir_id).to_def_id();\n+        let closure_def_id = tcx.hir().local_def_id(closure_expr.hir_id);\n         let upvars = tcx.upvars_mentioned(self.body_owner);\n \n         // For purposes of this function, generator and closures are equivalent."}, {"sha": "b487f013d27068fc61adcb703dfcaf6c9efb766d", "filename": "src/test/ui/suggestions/if-then-neeing-semi.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fif-then-neeing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fif-then-neeing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fif-then-neeing-semi.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -0,0 +1,70 @@\n+// edition:2018\n+\n+fn dummy() -> i32 {\n+    42\n+}\n+\n+fn extra_semicolon() {\n+    let _ = if true {\n+        //~^ NOTE `if` and `else` have incompatible types\n+        dummy(); //~ NOTE expected because of this\n+        //~^ HELP consider removing this semicolon\n+    } else {\n+        dummy() //~ ERROR `if` and `else` have incompatible types\n+        //~^ NOTE expected `()`, found `i32`\n+    };\n+}\n+\n+async fn async_dummy() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n+//~| NOTE while checking the return type of the `async fn`\n+//~| NOTE in this expansion of desugaring of `async` block or function\n+//~| NOTE checked the `Output` of this `async fn`, expected opaque type\n+//~| NOTE while checking the return type of the `async fn`\n+//~| NOTE in this expansion of desugaring of `async` block or function\n+async fn async_dummy2() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n+//~| NOTE checked the `Output` of this `async fn`, found opaque type\n+//~| NOTE while checking the return type of the `async fn`\n+//~| NOTE in this expansion of desugaring of `async` block or function\n+//~| NOTE while checking the return type of the `async fn`\n+//~| NOTE in this expansion of desugaring of `async` block or function\n+\n+async fn async_extra_semicolon_same() {\n+    let _ = if true {\n+        //~^ NOTE `if` and `else` have incompatible types\n+        async_dummy(); //~ NOTE expected because of this\n+        //~^ HELP consider removing this semicolon\n+    } else {\n+        async_dummy() //~ ERROR `if` and `else` have incompatible types\n+        //~^ NOTE expected `()`, found opaque type\n+        //~| NOTE expected unit type `()`\n+        //~| HELP consider `await`ing on the `Future`\n+    };\n+}\n+\n+async fn async_extra_semicolon_different() {\n+    let _ = if true {\n+        //~^ NOTE `if` and `else` have incompatible types\n+        async_dummy(); //~ NOTE expected because of this\n+        //~^ HELP consider removing this semicolon\n+    } else {\n+        async_dummy2() //~ ERROR `if` and `else` have incompatible types\n+        //~^ NOTE expected `()`, found opaque type\n+        //~| NOTE expected unit type `()`\n+        //~| HELP consider `await`ing on the `Future`\n+    };\n+}\n+\n+async fn async_different_futures() {\n+    let _ = if true {\n+        //~^ NOTE `if` and `else` have incompatible types\n+        async_dummy() //~ NOTE expected because of this\n+        //~| HELP consider `await`ing on both `Future`s\n+    } else {\n+        async_dummy2() //~ ERROR `if` and `else` have incompatible types\n+        //~^ NOTE expected opaque type, found a different opaque type\n+        //~| NOTE expected opaque type `impl Future<Output = ()>`\n+        //~| NOTE distinct uses of `impl Trait` result in different opaque types\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "d7c5818abbd54b76fc7465051dc6917499f59723", "filename": "src/test/ui/suggestions/if-then-neeing-semi.stderr", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fif-then-neeing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fif-then-neeing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fif-then-neeing-semi.stderr?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -0,0 +1,130 @@\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/if-then-neeing-semi.rs:37:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |\n+LL | |         async_dummy();\n+   | |         -------------- expected because of this\n+LL | |\n+LL | |     } else {\n+LL | |         async_dummy()\n+   | |         ^^^^^^^^^^^^^ expected `()`, found opaque type\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `if` and `else` have incompatible types\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/if-then-neeing-semi.rs:18:24\n+   |\n+LL | async fn async_dummy() {}\n+   |                        ^ checked the `Output` of this `async fn`, found opaque type\n+   = note: expected unit type `()`\n+            found opaque type `impl Future<Output = ()>`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         async_dummy().await\n+   |                      ++++++\n+help: consider removing this semicolon\n+   |\n+LL -         async_dummy();\n+LL +         async_dummy()\n+   |\n+\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/if-then-neeing-semi.rs:50:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |\n+LL | |         async_dummy();\n+   | |         -------------- expected because of this\n+LL | |\n+LL | |     } else {\n+LL | |         async_dummy2()\n+   | |         ^^^^^^^^^^^^^^ expected `()`, found opaque type\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `if` and `else` have incompatible types\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/if-then-neeing-semi.rs:24:25\n+   |\n+LL | async fn async_dummy2() {}\n+   |                         ^ checked the `Output` of this `async fn`, found opaque type\n+   = note: expected unit type `()`\n+            found opaque type `impl Future<Output = ()>`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         async_dummy2().await\n+   |                       ++++++\n+help: consider removing this semicolon and boxing the expressions\n+   |\n+LL ~         Box::new(async_dummy())\n+LL |\n+LL |     } else {\n+LL ~         Box::new(async_dummy2())\n+   |\n+\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/if-then-neeing-semi.rs:63:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |\n+LL | |         async_dummy()\n+   | |         ------------- expected because of this\n+LL | |\n+LL | |     } else {\n+LL | |         async_dummy2()\n+   | |         ^^^^^^^^^^^^^^ expected opaque type, found a different opaque type\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `if` and `else` have incompatible types\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/if-then-neeing-semi.rs:18:24\n+   |\n+LL | async fn async_dummy() {}\n+   |                        ^ checked the `Output` of this `async fn`, expected opaque type\n+note: while checking the return type of the `async fn`\n+  --> $DIR/if-then-neeing-semi.rs:24:25\n+   |\n+LL | async fn async_dummy2() {}\n+   |                         ^ checked the `Output` of this `async fn`, found opaque type\n+   = note: expected opaque type `impl Future<Output = ()>` (opaque type at <$DIR/if-then-neeing-semi.rs:18:24>)\n+              found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/if-then-neeing-semi.rs:24:25>)\n+   = note: distinct uses of `impl Trait` result in different opaque types\n+help: consider `await`ing on both `Future`s\n+   |\n+LL ~         async_dummy().await\n+LL |\n+LL |     } else {\n+LL ~         async_dummy2().await\n+   |\n+\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/if-then-neeing-semi.rs:13:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |\n+LL | |         dummy();\n+   | |         --------\n+   | |         |      |\n+   | |         |      help: consider removing this semicolon\n+   | |         expected because of this\n+LL | |\n+LL | |     } else {\n+LL | |         dummy()\n+   | |         ^^^^^^^ expected `()`, found `i32`\n+LL | |\n+LL | |     };\n+   | |_____- `if` and `else` have incompatible types\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "691e7553a0952ef5e1bf8807ffb975130d0056ca", "filename": "src/test/ui/suggestions/missing-bound-in-manual-copy-impl-2.fixed", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl-2.fixed?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+\n+#[derive(Clone)]\n+struct Wrapper<T>(T);\n+\n+struct OnlyCopyIfDisplay<T>(std::marker::PhantomData<T>);\n+\n+impl<T: std::fmt::Display> Clone for OnlyCopyIfDisplay<T> {\n+    fn clone(&self) -> Self {\n+        OnlyCopyIfDisplay(std::marker::PhantomData)\n+    }\n+}\n+\n+impl<T: std::fmt::Display> Copy for OnlyCopyIfDisplay<T> {}\n+\n+impl<S: std::fmt::Display> Copy for Wrapper<OnlyCopyIfDisplay<S>> {}\n+//~^ ERROR the trait `Copy` may not be implemented for this type\n+\n+fn main() {}"}, {"sha": "e3185e7eff8551677d1da311b70b6c7a9f311544", "filename": "src/test/ui/suggestions/missing-bound-in-manual-copy-impl-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl-2.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+\n+#[derive(Clone)]\n+struct Wrapper<T>(T);\n+\n+struct OnlyCopyIfDisplay<T>(std::marker::PhantomData<T>);\n+\n+impl<T: std::fmt::Display> Clone for OnlyCopyIfDisplay<T> {\n+    fn clone(&self) -> Self {\n+        OnlyCopyIfDisplay(std::marker::PhantomData)\n+    }\n+}\n+\n+impl<T: std::fmt::Display> Copy for OnlyCopyIfDisplay<T> {}\n+\n+impl<S> Copy for Wrapper<OnlyCopyIfDisplay<S>> {}\n+//~^ ERROR the trait `Copy` may not be implemented for this type\n+\n+fn main() {}"}, {"sha": "e0f405eedfa6947009c26f4000e653b4eaf22225", "filename": "src/test/ui/suggestions/missing-bound-in-manual-copy-impl-2.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl-2.stderr?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -0,0 +1,22 @@\n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/missing-bound-in-manual-copy-impl-2.rs:16:9\n+   |\n+LL | struct Wrapper<T>(T);\n+   |                   - this field does not implement `Copy`\n+...\n+LL | impl<S> Copy for Wrapper<OnlyCopyIfDisplay<S>> {}\n+   |         ^^^^\n+   |\n+note: the `Copy` impl for `OnlyCopyIfDisplay<S>` requires that `S: std::fmt::Display`\n+  --> $DIR/missing-bound-in-manual-copy-impl-2.rs:4:19\n+   |\n+LL | struct Wrapper<T>(T);\n+   |                   ^\n+help: consider restricting type parameter `S`\n+   |\n+LL | impl<S: std::fmt::Display> Copy for Wrapper<OnlyCopyIfDisplay<S>> {}\n+   |       +++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0204`."}, {"sha": "32a7215c5bdc3ef0ecaff5f10762ce8e420f8024", "filename": "src/test/ui/suggestions/missing-bound-in-manual-copy-impl.fixed", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl.fixed?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+\n+#[derive(Clone)]\n+struct Wrapper<T>(T);\n+\n+impl<S: Copy> Copy for Wrapper<S> {}\n+//~^ ERROR the trait `Copy` may not be implemented for this type\n+\n+fn main() {}"}, {"sha": "c688f4d41ee9b3ee232d4d26848f7df8f0abac04", "filename": "src/test/ui/suggestions/missing-bound-in-manual-copy-impl.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+\n+#[derive(Clone)]\n+struct Wrapper<T>(T);\n+\n+impl<S> Copy for Wrapper<S> {}\n+//~^ ERROR the trait `Copy` may not be implemented for this type\n+\n+fn main() {}"}, {"sha": "218988511dbc34f98a45130334f013b95f31eb29", "filename": "src/test/ui/suggestions/missing-bound-in-manual-copy-impl.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-bound-in-manual-copy-impl.stderr?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -0,0 +1,17 @@\n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/missing-bound-in-manual-copy-impl.rs:6:9\n+   |\n+LL | struct Wrapper<T>(T);\n+   |                   - this field does not implement `Copy`\n+LL |\n+LL | impl<S> Copy for Wrapper<S> {}\n+   |         ^^^^\n+   |\n+help: consider restricting type parameter `S`\n+   |\n+LL | impl<S: Copy> Copy for Wrapper<S> {}\n+   |       ++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0204`."}, {"sha": "7493a8685dff85875928f9a5fc600bcd65d5341f", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -968,7 +968,7 @@ pub fn can_move_expr_to_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'\n                     }\n                 },\n                 ExprKind::Closure { .. } => {\n-                    let closure_id = self.cx.tcx.hir().local_def_id(e.hir_id).to_def_id();\n+                    let closure_id = self.cx.tcx.hir().local_def_id(e.hir_id);\n                     for capture in self.cx.typeck_results().closure_min_captures_flattened(closure_id) {\n                         let local_id = match capture.place.base {\n                             PlaceBase::Local(id) => id,"}, {"sha": "ea654192bbf78df611327bd165fe796b1887d7f7", "filename": "triagebot.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5a7d8f945f4259fb6b8c4953a65248243c054d1/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e5a7d8f945f4259fb6b8c4953a65248243c054d1/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=e5a7d8f945f4259fb6b8c4953a65248243c054d1", "patch": "@@ -323,6 +323,7 @@ otherwise, make sure you bump the `FORMAT_VERSION` constant.\n cc = [\n     \"@CraftSpider\",\n     \"@aDotInTheVoid\",\n+    \"@Enselic\",\n ]\n \n [mentions.\"src/tools/cargo\"]"}]}