{"sha": "aef16300f7cfa79de3bd4797d0196d13445f4761", "node_id": "C_kwDOAAsO6NoAKGFlZjE2MzAwZjdjZmE3OWRlM2JkNDc5N2QwMTk2ZDEzNDQ1ZjQ3NjE", "commit": {"author": {"name": "Christofer Nolander", "email": "christofer.nolander@gmail.com", "date": "2022-05-20T22:00:47Z"}, "committer": {"name": "Christofer Nolander", "email": "christofer.nolander@gmail.com", "date": "2022-05-20T22:07:06Z"}, "message": "Order auto-imports by relevance\n\nThis first attempt prefers items that are closer to the module they are\nimported in.", "tree": {"sha": "0a6b3618c089f6236180d93ae170e3b283c34fe8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a6b3618c089f6236180d93ae170e3b283c34fe8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aef16300f7cfa79de3bd4797d0196d13445f4761", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aef16300f7cfa79de3bd4797d0196d13445f4761", "html_url": "https://github.com/rust-lang/rust/commit/aef16300f7cfa79de3bd4797d0196d13445f4761", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aef16300f7cfa79de3bd4797d0196d13445f4761/comments", "author": {"login": "nolanderc", "id": 16593746, "node_id": "MDQ6VXNlcjE2NTkzNzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16593746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nolanderc", "html_url": "https://github.com/nolanderc", "followers_url": "https://api.github.com/users/nolanderc/followers", "following_url": "https://api.github.com/users/nolanderc/following{/other_user}", "gists_url": "https://api.github.com/users/nolanderc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nolanderc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nolanderc/subscriptions", "organizations_url": "https://api.github.com/users/nolanderc/orgs", "repos_url": "https://api.github.com/users/nolanderc/repos", "events_url": "https://api.github.com/users/nolanderc/events{/privacy}", "received_events_url": "https://api.github.com/users/nolanderc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nolanderc", "id": 16593746, "node_id": "MDQ6VXNlcjE2NTkzNzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16593746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nolanderc", "html_url": "https://github.com/nolanderc", "followers_url": "https://api.github.com/users/nolanderc/followers", "following_url": "https://api.github.com/users/nolanderc/following{/other_user}", "gists_url": "https://api.github.com/users/nolanderc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nolanderc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nolanderc/subscriptions", "organizations_url": "https://api.github.com/users/nolanderc/orgs", "repos_url": "https://api.github.com/users/nolanderc/repos", "events_url": "https://api.github.com/users/nolanderc/events{/privacy}", "received_events_url": "https://api.github.com/users/nolanderc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a978e1404cdfa6f83818717b2dcdc989e8bc09f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a978e1404cdfa6f83818717b2dcdc989e8bc09f", "html_url": "https://github.com/rust-lang/rust/commit/2a978e1404cdfa6f83818717b2dcdc989e8bc09f"}], "stats": {"total": 142, "additions": 140, "deletions": 2}, "files": [{"sha": "3316b71de2c8882d9923a9e5aafa1f9cd54664e0", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 140, "deletions": 2, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/aef16300f7cfa79de3bd4797d0196d13445f4761/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef16300f7cfa79de3bd4797d0196d13445f4761/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=aef16300f7cfa79de3bd4797d0196d13445f4761", "patch": "@@ -1,7 +1,10 @@\n+use std::cmp::Reverse;\n+\n+use hir::{db::HirDatabase, Module};\n use ide_db::{\n     helpers::mod_path_to_ast,\n     imports::{\n-        import_assets::{ImportAssets, ImportCandidate},\n+        import_assets::{ImportAssets, ImportCandidate, LocatedImport},\n         insert_use::{insert_use, ImportScope},\n     },\n };\n@@ -107,6 +110,10 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     // we aren't interested in different namespaces\n     proposed_imports.dedup_by(|a, b| a.import_path == b.import_path);\n+\n+    // prioritize more relevant imports\n+    proposed_imports.sort_by_key(|import| Reverse(relevance_score(ctx, import)));\n+\n     for import in proposed_imports {\n         acc.add_group(\n             &group_label,\n@@ -158,11 +165,142 @@ fn group_label(import_candidate: &ImportCandidate) -> GroupLabel {\n     GroupLabel(name)\n }\n \n+/// Determine how relevant a given import is in the current context. Higher scores are more\n+/// relevant.\n+fn relevance_score(ctx: &AssistContext, import: &LocatedImport) -> i32 {\n+    let mut score = 0;\n+\n+    let db = ctx.db();\n+\n+    let item_module = match import.item_to_import {\n+        hir::ItemInNs::Types(item) | hir::ItemInNs::Values(item) => item.module(db),\n+        hir::ItemInNs::Macros(makro) => Some(makro.module(db)),\n+    };\n+\n+    let current_node = match ctx.covering_element() {\n+        NodeOrToken::Node(node) => Some(node),\n+        NodeOrToken::Token(token) => token.parent(),\n+    };\n+\n+    if let Some(module) = item_module.as_ref() {\n+        if module.krate().is_builtin(db) {\n+            // prefer items builtin to the language\n+            score += 5;\n+        }\n+    }\n+\n+    match item_module.zip(current_node) {\n+        // get the distance between the modules (prefer items that are more local)\n+        Some((item_module, current_node)) => {\n+            let current_module = ctx.sema.scope(&current_node).unwrap().module();\n+            score -= module_distance_hueristic(&current_module, &item_module, db) as i32;\n+        }\n+\n+        // could not find relevant modules, so just use the length of the path as an estimate\n+        None => return -(2 * import.import_path.len() as i32),\n+    }\n+\n+    score\n+}\n+\n+/// A heuristic that gives a higher score to modules that are more separated.\n+fn module_distance_hueristic(current: &Module, item: &Module, db: &dyn HirDatabase) -> usize {\n+    let mut current_path = current.path_to_root(db);\n+    let mut item_path = item.path_to_root(db);\n+\n+    current_path.reverse();\n+    item_path.reverse();\n+\n+    let mut i = 0;\n+    while i < current_path.len() && i < item_path.len() {\n+        if current_path[i] == item_path[i] {\n+            i += 1\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    let distinct_distance = current_path.len() + item_path.len();\n+    let common_prefix = 2 * i;\n+\n+    // prefer builtin crates and items within the same crate\n+    let crate_boundary_cost =\n+        if item.krate().is_builtin(db) || current.krate() == item.krate() { 0 } else { 4 };\n+\n+    distinct_distance - common_prefix + crate_boundary_cost\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n \n-    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use hir::Semantics;\n+    use ide_db::{\n+        assists::AssistResolveStrategy,\n+        base_db::{fixture::WithFixture, FileRange},\n+        RootDatabase,\n+    };\n+\n+    use crate::tests::{\n+        check_assist, check_assist_not_applicable, check_assist_target, TEST_CONFIG,\n+    };\n+\n+    fn check_auto_import_order(before: &str, order: &[&str]) {\n+        let (db, file_id, range_or_offset) = RootDatabase::with_range_or_offset(before);\n+        let frange = FileRange { file_id, range: range_or_offset.into() };\n+\n+        let sema = Semantics::new(&db);\n+        let config = TEST_CONFIG;\n+        let ctx = AssistContext::new(sema, &config, frange);\n+        let mut acc = Assists::new(&ctx, AssistResolveStrategy::All);\n+        auto_import(&mut acc, &ctx);\n+        let assists = acc.finish();\n+\n+        let labels = assists.iter().map(|assist| assist.label.to_string()).collect::<Vec<_>>();\n+\n+        assert_eq!(labels, order);\n+    }\n+\n+    #[test]\n+    fn prefer_shorter_paths() {\n+        let before = r\"\n+            //- /main.rs crate:main deps:foo,bar\n+            HashMap$0::new();\n+\n+            //- /lib.rs crate:foo\n+            pub mod collections { pub struct HashMap; }\n+\n+            //- /lib.rs crate:bar\n+            pub mod collections { pub mod hash_map { pub struct HashMap; } }\n+        \";\n+\n+        check_auto_import_order(\n+            before,\n+            &[\"Import `foo::collections::HashMap`\", \"Import `bar::collections::hash_map::HashMap`\"],\n+        )\n+    }\n+\n+    #[test]\n+    fn prefer_same_crate() {\n+        let before = r\"\n+            //- /main.rs crate:main deps:foo\n+            HashMap$0::new();\n+\n+            mod collections {\n+                pub mod hash_map {\n+                    pub struct HashMap;\n+                }\n+            }\n+\n+            //- /lib.rs crate:foo\n+            pub struct HashMap;\n+        \";\n+\n+        check_auto_import_order(\n+            before,\n+            &[\"Import `collections::hash_map::HashMap`\", \"Import `foo::HashMap`\"],\n+        )\n+    }\n \n     #[test]\n     fn not_applicable_if_scope_inside_macro() {"}]}