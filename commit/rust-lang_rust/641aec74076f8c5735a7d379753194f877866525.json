{"sha": "641aec74076f8c5735a7d379753194f877866525", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MWFlYzc0MDc2ZjhjNTczNWE3ZDM3OTc1MzE5NGY4Nzc4NjY1MjU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-05T02:13:26Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-07T23:51:13Z"}, "message": "remove some method resolve workarounds", "tree": {"sha": "db8945d207d7c89feccd20ab8650afd91a5f490f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db8945d207d7c89feccd20ab8650afd91a5f490f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/641aec74076f8c5735a7d379753194f877866525", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/641aec74076f8c5735a7d379753194f877866525", "html_url": "https://github.com/rust-lang/rust/commit/641aec74076f8c5735a7d379753194f877866525", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/641aec74076f8c5735a7d379753194f877866525/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28643d4135b453888be3f383c3f5f751f13bb647", "url": "https://api.github.com/repos/rust-lang/rust/commits/28643d4135b453888be3f383c3f5f751f13bb647", "html_url": "https://github.com/rust-lang/rust/commit/28643d4135b453888be3f383c3f5f751f13bb647"}], "stats": {"total": 236, "additions": 118, "deletions": 118}, "files": [{"sha": "c481fb8f5440d0ffb7db302c8bb218bbc40d63d2", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -176,7 +176,7 @@ fn name_str(nm: &Name) -> ~str {\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n-    opts.iter().position_(|opt| opt.name == nm)\n+    opts.iter().position(|opt| opt.name == nm)\n }\n \n /**"}, {"sha": "b9b2099d7c228f99e4a33765cadea16c06820fee", "filename": "src/libextra/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -950,7 +950,7 @@ impl serialize::Decoder for Decoder {\n             }\n             ref json => fail!(\"invalid variant: %?\", *json),\n         };\n-        let idx = match names.iter().position_(|n| str::eq_slice(*n, name)) {\n+        let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n             None => fail!(\"Unknown variant name: %?\", name),\n         };"}, {"sha": "6876b3510b6cadff24b6bd7f4c9ab491f16d626a", "filename": "src/libextra/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Fip.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -203,7 +203,7 @@ pub mod v4 {\n         }).collect();\n         if parts.len() != 4 {\n             Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n-        } else if parts.iter().any_(|x| *x == 256u) {\n+        } else if parts.iter().any(|x| *x == 256u) {\n             Err(fmt!(\"invalid octal in addr '%s'\", ip))\n         } else {\n             Ok(Ipv4Rep {"}, {"sha": "307f75dc98bea13abed902c7765551255f088969", "filename": "src/libextra/net/url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fnet%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fnet%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Furl.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -522,7 +522,7 @@ fn get_authority(rawurl: &str) ->\n     let host_is_end_plus_one: &fn() -> bool = || {\n         let xs = ['?', '#', '/'];\n         end+1 == len\n-            && !xs.iter().any_(|x| *x == (rawurl[end] as char))\n+            && !xs.iter().any(|x| *x == (rawurl[end] as char))\n     };\n \n     // finish up"}, {"sha": "d737698cfe2ca0055c3ac16c8948f0fa84000bab", "filename": "src/libextra/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -136,8 +136,8 @@ pub fn any<A:Copy + Send>(\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n     let mapped = map_slices(xs, || {\n         let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any_(f);\n+        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any(f);\n         result\n     });\n-    mapped.iter().any_(|&x| x)\n+    mapped.iter().any(|&x| x)\n }"}, {"sha": "e56b3b6bcf4c830e4e3f384e50db2d26eb193f39", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -294,7 +294,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n             // Find the offset of the NUL we want to go to\n             let nulpos = string_table.slice(offset as uint, string_table_bytes as uint)\n-                .iter().position_(|&b| b == 0);\n+                .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_owned(),"}, {"sha": "a5f7479d41a0116b8a8ed2b4af8a53bec2f5d374", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -844,7 +844,7 @@ mod test_treemap {\n             for 90.times {\n                 let k = rng.gen();\n                 let v = rng.gen();\n-                if !ctrl.iter().any_(|x| x == &(k, v)) {\n+                if !ctrl.iter().any(|x| x == &(k, v)) {\n                     assert!(map.insert(k, v));\n                     ctrl.push((k, v));\n                     check_structure(&map);"}, {"sha": "0d4d96b3b2b3ee64b190c36e3b66aee01dda1f1f", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -194,7 +194,7 @@ pub fn metas_in_cfg(cfg: &[@ast::meta_item],\n \n     if cfg_metas.iter().all(|c| c.is_empty()) { return true; }\n \n-    cfg_metas.iter().any_(|cfg_meta| {\n+    cfg_metas.iter().any(|cfg_meta| {\n         cfg_meta.iter().all(|cfg_mi| {\n             match cfg_mi.node {\n                 ast::meta_list(s, ref it) if \"not\" == s"}, {"sha": "bb1834dc5c8fca0653401fc2dddfbdafdbba62fb", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -102,7 +102,7 @@ pub fn get_used_crate_files(cstore: &CStore) -> ~[Path] {\n pub fn add_used_library(cstore: &mut CStore, lib: @str) -> bool {\n     assert!(!lib.is_empty());\n \n-    if cstore.used_libraries.iter().any_(|x| x == &lib) { return false; }\n+    if cstore.used_libraries.iter().any(|x| x == &lib) { return false; }\n     cstore.used_libraries.push(lib);\n     true\n }"}, {"sha": "73adade7a5d7162fc90c6fbce270437d93c39c8f", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -506,7 +506,7 @@ impl FlowedMoveData {\n         for self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n-            if base_indices.iter().any_(|x| x == &moved_path) {\n+            if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n                 // `loan_path` was moved.\n                 if !f(move, self.move_data.path(moved_path).loan_path) {\n@@ -535,7 +535,7 @@ impl FlowedMoveData {\n                        -> bool {\n         //! True if `id` is the id of the LHS of an assignment\n \n-        self.move_data.assignee_ids.iter().any_(|x| x == &id)\n+        self.move_data.assignee_ids.iter().any(|x| x == &id)\n     }\n \n     pub fn each_assignment_of(&self,"}, {"sha": "26a03b362e3567fe4ff55c25898e1a1c39763cb1", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -224,7 +224,7 @@ pub fn check_item_recursion(sess: Session,\n     (visitor.visit_item)(it, (env, visitor));\n \n     fn visit_item(it: @item, (env, v): (env, visit::vt<env>)) {\n-        if env.idstack.iter().any_(|x| x == &(it.id)) {\n+        if env.idstack.iter().any(|x| x == &(it.id)) {\n             env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);"}, {"sha": "0baeb8ce57c6cae2b2299252d3254f30ec24003b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -371,7 +371,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n         let variants = ty::enum_variants(cx.tcx, eid);\n         if found.len() != (*variants).len() {\n             for (*variants).iter().advance |v| {\n-                if !found.iter().any_(|x| x == &(variant(v.id))) {\n+                if !found.iter().any(|x| x == &(variant(v.id))) {\n                     return Some(variant(v.id));\n                 }\n             }\n@@ -805,13 +805,13 @@ pub fn is_refutable(cx: &MatchCheckCtxt, pat: &pat) -> bool {\n       }\n       pat_lit(_) | pat_range(_, _) => { true }\n       pat_struct(_, ref fields, _) => {\n-        fields.iter().any_(|f| is_refutable(cx, f.pat))\n+        fields.iter().any(|f| is_refutable(cx, f.pat))\n       }\n       pat_tup(ref elts) => {\n-        elts.iter().any_(|elt| is_refutable(cx, *elt))\n+        elts.iter().any(|elt| is_refutable(cx, *elt))\n       }\n       pat_enum(_, Some(ref args)) => {\n-        args.iter().any_(|a| is_refutable(cx, *a))\n+        args.iter().any(|a| is_refutable(cx, *a))\n       }\n       pat_enum(_,_) => { false }\n       pat_vec(*) => { true }"}, {"sha": "e054b84984d15aee1b1e375712b4febc2a82fe9f", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -341,14 +341,14 @@ impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n                 let entry_str = bits_to_str(on_entry);\n \n                 let gens = self.gens.slice(start, end);\n-                let gens_str = if gens.iter().any_(|&u| u != 0) {\n+                let gens_str = if gens.iter().any(|&u| u != 0) {\n                     fmt!(\" gen: %s\", bits_to_str(gens))\n                 } else {\n                     ~\"\"\n                 };\n \n                 let kills = self.kills.slice(start, end);\n-                let kills_str = if kills.iter().any_(|&u| u != 0) {\n+                let kills_str = if kills.iter().any(|&u| u != 0) {\n                     fmt!(\" kill: %s\", bits_to_str(kills))\n                 } else {\n                     ~\"\"\n@@ -643,7 +643,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 self.walk_opt_expr(o_e, in_out, loop_scopes);\n \n                 // is this a return from a `for`-loop closure?\n-                match loop_scopes.iter().position_(|s| s.loop_kind == ForLoop) {\n+                match loop_scopes.iter().position(|s| s.loop_kind == ForLoop) {\n                     Some(i) => {\n                         // if so, add the in_out bits to the state\n                         // upon exit. Remember that we cannot count\n@@ -916,7 +916,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             Some(_) => {\n                 match self.tcx().def_map.find(&expr.id) {\n                     Some(&ast::def_label(loop_id)) => {\n-                        match loop_scopes.iter().position_(|l| l.loop_id == loop_id) {\n+                        match loop_scopes.iter().position(|l| l.loop_id == loop_id) {\n                             Some(i) => i,\n                             None => {\n                                 self.tcx().sess.span_bug("}, {"sha": "a9454d1b23096e64a2942adefd20440bc95a22a3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -536,7 +536,7 @@ pub fn check_cast_for_escaping_regions(\n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n     // must have been declared on the enclosing fn item).\n-    if target_regions.iter().any_(|r| is_re_scope(*r)) {\n+    if target_regions.iter().any(|r| is_re_scope(*r)) {\n         return; /* case (1) */\n     }\n \n@@ -551,7 +551,7 @@ pub fn check_cast_for_escaping_regions(\n         |_r| {\n             // FIXME(#5723) --- turn this check on once &Objects are usable\n             //\n-            // if !target_regions.iter().any_(|t_r| is_subregion_of(cx, *t_r, r)) {\n+            // if !target_regions.iter().any(|t_r| is_subregion_of(cx, *t_r, r)) {\n             //     cx.tcx.sess.span_err(\n             //         source.span,\n             //         fmt!(\"source contains borrowed pointer with lifetime \\\n@@ -565,7 +565,7 @@ pub fn check_cast_for_escaping_regions(\n         |ty| {\n             match ty::get(ty).sty {\n                 ty::ty_param(source_param) => {\n-                    if target_params.iter().any_(|x| x == &source_param) {\n+                    if target_params.iter().any(|x| x == &source_param) {\n                         /* case (2) */\n                     } else {\n                         check_durable(cx.tcx, ty, source.span); /* case (3) */"}, {"sha": "0fc19ffd78e521ab8694a0c743f5822cc5b725b2", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -898,7 +898,7 @@ fn check_item_non_uppercase_statics(cx: &Context, it: &ast::item) {\n             // check for lowercase letters rather than non-uppercase\n             // ones (some scripts don't have a concept of\n             // upper/lowercase)\n-            if s.iter().any_(|c| c.is_lowercase()) {\n+            if s.iter().any(|c| c.is_lowercase()) {\n                 cx.span_lint(non_uppercase_statics, it.span,\n                              \"static constant should have an uppercase identifier\");\n             }\n@@ -1038,7 +1038,7 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n         // If we have doc(hidden), nothing to do\n         if cx.doc_hidden { return }\n         // If we're documented, nothing to do\n-        if attrs.iter().any_(|a| a.node.is_sugared_doc) { return }\n+        if attrs.iter().any(|a| a.node.is_sugared_doc) { return }\n \n         // otherwise, warn!\n         cx.span_lint(missing_doc, sp, msg);"}, {"sha": "f3d4abcdf310f79cf69fdbc1632913eb877c0279", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -390,8 +390,8 @@ impl VisitContext {\n                     // any fields which (1) were not explicitly\n                     // specified and (2) have a type that\n                     // moves-by-default:\n-                    let consume_with = with_fields.iter().any_(|tf| {\n-                        !fields.iter().any_(|f| f.node.ident == tf.ident) &&\n+                    let consume_with = with_fields.iter().any(|tf| {\n+                        !fields.iter().any(|f| f.node.ident == tf.ident) &&\n                             ty::type_moves_by_default(self.tcx, tf.mt.ty)\n                     });\n "}, {"sha": "8a2b134191534a9c32bb11a2b2bafec63a8f15be", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -259,7 +259,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                                          method_id.node);\n             if is_private &&\n                     (container_id.crate != local_crate ||\n-                     !privileged_items.iter().any_(|x| x == &(container_id.node))) {\n+                     !privileged_items.iter().any(|x| x == &(container_id.node))) {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n                                        token::ident_to_str(name)));\n@@ -287,7 +287,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n             def_fn(def_id, _) => {\n                 if def_id.crate == local_crate {\n                     if local_item_is_private(span, def_id.node) &&\n-                            !privileged_items.iter().any_(|x| x == &def_id.node) {\n+                            !privileged_items.iter().any(|x| x == &def_id.node) {\n                         tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n                                                token::ident_to_str(path.idents.last())));\n@@ -332,7 +332,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                         provided(method)\n                                              if method.vis == private &&\n                                              !privileged_items.iter()\n-                                             .any_(|x| x == &(trait_id.node)) => {\n+                                             .any(|x| x == &(trait_id.node)) => {\n                                             tcx.sess.span_err(span,\n                                                               fmt!(\"method `%s` is private\",\n                                                                    token::ident_to_str(&method\n@@ -417,7 +417,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                                           base))).sty {\n                         ty_struct(id, _)\n                         if id.crate != local_crate || !privileged_items.iter()\n-                                .any_(|x| x == &(id.node)) => {\n+                                .any(|x| x == &(id.node)) => {\n                             debug!(\"(privacy checking) checking field access\");\n                             check_field(expr.span, id, ident);\n                         }\n@@ -430,7 +430,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                                           base))).sty {\n                         ty_struct(id, _)\n                         if id.crate != local_crate ||\n-                           !privileged_items.iter().any_(|x| x == &(id.node)) => {\n+                           !privileged_items.iter().any(|x| x == &(id.node)) => {\n                             match method_map.find(&expr.id) {\n                                 None => {\n                                     tcx.sess.span_bug(expr.span,\n@@ -456,7 +456,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for (*fields).iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n@@ -467,7 +467,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for (*fields).iter().advance |field| {\n@@ -504,7 +504,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::expr_ty(tcx, operand)).sty {\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n-                                !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 check_variant(expr.span, id);\n                             }\n                         }\n@@ -522,7 +522,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::pat_ty(tcx, pattern)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n+                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for fields.iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n@@ -533,7 +533,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                         ty_enum(enum_id, _) => {\n                             if enum_id.crate != local_crate ||\n-                                    !privileged_items.iter().any_(|x| x == &enum_id.node) {\n+                                    !privileged_items.iter().any(|x| x == &enum_id.node) {\n                                 match tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {\n                                         for fields.iter().advance |field| {"}, {"sha": "e1c43121ec82be8c7265cf349c09a5b205bbaab8", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -78,7 +78,7 @@ impl RegionMaps {\n     pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n         match self.free_region_map.find_mut(&sub) {\n             Some(sups) => {\n-                if !sups.iter().any_(|x| x == &sup) {\n+                if !sups.iter().any(|x| x == &sup) {\n                     sups.push(sup);\n                 }\n                 return;\n@@ -202,7 +202,7 @@ impl RegionMaps {\n                             return true;\n                         }\n \n-                        if !queue.iter().any_(|x| x == parent) {\n+                        if !queue.iter().any(|x| x == parent) {\n                             queue.push(*parent);\n                         }\n                     }\n@@ -612,7 +612,7 @@ impl DetermineRpCtxt {\n             ambient_variance: self.ambient_variance,\n             id: self.item_id\n         };\n-        if !vec.iter().any_(|x| x == &dep) { vec.push(dep); }\n+        if !vec.iter().any(|x| x == &dep) { vec.push(dep); }\n     }\n \n     // Determines whether a reference to a region that appears in the"}, {"sha": "511e4fdd864cf48201f740ef5a94f7e15028bdb6", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -796,7 +796,7 @@ pub fn enter_region<'r>(bcx: block,\n pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n-        if set.iter().any_(|l| opt_eq(tcx, l, &val)) {return;}\n+        if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n \n@@ -963,7 +963,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n         for field_pats.iter().advance |field_pat| {\n             let field_ident = field_pat.ident;\n-            if !idents.iter().any_(|x| *x == field_ident) {\n+            if !idents.iter().any(|x| *x == field_ident) {\n                 idents.push(field_ident);\n             }\n         }\n@@ -974,7 +974,7 @@ pub fn pats_require_rooting(bcx: block,\n                             m: &[@Match],\n                             col: uint)\n                          -> bool {\n-    do m.iter().any_ |br| {\n+    do m.iter().any |br| {\n         let pat_id = br.pats[col].id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         bcx.ccx().maps.root_map.contains_key(&key)\n@@ -1003,7 +1003,7 @@ pub fn root_pats_as_necessary(mut bcx: block,\n // matches may be wildcards like _ or identifiers).\n macro_rules! any_pat (\n     ($m:expr, $pattern:pat) => (\n-        do ($m).iter().any_ |br| {\n+        do ($m).iter().any |br| {\n             match br.pats[col].node {\n                 $pattern => true,\n                 _ => false\n@@ -1029,7 +1029,7 @@ pub fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n }\n \n pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n-    do m.iter().any_ |br| {\n+    do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::pat_enum(_, Some(_)) => {"}, {"sha": "dc8f6b1d05b5179f3e06b3b7cb3d44ab716b340d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -147,7 +147,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n                     mk_struct(cx, self.tys, false).size == 0\n                 }\n                 fn find_ptr(&self) -> Option<uint> {\n-                    self.tys.iter().position_(|&ty| mono_data_classify(ty) == MonoNonNull)\n+                    self.tys.iter().position(|&ty| mono_data_classify(ty) == MonoNonNull)\n                 }\n             }\n "}, {"sha": "fa994ccaa651451df8494c986e1ba8ee61c7222e", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -413,7 +413,7 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // drop glue checks whether it is zero.\n pub fn revoke_clean(cx: block, val: ValueRef) {\n     do in_scope_cx(cx, None) |scope_info| {\n-        let cleanup_pos = scope_info.cleanups.iter().position_(\n+        let cleanup_pos = scope_info.cleanups.iter().position(\n             |cu| match *cu {\n                 clean_temp(v, _, _) if v == val => true,\n                 _ => false"}, {"sha": "9044ef5700321ed5a5ec972c96913fc31fc5ccf8", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -91,7 +91,7 @@ pub fn const_vec(cx: @mut CrateContext, e: &ast::expr, es: &[@ast::expr])\n         let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n         let vs = es.map(|e| const_expr(cx, *e));\n         // If the vector contains enums, an LLVM array won't work.\n-        let v = if vs.iter().any_(|vi| val_ty(*vi) != llunitty) {\n+        let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n             C_struct(vs)\n         } else {\n             C_array(llunitty, vs)"}, {"sha": "d1dde628dd00e8904b2ab4bbb91aee53eabc7d91", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -1147,7 +1147,7 @@ fn trans_rec_or_struct(bcx: block,\n         let mut need_base = vec::from_elem(field_tys.len(), true);\n \n         let numbered_fields = do fields.map |field| {\n-            let opt_pos = field_tys.iter().position_(|field_ty| field_ty.ident == field.node.ident);\n+            let opt_pos = field_tys.iter().position(|field_ty| field_ty.ident == field.node.ident);\n             match opt_pos {\n                 Some(i) => {\n                     need_base[i] = false;\n@@ -1171,7 +1171,7 @@ fn trans_rec_or_struct(bcx: block,\n                                      fields: leftovers })\n             }\n             None => {\n-                if need_base.iter().any_(|b| *b) {\n+                if need_base.iter().any(|b| *b) {\n                     tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n                 }\n                 None"}, {"sha": "bbcf68c386de7c9fcda00c372fc727b1dd730f95", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -84,7 +84,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let hash_id = make_mono_id(ccx, fn_id, impl_did_opt,\n                                &*psubsts,\n                                Some(param_uses));\n-    if hash_id.params.iter().any_(\n+    if hash_id.params.iter().any(\n                 |p| match *p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n     }"}, {"sha": "dce899010c76dd3e03f4af245c7d29924f9b5832", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -1485,8 +1485,8 @@ pub fn type_needs_subst(ty: t) -> bool {\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n-    tref.substs.self_ty.iter().any_(|&t| type_is_error(t)) ||\n-        tref.substs.tps.iter().any_(|&t| type_is_error(t))\n+    tref.substs.self_ty.iter().any(|&t| type_is_error(t)) ||\n+        tref.substs.tps.iter().any(|&t| type_is_error(t))\n }\n \n pub fn type_is_ty_var(ty: t) -> bool {\n@@ -2342,13 +2342,13 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_struct(did, ref substs) => {\n                 seen.push(did);\n                 let fields = struct_fields(cx, did, substs);\n-                let r = fields.iter().any_(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n+                let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n                 seen.pop();\n                 r\n             }\n \n             ty_tup(ref ts) => {\n-                ts.iter().any_(|t| type_requires(cx, seen, r_ty, *t))\n+                ts.iter().any(|t| type_requires(cx, seen, r_ty, *t))\n             }\n \n             ty_enum(ref did, _) if seen.contains(did) => {\n@@ -2359,7 +2359,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n                 let r = !vs.is_empty() && do vs.iter().all |variant| {\n-                    do variant.args.iter().any_ |aty| {\n+                    do variant.args.iter().any |aty| {\n                         let sty = subst(cx, substs, *aty);\n                         type_requires(cx, seen, r_ty, sty)\n                     }\n@@ -3241,7 +3241,7 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n }\n \n pub fn method_idx(id: ast::ident, meths: &[@Method]) -> Option<uint> {\n-    meths.iter().position_(|m| m.ident == id)\n+    meths.iter().position(|m| m.ident == id)\n }\n \n /// Returns a vector containing the indices of all type parameters that appear"}, {"sha": "d8185022e416d8e35f2915defd0cee547ff7ed05", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -553,7 +553,7 @@ pub fn bound_lifetimes<AC:AstConv>(\n     let special_idents = [special_idents::statik, special_idents::self_];\n     let mut bound_lifetime_names = opt_vec::Empty;\n     ast_lifetimes.map_to_vec(|ast_lifetime| {\n-        if special_idents.iter().any_(|&i| i == ast_lifetime.ident) {\n+        if special_idents.iter().any(|&i| i == ast_lifetime.ident) {\n             this.tcx().sess.span_err(\n                 ast_lifetime.span,\n                 fmt!(\"illegal lifetime parameter name: `%s`\","}, {"sha": "04c83f40f6cf88025384eee2f2301f4b5bbd2993", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -253,7 +253,7 @@ impl<'self> LookupContext<'self> {\n             ty_enum(did, _) => {\n                 // Watch out for newtype'd enums like \"enum t = @T\".\n                 // See discussion in typeck::check::do_autoderef().\n-                if enum_dids.iter().any_(|x| x == &did) {\n+                if enum_dids.iter().any(|x| x == &did) {\n                     return None;\n                 }\n                 enum_dids.push(did);\n@@ -368,7 +368,7 @@ impl<'self> LookupContext<'self> {\n \n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             let pos = {\n-                match trait_methods.iter().position_(|m| {\n+                match trait_methods.iter().position(|m| {\n                     m.explicit_self != ast::sty_static &&\n                         m.ident == self.m_name })\n                 {\n@@ -412,7 +412,7 @@ impl<'self> LookupContext<'self> {\n \n         let tcx = self.tcx();\n         let ms = ty::trait_methods(tcx, did);\n-        let index = match ms.iter().position_(|m| m.ident == self.m_name) {\n+        let index = match ms.iter().position(|m| m.ident == self.m_name) {\n             Some(i) => i,\n             None => { return; } // no method with the right name\n         };\n@@ -466,7 +466,7 @@ impl<'self> LookupContext<'self> {\n         // First, try self methods\n         let mut method_info: Option<MethodInfo> = None;\n         let methods = ty::trait_methods(tcx, did);\n-        match methods.iter().position_(|m| m.ident == self.m_name) {\n+        match methods.iter().position(|m| m.ident == self.m_name) {\n             Some(i) => {\n                 method_info = Some(MethodInfo {\n                     method_ty: methods[i],\n@@ -482,7 +482,7 @@ impl<'self> LookupContext<'self> {\n             for ty::trait_supertraits(tcx, did).iter().advance |trait_ref| {\n                 let supertrait_methods =\n                     ty::trait_methods(tcx, trait_ref.def_id);\n-                match supertrait_methods.iter().position_(|m| m.ident == self.m_name) {\n+                match supertrait_methods.iter().position(|m| m.ident == self.m_name) {\n                     Some(i) => {\n                         method_info = Some(MethodInfo {\n                             method_ty: supertrait_methods[i],\n@@ -538,7 +538,7 @@ impl<'self> LookupContext<'self> {\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n \n         let idx = {\n-            match impl_info.methods.iter().position_(|m| m.ident == self.m_name) {\n+            match impl_info.methods.iter().position(|m| m.ident == self.m_name) {\n                 Some(idx) => idx,\n                 None => { return; } // No method with the right name.\n             }"}, {"sha": "7cc3286741430b0ea287a4351929f9c94da8c20c", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -67,7 +67,7 @@ impl VtableContext {\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n-    type_param_defs.iter().any_(\n+    type_param_defs.iter().any(\n         |type_param_def| !type_param_def.bounds.trait_bounds.is_empty())\n }\n "}, {"sha": "fb544335a723b8a65d9e21ed3048db0c22b83937", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -391,7 +391,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n                                               generics, self_ty);\n \n         // FIXME(#5527) Could have same trait multiple times\n-        if ty_trait_refs.iter().any_(|other_trait| other_trait.def_id == trait_ref.def_id) {\n+        if ty_trait_refs.iter().any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n             // This means a trait inherited from the same supertrait more\n             // than once.\n             tcx.sess.span_err(sp, \"Duplicate supertrait in trait declaration\");"}, {"sha": "90a316c78f965caf13b337e88eee47662470ddca", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -540,7 +540,7 @@ pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n \n pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n     match r {\n-        ty::re_infer(ty::ReVar(ref v)) => new_vars.iter().any_(|x| x == v),\n+        ty::re_infer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n         _ => false\n     }\n }"}, {"sha": "96d18976358e0b05eb462542f5f6f1e015f22398", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -184,7 +184,7 @@ impl Combine for Lub {\n             // with.\n             for list::each(a_isr) |pair| {\n                 let (a_br, a_r) = *pair;\n-                if tainted.iter().any_(|x| x == &a_r) {\n+                if tainted.iter().any(|x| x == &a_r) {\n                     debug!(\"generalize_region(r0=%?): \\\n                             replacing with %?, tainted=%?\",\n                            r0, a_br, tainted);"}, {"sha": "50290ba752e74b202f1bb360ddf8ebf476257ab6", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -454,7 +454,7 @@ impl RegionVarBindings {\n         {\n             let mut result_set = result_set;\n             if r == r1 { // Clearly, this is potentially inefficient.\n-                if !result_set.iter().any_(|x| *x == r2) {\n+                if !result_set.iter().any(|x| *x == r2) {\n                     result_set.push(r2);\n                 }\n             }"}, {"sha": "7e418c0061d33c2458655e8a8f23e25e058b8ef8", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -199,7 +199,7 @@ impl Combine for Sub {\n                 // or new variables:\n                 match *tainted_region {\n                     ty::re_infer(ty::ReVar(ref vid)) => {\n-                        if new_vars.iter().any_(|x| x == vid) { loop; }\n+                        if new_vars.iter().any(|x| x == vid) { loop; }\n                     }\n                     _ => {\n                         if *tainted_region == skol { loop; }"}, {"sha": "35375d025ebc6812c6a09d561803cd1874ef846c", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -212,7 +212,7 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     let lint_flags = vec::append(getopts::opt_strs(matches, \"W\"),\n                                  getopts::opt_strs(matches, \"warn\"));\n \n-    let show_lint_options = lint_flags.iter().any_(|x| x == &~\"help\") ||\n+    let show_lint_options = lint_flags.iter().any(|x| x == &~\"help\") ||\n         (opt_present(matches, \"W\") && lint_flags.is_empty());\n \n     if show_lint_options {\n@@ -221,7 +221,7 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     }\n \n     let r = getopts::opt_strs(matches, \"Z\");\n-    if r.iter().any_(|x| x == &~\"help\") {\n+    if r.iter().any(|x| x == &~\"help\") {\n         describe_debug_flags();\n         return;\n     }"}, {"sha": "e61f8d6d74334b17eb76a91ed5e14057b7e9637d", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -57,7 +57,7 @@ pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n \n pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n     let r = doc_metas(attrs);\n-    do r.iter().any_ |meta| {\n+    do r.iter().any |meta| {\n         match attr::get_meta_item_list(*meta) {\n             Some(metas) => {\n                 let hiddens = attr::find_meta_items_by_name(metas, \"hidden\");"}, {"sha": "ccf014fb2383b33dcb5585b5fae9b3d8f31f3a92", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -64,7 +64,7 @@ pub mod util;\n pub fn main() {\n     let args = os::args();\n \n-    if args.iter().any_(|x| \"-h\" == *x) || args.iter().any_(|x| \"--help\" == *x) {\n+    if args.iter().any(|x| \"-h\" == *x) || args.iter().any(|x| \"--help\" == *x) {\n         config::usage();\n         return;\n     }"}, {"sha": "d7c03ce2ba767d2f8ec3af440ce68c5c73562b7b", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -381,7 +381,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                 let crate_path = Path(*crate);\n                 let crate_dir = crate_path.dirname();\n                 repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n-                if !repl.lib_search_paths.iter().any_(|x| x == &crate_dir) {\n+                if !repl.lib_search_paths.iter().any(|x| x == &crate_dir) {\n                     repl.lib_search_paths.push(crate_dir);\n                 }\n             }"}, {"sha": "251783577df8e8eb746a2452394d1406c5ab1fb4", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -626,14 +626,14 @@ fn install_remove() {\n     command_line_test([~\"install\", ~\"bar\"], &dir);\n     command_line_test([~\"install\", ~\"quux\"], &dir);\n     let list_output = command_line_test_output([~\"list\"]);\n-    assert!(list_output.iter().any_(|x| x == &~\"foo\"));\n-    assert!(list_output.iter().any_(|x| x == &~\"bar\"));\n-    assert!(list_output.iter().any_(|x| x == &~\"quux\"));\n+    assert!(list_output.iter().any(|x| x == &~\"foo\"));\n+    assert!(list_output.iter().any(|x| x == &~\"bar\"));\n+    assert!(list_output.iter().any(|x| x == &~\"quux\"));\n     command_line_test([~\"remove\", ~\"foo\"], &dir);\n     let list_output = command_line_test_output([~\"list\"]);\n-    assert!(!list_output.iter().any_(|x| x == &~\"foo\"));\n-    assert!(list_output.iter().any_(|x| x == &~\"bar\"));\n-    assert!(list_output.iter().any_(|x| x == &~\"quux\"));\n+    assert!(!list_output.iter().any(|x| x == &~\"foo\"));\n+    assert!(list_output.iter().any(|x| x == &~\"bar\"));\n+    assert!(list_output.iter().any(|x| x == &~\"quux\"));\n }\n \n #[test]\n@@ -699,7 +699,7 @@ fn test_versions() {\n     command_line_test([~\"install\", ~\"foo#0.1\"], &workspace);\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n-    assert!(!output.iter().any_(|x| x == &~\"foo#0.2\"));\n+    assert!(!output.iter().any(|x| x == &~\"foo#0.2\"));\n }\n \n #[test]"}, {"sha": "900ef4896ca118f117cb32e6025dda26ffcef6f4", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -55,7 +55,7 @@ pub fn root() -> Path {\n }\n \n pub fn is_cmd(cmd: &str) -> bool {\n-    COMMANDS.iter().any_(|&c| c == cmd)\n+    COMMANDS.iter().any(|&c| c == cmd)\n }\n \n struct ListenerFn {"}, {"sha": "8094b2387495cc9bfcb7bda9fa8ea23e210a4943", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -338,16 +338,16 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert!(it.any_(|&x| *x == 3));\n-    /// assert!(!it.any_(|&x| *x == 3));\n+    /// assert!(it.any(|&x| *x == 3));\n+    /// assert!(!it.any(|&x| *x == 3));\n     /// ~~~\n-    fn any_(&mut self, f: &fn(A) -> bool) -> bool;\n+    fn any(&mut self, f: &fn(A) -> bool) -> bool;\n \n     /// Return the first element satisfying the specified predicate\n     fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A>;\n \n     /// Return the index of the first element satisfying the specified predicate\n-    fn position_(&mut self, predicate: &fn(A) -> bool) -> Option<uint>;\n+    fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint>;\n \n     /// Count the number of elements satisfying the specified predicate\n     fn count(&mut self, predicate: &fn(A) -> bool) -> uint;\n@@ -504,7 +504,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     #[inline]\n-    fn any_(&mut self, f: &fn(A) -> bool) -> bool {\n+    fn any(&mut self, f: &fn(A) -> bool) -> bool {\n         for self.advance |x| { if f(x) { return true; } }\n         false\n     }\n@@ -520,7 +520,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n-    fn position_(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n+    fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n         let mut i = 0;\n         for self.advance |x| {\n             if predicate(x) {\n@@ -1368,10 +1368,10 @@ mod tests {\n     #[test]\n     fn test_any() {\n         let v = ~&[1, 2, 3, 4, 5];\n-        assert!(v.iter().any_(|&x| x < 10));\n-        assert!(v.iter().any_(|&x| x.is_even()));\n-        assert!(!v.iter().any_(|&x| x > 100));\n-        assert!(!v.slice(0, 0).iter().any_(|_| fail!()));\n+        assert!(v.iter().any(|&x| x < 10));\n+        assert!(v.iter().any(|&x| x.is_even()));\n+        assert!(!v.iter().any(|&x| x > 100));\n+        assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n     }\n \n     #[test]\n@@ -1385,9 +1385,9 @@ mod tests {\n     #[test]\n     fn test_position() {\n         let v = &[1, 3, 9, 27, 103, 14, 11];\n-        assert_eq!(v.iter().position_(|x| *x & 1 == 0).unwrap(), 5);\n-        assert_eq!(v.iter().position_(|x| *x % 3 == 0).unwrap(), 1);\n-        assert!(v.iter().position_(|x| *x % 12 == 0).is_none());\n+        assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n+        assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n+        assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n     }\n \n     #[test]"}, {"sha": "7e051b62171c85db65644bd5740b08506e35a6cb", "filename": "src/libstd/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -587,7 +587,7 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n     return cmd;\n \n     fn append_arg(cmd: &mut ~str, arg: &str) {\n-        let quote = arg.iter().any_(|c| c == ' ' || c == '\\t');\n+        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n         if quote {\n             cmd.push_char('\"');\n         }"}, {"sha": "bdd9bebf158d2f5b14abd8891bebfe6a7581a819", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -279,7 +279,7 @@ impl CharEq for extern \"Rust\" fn(char) -> bool {\n impl<'self, C: CharEq> CharEq for &'self [C] {\n     #[inline]\n     fn matches(&self, c: char) -> bool {\n-        self.iter().any_(|m| m.matches(c))\n+        self.iter().any(|m| m.matches(c))\n     }\n \n     fn only_ascii(&self) -> bool {"}, {"sha": "8dd96df45453927da947241d00095e5c7959a71b", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -142,7 +142,7 @@ unsafe fn local_data_lookup<T: 'static>(\n     -> Option<(uint, *libc::c_void)> {\n \n     let key_value = key_to_key_value(key);\n-    let map_pos = (*map).iter().position_(|entry|\n+    let map_pos = (*map).iter().position(|entry|\n         match *entry {\n             Some((k,_,_)) => k == key_value,\n             None => false\n@@ -215,7 +215,7 @@ pub unsafe fn local_set<T: 'static>(\n         }\n         None => {\n             // Find an empty slot. If not, grow the vector.\n-            match (*map).iter().position_(|x| x.is_none()) {\n+            match (*map).iter().position(|x| x.is_none()) {\n                 Some(empty_index) => { map[empty_index] = new_entry; }\n                 None => { map.push(new_entry); }\n             }"}, {"sha": "84e4358a496013c66f29df0d9b7257914c7deab4", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -191,7 +191,7 @@ impl<'self, T> Iterator<&'self [T]> for VecSplitIterator<'self, T> {\n             return Some(self.v);\n         }\n \n-        match self.v.iter().position_(|x| (self.pred)(x)) {\n+        match self.v.iter().position(|x| (self.pred)(x)) {\n             None => {\n                 self.finished = true;\n                 Some(self.v)\n@@ -1010,7 +1010,7 @@ impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n     /// Find the first index containing a matching value\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n-        self.iter().position_(|y| *x == *y)\n+        self.iter().position(|y| *x == *y)\n     }\n \n     /// Find the last index containing a matching value"}, {"sha": "e4532c476d75f626f446ece0bfeb7176df7b0e0a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -192,7 +192,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n             ast::meta_list(ref nb, ref misb) => {\n                 if na != nb { return false; }\n                 for misa.iter().advance |mi| {\n-                    if !misb.iter().any_(|x| x == mi) { return false; }\n+                    if !misb.iter().any(|x| x == mi) { return false; }\n                 }\n                 true\n             }"}, {"sha": "71e0d49493b81b8ce2d8c8ac6474a15beb27f347", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -198,7 +198,7 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n \n // does this attribute list contain \"macro_escape\" ?\n pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool {\n-    attrs.iter().any_(|attr| \"macro_escape\" == attr::get_attr_name(attr))\n+    attrs.iter().any(|attr| \"macro_escape\" == attr::get_attr_name(attr))\n }\n \n // Support for item-position macro invocations, exactly the same"}, {"sha": "c43b350abdbf7b797aa13d8aaec56b3d06393ab7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -3914,7 +3914,7 @@ impl Parser {\n         };\n         let full_path = full_path.normalize();\n \n-        let maybe_i = do self.sess.included_mod_stack.iter().position_ |&p| { p == full_path };\n+        let maybe_i = do self.sess.included_mod_stack.iter().position |&p| { p == full_path };\n         match maybe_i {\n             Some(i) => {\n                 let stack = &self.sess.included_mod_stack;"}, {"sha": "867be38545cdfe9256559a3c8c3b0f20b3ad7ce9", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -44,7 +44,7 @@ fn maybe_run_test(argv: &[~str], name: ~str, test: &fn()) {\n     if os::getenv(~\"RUST_BENCH\").is_some() {\n         run_test = true\n     } else if argv.len() > 0 {\n-        run_test = argv.iter().any_(|x| x == &~\"all\") || argv.iter().any_(|x| x == &name)\n+        run_test = argv.iter().any(|x| x == &~\"all\") || argv.iter().any(|x| x == &name)\n     }\n \n     if !run_test {"}, {"sha": "47de9334be15c039a794bbfc73126706f1edfa64", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -111,7 +111,7 @@ fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n     while keys.len() < n {\n         let k = r.gen_uint_range(0u, graph.len());\n \n-        if graph[k].len() > 0u && graph[k].iter().any_(|i| {\n+        if graph[k].len() > 0u && graph[k].iter().any(|i| {\n             *i != k as node_id\n         }) {\n             keys.insert(k as node_id);\n@@ -187,7 +187,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     }\n \n     let mut i = 0;\n-    while colors.iter().any_(is_gray) {\n+    while colors.iter().any(is_gray) {\n         // Do the BFS.\n         info!(\"PBFS iteration %?\", i);\n         i += 1;\n@@ -402,7 +402,7 @@ fn validate(edges: ~[(node_id, node_id)],\n             if *v == -1i64 || u == root {\n                 true\n             } else {\n-                edges.iter().any_(|x| x == &(u, *v)) || edges.iter().any_(|x| x == &(*v, u))\n+                edges.iter().any(|x| x == &(u, *v)) || edges.iter().any(|x| x == &(*v, u))\n             }\n         };\n         result"}, {"sha": "466f2def290bf60bf2afadb9435281c75c38fedd", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -20,28 +20,28 @@ pub fn main() {\n     }\n \n     // Usable at all:\n-    let mut any_negative = do v.iter().any_ |e| { e.is_negative() };\n+    let mut any_negative = do v.iter().any |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than assignments:\n-    any_negative = do v.iter().any_ |e| { e.is_negative() };\n+    any_negative = do v.iter().any |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n     let abs_v = do v.iter().transform |e| { e.abs() }.collect::<~[float]>();\n     assert!(do abs_v.iter().all |e| { e.is_positive() });\n-    assert!(!do abs_v.iter().any_ |e| { e.is_negative() });\n+    assert!(!do abs_v.iter().any |e| { e.is_negative() });\n \n     // Usable in funny statement-like forms:\n-    if !do v.iter().any_ |e| { e.is_positive() } {\n+    if !do v.iter().any |e| { e.is_positive() } {\n         assert!(false);\n     }\n     match do v.iter().all |e| { e.is_negative() } {\n         true => { fail!(\"incorrect answer.\"); }\n         false => { }\n     }\n     match 3 {\n-      _ if do v.iter().any_ |e| { e.is_negative() } => {\n+      _ if do v.iter().any |e| { e.is_negative() } => {\n       }\n       _ => {\n         fail!(\"wrong answer.\");\n@@ -58,7 +58,7 @@ pub fn main() {\n \n     // In the tail of a block\n     let w =\n-        if true { do abs_v.iter().any_ |e| { e.is_positive() } }\n+        if true { do abs_v.iter().any |e| { e.is_positive() } }\n       else { false };\n     assert!(w);\n }"}, {"sha": "068f18ac0f83aa1c7f053b3667fbc99d4884483c", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/641aec74076f8c5735a7d379753194f877866525/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641aec74076f8c5735a7d379753194f877866525/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=641aec74076f8c5735a7d379753194f877866525", "patch": "@@ -29,8 +29,8 @@ fn checktests() {\n     let tests = __test::tests;\n \n     assert!(\n-        tests.iter().any_(|t| t.desc.name.to_str() == ~\"shouldignore\" && t.desc.ignore));\n+        tests.iter().any(|t| t.desc.name.to_str() == ~\"shouldignore\" && t.desc.ignore));\n \n     assert!(\n-        tests.iter().any_(|t| t.desc.name.to_str() == ~\"shouldnotignore\" && !t.desc.ignore));\n+        tests.iter().any(|t| t.desc.name.to_str() == ~\"shouldnotignore\" && !t.desc.ignore));\n }"}]}