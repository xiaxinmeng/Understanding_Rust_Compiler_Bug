{"sha": "8611a0bb5cc401f90162449eaa82295ef5f70d68", "node_id": "C_kwDOAAsO6NoAKDg2MTFhMGJiNWNjNDAxZjkwMTYyNDQ5ZWFhODIyOTVlZjVmNzBkNjg", "commit": {"author": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-01T08:48:01Z"}, "committer": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-15T11:03:29Z"}, "message": "Expand `unnecessary_def_path` lint", "tree": {"sha": "ad2c1180cef9c72cfa40b631b2f593122872811e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad2c1180cef9c72cfa40b631b2f593122872811e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8611a0bb5cc401f90162449eaa82295ef5f70d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8611a0bb5cc401f90162449eaa82295ef5f70d68", "html_url": "https://github.com/rust-lang/rust/commit/8611a0bb5cc401f90162449eaa82295ef5f70d68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8611a0bb5cc401f90162449eaa82295ef5f70d68/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c84ac4cee96f13b0abe8dc1f1b2d4e9406f80791", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84ac4cee96f13b0abe8dc1f1b2d4e9406f80791", "html_url": "https://github.com/rust-lang/rust/commit/c84ac4cee96f13b0abe8dc1f1b2d4e9406f80791"}], "stats": {"total": 238, "additions": 182, "deletions": 56}, "files": [{"sha": "893410dbfdc984817292c9d9bf5b6bea24140dc5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8611a0bb5cc401f90162449eaa82295ef5f70d68/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8611a0bb5cc401f90162449eaa82295ef5f70d68/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8611a0bb5cc401f90162449eaa82295ef5f70d68", "patch": "@@ -542,7 +542,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|_| {\n             Box::<utils::internal_lints::lint_without_lint_pass::LintWithoutLintPass>::default()\n         });\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::unnecessary_def_path::UnnecessaryDefPath));\n+        store.register_late_pass(|_| Box::<utils::internal_lints::unnecessary_def_path::UnnecessaryDefPath>::default());\n         store.register_late_pass(|_| Box::new(utils::internal_lints::outer_expn_data_pass::OuterExpnDataPass));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::msrv_attr_impl::MsrvAttrImpl));\n     }"}, {"sha": "0a3852c98ee93eef59a252b0fe987b41a96e51f2", "filename": "clippy_lints/src/utils/internal_lints/unnecessary_def_path.rs", "status": "modified", "additions": 132, "deletions": 49, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/8611a0bb5cc401f90162449eaa82295ef5f70d68/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8611a0bb5cc401f90162449eaa82295ef5f70d68/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs?ref=8611a0bb5cc401f90162449eaa82295ef5f70d68", "patch": "@@ -1,18 +1,20 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{def_path_res, is_lint_allowed, match_any_def_paths, peel_hir_expr_refs};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{ExprKind, Local, Mutability, Node};\n+use rustc_hir::{Expr, ExprKind, Local, Mutability, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n use rustc_middle::ty::{self, AssocKind, DefIdTree, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::Span;\n \n use std::str;\n \n@@ -38,11 +40,56 @@ declare_clippy_lint! {\n     \"using a def path when a diagnostic item or a `LangItem` is available\"\n }\n \n-declare_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n+impl_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n+\n+#[derive(Default)]\n+pub struct UnnecessaryDefPath {\n+    array_def_ids: FxHashSet<(DefId, Span)>,\n+    linted_def_ids: FxHashSet<DefId>,\n+}\n \n-#[allow(clippy::too_many_lines)]\n impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n+            return;\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Call(func, args) => self.check_call(cx, func, args, expr.span),\n+            ExprKind::Array(elements) => self.check_array(cx, elements, expr.span),\n+            _ => {},\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        for &(def_id, span) in &self.array_def_ids {\n+            if self.linted_def_ids.contains(&def_id) {\n+                continue;\n+            }\n+\n+            let (msg, sugg) = if let Some(sym) = cx.tcx.get_diagnostic_name(def_id) {\n+                (\"diagnostic item\", format!(\"sym::{sym}\"))\n+            } else if let Some(sym) = get_lang_item_name(cx, def_id) {\n+                (\"language item\", format!(\"LangItem::{sym}\"))\n+            } else {\n+                continue;\n+            };\n+\n+            span_lint_and_help(\n+                cx,\n+                UNNECESSARY_DEF_PATH,\n+                span,\n+                &format!(\"hardcoded path to a {msg}\"),\n+                None,\n+                &format!(\"convert all references to use `{sugg}`\"),\n+            );\n+        }\n+    }\n+}\n+\n+impl UnnecessaryDefPath {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_call(&mut self, cx: &LateContext<'_>, func: &Expr<'_>, args: &[Expr<'_>], span: Span) {\n         enum Item {\n             LangItem(Symbol),\n             DiagnosticItem(Symbol),\n@@ -54,42 +101,17 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n             &[\"clippy_utils\", \"is_expr_path_def_path\"],\n         ];\n \n-        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n-            return;\n-        }\n-\n         if_chain! {\n-            if let ExprKind::Call(func, [cx_arg, def_arg, args@..]) = expr.kind;\n+            if let [cx_arg, def_arg, args@..] = args;\n             if let ExprKind::Path(path) = &func.kind;\n             if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n             if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n             let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, item_arg);\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n-            if let Some(def_id) = def_path_res(cx, &segments[..], None).opt_def_id();\n+            if let Some(def_id) = inherent_def_path_res(cx, &segments[..]);\n             then {\n-                // def_path_res will match field names before anything else, but for this we want to match\n-                // inherent functions first.\n-                let def_id = if cx.tcx.def_kind(def_id) == DefKind::Field {\n-                    let method_name = *segments.last().unwrap();\n-                    cx.tcx.def_key(def_id).parent\n-                        .and_then(|parent_idx|\n-                            cx.tcx.inherent_impls(DefId { index: parent_idx, krate: def_id.krate }).iter()\n-                                .find_map(|impl_id| cx.tcx.associated_items(*impl_id)\n-                                    .find_by_name_and_kind(\n-                                        cx.tcx,\n-                                        Ident::from_str(method_name),\n-                                        AssocKind::Fn,\n-                                        *impl_id,\n-                                    )\n-                                )\n-                        )\n-                        .map_or(def_id, |item| item.def_id)\n-                } else {\n-                    def_id\n-                };\n-\n                 // Check if the target item is a diagnostic item or LangItem.\n                 let (msg, item) = if let Some(item_name)\n                     = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n@@ -98,9 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n                         \"use of a def path to a diagnostic item\",\n                         Item::DiagnosticItem(*item_name),\n                     )\n-                } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n-                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n-                    let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n+                } else if let Some(item_name) = get_lang_item_name(cx, def_id) {\n                     (\n                         \"use of a def path to a `LangItem`\",\n                         Item::LangItem(item_name),\n@@ -168,10 +188,10 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n                 span_lint_and_then(\n                     cx,\n                     UNNECESSARY_DEF_PATH,\n-                    expr.span,\n+                    span,\n                     msg,\n                     |diag| {\n-                        diag.span_suggestion(expr.span, \"try\", sugg, app);\n+                        diag.span_suggestion(span, \"try\", sugg, app);\n                         if with_note {\n                             diag.help(\n                                 \"if this `DefId` came from a constructor expression or pattern then the \\\n@@ -180,9 +200,19 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n                         }\n                     },\n                 );\n+\n+                self.linted_def_ids.insert(def_id);\n             }\n         }\n     }\n+\n+    fn check_array(&mut self, cx: &LateContext<'_>, elements: &[Expr<'_>], span: Span) {\n+        let Some(path) = path_from_array(elements) else { return };\n+\n+        if let Some(def_id) = inherent_def_path_res(cx, &path.iter().map(AsRef::as_ref).collect::<Vec<_>>()) {\n+            self.array_def_ids.insert((def_id, span));\n+        }\n+    }\n }\n \n fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n@@ -209,18 +239,7 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n             },\n             _ => None,\n         },\n-        ExprKind::Array(exprs) => exprs\n-            .iter()\n-            .map(|expr| {\n-                if let ExprKind::Lit(lit) = &expr.kind {\n-                    if let LitKind::Str(sym, _) = lit.node {\n-                        return Some((*sym.as_str()).to_owned());\n-                    }\n-                }\n-\n-                None\n-            })\n-            .collect(),\n+        ExprKind::Array(exprs) => path_from_array(exprs),\n         _ => None,\n     }\n }\n@@ -258,3 +277,67 @@ fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation\n         None\n     }\n }\n+\n+fn path_from_array(exprs: &[Expr<'_>]) -> Option<Vec<String>> {\n+    exprs\n+        .iter()\n+        .map(|expr| {\n+            if let ExprKind::Lit(lit) = &expr.kind {\n+                if let LitKind::Str(sym, _) = lit.node {\n+                    return Some((*sym.as_str()).to_owned());\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect()\n+}\n+\n+// def_path_res will match field names before anything else, but for this we want to match\n+// inherent functions first.\n+fn inherent_def_path_res(cx: &LateContext<'_>, segments: &[&str]) -> Option<DefId> {\n+    def_path_res(cx, segments, None).opt_def_id().map(|def_id| {\n+        if cx.tcx.def_kind(def_id) == DefKind::Field {\n+            let method_name = *segments.last().unwrap();\n+            cx.tcx\n+                .def_key(def_id)\n+                .parent\n+                .and_then(|parent_idx| {\n+                    cx.tcx\n+                        .inherent_impls(DefId {\n+                            index: parent_idx,\n+                            krate: def_id.krate,\n+                        })\n+                        .iter()\n+                        .find_map(|impl_id| {\n+                            cx.tcx.associated_items(*impl_id).find_by_name_and_kind(\n+                                cx.tcx,\n+                                Ident::from_str(method_name),\n+                                AssocKind::Fn,\n+                                *impl_id,\n+                            )\n+                        })\n+                })\n+                .map_or(def_id, |item| item.def_id)\n+        } else {\n+            def_id\n+        }\n+    })\n+}\n+\n+fn get_lang_item_name(cx: &LateContext<'_>, def_id: DefId) -> Option<Symbol> {\n+    if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n+        let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n+        let item_name = cx\n+            .tcx\n+            .adt_def(lang_items)\n+            .variants()\n+            .iter()\n+            .nth(lang_item)\n+            .unwrap()\n+            .name;\n+        Some(item_name)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "cbbb4652306415b7256435bcdc5f83256c47c6b4", "filename": "tests/ui-internal/unnecessary_def_path.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8611a0bb5cc401f90162449eaa82295ef5f70d68/tests%2Fui-internal%2Funnecessary_def_path.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8611a0bb5cc401f90162449eaa82295ef5f70d68/tests%2Fui-internal%2Funnecessary_def_path.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.fixed?ref=8611a0bb5cc401f90162449eaa82295ef5f70d68", "patch": "@@ -28,17 +28,17 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::Ty;\n \n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n \n fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n     let _ = is_type_diagnostic_item(cx, ty, sym::Option);\n     let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n     let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n \n-    #[allow(unused)]\n+    #[allow(unused, clippy::unnecessary_def_path)]\n     let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n     let _ = is_type_diagnostic_item(cx, ty, sym::Rc);\n "}, {"sha": "f17fed6c6530410cc139dfe34c4dfa85d155917d", "filename": "tests/ui-internal/unnecessary_def_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8611a0bb5cc401f90162449eaa82295ef5f70d68/tests%2Fui-internal%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8611a0bb5cc401f90162449eaa82295ef5f70d68/tests%2Fui-internal%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.rs?ref=8611a0bb5cc401f90162449eaa82295ef5f70d68", "patch": "@@ -28,17 +28,17 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::Ty;\n \n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n \n fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n     let _ = match_type(cx, ty, &OPTION);\n     let _ = match_type(cx, ty, RESULT);\n     let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n \n-    #[allow(unused)]\n+    #[allow(unused, clippy::unnecessary_def_path)]\n     let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n     let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n "}, {"sha": "b5ff3a5420561a8d7f473e843d26d73e77c9ede4", "filename": "tests/ui-internal/unnecessary_def_path_hardcoded_path.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8611a0bb5cc401f90162449eaa82295ef5f70d68/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8611a0bb5cc401f90162449eaa82295ef5f70d68/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.rs?ref=8611a0bb5cc401f90162449eaa82295ef5f70d68", "patch": "@@ -0,0 +1,16 @@\n+#![feature(rustc_private)]\n+#![allow(unused)]\n+#![warn(clippy::unnecessary_def_path)]\n+\n+extern crate rustc_hir;\n+\n+use rustc_hir::LangItem;\n+\n+fn main() {\n+    const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n+    const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n+    const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+\n+    // Don't lint, not yet a diagnostic or language item\n+    const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n+}"}, {"sha": "af46d87bf676e42816316dcf94aef37abb063059", "filename": "tests/ui-internal/unnecessary_def_path_hardcoded_path.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8611a0bb5cc401f90162449eaa82295ef5f70d68/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8611a0bb5cc401f90162449eaa82295ef5f70d68/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr?ref=8611a0bb5cc401f90162449eaa82295ef5f70d68", "patch": "@@ -0,0 +1,27 @@\n+error: hardcoded path to a language item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:11:40\n+   |\n+LL |     const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `LangItem::DerefMut`\n+   = note: `-D clippy::unnecessary-def-path` implied by `-D warnings`\n+\n+error: hardcoded path to a diagnostic item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:12:43\n+   |\n+LL |     const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `sym::deref_method`\n+\n+error: hardcoded path to a diagnostic item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:10:36\n+   |\n+LL |     const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `sym::Deref`\n+\n+error: aborting due to 3 previous errors\n+"}]}