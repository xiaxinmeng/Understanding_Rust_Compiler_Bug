{"sha": "5bf5cc605fd2732fa35b284a4401bfaa899dcae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViZjVjYzYwNWZkMjczMmZhMzViMjg0YTQ0MDFiZmFhODk5ZGNhZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-10T02:52:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-10T02:52:08Z"}, "message": "auto merge of #14694 : aochagavia/rust/num-cleanup, r=alexcrichton", "tree": {"sha": "8b059260425c91d5220cef2bfed585e4e7d72f94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b059260425c91d5220cef2bfed585e4e7d72f94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bf5cc605fd2732fa35b284a4401bfaa899dcae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bf5cc605fd2732fa35b284a4401bfaa899dcae2", "html_url": "https://github.com/rust-lang/rust/commit/5bf5cc605fd2732fa35b284a4401bfaa899dcae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bf5cc605fd2732fa35b284a4401bfaa899dcae2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "907d96187641d8a018af2b73239723c66b011f71", "url": "https://api.github.com/repos/rust-lang/rust/commits/907d96187641d8a018af2b73239723c66b011f71", "html_url": "https://github.com/rust-lang/rust/commit/907d96187641d8a018af2b73239723c66b011f71"}, {"sha": "0eb858b4c913b531ae5ac915abbbe579b49b9df4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb858b4c913b531ae5ac915abbbe579b49b9df4", "html_url": "https://github.com/rust-lang/rust/commit/0eb858b4c913b531ae5ac915abbbe579b49b9df4"}], "stats": {"total": 882, "additions": 445, "deletions": 437}, "files": [{"sha": "0933301970d1969a3901a1c9f6b196107653e7b4", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5bf5cc605fd2732fa35b284a4401bfaa899dcae2/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bf5cc605fd2732fa35b284a4401bfaa899dcae2/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=5bf5cc605fd2732fa35b284a4401bfaa899dcae2", "patch": "@@ -17,18 +17,16 @@ A `BigInt` is a combination of `BigUint` and `Sign`.\n */\n \n use Integer;\n+use rand::Rng;\n \n-use std::cmp;\n+use std::{cmp, fmt};\n use std::default::Default;\n-use std::fmt;\n use std::from_str::FromStr;\n use std::num::CheckedDiv;\n use std::num::{Bitwise, ToPrimitive, FromPrimitive};\n use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n-use rand::Rng;\n use std::string::String;\n-use std::uint;\n-use std::{i64, u64};\n+use std::{uint, i64, u64};\n \n /**\n A `BigDigit` is a `BigUint`'s composing element.\n@@ -94,7 +92,7 @@ impl Eq for BigUint {}\n impl PartialOrd for BigUint {\n     #[inline]\n     fn lt(&self, other: &BigUint) -> bool {\n-        match self.cmp(other) { Less => true, _ => false}\n+        self.cmp(other) == Less\n     }\n }\n \n@@ -115,7 +113,7 @@ impl Ord for BigUint {\n \n impl Default for BigUint {\n     #[inline]\n-    fn default() -> BigUint { BigUint::new(Vec::new()) }\n+    fn default() -> BigUint { Zero::zero() }\n }\n \n impl fmt::Show for BigUint {\n@@ -605,7 +603,7 @@ impl_to_biguint!(u64,  FromPrimitive::from_u64)\n \n impl ToStrRadix for BigUint {\n     fn to_str_radix(&self, radix: uint) -> String {\n-        assert!(1 < radix && radix <= 16);\n+        assert!(1 < radix && radix <= 16, \"The radix must be within (1, 16]\");\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n             return fill_concat(self.data.as_slice(), radix, max_len)\n@@ -645,8 +643,7 @@ impl ToStrRadix for BigUint {\n impl FromStrRadix for BigUint {\n     /// Creates and initializes a `BigUint`.\n     #[inline]\n-    fn from_str_radix(s: &str, radix: uint)\n-        -> Option<BigUint> {\n+    fn from_str_radix(s: &str, radix: uint) -> Option<BigUint> {\n         BigUint::parse_bytes(s.as_bytes(), radix)\n     }\n }\n@@ -656,22 +653,19 @@ impl BigUint {\n     ///\n     /// The digits are be in base 2^32.\n     #[inline]\n-    pub fn new(v: Vec<BigDigit>) -> BigUint {\n+    pub fn new(mut digits: Vec<BigDigit>) -> BigUint {\n         // omit trailing zeros\n-        let new_len = v.iter().rposition(|n| *n != 0).map_or(0, |p| p + 1);\n-\n-        if new_len == v.len() { return BigUint { data: v }; }\n-        let mut v = v;\n-        v.truncate(new_len);\n-        return BigUint { data: v };\n+        let new_len = digits.iter().rposition(|n| *n != 0).map_or(0, |p| p + 1);\n+        digits.truncate(new_len);\n+        BigUint { data: digits }\n     }\n \n     /// Creates and initializes a `BigUint`.\n     ///\n     /// The digits are be in base 2^32.\n     #[inline]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n-        return BigUint::new(Vec::from_slice(slice));\n+        BigUint::new(Vec::from_slice(slice))\n     }\n \n     /// Creates and initializes a `BigUint`.\n@@ -768,7 +762,6 @@ impl BigUint {\n // `DoubleBigDigit` size dependent\n #[inline]\n fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n-    assert!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n         3  => (3486784401, 20),\n@@ -785,7 +778,7 @@ fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n         14 => (1475789056, 8),\n         15 => (2562890625, 8),\n         16 => (4294967296, 8),\n-        _  => fail!()\n+        _  => fail!(\"The radix must be within (1, 16]\")\n     }\n }\n \n@@ -815,7 +808,7 @@ pub struct BigInt {\n impl PartialEq for BigInt {\n     #[inline]\n     fn eq(&self, other: &BigInt) -> bool {\n-        match self.cmp(other) { Equal => true, _ => false }\n+        self.cmp(other) == Equal\n     }\n }\n \n@@ -824,7 +817,7 @@ impl Eq for BigInt {}\n impl PartialOrd for BigInt {\n     #[inline]\n     fn lt(&self, other: &BigInt) -> bool {\n-        match self.cmp(other) { Less => true, _ => false}\n+        self.cmp(other) == Less\n     }\n }\n \n@@ -844,7 +837,7 @@ impl Ord for BigInt {\n \n impl Default for BigInt {\n     #[inline]\n-    fn default() -> BigInt { BigInt::new(Zero, Vec::new()) }\n+    fn default() -> BigInt { Zero::zero() }\n }\n \n impl fmt::Show for BigInt {\n@@ -929,8 +922,7 @@ impl Add<BigInt, BigInt> for BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => other.clone(),\n             (_,    Zero)   => self.clone(),\n-            (Plus, Plus)   => BigInt::from_biguint(Plus,\n-                                                   self.data + other.data),\n+            (Plus, Plus)   => BigInt::from_biguint(Plus, self.data + other.data),\n             (Plus, Minus)  => self - (-*other),\n             (Minus, Plus)  => other - (-*self),\n             (Minus, Minus) => -((-self) + (-*other))\n@@ -975,15 +967,15 @@ impl Div<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn div(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.div_rem(other);\n-        return q;\n+        q\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.div_rem(other);\n-        return r;\n+        r\n     }\n }\n \n@@ -1045,13 +1037,13 @@ impl Integer for BigInt {\n     #[inline]\n     fn div_floor(&self, other: &BigInt) -> BigInt {\n         let (d, _) = self.div_mod_floor(other);\n-        return d;\n+        d\n     }\n \n     #[inline]\n     fn mod_floor(&self, other: &BigInt) -> BigInt {\n         let (_, m) = self.div_mod_floor(other);\n-        return m;\n+        m\n     }\n \n     fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n@@ -1265,7 +1257,7 @@ impl<R: Rng> RandBigInt for R {\n             let final_digit: BigDigit = self.gen();\n             data.push(final_digit >> (BigDigit::bits - rem));\n         }\n-        return BigUint::new(data);\n+        BigUint::new(data)\n     }\n \n     fn gen_bigint(&mut self, bit_size: uint) -> BigInt {\n@@ -1287,7 +1279,7 @@ impl<R: Rng> RandBigInt for R {\n         } else {\n             Minus\n         };\n-        return BigInt::from_biguint(sign, biguint);\n+        BigInt::from_biguint(sign, biguint)\n     }\n \n     fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint {\n@@ -1322,8 +1314,8 @@ impl BigInt {\n     ///\n     /// The digits are be in base 2^32.\n     #[inline]\n-    pub fn new(sign: Sign, v: Vec<BigDigit>) -> BigInt {\n-        BigInt::from_biguint(sign, BigUint::new(v))\n+    pub fn new(sign: Sign, digits: Vec<BigDigit>) -> BigInt {\n+        BigInt::from_biguint(sign, BigUint::new(digits))\n     }\n \n     /// Creates and initializes a `BigInt`.\n@@ -1334,7 +1326,7 @@ impl BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n         }\n-        return BigInt { sign: sign, data: data };\n+        BigInt { sign: sign, data: data }\n     }\n \n     /// Creates and initializes a `BigInt`.\n@@ -1344,8 +1336,7 @@ impl BigInt {\n     }\n \n     /// Creates and initializes a `BigInt`.\n-    pub fn parse_bytes(buf: &[u8], radix: uint)\n-        -> Option<BigInt> {\n+    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n         let mut sign  = Plus;\n         let mut start = 0;"}, {"sha": "d958d40d3d114c435179bb67e25741367bbe5d89", "filename": "src/libnum/integer.rs", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/5bf5cc605fd2732fa35b284a4401bfaa899dcae2/src%2Flibnum%2Finteger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bf5cc605fd2732fa35b284a4401bfaa899dcae2/src%2Flibnum%2Finteger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Finteger.rs?ref=5bf5cc605fd2732fa35b284a4401bfaa899dcae2", "patch": "@@ -0,0 +1,411 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Integer trait and functions\n+\n+pub trait Integer: Num + PartialOrd\n+                 + Div<Self, Self>\n+                 + Rem<Self, Self> {\n+    /// Simultaneous truncated integer division and modulus\n+    #[inline]\n+    fn div_rem(&self, other: &Self) -> (Self, Self) {\n+        (*self / *other, *self % *other)\n+    }\n+\n+    /// Floored integer division\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// # use num::Integer;\n+    /// assert!(( 8i).div_floor(& 3) ==  2);\n+    /// assert!(( 8i).div_floor(&-3) == -3);\n+    /// assert!((-8i).div_floor(& 3) == -3);\n+    /// assert!((-8i).div_floor(&-3) ==  2);\n+    ///\n+    /// assert!(( 1i).div_floor(& 2) ==  0);\n+    /// assert!(( 1i).div_floor(&-2) == -1);\n+    /// assert!((-1i).div_floor(& 2) == -1);\n+    /// assert!((-1i).div_floor(&-2) ==  0);\n+    /// ~~~\n+    fn div_floor(&self, other: &Self) -> Self;\n+\n+    /// Floored integer modulo, satisfying:\n+    ///\n+    /// ~~~\n+    /// # use num::Integer;\n+    /// # let n = 1i; let d = 1i;\n+    /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n+    /// ~~~\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// # use num::Integer;\n+    /// assert!(( 8i).mod_floor(& 3) ==  2);\n+    /// assert!(( 8i).mod_floor(&-3) == -1);\n+    /// assert!((-8i).mod_floor(& 3) ==  1);\n+    /// assert!((-8i).mod_floor(&-3) == -2);\n+    ///\n+    /// assert!(( 1i).mod_floor(& 2) ==  1);\n+    /// assert!(( 1i).mod_floor(&-2) == -1);\n+    /// assert!((-1i).mod_floor(& 2) ==  1);\n+    /// assert!((-1i).mod_floor(&-2) == -1);\n+    /// ~~~\n+    fn mod_floor(&self, other: &Self) -> Self;\n+\n+    /// Simultaneous floored integer division and modulus\n+    fn div_mod_floor(&self, other: &Self) -> (Self, Self) {\n+        (self.div_floor(other), self.mod_floor(other))\n+    }\n+\n+    /// Greatest Common Divisor (GCD)\n+    fn gcd(&self, other: &Self) -> Self;\n+\n+    /// Lowest Common Multiple (LCM)\n+    fn lcm(&self, other: &Self) -> Self;\n+\n+    /// Returns `true` if `other` divides evenly into `self`\n+    fn divides(&self, other: &Self) -> bool;\n+\n+    /// Returns `true` if the number is even\n+    fn is_even(&self) -> bool;\n+\n+    /// Returns `true` if the number is odd\n+    fn is_odd(&self) -> bool;\n+}\n+\n+/// Simultaneous integer division and modulus\n+#[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) { x.div_rem(&y) }\n+/// Floored integer division\n+#[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T { x.div_floor(&y) }\n+/// Floored integer modulus\n+#[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T { x.mod_floor(&y) }\n+/// Simultaneous floored integer division and modulus\n+#[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) { x.div_mod_floor(&y) }\n+\n+/// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\n+/// result is always positive.\n+#[inline(always)] pub fn gcd<T: Integer>(x: T, y: T) -> T { x.gcd(&y) }\n+/// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n+#[inline(always)] pub fn lcm<T: Integer>(x: T, y: T) -> T { x.lcm(&y) }\n+\n+macro_rules! impl_integer_for_int {\n+    ($T:ty, $test_mod:ident) => (\n+        impl Integer for $T {\n+            /// Floored integer division\n+            #[inline]\n+            fn div_floor(&self, other: &$T) -> $T {\n+                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+                match self.div_rem(other) {\n+                    (d, r) if (r > 0 && *other < 0)\n+                           || (r < 0 && *other > 0) => d - 1,\n+                    (d, _)                          => d,\n+                }\n+            }\n+\n+            /// Floored integer modulo\n+            #[inline]\n+            fn mod_floor(&self, other: &$T) -> $T {\n+                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+                match *self % *other {\n+                    r if (r > 0 && *other < 0)\n+                      || (r < 0 && *other > 0) => r + *other,\n+                    r                          => r,\n+                }\n+            }\n+\n+            /// Calculates `div_floor` and `mod_floor` simultaneously\n+            #[inline]\n+            fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n+                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+                match self.div_rem(other) {\n+                    (d, r) if (r > 0 && *other < 0)\n+                           || (r < 0 && *other > 0) => (d - 1, r + *other),\n+                    (d, r)                          => (d, r),\n+                }\n+            }\n+\n+            /// Calculates the Greatest Common Divisor (GCD) of the number and\n+            /// `other`. The result is always positive.\n+            #[inline]\n+            fn gcd(&self, other: &$T) -> $T {\n+                // Use Euclid's algorithm\n+                let mut m = *self;\n+                let mut n = *other;\n+                while m != 0 {\n+                    let temp = m;\n+                    m = n % temp;\n+                    n = temp;\n+                }\n+                n.abs()\n+            }\n+\n+            /// Calculates the Lowest Common Multiple (LCM) of the number and\n+            /// `other`.\n+            #[inline]\n+            fn lcm(&self, other: &$T) -> $T {\n+                // should not have to recalculate abs\n+                ((*self * *other) / self.gcd(other)).abs()\n+            }\n+\n+            /// Returns `true` if the number can be divided by `other` without\n+            /// leaving a remainder\n+            #[inline]\n+            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n+\n+            /// Returns `true` if the number is divisible by `2`\n+            #[inline]\n+            fn is_even(&self) -> bool { self & 1 == 0 }\n+\n+            /// Returns `true` if the number is not divisible by `2`\n+            #[inline]\n+            fn is_odd(&self) -> bool { !self.is_even() }\n+        }\n+\n+        #[cfg(test)]\n+        mod $test_mod {\n+            use Integer;\n+\n+            /// Checks that the division rule holds for:\n+            ///\n+            /// - `n`: numerator (dividend)\n+            /// - `d`: denominator (divisor)\n+            /// - `qr`: quotient and remainder\n+            #[cfg(test)]\n+            fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) {\n+                assert_eq!(d * q + r, n);\n+            }\n+\n+            #[test]\n+            fn test_div_rem() {\n+                fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) {\n+                    let (n,d) = nd;\n+                    let separate_div_rem = (n / d, n % d);\n+                    let combined_div_rem = n.div_rem(&d);\n+\n+                    assert_eq!(separate_div_rem, qr);\n+                    assert_eq!(combined_div_rem, qr);\n+\n+                    test_division_rule(nd, separate_div_rem);\n+                    test_division_rule(nd, combined_div_rem);\n+                }\n+\n+                test_nd_dr(( 8,  3), ( 2,  2));\n+                test_nd_dr(( 8, -3), (-2,  2));\n+                test_nd_dr((-8,  3), (-2, -2));\n+                test_nd_dr((-8, -3), ( 2, -2));\n+\n+                test_nd_dr(( 1,  2), ( 0,  1));\n+                test_nd_dr(( 1, -2), ( 0,  1));\n+                test_nd_dr((-1,  2), ( 0, -1));\n+                test_nd_dr((-1, -2), ( 0, -1));\n+            }\n+\n+            #[test]\n+            fn test_div_mod_floor() {\n+                fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) {\n+                    let (n,d) = nd;\n+                    let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n+                    let combined_div_mod_floor = n.div_mod_floor(&d);\n+\n+                    assert_eq!(separate_div_mod_floor, dm);\n+                    assert_eq!(combined_div_mod_floor, dm);\n+\n+                    test_division_rule(nd, separate_div_mod_floor);\n+                    test_division_rule(nd, combined_div_mod_floor);\n+                }\n+\n+                test_nd_dm(( 8,  3), ( 2,  2));\n+                test_nd_dm(( 8, -3), (-3, -1));\n+                test_nd_dm((-8,  3), (-3,  1));\n+                test_nd_dm((-8, -3), ( 2, -2));\n+\n+                test_nd_dm(( 1,  2), ( 0,  1));\n+                test_nd_dm(( 1, -2), (-1, -1));\n+                test_nd_dm((-1,  2), (-1,  1));\n+                test_nd_dm((-1, -2), ( 0, -1));\n+            }\n+\n+            #[test]\n+            fn test_gcd() {\n+                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n+                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n+                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n+                assert_eq!((3 as $T).gcd(&-3), 3 as $T);\n+                assert_eq!((-6 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((-4 as $T).gcd(&-2), 2 as $T);\n+            }\n+\n+            #[test]\n+            fn test_lcm() {\n+                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n+                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n+                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n+                assert_eq!((-1 as $T).lcm(&1), 1 as $T);\n+                assert_eq!((1 as $T).lcm(&-1), 1 as $T);\n+                assert_eq!((-1 as $T).lcm(&-1), 1 as $T);\n+                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n+                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n+            }\n+\n+            #[test]\n+            fn test_even() {\n+                assert_eq!((-4 as $T).is_even(), true);\n+                assert_eq!((-3 as $T).is_even(), false);\n+                assert_eq!((-2 as $T).is_even(), true);\n+                assert_eq!((-1 as $T).is_even(), false);\n+                assert_eq!((0 as $T).is_even(), true);\n+                assert_eq!((1 as $T).is_even(), false);\n+                assert_eq!((2 as $T).is_even(), true);\n+                assert_eq!((3 as $T).is_even(), false);\n+                assert_eq!((4 as $T).is_even(), true);\n+            }\n+\n+            #[test]\n+            fn test_odd() {\n+                assert_eq!((-4 as $T).is_odd(), false);\n+                assert_eq!((-3 as $T).is_odd(), true);\n+                assert_eq!((-2 as $T).is_odd(), false);\n+                assert_eq!((-1 as $T).is_odd(), true);\n+                assert_eq!((0 as $T).is_odd(), false);\n+                assert_eq!((1 as $T).is_odd(), true);\n+                assert_eq!((2 as $T).is_odd(), false);\n+                assert_eq!((3 as $T).is_odd(), true);\n+                assert_eq!((4 as $T).is_odd(), false);\n+            }\n+        }\n+    )\n+}\n+\n+impl_integer_for_int!(i8,   test_integer_i8)\n+impl_integer_for_int!(i16,  test_integer_i16)\n+impl_integer_for_int!(i32,  test_integer_i32)\n+impl_integer_for_int!(i64,  test_integer_i64)\n+impl_integer_for_int!(int,  test_integer_int)\n+\n+macro_rules! impl_integer_for_uint {\n+    ($T:ty, $test_mod:ident) => (\n+        impl Integer for $T {\n+            /// Unsigned integer division. Returns the same result as `div` (`/`).\n+            #[inline]\n+            fn div_floor(&self, other: &$T) -> $T { *self / *other }\n+\n+            /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n+            #[inline]\n+            fn mod_floor(&self, other: &$T) -> $T { *self % *other }\n+\n+            /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+            #[inline]\n+            fn gcd(&self, other: &$T) -> $T {\n+                // Use Euclid's algorithm\n+                let mut m = *self;\n+                let mut n = *other;\n+                while m != 0 {\n+                    let temp = m;\n+                    m = n % temp;\n+                    n = temp;\n+                }\n+                n\n+            }\n+\n+            /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+            #[inline]\n+            fn lcm(&self, other: &$T) -> $T {\n+                (*self * *other) / self.gcd(other)\n+            }\n+\n+            /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+            #[inline]\n+            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n+\n+            /// Returns `true` if the number is divisible by `2`\n+            #[inline]\n+            fn is_even(&self) -> bool { self & 1 == 0 }\n+\n+            /// Returns `true` if the number is not divisible by `2`\n+            #[inline]\n+            fn is_odd(&self) -> bool { !self.is_even() }\n+        }\n+\n+        #[cfg(test)]\n+        mod $test_mod {\n+            use Integer;\n+\n+            #[test]\n+            fn test_div_mod_floor() {\n+                assert_eq!((10 as $T).div_floor(&(3 as $T)), 3 as $T);\n+                assert_eq!((10 as $T).mod_floor(&(3 as $T)), 1 as $T);\n+                assert_eq!((10 as $T).div_mod_floor(&(3 as $T)), (3 as $T, 1 as $T));\n+                assert_eq!((5 as $T).div_floor(&(5 as $T)), 1 as $T);\n+                assert_eq!((5 as $T).mod_floor(&(5 as $T)), 0 as $T);\n+                assert_eq!((5 as $T).div_mod_floor(&(5 as $T)), (1 as $T, 0 as $T));\n+                assert_eq!((3 as $T).div_floor(&(7 as $T)), 0 as $T);\n+                assert_eq!((3 as $T).mod_floor(&(7 as $T)), 3 as $T);\n+                assert_eq!((3 as $T).div_mod_floor(&(7 as $T)), (0 as $T, 3 as $T));\n+            }\n+\n+            #[test]\n+            fn test_gcd() {\n+                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n+                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n+                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n+                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n+            }\n+\n+            #[test]\n+            fn test_lcm() {\n+                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n+                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n+                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n+                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n+                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n+                assert_eq!((99 as $T).lcm(&17), 1683 as $T);\n+            }\n+\n+            #[test]\n+            fn test_divides() {\n+                assert!((6 as $T).divides(&(6 as $T)));\n+                assert!((6 as $T).divides(&(3 as $T)));\n+                assert!((6 as $T).divides(&(1 as $T)));\n+            }\n+\n+            #[test]\n+            fn test_even() {\n+                assert_eq!((0 as $T).is_even(), true);\n+                assert_eq!((1 as $T).is_even(), false);\n+                assert_eq!((2 as $T).is_even(), true);\n+                assert_eq!((3 as $T).is_even(), false);\n+                assert_eq!((4 as $T).is_even(), true);\n+            }\n+\n+            #[test]\n+            fn test_odd() {\n+                assert_eq!((0 as $T).is_odd(), false);\n+                assert_eq!((1 as $T).is_odd(), true);\n+                assert_eq!((2 as $T).is_odd(), false);\n+                assert_eq!((3 as $T).is_odd(), true);\n+                assert_eq!((4 as $T).is_odd(), false);\n+            }\n+        }\n+    )\n+}\n+\n+impl_integer_for_uint!(u8,   test_integer_u8)\n+impl_integer_for_uint!(u16,  test_integer_u16)\n+impl_integer_for_uint!(u32,  test_integer_u32)\n+impl_integer_for_uint!(u64,  test_integer_u64)\n+impl_integer_for_uint!(uint, test_integer_uint)"}, {"sha": "709882c87cedb970b3be3f693517592507fefd77", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 7, "deletions": 401, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/5bf5cc605fd2732fa35b284a4401bfaa899dcae2/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bf5cc605fd2732fa35b284a4401bfaa899dcae2/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=5bf5cc605fd2732fa35b284a4401bfaa899dcae2", "patch": "@@ -57,406 +57,12 @@\n \n extern crate rand;\n \n+pub use bigint::{BigInt, BigUint};\n+pub use rational::{Rational, BigRational};\n+pub use complex::Complex;\n+pub use integer::Integer;\n+\n pub mod bigint;\n-pub mod rational;\n pub mod complex;\n-\n-pub trait Integer: Num + PartialOrd\n-                 + Div<Self, Self>\n-                 + Rem<Self, Self> {\n-    /// Simultaneous truncated integer division and modulus\n-    #[inline]\n-    fn div_rem(&self, other: &Self) -> (Self, Self) {\n-        (*self / *other, *self % *other)\n-    }\n-\n-    /// Floored integer division\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// # use num::Integer;\n-    /// assert!(( 8i).div_floor(& 3) ==  2);\n-    /// assert!(( 8i).div_floor(&-3) == -3);\n-    /// assert!((-8i).div_floor(& 3) == -3);\n-    /// assert!((-8i).div_floor(&-3) ==  2);\n-    ///\n-    /// assert!(( 1i).div_floor(& 2) ==  0);\n-    /// assert!(( 1i).div_floor(&-2) == -1);\n-    /// assert!((-1i).div_floor(& 2) == -1);\n-    /// assert!((-1i).div_floor(&-2) ==  0);\n-    /// ~~~\n-    fn div_floor(&self, other: &Self) -> Self;\n-\n-    /// Floored integer modulo, satisfying:\n-    ///\n-    /// ~~~\n-    /// # use num::Integer;\n-    /// # let n = 1i; let d = 1i;\n-    /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n-    /// ~~~\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// # use num::Integer;\n-    /// assert!(( 8i).mod_floor(& 3) ==  2);\n-    /// assert!(( 8i).mod_floor(&-3) == -1);\n-    /// assert!((-8i).mod_floor(& 3) ==  1);\n-    /// assert!((-8i).mod_floor(&-3) == -2);\n-    ///\n-    /// assert!(( 1i).mod_floor(& 2) ==  1);\n-    /// assert!(( 1i).mod_floor(&-2) == -1);\n-    /// assert!((-1i).mod_floor(& 2) ==  1);\n-    /// assert!((-1i).mod_floor(&-2) == -1);\n-    /// ~~~\n-    fn mod_floor(&self, other: &Self) -> Self;\n-\n-    /// Simultaneous floored integer division and modulus\n-    fn div_mod_floor(&self, other: &Self) -> (Self, Self) {\n-        (self.div_floor(other), self.mod_floor(other))\n-    }\n-\n-    /// Greatest Common Divisor (GCD)\n-    fn gcd(&self, other: &Self) -> Self;\n-\n-    /// Lowest Common Multiple (LCM)\n-    fn lcm(&self, other: &Self) -> Self;\n-\n-    /// Returns `true` if `other` divides evenly into `self`\n-    fn divides(&self, other: &Self) -> bool;\n-\n-    /// Returns `true` if the number is even\n-    fn is_even(&self) -> bool;\n-\n-    /// Returns `true` if the number is odd\n-    fn is_odd(&self) -> bool;\n-}\n-\n-/// Simultaneous integer division and modulus\n-#[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) { x.div_rem(&y) }\n-/// Floored integer division\n-#[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T { x.div_floor(&y) }\n-/// Floored integer modulus\n-#[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T { x.mod_floor(&y) }\n-/// Simultaneous floored integer division and modulus\n-#[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) { x.div_mod_floor(&y) }\n-\n-/// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\n-/// result is always positive.\n-#[inline(always)] pub fn gcd<T: Integer>(x: T, y: T) -> T { x.gcd(&y) }\n-/// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-#[inline(always)] pub fn lcm<T: Integer>(x: T, y: T) -> T { x.lcm(&y) }\n-\n-macro_rules! impl_integer_for_int {\n-    ($T:ty, $test_mod:ident) => (\n-        impl Integer for $T {\n-            /// Floored integer division\n-            #[inline]\n-            fn div_floor(&self, other: &$T) -> $T {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match self.div_rem(other) {\n-                    (d, r) if (r > 0 && *other < 0)\n-                           || (r < 0 && *other > 0) => d - 1,\n-                    (d, _)                          => d,\n-                }\n-            }\n-\n-            /// Floored integer modulo\n-            #[inline]\n-            fn mod_floor(&self, other: &$T) -> $T {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match *self % *other {\n-                    r if (r > 0 && *other < 0)\n-                      || (r < 0 && *other > 0) => r + *other,\n-                    r                          => r,\n-                }\n-            }\n-\n-            /// Calculates `div_floor` and `mod_floor` simultaneously\n-            #[inline]\n-            fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match self.div_rem(other) {\n-                    (d, r) if (r > 0 && *other < 0)\n-                           || (r < 0 && *other > 0) => (d - 1, r + *other),\n-                    (d, r)                          => (d, r),\n-                }\n-            }\n-\n-            /// Calculates the Greatest Common Divisor (GCD) of the number and\n-            /// `other`. The result is always positive.\n-            #[inline]\n-            fn gcd(&self, other: &$T) -> $T {\n-                // Use Euclid's algorithm\n-                let mut m = *self;\n-                let mut n = *other;\n-                while m != 0 {\n-                    let temp = m;\n-                    m = n % temp;\n-                    n = temp;\n-                }\n-                n.abs()\n-            }\n-\n-            /// Calculates the Lowest Common Multiple (LCM) of the number and\n-            /// `other`.\n-            #[inline]\n-            fn lcm(&self, other: &$T) -> $T {\n-                // should not have to recalculate abs\n-                ((*self * *other) / self.gcd(other)).abs()\n-            }\n-\n-            /// Returns `true` if the number can be divided by `other` without\n-            /// leaving a remainder\n-            #[inline]\n-            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-            /// Returns `true` if the number is divisible by `2`\n-            #[inline]\n-            fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-            /// Returns `true` if the number is not divisible by `2`\n-            #[inline]\n-            fn is_odd(&self) -> bool { !self.is_even() }\n-        }\n-\n-        #[cfg(test)]\n-        mod $test_mod {\n-            use Integer;\n-\n-            /// Checks that the division rule holds for:\n-            ///\n-            /// - `n`: numerator (dividend)\n-            /// - `d`: denominator (divisor)\n-            /// - `qr`: quotient and remainder\n-            #[cfg(test)]\n-            fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) {\n-                assert_eq!(d * q + r, n);\n-            }\n-\n-            #[test]\n-            fn test_div_rem() {\n-                fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) {\n-                    let (n,d) = nd;\n-                    let separate_div_rem = (n / d, n % d);\n-                    let combined_div_rem = n.div_rem(&d);\n-\n-                    assert_eq!(separate_div_rem, qr);\n-                    assert_eq!(combined_div_rem, qr);\n-\n-                    test_division_rule(nd, separate_div_rem);\n-                    test_division_rule(nd, combined_div_rem);\n-                }\n-\n-                test_nd_dr(( 8,  3), ( 2,  2));\n-                test_nd_dr(( 8, -3), (-2,  2));\n-                test_nd_dr((-8,  3), (-2, -2));\n-                test_nd_dr((-8, -3), ( 2, -2));\n-\n-                test_nd_dr(( 1,  2), ( 0,  1));\n-                test_nd_dr(( 1, -2), ( 0,  1));\n-                test_nd_dr((-1,  2), ( 0, -1));\n-                test_nd_dr((-1, -2), ( 0, -1));\n-            }\n-\n-            #[test]\n-            fn test_div_mod_floor() {\n-                fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) {\n-                    let (n,d) = nd;\n-                    let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n-                    let combined_div_mod_floor = n.div_mod_floor(&d);\n-\n-                    assert_eq!(separate_div_mod_floor, dm);\n-                    assert_eq!(combined_div_mod_floor, dm);\n-\n-                    test_division_rule(nd, separate_div_mod_floor);\n-                    test_division_rule(nd, combined_div_mod_floor);\n-                }\n-\n-                test_nd_dm(( 8,  3), ( 2,  2));\n-                test_nd_dm(( 8, -3), (-3, -1));\n-                test_nd_dm((-8,  3), (-3,  1));\n-                test_nd_dm((-8, -3), ( 2, -2));\n-\n-                test_nd_dm(( 1,  2), ( 0,  1));\n-                test_nd_dm(( 1, -2), (-1, -1));\n-                test_nd_dm((-1,  2), (-1,  1));\n-                test_nd_dm((-1, -2), ( 0, -1));\n-            }\n-\n-            #[test]\n-            fn test_gcd() {\n-                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-                assert_eq!((3 as $T).gcd(&-3), 3 as $T);\n-                assert_eq!((-6 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((-4 as $T).gcd(&-2), 2 as $T);\n-            }\n-\n-            #[test]\n-            fn test_lcm() {\n-                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((-1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((1 as $T).lcm(&-1), 1 as $T);\n-                assert_eq!((-1 as $T).lcm(&-1), 1 as $T);\n-                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-            }\n-\n-            #[test]\n-            fn test_even() {\n-                assert_eq!((-4 as $T).is_even(), true);\n-                assert_eq!((-3 as $T).is_even(), false);\n-                assert_eq!((-2 as $T).is_even(), true);\n-                assert_eq!((-1 as $T).is_even(), false);\n-                assert_eq!((0 as $T).is_even(), true);\n-                assert_eq!((1 as $T).is_even(), false);\n-                assert_eq!((2 as $T).is_even(), true);\n-                assert_eq!((3 as $T).is_even(), false);\n-                assert_eq!((4 as $T).is_even(), true);\n-            }\n-\n-            #[test]\n-            fn test_odd() {\n-                assert_eq!((-4 as $T).is_odd(), false);\n-                assert_eq!((-3 as $T).is_odd(), true);\n-                assert_eq!((-2 as $T).is_odd(), false);\n-                assert_eq!((-1 as $T).is_odd(), true);\n-                assert_eq!((0 as $T).is_odd(), false);\n-                assert_eq!((1 as $T).is_odd(), true);\n-                assert_eq!((2 as $T).is_odd(), false);\n-                assert_eq!((3 as $T).is_odd(), true);\n-                assert_eq!((4 as $T).is_odd(), false);\n-            }\n-        }\n-    )\n-}\n-\n-impl_integer_for_int!(i8,   test_integer_i8)\n-impl_integer_for_int!(i16,  test_integer_i16)\n-impl_integer_for_int!(i32,  test_integer_i32)\n-impl_integer_for_int!(i64,  test_integer_i64)\n-impl_integer_for_int!(int,  test_integer_int)\n-\n-macro_rules! impl_integer_for_uint {\n-    ($T:ty, $test_mod:ident) => (\n-        impl Integer for $T {\n-            /// Unsigned integer division. Returns the same result as `div` (`/`).\n-            #[inline]\n-            fn div_floor(&self, other: &$T) -> $T { *self / *other }\n-\n-            /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n-            #[inline]\n-            fn mod_floor(&self, other: &$T) -> $T { *self % *other }\n-\n-            /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-            #[inline]\n-            fn gcd(&self, other: &$T) -> $T {\n-                // Use Euclid's algorithm\n-                let mut m = *self;\n-                let mut n = *other;\n-                while m != 0 {\n-                    let temp = m;\n-                    m = n % temp;\n-                    n = temp;\n-                }\n-                n\n-            }\n-\n-            /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n-            #[inline]\n-            fn lcm(&self, other: &$T) -> $T {\n-                (*self * *other) / self.gcd(other)\n-            }\n-\n-            /// Returns `true` if the number can be divided by `other` without leaving a remainder\n-            #[inline]\n-            fn divides(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-            /// Returns `true` if the number is divisible by `2`\n-            #[inline]\n-            fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-            /// Returns `true` if the number is not divisible by `2`\n-            #[inline]\n-            fn is_odd(&self) -> bool { !self.is_even() }\n-        }\n-\n-        #[cfg(test)]\n-        mod $test_mod {\n-            use Integer;\n-\n-            #[test]\n-            fn test_div_mod_floor() {\n-                assert_eq!((10 as $T).div_floor(&(3 as $T)), 3 as $T);\n-                assert_eq!((10 as $T).mod_floor(&(3 as $T)), 1 as $T);\n-                assert_eq!((10 as $T).div_mod_floor(&(3 as $T)), (3 as $T, 1 as $T));\n-                assert_eq!((5 as $T).div_floor(&(5 as $T)), 1 as $T);\n-                assert_eq!((5 as $T).mod_floor(&(5 as $T)), 0 as $T);\n-                assert_eq!((5 as $T).div_mod_floor(&(5 as $T)), (1 as $T, 0 as $T));\n-                assert_eq!((3 as $T).div_floor(&(7 as $T)), 0 as $T);\n-                assert_eq!((3 as $T).mod_floor(&(7 as $T)), 3 as $T);\n-                assert_eq!((3 as $T).div_mod_floor(&(7 as $T)), (0 as $T, 3 as $T));\n-            }\n-\n-            #[test]\n-            fn test_gcd() {\n-                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-            }\n-\n-            #[test]\n-            fn test_lcm() {\n-                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-                assert_eq!((99 as $T).lcm(&17), 1683 as $T);\n-            }\n-\n-            #[test]\n-            fn test_divides() {\n-                assert!((6 as $T).divides(&(6 as $T)));\n-                assert!((6 as $T).divides(&(3 as $T)));\n-                assert!((6 as $T).divides(&(1 as $T)));\n-            }\n-\n-            #[test]\n-            fn test_even() {\n-                assert_eq!((0 as $T).is_even(), true);\n-                assert_eq!((1 as $T).is_even(), false);\n-                assert_eq!((2 as $T).is_even(), true);\n-                assert_eq!((3 as $T).is_even(), false);\n-                assert_eq!((4 as $T).is_even(), true);\n-            }\n-\n-            #[test]\n-            fn test_odd() {\n-                assert_eq!((0 as $T).is_odd(), false);\n-                assert_eq!((1 as $T).is_odd(), true);\n-                assert_eq!((2 as $T).is_odd(), false);\n-                assert_eq!((3 as $T).is_odd(), true);\n-                assert_eq!((4 as $T).is_odd(), false);\n-            }\n-        }\n-    )\n-}\n-\n-impl_integer_for_uint!(u8,   test_integer_u8)\n-impl_integer_for_uint!(u16,  test_integer_u16)\n-impl_integer_for_uint!(u32,  test_integer_u32)\n-impl_integer_for_uint!(u64,  test_integer_u64)\n-impl_integer_for_uint!(uint, test_integer_uint)\n+pub mod integer;\n+pub mod rational;"}]}