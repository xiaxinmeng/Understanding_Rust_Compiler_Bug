{"sha": "3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZWIwMTEyZWYzMDdkNGQyODBkZGE4YWNhNGFhN2Q0YTM0ZWIzZjY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-11-03T04:52:00Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-11-03T04:52:00Z"}, "message": "Ignore whitespace tokens when re-computing spans in save_analysis", "tree": {"sha": "d891f1afdb8c2e0ccc35dba7425486fbaa625980", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d891f1afdb8c2e0ccc35dba7425486fbaa625980"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6", "html_url": "https://github.com/rust-lang/rust/commit/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcc5c3b31b294a19c369e7b1926528610230686d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcc5c3b31b294a19c369e7b1926528610230686d", "html_url": "https://github.com/rust-lang/rust/commit/dcc5c3b31b294a19c369e7b1926528610230686d"}], "stats": {"total": 58, "additions": 29, "deletions": 29}, "files": [{"sha": "44cad45519029a94e236f1457aa4d6c25f7771f4", "filename": "src/librustc/middle/save/span_utils.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs?ref=3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6", "patch": "@@ -92,7 +92,7 @@ impl<'a> SpanUtils<'a> {\n         let mut toks = self.retokenise_span(span);\n         let mut bracket_count = 0u;\n         loop {\n-            let ts = toks.next_token();\n+            let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 return self.make_sub_span(span, result)\n             }\n@@ -115,7 +115,7 @@ impl<'a> SpanUtils<'a> {\n         let mut toks = self.retokenise_span(span);\n         let mut bracket_count = 0u;\n         loop {\n-            let ts = toks.next_token();\n+            let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 return None;\n             }\n@@ -137,13 +137,13 @@ impl<'a> SpanUtils<'a> {\n     // any brackets, or the last span.\n     pub fn sub_span_for_meth_name(&self, span: Span) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.next_token();\n+        let mut prev = toks.real_token();\n         let mut result = None;\n         let mut bracket_count = 0u;\n         let mut last_span = None;\n         while prev.tok != token::Eof {\n             last_span = None;\n-            let mut next = toks.next_token();\n+            let mut next = toks.real_token();\n \n             if (next.tok == token::OpenDelim(token::Paren) ||\n                 next.tok == token::Lt) &&\n@@ -156,7 +156,7 @@ impl<'a> SpanUtils<'a> {\n                 next.tok == token::ModSep {\n                 let old = prev;\n                 prev = next;\n-                next = toks.next_token();\n+                next = toks.real_token();\n                 if next.tok == token::Lt &&\n                    old.tok.is_ident() {\n                     result = Some(old.sp);\n@@ -185,11 +185,11 @@ impl<'a> SpanUtils<'a> {\n     // brackets, or the last span.\n     pub fn sub_span_for_type_name(&self, span: Span) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.next_token();\n+        let mut prev = toks.real_token();\n         let mut result = None;\n         let mut bracket_count = 0u;\n         loop {\n-            let next = toks.next_token();\n+            let next = toks.real_token();\n \n             if (next.tok == token::Lt ||\n                 next.tok == token::Colon) &&\n@@ -234,7 +234,7 @@ impl<'a> SpanUtils<'a> {\n         // We keep track of how many brackets we're nested in\n         let mut bracket_count = 0i;\n         loop {\n-            let ts = toks.next_token();\n+            let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 if bracket_count != 0 {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n@@ -263,12 +263,12 @@ impl<'a> SpanUtils<'a> {\n \n     pub fn sub_span_before_token(&self, span: Span, tok: Token) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.next_token();\n+        let mut prev = toks.real_token();\n         loop {\n             if prev.tok == token::Eof {\n                 return None;\n             }\n-            let next = toks.next_token();\n+            let next = toks.real_token();\n             if next.tok == tok {\n                 return self.make_sub_span(span, Some(prev.sp));\n             }\n@@ -281,15 +281,16 @@ impl<'a> SpanUtils<'a> {\n                               keyword: keywords::Keyword) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n-            let ts = toks.next_token();\n+            let ts = toks.real_token();\n             if ts.tok == token::Eof {\n                 return None;\n             }\n             if ts.tok.is_keyword(keyword) {\n-                let ts = toks.next_token();\n+                let ts = toks.real_token();\n                 if ts.tok == token::Eof {\n                     return None\n                 } else {\n+                    println!(\"found keyword: {} at {}\", ts, ts.sp);\n                     return self.make_sub_span(span, Some(ts.sp));\n                 }\n             }"}, {"sha": "1bc1d42d888ddf1779f6e821e6b8b8797caf1a3e", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6", "patch": "@@ -35,6 +35,19 @@ pub trait Reader {\n     /// Report a non-fatal error with the current span.\n     fn err(&self, &str);\n     fn peek(&self) -> TokenAndSpan;\n+    /// Get a token the parser cares about.\n+    fn real_token(&mut self) -> TokenAndSpan {\n+        let mut t = self.next_token();\n+        loop {\n+            match t.tok {\n+                token::Whitespace | token::Comment | token::Shebang(_) => {\n+                    t = self.next_token();\n+                },\n+                _ => break\n+            }\n+        }\n+        t\n+    }\n }\n \n #[deriving(Clone, PartialEq, Eq, Show)]"}, {"sha": "e3157d7ac755a174a744f8bae9f29a08195f13cb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3ceb0112ef307d4d280dda8aca4aa7d4a34eb3f6", "patch": "@@ -338,27 +338,13 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n     t.is_plain_ident() || *t == token::Underscore\n }\n \n-/// Get a token the parser cares about\n-fn real_token(rdr: &mut Reader) -> TokenAndSpan {\n-    let mut t = rdr.next_token();\n-    loop {\n-        match t.tok {\n-            token::Whitespace | token::Comment | token::Shebang(_) => {\n-                t = rdr.next_token();\n-            },\n-            _ => break\n-        }\n-    }\n-    t\n-}\n-\n impl<'a> Parser<'a> {\n     pub fn new(sess: &'a ParseSess,\n                cfg: ast::CrateConfig,\n                mut rdr: Box<Reader+'a>)\n                -> Parser<'a>\n     {\n-        let tok0 = real_token(&mut *rdr);\n+        let tok0 = rdr.real_token();\n         let span = tok0.sp;\n         let placeholder = TokenAndSpan {\n             tok: token::Underscore,\n@@ -898,7 +884,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n         let next = if self.buffer_start == self.buffer_end {\n-            real_token(&mut *self.reader)\n+            self.reader.real_token()\n         } else {\n             // Avoid token copies with `replace`.\n             let buffer_start = self.buffer_start as uint;\n@@ -942,7 +928,7 @@ impl<'a> Parser<'a> {\n                       -> R {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n-            self.buffer[self.buffer_end as uint] = real_token(&mut *self.reader);\n+            self.buffer[self.buffer_end as uint] = self.reader.real_token();\n             self.buffer_end = (self.buffer_end + 1) & 3;\n         }\n         f(&self.buffer[((self.buffer_start + dist - 1) & 3) as uint].tok)"}]}