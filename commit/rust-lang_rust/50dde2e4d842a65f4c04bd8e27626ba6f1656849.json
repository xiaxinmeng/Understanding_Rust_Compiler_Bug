{"sha": "50dde2e4d842a65f4c04bd8e27626ba6f1656849", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZGRlMmU0ZDg0MmE2NWY0YzA0YmQ4ZTI3NjI2YmE2ZjE2NTY4NDk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-08T20:52:40Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-22T07:18:29Z"}, "message": "Normalize when finding trait object candidates", "tree": {"sha": "49a7e320d0363ea2a2f875b7efce509945792458", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49a7e320d0363ea2a2f875b7efce509945792458"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50dde2e4d842a65f4c04bd8e27626ba6f1656849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50dde2e4d842a65f4c04bd8e27626ba6f1656849", "html_url": "https://github.com/rust-lang/rust/commit/50dde2e4d842a65f4c04bd8e27626ba6f1656849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50dde2e4d842a65f4c04bd8e27626ba6f1656849/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c43a649313a2a9d03923598c6a5b260624e8f66", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c43a649313a2a9d03923598c6a5b260624e8f66", "html_url": "https://github.com/rust-lang/rust/commit/6c43a649313a2a9d03923598c6a5b260624e8f66"}], "stats": {"total": 173, "additions": 107, "deletions": 66}, "files": [{"sha": "c570ad3273d4e3dcbd81c12911dd908c53b93ed6", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50dde2e4d842a65f4c04bd8e27626ba6f1656849/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50dde2e4d842a65f4c04bd8e27626ba6f1656849/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=50dde2e4d842a65f4c04bd8e27626ba6f1656849", "patch": "@@ -127,7 +127,10 @@ pub enum SelectionCandidate<'tcx> {\n \n     TraitAliasCandidate(DefId),\n \n-    ObjectCandidate,\n+    /// Matching `dyn Trait` with a supertrait of `Trait`. The index is the\n+    /// position in the iterator returned by\n+    /// `rustc_infer::traits::util::supertraits`.\n+    ObjectCandidate(usize),\n \n     BuiltinObjectCandidate,\n "}, {"sha": "b0bfb4ad173719c791a3f228f87997aac1c11a50", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/50dde2e4d842a65f4c04bd8e27626ba6f1656849/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50dde2e4d842a65f4c04bd8e27626ba6f1656849/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=50dde2e4d842a65f4c04bd8e27626ba6f1656849", "patch": "@@ -642,24 +642,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             debug!(?poly_trait_ref, \"assemble_candidates_from_object_ty\");\n \n+            let poly_trait_predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n+            let placeholder_trait_predicate =\n+                self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n+\n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the\n             // correct trait, but also the correct type parameters.\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n             // but `Foo` is declared as `trait Foo: Bar<u32>`.\n-            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n-                .filter(|upcast_trait_ref| {\n-                    self.infcx\n-                        .probe(|_| self.match_poly_trait_ref(obligation, *upcast_trait_ref).is_ok())\n+            let candidate_supertraits = util::supertraits(self.tcx(), poly_trait_ref)\n+                .enumerate()\n+                .filter(|&(_, upcast_trait_ref)| {\n+                    self.infcx.probe(|_| {\n+                        self.match_normalize_trait_ref(\n+                            obligation,\n+                            upcast_trait_ref,\n+                            placeholder_trait_predicate.trait_ref,\n+                        )\n+                        .is_ok()\n+                    })\n                 })\n-                .count();\n+                .map(|(idx, _)| ObjectCandidate(idx));\n \n-            if upcast_trait_refs > 1 {\n-                // Can be upcast in many ways; need more type information.\n-                candidates.ambiguous = true;\n-            } else if upcast_trait_refs == 1 {\n-                candidates.vec.push(ObjectCandidate);\n-            }\n+            candidates.vec.extend(candidate_supertraits);\n         })\n     }\n "}, {"sha": "872b8e85f563fa1bbcd191b1628298a91159ef13", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/50dde2e4d842a65f4c04bd8e27626ba6f1656849/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50dde2e4d842a65f4c04bd8e27626ba6f1656849/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=50dde2e4d842a65f4c04bd8e27626ba6f1656849", "patch": "@@ -73,6 +73,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(ImplSource::Param(obligations))\n             }\n \n+            ObjectCandidate(idx) => {\n+                let data = self.confirm_object_candidate(obligation, idx)?;\n+                Ok(ImplSource::Object(data))\n+            }\n+\n             ClosureCandidate => {\n                 let vtable_closure = self.confirm_closure_candidate(obligation)?;\n                 Ok(ImplSource::Closure(vtable_closure))\n@@ -97,11 +102,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(ImplSource::TraitAlias(data))\n             }\n \n-            ObjectCandidate => {\n-                let data = self.confirm_object_candidate(obligation);\n-                Ok(ImplSource::Object(data))\n-            }\n-\n             BuiltinObjectCandidate => {\n                 // This indicates something like `Trait + Send: Send`. In this case, we know that\n                 // this holds because that's what the object type is telling us, and there's really\n@@ -365,9 +365,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_object_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> ImplSourceObjectData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(?obligation, \"confirm_object_candidate\");\n+        index: usize,\n+    ) -> Result<ImplSourceObjectData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let tcx = self.tcx();\n+        debug!(?obligation, ?index, \"confirm_object_candidate\");\n \n         let trait_predicate =\n             self.infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n@@ -393,43 +394,39 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n             .with_self_ty(self.tcx(), self_ty);\n \n-        let mut upcast_trait_ref = None;\n         let mut nested = vec![];\n-        let vtable_base;\n \n-        {\n-            // We want to find the first supertrait in the list of\n-            // supertraits that we can unify with, and do that\n-            // unification. We know that there is exactly one in the list\n-            // where we can unify, because otherwise select would have\n-            // reported an ambiguity. (When we do find a match, also\n-            // record it for later.)\n-            let nonmatching = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref))\n-                .take_while(|&t| {\n-                    match self.infcx.commit_if_ok(|_| {\n-                        self.infcx\n-                            .at(&obligation.cause, obligation.param_env)\n-                            .sup(obligation_trait_ref, t)\n-                            .map(|InferOk { obligations, .. }| obligations)\n-                            .map_err(|_| ())\n-                    }) {\n-                        Ok(obligations) => {\n-                            upcast_trait_ref = Some(t);\n-                            nested.extend(obligations);\n-                            false\n-                        }\n-                        Err(_) => true,\n-                    }\n-                });\n+        let mut supertraits = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref));\n \n-            // Additionally, for each of the non-matching predicates that\n-            // we pass over, we sum up the set of number of vtable\n-            // entries, so that we can compute the offset for the selected\n-            // trait.\n-            vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n-        }\n+        // For each of the non-matching predicates that\n+        // we pass over, we sum up the set of number of vtable\n+        // entries, so that we can compute the offset for the selected\n+        // trait.\n+        let vtable_base = supertraits\n+            .by_ref()\n+            .take(index)\n+            .map(|t| super::util::count_own_vtable_entries(tcx, t))\n+            .sum();\n+\n+        let unnormalized_upcast_trait_ref =\n+            supertraits.next().expect(\"supertraits iterator no longer has as many elements\");\n+\n+        let upcast_trait_ref = normalize_with_depth_to(\n+            self,\n+            obligation.param_env,\n+            obligation.cause.clone(),\n+            obligation.recursion_depth + 1,\n+            &unnormalized_upcast_trait_ref,\n+            &mut nested,\n+        );\n \n-        let upcast_trait_ref = upcast_trait_ref.unwrap();\n+        nested.extend(self.infcx.commit_if_ok(|_| {\n+            self.infcx\n+                .at(&obligation.cause, obligation.param_env)\n+                .sup(obligation_trait_ref, upcast_trait_ref)\n+                .map(|InferOk { obligations, .. }| obligations)\n+                .map_err(|_| Unimplemented)\n+        })?);\n \n         // Check supertraits hold. This is so that their associated type bounds\n         // will be checked in the code below.\n@@ -495,7 +492,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         debug!(?nested, \"object nested obligations\");\n-        ImplSourceObjectData { upcast_trait_ref, vtable_base, nested }\n+        Ok(ImplSourceObjectData { upcast_trait_ref, vtable_base, nested })\n     }\n \n     fn confirm_fn_pointer_candidate("}, {"sha": "4cc4bc0acdab68923116058b5c4b1b15ccb9af6c", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/50dde2e4d842a65f4c04bd8e27626ba6f1656849/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50dde2e4d842a65f4c04bd8e27626ba6f1656849/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=50dde2e4d842a65f4c04bd8e27626ba6f1656849", "patch": "@@ -1174,7 +1174,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n                     let bound = bound_predicate.rebind(pred.trait_ref);\n                     if self.infcx.probe(|_| {\n-                        match self.match_projection(\n+                        match self.match_normalize_trait_ref(\n                             obligation,\n                             bound,\n                             placeholder_trait_predicate.trait_ref,\n@@ -1202,7 +1202,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Equates the trait in `obligation` with trait bound. If the two traits\n     /// can be equated and the normalized trait bound doesn't contain inference\n     /// variables or placeholders, the normalized bound is returned.\n-    fn match_projection(\n+    fn match_normalize_trait_ref(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n@@ -1352,10 +1352,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..)\n-                | ObjectCandidate\n+                | ObjectCandidate(_)\n                 | ProjectionCandidate(_),\n             ) => !is_global(cand),\n-            (ObjectCandidate | ProjectionCandidate(_), ParamCandidate(ref cand)) => {\n+            (ObjectCandidate(_) | ProjectionCandidate(_), ParamCandidate(ref cand)) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n                 is_global(cand)\n@@ -1376,20 +1376,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 is_global(cand) && other.evaluation.must_apply_modulo_regions()\n             }\n \n-            (ProjectionCandidate(i), ProjectionCandidate(j)) => {\n+            (ProjectionCandidate(i), ProjectionCandidate(j))\n+            | (ObjectCandidate(i), ObjectCandidate(j)) => {\n                 // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n                 i < j && !needs_infer\n             }\n-            (ObjectCandidate, ObjectCandidate) => bug!(\"Duplicate object candidate\"),\n-            (ObjectCandidate, ProjectionCandidate(_))\n-            | (ProjectionCandidate(_), ObjectCandidate) => {\n+            (ObjectCandidate(_), ProjectionCandidate(_))\n+            | (ProjectionCandidate(_), ObjectCandidate(_)) => {\n                 bug!(\"Have both object and projection candidate\")\n             }\n \n             // Arbitrarily give projection and object candidates priority.\n             (\n-                ObjectCandidate | ProjectionCandidate(_),\n+                ObjectCandidate(_) | ProjectionCandidate(_),\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n@@ -1409,7 +1409,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..),\n-                ObjectCandidate | ProjectionCandidate(_),\n+                ObjectCandidate(_) | ProjectionCandidate(_),\n             ) => false,\n \n             (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n@@ -1885,9 +1885,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Normalize `where_clause_trait_ref` and try to match it against\n     /// `obligation`. If successful, return any predicates that\n-    /// result from the normalization. Normalization is necessary\n-    /// because where-clauses are stored in the parameter environment\n-    /// unnormalized.\n+    /// result from the normalization.\n     fn match_where_clause_trait_ref(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,"}, {"sha": "021a93eacff1f1caef3933149d34f0ce7e6f7994", "filename": "src/test/ui/traits/normalize-super-trait.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/50dde2e4d842a65f4c04bd8e27626ba6f1656849/src%2Ftest%2Fui%2Ftraits%2Fnormalize-super-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50dde2e4d842a65f4c04bd8e27626ba6f1656849/src%2Ftest%2Fui%2Ftraits%2Fnormalize-super-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnormalize-super-trait.rs?ref=50dde2e4d842a65f4c04bd8e27626ba6f1656849", "patch": "@@ -0,0 +1,37 @@\n+// Regression test for #77653\n+// When monomorphizing `f` we need to prove `dyn Derived<()>: Base<()>`. This\n+// requires us to normalize the `Base<<() as Proj>::S>` to `Base<()>` when\n+// comparing the supertrait `Derived<()>` to the expected trait.\n+\n+// build-pass\n+\n+trait Proj {\n+    type S;\n+}\n+\n+impl Proj for () {\n+    type S = ();\n+}\n+\n+impl Proj for i32 {\n+    type S = i32;\n+}\n+\n+trait Base<T> {\n+    fn is_base(&self);\n+}\n+\n+trait Derived<B: Proj>: Base<B::S> + Base<()> {\n+    fn is_derived(&self);\n+}\n+\n+fn f<P: Proj>(obj: &dyn Derived<P>) {\n+    obj.is_derived();\n+    Base::<P::S>::is_base(obj);\n+    Base::<()>::is_base(obj);\n+}\n+\n+fn main() {\n+    let x: fn(_) = f::<()>;\n+    let x: fn(_) = f::<i32>;\n+}"}]}