{"sha": "4e8855bdc9b419e0ab48d886c10128f93a9bf98d", "node_id": "C_kwDOAAsO6NoAKDRlODg1NWJkYzliNDE5ZTBhYjQ4ZDg4NmMxMDEyOGY5M2E5YmY5OGQ", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-06T04:23:01Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-06T06:57:17Z"}, "message": "rustc_metadata: Make `opt_item_ident` in decoder faster and stricter\n\nBy avoiding formatting and allocations in the no-ident case, and by making the span mandatory if the ident exists.\n\nUse the optimized `opt_item_ident` to cleanup `fn each_child_of_item`", "tree": {"sha": "8f43b2cd511765e905a9cac6b5949512e18cf940", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f43b2cd511765e905a9cac6b5949512e18cf940"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e8855bdc9b419e0ab48d886c10128f93a9bf98d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8855bdc9b419e0ab48d886c10128f93a9bf98d", "html_url": "https://github.com/rust-lang/rust/commit/4e8855bdc9b419e0ab48d886c10128f93a9bf98d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e8855bdc9b419e0ab48d886c10128f93a9bf98d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c6120c3864483a44f6e29fe5de22e5074ec25f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c6120c3864483a44f6e29fe5de22e5074ec25f5", "html_url": "https://github.com/rust-lang/rust/commit/4c6120c3864483a44f6e29fe5de22e5074ec25f5"}], "stats": {"total": 61, "additions": 25, "deletions": 36}, "files": [{"sha": "58397066a1254ca8ede369e1123fb5f3b77226fa", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4e8855bdc9b419e0ab48d886c10128f93a9bf98d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8855bdc9b419e0ab48d886c10128f93a9bf98d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=4e8855bdc9b419e0ab48d886c10128f93a9bf98d", "patch": "@@ -722,25 +722,24 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    fn try_item_ident(&self, item_index: DefIndex, sess: &Session) -> Result<Ident, String> {\n-        let name = self\n-            .def_key(item_index)\n-            .disambiguated_data\n-            .data\n-            .get_opt_name()\n-            .ok_or_else(|| format!(\"Missing opt name for {:?}\", item_index))?;\n-        let span = self\n-            .root\n-            .tables\n-            .ident_span\n-            .get(self, item_index)\n-            .ok_or_else(|| format!(\"Missing ident span for {:?} ({:?})\", name, item_index))?\n-            .decode((self, sess));\n-        Ok(Ident::new(name, span))\n+    fn opt_item_ident(&self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n+        let name = self.def_key(item_index).disambiguated_data.data.get_opt_name()?;\n+        let span = match self.root.tables.ident_span.get(self, item_index) {\n+            Some(lazy_span) => lazy_span.decode((self, sess)),\n+            None => {\n+                // FIXME: this weird case of a name with no span is specific to `extern crate`\n+                // items, which are supposed to be treated like `use` items and only be encoded\n+                // to metadata as `Export`s, return `None` because that's what all the callers\n+                // expect in this case.\n+                assert_eq!(self.def_kind(item_index), DefKind::ExternCrate);\n+                return None;\n+            }\n+        };\n+        Some(Ident::new(name, span))\n     }\n \n     fn item_ident(&self, item_index: DefIndex, sess: &Session) -> Ident {\n-        self.try_item_ident(item_index, sess).unwrap()\n+        self.opt_item_ident(item_index, sess).expect(\"no encoded ident for item\")\n     }\n \n     fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n@@ -1102,27 +1101,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         // Iterate over all children.\n         if let Some(children) = self.root.tables.children.get(self, id) {\n             for child_index in children.decode((self, sess)) {\n-                // FIXME: Merge with the logic below.\n-                if let None | Some(EntryKind::ForeignMod | EntryKind::Impl(_)) =\n-                    self.maybe_kind(child_index)\n-                {\n-                    continue;\n-                }\n-\n-                let def_key = self.def_key(child_index);\n-                if def_key.disambiguated_data.data.get_opt_name().is_some() {\n-                    let span = self.get_span(child_index, sess);\n+                if let Some(ident) = self.opt_item_ident(child_index, sess) {\n                     let kind = self.def_kind(child_index);\n-                    let ident = self.item_ident(child_index, sess);\n-                    let vis = self.get_visibility(child_index);\n+                    if matches!(kind, DefKind::Macro(..)) {\n+                        // FIXME: Macros are currently encoded twice, once as items and once as\n+                        // reexports. We ignore the items here and only use the reexports.\n+                        continue;\n+                    }\n                     let def_id = self.local_def_id(child_index);\n                     let res = Res::Def(kind, def_id);\n+                    let vis = self.get_visibility(child_index);\n+                    let span = self.get_span(child_index, sess);\n \n-                    // FIXME: Macros are currently encoded twice, once as items and once as\n-                    // reexports. We ignore the items here and only use the reexports.\n-                    if !matches!(kind, DefKind::Macro(..)) {\n-                        callback(Export { res, ident, vis, span });\n-                    }\n+                    callback(Export { ident, res, vis, span });\n \n                     // For non-re-export structs and variants add their constructors to children.\n                     // Re-export lists automatically contain constructors when necessary."}, {"sha": "f3666916d33a910f3407851e2d6efe817c2b6b1a", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8855bdc9b419e0ab48d886c10128f93a9bf98d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8855bdc9b419e0ab48d886c10128f93a9bf98d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=4e8855bdc9b419e0ab48d886c10128f93a9bf98d", "patch": "@@ -133,9 +133,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     generator_kind => { cdata.generator_kind(def_id.index) }\n     opt_def_kind => { Some(cdata.def_kind(def_id.index)) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n-    def_ident_span => {\n-        cdata.try_item_ident(def_id.index, &tcx.sess).ok().map(|ident| ident.span)\n-    }\n+    def_ident_span => { cdata.opt_item_ident(def_id.index, &tcx.sess).map(|ident| ident.span) }\n     lookup_stability => {\n         cdata.get_stability(def_id.index).map(|s| tcx.intern_stability(s))\n     }"}]}