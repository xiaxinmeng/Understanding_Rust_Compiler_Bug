{"sha": "4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMmIwOTgzMWJkNjdhZDUyOTU0ZDVjZmI0OGVhZTA2NmIzZDRjMDA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-10-11T21:12:21Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-10-11T21:12:59Z"}, "message": "Rust upgrade to rustc 1.5.0-nightly (9d3e79ad3 2015-10-10)", "tree": {"sha": "45304e50a4481d74ba36dbb1e524c36b0a5a9b21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45304e50a4481d74ba36dbb1e524c36b0a5a9b21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "html_url": "https://github.com/rust-lang/rust/commit/4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f84e3551bc3b236c4800a026620a790dff95c21", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f84e3551bc3b236c4800a026620a790dff95c21", "html_url": "https://github.com/rust-lang/rust/commit/6f84e3551bc3b236c4800a026620a790dff95c21"}], "stats": {"total": 188, "additions": 102, "deletions": 86}, "files": [{"sha": "6503c5e1006d45bb5335b36b1d4a4855f115abc5", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "patch": "@@ -75,7 +75,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box misc::ModuloOne);\n     reg.register_late_lint_pass(box unicode::Unicode);\n     reg.register_late_lint_pass(box strings::StringAdd);\n-    reg.register_late_lint_pass(box returns::ReturnPass);\n+    reg.register_early_lint_pass(box returns::ReturnPass);\n     reg.register_late_lint_pass(box methods::MethodsPass);\n     reg.register_late_lint_pass(box shadow::ShadowPass);\n     reg.register_late_lint_pass(box types::LetPass);"}, {"sha": "3df4efd0889da78940d0094897dbdeb72eb06333", "filename": "src/returns.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "patch": "@@ -1,10 +1,10 @@\n use rustc::lint::*;\n-use rustc_front::hir::*;\n-use reexport::*;\n+use syntax::ast::*;\n+//use reexport::*;\n use syntax::codemap::{Span, Spanned};\n-use rustc_front::visit::FnKind;\n+use syntax::visit::FnKind;\n \n-use utils::{span_lint, snippet, match_path, in_external_macro};\n+use utils::{span_lint, snippet, match_path_ast, in_external_macro};\n \n declare_lint!(pub NEEDLESS_RETURN, Warn,\n               \"using a return statement like `return expr;` where an expression would suffice\");\n@@ -17,7 +17,7 @@ pub struct ReturnPass;\n \n impl ReturnPass {\n     // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &LateContext, block: &Block) {\n+    fn check_block_return(&mut self, cx: &EarlyContext, block: &Block) {\n         if let Some(ref expr) = block.expr {\n             self.check_final_expr(cx, expr);\n         } else if let Some(stmt) = block.stmts.last() {\n@@ -30,7 +30,7 @@ impl ReturnPass {\n     }\n \n     // Check a the final expression in a block if it's a return.\n-    fn check_final_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_final_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         match expr.node {\n             // simple return is always \"bad\"\n             ExprRet(Some(ref inner)) => {\n@@ -48,7 +48,7 @@ impl ReturnPass {\n                 self.check_final_expr(cx, elsexpr);\n             }\n             // a match expr, check all arms\n-            ExprMatch(_, ref arms, _) => {\n+            ExprMatch(_, ref arms) => {\n                 for arm in arms {\n                     self.check_final_expr(cx, &arm.body);\n                 }\n@@ -57,7 +57,7 @@ impl ReturnPass {\n         }\n     }\n \n-    fn emit_return_lint(&mut self, cx: &LateContext, spans: (Span, Span)) {\n+    fn emit_return_lint(&mut self, cx: &EarlyContext, spans: (Span, Span)) {\n         if in_external_macro(cx, spans.1) {return;}\n         span_lint(cx, NEEDLESS_RETURN, spans.0, &format!(\n             \"unneeded return statement. Consider using `{}` \\\n@@ -66,7 +66,7 @@ impl ReturnPass {\n     }\n \n     // Check for \"let x = EXPR; x\"\n-    fn check_let_return(&mut self, cx: &LateContext, block: &Block) {\n+    fn check_let_return(&mut self, cx: &EarlyContext, block: &Block) {\n         // we need both a let-binding stmt and an expr\n         if_let_chain! {\n             [\n@@ -77,14 +77,14 @@ impl ReturnPass {\n                 let Some(ref initexpr) = local.init,\n                 let PatIdent(_, Spanned { node: id, .. }, _) = local.pat.node,\n                 let ExprPath(_, ref path) = retexpr.node,\n-                match_path(path, &[&id.name.as_str()])\n+                match_path_ast(path, &[&id.name.as_str()])\n             ], {\n                 self.emit_let_lint(cx, retexpr.span, initexpr.span);\n             }\n         }\n     }\n \n-    fn emit_let_lint(&mut self, cx: &LateContext, lint_span: Span, note_span: Span) {\n+    fn emit_let_lint(&mut self, cx: &EarlyContext, lint_span: Span, note_span: Span) {\n         if in_external_macro(cx, note_span) {return;}\n         span_lint(cx, LET_AND_RETURN, lint_span,\n                   \"returning the result of a let binding from a block. \\\n@@ -102,13 +102,13 @@ impl LintPass for ReturnPass {\n     }\n }\n \n-impl LateLintPass for ReturnPass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, _: &FnDecl,\n+impl EarlyLintPass for ReturnPass {\n+    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, _: &FnDecl,\n                 block: &Block, _: Span, _: NodeId) {\n         self.check_block_return(cx, block);\n     }\n \n-    fn check_block(&mut self, cx: &LateContext, block: &Block) {\n+    fn check_block(&mut self, cx: &EarlyContext, block: &Block) {\n         self.check_let_return(cx, block);\n     }\n }"}, {"sha": "13df95bf8ddb7e0a9ae8252496c1e7003434b15d", "filename": "src/shadow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "patch": "@@ -7,7 +7,7 @@ use rustc_front::visit::FnKind;\n use rustc::lint::*;\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n-use utils::{in_external_macro, snippet, span_lint, span_note_and_lint};\n+use utils::{is_from_for_desugar, in_external_macro, snippet, span_lint, span_note_and_lint};\n \n declare_lint!(pub SHADOW_SAME, Allow,\n     \"rebinding a name to itself, e.g. `let mut x = &mut x`\");\n@@ -60,6 +60,7 @@ fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>\n \n fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, decl.span) { return; }\n+    if is_from_for_desugar(decl) { return; }\n     if let DeclLocal(ref local) = decl.node {\n         let Local{ ref pat, ref ty, ref init, id: _, span } = **local;\n         if let &Some(ref t) = ty { check_ty(cx, t, bindings) }"}, {"sha": "584f9b349883385ae234c0e793afb657cc113fae", "filename": "src/types.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "patch": "@@ -9,7 +9,8 @@ use syntax::ast::IntTy::*;\n use syntax::ast::UintTy::*;\n use syntax::ast::FloatTy::*;\n \n-use utils::{match_type, snippet, span_lint, span_help_and_lint, in_macro, in_external_macro};\n+use utils::{match_type, snippet, span_lint, span_help_and_lint};\n+use utils::{is_from_for_desugar, in_macro, in_external_macro};\n use utils::{LL_PATH, VEC_PATH};\n \n /// Handles all the linting of funky types\n@@ -61,9 +62,10 @@ fn check_let_unit(cx: &LateContext, decl: &Decl) {\n         if *bindtype == ty::TyTuple(vec![]) {\n             if in_external_macro(cx, decl.span) ||\n                 in_macro(cx, local.pat.span) { return; }\n-            span_lint(cx, LET_UNIT_VALUE, decl.span, &format!(\n-                \"this let-binding has unit value. Consider omitting `let {} =`\",\n-                snippet(cx, local.pat.span, \"..\")));\n+                if is_from_for_desugar(decl) { return; }\n+                span_lint(cx, LET_UNIT_VALUE, decl.span, &format!(\n+                    \"this let-binding has unit value. Consider omitting `let {} =`\",\n+                    snippet(cx, local.pat.span, \"..\")));\n         }\n     }\n }"}, {"sha": "34a6d25af256e4779f02698484b2abd1ea1f0074", "filename": "src/utils.rs", "status": "modified", "additions": 76, "deletions": 63, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "patch": "@@ -7,6 +7,7 @@ use rustc::middle::def_id::DefId;\n use rustc::middle::ty;\n use std::borrow::Cow;\n use syntax::ast::Lit_::*;\n+use syntax::ast;\n \n // module DefPaths for certain structs/enums we check for\n pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n@@ -15,15 +16,56 @@ pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n \n+/// Produce a nested chain of if-lets and ifs from the patterns:\n+///\n+///     if_let_chain! {\n+///         [\n+///             Some(y) = x,\n+///             y.len() == 2,\n+///             Some(z) = y,\n+///         ],\n+///         {\n+///             block\n+///         }\n+///     }\n+///\n+/// becomes\n+///\n+///     if let Some(y) = x {\n+///         if y.len() == 2 {\n+///             if let Some(z) = y {\n+///                 block\n+///             }\n+///         }\n+///     }\n+#[macro_export]\n+macro_rules! if_let_chain {\n+    ([let $pat:pat = $expr:expr, $($tt:tt)+], $block:block) => {\n+        if let $pat = $expr {\n+           if_let_chain!{ [$($tt)+], $block }\n+        }\n+    };\n+    ([let $pat:pat = $expr:expr], $block:block) => {\n+        if let $pat = $expr {\n+           $block\n+        }\n+    };\n+    ([$expr:expr, $($tt:tt)+], $block:block) => {\n+        if $expr {\n+           if_let_chain!{ [$($tt)+], $block }\n+        }\n+    };\n+    ([$expr:expr], $block:block) => {\n+        if $expr {\n+           $block\n+        }\n+    };\n+}\n+\n /// returns true this expn_info was expanded by any macro\n pub fn in_macro(cx: &LateContext, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id,\n-            |info| info.map_or(false, |i| {\n-        match i.callee.format {\n-            ExpnFormat::CompilerExpansion(..) => false,\n-            _ => true,\n-        }\n-    }))\n+            |info| info.is_some())\n }\n \n /// returns true if the macro that expanded the crate was outside of\n@@ -34,17 +76,9 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n     fn in_macro_ext<T: LintContext>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n-            match info.callee.format {\n-                ExpnFormat::CompilerExpansion(..) => {\n-                    if info.callee.name().as_str() == \"closure expansion\" {\n-                        return false;\n-                    }\n-                },\n-                ExpnFormat::MacroAttribute(..) => {\n-                    // these are all plugins\n-                    return true;\n-                },\n-                _ => (),\n+            if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n+                // these are all plugins\n+                return true;\n             }\n             // no span for the callee = external macro\n             info.callee.span.map_or(true, |span| {\n@@ -102,6 +136,13 @@ pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n         |(a, b)| a.identifier.name.as_str() == *b)\n }\n \n+/// match a Path against a slice of segment string literals, e.g.\n+/// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n+pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(\n+        |(a, b)| a.identifier.name.as_str() == *b)\n+}\n+\n /// get the name of the item the expression is in, if available\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n@@ -115,6 +156,24 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     }\n }\n \n+/// checks if a `let` decl is from a for loop desugaring\n+pub fn is_from_for_desugar(decl: &Decl) -> bool {\n+    if_let_chain! {\n+        [\n+            let DeclLocal(ref loc) = decl.node,\n+            let Some(ref expr) = loc.init,\n+            // FIXME: This should check for MatchSource::ForLoop\n+            // but right now there's a bug where the match source isn't\n+            // set during lowering\n+            // https://github.com/rust-lang/rust/pull/28973\n+            let ExprMatch(_, _, _) = expr.node\n+        ],\n+        { return true; }\n+    };\n+    false\n+}\n+\n+\n /// convert a span to a code snippet if available, otherwise use default, e.g.\n /// `snippet(cx, expr.span, \"..\")`\n pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n@@ -262,49 +321,3 @@ pub fn is_integer_literal(expr: &Expr, value: u64) -> bool\n     }\n     false\n }\n-\n-/// Produce a nested chain of if-lets and ifs from the patterns:\n-///\n-///     if_let_chain! {\n-///         [\n-///             Some(y) = x,\n-///             y.len() == 2,\n-///             Some(z) = y,\n-///         ],\n-///         {\n-///             block\n-///         }\n-///     }\n-///\n-/// becomes\n-///\n-///     if let Some(y) = x {\n-///         if y.len() == 2 {\n-///             if let Some(z) = y {\n-///                 block\n-///             }\n-///         }\n-///     }\n-#[macro_export]\n-macro_rules! if_let_chain {\n-    ([let $pat:pat = $expr:expr, $($tt:tt)+], $block:block) => {\n-        if let $pat = $expr {\n-           if_let_chain!{ [$($tt)+], $block }\n-        }\n-    };\n-    ([let $pat:pat = $expr:expr], $block:block) => {\n-        if let $pat = $expr {\n-           $block\n-        }\n-    };\n-    ([$expr:expr, $($tt:tt)+], $block:block) => {\n-        if $expr {\n-           if_let_chain!{ [$($tt)+], $block }\n-        }\n-    };\n-    ([$expr:expr], $block:block) => {\n-        if $expr {\n-           $block\n-        }\n-    };\n-}"}, {"sha": "1ba8616ed29e2e9b564ca2b4afa99bb4df493c21", "filename": "tests/compile-fail/strings.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/tests%2Fcompile-fail%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2b09831bd67ad52954d5cfb48eae066b3d4c00/tests%2Fcompile-fail%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstrings.rs?ref=4e2b09831bd67ad52954d5cfb48eae066b3d4c00", "patch": "@@ -6,7 +6,7 @@\n fn add_only() { // ignores assignment distinction\n     let mut x = \"\".to_owned();\n \n-    for _ in (1..3) {\n+    for _ in 1..3 {\n         x = x + \".\"; //~ERROR you added something to a string.\n     }\n \n@@ -20,7 +20,7 @@ fn add_only() { // ignores assignment distinction\n fn add_assign_only() {\n     let mut x = \"\".to_owned();\n \n-    for _ in (1..3) {\n+    for _ in 1..3 {\n         x = x + \".\"; //~ERROR you assigned the result of adding something to this string.\n     }\n \n@@ -34,7 +34,7 @@ fn add_assign_only() {\n fn both() {\n     let mut x = \"\".to_owned();\n \n-    for _ in (1..3) {\n+    for _ in 1..3 {\n         x = x + \".\"; //~ERROR you assigned the result of adding something to this string.\n     }\n "}]}