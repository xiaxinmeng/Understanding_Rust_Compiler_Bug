{"sha": "4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "node_id": "C_kwDOAAsO6NoAKDRiZDMzZmRiNGE0MGU4MmNmODU3MmNhNjhhMTNlMWUyZmJlZjYwZjM", "commit": {"author": {"name": "nils", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-03-28T10:51:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-28T10:51:12Z"}, "message": "Rollup merge of #102472 - lcnr:static-in-eval, r=jackh726\n\nstop special-casing `'static` in evaluation\n\nfixes #102360\n\nI have no idea whether this actually removed all places where `'static` matters. Without canonicalization it's very easy to accidentally rely on `'static` again. Blocked on changing the `order_dependent_trait_objects` future-compat lint to a hard error\n\nr? `@nikomatsakis`", "tree": {"sha": "bb7ed259508c36c12a72d546fb52e67f93cf8497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb7ed259508c36c12a72d546fb52e67f93cf8497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkIsagCRBK7hj4Ov3rIwAA/aMIAJven+MbHyJBqdmZXMxlmxf3\n6aZSNMA2QoTDdZNc3s21CUs0pGIhEqxdnSZ5UKswRw59RLZy5NsEltYlnZunhEIj\n1CnfpsqFtTFlAqAlR5ChYp+hm1rSpXB3Ijp+2gdvNkkEDRM5VOd14uGDIXlxfRWG\nXZhHz7lN0rZG0UuQzgiN/9MvYwdSZyQheAwB7hR6a7snMxsJjFAzCeWSfSJkl38C\nxkaYcWWsKRYU0Yi9x9vPqkRfywaO9+Ec/tdYvKXnAO0UZplGXOT4Ouk8ndrcYO92\npA+DyXON7S6EWtHm2OVQcVM+DP4aw9ZtYZOpdItA6VJnsR9rveF0JHpjya6wJDU=\n=4xZc\n-----END PGP SIGNATURE-----\n", "payload": "tree bb7ed259508c36c12a72d546fb52e67f93cf8497\nparent 0883848882483e216714d5be5a1fde87dd5a1690\nparent 73c79cd80631bf4cb4a20914d02aa08d0f80ba7f\nauthor nils <48135649+Nilstrieb@users.noreply.github.com> 1680000672 +0200\ncommitter GitHub <noreply@github.com> 1680000672 +0200\n\nRollup merge of #102472 - lcnr:static-in-eval, r=jackh726\n\nstop special-casing `'static` in evaluation\n\nfixes #102360\n\nI have no idea whether this actually removed all places where `'static` matters. Without canonicalization it's very easy to accidentally rely on `'static` again. Blocked on changing the `order_dependent_trait_objects` future-compat lint to a hard error\n\nr? `@nikomatsakis`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "html_url": "https://github.com/rust-lang/rust/commit/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0883848882483e216714d5be5a1fde87dd5a1690", "url": "https://api.github.com/repos/rust-lang/rust/commits/0883848882483e216714d5be5a1fde87dd5a1690", "html_url": "https://github.com/rust-lang/rust/commit/0883848882483e216714d5be5a1fde87dd5a1690"}, {"sha": "73c79cd80631bf4cb4a20914d02aa08d0f80ba7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/73c79cd80631bf4cb4a20914d02aa08d0f80ba7f", "html_url": "https://github.com/rust-lang/rust/commit/73c79cd80631bf4cb4a20914d02aa08d0f80ba7f"}], "stats": {"total": 253, "additions": 151, "deletions": 102}, "files": [{"sha": "d89f63e5c53e9641b6e2a3452a915d98723dc4b2", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "patch": "@@ -43,18 +43,16 @@ pub struct TypeFreshener<'a, 'tcx> {\n     const_freshen_count: u32,\n     ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n     const_freshen_map: FxHashMap<ty::InferConst<'tcx>, ty::Const<'tcx>>,\n-    keep_static: bool,\n }\n \n impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'tcx>, keep_static: bool) -> TypeFreshener<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'tcx>) -> TypeFreshener<'a, 'tcx> {\n         TypeFreshener {\n             infcx,\n             ty_freshen_count: 0,\n             const_freshen_count: 0,\n             ty_freshen_map: Default::default(),\n             const_freshen_map: Default::default(),\n-            keep_static,\n         }\n     }\n \n@@ -121,18 +119,9 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for TypeFreshener<'a, 'tcx> {\n             | ty::ReFree(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n+            | ty::ReStatic\n             | ty::ReError(_)\n-            | ty::ReErased => {\n-                // replace all free regions with 'erased\n-                self.interner().lifetimes.re_erased\n-            }\n-            ty::ReStatic => {\n-                if self.keep_static {\n-                    r\n-                } else {\n-                    self.interner().lifetimes.re_erased\n-                }\n-            }\n+            | ty::ReErased => self.interner().lifetimes.re_erased,\n         }\n     }\n "}, {"sha": "5ee560837780ab1014426d60b65e3cedab4c0cc3", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "patch": "@@ -713,12 +713,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n \n     pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n-        freshen::TypeFreshener::new(self, false)\n-    }\n-\n-    /// Like `freshener`, but does not replace `'static` regions.\n-    pub fn freshener_keep_static<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n-        freshen::TypeFreshener::new(self, true)\n+        freshen::TypeFreshener::new(self)\n     }\n \n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {"}, {"sha": "98c3e7c13ac6e3fba8aad3ef94a1a41300e75fc6", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 86, "deletions": 78, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "patch": "@@ -211,7 +211,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n-            freshener: infcx.freshener_keep_static(),\n+            freshener: infcx.freshener(),\n             intercrate_ambiguity_causes: None,\n             query_mode: TraitQueryMode::Standard,\n         }\n@@ -770,14 +770,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(pred)) => {\n-                    // A global type with no late-bound regions can only\n-                    // contain the \"'static\" lifetime (any other lifetime\n-                    // would either be late-bound or local), so it is guaranteed\n-                    // to outlive any other lifetime\n-                    if pred.0.is_global() && !pred.0.has_late_bound_vars() {\n-                        Ok(EvaluatedToOk)\n-                    } else {\n+                    // A global type with no free lifetimes or generic parameters\n+                    // outlives anything.\n+                    if pred.0.has_free_regions()\n+                        || pred.0.has_late_bound_regions()\n+                        || pred.0.has_non_region_infer()\n+                        || pred.0.has_non_region_infer()\n+                    {\n                         Ok(EvaluatedToOkModuloRegions)\n+                    } else {\n+                        Ok(EvaluatedToOk)\n                     }\n                 }\n \n@@ -1825,6 +1827,12 @@ enum DropVictim {\n     No,\n }\n \n+impl DropVictim {\n+    fn drop_if(should_drop: bool) -> DropVictim {\n+        if should_drop { DropVictim::Yes } else { DropVictim::No }\n+    }\n+}\n+\n /// ## Winnowing\n ///\n /// Winnowing is the process of attempting to resolve ambiguity by\n@@ -1890,11 +1898,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                     // or the current one if tied (they should both evaluate to the same answer). This is\n                     // probably best characterized as a \"hack\", since we might prefer to just do our\n                     // best to *not* create essentially duplicate candidates in the first place.\n-                    if other.bound_vars().len() <= victim.bound_vars().len() {\n-                        DropVictim::Yes\n-                    } else {\n-                        DropVictim::No\n-                    }\n+                    DropVictim::drop_if(other.bound_vars().len() <= victim.bound_vars().len())\n                 } else if other.skip_binder().trait_ref == victim.skip_binder().trait_ref\n                     && victim.skip_binder().constness == ty::BoundConstness::NotConst\n                     && other.skip_binder().polarity == victim.skip_binder().polarity\n@@ -1924,17 +1928,13 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                 | ObjectCandidate(_)\n                 | ProjectionCandidate(..),\n             ) => {\n-                if is_global(other_cand) {\n-                    DropVictim::No\n-                } else {\n-                    // We have a where clause so don't go around looking\n-                    // for impls. Arbitrarily give param candidates priority\n-                    // over projection and object candidates.\n-                    //\n-                    // Global bounds from the where clause should be ignored\n-                    // here (see issue #50825).\n-                    DropVictim::Yes\n-                }\n+                // We have a where clause so don't go around looking\n+                // for impls. Arbitrarily give param candidates priority\n+                // over projection and object candidates.\n+                //\n+                // Global bounds from the where clause should be ignored\n+                // here (see issue #50825).\n+                DropVictim::drop_if(!is_global(other_cand))\n             }\n             (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref victim_cand)) => {\n                 // Prefer these to a global where-clause bound\n@@ -1956,18 +1956,16 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n             ) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                if is_global(victim_cand) && other.evaluation.must_apply_modulo_regions() {\n-                    DropVictim::Yes\n-                } else {\n-                    DropVictim::No\n-                }\n+                DropVictim::drop_if(\n+                    is_global(victim_cand) && other.evaluation.must_apply_modulo_regions(),\n+                )\n             }\n \n             (ProjectionCandidate(i, _), ProjectionCandidate(j, _))\n             | (ObjectCandidate(i), ObjectCandidate(j)) => {\n                 // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                if i < j && !needs_infer { DropVictim::Yes } else { DropVictim::No }\n+                DropVictim::drop_if(i < j && !needs_infer)\n             }\n             (ObjectCandidate(_), ProjectionCandidate(..))\n             | (ProjectionCandidate(..), ObjectCandidate(_)) => {\n@@ -2018,55 +2016,65 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                     }\n                 }\n \n-                if other.evaluation.must_apply_considering_regions() {\n-                    match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n-                        Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n-                            // Subtle: If the predicate we are evaluating has inference\n-                            // variables, do *not* allow discarding candidates due to\n-                            // marker trait impls.\n-                            //\n-                            // Without this restriction, we could end up accidentally\n-                            // constraining inference variables based on an arbitrarily\n-                            // chosen trait impl.\n-                            //\n-                            // Imagine we have the following code:\n-                            //\n-                            // ```rust\n-                            // #[marker] trait MyTrait {}\n-                            // impl MyTrait for u8 {}\n-                            // impl MyTrait for bool {}\n-                            // ```\n-                            //\n-                            // And we are evaluating the predicate `<_#0t as MyTrait>`.\n-                            //\n-                            // During selection, we will end up with one candidate for each\n-                            // impl of `MyTrait`. If we were to discard one impl in favor\n-                            // of the other, we would be left with one candidate, causing\n-                            // us to \"successfully\" select the predicate, unifying\n-                            // _#0t with (for example) `u8`.\n-                            //\n-                            // However, we have no reason to believe that this unification\n-                            // is correct - we've essentially just picked an arbitrary\n-                            // *possibility* for _#0t, and required that this be the *only*\n-                            // possibility.\n-                            //\n-                            // Eventually, we will either:\n-                            // 1) Unify all inference variables in the predicate through\n-                            // some other means (e.g. type-checking of a function). We will\n-                            // then be in a position to drop marker trait candidates\n-                            // without constraining inference variables (since there are\n-                            // none left to constrain)\n-                            // 2) Be left with some unconstrained inference variables. We\n-                            // will then correctly report an inference error, since the\n-                            // existence of multiple marker trait impls tells us nothing\n-                            // about which one should actually apply.\n-                            if needs_infer { DropVictim::No } else { DropVictim::Yes }\n-                        }\n-                        Some(_) => DropVictim::Yes,\n-                        None => DropVictim::No,\n+                match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n+                    // For #33140 the impl headers must be exactly equal, the trait must not have\n+                    // any associated items and there are no where-clauses.\n+                    //\n+                    // We can just arbitrarily drop one of the impls.\n+                    Some(ty::ImplOverlapKind::Issue33140) => {\n+                        assert_eq!(other.evaluation, victim.evaluation);\n+                        DropVictim::Yes\n                     }\n-                } else {\n-                    DropVictim::No\n+                    // For candidates which already reference errors it doesn't really\n+                    // matter what we do \ud83e\udd37\n+                    Some(ty::ImplOverlapKind::Permitted { marker: false }) => {\n+                        DropVictim::drop_if(other.evaluation.must_apply_considering_regions())\n+                    }\n+                    Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n+                        // Subtle: If the predicate we are evaluating has inference\n+                        // variables, do *not* allow discarding candidates due to\n+                        // marker trait impls.\n+                        //\n+                        // Without this restriction, we could end up accidentally\n+                        // constraining inference variables based on an arbitrarily\n+                        // chosen trait impl.\n+                        //\n+                        // Imagine we have the following code:\n+                        //\n+                        // ```rust\n+                        // #[marker] trait MyTrait {}\n+                        // impl MyTrait for u8 {}\n+                        // impl MyTrait for bool {}\n+                        // ```\n+                        //\n+                        // And we are evaluating the predicate `<_#0t as MyTrait>`.\n+                        //\n+                        // During selection, we will end up with one candidate for each\n+                        // impl of `MyTrait`. If we were to discard one impl in favor\n+                        // of the other, we would be left with one candidate, causing\n+                        // us to \"successfully\" select the predicate, unifying\n+                        // _#0t with (for example) `u8`.\n+                        //\n+                        // However, we have no reason to believe that this unification\n+                        // is correct - we've essentially just picked an arbitrary\n+                        // *possibility* for _#0t, and required that this be the *only*\n+                        // possibility.\n+                        //\n+                        // Eventually, we will either:\n+                        // 1) Unify all inference variables in the predicate through\n+                        // some other means (e.g. type-checking of a function). We will\n+                        // then be in a position to drop marker trait candidates\n+                        // without constraining inference variables (since there are\n+                        // none left to constrain)\n+                        // 2) Be left with some unconstrained inference variables. We\n+                        // will then correctly report an inference error, since the\n+                        // existence of multiple marker trait impls tells us nothing\n+                        // about which one should actually apply.\n+                        DropVictim::drop_if(\n+                            !needs_infer && other.evaluation.must_apply_considering_regions(),\n+                        )\n+                    }\n+                    None => DropVictim::No,\n                 }\n             }\n "}, {"sha": "b9f1de7ec13a538d625a1902d88e44cf729514a2", "filename": "tests/ui/marker_trait_attr/overlap-marker-trait-with-static-lifetime.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.rs?ref=4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "patch": "@@ -1,4 +1,8 @@\n-// check-pass\n+// known-bug: #89515\n+//\n+// The trait solver cannot deal with ambiguous marker trait impls\n+// if there are lifetimes involved. As we must not special-case any\n+// regions this does not work, even with 'static\n #![feature(marker_trait_attr)]\n \n #[marker]"}, {"sha": "fe4de540b513af95e7db0c76e780c0b5e7a532a3", "filename": "tests/ui/marker_trait_attr/overlap-marker-trait-with-static-lifetime.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmarker_trait_attr%2Foverlap-marker-trait-with-static-lifetime.stderr?ref=4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "patch": "@@ -0,0 +1,31 @@\n+error[E0283]: type annotations needed: cannot satisfy `&'static (): Marker`\n+  --> $DIR/overlap-marker-trait-with-static-lifetime.rs:11:17\n+   |\n+LL | impl Marker for &'static () {}\n+   |                 ^^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&'static (): Marker` found\n+  --> $DIR/overlap-marker-trait-with-static-lifetime.rs:11:1\n+   |\n+LL | impl Marker for &'static () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl Marker for &'static () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0283]: type annotations needed: cannot satisfy `&'static (): Marker`\n+  --> $DIR/overlap-marker-trait-with-static-lifetime.rs:12:17\n+   |\n+LL | impl Marker for &'static () {}\n+   |                 ^^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&'static (): Marker` found\n+  --> $DIR/overlap-marker-trait-with-static-lifetime.rs:11:1\n+   |\n+LL | impl Marker for &'static () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | impl Marker for &'static () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "97a814f51eec58278b8e4a1d155148cf1919d00d", "filename": "tests/ui/marker_trait_attr/overlapping-impl-1-modulo-regions.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.rs?ref=4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "patch": "@@ -1,9 +1,17 @@\n-// check-pass\n+// known-bug: #109481\n+//\n+// While the `T: Copy` is always applicable when checking\n+// that the impl `impl<T: Copy> F for T {}` is well formed,\n+// the old trait solver can only approximate this by checking\n+// that there are no inference variables in the obligation and\n+// no region constraints in the evaluation result.\n+//\n+// Because of this we end up with ambiguity here.\n #![feature(marker_trait_attr)]\n \n #[marker]\n pub trait F {}\n-impl<T> F for T where T: Copy {}\n-impl<T> F for T where T: 'static {}\n+impl<T: Copy> F for T {}\n+impl<T: 'static> F for T {}\n \n fn main() {}"}, {"sha": "e713d1451cfd2762867271ddf3bca44c9ff9c7fb", "filename": "tests/ui/marker_trait_attr/overlapping-impl-1-modulo-regions.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmarker_trait_attr%2Foverlapping-impl-1-modulo-regions.stderr?ref=4bd33fdb4a40e82cf8572ca68a13e1e2fbef60f3", "patch": "@@ -0,0 +1,14 @@\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/overlapping-impl-1-modulo-regions.rs:14:21\n+   |\n+LL | impl<T: Copy> F for T {}\n+   |                     ^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | impl<T: Copy + 'static> F for T {}\n+   |              +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0310`."}]}