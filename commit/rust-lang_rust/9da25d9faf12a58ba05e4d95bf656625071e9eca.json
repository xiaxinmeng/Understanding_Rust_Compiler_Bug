{"sha": "9da25d9faf12a58ba05e4d95bf656625071e9eca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYTI1ZDlmYWYxMmE1OGJhMDVlNGQ5NWJmNjU2NjI1MDcxZTllY2E=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-23T23:49:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-23T23:49:36Z"}, "message": "Rollup merge of #67761 - cjgillot:split_graph, r=Zoxc\n\nMove the dep_graph construction to a dedicated crate.\n\nThe interface for librustc consists in two traits: `DepKind` and `DepContext`.\n\nThe `DepKind` is the main interface. It allows to probe properties of the dependency.\nAs before, `DepNode` is the pair of a `DepKind` object and a hash fingerprint.\n\nThe `DepContext` takes the place of the `TyCtxt`, and handles communication with the query engine.\n\nThe use of the `ImplicitCtxt` through `ty::tls` is done through the `DepKind` trait.\nThis may not be the best choice, but it seemed like the simplest.", "tree": {"sha": "8678e532097dba374389ddc411a154d354ed2c42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8678e532097dba374389ddc411a154d354ed2c42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9da25d9faf12a58ba05e4d95bf656625071e9eca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeeUsQCRBK7hj4Ov3rIwAAdHIIAIAunBDPRzpJvlrDyDeBwAFM\npU3UwJrEaQcwZRWbpeF1oBhYdaWJGNxIObBwCI22B7ZTUC7ZRnqRfmNzfGd82Pj8\nGtOKV4H7XKJ3AWWFiKLkfZXOkYbR5nS2kyuWjnOpM/8bM5h4u/Rq7ghg15LvHrFi\nZorNfN48s3pAk5OUtjTI+VnJ8WaoDUkmoWsuoi1GbERA8l7/DLvFuOPaT066Tbyu\n1kIxU8sRZ4yNMffpC1FtrIMcotgphgUJ+lQ32D3EfpZObwJ13JwXvTCmIDzuNq9s\nDgzAmxR8o//PP2gjMXrrS6XiWQiC1uRJqFZ2KbSdTuXzivrS0LTf8VO6whaQBOY=\n=ccdZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 8678e532097dba374389ddc411a154d354ed2c42\nparent 1edd389cc4c7b5be7a3dd4fe4b986f6017018e54\nparent 0f918cba3ff48216a140db4fd06e2ea13abc78c9\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585007376 +0100\ncommitter GitHub <noreply@github.com> 1585007376 +0100\n\nRollup merge of #67761 - cjgillot:split_graph, r=Zoxc\n\nMove the dep_graph construction to a dedicated crate.\n\nThe interface for librustc consists in two traits: `DepKind` and `DepContext`.\n\nThe `DepKind` is the main interface. It allows to probe properties of the dependency.\nAs before, `DepNode` is the pair of a `DepKind` object and a hash fingerprint.\n\nThe `DepContext` takes the place of the `TyCtxt`, and handles communication with the query engine.\n\nThe use of the `ImplicitCtxt` through `ty::tls` is done through the `DepKind` trait.\nThis may not be the best choice, but it seemed like the simplest.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9da25d9faf12a58ba05e4d95bf656625071e9eca", "html_url": "https://github.com/rust-lang/rust/commit/9da25d9faf12a58ba05e4d95bf656625071e9eca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9da25d9faf12a58ba05e4d95bf656625071e9eca/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1edd389cc4c7b5be7a3dd4fe4b986f6017018e54", "url": "https://api.github.com/repos/rust-lang/rust/commits/1edd389cc4c7b5be7a3dd4fe4b986f6017018e54", "html_url": "https://github.com/rust-lang/rust/commit/1edd389cc4c7b5be7a3dd4fe4b986f6017018e54"}, {"sha": "0f918cba3ff48216a140db4fd06e2ea13abc78c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f918cba3ff48216a140db4fd06e2ea13abc78c9", "html_url": "https://github.com/rust-lang/rust/commit/0f918cba3ff48216a140db4fd06e2ea13abc78c9"}], "stats": {"total": 1194, "additions": 763, "deletions": 431}, "files": [{"sha": "22a06151353bada202aa083bf39d34c2cab1d293", "filename": "Cargo.lock", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -3116,6 +3116,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4021,6 +4022,22 @@ dependencies = [\n  \"rustc_typeck\",\n ]\n \n+[[package]]\n+name = \"rustc_query_system\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"parking_lot 0.9.0\",\n+ \"rustc_ast\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"serialize\",\n+ \"smallvec 1.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_resolve\"\n version = \"0.0.0\""}, {"sha": "47b94a2f1a4b49947eef67613ecdd6a3de4cb3a1", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -25,6 +25,7 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_query_system = { path = \"../librustc_query_system\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "fdcc1a0db0538236e8ffd1ff2d07dea2c7512391", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 46, "deletions": 142, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -50,7 +50,7 @@\n //! fingerprint for a given set of node parameters.\n \n use crate::hir::map::DefPathHash;\n-use crate::ich::{Fingerprint, StableHashingContext};\n+use crate::ich::Fingerprint;\n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n use crate::traits;\n@@ -62,13 +62,13 @@ use crate::traits::query::{\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::HirId;\n use rustc_span::symbol::Symbol;\n-use std::fmt;\n use std::hash::Hash;\n \n+pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n+\n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e., which sub-expression of the macro we are in) but don't need\n // to actually use any of the arguments.\n@@ -128,7 +128,7 @@ macro_rules! define_dep_nodes {\n \n                             // tuple args\n                             $({\n-                                return <$tuple_arg_ty as DepNodeParams>\n+                                return <$tuple_arg_ty as DepNodeParams<TyCtxt<'_>>>\n                                     ::CAN_RECONSTRUCT_QUERY_KEY;\n                             })*\n \n@@ -212,38 +212,46 @@ macro_rules! define_dep_nodes {\n             )*\n         }\n \n-        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n-                 RustcEncodable, RustcDecodable)]\n-        pub struct DepNode {\n-            pub kind: DepKind,\n-            pub hash: Fingerprint,\n+        pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n+\n+        pub trait DepNodeExt: Sized {\n+            /// Construct a DepNode from the given DepKind and DefPathHash. This\n+            /// method will assert that the given DepKind actually requires a\n+            /// single DefId/DefPathHash parameter.\n+            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n+\n+            /// Extracts the DefId corresponding to this DepNode. This will work\n+            /// if two conditions are met:\n+            ///\n+            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+            /// 2. the item that the DefPath refers to exists in the current tcx.\n+            ///\n+            /// Condition (1) is determined by the DepKind variant of the\n+            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+            /// refers to something from the previous compilation session that\n+            /// has been removed.\n+            fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId>;\n+\n+            /// Used in testing\n+            fn from_label_string(label: &str, def_path_hash: DefPathHash)\n+                -> Result<Self, ()>;\n+\n+            /// Used in testing\n+            fn has_label_string(label: &str) -> bool;\n         }\n \n-        impl DepNode {\n+        impl DepNodeExt for DepNode {\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter.\n-            pub fn from_def_path_hash(def_path_hash: DefPathHash,\n-                                      kind: DepKind)\n-                                      -> DepNode {\n+            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n                 debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n                 DepNode {\n                     kind,\n                     hash: def_path_hash.0,\n                 }\n             }\n \n-            /// Creates a new, parameterless DepNode. This method will assert\n-            /// that the DepNode corresponding to the given DepKind actually\n-            /// does not require any parameters.\n-            pub fn new_no_params(kind: DepKind) -> DepNode {\n-                debug_assert!(!kind.has_params());\n-                DepNode {\n-                    kind,\n-                    hash: Fingerprint::ZERO,\n-                }\n-            }\n-\n             /// Extracts the DefId corresponding to this DepNode. This will work\n             /// if two conditions are met:\n             ///\n@@ -254,20 +262,17 @@ macro_rules! define_dep_nodes {\n             /// DepNode. Condition (2) might not be fulfilled if a DepNode\n             /// refers to something from the previous compilation session that\n             /// has been removed.\n-            pub fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n+            fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n                 if self.kind.can_reconstruct_query_key() {\n                     let def_path_hash = DefPathHash(self.hash);\n-                    tcx.def_path_hash_to_def_id.as_ref()?\n-                        .get(&def_path_hash).cloned()\n+                    tcx.def_path_hash_to_def_id.as_ref()?.get(&def_path_hash).cloned()\n                 } else {\n                     None\n                 }\n             }\n \n             /// Used in testing\n-            pub fn from_label_string(label: &str,\n-                                     def_path_hash: DefPathHash)\n-                                     -> Result<DepNode, ()> {\n+            fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n                 let kind = match label {\n                     $(\n                         stringify!($variant) => DepKind::$variant,\n@@ -287,7 +292,7 @@ macro_rules! define_dep_nodes {\n             }\n \n             /// Used in testing\n-            pub fn has_label_string(label: &str) -> bool {\n+            fn has_label_string(label: &str) -> bool {\n                 match label {\n                     $(\n                         stringify!($variant) => true,\n@@ -308,35 +313,6 @@ macro_rules! define_dep_nodes {\n     );\n }\n \n-impl fmt::Debug for DepNode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.kind)?;\n-\n-        if !self.kind.has_params() && !self.kind.is_anon() {\n-            return Ok(());\n-        }\n-\n-        write!(f, \"(\")?;\n-\n-        crate::ty::tls::with_opt(|opt_tcx| {\n-            if let Some(tcx) = opt_tcx {\n-                if let Some(def_id) = self.extract_def_id(tcx) {\n-                    write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n-                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*self) {\n-                    write!(f, \"{}\", s)?;\n-                } else {\n-                    write!(f, \"{}\", self.hash)?;\n-                }\n-            } else {\n-                write!(f, \"{}\", self.hash)?;\n-            }\n-            Ok(())\n-        })?;\n-\n-        write!(f, \")\")\n-    }\n-}\n-\n rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,\n@@ -349,58 +325,10 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] CompileCodegenUnit(Symbol),\n ]);\n \n-pub(crate) trait DepNodeParams<'tcx>: fmt::Debug + Sized {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n-\n-    /// This method turns the parameters of a DepNodeConstructor into an opaque\n-    /// Fingerprint to be used in DepNode.\n-    /// Not all DepNodeParams support being turned into a Fingerprint (they\n-    /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: TyCtxt<'tcx>) -> Fingerprint {\n-        panic!(\"Not implemented. Accidentally called on anonymous node?\")\n-    }\n-\n-    fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-\n-    /// This method tries to recover the query key from the given `DepNode`,\n-    /// something which is needed when forcing `DepNode`s during red-green\n-    /// evaluation. The query system will only call this method if\n-    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n-    /// It is always valid to return `None` here, in which case incremental\n-    /// compilation will treat the query as having changed instead of forcing it.\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n-}\n-\n-impl<'tcx, T> DepNodeParams<'tcx> for T\n-where\n-    T: HashStable<StableHashingContext<'tcx>> + fmt::Debug,\n-{\n-    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n-\n-    default fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-\n-        self.hash_stable(&mut hcx, &mut hasher);\n-\n-        hasher.finish()\n-    }\n-\n-    default fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-\n-    default fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n-        None\n-    }\n-}\n-\n-impl<'tcx> DepNodeParams<'tcx> for DefId {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         tcx.def_path_hash(*self).0\n     }\n \n@@ -413,10 +341,10 @@ impl<'tcx> DepNodeParams<'tcx> for DefId {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for LocalDefId {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         self.to_def_id().to_fingerprint(tcx)\n     }\n \n@@ -429,10 +357,10 @@ impl<'tcx> DepNodeParams<'tcx> for LocalDefId {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         tcx.def_path_hash(def_id).0\n     }\n@@ -446,13 +374,13 @@ impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let (def_id_0, def_id_1) = *self;\n \n         let def_path_hash_0 = tcx.def_path_hash(def_id_0);\n@@ -468,13 +396,13 @@ impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for HirId {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let HirId { owner, local_id } = *self;\n \n         let def_path_hash = tcx.def_path_hash(owner.to_def_id());\n@@ -483,27 +411,3 @@ impl<'tcx> DepNodeParams<'tcx> for HirId {\n         def_path_hash.0.combine(local_id)\n     }\n }\n-\n-/// A \"work product\" corresponds to a `.o` (or other) file that we\n-/// save in between runs. These IDs do not have a `DefId` but rather\n-/// some independent path or string that persists between runs without\n-/// the need to be mapped or unmapped. (This ensures we can serialize\n-/// them even in the absence of a tcx.)\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-#[derive(HashStable)]\n-pub struct WorkProductId {\n-    hash: Fingerprint,\n-}\n-\n-impl WorkProductId {\n-    pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n-        let mut hasher = StableHasher::new();\n-        cgu_name.len().hash(&mut hasher);\n-        cgu_name.hash(&mut hasher);\n-        WorkProductId { hash: hasher.finish() }\n-    }\n-\n-    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n-        WorkProductId { hash: fingerprint }\n-    }\n-}"}, {"sha": "3c39597584df50cffbde05897ee6f38ce58c4b06", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 189, "deletions": 15, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -1,17 +1,191 @@\n-pub mod debug;\n+use crate::ich::StableHashingContext;\n+use crate::ty::query::try_load_from_on_disk_cache;\n+use crate::ty::{self, TyCtxt};\n+use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::Diagnostic;\n+use rustc_hir::def_id::DefId;\n+\n mod dep_node;\n-mod graph;\n-mod prev;\n-mod query;\n mod safe;\n-mod serialized;\n-\n-pub(crate) use self::dep_node::DepNodeParams;\n-pub use self::dep_node::{label_strs, DepConstructor, DepKind, DepNode, WorkProductId};\n-pub use self::graph::WorkProductFileKind;\n-pub use self::graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n-pub use self::prev::PreviousDepGraph;\n-pub use self::query::DepGraphQuery;\n-pub use self::safe::AssertDepGraphSafe;\n-pub use self::safe::DepGraphSafe;\n-pub use self::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+\n+pub(crate) use rustc_query_system::dep_graph::DepNodeParams;\n+pub use rustc_query_system::dep_graph::{\n+    debug, hash_result, DepContext, DepNodeColor, DepNodeIndex, SerializedDepNodeIndex,\n+    WorkProduct, WorkProductFileKind, WorkProductId,\n+};\n+\n+pub use dep_node::{label_strs, DepConstructor, DepKind, DepNode, DepNodeExt};\n+pub use safe::AssertDepGraphSafe;\n+pub use safe::DepGraphSafe;\n+\n+pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n+pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n+pub type DepGraphQuery = rustc_query_system::dep_graph::DepGraphQuery<DepKind>;\n+pub type PreviousDepGraph = rustc_query_system::dep_graph::PreviousDepGraph<DepKind>;\n+pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<DepKind>;\n+\n+impl rustc_query_system::dep_graph::DepKind for DepKind {\n+    fn is_eval_always(&self) -> bool {\n+        DepKind::is_eval_always(self)\n+    }\n+\n+    fn has_params(&self) -> bool {\n+        DepKind::has_params(self)\n+    }\n+\n+    fn debug_node(node: &DepNode, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{:?}\", node.kind)?;\n+\n+        if !node.kind.has_params() && !node.kind.is_anon() {\n+            return Ok(());\n+        }\n+\n+        write!(f, \"(\")?;\n+\n+        ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                if let Some(def_id) = node.extract_def_id(tcx) {\n+                    write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n+                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*node) {\n+                    write!(f, \"{}\", s)?;\n+                } else {\n+                    write!(f, \"{}\", node.hash)?;\n+                }\n+            } else {\n+                write!(f, \"{}\", node.hash)?;\n+            }\n+            Ok(())\n+        })?;\n+\n+        write!(f, \")\")\n+    }\n+\n+    fn with_deps<OP, R>(task_deps: Option<&Lock<TaskDeps>>, op: OP) -> R\n+    where\n+        OP: FnOnce() -> R,\n+    {\n+        ty::tls::with_context(|icx| {\n+            let icx = ty::tls::ImplicitCtxt { task_deps, ..icx.clone() };\n+\n+            ty::tls::enter_context(&icx, |_| op())\n+        })\n+    }\n+\n+    fn read_deps<OP>(op: OP) -> ()\n+    where\n+        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps>>) -> (),\n+    {\n+        ty::tls::with_context_opt(|icx| {\n+            let icx = if let Some(icx) = icx { icx } else { return };\n+            op(icx.task_deps)\n+        })\n+    }\n+}\n+\n+impl<'tcx> DepContext for TyCtxt<'tcx> {\n+    type DepKind = DepKind;\n+    type StableHashingContext = StableHashingContext<'tcx>;\n+\n+    fn create_stable_hashing_context(&self) -> Self::StableHashingContext {\n+        TyCtxt::create_stable_hashing_context(*self)\n+    }\n+\n+    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n+        // FIXME: This match is just a workaround for incremental bugs and should\n+        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n+        // bug that must be fixed before removing this.\n+        match dep_node.kind {\n+            DepKind::hir_owner | DepKind::hir_owner_nodes | DepKind::CrateMetadata => {\n+                if let Some(def_id) = dep_node.extract_def_id(*self) {\n+                    if def_id_corresponds_to_hir_dep_node(*self, def_id) {\n+                        if dep_node.kind == DepKind::CrateMetadata {\n+                            // The `DefPath` has corresponding node,\n+                            // and that node should have been marked\n+                            // either red or green in `data.colors`.\n+                            bug!(\n+                                \"DepNode {:?} should have been \\\n+                             pre-marked as red or green but wasn't.\",\n+                                dep_node\n+                            );\n+                        }\n+                    } else {\n+                        // This `DefPath` does not have a\n+                        // corresponding `DepNode` (e.g. a\n+                        // struct field), and the ` DefPath`\n+                        // collided with the `DefPath` of a\n+                        // proper item that existed in the\n+                        // previous compilation session.\n+                        //\n+                        // Since the given `DefPath` does not\n+                        // denote the item that previously\n+                        // existed, we just fail to mark green.\n+                        return false;\n+                    }\n+                } else {\n+                    // If the node does not exist anymore, we\n+                    // just fail to mark green.\n+                    return false;\n+                }\n+            }\n+            _ => {\n+                // For other kinds of nodes it's OK to be\n+                // forced.\n+            }\n+        }\n+\n+        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n+        ty::query::force_from_dep_node(*self, dep_node)\n+    }\n+\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool {\n+        self.sess.has_errors_or_delayed_span_bugs()\n+    }\n+\n+    fn diagnostic(&self) -> &rustc_errors::Handler {\n+        self.sess.diagnostic()\n+    }\n+\n+    // Interactions with on_disk_cache\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n+        try_load_from_on_disk_cache(*self, dep_node)\n+    }\n+\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {\n+        self.queries.on_disk_cache.load_diagnostics(*self, prev_dep_node_index)\n+    }\n+\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n+        self.queries.on_disk_cache.store_diagnostics(dep_node_index, diagnostics)\n+    }\n+\n+    fn profiler(&self) -> &SelfProfilerRef {\n+        &self.prof\n+    }\n+}\n+\n+fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    def_id.index == hir_id.owner.local_def_index\n+}\n+\n+impl rustc_query_system::HashStableContext for StableHashingContext<'_> {\n+    fn debug_dep_tasks(&self) -> bool {\n+        self.sess().opts.debugging_opts.dep_tasks\n+    }\n+}\n+\n+impl rustc_query_system::HashStableContextProvider<StableHashingContext<'tcx>> for TyCtxt<'tcx> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'tcx> {\n+        self.create_stable_hashing_context()\n+    }\n+}\n+\n+impl rustc_query_system::HashStableContextProvider<StableHashingContext<'a>>\n+    for StableHashingContext<'a>\n+{\n+    fn get_stable_hashing_context(&self) -> Self {\n+        self.clone()\n+    }\n+}"}, {"sha": "47a1c09672ff60aad8fa8c5f84b788d0e34b1b02", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -2,56 +2,8 @@\n \n use crate::ty::TyCtxt;\n \n-use rustc_ast::ast::NodeId;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::BodyId;\n-\n-/// The `DepGraphSafe` trait is used to specify what kinds of values\n-/// are safe to \"leak\" into a task. The idea is that this should be\n-/// only be implemented for things like the tcx as well as various id\n-/// types, which will create reads in the dep-graph whenever the trait\n-/// loads anything that might depend on the input program.\n-pub trait DepGraphSafe {}\n-\n-/// A `BodyId` on its own doesn't give access to any particular state.\n-/// You must fetch the state from the various maps or generate\n-/// on-demand queries, all of which create reads.\n-impl DepGraphSafe for BodyId {}\n-\n-/// A `NodeId` on its own doesn't give access to any particular state.\n-/// You must fetch the state from the various maps or generate\n-/// on-demand queries, all of which create reads.\n-impl DepGraphSafe for NodeId {}\n-\n-/// A `DefId` on its own doesn't give access to any particular state.\n-/// You must fetch the state from the various maps or generate\n-/// on-demand queries, all of which create reads.\n-impl DepGraphSafe for DefId {}\n+pub use rustc_query_system::dep_graph::{AssertDepGraphSafe, DepGraphSafe};\n \n /// The type context itself can be used to access all kinds of tracked\n /// state, but those accesses should always generate read events.\n impl<'tcx> DepGraphSafe for TyCtxt<'tcx> {}\n-\n-/// Tuples make it easy to build up state.\n-impl<A, B> DepGraphSafe for (A, B)\n-where\n-    A: DepGraphSafe,\n-    B: DepGraphSafe,\n-{\n-}\n-\n-/// Shared ref to dep-graph-safe stuff should still be dep-graph-safe.\n-impl<'a, A> DepGraphSafe for &'a A where A: DepGraphSafe {}\n-\n-/// Mut ref to dep-graph-safe stuff should still be dep-graph-safe.\n-impl<'a, A> DepGraphSafe for &'a mut A where A: DepGraphSafe {}\n-\n-/// No data here! :)\n-impl DepGraphSafe for () {}\n-\n-/// A convenient override that lets you pass arbitrary state into a\n-/// task. Every use should be accompanied by a comment explaining why\n-/// it makes sense (or how it could be refactored away in the future).\n-pub struct AssertDepGraphSafe<T>(pub T);\n-\n-impl<T> DepGraphSafe for AssertDepGraphSafe<T> {}"}, {"sha": "b45b3b3f539eafeae96a7936036c8c8151eb90ee", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -150,8 +150,6 @@ rustc_query_append! { [define_queries!][<'tcx>] }\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below.\n pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n-    use crate::dep_graph::DepKind;\n-\n     // We must avoid ever having to call `force_from_dep_node()` for a\n     // `DepNode::codegen_unit`:\n     // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n@@ -166,7 +164,7 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     // hit the cache instead of having to go through `force_from_dep_node`.\n     // This assertion makes sure, we actually keep applying the solution above.\n     debug_assert!(\n-        dep_node.kind != DepKind::codegen_unit,\n+        dep_node.kind != crate::dep_graph::DepKind::codegen_unit,\n         \"calling force_from_dep_node() on DepKind::codegen_unit\"\n     );\n \n@@ -177,30 +175,21 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already.\n-        DepKind::CrateMetadata |\n+        crate::dep_graph::DepKind::CrateMetadata |\n \n         // These are anonymous nodes.\n-        DepKind::TraitSelect |\n+        crate::dep_graph::DepKind::TraitSelect |\n \n         // We don't have enough information to reconstruct the query key of\n         // these.\n-        DepKind::CompileCodegenUnit => {\n+        crate::dep_graph::DepKind::CompileCodegenUnit => {\n             bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n         }\n     );\n \n     false\n }\n \n-impl DepNode {\n-    /// Check whether the query invocation corresponding to the given\n-    /// DepNode is eligible for on-disk-caching. If so, this is method\n-    /// will execute the query corresponding to the given DepNode.\n-    /// Also, as a sanity check, it expects that the corresponding query\n-    /// invocation has been marked as green already.\n-    pub fn try_load_from_on_disk_cache<'tcx>(&self, tcx: TyCtxt<'tcx>) {\n-        use crate::dep_graph::DepKind;\n-\n-        rustc_dep_node_try_load_from_on_disk_cache!(self, tcx)\n-    }\n+pub(crate) fn try_load_from_on_disk_cache<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n+    rustc_dep_node_try_load_from_on_disk_cache!(dep_node, tcx)\n }"}, {"sha": "305e0fcc383ad260bfbece88eedeb9d79ae70361", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -35,7 +35,7 @@\n \n use graphviz as dot;\n use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n-use rustc::dep_graph::{DepGraphQuery, DepKind, DepNode};\n+use rustc::dep_graph::{DepGraphQuery, DepKind, DepNode, DepNodeExt};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n use rustc_ast::ast;"}, {"sha": "9ddd238afff2bb7e2d2d193817e085cb913f8299", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -13,7 +13,7 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n-use rustc::dep_graph::{label_strs, DepNode};\n+use rustc::dep_graph::{label_strs, DepNode, DepNodeExt};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n use rustc_ast::ast::{self, Attribute, NestedMetaItem};"}, {"sha": "e7005f2f5ba775578e5fcd5ffa3c69f0d77246e9", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -429,14 +429,14 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 });\n \n                 try_load_from_on_disk_cache_stream.extend(quote! {\n-                    DepKind::#name => {\n-                        if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n+                    ::rustc::dep_graph::DepKind::#name => {\n+                        if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n                             debug_assert!($tcx.dep_graph\n                                             .node_color($dep_node)\n                                             .map(|c| c.is_green())\n                                             .unwrap_or(false));\n \n-                            let key = <#arg as DepNodeParams>::recover($tcx, $dep_node).unwrap();\n+                            let key = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node).unwrap();\n                             if queries::#name::cache_on_disk($tcx, key, None) {\n                                 let _ = $tcx.#name(key);\n                             }\n@@ -486,9 +486,9 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n             // Add a match arm to force the query given the dep node\n             dep_node_force_stream.extend(quote! {\n-                DepKind::#name => {\n-                    if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n-                        if let Some(key) = <#arg as DepNodeParams>::recover($tcx, $dep_node) {\n+                ::rustc::dep_graph::DepKind::#name => {\n+                    if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n+                        if let Some(key) = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node) {\n                             $tcx.force_query::<crate::ty::query::queries::#name<'_>>(\n                                 key,\n                                 DUMMY_SP,\n@@ -509,7 +509,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     }\n \n     dep_node_force_stream.extend(quote! {\n-        DepKind::Null => {\n+        ::rustc::dep_graph::DepKind::Null => {\n             bug!(\"Cannot force dep node: {:?}\", $dep_node)\n         }\n     });"}, {"sha": "4e086bcbb2d92e1b7a6c3c0c9cd9eed2a6993345", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -4,7 +4,7 @@ use crate::creader::CrateMetadataRef;\n use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n-use rustc::dep_graph::{self, DepNode, DepNodeIndex};\n+use rustc::dep_graph::{self, DepNode, DepNodeExt, DepNodeIndex};\n use rustc::hir::exports::Export;\n use rustc::middle::cstore::{CrateSource, ExternCrate};\n use rustc::middle::cstore::{ForeignModule, LinkagePreference, NativeLibrary};"}, {"sha": "a01bb5e5ea30dbc2a341b5120a26de8bc3326a49", "filename": "src/librustc_query_system/Cargo.toml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2FCargo.toml?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -0,0 +1,22 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_query_system\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_query_system\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+rustc_ast = { path = \"../librustc_ast\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_index = { path = \"../librustc_index\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n+rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+parking_lot = \"0.9\"\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "b9d91cd35a8ddf6ce799b94d488bffc955b2efde", "filename": "src/librustc_query_system/dep_graph/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2FREADME.md?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "previous_filename": "src/librustc/dep_graph/README.md"}, {"sha": "718a2f1039a4df8576fb3ac2cc842c322fbd573f", "filename": "src/librustc_query_system/dep_graph/debug.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -1,6 +1,6 @@\n //! Code for debugging the dep-graph.\n \n-use super::dep_node::DepNode;\n+use super::{DepKind, DepNode};\n use std::error::Error;\n \n /// A dep-node filter goes from a user-defined string to a query over\n@@ -26,7 +26,7 @@ impl DepNodeFilter {\n     }\n \n     /// Tests whether `node` meets the filter, returning true if so.\n-    pub fn test(&self, node: &DepNode) -> bool {\n+    pub fn test<K: DepKind>(&self, node: &DepNode<K>) -> bool {\n         let debug_str = format!(\"{:?}\", node);\n         self.text.split('&').map(|s| s.trim()).all(|f| debug_str.contains(f))\n     }\n@@ -52,7 +52,7 @@ impl EdgeFilter {\n         }\n     }\n \n-    pub fn test(&self, source: &DepNode, target: &DepNode) -> bool {\n+    pub fn test<K: DepKind>(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n         self.source.test(source) && self.target.test(target)\n     }\n }", "previous_filename": "src/librustc/dep_graph/debug.rs"}, {"sha": "c6fff2f01643addd479c5d3f1d00b1c1d508b58d", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -0,0 +1,146 @@\n+//! This module defines the `DepNode` type which the compiler uses to represent\n+//! nodes in the dependency graph. A `DepNode` consists of a `DepKind` (which\n+//! specifies the kind of thing it represents, like a piece of HIR, MIR, etc)\n+//! and a `Fingerprint`, a 128 bit hash value the exact meaning of which\n+//! depends on the node's `DepKind`. Together, the kind and the fingerprint\n+//! fully identify a dependency node, even across multiple compilation sessions.\n+//! In other words, the value of the fingerprint does not depend on anything\n+//! that is specific to a given compilation session, like an unpredictable\n+//! interning key (e.g., NodeId, DefId, Symbol) or the numeric value of a\n+//! pointer. The concept behind this could be compared to how git commit hashes\n+//! uniquely identify a given commit and has a few advantages:\n+//!\n+//! * A `DepNode` can simply be serialized to disk and loaded in another session\n+//!   without the need to do any \"rebasing (like we have to do for Spans and\n+//!   NodeIds) or \"retracing\" like we had to do for `DefId` in earlier\n+//!   implementations of the dependency graph.\n+//! * A `Fingerprint` is just a bunch of bits, which allows `DepNode` to\n+//!   implement `Copy`, `Sync`, `Send`, `Freeze`, etc.\n+//! * Since we just have a bit pattern, `DepNode` can be mapped from disk into\n+//!   memory without any post-processing (e.g., \"abomination-style\" pointer\n+//!   reconstruction).\n+//! * Because a `DepNode` is self-contained, we can instantiate `DepNodes` that\n+//!   refer to things that do not exist anymore. In previous implementations\n+//!   `DepNode` contained a `DefId`. A `DepNode` referring to something that\n+//!   had been removed between the previous and the current compilation session\n+//!   could not be instantiated because the current compilation session\n+//!   contained no `DefId` for thing that had been removed.\n+//!\n+//! `DepNode` definition happens in `librustc` with the `define_dep_nodes!()` macro.\n+//! This macro defines the `DepKind` enum and a corresponding `DepConstructor` enum. The\n+//! `DepConstructor` enum links a `DepKind` to the parameters that are needed at runtime in order\n+//! to construct a valid `DepNode` fingerprint.\n+//!\n+//! Because the macro sees what parameters a given `DepKind` requires, it can\n+//! \"infer\" some properties for each kind of `DepNode`:\n+//!\n+//! * Whether a `DepNode` of a given kind has any parameters at all. Some\n+//!   `DepNode`s could represent global concepts with only one value.\n+//! * Whether it is possible, in principle, to reconstruct a query key from a\n+//!   given `DepNode`. Many `DepKind`s only require a single `DefId` parameter,\n+//!   in which case it is possible to map the node's fingerprint back to the\n+//!   `DefId` it was computed from. In other cases, too much information gets\n+//!   lost during fingerprint computation.\n+\n+use super::{DepContext, DepKind};\n+\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_macros::HashStable_Generic;\n+\n+use std::fmt;\n+use std::hash::Hash;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub struct DepNode<K> {\n+    pub kind: K,\n+    pub hash: Fingerprint,\n+}\n+\n+impl<K: DepKind> DepNode<K> {\n+    /// Creates a new, parameterless DepNode. This method will assert\n+    /// that the DepNode corresponding to the given DepKind actually\n+    /// does not require any parameters.\n+    pub fn new_no_params(kind: K) -> DepNode<K> {\n+        debug_assert!(!kind.has_params());\n+        DepNode { kind, hash: Fingerprint::ZERO }\n+    }\n+}\n+\n+impl<K: DepKind> fmt::Debug for DepNode<K> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        K::debug_node(self, f)\n+    }\n+}\n+\n+pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n+\n+    /// This method turns the parameters of a DepNodeConstructor into an opaque\n+    /// Fingerprint to be used in DepNode.\n+    /// Not all DepNodeParams support being turned into a Fingerprint (they\n+    /// don't need to if the corresponding DepNode is anonymous).\n+    fn to_fingerprint(&self, _: Ctxt) -> Fingerprint {\n+        panic!(\"Not implemented. Accidentally called on anonymous node?\")\n+    }\n+\n+    fn to_debug_str(&self, _: Ctxt) -> String {\n+        format!(\"{:?}\", self)\n+    }\n+\n+    /// This method tries to recover the query key from the given `DepNode`,\n+    /// something which is needed when forcing `DepNode`s during red-green\n+    /// evaluation. The query system will only call this method if\n+    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n+    /// It is always valid to return `None` here, in which case incremental\n+    /// compilation will treat the query as having changed instead of forcing it.\n+    fn recover(tcx: Ctxt, dep_node: &DepNode<Ctxt::DepKind>) -> Option<Self>;\n+}\n+\n+impl<Ctxt: DepContext, T> DepNodeParams<Ctxt> for T\n+where\n+    T: HashStable<Ctxt::StableHashingContext> + fmt::Debug,\n+{\n+    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n+        let mut hcx = tcx.create_stable_hashing_context();\n+        let mut hasher = StableHasher::new();\n+\n+        self.hash_stable(&mut hcx, &mut hasher);\n+\n+        hasher.finish()\n+    }\n+\n+    default fn to_debug_str(&self, _: Ctxt) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+\n+    default fn recover(_: Ctxt, _: &DepNode<Ctxt::DepKind>) -> Option<Self> {\n+        None\n+    }\n+}\n+\n+/// A \"work product\" corresponds to a `.o` (or other) file that we\n+/// save in between runs. These IDs do not have a `DefId` but rather\n+/// some independent path or string that persists between runs without\n+/// the need to be mapped or unmapped. (This ensures we can serialize\n+/// them even in the absence of a tcx.)\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(HashStable_Generic)]\n+pub struct WorkProductId {\n+    hash: Fingerprint,\n+}\n+\n+impl WorkProductId {\n+    pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n+        let mut hasher = StableHasher::new();\n+        cgu_name.len().hash(&mut hasher);\n+        cgu_name.hash(&mut hasher);\n+        WorkProductId { hash: hasher.finish() }\n+    }\n+\n+    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n+        WorkProductId { hash: fingerprint }\n+    }\n+}"}, {"sha": "7352551559cf4835c4eb32288b51d4e114ac5e8f", "filename": "src/librustc_query_system/dep_graph/graph.rs", "status": "renamed", "additions": 116, "deletions": 164, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -1,32 +1,33 @@\n-use crate::ty::{self, TyCtxt};\n-use parking_lot::{Condvar, Mutex};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::QueryInvocationId;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n+use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n-use smallvec::SmallVec;\n+\n+use parking_lot::{Condvar, Mutex};\n+use smallvec::{smallvec, SmallVec};\n use std::collections::hash_map::Entry;\n use std::env;\n use std::hash::Hash;\n+use std::marker::PhantomData;\n use std::mem;\n use std::sync::atomic::Ordering::Relaxed;\n \n-use crate::ich::{Fingerprint, StableHashingContext, StableHashingContextProvider};\n-\n use super::debug::EdgeFilter;\n-use super::dep_node::{DepKind, DepNode, WorkProductId};\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n use super::safe::DepGraphSafe;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+use super::{DepContext, DepKind, DepNode, WorkProductId};\n+use crate::{HashStableContext, HashStableContextProvider};\n \n #[derive(Clone)]\n-pub struct DepGraph {\n-    data: Option<Lrc<DepGraphData>>,\n+pub struct DepGraph<K: DepKind> {\n+    data: Option<Lrc<DepGraphData<K>>>,\n \n     /// This field is used for assigning DepNodeIndices when running in\n     /// non-incremental mode. Even in non-incremental mode we make sure that\n@@ -65,16 +66,16 @@ impl DepNodeColor {\n     }\n }\n \n-struct DepGraphData {\n+struct DepGraphData<K: DepKind> {\n     /// The new encoding of the dependency graph, optimized for red/green\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n     /// current one anymore.\n-    current: CurrentDepGraph,\n+    current: CurrentDepGraph<K>,\n \n     /// The dep-graph from the previous compilation session. It contains all\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n-    previous: PreviousDepGraph,\n+    previous: PreviousDepGraph<K>,\n \n     colors: DepNodeColorMap,\n \n@@ -90,24 +91,24 @@ struct DepGraphData {\n     /// this map. We can later look for and extract that data.\n     previous_work_products: FxHashMap<WorkProductId, WorkProduct>,\n \n-    dep_node_debug: Lock<FxHashMap<DepNode, String>>,\n+    dep_node_debug: Lock<FxHashMap<DepNode<K>, String>>,\n }\n \n-pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Option<Fingerprint>\n+pub fn hash_result<HashCtxt, R>(hcx: &mut HashCtxt, result: &R) -> Option<Fingerprint>\n where\n-    R: for<'a> HashStable<StableHashingContext<'a>>,\n+    R: HashStable<HashCtxt>,\n {\n     let mut stable_hasher = StableHasher::new();\n     result.hash_stable(hcx, &mut stable_hasher);\n \n     Some(stable_hasher.finish())\n }\n \n-impl DepGraph {\n+impl<K: DepKind> DepGraph<K> {\n     pub fn new(\n-        prev_graph: PreviousDepGraph,\n+        prev_graph: PreviousDepGraph<K>,\n         prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n-    ) -> DepGraph {\n+    ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n         DepGraph {\n@@ -124,7 +125,7 @@ impl DepGraph {\n         }\n     }\n \n-    pub fn new_disabled() -> DepGraph {\n+    pub fn new_disabled() -> DepGraph<K> {\n         DepGraph { data: None, virtual_dep_node_index: Lrc::new(AtomicU32::new(0)) }\n     }\n \n@@ -134,7 +135,7 @@ impl DepGraph {\n         self.data.is_some()\n     }\n \n-    pub fn query(&self) -> DepGraphQuery {\n+    pub fn query(&self) -> DepGraphQuery<K> {\n         let data = self.data.as_ref().unwrap().current.data.lock();\n         let nodes: Vec<_> = data.iter().map(|n| n.node).collect();\n         let mut edges = Vec::new();\n@@ -150,9 +151,8 @@ impl DepGraph {\n \n     pub fn assert_ignored(&self) {\n         if let Some(..) = self.data {\n-            ty::tls::with_context_opt(|icx| {\n-                let icx = if let Some(icx) = icx { icx } else { return };\n-                assert!(icx.task_deps.is_none(), \"expected no task dependency tracking\");\n+            K::read_deps(|task_deps| {\n+                assert!(task_deps.is_none(), \"expected no task dependency tracking\");\n             })\n         }\n     }\n@@ -161,11 +161,7 @@ impl DepGraph {\n     where\n         OP: FnOnce() -> R,\n     {\n-        ty::tls::with_context(|icx| {\n-            let icx = ty::tls::ImplicitCtxt { task_deps: None, ..icx.clone() };\n-\n-            ty::tls::enter_context(&icx, |_| op())\n-        })\n+        K::with_deps(None, op)\n     }\n \n     /// Starts a new dep-graph task. Dep-graph tasks are specified\n@@ -195,16 +191,17 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/incremental-compilation.html\n-    pub fn with_task<'a, C, A, R>(\n+    pub fn with_task<H, C, A, R>(\n         &self,\n-        key: DepNode,\n+        key: DepNode<K>,\n         cx: C,\n         arg: A,\n         task: fn(C, A) -> R,\n-        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'a>,\n+        C: DepGraphSafe + HashStableContextProvider<H>,\n+        H: HashStableContext,\n     {\n         self.with_task_impl(\n             key,\n@@ -218,31 +215,33 @@ impl DepGraph {\n                     node: Some(_key),\n                     reads: SmallVec::new(),\n                     read_set: Default::default(),\n+                    phantom_data: PhantomData,\n                 })\n             },\n             |data, key, fingerprint, task| data.complete_task(key, task.unwrap(), fingerprint),\n             hash_result,\n         )\n     }\n \n-    fn with_task_impl<'a, C, A, R>(\n+    fn with_task_impl<H, C, A, R>(\n         &self,\n-        key: DepNode,\n+        key: DepNode<K>,\n         cx: C,\n         arg: A,\n         no_tcx: bool,\n         task: fn(C, A) -> R,\n-        create_task: fn(DepNode) -> Option<TaskDeps>,\n+        create_task: fn(DepNode<K>) -> Option<TaskDeps<K>>,\n         finish_task_and_alloc_depnode: fn(\n-            &CurrentDepGraph,\n-            DepNode,\n+            &CurrentDepGraph<K>,\n+            DepNode<K>,\n             Fingerprint,\n-            Option<TaskDeps>,\n+            Option<TaskDeps<K>>,\n         ) -> DepNodeIndex,\n-        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'a>,\n+        C: DepGraphSafe + HashStableContextProvider<H>,\n+        H: HashStableContext,\n     {\n         if let Some(ref data) = self.data {\n             let task_deps = create_task(key).map(Lock::new);\n@@ -257,12 +256,7 @@ impl DepGraph {\n             let result = if no_tcx {\n                 task(cx, arg)\n             } else {\n-                ty::tls::with_context(|icx| {\n-                    let icx =\n-                        ty::tls::ImplicitCtxt { task_deps: task_deps.as_ref(), ..icx.clone() };\n-\n-                    ty::tls::enter_context(&icx, |_| task(cx, arg))\n-                })\n+                K::with_deps(task_deps.as_ref(), || task(cx, arg))\n             };\n \n             let current_fingerprint = hash_result(&mut hcx, &result);\n@@ -274,7 +268,7 @@ impl DepGraph {\n                 task_deps.map(|lock| lock.into_inner()),\n             );\n \n-            let print_status = cfg!(debug_assertions) && hcx.sess().opts.debugging_opts.dep_tasks;\n+            let print_status = cfg!(debug_assertions) && hcx.debug_dep_tasks();\n \n             // Determine the color of the new DepNode.\n             if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n@@ -322,22 +316,16 @@ impl DepGraph {\n \n     /// Executes something within an \"anonymous\" task, that is, a task the\n     /// `DepNode` of which is determined by the list of inputs it read from.\n-    pub fn with_anon_task<OP, R>(&self, dep_kind: DepKind, op: OP) -> (R, DepNodeIndex)\n+    pub fn with_anon_task<OP, R>(&self, dep_kind: K, op: OP) -> (R, DepNodeIndex)\n     where\n         OP: FnOnce() -> R,\n     {\n         if let Some(ref data) = self.data {\n-            let (result, task_deps) = ty::tls::with_context(|icx| {\n-                let task_deps = Lock::new(TaskDeps::default());\n-\n-                let r = {\n-                    let icx = ty::tls::ImplicitCtxt { task_deps: Some(&task_deps), ..icx.clone() };\n+            let task_deps = Lock::new(TaskDeps::default());\n \n-                    ty::tls::enter_context(&icx, |_| op())\n-                };\n+            let result = K::with_deps(Some(&task_deps), op);\n+            let task_deps = task_deps.into_inner();\n \n-                (r, task_deps.into_inner())\n-            });\n             let dep_node_index = data.current.complete_anon_task(dep_kind, task_deps);\n             (result, dep_node_index)\n         } else {\n@@ -347,16 +335,17 @@ impl DepGraph {\n \n     /// Executes something within an \"eval-always\" task which is a task\n     /// that runs whenever anything changes.\n-    pub fn with_eval_always_task<'a, C, A, R>(\n+    pub fn with_eval_always_task<H, C, A, R>(\n         &self,\n-        key: DepNode,\n+        key: DepNode<K>,\n         cx: C,\n         arg: A,\n         task: fn(C, A) -> R,\n-        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'a>,\n+        C: DepGraphSafe + HashStableContextProvider<H>,\n+        H: HashStableContext,\n     {\n         self.with_task_impl(\n             key,\n@@ -371,14 +360,14 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn read(&self, v: DepNode) {\n+    pub fn read(&self, v: DepNode<K>) {\n         if let Some(ref data) = self.data {\n             let map = data.current.node_to_node_index.get_shard_by_value(&v).lock();\n             if let Some(dep_node_index) = map.get(&v).copied() {\n                 std::mem::drop(map);\n                 data.read_index(dep_node_index);\n             } else {\n-                bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n+                panic!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n             }\n         }\n     }\n@@ -391,7 +380,7 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn dep_node_index_of(&self, dep_node: &DepNode) -> DepNodeIndex {\n+    pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n         self.data\n             .as_ref()\n             .unwrap()\n@@ -405,7 +394,7 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n+    pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n         if let Some(ref data) = self.data {\n             data.current\n                 .node_to_node_index\n@@ -423,12 +412,12 @@ impl DepGraph {\n         data[dep_node_index].fingerprint\n     }\n \n-    pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+    pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n     #[inline]\n-    pub fn prev_dep_node_index_of(&self, dep_node: &DepNode) -> SerializedDepNodeIndex {\n+    pub fn prev_dep_node_index_of(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n         self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n     }\n \n@@ -445,7 +434,7 @@ impl DepGraph {\n     }\n \n     #[inline(always)]\n-    pub fn register_dep_node_debug_str<F>(&self, dep_node: DepNode, debug_str_gen: F)\n+    pub fn register_dep_node_debug_str<F>(&self, dep_node: DepNode<K>, debug_str_gen: F)\n     where\n         F: FnOnce() -> String,\n     {\n@@ -458,7 +447,7 @@ impl DepGraph {\n         dep_node_debug.borrow_mut().insert(dep_node, debug_str);\n     }\n \n-    pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n+    pub fn dep_node_debug_str(&self, dep_node: DepNode<K>) -> Option<String> {\n         self.data.as_ref()?.dep_node_debug.borrow().get(&dep_node).cloned()\n     }\n \n@@ -475,7 +464,7 @@ impl DepGraph {\n         }\n     }\n \n-    pub fn serialize(&self) -> SerializedDepGraph {\n+    pub fn serialize(&self) -> SerializedDepGraph<K> {\n         let data = self.data.as_ref().unwrap().current.data.lock();\n \n         let fingerprints: IndexVec<SerializedDepNodeIndex, _> =\n@@ -503,7 +492,7 @@ impl DepGraph {\n         SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data }\n     }\n \n-    pub fn node_color(&self, dep_node: &DepNode) -> Option<DepNodeColor> {\n+    pub fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n             if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n                 return data.colors.get(prev_index);\n@@ -521,10 +510,10 @@ impl DepGraph {\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n     /// a node index can be found for that node.\n-    pub fn try_mark_green_and_read(\n+    pub fn try_mark_green_and_read<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'_>,\n-        dep_node: &DepNode,\n+        tcx: Ctxt,\n+        dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         self.try_mark_green(tcx, dep_node).map(|(prev_index, dep_node_index)| {\n             debug_assert!(self.is_green(&dep_node));\n@@ -533,10 +522,10 @@ impl DepGraph {\n         })\n     }\n \n-    pub fn try_mark_green(\n+    pub fn try_mark_green<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'_>,\n-        dep_node: &DepNode,\n+        tcx: Ctxt,\n+        dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         debug_assert!(!dep_node.kind.is_eval_always());\n \n@@ -561,12 +550,12 @@ impl DepGraph {\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    fn try_mark_previous_green<'tcx>(\n+    fn try_mark_previous_green<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        data: &DepGraphData,\n+        tcx: Ctxt,\n+        data: &DepGraphData<K>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n-        dep_node: &DepNode,\n+        dep_node: &DepNode<K>,\n     ) -> Option<DepNodeIndex> {\n         debug!(\"try_mark_previous_green({:?}) - BEGIN\", dep_node);\n \n@@ -648,50 +637,6 @@ impl DepGraph {\n                             current_deps.push(node_index);\n                             continue;\n                         }\n-                    } else {\n-                        // FIXME: This match is just a workaround for incremental bugs and should\n-                        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n-                        // bug that must be fixed before removing this.\n-                        match dep_dep_node.kind {\n-                            DepKind::hir_owner\n-                            | DepKind::hir_owner_nodes\n-                            | DepKind::CrateMetadata => {\n-                                if let Some(def_id) = dep_dep_node.extract_def_id(tcx) {\n-                                    if def_id_corresponds_to_hir_dep_node(tcx, def_id) {\n-                                        if dep_dep_node.kind == DepKind::CrateMetadata {\n-                                            // The `DefPath` has corresponding node,\n-                                            // and that node should have been marked\n-                                            // either red or green in `data.colors`.\n-                                            bug!(\n-                                                \"DepNode {:?} should have been \\\n-                                             pre-marked as red or green but wasn't.\",\n-                                                dep_dep_node\n-                                            );\n-                                        }\n-                                    } else {\n-                                        // This `DefPath` does not have a\n-                                        // corresponding `DepNode` (e.g. a\n-                                        // struct field), and the ` DefPath`\n-                                        // collided with the `DefPath` of a\n-                                        // proper item that existed in the\n-                                        // previous compilation session.\n-                                        //\n-                                        // Since the given `DefPath` does not\n-                                        // denote the item that previously\n-                                        // existed, we just fail to mark green.\n-                                        return None;\n-                                    }\n-                                } else {\n-                                    // If the node does not exist anymore, we\n-                                    // just fail to mark green.\n-                                    return None;\n-                                }\n-                            }\n-                            _ => {\n-                                // For other kinds of nodes it's OK to be\n-                                // forced.\n-                            }\n-                        }\n                     }\n \n                     // We failed to mark it green, so we try to force the query.\n@@ -700,7 +645,7 @@ impl DepGraph {\n                             dependency {:?}\",\n                         dep_node, dep_dep_node\n                     );\n-                    if crate::ty::query::force_from_dep_node(tcx, dep_dep_node) {\n+                    if tcx.try_force_from_dep_node(dep_dep_node) {\n                         let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n                         match dep_dep_node_color {\n@@ -721,8 +666,8 @@ impl DepGraph {\n                                 return None;\n                             }\n                             None => {\n-                                if !tcx.sess.has_errors_or_delayed_span_bugs() {\n-                                    bug!(\n+                                if !tcx.has_errors_or_delayed_span_bugs() {\n+                                    panic!(\n                                         \"try_mark_previous_green() - Forcing the DepNode \\\n                                           should have set its color\"\n                                     )\n@@ -779,7 +724,7 @@ impl DepGraph {\n \n         // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere\n         // Maybe store a list on disk and encode this fact in the DepNodeState\n-        let diagnostics = tcx.queries.on_disk_cache.load_diagnostics(tcx, prev_dep_node_index);\n+        let diagnostics = tcx.load_diagnostics(prev_dep_node_index);\n \n         #[cfg(not(parallel_compiler))]\n         debug_assert!(\n@@ -805,10 +750,10 @@ impl DepGraph {\n     /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n-    fn emit_diagnostics<'tcx>(\n+    fn emit_diagnostics<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        data: &DepGraphData,\n+        tcx: Ctxt,\n+        data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         diagnostics: Vec<Diagnostic>,\n@@ -827,9 +772,9 @@ impl DepGraph {\n             mem::drop(emitting);\n \n             // Promote the previous diagnostics to the current session.\n-            tcx.queries.on_disk_cache.store_diagnostics(dep_node_index, diagnostics.clone().into());\n+            tcx.store_diagnostics(dep_node_index, diagnostics.clone().into());\n \n-            let handle = tcx.sess.diagnostic();\n+            let handle = tcx.diagnostic();\n \n             for diagnostic in diagnostics {\n                 handle.emit_diagnostic(&diagnostic);\n@@ -858,7 +803,7 @@ impl DepGraph {\n \n     // Returns true if the given node has been marked as green during the\n     // current compilation session. Used in various assertions\n-    pub fn is_green(&self, dep_node: &DepNode) -> bool {\n+    pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n         self.node_color(dep_node).map(|c| c.is_green()).unwrap_or(false)\n     }\n \n@@ -870,15 +815,15 @@ impl DepGraph {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions(&self, tcx: TyCtxt<'_>) {\n-        let _prof_timer = tcx.prof.generic_activity(\"incr_comp_query_cache_promotion\");\n+    pub fn exec_cache_promotions<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n+        let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n         let data = self.data.as_ref().unwrap();\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n                     let dep_node = data.previous.index_to_node(prev_index);\n-                    dep_node.try_load_from_on_disk_cache(tcx);\n+                    tcx.try_load_from_on_disk_cache(&dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {\n                     // We can skip red nodes because a node can only be marked\n@@ -895,11 +840,6 @@ impl DepGraph {\n     }\n }\n \n-fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    def_id.index == hir_id.owner.local_def_index\n-}\n-\n /// A \"work product\" is an intermediate result that we save into the\n /// incremental directory for later re-use. The primary example are\n /// the object files that we save for each partition at code\n@@ -946,8 +886,8 @@ pub enum WorkProductFileKind {\n }\n \n #[derive(Clone)]\n-struct DepNodeData {\n-    node: DepNode,\n+struct DepNodeData<K> {\n+    node: DepNode<K>,\n     edges: EdgesVec,\n     fingerprint: Fingerprint,\n }\n@@ -967,9 +907,9 @@ struct DepNodeData {\n /// The only operation that must manipulate both locks is adding new nodes, in which case\n /// we first acquire the `node_to_node_index` lock and then, once a new node is to be inserted,\n /// acquire the lock on `data.`\n-pub(super) struct CurrentDepGraph {\n-    data: Lock<IndexVec<DepNodeIndex, DepNodeData>>,\n-    node_to_node_index: Sharded<FxHashMap<DepNode, DepNodeIndex>>,\n+pub(super) struct CurrentDepGraph<K> {\n+    data: Lock<IndexVec<DepNodeIndex, DepNodeData<K>>>,\n+    node_to_node_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n@@ -995,8 +935,8 @@ pub(super) struct CurrentDepGraph {\n     total_duplicate_read_count: AtomicU64,\n }\n \n-impl CurrentDepGraph {\n-    fn new(prev_graph_node_count: usize) -> CurrentDepGraph {\n+impl<K: DepKind> CurrentDepGraph<K> {\n+    fn new(prev_graph_node_count: usize) -> CurrentDepGraph<K> {\n         use std::time::{SystemTime, UNIX_EPOCH};\n \n         let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n@@ -1008,7 +948,7 @@ impl CurrentDepGraph {\n             match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n                 Ok(s) => match EdgeFilter::new(&s) {\n                     Ok(f) => Some(f),\n-                    Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+                    Err(err) => panic!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n                 },\n                 Err(_) => None,\n             }\n@@ -1039,14 +979,14 @@ impl CurrentDepGraph {\n \n     fn complete_task(\n         &self,\n-        node: DepNode,\n-        task_deps: TaskDeps,\n+        node: DepNode<K>,\n+        task_deps: TaskDeps<K>,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n         self.alloc_node(node, task_deps.reads, fingerprint)\n     }\n \n-    fn complete_anon_task(&self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n+    fn complete_anon_task(&self, kind: K, task_deps: TaskDeps<K>) -> DepNodeIndex {\n         debug_assert!(!kind.is_eval_always());\n \n         let mut hasher = StableHasher::new();\n@@ -1072,7 +1012,7 @@ impl CurrentDepGraph {\n \n     fn alloc_node(\n         &self,\n-        dep_node: DepNode,\n+        dep_node: DepNode<K>,\n         edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n@@ -1084,7 +1024,7 @@ impl CurrentDepGraph {\n \n     fn intern_node(\n         &self,\n-        dep_node: DepNode,\n+        dep_node: DepNode<K>,\n         edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n@@ -1101,12 +1041,11 @@ impl CurrentDepGraph {\n     }\n }\n \n-impl DepGraphData {\n+impl<K: DepKind> DepGraphData<K> {\n     #[inline(never)]\n     fn read_index(&self, source: DepNodeIndex) {\n-        ty::tls::with_context_opt(|icx| {\n-            let icx = if let Some(icx) = icx { icx } else { return };\n-            if let Some(task_deps) = icx.task_deps {\n+        K::read_deps(|task_deps| {\n+            if let Some(task_deps) = task_deps {\n                 let mut task_deps = task_deps.lock();\n                 let task_deps = &mut *task_deps;\n                 if cfg!(debug_assertions) {\n@@ -1135,7 +1074,7 @@ impl DepGraphData {\n                             if let Some(ref forbidden_edge) = self.current.forbidden_edge {\n                                 let source = data[source].node;\n                                 if forbidden_edge.test(&source, &target) {\n-                                    bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n+                                    panic!(\"forbidden edge {:?} -> {:?} created\", source, target)\n                                 }\n                             }\n                         }\n@@ -1151,12 +1090,25 @@ impl DepGraphData {\n /// The capacity of the `reads` field `SmallVec`\n const TASK_DEPS_READS_CAP: usize = 8;\n type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;\n-#[derive(Default)]\n-pub struct TaskDeps {\n+\n+pub struct TaskDeps<K> {\n     #[cfg(debug_assertions)]\n-    node: Option<DepNode>,\n+    node: Option<DepNode<K>>,\n     reads: EdgesVec,\n     read_set: FxHashSet<DepNodeIndex>,\n+    phantom_data: PhantomData<DepNode<K>>,\n+}\n+\n+impl<K> Default for TaskDeps<K> {\n+    fn default() -> Self {\n+        Self {\n+            #[cfg(debug_assertions)]\n+            node: None,\n+            reads: EdgesVec::new(),\n+            read_set: FxHashSet::default(),\n+            phantom_data: PhantomData,\n+        }\n+    }\n }\n \n // A data structure that stores Option<DepNodeColor> values as a contiguous", "previous_filename": "src/librustc/dep_graph/graph.rs"}, {"sha": "825b341cd146d51889bcc71bb1ffd7727204d5c0", "filename": "src/librustc_query_system/dep_graph/mod.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -0,0 +1,75 @@\n+pub mod debug;\n+mod dep_node;\n+mod graph;\n+mod prev;\n+mod query;\n+mod safe;\n+mod serialized;\n+\n+pub use dep_node::{DepNode, DepNodeParams, WorkProductId};\n+pub use graph::WorkProductFileKind;\n+pub use graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n+pub use prev::PreviousDepGraph;\n+pub use query::DepGraphQuery;\n+pub use safe::AssertDepGraphSafe;\n+pub use safe::DepGraphSafe;\n+pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+\n+use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::Diagnostic;\n+\n+use std::fmt;\n+use std::hash::Hash;\n+\n+pub trait DepContext: Copy {\n+    type DepKind: self::DepKind;\n+    type StableHashingContext: crate::HashStableContext;\n+\n+    /// Create a hashing context for hashing new results.\n+    fn create_stable_hashing_context(&self) -> Self::StableHashingContext;\n+\n+    /// Try to force a dep node to execute and see if it's green.\n+    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n+\n+    /// Return whether the current session is tainted by errors.\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool;\n+\n+    /// Return the diagnostic handler.\n+    fn diagnostic(&self) -> &rustc_errors::Handler;\n+\n+    /// Load data from the on-disk cache.\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n+\n+    /// Load diagnostics associated to the node in the previous session.\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic>;\n+\n+    /// Register diagnostics for the given node, for use in next session.\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n+\n+    /// Access the profiler.\n+    fn profiler(&self) -> &SelfProfilerRef;\n+}\n+\n+/// Describe the different families of dependency nodes.\n+pub trait DepKind: Copy + fmt::Debug + Eq + Ord + Hash {\n+    /// Return whether this kind always require evaluation.\n+    fn is_eval_always(&self) -> bool;\n+\n+    /// Return whether this kind requires additional parameters to be executed.\n+    fn has_params(&self) -> bool;\n+\n+    /// Implementation of `std::fmt::Debug` for `DepNode`.\n+    fn debug_node(node: &DepNode<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result;\n+\n+    /// Execute the operation with provided dependencies.\n+    fn with_deps<OP, R>(deps: Option<&Lock<TaskDeps<Self>>>, op: OP) -> R\n+    where\n+        OP: FnOnce() -> R;\n+\n+    /// Access dependencies from current implicit context.\n+    fn read_deps<OP>(op: OP) -> ()\n+    where\n+        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps<Self>>>) -> ();\n+}"}, {"sha": "5cba64cac4b3449eb26eddc6c053c460444f6aea", "filename": "src/librustc_query_system/dep_graph/prev.rs", "status": "renamed", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -1,16 +1,22 @@\n-use super::dep_node::DepNode;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n-use crate::ich::Fingerprint;\n+use super::{DepKind, DepNode};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, Default)]\n-pub struct PreviousDepGraph {\n-    data: SerializedDepGraph,\n-    index: FxHashMap<DepNode, SerializedDepNodeIndex>,\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct PreviousDepGraph<K: DepKind> {\n+    data: SerializedDepGraph<K>,\n+    index: FxHashMap<DepNode<K>, SerializedDepNodeIndex>,\n }\n \n-impl PreviousDepGraph {\n-    pub fn new(data: SerializedDepGraph) -> PreviousDepGraph {\n+impl<K: DepKind> Default for PreviousDepGraph<K> {\n+    fn default() -> Self {\n+        PreviousDepGraph { data: Default::default(), index: Default::default() }\n+    }\n+}\n+\n+impl<K: DepKind> PreviousDepGraph<K> {\n+    pub fn new(data: SerializedDepGraph<K>) -> PreviousDepGraph<K> {\n         let index: FxHashMap<_, _> =\n             data.nodes.iter_enumerated().map(|(idx, &dep_node)| (dep_node, idx)).collect();\n         PreviousDepGraph { data, index }\n@@ -25,22 +31,22 @@ impl PreviousDepGraph {\n     }\n \n     #[inline]\n-    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode {\n+    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode<K> {\n         self.data.nodes[dep_node_index]\n     }\n \n     #[inline]\n-    pub fn node_to_index(&self, dep_node: &DepNode) -> SerializedDepNodeIndex {\n+    pub fn node_to_index(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n         self.index[dep_node]\n     }\n \n     #[inline]\n-    pub fn node_to_index_opt(&self, dep_node: &DepNode) -> Option<SerializedDepNodeIndex> {\n+    pub fn node_to_index_opt(&self, dep_node: &DepNode<K>) -> Option<SerializedDepNodeIndex> {\n         self.index.get(dep_node).cloned()\n     }\n \n     #[inline]\n-    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+    pub fn fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.index.get(dep_node).map(|&node_index| self.data.fingerprints[node_index])\n     }\n ", "previous_filename": "src/librustc/dep_graph/prev.rs"}, {"sha": "4a4283b2a0cbbd05f8083fdb4ba5e038db37019b", "filename": "src/librustc_query_system/dep_graph/query.rs", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -3,15 +3,15 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n \n-use super::DepNode;\n+use super::{DepKind, DepNode};\n \n-pub struct DepGraphQuery {\n-    pub graph: Graph<DepNode, ()>,\n-    pub indices: FxHashMap<DepNode, NodeIndex>,\n+pub struct DepGraphQuery<K> {\n+    pub graph: Graph<DepNode<K>, ()>,\n+    pub indices: FxHashMap<DepNode<K>, NodeIndex>,\n }\n \n-impl DepGraphQuery {\n-    pub fn new(nodes: &[DepNode], edges: &[(DepNode, DepNode)]) -> DepGraphQuery {\n+impl<K: DepKind> DepGraphQuery<K> {\n+    pub fn new(nodes: &[DepNode<K>], edges: &[(DepNode<K>, DepNode<K>)]) -> DepGraphQuery<K> {\n         let mut graph = Graph::with_capacity(nodes.len(), edges.len());\n         let mut indices = FxHashMap::default();\n         for node in nodes {\n@@ -27,15 +27,15 @@ impl DepGraphQuery {\n         DepGraphQuery { graph, indices }\n     }\n \n-    pub fn contains_node(&self, node: &DepNode) -> bool {\n+    pub fn contains_node(&self, node: &DepNode<K>) -> bool {\n         self.indices.contains_key(&node)\n     }\n \n-    pub fn nodes(&self) -> Vec<&DepNode> {\n+    pub fn nodes(&self) -> Vec<&DepNode<K>> {\n         self.graph.all_nodes().iter().map(|n| &n.data).collect()\n     }\n \n-    pub fn edges(&self) -> Vec<(&DepNode, &DepNode)> {\n+    pub fn edges(&self) -> Vec<(&DepNode<K>, &DepNode<K>)> {\n         self.graph\n             .all_edges()\n             .iter()\n@@ -44,7 +44,7 @@ impl DepGraphQuery {\n             .collect()\n     }\n \n-    fn reachable_nodes(&self, node: &DepNode, direction: Direction) -> Vec<&DepNode> {\n+    fn reachable_nodes(&self, node: &DepNode<K>, direction: Direction) -> Vec<&DepNode<K>> {\n         if let Some(&index) = self.indices.get(node) {\n             self.graph.depth_traverse(index, direction).map(|s| self.graph.node_data(s)).collect()\n         } else {\n@@ -54,17 +54,17 @@ impl DepGraphQuery {\n \n     /// All nodes reachable from `node`. In other words, things that\n     /// will have to be recomputed if `node` changes.\n-    pub fn transitive_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n+    pub fn transitive_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         self.reachable_nodes(node, OUTGOING)\n     }\n \n     /// All nodes that can reach `node`.\n-    pub fn transitive_predecessors(&self, node: &DepNode) -> Vec<&DepNode> {\n+    pub fn transitive_predecessors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         self.reachable_nodes(node, INCOMING)\n     }\n \n     /// Just the outgoing edges from `node`.\n-    pub fn immediate_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n+    pub fn immediate_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.successor_nodes(index).map(|s| self.graph.node_data(s)).collect()\n         } else {", "previous_filename": "src/librustc/dep_graph/query.rs"}, {"sha": "7bba348f8841f70c46019f9aa8ba64612f9c3190", "filename": "src/librustc_query_system/dep_graph/safe.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -0,0 +1,51 @@\n+//! The `DepGraphSafe` trait\n+\n+use rustc_ast::ast::NodeId;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::BodyId;\n+\n+/// The `DepGraphSafe` trait is used to specify what kinds of values\n+/// are safe to \"leak\" into a task. The idea is that this should be\n+/// only be implemented for things like the tcx as well as various id\n+/// types, which will create reads in the dep-graph whenever the trait\n+/// loads anything that might depend on the input program.\n+pub trait DepGraphSafe {}\n+\n+/// A `BodyId` on its own doesn't give access to any particular state.\n+/// You must fetch the state from the various maps or generate\n+/// on-demand queries, all of which create reads.\n+impl DepGraphSafe for BodyId {}\n+\n+/// A `NodeId` on its own doesn't give access to any particular state.\n+/// You must fetch the state from the various maps or generate\n+/// on-demand queries, all of which create reads.\n+impl DepGraphSafe for NodeId {}\n+\n+/// A `DefId` on its own doesn't give access to any particular state.\n+/// You must fetch the state from the various maps or generate\n+/// on-demand queries, all of which create reads.\n+impl DepGraphSafe for DefId {}\n+\n+/// Tuples make it easy to build up state.\n+impl<A, B> DepGraphSafe for (A, B)\n+where\n+    A: DepGraphSafe,\n+    B: DepGraphSafe,\n+{\n+}\n+\n+/// Shared ref to dep-graph-safe stuff should still be dep-graph-safe.\n+impl<'a, A> DepGraphSafe for &'a A where A: DepGraphSafe {}\n+\n+/// Mut ref to dep-graph-safe stuff should still be dep-graph-safe.\n+impl<'a, A> DepGraphSafe for &'a mut A where A: DepGraphSafe {}\n+\n+/// No data here! :)\n+impl DepGraphSafe for () {}\n+\n+/// A convenient override that lets you pass arbitrary state into a\n+/// task. Every use should be accompanied by a comment explaining why\n+/// it makes sense (or how it could be refactored away in the future).\n+pub struct AssertDepGraphSafe<T>(pub T);\n+\n+impl<T> DepGraphSafe for AssertDepGraphSafe<T> {}"}, {"sha": "4a89da23ea6a59239ff9a99834d9bc029e51d2bf", "filename": "src/librustc_query_system/dep_graph/serialized.rs", "status": "renamed", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -1,18 +1,18 @@\n //! The data that we will serialize and deserialize.\n \n-use crate::dep_graph::DepNode;\n-use crate::ich::Fingerprint;\n+use super::{DepKind, DepNode};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_index::vec::IndexVec;\n \n rustc_index::newtype_index! {\n     pub struct SerializedDepNodeIndex { .. }\n }\n \n /// Data for use when recompiling the **current crate**.\n-#[derive(Debug, RustcEncodable, RustcDecodable, Default)]\n-pub struct SerializedDepGraph {\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepGraph<K: DepKind> {\n     /// The set of all DepNodes in the graph\n-    pub nodes: IndexVec<SerializedDepNodeIndex, DepNode>,\n+    pub nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>>,\n     /// The set of all Fingerprints in the graph. Each Fingerprint corresponds to\n     /// the DepNode at the same index in the nodes vector.\n     pub fingerprints: IndexVec<SerializedDepNodeIndex, Fingerprint>,\n@@ -25,7 +25,18 @@ pub struct SerializedDepGraph {\n     pub edge_list_data: Vec<SerializedDepNodeIndex>,\n }\n \n-impl SerializedDepGraph {\n+impl<K: DepKind> Default for SerializedDepGraph<K> {\n+    fn default() -> Self {\n+        SerializedDepGraph {\n+            nodes: Default::default(),\n+            fingerprints: Default::default(),\n+            edge_list_indices: Default::default(),\n+            edge_list_data: Default::default(),\n+        }\n+    }\n+}\n+\n+impl<K: DepKind> SerializedDepGraph<K> {\n     #[inline]\n     pub fn edge_targets_from(&self, source: SerializedDepNodeIndex) -> &[SerializedDepNodeIndex] {\n         let targets = self.edge_list_indices[source];", "previous_filename": "src/librustc/dep_graph/serialized.rs"}, {"sha": "ef4886828c41167dc5358c8dafcfe52ed831e750", "filename": "src/librustc_query_system/lib.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da25d9faf12a58ba05e4d95bf656625071e9eca/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=9da25d9faf12a58ba05e4d95bf656625071e9eca", "patch": "@@ -0,0 +1,32 @@\n+#![feature(const_fn)]\n+#![feature(const_if_match)]\n+#![feature(const_panic)]\n+#![feature(core_intrinsics)]\n+#![feature(specialization)]\n+#![feature(stmt_expr_attributes)]\n+\n+#[macro_use]\n+extern crate log;\n+\n+pub mod dep_graph;\n+\n+pub trait HashStableContext {\n+    fn debug_dep_tasks(&self) -> bool;\n+}\n+\n+/// Something that can provide a stable hashing context.\n+pub trait HashStableContextProvider<Ctxt> {\n+    fn get_stable_hashing_context(&self) -> Ctxt;\n+}\n+\n+impl<Ctxt, T: HashStableContextProvider<Ctxt>> HashStableContextProvider<Ctxt> for &T {\n+    fn get_stable_hashing_context(&self) -> Ctxt {\n+        (**self).get_stable_hashing_context()\n+    }\n+}\n+\n+impl<Ctxt, T: HashStableContextProvider<Ctxt>> HashStableContextProvider<Ctxt> for &mut T {\n+    fn get_stable_hashing_context(&self) -> Ctxt {\n+        (**self).get_stable_hashing_context()\n+    }\n+}"}]}