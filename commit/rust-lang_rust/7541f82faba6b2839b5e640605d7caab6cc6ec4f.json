{"sha": "7541f82faba6b2839b5e640605d7caab6cc6ec4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NDFmODJmYWJhNmIyODM5YjVlNjQwNjA1ZDdjYWFiNmNjNmVjNGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T18:27:03Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-08T18:27:03Z"}, "message": "Fix dead links in the guide and reorganize", "tree": {"sha": "423d2f21a5fd924aa77a1c613ca4faaa79fa7794", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/423d2f21a5fd924aa77a1c613ca4faaa79fa7794"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7541f82faba6b2839b5e640605d7caab6cc6ec4f", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7541f82faba6b2839b5e640605d7caab6cc6ec4f", "html_url": "https://github.com/rust-lang/rust/commit/7541f82faba6b2839b5e640605d7caab6cc6ec4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7541f82faba6b2839b5e640605d7caab6cc6ec4f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "483fca9fa55d0c1f936412d577424916f20d94a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/483fca9fa55d0c1f936412d577424916f20d94a3", "html_url": "https://github.com/rust-lang/rust/commit/483fca9fa55d0c1f936412d577424916f20d94a3"}], "stats": {"total": 781, "additions": 112, "deletions": 669}, "files": [{"sha": "1104c3eb6dbb5040fcd6c8dd0a7e53d590325431", "filename": "mk/docs.mk", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -275,9 +275,8 @@ endif\n docs: $(DOC_TARGETS)\n compiler-docs: $(COMPILER_DOC_TARGETS)\n \n-trpl: tmp/trpl.ok\n+trpl: doc/book/index.html\n \n-tmp/trpl.ok: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/trpl/*.md)\n+doc/book/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/trpl/*.md)\n \t$(Q)rm -rf doc/book\n \t$(Q)$(RUSTBOOK) build $(S)src/doc/trpl doc/book\n-\t$(Q)touch $@"}, {"sha": "c8c4beb11531bc2c65dba186f7e6ba687e5b9ec0", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -156,8 +156,8 @@ endef\n \n $(foreach doc,$(DOCS), \\\n   $(eval $(call DOCTEST,md-$(doc),$(S)src/doc/$(doc).md)))\n-$(foreach file,$(wildcard $(S)src/doc/trpl/src/*), \\\n-  $(eval $(call DOCTEST,$(file:$(S)src/doc/trpl/src/%.md=trpl-%),$(file))))\n+$(foreach file,$(wildcard $(S)src/doc/trpl/*.md), \\\n+  $(eval $(call DOCTEST,$(file:$(S)src/doc/trpl/%.md=trpl-%),$(file))))\n \n ######################################################################\n # Main test targets"}, {"sha": "1a61c6d216b68054cda09231b979b8cfe7bdaa1b", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,35 +1,36 @@\n # Summary\n \n-* [I: The Basics](src/basic.md)\n-    * [Installing Rust](src/installing-rust.md)\n-    * [Hello, world!](src/hello-world.md)\n-    * [Hello, Cargo!](src/hello-cargo.md)\n-    * [Variable Bindings](src/variable-bindings.md)\n-    * [If](src/if.md)\n-    * [Functions](src/functions.md)\n-    * [Comments](src/comments.md)\n-    * [Compound Data Types](src/compound-data-types.md)\n-    * [Match](src/match.md)\n-    * [Looping](src/looping.md)\n-    * [Strings](src/strings.md)\n-    * [Arrays, Vectors, and Slices](src/arrays-vectors-and-slices.md)\n-    * [Standard Input](src/standard-input.md)\n-    * [Guessing Game](src/guessing-game.md)\n-* [II: Intermedite Rust](src/intermediate.md)\n-    * [Crates and Modules](src/crates-and-modules.md)\n-    * [Testing](src/testing.md)\n-    * [Pointers](src/pointers.md)\n-    * [Patterns](src/patterns.md)\n-    * [Method Syntax](src/method-syntax.md)\n-    * [Closures](src/closures.md)\n-    * [Iterators](src/iterators.md)\n-    * [Generics](src/generics.md)\n-    * [Traits](src/traits.md)\n-    * [Tasks](src/tasks.md)\n-    * [Error Handling](src/error-handling.md)\n-* [III: Advanced Topics](src/advanced.md)\n-    * [FFI](src/ffi.md)\n-    * [Unsafe Code](src/unsafe.md)\n-    * [Macros](src/macros.md)\n-    * [Compiler Plugins](src/plugins.md)\n-* [Conclusion](src/conclusion.md)\n+* [I: The Basics](basic.md)\n+    * [Installing Rust](installing-rust.md)\n+    * [Hello, world!](hello-world.md)\n+    * [Hello, Cargo!](hello-cargo.md)\n+    * [Variable Bindings](variable-bindings.md)\n+    * [If](if.md)\n+    * [Functions](functions.md)\n+    * [Comments](comments.md)\n+    * [Compound Data Types](compound-data-types.md)\n+    * [Match](match.md)\n+    * [Looping](looping.md)\n+    * [Strings](strings.md)\n+    * [Arrays, Vectors, and Slices](arrays-vectors-and-slices.md)\n+    * [Standard Input](standard-input.md)\n+    * [Guessing Game](guessing-game.md)\n+* [II: Intermediate Rust](intermediate.md)\n+    * [Crates and Modules](crates-and-modules.md)\n+    * [Testing](testing.md)\n+    * [Pointers](pointers.md)\n+    * [Ownership](ownership.md)\n+    * [Patterns](patterns.md)\n+    * [Method Syntax](method-syntax.md)\n+    * [Closures](closures.md)\n+    * [Iterators](iterators.md)\n+    * [Generics](generics.md)\n+    * [Traits](traits.md)\n+    * [Tasks](tasks.md)\n+    * [Error Handling](error-handling.md)\n+* [III: Advanced Topics](advanced.md)\n+    * [FFI](ffi.md)\n+    * [Unsafe Code](unsafe.md)\n+    * [Macros](macros.md)\n+    * [Compiler Plugins](plugins.md)\n+* [Conclusion](conclusion.md)"}, {"sha": "138db523b9a21ff6cb030672a72319f1698ac82b", "filename": "src/doc/trpl/advanced.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fadvanced.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fadvanced.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/advanced.md"}, {"sha": "24d60dd2e4e3c1395be26564fef29943bdeacad7", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Arrays, Vectors, and Slices\n+% Arrays, Vectors, and Slices\n \n Like many programming languages, Rust has list types to represent a sequence of\n things. The most basic is the **array**, a fixed-size list of elements of the\n@@ -48,7 +48,7 @@ errant access is the source of many bugs in other systems programming\n languages.\n \n A **vector** is a dynamic or \"growable\" array, implemented as the standard\n-library type [`Vec<T>`](std/vec/) (we'll talk about what the `<T>` means\n+library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means\n later). Vectors are to arrays what `String` is to `&str`. You can create them\n with the `vec!` macro:\n ", "previous_filename": "src/doc/trpl/src/arrays-vectors-and-slices.md"}, {"sha": "087121d0e7dc3d30e35240165ff9090bd7fcd452", "filename": "src/doc/trpl/basic.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fbasic.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fbasic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbasic.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/basic.md"}, {"sha": "6413b90ee71e00ffa5b0d437a6c8030f9774bb88", "filename": "src/doc/trpl/closures.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Closures\n+% Closures\n \n So far, we've made lots of functions in Rust, but we've given them all names.\n Rust also allows us to create anonymous functions. Rust's anonymous", "previous_filename": "src/doc/trpl/src/closures.md"}, {"sha": "f02c1ad9a183e8672326497761b0d025b2027f4d", "filename": "src/doc/trpl/comments.md", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcomments.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Comments\n+% Comments\n \n Now that we have some functions, it's a good idea to learn about comments.\n Comments are notes that you leave to other programmers to help explain things\n@@ -42,5 +42,5 @@ fn hello(name: &str) {\n When writing doc comments, adding sections for any arguments, return values,\n and providing some examples of usage is very, very helpful.\n \n-You can use the [`rustdoc`](rustdoc.html) tool to generate HTML documentation\n+You can use the [`rustdoc`](../rustdoc.html) tool to generate HTML documentation\n from these doc comments.", "previous_filename": "src/doc/trpl/src/comments.md"}, {"sha": "b80d248bc41d1b6059ceb2b8d0fb9fc1a0302351", "filename": "src/doc/trpl/compound-data-types.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Compound Data Types\n+% Compound Data Types\n \n Rust, like many programming languages, has a number of different data types\n that are built-in. You've already done some simple work with integers and", "previous_filename": "src/doc/trpl/src/compound-data-types.md"}, {"sha": "0472787e948d96ff7f720e890e666d74005a3862", "filename": "src/doc/trpl/conclusion.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fconclusion.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fconclusion.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconclusion.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/conclusion.md"}, {"sha": "ba825c2c9a8008e6ea22cda292cd213269ca0d0f", "filename": "src/doc/trpl/crates-and-modules.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/crates-and-modules.md"}, {"sha": "98b46511f04584fbfff7f5d6be4b11a8ed28b40e", "filename": "src/doc/trpl/error-handling.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/error-handling.md"}, {"sha": "1f12c05f37e34475d9f892eae3274c1f1220343e", "filename": "src/doc/trpl/ffi.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/ffi.md"}, {"sha": "e3827d962c3313fe9dbc90d54e6987642e1661b2", "filename": "src/doc/trpl/functions.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Functions\n+% Functions\n \n You've already seen one function so far, the `main` function:\n ", "previous_filename": "src/doc/trpl/src/functions.md"}, {"sha": "137b66ea15af0d213e31ae8d0f2a5e63cbfd6f4b", "filename": "src/doc/trpl/generics.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/generics.md"}, {"sha": "2847964f15f5018e427f31869dadde16570ab728", "filename": "src/doc/trpl/guessing-game.md", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Guessing Game\n+% Guessing Game\n \n Okay! We've got the basics of Rust down. Let's write a bigger program.\n \n@@ -108,12 +108,12 @@ we do know that Rust has random number generation, but we don't know how to\n use it.\n \n Enter the docs. Rust has a page specifically to document the standard library.\n-You can find that page [here](std/index.html). There's a lot of information on\n+You can find that page [here](../std/index.html). There's a lot of information on\n that page, but the best part is the search bar. Right up at the top, there's\n a box that you can enter in a search term. The search is pretty primitive\n right now, but is getting better all the time. If you type 'random' in that\n-box, the page will update to [this one](std/index.html?search=random). The very\n-first result is a link to [`std::rand::random`](std/rand/fn.random.html). If we\n+box, the page will update to [this one](../std/index.html?search=random). The very\n+first result is a link to [`std::rand::random`](../std/rand/fn.random.html). If we\n click on that result, we'll be taken to its documentation page.\n \n This page shows us a few things: the type signature of the function, some", "previous_filename": "src/doc/trpl/src/guessing-game.md"}, {"sha": "d8acd95b59d8fcd99934b29f945b59315e62d4bf", "filename": "src/doc/trpl/hello-cargo.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Hello, Cargo!\n+% Hello, Cargo!\n \n [Cargo](http://crates.io) is a tool that Rustaceans use to help manage their\n Rust projects. Cargo is currently in an alpha state, just like Rust, and so it", "previous_filename": "src/doc/trpl/src/hello-cargo.md"}, {"sha": "f9cc1ebf0bf13d2ee2c8e1c50b0ab1bf56491e7a", "filename": "src/doc/trpl/hello-world.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fhello-world.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fhello-world.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-world.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Hello, world!\n+% Hello, world!\n \n Now that you have Rust installed, let's write your first Rust program. It's\n traditional to make your first program in any new language one that prints the", "previous_filename": "src/doc/trpl/src/hello-world.md"}, {"sha": "6f81a27b2b7d3031ab4c10bd83191ad5bea3855c", "filename": "src/doc/trpl/if.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# `if`\n+% `if`\n \n Rust's take on `if` is not particularly complex, but it's much more like the\n `if` you'll find in a dynamically typed language than in a more traditional", "previous_filename": "src/doc/trpl/src/if.md"}, {"sha": "5893b51a4208cb2122cbc48f3c585333dd1bbab2", "filename": "src/doc/trpl/installing-rust.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Installing Rust\n+% Installing Rust\n \n The first step to using Rust is to install it! There are a number of ways to\n install Rust, but the easiest is to use the `rustup` script. If you're on", "previous_filename": "src/doc/trpl/src/installing-rust.md"}, {"sha": "73370a32231ebec4d452ed56f65343959ccf6891", "filename": "src/doc/trpl/intermediate.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fintermediate.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fintermediate.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fintermediate.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/intermediate.md"}, {"sha": "a773b7329dbaf376521b83fc0155eeedc148b824", "filename": "src/doc/trpl/iterators.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -336,4 +336,4 @@ can help you with. There are a number of really useful iterators, and you can\n write your own as well. Iterators provide a safe, efficient way to manipulate\n all kinds of lists. They're a little unusual at first, but if you play with\n them, you'll get hooked. For a full list of the different iterators and\n-consumers, check out the [iterator module documentation](std/iter/index.html).\n+consumers, check out the [iterator module documentation](../std/iter/index.html).", "previous_filename": "src/doc/trpl/src/iterators.md"}, {"sha": "80926c99e872fd78f11a5397b74a92d7e994b49d", "filename": "src/doc/trpl/looping.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Looping\n+% Looping\n \n Looping is the last basic construct that we haven't learned yet in Rust. Rust has\n two main looping constructs: `for` and `while`.", "previous_filename": "src/doc/trpl/src/looping.md"}, {"sha": "c694806b4bab9f60203f0c485da1160bf611399d", "filename": "src/doc/trpl/macros.md", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -507,7 +507,7 @@ When this library is loaded with `#[use_macros] extern crate`, only `m2` will\n be imported.\n \n The Rust Reference has a [listing of macro-related\n-attributes](reference.html#macro--and-plugin-related-attributes).\n+attributes](../reference.html#macro--and-plugin-related-attributes).\n \n # The variable `$crate`\n \n@@ -567,7 +567,7 @@ intermediate states out, and passing the flag `--pretty expanded` as a\n command-line argument to the compiler will show the result of expansion.\n \n If Rust's macro system can't do what you need, you may want to write a\n-[compiler plugin](guide-plugin.html) instead. Compared to `macro_rules!`\n+[compiler plugin](plugin.html) instead. Compared to `macro_rules!`\n macros, this is significantly more work, the interfaces are much less stable,\n and the warnings about debugging apply ten-fold. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax", "previous_filename": "src/doc/trpl/src/macros.md"}, {"sha": "c120142cf5c72835a4ad88d21a1e9fd371901b17", "filename": "src/doc/trpl/match.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Match\n+% Match\n \n Often, a simple `if`/`else` isn't enough, because you have more than two\n possible options. Also, `else` conditions can get incredibly complicated, so", "previous_filename": "src/doc/trpl/src/match.md"}, {"sha": "54e9cdf51911583112c93b02afcfc349827b92b4", "filename": "src/doc/trpl/method-syntax.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/method-syntax.md"}, {"sha": "3db4da73f932ebf73d8c13a909ffd8d6702a2eff", "filename": "src/doc/trpl/ownership.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/ownership.md"}, {"sha": "282703c43874c1b8479fbcb80069407a8774d915", "filename": "src/doc/trpl/patterns.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/patterns.md"}, {"sha": "2a0710d018c4ef3d3369e7efa128e67cabafc67c", "filename": "src/doc/trpl/plugins.md", "status": "renamed", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -5,20 +5,20 @@\n <p>\n <b>Warning:</b> Plugins are an advanced, unstable feature! For many details,\n the only available documentation is the <a\n-href=\"syntax/index.html\"><code>libsyntax</code></a> and <a\n-href=\"rustc/index.html\"><code>librustc</code></a> API docs, or even the source\n+href=\"../syntax/index.html\"><code>libsyntax</code></a> and <a\n+href=\"../rustc/index.html\"><code>librustc</code></a> API docs, or even the source\n code itself. These internal compiler APIs are also subject to change at any\n time.\n </p>\n \n <p>\n For defining new syntax it is often much easier to use Rust's <a\n-href=\"guide-macros.html\">built-in macro system</a>.\n+href=\"macros.html\">built-in macro system</a>.\n </p>\n \n <p style=\"margin-bottom: 0\">\n The code in this document uses language features not covered in the Rust\n-Guide.  See the <a href=\"reference.html\">Reference Manual</a> for more\n+Guide.  See the <a href=\"../reference.html\">Reference Manual</a> for more\n information.\n </p>\n \n@@ -32,19 +32,19 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n A plugin is a dynamic library crate with a designated \"registrar\" function that\n registers extensions with `rustc`. Other crates can use these extensions by\n loading the plugin crate with `#[plugin] extern crate`. See the\n-[`rustc::plugin`](rustc/plugin/index.html) documentation for more about the\n+[`rustc::plugin`](../rustc/plugin/index.html) documentation for more about the\n mechanics of defining and loading a plugin.\n \n Arguments passed as `#[plugin=...]` or `#[plugin(...)]` are not interpreted by\n rustc itself.  They are provided to the plugin through the `Registry`'s [`args`\n-method](rustc/plugin/registry/struct.Registry.html#method.args).\n+method](../rustc/plugin/registry/struct.Registry.html#method.args).\n \n # Syntax extensions\n \n Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n is the procedural macro. These are invoked the same way as [ordinary\n-macros](guide-macros.html), but the expansion is performed by arbitrary Rust\n-code that manipulates [syntax trees](syntax/ast/index.html) at\n+macros](macros.html), but the expansion is performed by arbitrary Rust\n+code that manipulates [syntax trees](../syntax/ast/index.html) at\n compile time.\n \n Let's write a plugin\n@@ -126,14 +126,13 @@ The advantages over a simple `fn(&str) -> uint` are:\n   a way to define new literal syntax for any data type.\n \n In addition to procedural macros, you can define new\n-[`deriving`](reference.html#deriving)-like attributes and other kinds of\n+[`deriving`](../reference.html#deriving)-like attributes and other kinds of\n extensions.  See\n-[`Registry::register_syntax_extension`](rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension)\n+[`Registry::register_syntax_extension`](../rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension)\n and the [`SyntaxExtension`\n enum](http://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html).  For\n a more involved macro example, see\n-[`src/libregex_macros/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libregex_macros/lib.rs)\n-in the Rust distribution.\n+[`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n \n ## Tips and tricks\n@@ -147,7 +146,7 @@ variables of the same name (but different syntax contexts) are in play\n in the same scope. In this case `--pretty expanded,hygiene` will tell\n you about the syntax contexts.\n \n-You can use [`syntax::parse`](syntax/parse/index.html) to turn token trees into\n+You can use [`syntax::parse`](../syntax/parse/index.html) to turn token trees into\n higher-level syntax elements like expressions:\n \n ```ignore\n@@ -163,31 +162,31 @@ Looking through [`libsyntax` parser\n code](https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs)\n will give you a feel for how the parsing infrastructure works.\n \n-Keep the [`Span`s](syntax/codemap/struct.Span.html) of\n+Keep the [`Span`s](../syntax/codemap/struct.Span.html) of\n everything you parse, for better error reporting. You can wrap\n-[`Spanned`](syntax/codemap/struct.Spanned.html) around\n+[`Spanned`](../syntax/codemap/struct.Spanned.html) around\n your custom data structures.\n \n Calling\n-[`ExtCtxt::span_fatal`](syntax/ext/base/struct.ExtCtxt.html#method.span_fatal)\n+[`ExtCtxt::span_fatal`](../syntax/ext/base/struct.ExtCtxt.html#method.span_fatal)\n will immediately abort compilation. It's better to instead call\n-[`ExtCtxt::span_err`](syntax/ext/base/struct.ExtCtxt.html#method.span_err)\n+[`ExtCtxt::span_err`](../syntax/ext/base/struct.ExtCtxt.html#method.span_err)\n and return\n-[`DummyResult`](syntax/ext/base/struct.DummyResult.html),\n+[`DummyResult`](../syntax/ext/base/struct.DummyResult.html),\n so that the compiler can continue and find further errors.\n \n The example above produced an integer literal using\n-[`AstBuilder::expr_uint`](syntax/ext/build/trait.AstBuilder.html#tymethod.expr_uint).\n+[`AstBuilder::expr_uint`](../syntax/ext/build/trait.AstBuilder.html#tymethod.expr_uint).\n As an alternative to the `AstBuilder` trait, `libsyntax` provides a set of\n-[quasiquote macros](syntax/ext/quote/index.html).  They are undocumented and\n+[quasiquote macros](../syntax/ext/quote/index.html).  They are undocumented and\n very rough around the edges.  However, the implementation may be a good\n starting point for an improved quasiquote as an ordinary plugin library.\n \n \n # Lint plugins\n \n Plugins can extend [Rust's lint\n-infrastructure](reference.html#lint-check-attributes) with additional checks for\n+infrastructure](../reference.html#lint-check-attributes) with additional checks for\n code style, safety, etc. You can see\n [`src/test/auxiliary/lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs)\n for a full example, the core of which is reproduced here:\n@@ -236,11 +235,11 @@ foo.rs:4 fn lintme() { }\n The components of a lint plugin are:\n \n * one or more `declare_lint!` invocations, which define static\n-  [`Lint`](rustc/lint/struct.Lint.html) structs;\n+  [`Lint`](../rustc/lint/struct.Lint.html) structs;\n \n * a struct holding any state needed by the lint pass (here, none);\n \n-* a [`LintPass`](rustc/lint/trait.LintPass.html)\n+* a [`LintPass`](../rustc/lint/trait.LintPass.html)\n   implementation defining how to check each syntax element. A single\n   `LintPass` may call `span_lint` for several different `Lint`s, but should\n   register them all through the `get_lints` method.\n@@ -252,7 +251,7 @@ mostly use the same infrastructure as lint plugins, and provide examples of how\n to access type information.\n \n Lints defined by plugins are controlled by the usual [attributes and compiler\n-flags](reference.html#lint-check-attributes), e.g. `#[allow(test_lint)]` or\n+flags](../reference.html#lint-check-attributes), e.g. `#[allow(test_lint)]` or\n `-A test-lint`. These identifiers are derived from the first argument to\n `declare_lint!`, with appropriate case and punctuation conversion.\n ", "previous_filename": "src/doc/trpl/src/plugins.md"}, {"sha": "ad80d2812d07794fa7588184b91b13d8d955b4f4", "filename": "src/doc/trpl/pointers.md", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -409,7 +409,7 @@ test.rs:4         let y = &x;\n \n As you might guess, this kind of analysis is complex for a human, and therefore\n hard for a computer, too! There is an entire [guide devoted to references, ownership,\n-and lifetimes](guide-ownership.html) that goes into this topic in\n+and lifetimes](ownership.html) that goes into this topic in\n great detail, so if you want the full details, check that out.\n \n ## Best practices\n@@ -542,7 +542,7 @@ with some improvements:\n 4. Rust enforces that no other writeable pointers alias to this heap memory,\n    which means writing to an invalid pointer is not possible.\n \n-See the section on references or the [ownership guide](guide-ownership.html)\n+See the section on references or the [ownership guide](ownership.html)\n for more detail on how lifetimes work.\n \n Using boxes and references together is very common. For example:\n@@ -780,6 +780,6 @@ Here's a quick rundown of Rust's pointer types:\n \n # Related resources\n \n-* [API documentation for Box](std/boxed/index.html)\n-* [Ownership guide](guide-ownership.html)\n+* [API documentation for Box](../std/boxed/index.html)\n+* [Ownership guide](ownership.html)\n * [Cyclone paper on regions](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf), which inspired Rust's lifetime system", "previous_filename": "src/doc/trpl/src/pointers.md"}, {"sha": "7a5c535827c251f35f58f50ee146d6b6d2075046", "filename": "src/doc/trpl/src/guide-lifetimes.md", "status": "removed", "additions": 0, "deletions": 565, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/483fca9fa55d0c1f936412d577424916f20d94a3/src%2Fdoc%2Ftrpl%2Fsrc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/483fca9fa55d0c1f936412d577424916f20d94a3/src%2Fdoc%2Ftrpl%2Fsrc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fsrc%2Fguide-lifetimes.md?ref=483fca9fa55d0c1f936412d577424916f20d94a3", "patch": "@@ -1,565 +0,0 @@\n-% The Rust References and Lifetimes Guide\n-\n-# Introduction\n-\n-References are one of the more flexible and powerful tools available in\n-Rust. They can point anywhere: into the heap, stack, and even into the\n-interior of another data structure. A reference is as flexible as a C pointer\n-or C++ reference.\n-\n-Unlike C and C++ compilers, the Rust compiler includes special static\n-checks that ensure that programs use references safely.\n-\n-Despite their complete safety, a reference's representation at runtime\n-is the same as that of an ordinary pointer in a C program. They introduce zero\n-overhead. The compiler does all safety checks at compile time.\n-\n-Although references have rather elaborate theoretical underpinnings\n-(e.g. region pointers), the core concepts will be familiar to anyone\n-who has worked with C or C++. The best way to explain how they are\n-used\u2014and their limitations\u2014is probably just to work through several examples.\n-\n-# By example\n-\n-References, sometimes known as *borrowed pointers*, are only valid for\n-a limited duration. References never claim any kind of ownership\n-over the data that they point to. Instead, they are used for cases\n-where you would like to use data for a short time.\n-\n-Consider a simple struct type `Point`:\n-\n-~~~\n-struct Point {x: f64, y: f64}\n-~~~\n-\n-We can use this simple definition to allocate points in many different ways. For\n-example, in this code, each of these local variables contains a point,\n-but allocated in a different place:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let on_the_stack : Point      =     Point {x: 3.0, y: 4.0};\n-let on_the_heap  : Box<Point> = box Point {x: 7.0, y: 9.0};\n-~~~\n-\n-Suppose we wanted to write a procedure that computed the distance between any\n-two points, no matter where they were stored. One option is to define a function\n-that takes two arguments of type `Point`\u2014that is, it takes the points by value.\n-But if we define it this way, calling the function will cause the points to be\n-copied. For points, this is probably not so bad, but often copies are\n-expensive. So we'd like to define a function that takes the points just as\n-a reference.\n-\n-~~~\n-# use std::num::Float;\n-# struct Point {x: f64, y: f64}\n-# fn sqrt(f: f64) -> f64 { 0.0 }\n-fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n-    let x_d = p1.x - p2.x;\n-    let y_d = p1.y - p2.y;\n-    (x_d * x_d + y_d * y_d).sqrt()\n-}\n-~~~\n-\n-Now we can call `compute_distance()`:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-# let on_the_stack :     Point  =     Point{x: 3.0, y: 4.0};\n-# let on_the_heap  : Box<Point> = box Point{x: 7.0, y: 9.0};\n-# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&on_the_stack, &*on_the_heap);\n-~~~\n-\n-Here, the `&` operator takes the address of the variable\n-`on_the_stack`; this is because `on_the_stack` has the type `Point`\n-(that is, a struct value) and we have to take its address to get a\n-value. We also call this _borrowing_ the local variable\n-`on_the_stack`, because we have created an alias: that is, another\n-name for the same data.\n-\n-Likewise, in the case of `on_the_heap`,\n-the `&` operator is used in conjunction with the `*` operator\n-to take a reference to the contents of the box.\n-\n-Whenever a caller lends data to a callee, there are some limitations on what\n-the caller can do with the original. For example, if the contents of a\n-variable have been lent out, you cannot send that variable to another task. In\n-addition, the compiler will reject any code that might cause the borrowed\n-value to be freed or overwrite its component fields with values of different\n-types (I'll get into what kinds of actions those are shortly). This rule\n-should make intuitive sense: you must wait for a borrower to return the value\n-that you lent it (that is, wait for the reference to go out of scope)\n-before you can make full use of it again.\n-\n-# Other uses for the & operator\n-\n-In the previous example, the value `on_the_stack` was defined like so:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let on_the_stack: Point = Point {x: 3.0, y: 4.0};\n-~~~\n-\n-This declaration means that code can only pass `Point` by value to other\n-functions. As a consequence, we had to explicitly take the address of\n-`on_the_stack` to get a reference. Sometimes however it is more\n-convenient to move the & operator into the definition of `on_the_stack`:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let on_the_stack2: &Point = &Point {x: 3.0, y: 4.0};\n-~~~\n-\n-Applying `&` to an rvalue (non-assignable location) is just a convenient\n-shorthand for creating a temporary and taking its address. A more verbose\n-way to write the same code is:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let tmp = Point {x: 3.0, y: 4.0};\n-let on_the_stack2 : &Point = &tmp;\n-~~~\n-\n-# Taking the address of fields\n-\n-The `&` operator is not limited to taking the address of\n-local variables. It can also take the address of fields or\n-individual array elements. For example, consider this type definition\n-for `Rectangle`:\n-\n-~~~\n-struct Point {x: f64, y: f64} // as before\n-struct Size {w: f64, h: f64} // as before\n-struct Rectangle {origin: Point, size: Size}\n-~~~\n-\n-Now, as before, we can define rectangles in a few different ways:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-# struct Size {w: f64, h: f64} // as before\n-# struct Rectangle {origin: Point, size: Size}\n-let rect_stack   =    &Rectangle {origin: Point {x: 1.0, y: 2.0},\n-                                  size: Size {w: 3.0, h: 4.0}};\n-let rect_heap    = box Rectangle {origin: Point {x: 5.0, y: 6.0},\n-                                  size: Size {w: 3.0, h: 4.0}};\n-~~~\n-\n-In each case, we can extract out individual subcomponents with the `&`\n-operator. For example, I could write:\n-\n-~~~\n-# struct Point {x: f64, y: f64} // as before\n-# struct Size {w: f64, h: f64} // as before\n-# struct Rectangle {origin: Point, size: Size}\n-# let rect_stack  = &Rectangle {origin: Point {x: 1.0, y: 2.0}, size: Size {w: 3.0, h: 4.0}};\n-# let rect_heap   = box Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n-# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&rect_stack.origin, &rect_heap.origin);\n-~~~\n-\n-which would borrow the field `origin` from the rectangle on the stack\n-as well as from the owned box, and then compute the distance between them.\n-\n-# Lifetimes\n-\n-We\u2019ve seen a few examples of borrowing data. To this point, we\u2019ve glossed\n-over issues of safety. As stated in the introduction, at runtime a reference\n-is simply a pointer, nothing more. Therefore, avoiding C's problems with\n-dangling pointers requires a compile-time safety check.\n-\n-The basis for the check is the notion of _lifetimes_. A lifetime is a\n-static approximation of the span of execution during which the pointer\n-is valid: it always corresponds to some expression or block within the\n-program.\n-\n-The compiler will only allow a borrow *if it can guarantee that the data will\n-not be reassigned or moved for the lifetime of the pointer*. This does not\n-necessarily mean that the data is stored in immutable memory. For example,\n-the following function is legal:\n-\n-~~~\n-# fn some_condition() -> bool { true }\n-# struct Foo { f: int }\n-fn example3() -> int {\n-    let mut x = box Foo {f: 3};\n-    if some_condition() {\n-        let y = &x.f;      // -+ L\n-        return *y;         //  |\n-    }                      // -+\n-    x = box Foo {f: 4};\n-    // ...\n-# return 0;\n-}\n-~~~\n-\n-Here, the interior of the variable `x` is being borrowed\n-and `x` is declared as mutable. However, the compiler can prove that\n-`x` is not assigned anywhere in the lifetime L of the variable\n-`y`. Therefore, it accepts the function, even though `x` is mutable\n-and in fact is mutated later in the function.\n-\n-It may not be clear why we are so concerned about mutating a borrowed\n-variable. The reason is that the runtime system frees any box\n-_as soon as its owning reference changes or goes out of\n-scope_. Therefore, a program like this is illegal (and would be\n-rejected by the compiler):\n-\n-~~~ {.ignore}\n-fn example3() -> int {\n-    let mut x = box X {f: 3};\n-    let y = &x.f;\n-    x = box X {f: 4};  // Error reported here.\n-    *y\n-}\n-~~~\n-\n-To make this clearer, consider this diagram showing the state of\n-memory immediately before the re-assignment of `x`:\n-\n-~~~ {.text}\n-    Stack               Exchange Heap\n-\n-  x +-------------+\n-    | box {f:int} | ----+\n-  y +-------------+     |\n-    | &int        | ----+\n-    +-------------+     |    +---------+\n-                        +--> |  f: 3   |\n-                             +---------+\n-~~~\n-\n-Once the reassignment occurs, the memory will look like this:\n-\n-~~~ {.text}\n-    Stack               Exchange Heap\n-\n-  x +-------------+          +---------+\n-    | box {f:int} | -------> |  f: 4   |\n-  y +-------------+          +---------+\n-    | &int        | ----+\n-    +-------------+     |    +---------+\n-                        +--> | (freed) |\n-                             +---------+\n-~~~\n-\n-Here you can see that the variable `y` still points at the old `f`\n-property of Foo, which has been freed.\n-\n-In fact, the compiler can apply the same kind of reasoning to any\n-memory that is (uniquely) owned by the stack frame. So we could\n-modify the previous example to introduce additional owned pointers\n-and structs, and the compiler will still be able to detect possible\n-mutations. This time, we'll use an analogy to illustrate the concept.\n-\n-~~~ {.ignore}\n-fn example3() -> int {\n-    struct House { owner: Box<Person> }\n-    struct Person { age: int }\n-\n-    let mut house = box House {\n-        owner: box Person {age: 30}\n-    };\n-\n-    let owner_age = &house.owner.age;\n-    house = box House {owner: box Person {age: 40}};  // Error reported here.\n-    house.owner = box Person {age: 50};               // Error reported here.\n-    *owner_age\n-}\n-~~~\n-\n-In this case, two errors are reported, one when the variable `house` is\n-modified and another when `house.owner` is modified. Either modification would\n-invalidate the pointer `owner_age`.\n-\n-# Borrowing and enums\n-\n-The previous example showed that the type system forbids any mutations\n-of owned boxed values while they are being borrowed. In general, the type\n-system also forbids borrowing a value as mutable if it is already being\n-borrowed - either as a mutable reference or an immutable one. This restriction\n-prevents pointers from pointing into freed memory. There is one other\n-case where the compiler must be very careful to ensure that pointers\n-remain valid: pointers into the interior of an `enum`.\n-\n-Let\u2019s look at the following `shape` type that can represent both rectangles\n-and circles:\n-\n-~~~\n-struct Point {x: f64, y: f64}; // as before\n-struct Size {w: f64, h: f64}; // as before\n-enum Shape {\n-    Circle(Point, f64),   // origin, radius\n-    Rectangle(Point, Size)  // upper-left, dimensions\n-}\n-~~~\n-\n-Now we might write a function to compute the area of a shape. This\n-function takes a reference to a shape, to avoid the need for\n-copying.\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-fn compute_area(shape: &Shape) -> f64 {\n-    match *shape {\n-        Shape::Circle(_, radius) => std::f64::consts::PI * radius * radius,\n-        Shape::Rectangle(_, ref size) => size.w * size.h\n-    }\n-}\n-~~~\n-\n-The first case matches against circles. Here, the pattern extracts the\n-radius from the shape variant and the action uses it to compute the\n-area of the circle.\n-\n-The second match is more interesting. Here we match against a\n-rectangle and extract its size: but rather than copy the `size`\n-struct, we use a by-reference binding to create a pointer to it. In\n-other words, a pattern binding like `ref size` binds the name `size`\n-to a pointer of type `&size` into the _interior of the enum_.\n-\n-To make this more clear, let's look at a diagram of memory layout in\n-the case where `shape` points at a rectangle:\n-\n-~~~ {.text}\n-Stack             Memory\n-\n-+-------+         +---------------+\n-| shape | ------> | rectangle(    |\n-+-------+         |   {x: f64,    |\n-| size  | -+      |    y: f64},   |\n-+-------+  +----> |   {w: f64,    |\n-                  |    h: f64})   |\n-                  +---------------+\n-~~~\n-\n-Here you can see that rectangular shapes are composed of five words of\n-memory. The first is a tag indicating which variant this enum is\n-(`rectangle`, in this case). The next two words are the `x` and `y`\n-fields for the point and the remaining two are the `w` and `h` fields\n-for the size. The binding `size` is then a pointer into the inside of\n-the shape.\n-\n-Perhaps you can see where the danger lies: if the shape were somehow\n-to be reassigned, perhaps to a circle, then although the memory used\n-to store that shape value would still be valid, _it would have a\n-different type_! The following diagram shows what memory would look\n-like if code overwrote `shape` with a circle:\n-\n-~~~ {.text}\n-Stack             Memory\n-\n-+-------+         +---------------+\n-| shape | ------> | circle(       |\n-+-------+         |   {x: f64,    |\n-| size  | -+      |    y: f64},   |\n-+-------+  +----> |   f64)        |\n-                  |               |\n-                  +---------------+\n-~~~\n-\n-As you can see, the `size` pointer would be pointing at a `f64`\n-instead of a struct. This is not good: dereferencing the second field\n-of a `f64` as if it were a struct with two fields would be a memory\n-safety violation.\n-\n-So, in fact, for every `ref` binding, the compiler will impose the\n-same rules as the ones we saw for borrowing the interior of an owned\n-box: it must be able to guarantee that the `enum` will not be\n-overwritten for the duration of the borrow.  In fact, the compiler\n-would accept the example we gave earlier. The example is safe because\n-the shape pointer has type `&Shape`, which means \"reference to\n-immutable memory containing a `shape`\". If, however, the type of that\n-pointer were `&mut Shape`, then the ref binding would be ill-typed.\n-Just as with owned boxes, the compiler will permit `ref` bindings\n-into data owned by the stack frame even if the data are mutable,\n-but otherwise it requires that the data reside in immutable memory.\n-\n-# Returning references\n-\n-So far, all of the examples we have looked at, use references in a\n-\u201cdownward\u201d direction. That is, a method or code block creates a\n-reference, then uses it within the same scope. It is also\n-possible to return references as the result of a function, but\n-as we'll see, doing so requires some explicit annotation.\n-\n-We could write a subroutine like this:\n-\n-~~~\n-struct Point {x: f64, y: f64}\n-fn get_x<'r>(p: &'r Point) -> &'r f64 { &p.x }\n-~~~\n-\n-Here, the function `get_x()` returns a pointer into the structure it\n-was given. The type of the parameter (`&'r Point`) and return type\n-(`&'r f64`) both use a new syntactic form that we have not seen so\n-far.  Here the identifier `r` names the lifetime of the pointer\n-explicitly. So in effect, this function declares that it takes a\n-pointer with lifetime `r` and returns a pointer with that same\n-lifetime.\n-\n-In general, it is only possible to return references if they\n-are derived from a parameter to the procedure. In that case, the\n-pointer result will always have the same lifetime as one of the\n-parameters; named lifetimes indicate which parameter that\n-is.\n-\n-In the previous code samples, function parameter types did not include a\n-lifetime name. The compiler simply creates a fresh name for the lifetime\n-automatically: that is, the lifetime name is guaranteed to refer to a distinct\n-lifetime from the lifetimes of all other parameters.\n-\n-Named lifetimes that appear in function signatures are conceptually\n-the same as the other lifetimes we have seen before, but they are a bit\n-abstract: they don\u2019t refer to a specific expression within `get_x()`,\n-but rather to some expression within the *caller of `get_x()`*.  The\n-lifetime `r` is actually a kind of *lifetime parameter*: it is defined\n-by the caller to `get_x()`, just as the value for the parameter `p` is\n-defined by that caller.\n-\n-In any case, whatever the lifetime of `r` is, the pointer produced by\n-`&p.x` always has the same lifetime as `p` itself: a pointer to a\n-field of a struct is valid as long as the struct is valid. Therefore,\n-the compiler accepts the function `get_x()`.\n-\n-In general, if you borrow a struct or box to create a\n-reference, it will only be valid within the function\n-and cannot be returned. This is why the typical way to return references\n-is to take references as input (the only other case in\n-which it can be legal to return a reference is if it\n-points at a static constant).\n-\n-# Named lifetimes\n-\n-Lifetimes can be named and referenced. For example, the special lifetime\n-`'static`, which does not go out of scope, can be used to create global\n-variables and communicate between tasks (see the manual for use cases).\n-\n-## Parameter Lifetimes\n-\n-Named lifetimes allow for grouping of parameters by lifetime.\n-For example, consider this function:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-fn select<'r, T>(shape: &'r Shape, threshold: f64,\n-                 a: &'r T, b: &'r T) -> &'r T {\n-    if compute_area(shape) > threshold {a} else {b}\n-}\n-~~~\n-\n-This function takes three references and assigns each the same\n-lifetime `r`.  In practice, this means that, in the caller, the\n-lifetime `r` will be the *intersection of the lifetime of the three\n-region parameters*. This may be overly conservative, as in this\n-example:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-# fn select<'r, T>(shape: &Shape, threshold: f64,\n-#                  a: &'r T, b: &'r T) -> &'r T {\n-#     if compute_area(shape) > threshold {a} else {b}\n-# }\n-                                                            // -+ r\n-fn select_based_on_unit_circle<'r, T>(                      //  |-+ B\n-    threshold: f64, a: &'r T, b: &'r T) -> &'r T {          //  | |\n-                                                            //  | |\n-    let shape = Shape::Circle(Point {x: 0., y: 0.}, 1.);    //  | |\n-    select(&shape, threshold, a, b)                         //  | |\n-}                                                           //  |-+\n-                                                            // -+\n-~~~\n-\n-In this call to `select()`, the lifetime of the first parameter shape\n-is B, the function body. Both of the second two parameters `a` and `b`\n-share the same lifetime, `r`, which is a lifetime parameter of\n-`select_based_on_unit_circle()`. The caller will infer the\n-intersection of these two lifetimes as the lifetime of the returned\n-value, and hence the return value of `select()` will be assigned a\n-lifetime of B. This will in turn lead to a compilation error, because\n-`select_based_on_unit_circle()` is supposed to return a value with the\n-lifetime `r`.\n-\n-To address this, we can modify the definition of `select()` to\n-distinguish the lifetime of the first parameter from the lifetime of\n-the latter two. After all, the first parameter is not being\n-returned. Here is how the new `select()` might look:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-fn select<'r, 'tmp, T>(shape: &'tmp Shape, threshold: f64,\n-                       a: &'r T, b: &'r T) -> &'r T {\n-    if compute_area(shape) > threshold {a} else {b}\n-}\n-~~~\n-\n-Here you can see that `shape`'s lifetime is now named `tmp`. The\n-parameters `a`, `b`, and the return value all have the lifetime `r`.\n-However, since the lifetime `tmp` is not returned, it would be more\n-concise to just omit the named lifetime for `shape` altogether:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-fn select<'r, T>(shape: &Shape, threshold: f64,\n-                 a: &'r T, b: &'r T) -> &'r T {\n-    if compute_area(shape) > threshold {a} else {b}\n-}\n-~~~\n-\n-This is equivalent to the previous definition.\n-\n-## Labeled Control Structures\n-\n-Named lifetime notation can also be used to control the flow of execution:\n-\n-~~~\n-'h: for i in range(0u, 10) {\n-    'g: loop {\n-        if i % 2 == 0 { continue 'h; }\n-        if i == 9 { break 'h; }\n-        break 'g;\n-    }\n-}\n-~~~\n-\n-> *Note:* Labelled breaks are not currently supported within `while` loops.\n-\n-Named labels are hygienic and can be used safely within macros.\n-See the macros guide section on hygiene for more details.\n-\n-# Conclusion\n-\n-So there you have it: a (relatively) brief tour of the lifetime\n-system. For more details, we refer to the (yet to be written) reference\n-document on references, which will explain the full notation\n-and give more examples."}, {"sha": "2d31f06ebaae14317d8bc324d60a17879b21b4ee", "filename": "src/doc/trpl/standard-input.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstandard-input.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Standard Input\n+% Standard Input\n \n Getting input from the keyboard is pretty easy, but uses some things\n we haven't seen before. Here's a simple program that reads some input,", "previous_filename": "src/doc/trpl/src/standard-input.md"}, {"sha": "a40e748dae7b09707da1e4d7017218346d07a8d1", "filename": "src/doc/trpl/strings.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Strings\n+% Strings\n \n Strings are an important concept for any programmer to master. Rust's string\n handling system is a bit different from other languages, due to its systems", "previous_filename": "src/doc/trpl/src/strings.md"}, {"sha": "8e9f40b0f4ec2ab985ca6c7b39d3c44d96c9ccc4", "filename": "src/doc/trpl/tasks.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ftasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ftasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftasks.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -369,7 +369,7 @@ Unlike `spawn`, the function spawned using `try` may return a value, which\n child thread terminates successfully, `try` will return an `Ok` result; if the\n child thread panics, `try` will return an `Error` result.\n \n-[`Result`]: std/result/index.html\n+[`Result`]: ../std/result/index.html\n \n > *Note:* A panicked thread does not currently produce a useful error\n > value (`try` always returns `Err(())`). In the", "previous_filename": "src/doc/trpl/src/tasks.md"}, {"sha": "4c3d93bdfbe5feb70333c8aa1fc7f1b419f66db7", "filename": "src/doc/trpl/testing.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/testing.md"}, {"sha": "04c644da2abbcd8f57145788ab7c0521c54082f8", "filename": "src/doc/trpl/traits.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "previous_filename": "src/doc/trpl/src/traits.md"}, {"sha": "3e0a1ef13454a499225de546fb09c006f63aa091", "filename": "src/doc/trpl/unsafe.md", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -12,7 +12,7 @@ block which allows the programmer to dodge some of the compiler's\n checks and do a wide range of operations, such as:\n \n - dereferencing [raw pointers](#raw-pointers)\n-- calling a function via FFI ([covered by the FFI guide](guide-ffi.html))\n+- calling a function via FFI ([covered by the FFI guide](ffi.html))\n - casting between types bitwise (`transmute`, aka \"reinterpret cast\")\n - [inline assembly](#inline-assembly)\n \n@@ -37,7 +37,7 @@ build safe interfaces.\n ## References\n \n One of Rust's biggest features is memory safety.  This is achieved in\n-part via [the ownership system](guide-ownership.html), which is how the\n+part via [the ownership system](ownership.html), which is how the\n compiler can guarantee that every `&` reference is always valid, and,\n for example, never pointing to freed memory.\n \n@@ -504,7 +504,7 @@ shouldn't get triggered.\n The second of these three functions, `eh_personality`, is used by the\n failure mechanisms of the compiler. This is often mapped to GCC's\n personality function (see the\n-[libstd implementation](std/rt/unwind/index.html) for more\n+[libstd implementation](../std/rt/unwind/index.html) for more\n information), but crates which do not trigger a panic can be assured\n that this function is never called. The final function, `panic_fmt`, is\n also used by the failure mechanisms of the compiler.\n@@ -517,7 +517,7 @@ also used by the failure mechanisms of the compiler.\n With the above techniques, we've got a bare-metal executable running some Rust\n code. There is a good deal of functionality provided by the standard library,\n however, that is necessary to be productive in Rust. If the standard library is\n-not sufficient, then [libcore](core/index.html) is designed to be used\n+not sufficient, then [libcore](../core/index.html) is designed to be used\n instead.\n \n The core library has very few dependencies and is much more portable than the", "previous_filename": "src/doc/trpl/src/unsafe.md"}, {"sha": "4e2e7bd2fe2f442ca91b7ec63ff2820ff1199abf", "filename": "src/doc/trpl/variable-bindings.md", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -1,4 +1,4 @@\n-# Variable bindings\n+% Variable bindings\n \n The first thing we'll learn about are 'variable bindings.' They look like this:\n \n@@ -170,5 +170,5 @@ arguments we pass to functions and macros, if you're passing more than one.\n When you just use the curly braces, Rust will attempt to display the\n value in a meaningful way by checking out its type. If you want to specify the\n format in a more detailed manner, there are a [wide number of options\n-available](std/fmt/index.html). For now, we'll just stick to the default:\n+available](../std/fmt/index.html). For now, we'll just stick to the default:\n integers aren't very complicated to print.", "previous_filename": "src/doc/trpl/src/variable-bindings.md"}, {"sha": "1d16de2a2febc629a76ee428e3ecd1ed6a7d418e", "filename": "src/rustbook/book.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -29,8 +29,8 @@ pub struct Book {\n /// A depth-first iterator over a book.\n pub struct BookItems<'a> {\n     cur_items: &'a [BookItem],\n-    cur_idx: uint,\n-    stack: Vec<(&'a [BookItem], uint)>,\n+    cur_idx: usize,\n+    stack: Vec<(&'a [BookItem], usize)>,\n }\n \n impl<'a> Iterator for BookItems<'a> {\n@@ -80,7 +80,7 @@ impl Book {\n pub fn parse_summary<R: Reader>(input: R, src: &Path) -> Result<Book, Vec<String>> {\n     fn collapse(stack: &mut Vec<BookItem>,\n                 top_items: &mut Vec<BookItem>,\n-                to_level: uint) {\n+                to_level: usize) {\n         loop {\n             if stack.len() < to_level { return }\n             if stack.len() == 1 {\n@@ -141,7 +141,7 @@ pub fn parse_summary<R: Reader>(input: R, src: &Path) -> Result<Book, Vec<String\n             };\n             let level = cap.name(\"indent\").unwrap().chars().map(|c| {\n                 match c {\n-                    ' ' => 1u,\n+                    ' ' => 1us,\n                     '\\t' => 4,\n                     _ => unreachable!()\n                 }"}, {"sha": "1cb5e38e19076da4158e1eeb31ec9c72e3cebac8", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -130,8 +130,8 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         ];\n         let output_result = rustdoc::main_args(rustdoc_args);\n         if output_result != 0 {\n-\n-            let message = format!(\"Could not execute `rustdoc`: {}\", output_result);\n+            let message = format!(\"Could not execute `rustdoc` with {:?}: {}\",\n+                                  rustdoc_args, output_result);\n             return Err(box message as Box<Error>);\n         }\n     }\n@@ -172,12 +172,13 @@ impl Subcommand for Build {\n         match book::parse_summary(summary, &src) {\n             Ok(book) => {\n                 // execute rustdoc on the whole book\n-                let _ = render(&book, &tgt).map_err(|err| {\n+                try!(render(&book, &tgt).map_err(|err| {\n                     term.err(&format!(\"error: {}\", err.description())[]);\n                     err.detail().map(|detail| {\n                         term.err(&format!(\"detail: {}\", detail)[]);\n-                    })\n-                });\n+                    });\n+                    err\n+                }))\n             }\n             Err(errors) => {\n                 for err in errors.into_iter() {"}, {"sha": "a5915ed4d7370d23473ed526de7953c7bc0fc991", "filename": "src/rustbook/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ferror.rs?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -56,6 +56,12 @@ impl Error for String {\n     }\n }\n \n+impl<'a> Error for Box<Error + 'a> {\n+    fn description(&self) -> &str { (**self).description() }\n+    fn detail(&self) -> Option<&str> { (**self).detail() }\n+    fn cause(&self) -> Option<&Error> { (**self).cause() }\n+}\n+\n impl FromError<()> for () {\n     fn from_err(_: ()) -> () { () }\n }"}, {"sha": null, "filename": "src/rustbook/main.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f"}, {"sha": "471e22ce7c1f1df06716d906b4921e2c6db8b9b2", "filename": "src/rustbook/term.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7541f82faba6b2839b5e640605d7caab6cc6ec4f/src%2Frustbook%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fterm.rs?ref=7541f82faba6b2839b5e640605d7caab6cc6ec4f", "patch": "@@ -11,6 +11,7 @@\n //! An abstraction of the terminal. Eventually, provide color and\n //! verbosity support. For now, just a wrapper around stdout/stderr.\n \n+use std::os;\n use std::io::stdio;\n \n pub struct Term {\n@@ -27,5 +28,6 @@ impl Term {\n     pub fn err(&mut self, msg: &str) {\n         // swallow any errors\n         let _ = self.err.write_line(msg);\n+        os::set_exit_status(101);\n     }\n }"}]}