{"sha": "b47c314c5652c8ecc3f086b0326f467b857b9d5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0N2MzMTRjNTY1MmM4ZWNjM2YwODZiMDMyNmY0NjdiODU3YjlkNWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-05T07:06:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-05T07:06:11Z"}, "message": "Auto merge of #52991 - nikomatsakis:nll-escaping-into-return, r=pnkfelix\n\navoid computing liveness for locals that escape into statics\n\nFixes #52713\n\nI poked at this on the plane and I think it's working -- but I want to do a bit more investigation and double check. The idea is to identify those local variables where the entire value will \"escape\" into the return -- for them, we don't need to compute liveness, since we know that the outlives relations from the return type will force those regions to be equal to free regions. This should help with html5ever in particular.\n\n- [x] test performance\n- [x] verify correctness\n- [x] add comments\n\nr? @pnkfelix\ncc @lqd", "tree": {"sha": "c755c1c13fd5b6e908a6f315cf13640c9d04c143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c755c1c13fd5b6e908a6f315cf13640c9d04c143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b47c314c5652c8ecc3f086b0326f467b857b9d5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b47c314c5652c8ecc3f086b0326f467b857b9d5b", "html_url": "https://github.com/rust-lang/rust/commit/b47c314c5652c8ecc3f086b0326f467b857b9d5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b47c314c5652c8ecc3f086b0326f467b857b9d5b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddcf17e1ed577bad26e92db3c25499620f853a49", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddcf17e1ed577bad26e92db3c25499620f853a49", "html_url": "https://github.com/rust-lang/rust/commit/ddcf17e1ed577bad26e92db3c25499620f853a49"}, {"sha": "2e2ea26a8305d44e2441b8a97e05f7f4d69f7220", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2ea26a8305d44e2441b8a97e05f7f4d69f7220", "html_url": "https://github.com/rust-lang/rust/commit/2e2ea26a8305d44e2441b8a97e05f7f4d69f7220"}], "stats": {"total": 396, "additions": 331, "deletions": 65}, "files": [{"sha": "7e39f3d3b08418618516629ae866807f02ae392c", "filename": "src/librustc_mir/borrow_check/nll/escaping_locals.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fescaping_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fescaping_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fescaping_locals.rs?ref=b47c314c5652c8ecc3f086b0326f467b857b9d5b", "patch": "@@ -0,0 +1,229 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Identify those variables whose entire value will eventually be\n+//! returned from the fn via the RETURN_PLACE. As an optimization, we\n+//! can skip computing liveness results for those variables. The idea\n+//! is that the return type of the fn only ever contains free\n+//! regions. Therefore, the types of those variables are going to\n+//! ultimately be contrained to outlive those free regions -- since\n+//! free regions are always live for the entire body, this implies\n+//! that the liveness results are not important for those regions.\n+//! This is most important in the \"fns\" that we create to represent static\n+//! values, since those are often really quite large, and all regions in them\n+//! will ultimately be constrained to be `'static`. Two examples:\n+//!\n+//! ```\n+//! fn foo() -> &'static [u32] { &[] }\n+//! static FOO: &[u32] = &[];\n+//! ```\n+//!\n+//! In both these cases, the return value will only have static lifetime.\n+//!\n+//! NB: The simple logic here relies on the fact that outlives\n+//! relations in our analysis don't have locations. Otherwise, we\n+//! would have to restrict ourselves to values that are\n+//! *unconditionally* returned (which would still cover the \"big\n+//! static value\" case).\n+//!\n+//! The way that this code works is to use union-find -- we iterate\n+//! over the MIR and union together two variables X and Y if all\n+//! regions in the value of Y are going to be stored into X -- that\n+//! is, if `typeof(X): 'a` requires that `typeof(Y): 'a`. This means\n+//! that e.g. we can union together `x` and `y` if we have something\n+//! like `x = (y, 22)`, but not something like `x = y.f` (since there\n+//! may be regions in the type of `y` that do not appear in the field\n+//! `f`).\n+\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::*;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::unify as ut;\n+\n+crate struct EscapingLocals {\n+    unification_table: ut::UnificationTable<ut::InPlace<AssignedLocal>>,\n+}\n+\n+impl EscapingLocals {\n+    crate fn compute(mir: &Mir<'tcx>) -> Self {\n+        let mut visitor = GatherAssignedLocalsVisitor::new();\n+        visitor.visit_mir(mir);\n+\n+        EscapingLocals {\n+            unification_table: visitor.unification_table,\n+        }\n+    }\n+\n+    /// True if `local` is known to escape into static\n+    /// memory.\n+    crate fn escapes_into_return(&mut self, local: Local) -> bool {\n+        let return_place = AssignedLocal::from(RETURN_PLACE);\n+        let other_place = AssignedLocal::from(local);\n+        self.unification_table.unioned(return_place, other_place)\n+    }\n+}\n+\n+/// The MIR visitor gathering the union-find of the locals used in\n+/// assignments.\n+struct GatherAssignedLocalsVisitor {\n+    unification_table: ut::UnificationTable<ut::InPlace<AssignedLocal>>,\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+struct AssignedLocal(u32);\n+\n+impl ut::UnifyKey for AssignedLocal {\n+    type Value = ();\n+\n+    fn index(&self) -> u32 {\n+        self.0\n+    }\n+\n+    fn from_index(i: u32) -> AssignedLocal {\n+        AssignedLocal(i)\n+    }\n+\n+    fn tag() -> &'static str {\n+        \"AssignedLocal\"\n+    }\n+}\n+\n+impl From<Local> for AssignedLocal {\n+    fn from(item: Local) -> Self {\n+        // newtype_indexes use usize but are u32s.\n+        assert!(item.index() < ::std::u32::MAX as usize);\n+        AssignedLocal(item.index() as u32)\n+    }\n+}\n+\n+impl GatherAssignedLocalsVisitor {\n+    fn new() -> Self {\n+        Self {\n+            unification_table: ut::UnificationTable::new(),\n+        }\n+    }\n+\n+    fn union_locals_if_needed(&mut self, lvalue: Option<Local>, rvalue: Option<Local>) {\n+        if let Some(lvalue) = lvalue {\n+            if let Some(rvalue) = rvalue {\n+                if lvalue != rvalue {\n+                    debug!(\"EscapingLocals: union {:?} and {:?}\", lvalue, rvalue);\n+                    self.unification_table\n+                        .union(AssignedLocal::from(lvalue), AssignedLocal::from(rvalue));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Returns the potential `Local` associated to this `Place` or `PlaceProjection`\n+fn find_local_in_place(place: &Place) -> Option<Local> {\n+    match place {\n+        Place::Local(local) => Some(*local),\n+\n+        // If you do e.g. `x = a.f` then only *part* of the type of\n+        // `a` escapes into `x` (the part contained in `f`); if `a`'s\n+        // type has regions that don't appear in `f`, those might not\n+        // escape.\n+        Place::Projection(..) => None,\n+\n+        Place::Static { .. } | Place::Promoted { .. } => None,\n+    }\n+}\n+\n+// Returns the potential `Local` in this `Operand`.\n+fn find_local_in_operand(op: &Operand) -> Option<Local> {\n+    // Conservatively check a subset of `Operand`s we know our\n+    // benchmarks track, for example `html5ever`.\n+    match op {\n+        Operand::Copy(place) | Operand::Move(place) => find_local_in_place(place),\n+        Operand::Constant(_) => None,\n+    }\n+}\n+\n+impl Visitor<'tcx> for GatherAssignedLocalsVisitor {\n+    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n+        // We need as many union-find keys as there are locals\n+        for _ in 0..mir.local_decls.len() {\n+            self.unification_table.new_key(());\n+        }\n+\n+        self.super_mir(mir);\n+    }\n+\n+    fn visit_assign(\n+        &mut self,\n+        block: BasicBlock,\n+        place: &Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        let local = find_local_in_place(place);\n+\n+        // Find those cases where there is a `Place` consumed by\n+        // `rvalue` and we know that all regions in its type will be\n+        // incorporated into `place`, the `Place` we are assigning to.\n+        match rvalue {\n+            // `x = y` is the simplest possible case.\n+            Rvalue::Use(op) => self.union_locals_if_needed(local, find_local_in_operand(op)),\n+\n+            // `X = &'r P` -- the type of `X` will be `&'r T_P`, where\n+            // `T_P` is the type of `P`.\n+            Rvalue::Ref(_, _, place) => {\n+                // Special case: if you have `X = &*Y` (or `X = &**Y`\n+                // etc), then the outlives relationships will ensure\n+                // that all regions in `Y` are constrained by regions\n+                // in `X` -- this is because the lifetimes of the\n+                // references we deref through are required to outlive\n+                // the borrow lifetime `'r` (which appears in `X`).\n+                //\n+                // (We don't actually need to check the type of `Y`:\n+                // since `ProjectionElem::Deref` represents a built-in\n+                // deref and not an overloaded deref, if the thing we\n+                // deref through is not a reference, then it must be a\n+                // `Box` or `*const`, in which case it contains no\n+                // references.)\n+                let mut place_ref = place;\n+                while let Place::Projection(proj) = place_ref {\n+                    if let ProjectionElem::Deref = proj.elem {\n+                        place_ref = &proj.base;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+\n+                self.union_locals_if_needed(local, find_local_in_place(place_ref))\n+            }\n+\n+            Rvalue::Cast(kind, op, _) => match kind {\n+                CastKind::Unsize => {\n+                    // Casting a `&[T; N]` to `&[T]` or `&Foo` to `&Trait` --\n+                    // in both cases, no regions are \"lost\".\n+                    self.union_locals_if_needed(local, find_local_in_operand(op))\n+                }\n+                _ => (),\n+            },\n+\n+            // Constructing an aggregate like `(x,)` or `Foo { x }`\n+            // includes the full type of `x`.\n+            Rvalue::Aggregate(_, ops) => {\n+                for rvalue in ops.iter().map(find_local_in_operand) {\n+                    self.union_locals_if_needed(local, rvalue);\n+                }\n+            }\n+\n+            // For other things, be conservative and do not union.\n+            _ => (),\n+        };\n+\n+        self.super_assign(block, place, rvalue, location);\n+    }\n+}"}, {"sha": "d018a9277d83420158a50b2f0c14333f3d89d6ef", "filename": "src/librustc_mir/borrow_check/nll/liveness_map.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs?ref=b47c314c5652c8ecc3f086b0326f467b857b9d5b", "patch": "@@ -16,9 +16,10 @@\n //! liveness code so that it only operates over variables with regions in their\n //! types, instead of all variables.\n \n+use borrow_check::nll::escaping_locals::EscapingLocals;\n+use rustc::mir::{Local, Mir};\n use rustc::ty::TypeFoldable;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::mir::{Mir, Local};\n use util::liveness::LiveVariableMap;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -29,14 +30,13 @@ use rustc_data_structures::indexed_vec::Idx;\n crate struct NllLivenessMap {\n     /// For each local variable, contains either None (if the type has no regions)\n     /// or Some(i) with a suitable index.\n-    pub from_local: IndexVec<Local, Option<LocalWithRegion>>,\n-    /// For each LocalWithRegion, maps back to the original Local index.\n-    pub to_local: IndexVec<LocalWithRegion, Local>,\n+    from_local: IndexVec<Local, Option<LocalWithRegion>>,\n \n+    /// For each LocalWithRegion, maps back to the original Local index.\n+    to_local: IndexVec<LocalWithRegion, Local>,\n }\n \n impl LiveVariableMap for NllLivenessMap {\n-\n     fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n         self.from_local[local]\n     }\n@@ -55,21 +55,43 @@ impl LiveVariableMap for NllLivenessMap {\n impl NllLivenessMap {\n     /// Iterates over the variables in Mir and assigns each Local whose type contains\n     /// regions a LocalWithRegion index. Returns a map for converting back and forth.\n-    pub fn compute(mir: &Mir) -> Self {\n+    crate fn compute(mir: &Mir<'tcx>) -> Self {\n+        let mut escaping_locals = EscapingLocals::compute(mir);\n+\n         let mut to_local = IndexVec::default();\n-        let from_local: IndexVec<Local,Option<_>> = mir\n+        let mut escapes_into_return = 0;\n+        let mut no_regions = 0;\n+        let from_local: IndexVec<Local, Option<_>> = mir\n             .local_decls\n             .iter_enumerated()\n             .map(|(local, local_decl)| {\n-                if local_decl.ty.has_free_regions() {\n-                    Some(to_local.push(local))\n+                if escaping_locals.escapes_into_return(local) {\n+                    // If the local escapes into the return value,\n+                    // then the return value will force all of the\n+                    // regions in its type to outlive free regions\n+                    // (e.g., `'static`) and hence liveness is not\n+                    // needed. This is particularly important for big\n+                    // statics.\n+                    escapes_into_return += 1;\n+                    None\n+                } else if local_decl.ty.has_free_regions() {\n+                    let l = to_local.push(local);\n+                    debug!(\"liveness_map: {:?} = {:?}\", local, l);\n+                    Some(l)\n+                } else {\n+                    no_regions += 1;\n+                    None\n                 }\n-                    else {\n-                        None\n-                    }\n             }).collect();\n \n-        Self { from_local, to_local }\n+        debug!(\"liveness_map: {} variables need liveness\", to_local.len());\n+        debug!(\"liveness_map: {} escapes into return\", escapes_into_return);\n+        debug!(\"liveness_map: {} no regions\", no_regions);\n+\n+        Self {\n+            from_local,\n+            to_local,\n+        }\n     }\n }\n "}, {"sha": "44ed6b7676c0c61e18e517f8eaf1dc1cf554ca39", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=b47c314c5652c8ecc3f086b0326f467b857b9d5b", "patch": "@@ -39,7 +39,9 @@ use polonius_engine::{Algorithm, Output};\n use util as mir_util;\n use util::pretty::{self, ALIGN};\n \n+mod constraints;\n mod constraint_generation;\n+mod escaping_locals;\n pub mod explain_borrow;\n mod facts;\n mod invalidation;\n@@ -49,8 +51,6 @@ crate mod type_check;\n mod universal_regions;\n crate mod liveness_map;\n \n-mod constraints;\n-\n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;\n@@ -120,6 +120,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         location_table,\n         borrow_set,\n         &liveness,\n+        &liveness_map,\n         &mut all_facts,\n         flow_inits,\n         move_data,\n@@ -205,6 +206,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     dump_mir_results(\n         infcx,\n         &liveness,\n+        &liveness_map,\n         MirSource::item(def_id),\n         &mir,\n         &regioncx,\n@@ -221,6 +223,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n+    liveness_map: &NllLivenessMap,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n@@ -230,16 +233,14 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n-    let map = &NllLivenessMap::compute(mir);\n-\n     let regular_liveness_per_location: FxHashMap<_, _> = mir\n         .basic_blocks()\n         .indices()\n         .flat_map(|bb| {\n             let mut results = vec![];\n             liveness\n                 .regular\n-                .simulate_block(&mir, bb, map, |location, local_set| {\n+                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results\n@@ -253,7 +254,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n             let mut results = vec![];\n             liveness\n                 .drop\n-                .simulate_block(&mir, bb, map, |location, local_set| {\n+                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results"}, {"sha": "d02f54dc4b87df4feb35bac7279b1c82526c4cad", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=b47c314c5652c8ecc3f086b0326f467b857b9d5b", "patch": "@@ -37,17 +37,18 @@ pub(super) fn generate<'gcx, 'tcx>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n+    liveness_map: &NllLivenessMap,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n     let mut generator = TypeLivenessGenerator {\n         cx,\n         mir,\n         liveness,\n+        liveness_map,\n         flow_inits,\n         move_data,\n         drop_data: FxHashMap(),\n-        map: &NllLivenessMap::compute(mir),\n     };\n \n     for bb in mir.basic_blocks().indices() {\n@@ -65,10 +66,10 @@ where\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n     liveness: &'gen LivenessResults<LocalWithRegion>,\n+    liveness_map: &'gen NllLivenessMap,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n     drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n-    map: &'gen NllLivenessMap,\n }\n \n struct DropData<'tcx> {\n@@ -86,9 +87,9 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n \n         self.liveness\n             .regular\n-            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.liveness_map, |location, live_locals| {\n                 for live_local in live_locals.iter() {\n-                    let local = self.map.from_live_var(live_local);\n+                    let local = self.liveness_map.from_live_var(live_local);\n                     let live_local_ty = self.mir.local_decls[local].ty;\n                     Self::push_type_live_constraint(&mut self.cx, live_local_ty, location);\n                 }\n@@ -97,7 +98,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         let mut all_live_locals: Vec<(Location, Vec<LocalWithRegion>)> = vec![];\n         self.liveness\n             .drop\n-            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.liveness_map, |location, live_locals| {\n                 all_live_locals.push((location, live_locals.iter().collect()));\n             });\n         debug!(\n@@ -124,7 +125,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                     });\n                 }\n \n-                let local = self.map.from_live_var(live_local);\n+                let local = self.liveness_map.from_live_var(live_local);\n                 let mpi = self.move_data.rev_lookup.find_local(local);\n                 if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n                     debug!(\n@@ -133,7 +134,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                         self.move_data.move_paths[initialized_child]\n                     );\n \n-                    let local = self.map.from_live_var(live_local);\n+                    let local = self.liveness_map.from_live_var(live_local);\n                     let live_local_ty = self.mir.local_decls[local].ty;\n                     self.add_drop_live_constraint(live_local, live_local_ty, location);\n                 }"}, {"sha": "15afc6c52bf2b34eec323282f19e110bad45aec2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=b47c314c5652c8ecc3f086b0326f467b857b9d5b", "patch": "@@ -15,9 +15,12 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::values::{RegionValueElements, LivenessValues};\n+use borrow_check::nll::liveness_map::NllLivenessMap;\n+use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n-use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n+use borrow_check::nll::type_check::free_region_relations::{\n+    CreateResult, UniversalRegionRelations,\n+};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::LocalWithRegion;\n use borrow_check::nll::ToRegionVid;\n@@ -116,6 +119,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n+    liveness_map: &NllLivenessMap,\n     all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -166,7 +170,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             Some(&mut borrowck_context),\n             Some(errors_buffer),\n             |cx| {\n-                liveness::generate(cx, mir, liveness, flow_inits, move_data);\n+                liveness::generate(cx, mir, liveness, liveness_map, flow_inits, move_data);\n                 cx.equate_inputs_and_outputs(\n                     mir,\n                     mir_def_id,"}, {"sha": "52f1547bce6f86f33b7bcd359e41186aef326d06", "filename": "src/test/ui/borrowck/promote-ref-mut-in-let-issue-46557.nll.stderr", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr?ref=b47c314c5652c8ecc3f086b0326f467b857b9d5b", "patch": "@@ -1,30 +1,24 @@\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:15:21\n    |\n-LL |   fn gimme_static_mut_let() -> &'static mut u32 {\n-   |  _______________________________________________-\n-LL | |     let ref mut x = 1234543; //~ ERROR\n-   | |                     ^^^^^^^ temporary value does not live long enough\n-LL | |     x\n-LL | | }\n-   | | -\n-   | | |\n-   | |_temporary value only lives until here\n-   |   borrow later used here\n+LL |     let ref mut x = 1234543; //~ ERROR\n+   |                     ^^^^^^^ temporary value does not live long enough\n+LL |     x\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:20:25\n    |\n-LL |   fn gimme_static_mut_let_nested() -> &'static mut u32 {\n-   |  ______________________________________________________-\n-LL | |     let (ref mut x, ) = (1234543, ); //~ ERROR\n-   | |                         ^^^^^^^^^^^ temporary value does not live long enough\n-LL | |     x\n-LL | | }\n-   | | -\n-   | | |\n-   | |_temporary value only lives until here\n-   |   borrow later used here\n+LL |     let (ref mut x, ) = (1234543, ); //~ ERROR\n+   |                         ^^^^^^^^^^^ temporary value does not live long enough\n+LL |     x\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:25:11"}, {"sha": "580dce3c0fe632691f65bc1d8d35d1e153275397", "filename": "src/test/ui/nll/get_default.nll.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr?ref=b47c314c5652c8ecc3f086b0326f467b857b9d5b", "patch": "@@ -63,9 +63,18 @@ LL |         match map.get() {\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n-...\n-LL |                 return v;\n-   |                        - borrow later used here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n+  --> $DIR/get_default.rs:41:1\n+   |\n+LL | / fn err(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n   --> $DIR/get_default.rs:51:17"}, {"sha": "2f8eab907c7bb5185353420d28460e9ac2cd38e6", "filename": "src/test/ui/nll/get_default.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=b47c314c5652c8ecc3f086b0326f467b857b9d5b", "patch": "@@ -63,9 +63,18 @@ LL |         match map.get() {\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^ mutable borrow occurs here\n-...\n-LL |                 return v;\n-   |                        - borrow later used here\n+   |\n+note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n+  --> $DIR/get_default.rs:41:1\n+   |\n+LL | / fn err(map: &mut Map) -> &String {\n+LL | |     loop {\n+LL | |         match map.get() {\n+LL | |             Some(v) => {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n   --> $DIR/get_default.rs:51:17"}, {"sha": "f441085f242edddc102c2078ba1fd1691134b523", "filename": "src/test/ui/nll/return-ref-mut-issue-46557.stderr", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b47c314c5652c8ecc3f086b0326f467b857b9d5b/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr?ref=b47c314c5652c8ecc3f086b0326f467b857b9d5b", "patch": "@@ -1,16 +1,13 @@\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/return-ref-mut-issue-46557.rs:17:21\n    |\n-LL |   fn gimme_static_mut() -> &'static mut u32 {\n-   |  ___________________________________________-\n-LL | |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n-   | |                     ^^^^^^^ temporary value does not live long enough\n-LL | |     x\n-LL | | }\n-   | | -\n-   | | |\n-   | |_temporary value only lives until here\n-   |   borrow later used here\n+LL |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n+   |                     ^^^^^^^ temporary value does not live long enough\n+LL |     x\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error: aborting due to previous error\n "}]}