{"sha": "e0df0429c49bce88e9d81ead810804047ea26631", "node_id": "C_kwDOAAsO6NoAKGUwZGYwNDI5YzQ5YmNlODhlOWQ4MWVhZDgxMDgwNDA0N2VhMjY2MzE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-01-23T01:39:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-01-23T01:39:57Z"}, "message": "Merge from rustc", "tree": {"sha": "5c70e7ac6f8df274ef2fee968f9e8b3fecf76c9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c70e7ac6f8df274ef2fee968f9e8b3fecf76c9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0df0429c49bce88e9d81ead810804047ea26631", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0df0429c49bce88e9d81ead810804047ea26631", "html_url": "https://github.com/rust-lang/rust/commit/e0df0429c49bce88e9d81ead810804047ea26631", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0df0429c49bce88e9d81ead810804047ea26631/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb7770736c15488ec816d24ed41928d513f56b4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7770736c15488ec816d24ed41928d513f56b4c", "html_url": "https://github.com/rust-lang/rust/commit/cb7770736c15488ec816d24ed41928d513f56b4c"}, {"sha": "002dbbeafa39d0375ba45d2e9f7bc2d4ae248c59", "url": "https://api.github.com/repos/rust-lang/rust/commits/002dbbeafa39d0375ba45d2e9f7bc2d4ae248c59", "html_url": "https://github.com/rust-lang/rust/commit/002dbbeafa39d0375ba45d2e9f7bc2d4ae248c59"}], "stats": {"total": 15719, "additions": 10308, "deletions": 5411}, "files": [{"sha": "42c86a827693a16de9fe7fc3cc925bdbfa8de70c", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -15,6 +15,7 @@ Adrien T\u00e9tar <adri-from-59@hotmail.fr>\n Ahmed Charles <ahmedcharles@gmail.com> <acharles@outlook.com>\n Alan Egerton <eggyal@gmail.com>\n Alan Stoate <alan.stoate@gmail.com>\n+Albert Larsan <albert.larsan@gmail.com> Albert Larsan <74931857+albertlarsan68@users.noreply.github.com>\n Alessandro Decina <alessandro.d@gmail.com>\n Alex Burka <durka42+github@gmail.com> Alex Burka <aburka@seas.upenn.edu>\n Alex Hansen <ahansen2@trinity.edu>"}, {"sha": "cc1b5dcf6a76e5571d869c6363c1732d3233b1f9", "filename": "Cargo.lock", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -351,7 +351,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap 4.0.32\",\n+ \"clap 4.1.1\",\n  \"crates-io\",\n  \"curl\",\n  \"curl-sys\",\n@@ -551,9 +551,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.76\"\n+version = \"1.0.77\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"76a284da2e6fe2092f2353e51713435363112dfd60030e22add80be333fb928f\"\n+checksum = \"e9f73505338f7d905b19d18738976aae232eb46b8efc15554ffc56deb5d9ebe4\"\n dependencies = [\n  \"jobserver\",\n ]\n@@ -655,12 +655,12 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"4.0.32\"\n+version = \"4.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a7db700bc935f9e43e88d00b0850dae18a63773cfbec6d8e070fccf7fef89a39\"\n+checksum = \"4ec7a4128863c188deefe750ac1d1dfe66c236909f845af04beed823638dc1b2\"\n dependencies = [\n  \"bitflags\",\n- \"clap_derive 4.0.21\",\n+ \"clap_derive 4.1.0\",\n  \"clap_lex 0.3.0\",\n  \"is-terminal\",\n  \"once_cell\",\n@@ -675,7 +675,7 @@ version = \"4.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"10861370d2ba66b0f5989f83ebf35db6421713fd92351790e7fdd6c36774c56b\"\n dependencies = [\n- \"clap 4.0.32\",\n+ \"clap 4.1.1\",\n ]\n \n [[package]]\n@@ -693,9 +693,9 @@ dependencies = [\n \n [[package]]\n name = \"clap_derive\"\n-version = \"4.0.21\"\n+version = \"4.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0177313f9f02afc995627906bbd8967e2be069f5261954222dac78290c2b9014\"\n+checksum = \"684a277d672e91966334af371f1a7b5833f9aa00b07c84e92fbce95e00208ce8\"\n dependencies = [\n  \"heck\",\n  \"proc-macro-error\",\n@@ -1799,9 +1799,9 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.16.0\"\n+version = \"0.16.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be36bc9e0546df253c0cc41fd0af34f5e92845ad8509462ec76672fac6997f5b\"\n+checksum = \"ccf7f68c2995f392c49fffb4f95ae2c873297830eb25c6bc4c114ce8f4562acc\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -2294,7 +2294,7 @@ name = \"jsondoclint\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap 4.0.32\",\n+ \"clap 4.1.1\",\n  \"fs-err\",\n  \"rustdoc-json-types\",\n  \"serde\",\n@@ -2365,9 +2365,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.14.1+1.5.0\"\n+version = \"0.14.2+1.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4a07fb2692bc3593bda59de45a502bb3071659f2c515e28c71e728306b038e17\"\n+checksum = \"7f3d95f6b51075fe9810a7ae22c7095f12b98005ab364d8544797a825ce946a4\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -2557,7 +2557,7 @@ dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap 4.0.32\",\n+ \"clap 4.1.1\",\n  \"clap_complete\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.10.0\",\n@@ -3528,7 +3528,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 4.0.32\",\n+ \"clap 4.1.1\",\n  \"env_logger 0.7.1\",\n  \"mdbook\",\n ]\n@@ -4783,6 +4783,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_parse_format\",\n  \"rustc_query_system\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -5607,6 +5608,7 @@ dependencies = [\n  \"lazy_static\",\n  \"miropt-test-tools\",\n  \"regex\",\n+ \"semver\",\n  \"termcolor\",\n  \"walkdir\",\n ]"}, {"sha": "0eb7c4b266a9f3a529e1b3c555ac2bf1dee974c1", "filename": "README.md", "status": "modified", "additions": 90, "deletions": 73, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -3,10 +3,11 @@\n This is the main source code repository for [Rust]. It contains the compiler,\n standard library, and documentation.\n \n-[Rust]: https://www.rust-lang.org\n+[Rust]: https://www.rust-lang.org/\n \n **Note: this README is for _users_ rather than _contributors_.**\n-If you wish to _contribute_ to the compiler, you should read [CONTRIBUTING.md](CONTRIBUTING.md) instead.\n+If you wish to _contribute_ to the compiler, you should read\n+[CONTRIBUTING.md](CONTRIBUTING.md) instead.\n \n ## Quick Start\n \n@@ -20,13 +21,15 @@ Read [\"Installation\"] from [The Book].\n The Rust build system uses a Python script called `x.py` to build the compiler,\n which manages the bootstrapping process. It lives at the root of the project.\n \n-The `x.py` command can be run directly on most Unix systems in the following format:\n+The `x.py` command can be run directly on most Unix systems in the following\n+format:\n \n ```sh\n ./x.py <subcommand> [flags]\n ```\n \n-This is how the documentation and examples assume you are running `x.py`. Some alternative ways are:\n+This is how the documentation and examples assume you are running `x.py`.\n+Some alternative ways are:\n \n ```sh\n # On a Unix shell if you don't have the necessary `python3` command\n@@ -39,8 +42,8 @@ x.py <subcommand> [flags]\n python x.py <subcommand> [flags]\n ```\n \n-More information about `x.py` can be found\n-by running it with the `--help` flag or reading the [rustc dev guide][rustcguidebuild].\n+More information about `x.py` can be found by running it with the `--help` flag\n+or reading the [rustc dev guide][rustcguidebuild].\n \n [gettingstarted]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n [rustcguidebuild]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n@@ -49,24 +52,29 @@ by running it with the `--help` flag or reading the [rustc dev guide][rustcguide\n \n Make sure you have installed the dependencies:\n \n-   * `python` 3 or 2.7\n-   * `git`\n-   * A C compiler (when building for the host, `cc` is enough; cross-compiling may need additional compilers)\n-   * `curl` (not needed on Windows)\n-   * `pkg-config` if you are compiling on Linux and targeting Linux\n-   * `libiconv` (already included with glibc on Debian-based distros)\n+* `python` 3 or 2.7\n+* `git`\n+* A C compiler (when building for the host, `cc` is enough; cross-compiling may\n+  need additional compilers)\n+* `curl` (not needed on Windows)\n+* `pkg-config` if you are compiling on Linux and targeting Linux\n+* `libiconv` (already included with glibc on Debian-based distros)\n \n-To build cargo, you'll also need OpenSSL (`libssl-dev` or `openssl-devel` on most Unix distros).\n+To build Cargo, you'll also need OpenSSL (`libssl-dev` or `openssl-devel` on\n+most Unix distros).\n \n If building LLVM from source, you'll need additional tools:\n \n * `g++`, `clang++`, or MSVC with versions listed on\n   [LLVM's documentation](https://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library)\n-* `ninja`, or GNU `make` 3.81 or later (ninja is recommended, especially on Windows)\n+* `ninja`, or GNU `make` 3.81 or later (Ninja is recommended, especially on\n+  Windows)\n * `cmake` 3.13.4 or later\n-* `libstdc++-static` may be required on some Linux distributions such as Fedora and Ubuntu\n+* `libstdc++-static` may be required on some Linux distributions such as Fedora\n+  and Ubuntu\n \n-On tier 1 or tier 2 with host tools platforms, you can also choose to download LLVM by setting `llvm.download-ci-llvm = true`.\n+On tier 1 or tier 2 with host tools platforms, you can also choose to download\n+LLVM by setting `llvm.download-ci-llvm = true`.\n Otherwise, you'll need LLVM installed and `llvm-config` in your path.\n See [the rustc-dev-guide for more info][sysllvm].\n \n@@ -86,52 +94,57 @@ See [the rustc-dev-guide for more info][sysllvm].\n \n 2. Configure the build settings:\n \n-    The Rust build system uses a file named `config.toml` in the root of the\n-    source tree to determine various configuration settings for the build.\n-    Set up the defaults intended for distros to get started. You can see a full list of options\n-    in `config.toml.example`.\n+   The Rust build system uses a file named `config.toml` in the root of the\n+   source tree to determine various configuration settings for the build.\n+   Set up the defaults intended for distros to get started. You can see a full\n+   list of options in `config.toml.example`.\n \n-    ```sh\n-    printf 'profile = \"user\" \\nchangelog-seen = 2 \\n' > config.toml\n-    ```\n+   ```sh\n+   printf 'profile = \"user\" \\nchangelog-seen = 2 \\n' > config.toml\n+   ```\n \n-    If you plan to use `x.py install` to create an installation, it is recommended\n-    that you set the `prefix` value in the `[install]` section to a directory.\n+   If you plan to use `x.py install` to create an installation, it is\n+   recommended that you set the `prefix` value in the `[install]` section to a\n+   directory.\n \n 3. Build and install:\n \n-    ```sh\n-    ./x.py build && ./x.py install\n-    ```\n+   ```sh\n+   ./x.py build && ./x.py install\n+   ```\n \n-    When complete, `./x.py install` will place several programs into\n-    `$PREFIX/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n-    API-documentation tool. If you've set `profile = \"user\"` or `build.extended = true`, it will\n-    also include [Cargo], Rust's package manager.\n+   When complete, `./x.py install` will place several programs into\n+   `$PREFIX/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n+   API-documentation tool. If you've set `profile = \"user\"` or\n+   `build.extended = true`, it will also include [Cargo], Rust's package\n+   manager.\n \n [Cargo]: https://github.com/rust-lang/cargo\n \n ### Building on Windows\n \n-On Windows, we suggest using [winget] to install dependencies by running the following in a terminal:\n+On Windows, we suggest using [winget] to install dependencies by running the\n+following in a terminal:\n \n ```powershell\n winget install -e Python.Python.3\n winget install -e Kitware.CMake\n winget install -e Git.Git\n ```\n \n-Then edit your system's `PATH` variable and add: `C:\\Program Files\\CMake\\bin`. See\n-[this guide on editing the system `PATH`](https://www.java.com/en/download/help/path.html) from the\n-Java documentation.\n+Then edit your system's `PATH` variable and add: `C:\\Program Files\\CMake\\bin`.\n+See\n+[this guide on editing the system `PATH`](https://www.java.com/en/download/help/path.html)\n+from the Java documentation.\n \n [winget]: https://github.com/microsoft/winget-cli\n \n There are two prominent ABIs in use on Windows: the native (MSVC) ABI used by\n Visual Studio and the GNU ABI used by the GCC toolchain. Which version of Rust\n you need depends largely on what C/C++ libraries you want to interoperate with.\n-Use the MSVC build of Rust to interop with software produced by Visual Studio and\n-the GNU build to interop with GNU software built using the MinGW/MSYS2 toolchain.\n+Use the MSVC build of Rust to interop with software produced by Visual Studio\n+and the GNU build to interop with GNU software built using the MinGW/MSYS2\n+toolchain.\n \n #### MinGW\n \n@@ -144,7 +157,7 @@ the GNU build to interop with GNU software built using the MinGW/MSYS2 toolchain\n 2. Run `mingw32_shell.bat` or `mingw64_shell.bat` from the MSYS2 installation\n    directory (e.g. `C:\\msys64`), depending on whether you want 32-bit or 64-bit\n    Rust. (As of the latest version of MSYS2 you have to run `msys2_shell.cmd\n-   -mingw32` or `msys2_shell.cmd -mingw64` from the command line instead)\n+   -mingw32` or `msys2_shell.cmd -mingw64` from the command line instead.)\n \n 3. From this terminal, install the required tools:\n \n@@ -153,11 +166,11 @@ the GNU build to interop with GNU software built using the MinGW/MSYS2 toolchain\n    pacman -Sy pacman-mirrors\n \n    # Install build tools needed for Rust. If you're building a 32-bit compiler,\n-   # then replace \"x86_64\" below with \"i686\". If you've already got git, python,\n-   # or CMake installed and in PATH you can remove them from this list. Note\n-   # that it is important that you do **not** use the 'python2', 'cmake' and 'ninja'\n-   # packages from the 'msys2' subsystem. The build has historically been known\n-   # to fail with these packages.\n+   # then replace \"x86_64\" below with \"i686\". If you've already got Git, Python,\n+   # or CMake installed and in PATH you can remove them from this list.\n+   # Note that it is important that you do **not** use the 'python2', 'cmake',\n+   # and 'ninja' packages from the 'msys2' subsystem.\n+   # The build has historically been known to fail with these packages.\n    pacman -S git \\\n                make \\\n                diffutils \\\n@@ -178,12 +191,12 @@ the GNU build to interop with GNU software built using the MinGW/MSYS2 toolchain\n \n MSVC builds of Rust additionally require an installation of Visual Studio 2017\n (or later) so `rustc` can use its linker.  The simplest way is to get\n-[Visual Studio], check the \u201cC++ build tools\u201d and \u201cWindows 10 SDK\u201d workload.\n+[Visual Studio], check the \"C++ build tools\" and \"Windows 10 SDK\" workload.\n \n [Visual Studio]: https://visualstudio.microsoft.com/downloads/\n \n-(If you're installing cmake yourself, be careful that \u201cC++ CMake tools for\n-Windows\u201d doesn't get included under \u201cIndividual components\u201d.)\n+(If you're installing CMake yourself, be careful that \"C++ CMake tools for\n+Windows\" doesn't get included under \"Individual components\".)\n \n With these dependencies installed, you can build the compiler in a `cmd.exe`\n shell with:\n@@ -192,10 +205,11 @@ shell with:\n python x.py build\n ```\n \n-Right now, building Rust only works with some known versions of Visual Studio. If\n-you have a more recent version installed and the build system doesn't understand,\n-you may need to force rustbuild to use an older version. This can be done\n-by manually calling the appropriate vcvars file before running the bootstrap.\n+Right now, building Rust only works with some known versions of Visual Studio.\n+If you have a more recent version installed and the build system doesn't\n+understand, you may need to force rustbuild to use an older version.\n+This can be done by manually calling the appropriate vcvars file before running\n+the bootstrap.\n \n ```batch\n CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n@@ -215,9 +229,9 @@ Windows build triples are:\n     - `x86_64-pc-windows-msvc`\n \n The build triple can be specified by either specifying `--build=<triple>` when\n-invoking `x.py` commands, or by creating a `config.toml` file (as described\n-in [Installing From Source](#installing-from-source)), and modifying the\n-`build` option under the `[build]` section.\n+invoking `x.py` commands, or by creating a `config.toml` file (as described in\n+[Installing from Source](#installing-from-source)), and modifying the `build`\n+option under the `[build]` section.\n \n ### Configure and Make\n \n@@ -229,33 +243,35 @@ configure script and makefile (the latter of which just invokes `x.py`).\n make && sudo make install\n ```\n \n-`configure` generates a `config.toml` which can also be used with normal `x.py` invocations.\n+`configure` generates a `config.toml` which can also be used with normal `x.py`\n+invocations.\n \n ## Building Documentation\n \n-If you\u2019d like to build the documentation, it\u2019s almost the same:\n+If you'd like to build the documentation, it's almost the same:\n \n ```sh\n ./x.py doc\n ```\n \n The generated documentation will appear under `doc` in the `build` directory for\n-the ABI used. I.e., if the ABI was `x86_64-pc-windows-msvc`, the directory will be\n-`build\\x86_64-pc-windows-msvc\\doc`.\n+the ABI used. That is, if the ABI was `x86_64-pc-windows-msvc`, the directory\n+will be `build\\x86_64-pc-windows-msvc\\doc`.\n \n ## Notes\n \n-Since the Rust compiler is written in Rust, it must be built by a\n-precompiled \"snapshot\" version of itself (made in an earlier stage of\n-development). As such, source builds require an Internet connection to\n-fetch snapshots, and an OS that can execute the available snapshot binaries.\n+Since the Rust compiler is written in Rust, it must be built by a precompiled\n+\"snapshot\" version of itself (made in an earlier stage of development).\n+As such, source builds require an Internet connection to fetch snapshots, and an\n+OS that can execute the available snapshot binaries.\n \n-See https://doc.rust-lang.org/nightly/rustc/platform-support.html for a list of supported platforms.\n-Only \"host tools\" platforms have a pre-compiled snapshot binary available; to compile for a platform\n-without host tools you must cross-compile.\n+See https://doc.rust-lang.org/nightly/rustc/platform-support.html for a list of\n+supported platforms.\n+Only \"host tools\" platforms have a pre-compiled snapshot binary available; to\n+compile for a platform without host tools you must cross-compile.\n \n-You may find that other platforms work, but these are our officially\n-supported build environments that are most likely to work.\n+You may find that other platforms work, but these are our officially supported\n+build environments that are most likely to work.\n \n ## Getting Help\n \n@@ -267,23 +283,24 @@ See [CONTRIBUTING.md](CONTRIBUTING.md).\n \n ## License\n \n-Rust is primarily distributed under the terms of both the MIT license\n-and the Apache License (Version 2.0), with portions covered by various\n-BSD-like licenses.\n+Rust is primarily distributed under the terms of both the MIT license and the\n+Apache License (Version 2.0), with portions covered by various BSD-like\n+licenses.\n \n See [LICENSE-APACHE](LICENSE-APACHE), [LICENSE-MIT](LICENSE-MIT), and\n [COPYRIGHT](COPYRIGHT) for details.\n \n ## Trademark\n \n [The Rust Foundation][rust-foundation] owns and protects the Rust and Cargo\n-trademarks and logos (the \u201cRust Trademarks\u201d).\n+trademarks and logos (the \"Rust Trademarks\").\n \n-If you want to use these names or brands, please read the [media guide][media-guide].\n+If you want to use these names or brands, please read the\n+[media guide][media-guide].\n \n Third-party logos may be subject to third-party copyrights and trademarks. See\n [Licenses][policies-licenses] for details.\n \n [rust-foundation]: https://foundation.rust-lang.org/\n-[media-guide]: https://www.rust-lang.org/policies/media-guide\n+[media-guide]: https://foundation.rust-lang.org/policies/logo-policy-and-media-guide/\n [policies-licenses]: https://www.rust-lang.org/policies/licenses"}, {"sha": "9317579f70dd5967cb5e80382c8cab541c58ecea", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -2032,7 +2032,8 @@ impl Clone for Ty {\n impl Ty {\n     pub fn peel_refs(&self) -> &Self {\n         let mut final_ty = self;\n-        while let TyKind::Ref(_, MutTy { ty, .. }) = &final_ty.kind {\n+        while let TyKind::Ref(_, MutTy { ty, .. }) | TyKind::Ptr(MutTy { ty, .. }) = &final_ty.kind\n+        {\n             final_ty = ty;\n         }\n         final_ty"}, {"sha": "902b4b1a1ecfefb5fa53fbbfd499f2a2b0329dfb", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1100,16 +1100,17 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         replace_span: self.ending_semi_or_hi(item.span),\n                         extern_block_suggestion: match sig.header.ext {\n                             Extern::None => None,\n-                            Extern::Implicit(start_span) => Some(ExternBlockSuggestion {\n+                            Extern::Implicit(start_span) => Some(ExternBlockSuggestion::Implicit {\n                                 start_span,\n                                 end_span: item.span.shrink_to_hi(),\n-                                abi: None,\n-                            }),\n-                            Extern::Explicit(abi, start_span) => Some(ExternBlockSuggestion {\n-                                start_span,\n-                                end_span: item.span.shrink_to_hi(),\n-                                abi: Some(abi.symbol_unescaped),\n                             }),\n+                            Extern::Explicit(abi, start_span) => {\n+                                Some(ExternBlockSuggestion::Explicit {\n+                                    start_span,\n+                                    end_span: item.span.shrink_to_hi(),\n+                                    abi: abi.symbol_unescaped,\n+                                })\n+                            }\n                         },\n                     });\n                 }"}, {"sha": "09e262452b11d5819d0f743fa53b0ca1f264f2cd", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,6 +1,5 @@\n //! Errors emitted by ast_passes.\n \n-use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic, SubdiagnosticMessage};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{Span, Symbol};\n \n@@ -207,28 +206,21 @@ pub struct FnWithoutBody {\n     pub extern_block_suggestion: Option<ExternBlockSuggestion>,\n }\n \n-pub struct ExternBlockSuggestion {\n-    pub start_span: Span,\n-    pub end_span: Span,\n-    pub abi: Option<Symbol>,\n-}\n-\n-impl AddToDiagnostic for ExternBlockSuggestion {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n-    where\n-        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n-    {\n-        let start_suggestion = if let Some(abi) = self.abi {\n-            format!(\"extern \\\"{}\\\" {{\", abi)\n-        } else {\n-            \"extern {\".to_owned()\n-        };\n-        let end_suggestion = \" }\".to_owned();\n-\n-        diag.multipart_suggestion(\n-            fluent::extern_block_suggestion,\n-            vec![(self.start_span, start_suggestion), (self.end_span, end_suggestion)],\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n+#[derive(Subdiagnostic)]\n+pub enum ExternBlockSuggestion {\n+    #[multipart_suggestion(ast_passes_extern_block_suggestion, applicability = \"maybe-incorrect\")]\n+    Implicit {\n+        #[suggestion_part(code = \"extern {{\")]\n+        start_span: Span,\n+        #[suggestion_part(code = \" }}\")]\n+        end_span: Span,\n+    },\n+    #[multipart_suggestion(ast_passes_extern_block_suggestion, applicability = \"maybe-incorrect\")]\n+    Explicit {\n+        #[suggestion_part(code = \"extern \\\"{abi}\\\" {{\")]\n+        start_span: Span,\n+        #[suggestion_part(code = \" }}\")]\n+        end_span: Span,\n+        abi: Symbol,\n+    },\n }"}, {"sha": "e5a36259fa495c0abdff6188e8dc5862499dbdbe", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -673,40 +673,34 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         // Find out if the predicates show that the type is a Fn or FnMut\n-        let find_fn_kind_from_did = |predicates: ty::EarlyBinder<\n-            &[(ty::Predicate<'tcx>, Span)],\n-        >,\n-                                     substs| {\n-            predicates.0.iter().find_map(|(pred, _)| {\n-                    let pred = if let Some(substs) = substs {\n-                        predicates.rebind(*pred).subst(tcx, substs).kind().skip_binder()\n-                    } else {\n-                        pred.kind().skip_binder()\n-                    };\n-                    if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = pred && pred.self_ty() == ty {\n-                    if Some(pred.def_id()) == tcx.lang_items().fn_trait() {\n-                        return Some(hir::Mutability::Not);\n-                    } else if Some(pred.def_id()) == tcx.lang_items().fn_mut_trait() {\n-                        return Some(hir::Mutability::Mut);\n-                    }\n+        let find_fn_kind_from_did = |(pred, _): (ty::Predicate<'tcx>, _)| {\n+            if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = pred.kind().skip_binder()\n+                && pred.self_ty() == ty\n+            {\n+                if Some(pred.def_id()) == tcx.lang_items().fn_trait() {\n+                    return Some(hir::Mutability::Not);\n+                } else if Some(pred.def_id()) == tcx.lang_items().fn_mut_trait() {\n+                    return Some(hir::Mutability::Mut);\n                 }\n-                    None\n-                })\n+            }\n+            None\n         };\n \n         // If the type is opaque/param/closure, and it is Fn or FnMut, let's suggest (mutably)\n         // borrowing the type, since `&mut F: FnMut` iff `F: FnMut` and similarly for `Fn`.\n         // These types seem reasonably opaque enough that they could be substituted with their\n         // borrowed variants in a function body when we see a move error.\n-        let borrow_level = match ty.kind() {\n-            ty::Param(_) => find_fn_kind_from_did(\n-                tcx.bound_explicit_predicates_of(self.mir_def_id().to_def_id())\n-                    .map_bound(|p| p.predicates),\n-                None,\n-            ),\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                find_fn_kind_from_did(tcx.bound_explicit_item_bounds(*def_id), Some(*substs))\n-            }\n+        let borrow_level = match *ty.kind() {\n+            ty::Param(_) => tcx\n+                .explicit_predicates_of(self.mir_def_id().to_def_id())\n+                .predicates\n+                .iter()\n+                .copied()\n+                .find_map(find_fn_kind_from_did),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => tcx\n+                .bound_explicit_item_bounds(def_id)\n+                .subst_iter_copied(tcx, substs)\n+                .find_map(find_fn_kind_from_did),\n             ty::Closure(_, substs) => match substs.as_closure().kind() {\n                 ty::ClosureKind::Fn => Some(hir::Mutability::Not),\n                 ty::ClosureKind::FnMut => Some(hir::Mutability::Mut),\n@@ -2199,7 +2193,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut back_edge_stack = Vec::new();\n \n         predecessor_locations(self.body, location).for_each(|predecessor| {\n-            if location.dominates(predecessor, &self.dominators) {\n+            if location.dominates(predecessor, self.dominators()) {\n                 back_edge_stack.push(predecessor)\n             } else {\n                 stack.push(predecessor);\n@@ -2311,7 +2305,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             let mut has_predecessor = false;\n             predecessor_locations(self.body, location).for_each(|predecessor| {\n-                if location.dominates(predecessor, &self.dominators) {\n+                if location.dominates(predecessor, self.dominators()) {\n                     back_edge_stack.push(predecessor)\n                 } else {\n                     stack.push(predecessor);"}, {"sha": "187861ba127bd93e36af2707722146eee40ff574", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 113, "deletions": 4, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -5,8 +5,13 @@\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n+use rustc_hir::def::Res::Def;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n+use rustc_hir::GenericBound::Trait;\n+use rustc_hir::QPath::Resolved;\n+use rustc_hir::WherePredicate::BoundPredicate;\n+use rustc_hir::{PolyTraitRef, TyKind, WhereBoundPredicate};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::{\n         self, find_anon_type, find_param_with_region, suggest_adding_lifetime_params,\n@@ -186,6 +191,101 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         false\n     }\n \n+    // For generic associated types (GATs) which implied 'static requirement\n+    // from higher-ranked trait bounds (HRTB). Try to locate span of the trait\n+    // and the span which bounded to the trait for adding 'static lifetime suggestion\n+    fn suggest_static_lifetime_for_gat_from_hrtb(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        lower_bound: RegionVid,\n+    ) {\n+        let mut suggestions = vec![];\n+        let hir = self.infcx.tcx.hir();\n+\n+        // find generic associated types in the given region 'lower_bound'\n+        let gat_id_and_generics = self\n+            .regioncx\n+            .placeholders_contained_in(lower_bound)\n+            .map(|placeholder| {\n+                if let Some(id) = placeholder.name.get_id()\n+                    && let Some(placeholder_id) = id.as_local()\n+                    && let gat_hir_id = hir.local_def_id_to_hir_id(placeholder_id)\n+                    && let Some(generics_impl) = hir.get_parent(gat_hir_id).generics()\n+                {\n+                    Some((gat_hir_id, generics_impl))\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        debug!(?gat_id_and_generics);\n+\n+        // find higher-ranked trait bounds bounded to the generic associated types\n+        let mut hrtb_bounds = vec![];\n+        gat_id_and_generics.iter().flatten().for_each(|(gat_hir_id, generics)| {\n+            for pred in generics.predicates {\n+                let BoundPredicate(\n+                        WhereBoundPredicate {\n+                            bound_generic_params,\n+                            bounds,\n+                            ..\n+                        }) = pred else { continue; };\n+                if bound_generic_params\n+                    .iter()\n+                    .rfind(|bgp| hir.local_def_id_to_hir_id(bgp.def_id) == *gat_hir_id)\n+                    .is_some()\n+                {\n+                    for bound in *bounds {\n+                        hrtb_bounds.push(bound);\n+                    }\n+                }\n+            }\n+        });\n+        debug!(?hrtb_bounds);\n+\n+        hrtb_bounds.iter().for_each(|bound| {\n+            let Trait(PolyTraitRef { trait_ref, span: trait_span, .. }, _) = bound else { return; };\n+            diag.span_note(\n+                *trait_span,\n+                format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\")\n+            );\n+            let Some(generics_fn) = hir.get_generics(self.body.source.def_id().expect_local()) else { return; };\n+            let Def(_, trait_res_defid) = trait_ref.path.res else { return; };\n+            debug!(?generics_fn);\n+            generics_fn.predicates.iter().for_each(|predicate| {\n+                let BoundPredicate(\n+                    WhereBoundPredicate {\n+                        span: bounded_span,\n+                        bounded_ty,\n+                        bounds,\n+                        ..\n+                    }\n+                ) = predicate else { return; };\n+                bounds.iter().for_each(|bd| {\n+                    if let Trait(PolyTraitRef { trait_ref: tr_ref, .. }, _) = bd\n+                        && let Def(_, res_defid) = tr_ref.path.res\n+                        && res_defid == trait_res_defid // trait id matches\n+                        && let TyKind::Path(Resolved(_, path)) = bounded_ty.kind\n+                        && let Def(_, defid) = path.res\n+                        && generics_fn.params\n+                            .iter()\n+                            .rfind(|param| param.def_id.to_def_id() == defid)\n+                            .is_some() {\n+                            suggestions.push((bounded_span.shrink_to_hi(), format!(\" + 'static\")));\n+                        }\n+                });\n+            });\n+        });\n+        if suggestions.len() > 0 {\n+            suggestions.dedup();\n+            diag.multipart_suggestion_verbose(\n+                format!(\"consider restricting the type parameter to the `'static` lifetime\"),\n+                suggestions,\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+\n     /// Produces nice borrowck error diagnostics for all the errors collected in `nll_errors`.\n     pub(crate) fn report_region_errors(&mut self, nll_errors: RegionErrors<'tcx>) {\n         // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n@@ -223,12 +323,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // to report it; we could probably handle it by\n                         // iterating over the universal regions and reporting\n                         // an error that multiple bounds are required.\n-                        self.buffer_error(self.infcx.tcx.sess.create_err(\n-                            GenericDoesNotLiveLongEnough {\n+                        let mut diag =\n+                            self.infcx.tcx.sess.create_err(GenericDoesNotLiveLongEnough {\n                                 kind: type_test.generic_kind.to_string(),\n                                 span: type_test_span,\n-                            },\n-                        ));\n+                            });\n+\n+                        // Add notes and suggestions for the case of 'static lifetime\n+                        // implied but not specified when a generic associated types\n+                        // are from higher-ranked trait bounds\n+                        self.suggest_static_lifetime_for_gat_from_hrtb(\n+                            &mut diag,\n+                            type_test.lower_bound,\n+                        );\n+\n+                        self.buffer_error(diag);\n                     }\n                 }\n "}, {"sha": "73ea7314b75cc202c6a9091ed39ad2b7d4dae464", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -5,6 +5,7 @@\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n+#![feature(once_cell)]\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![feature(trusted_step)]\n@@ -39,6 +40,7 @@ use rustc_span::{Span, Symbol};\n \n use either::Either;\n use smallvec::SmallVec;\n+use std::cell::OnceCell;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::rc::Rc;\n@@ -333,7 +335,7 @@ fn do_mir_borrowck<'tcx>(\n                 used_mut: Default::default(),\n                 used_mut_upvars: SmallVec::new(),\n                 borrow_set: Rc::clone(&borrow_set),\n-                dominators: Dominators::dummy(), // not used\n+                dominators: Default::default(),\n                 upvars: Vec::new(),\n                 local_names: IndexVec::from_elem(None, &promoted_body.local_decls),\n                 region_names: RefCell::default(),\n@@ -346,8 +348,6 @@ fn do_mir_borrowck<'tcx>(\n         };\n     }\n \n-    let dominators = body.basic_blocks.dominators();\n-\n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n         param_env,\n@@ -364,7 +364,7 @@ fn do_mir_borrowck<'tcx>(\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n         borrow_set: Rc::clone(&borrow_set),\n-        dominators,\n+        dominators: Default::default(),\n         upvars,\n         local_names,\n         region_names: RefCell::default(),\n@@ -534,7 +534,7 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n     borrow_set: Rc<BorrowSet<'tcx>>,\n \n     /// Dominators for MIR\n-    dominators: Dominators<BasicBlock>,\n+    dominators: OnceCell<Dominators<BasicBlock>>,\n \n     /// Information about upvars not necessarily preserved in types or MIR\n     upvars: Vec<Upvar<'tcx>>,\n@@ -1051,7 +1051,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 (Read(kind), BorrowKind::Unique | BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if !is_active(&this.dominators, borrow, location) {\n+                    if !is_active(this.dominators(), borrow, location) {\n                         assert!(allow_two_phase_borrow(borrow.kind));\n                         return Control::Continue;\n                     }\n@@ -2219,6 +2219,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn is_upvar_field_projection(&self, place_ref: PlaceRef<'tcx>) -> Option<Field> {\n         path_utils::is_upvar_field_projection(self.infcx.tcx, &self.upvars, place_ref, self.body())\n     }\n+\n+    fn dominators(&self) -> &Dominators<BasicBlock> {\n+        self.dominators.get_or_init(|| self.body.basic_blocks.dominators())\n+    }\n }\n \n mod error {"}, {"sha": "238172ea3992f5a08b2cac2f0f00b1659d67ae02", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -527,6 +527,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_values.region_value_str(scc)\n     }\n \n+    pub(crate) fn placeholders_contained_in<'a>(\n+        &'a self,\n+        r: RegionVid,\n+    ) -> impl Iterator<Item = ty::PlaceholderRegion> + 'a {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        self.scc_values.placeholders_contained_in(scc)\n+    }\n+\n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());"}, {"sha": "db5a67a8b442d97e13678b8262a7f2cdc197580d", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -12,6 +12,8 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::ObligationCtxt;\n \n+use crate::session_diagnostics::NonGenericOpaqueTypeParam;\n+\n use super::RegionInferenceContext;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -250,7 +252,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         }\n \n         let definition_ty = instantiated_ty\n-            .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false, origin)\n+            .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false)\n             .ty;\n \n         if !check_opaque_type_parameter_valid(\n@@ -389,17 +391,13 @@ fn check_opaque_type_parameter_valid(\n         } else {\n             // Prevent `fn foo() -> Foo<u32>` from being defining.\n             let opaque_param = opaque_generics.param_at(i, tcx);\n-            tcx.sess\n-                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                .span_note(\n-                    tcx.def_span(opaque_param.def_id),\n-                    &format!(\n-                        \"used non-generic {} `{}` for generic parameter\",\n-                        opaque_param.kind.descr(),\n-                        arg,\n-                    ),\n-                )\n-                .emit();\n+            let kind = opaque_param.kind.descr();\n+            tcx.sess.emit_err(NonGenericOpaqueTypeParam {\n+                ty: arg,\n+                kind,\n+                span,\n+                param_span: tcx.def_span(opaque_param.def_id),\n+            });\n             return false;\n         }\n     }"}, {"sha": "23acf159240fa7bf509b44ee9683a6bac6acd87c", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,6 +1,6 @@\n use rustc_errors::{IntoDiagnosticArg, MultiSpan};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{GenericArg, Ty};\n use rustc_span::Span;\n \n use crate::diagnostics::RegionName;\n@@ -240,3 +240,14 @@ pub(crate) struct MoveBorrow<'a> {\n     #[label]\n     pub borrow_span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(borrowck_opaque_type_non_generic_param, code = \"E0792\")]\n+pub(crate) struct NonGenericOpaqueTypeParam<'a, 'tcx> {\n+    pub ty: GenericArg<'tcx>,\n+    pub kind: &'a str,\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub param_span: Span,\n+}"}, {"sha": "11729e2c83f0b9d098788e495a6db5ea5b271ce5", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -107,11 +107,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         instantiated_predicates: ty::InstantiatedPredicates<'tcx>,\n         locations: Locations,\n     ) {\n-        for (predicate, span) in instantiated_predicates\n-            .predicates\n-            .into_iter()\n-            .zip(instantiated_predicates.spans.into_iter())\n-        {\n+        for (predicate, span) in instantiated_predicates {\n             debug!(?predicate);\n             let category = ConstraintCategory::Predicate(span);\n             let predicate = self.normalize_with_category(predicate, locations, category);"}, {"sha": "82ff862479e81824e1f47c6606e6b54cca6e6c86", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -359,14 +359,9 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                         .insert(ty::OutlivesPredicate(GenericKind::Param(param_b), r_a));\n                 }\n \n-                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n+                OutlivesBound::RegionSubAlias(r_a, alias_b) => {\n                     self.region_bound_pairs\n-                        .insert(ty::OutlivesPredicate(GenericKind::Projection(projection_b), r_a));\n-                }\n-\n-                OutlivesBound::RegionSubOpaque(r_a, def_id, substs) => {\n-                    self.region_bound_pairs\n-                        .insert(ty::OutlivesPredicate(GenericKind::Opaque(def_id, substs), r_a));\n+                        .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n             }\n         }"}, {"sha": "ef5a75f428d4e979c8582c5708c79a8c9854180e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -82,7 +82,7 @@ pub fn expand_deriving_clone(\n             nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: substructure,\n         }],\n         associated_types: Vec::new(),\n@@ -177,7 +177,9 @@ fn cs_clone(\n             all_fields = af;\n             vdata = &variant.data;\n         }\n-        EnumTag(..) => cx.span_bug(trait_span, &format!(\"enum tags in `derive({})`\", name,)),\n+        EnumTag(..) | AllFieldlessEnum(..) => {\n+            cx.span_bug(trait_span, &format!(\"enum tags in `derive({})`\", name,))\n+        }\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, &format!(\"associated function in `derive({})`\", name))\n         }"}, {"sha": "3e994f037ad7aa7e2843b0a271257b679bbab3e4", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -36,7 +36,7 @@ pub fn expand_deriving_eq(\n             nonself_args: vec![],\n             ret_ty: Unit,\n             attributes: attrs,\n-            unify_fieldless_variants: true,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 cs_total_eq_assert(a, b, c)\n             })),"}, {"sha": "a926fca4e65f8ac21fe7eabd06a1c260d5c0b474", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -29,7 +29,7 @@ pub fn expand_deriving_ord(\n             nonself_args: vec![(self_ref(), sym::other)],\n             ret_ty: Path(path_std!(cmp::Ordering)),\n             attributes: attrs,\n-            unify_fieldless_variants: true,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| cs_cmp(a, b, c))),\n         }],\n         associated_types: Vec::new(),"}, {"sha": "9051fe0b28abec750146a6435e0b50c021e99d6f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -76,7 +76,7 @@ pub fn expand_deriving_partial_eq(\n         nonself_args: vec![(self_ref(), sym::other)],\n         ret_ty: Path(path_local!(bool)),\n         attributes: attrs,\n-        unify_fieldless_variants: true,\n+        fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n         combine_substructure: combine_substructure(Box::new(|a, b, c| cs_eq(a, b, c))),\n     }];\n "}, {"sha": "c9dc89212622d70d7d6ddc2bdbfac0093a7bf263", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_partial_ord(\n         nonself_args: vec![(self_ref(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n-        unify_fieldless_variants: true,\n+        fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n         combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n             cs_partial_cmp(cx, span, substr)\n         })),"}, {"sha": "e0f487e864898d72d530efd0d1b1b0815d01894d", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -2,6 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n+use ast::EnumDef;\n use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -31,7 +32,8 @@ pub fn expand_deriving_debug(\n             nonself_args: vec![(fmtr, sym::f)],\n             ret_ty: Path(path_std!(fmt::Result)),\n             attributes: ast::AttrVec::new(),\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy:\n+                FieldlessVariantsStrategy::SpecializeIfAllVariantsFieldless,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 show_substructure(a, b, c)\n             })),\n@@ -43,16 +45,18 @@ pub fn expand_deriving_debug(\n }\n \n fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n+    // We want to make sure we have the ctxt set so that we can use unstable methods\n+    let span = cx.with_def_site_ctxt(span);\n+\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n         EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n+        AllFieldlessEnum(enum_def) => return show_fieldless_enum(cx, span, enum_def, substr),\n         EnumTag(..) | StaticStruct(..) | StaticEnum(..) => {\n             cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\")\n         }\n     };\n \n-    // We want to make sure we have the ctxt set so that we can use unstable methods\n-    let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_str(span, ident.name);\n     let fmt = substr.nonselflike_args[0].clone();\n \n@@ -173,3 +177,47 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         BlockOrExpr::new_mixed(stmts, Some(expr))\n     }\n }\n+\n+/// Special case for enums with no fields. Builds:\n+/// ```text\n+/// impl ::core::fmt::Debug for A {\n+///     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+///          ::core::fmt::Formatter::write_str(f,\n+///             match self {\n+///                 A::A => \"A\",\n+///                 A::B() => \"B\",\n+///                 A::C {} => \"C\",\n+///             })\n+///     }\n+/// }\n+/// ```\n+fn show_fieldless_enum(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    def: &EnumDef,\n+    substr: &Substructure<'_>,\n+) -> BlockOrExpr {\n+    let fmt = substr.nonselflike_args[0].clone();\n+    let arms = def\n+        .variants\n+        .iter()\n+        .map(|v| {\n+            let variant_path = cx.path(span, vec![substr.type_ident, v.ident]);\n+            let pat = match &v.data {\n+                ast::VariantData::Tuple(fields, _) => {\n+                    debug_assert!(fields.is_empty());\n+                    cx.pat_tuple_struct(span, variant_path, vec![])\n+                }\n+                ast::VariantData::Struct(fields, _) => {\n+                    debug_assert!(fields.is_empty());\n+                    cx.pat_struct(span, variant_path, vec![])\n+                }\n+                ast::VariantData::Unit(_) => cx.pat_path(span, variant_path),\n+            };\n+            cx.arm(span, pat, cx.expr_str(span, v.ident.name))\n+        })\n+        .collect::<Vec<_>>();\n+    let name = cx.expr_match(span, cx.expr_self(span), arms);\n+    let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n+    BlockOrExpr::new_expr(cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]))\n+}"}, {"sha": "5f9519dad1b25e91213e145a4ec768cc376f5d01", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -49,7 +49,7 @@ pub fn expand_deriving_rustc_decodable(\n                 PathKind::Std,\n             )),\n             attributes: ast::AttrVec::new(),\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 decodable_substructure(a, b, c, krate)\n             })),"}, {"sha": "18270747296b8f7c7d8762e141f7c8df88da5f36", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -34,7 +34,7 @@ pub fn expand_deriving_default(\n             nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|cx, trait_span, substr| {\n                 match substr.fields {\n                     StaticStruct(_, fields) => {"}, {"sha": "2afeed927ac2c7664d8e941f211f7c3f3bccff74", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -133,7 +133,7 @@ pub fn expand_deriving_rustc_encodable(\n                 PathKind::Std,\n             )),\n             attributes: AttrVec::new(),\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 encodable_substructure(a, b, c, krate)\n             })),"}, {"sha": "17b7ac0eba1209de55bddbee1ba6087945b409ed", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -222,14 +222,27 @@ pub struct MethodDef<'a> {\n \n     pub attributes: ast::AttrVec,\n \n-    /// Can we combine fieldless variants for enums into a single match arm?\n-    /// If true, indicates that the trait operation uses the enum tag in some\n-    /// way.\n-    pub unify_fieldless_variants: bool,\n+    pub fieldless_variants_strategy: FieldlessVariantsStrategy,\n \n     pub combine_substructure: RefCell<CombineSubstructureFunc<'a>>,\n }\n \n+/// How to handle fieldless enum variants.\n+#[derive(PartialEq)]\n+pub enum FieldlessVariantsStrategy {\n+    /// Combine fieldless variants into a single match arm.\n+    /// This assumes that relevant information has been handled\n+    /// by looking at the enum's discriminant.\n+    Unify,\n+    /// Don't do anything special about fieldless variants. They are\n+    /// handled like any other variant.\n+    Default,\n+    /// If all variants of the enum are fieldless, expand the special\n+    /// `AllFieldLessEnum` substructure, so that the entire enum can be handled\n+    /// at once.\n+    SpecializeIfAllVariantsFieldless,\n+}\n+\n /// All the data about the data structure/method being derived upon.\n pub struct Substructure<'a> {\n     /// ident of self\n@@ -264,9 +277,14 @@ pub enum StaticFields {\n \n /// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n-    /// A non-static method with `Self` is a struct.\n+    /// A non-static method where `Self` is a struct.\n     Struct(&'a ast::VariantData, Vec<FieldInfo>),\n \n+    /// A non-static method handling the entire enum at once\n+    /// (after it has been determined that none of the enum\n+    /// variants has any fields).\n+    AllFieldlessEnum(&'a ast::EnumDef),\n+\n     /// Matching variants of the enum: variant index, variant count, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n@@ -1086,8 +1104,8 @@ impl<'a> MethodDef<'a> {\n     /// ```\n     /// Creates a tag check combined with a match for a tuple of all\n     /// `selflike_args`, with an arm for each variant with fields, possibly an\n-    /// arm for each fieldless variant (if `!unify_fieldless_variants` is not\n-    /// true), and possibly a default arm.\n+    /// arm for each fieldless variant (if `unify_fieldless_variants` is not\n+    /// `Unify`), and possibly a default arm.\n     fn expand_enum_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1101,7 +1119,8 @@ impl<'a> MethodDef<'a> {\n         let variants = &enum_def.variants;\n \n         // Traits that unify fieldless variants always use the tag(s).\n-        let uses_tags = self.unify_fieldless_variants;\n+        let unify_fieldless_variants =\n+            self.fieldless_variants_strategy == FieldlessVariantsStrategy::Unify;\n \n         // There is no sensible code to be generated for *any* deriving on a\n         // zero-variant enum. So we just generate a failing expression.\n@@ -1161,23 +1180,35 @@ impl<'a> MethodDef<'a> {\n         // match is necessary.\n         let all_fieldless = variants.iter().all(|v| v.data.fields().is_empty());\n         if all_fieldless {\n-            if uses_tags && variants.len() > 1 {\n-                // If the type is fieldless and the trait uses the tag and\n-                // there are multiple variants, we need just an operation on\n-                // the tag(s).\n-                let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n-                let mut tag_check = self.call_substructure_method(\n-                    cx,\n-                    trait_,\n-                    type_ident,\n-                    nonselflike_args,\n-                    &EnumTag(tag_field, None),\n-                );\n-                tag_let_stmts.append(&mut tag_check.0);\n-                return BlockOrExpr(tag_let_stmts, tag_check.1);\n-            }\n-\n-            if variants.len() == 1 {\n+            if variants.len() > 1 {\n+                match self.fieldless_variants_strategy {\n+                    FieldlessVariantsStrategy::Unify => {\n+                        // If the type is fieldless and the trait uses the tag and\n+                        // there are multiple variants, we need just an operation on\n+                        // the tag(s).\n+                        let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n+                        let mut tag_check = self.call_substructure_method(\n+                            cx,\n+                            trait_,\n+                            type_ident,\n+                            nonselflike_args,\n+                            &EnumTag(tag_field, None),\n+                        );\n+                        tag_let_stmts.append(&mut tag_check.0);\n+                        return BlockOrExpr(tag_let_stmts, tag_check.1);\n+                    }\n+                    FieldlessVariantsStrategy::SpecializeIfAllVariantsFieldless => {\n+                        return self.call_substructure_method(\n+                            cx,\n+                            trait_,\n+                            type_ident,\n+                            nonselflike_args,\n+                            &AllFieldlessEnum(enum_def),\n+                        );\n+                    }\n+                    FieldlessVariantsStrategy::Default => (),\n+                }\n+            } else if variants.len() == 1 {\n                 // If there is a single variant, we don't need an operation on\n                 // the tag(s). Just use the most degenerate result.\n                 return self.call_substructure_method(\n@@ -1187,7 +1218,7 @@ impl<'a> MethodDef<'a> {\n                     nonselflike_args,\n                     &EnumMatching(0, 1, &variants[0], Vec::new()),\n                 );\n-            };\n+            }\n         }\n \n         // These arms are of the form:\n@@ -1198,7 +1229,7 @@ impl<'a> MethodDef<'a> {\n         let mut match_arms: Vec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n-            .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n+            .filter(|&(_, v)| !(unify_fieldless_variants && v.data.fields().is_empty()))\n             .map(|(index, variant)| {\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n@@ -1249,7 +1280,7 @@ impl<'a> MethodDef<'a> {\n         // Add a default arm to the match, if necessary.\n         let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n         let default = match first_fieldless {\n-            Some(v) if self.unify_fieldless_variants => {\n+            Some(v) if unify_fieldless_variants => {\n                 // We need a default case that handles all the fieldless\n                 // variants. The index and actual variant aren't meaningful in\n                 // this case, so just use dummy values.\n@@ -1296,7 +1327,7 @@ impl<'a> MethodDef<'a> {\n         // If the trait uses the tag and there are multiple variants, we need\n         // to add a tag check operation before the match. Otherwise, the match\n         // is enough.\n-        if uses_tags && variants.len() > 1 {\n+        if unify_fieldless_variants && variants.len() > 1 {\n             let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n \n             // Combine a tag check with the match.\n@@ -1580,5 +1611,6 @@ where\n             }\n         }\n         StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n+        AllFieldlessEnum(..) => cx.span_bug(trait_span, \"fieldless enum in `derive`\"),\n     }\n }"}, {"sha": "f8570d8f86a08dd691fe82dbd23c26518afcde24", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -33,7 +33,7 @@ pub fn expand_deriving_hash(\n             nonself_args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n             ret_ty: Unit,\n             attributes: AttrVec::new(),\n-            unify_fieldless_variants: true,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 hash_substructure(a, b, c)\n             })),"}, {"sha": "28fbcb15b2b5893ab9ea6912d5047a05a6f293a7", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -68,7 +68,7 @@ impl DebugContext {\n             .working_dir\n             .to_string_lossy(FileNameDisplayPreference::Remapped)\n             .into_owned();\n-        let (name, file_info) = match tcx.sess.local_crate_source_file.clone() {\n+        let (name, file_info) = match tcx.sess.local_crate_source_file() {\n             Some(path) => {\n                 let name = path.to_string_lossy().into_owned();\n                 (name, None)"}, {"sha": "5e98deae48aa2dae049de2e28fad05c4df7a256e", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             layout: TyAndLayout<'tcx>,\n             offset: Size,\n         ) {\n-            if !scalar.is_always_valid(bx) {\n+            if !scalar.is_uninit_valid() {\n                 bx.noundef_metadata(load);\n             }\n "}, {"sha": "22c61248b7d53275fa3e8a662c93ad7f7ae83775", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -8,7 +8,7 @@ use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefIdSet;\n+use rustc_hir::def_id::DefId;\n use rustc_llvm::RustString;\n use rustc_middle::bug;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n@@ -291,7 +291,7 @@ fn add_unused_functions(cx: &CodegenCx<'_, '_>) {\n \n     let ignore_unused_generics = tcx.sess.instrument_coverage_except_unused_generics();\n \n-    let eligible_def_ids: DefIdSet = tcx\n+    let eligible_def_ids: Vec<DefId> = tcx\n         .mir_keys(())\n         .iter()\n         .filter_map(|local_def_id| {\n@@ -317,7 +317,9 @@ fn add_unused_functions(cx: &CodegenCx<'_, '_>) {\n \n     let codegenned_def_ids = tcx.codegened_and_inlined_items(());\n \n-    for &non_codegenned_def_id in eligible_def_ids.difference(codegenned_def_ids) {\n+    for non_codegenned_def_id in\n+        eligible_def_ids.into_iter().filter(|id| !codegenned_def_ids.contains(id))\n+    {\n         let codegen_fn_attrs = tcx.codegen_fn_attrs(non_codegenned_def_id);\n \n         // If a function is marked `#[no_coverage]`, then skip generating a"}, {"sha": "b6eb5ee183fa397e6487e75983d27cbe393bcdfc", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -782,10 +782,10 @@ pub fn build_compile_unit_di_node<'ll, 'tcx>(\n     codegen_unit_name: &str,\n     debug_context: &CodegenUnitDebugContext<'ll, 'tcx>,\n ) -> &'ll DIDescriptor {\n-    let mut name_in_debuginfo = match tcx.sess.local_crate_source_file {\n-        Some(ref path) => path.clone(),\n-        None => PathBuf::from(tcx.crate_name(LOCAL_CRATE).as_str()),\n-    };\n+    let mut name_in_debuginfo = tcx\n+        .sess\n+        .local_crate_source_file()\n+        .unwrap_or_else(|| PathBuf::from(tcx.crate_name(LOCAL_CRATE).as_str()));\n \n     // To avoid breaking split DWARF, we need to ensure that each codegen unit\n     // has a unique `DW_AT_name`. This is because there's a remote chance that"}, {"sha": "57a99e74c21ade04464f985e4623fa635e1fdddf", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -173,11 +173,15 @@ fn exported_symbols_provider_local(\n         return &[];\n     }\n \n-    let mut symbols: Vec<_> = tcx\n-        .reachable_non_generics(LOCAL_CRATE)\n-        .iter()\n-        .map(|(&def_id, &info)| (ExportedSymbol::NonGeneric(def_id), info))\n-        .collect();\n+    // FIXME: Sorting this is unnecessary since we are sorting later anyway.\n+    //        Can we skip the later sorting?\n+    let mut symbols: Vec<_> = tcx.with_stable_hashing_context(|hcx| {\n+        tcx.reachable_non_generics(LOCAL_CRATE)\n+            .to_sorted(&hcx, true)\n+            .into_iter()\n+            .map(|(&def_id, &info)| (ExportedSymbol::NonGeneric(def_id), info))\n+            .collect()\n+    });\n \n     if tcx.entry_fn(()).is_some() {\n         let exported_symbol ="}, {"sha": "32d3cfe6fc650a2f76a19e9594bd7870ba5a8eeb", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -964,16 +964,19 @@ pub fn provide(providers: &mut Providers) {\n         };\n \n         let (defids, _) = tcx.collect_and_partition_mono_items(cratenum);\n-        for id in &*defids {\n+\n+        let any_for_speed = defids.items().any(|id| {\n             let CodegenFnAttrs { optimize, .. } = tcx.codegen_fn_attrs(*id);\n             match optimize {\n-                attr::OptimizeAttr::None => continue,\n-                attr::OptimizeAttr::Size => continue,\n-                attr::OptimizeAttr::Speed => {\n-                    return for_speed;\n-                }\n+                attr::OptimizeAttr::None | attr::OptimizeAttr::Size => false,\n+                attr::OptimizeAttr::Speed => true,\n             }\n+        });\n+\n+        if any_for_speed {\n+            return for_speed;\n         }\n+\n         tcx.sess.opts.optimize\n     };\n }"}, {"sha": "0579f7815352772807a19789d6928440256383b2", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -36,16 +36,16 @@ impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalErrKind {\n impl fmt::Display for ConstEvalErrKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::ConstEvalErrKind::*;\n-        match *self {\n+        match self {\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n             ModifiedGlobal => {\n                 write!(f, \"modifying a static's initial value from another static's initializer\")\n             }\n-            AssertFailure(ref msg) => write!(f, \"{:?}\", msg),\n+            AssertFailure(msg) => write!(f, \"{:?}\", msg),\n             Panic { msg, line, col, file } => {\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)\n             }\n-            Abort(ref msg) => write!(f, \"{}\", msg),\n+            Abort(msg) => write!(f, \"{}\", msg),\n         }\n     }\n }"}, {"sha": "4709514c82e85ab70a99727065a9c2008f26dcf0", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -225,7 +225,7 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n     /// `align_offset(ptr, target_align)` needs special handling in const eval, because the pointer\n     /// may not have an address.\n     ///\n-    /// If `ptr` does have a known address, then we return `CONTINUE` and the function call should\n+    /// If `ptr` does have a known address, then we return `Continue(())` and the function call should\n     /// proceed as normal.\n     ///\n     /// If `ptr` doesn't have an address, but its underlying allocation's alignment is at most\n@@ -273,18 +273,18 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n                         ret,\n                         StackPopUnwind::NotAllowed,\n                     )?;\n-                    Ok(ControlFlow::BREAK)\n+                    Ok(ControlFlow::Break(()))\n                 } else {\n                     // Not alignable in const, return `usize::MAX`.\n                     let usize_max = Scalar::from_machine_usize(self.machine_usize_max(), self);\n                     self.write_scalar(usize_max, dest)?;\n                     self.return_to_block(ret)?;\n-                    Ok(ControlFlow::BREAK)\n+                    Ok(ControlFlow::Break(()))\n                 }\n             }\n             Err(_addr) => {\n                 // The pointer has an address, continue with function call.\n-                Ok(ControlFlow::CONTINUE)\n+                Ok(ControlFlow::Continue(()))\n             }\n         }\n     }\n@@ -533,7 +533,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         let eval_to_int =\n             |op| ecx.read_immediate(&ecx.eval_operand(op, None)?).map(|x| x.to_const_int());\n         let err = match msg {\n-            BoundsCheck { ref len, ref index } => {\n+            BoundsCheck { len, index } => {\n                 let len = eval_to_int(len)?;\n                 let index = eval_to_int(index)?;\n                 BoundsCheck { len, index }"}, {"sha": "b2c847d3fd8dd6fca2403ecd5d9216ae4c5e63f4", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -347,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let new_vptr = self.get_vtable_ptr(ty, data_b.principal())?;\n                 self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n             }\n-            (_, &ty::Dynamic(ref data, _, ty::Dyn)) => {\n+            (_, &ty::Dynamic(data, _, ty::Dyn)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable_ptr(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_scalar(src)?;"}, {"sha": "cc7b6c91b607426e57cd6ff9b65b597eb8b4d54e", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -79,9 +79,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n         }\n         sym::variant_count => match tp_ty.kind() {\n             // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n-            ty::Adt(ref adt, _) => {\n-                ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx)\n-            }\n+            ty::Adt(adt, _) => ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx),\n             ty::Alias(..) | ty::Param(_) | ty::Placeholder(_) | ty::Infer(_) => {\n                 throw_inval!(TooGeneric)\n             }"}, {"sha": "291bfb2b55896dd73412d453533eab6223c56a6f", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -863,7 +863,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n \n             write!(fmt, \"{id:?}\")?;\n             match self.ecx.memory.alloc_map.get(id) {\n-                Some(&(kind, ref alloc)) => {\n+                Some((kind, alloc)) => {\n                     // normal alloc\n                     write!(fmt, \" ({}, \", kind)?;\n                     write_allocation_track_relocs("}, {"sha": "befc0928f3debd253efecb036e95d991b02be214", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -533,11 +533,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::Operand::*;\n-        let op = match *mir_op {\n+        let op = match mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n-            Copy(place) | Move(place) => self.eval_place_to_op(place, layout)?,\n+            &Copy(place) | &Move(place) => self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => {\n+            Constant(constant) => {\n                 let c =\n                     self.subst_from_current_frame_and_normalize_erasing_regions(constant.literal)?;\n "}, {"sha": "fad4cb06cd6fe4805f2f9dacfb3feac0bf075e22", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -111,7 +111,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 M::retag_place_contents(self, *kind, &dest)?;\n             }\n \n-            Intrinsic(box ref intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n+            Intrinsic(box intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n \n             // Statements we do not track.\n             AscribeUserType(..) => {}\n@@ -163,8 +163,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.copy_op(&op, &dest, /*allow_transmute*/ false)?;\n             }\n \n-            CopyForDeref(ref place) => {\n-                let op = self.eval_place_to_op(*place, Some(dest.layout))?;\n+            CopyForDeref(place) => {\n+                let op = self.eval_place_to_op(place, Some(dest.layout))?;\n                 self.copy_op(&op, &dest, /* allow_transmute*/ false)?;\n             }\n "}, {"sha": "cabc65e2c077e674d356938d939341dbb8bafb54", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -26,7 +26,7 @@ where\n \n         fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n             if !ty.needs_subst() {\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Continue(());\n             }\n \n             match *ty.kind() {\n@@ -48,7 +48,7 @@ where\n                             return subst.visit_with(self);\n                         }\n                     }\n-                    ControlFlow::CONTINUE\n+                    ControlFlow::Continue(())\n                 }\n                 _ => ty.super_visit_with(self),\n             }"}, {"sha": "19e359986a12e15762ad60cd06dc945a2f0eb046", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -419,7 +419,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             )\n         }\n         // Recursive checking\n-        if let Some(ref mut ref_tracking) = self.ref_tracking {\n+        if let Some(ref_tracking) = self.ref_tracking.as_deref_mut() {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n             if let Ok((alloc_id, _offset, _prov)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {"}, {"sha": "f9efc2418dbbcd0ed5ccb8919da86b8bec11a391", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -481,12 +481,12 @@ macro_rules! make_value_visitor {\n                 };\n \n                 // Visit the fields of this value.\n-                match v.layout().fields {\n+                match &v.layout().fields {\n                     FieldsShape::Primitive => {}\n-                    FieldsShape::Union(fields) => {\n+                    &FieldsShape::Union(fields) => {\n                         self.visit_union(v, fields)?;\n                     }\n-                    FieldsShape::Arbitrary { ref offsets, .. } => {\n+                    FieldsShape::Arbitrary { offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n                         // errors: Projecting to a field needs access to `ecx`.\n                         let fields: Vec<InterpResult<'tcx, Self::V>> ="}, {"sha": "57b91df2d0708f8f06e35438518c51b6f148df6c", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,7 +6,6 @@ Rust MIR: a lowered representation of Rust.\n \n #![feature(assert_matches)]\n #![feature(box_patterns)]\n-#![feature(control_flow_enum)]\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n #![feature(let_chains)]"}, {"sha": "79f1737e32b21fcabe767b8999d753b5210aaa30", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -442,7 +442,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n         self.super_rvalue(rvalue, location);\n \n-        match *rvalue {\n+        match rvalue {\n             Rvalue::ThreadLocalRef(_) => self.check_op(ops::ThreadLocalAccess),\n \n             Rvalue::Use(_)\n@@ -451,18 +451,15 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             | Rvalue::Discriminant(..)\n             | Rvalue::Len(_) => {}\n \n-            Rvalue::Aggregate(ref kind, ..) => {\n-                if let AggregateKind::Generator(def_id, ..) = kind.as_ref() {\n-                    if let Some(generator_kind) = self.tcx.generator_kind(def_id.to_def_id()) {\n-                        if matches!(generator_kind, hir::GeneratorKind::Async(..)) {\n-                            self.check_op(ops::Generator(generator_kind));\n-                        }\n-                    }\n+            Rvalue::Aggregate(kind, ..) => {\n+                if let AggregateKind::Generator(def_id, ..) = kind.as_ref()\n+                    && let Some(generator_kind @ hir::GeneratorKind::Async(..)) = self.tcx.generator_kind(def_id.to_def_id())\n+                {\n+                    self.check_op(ops::Generator(generator_kind));\n                 }\n             }\n \n-            Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n-            | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place) => {\n+            Rvalue::Ref(_, kind @ (BorrowKind::Mut { .. } | BorrowKind::Unique), place) => {\n                 let ty = place.ty(self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind() {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n@@ -491,12 +488,12 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 }\n             }\n \n-            Rvalue::AddressOf(Mutability::Mut, ref place) => {\n+            Rvalue::AddressOf(Mutability::Mut, place) => {\n                 self.check_mut_borrow(place.local, hir::BorrowKind::Raw)\n             }\n \n-            Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, ref place)\n-            | Rvalue::AddressOf(Mutability::Not, ref place) => {\n+            Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, place)\n+            | Rvalue::AddressOf(Mutability::Not, place) => {\n                 let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n                     &self.ccx,\n                     &mut |local| self.qualifs.has_mut_interior(self.ccx, local, location),\n@@ -564,7 +561,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => {}\n             Rvalue::ShallowInitBox(_, _) => {}\n \n-            Rvalue::UnaryOp(_, ref operand) => {\n+            Rvalue::UnaryOp(_, operand) => {\n                 let ty = operand.ty(self.body, self.tcx);\n                 if is_int_bool_or_char(ty) {\n                     // Int, bool, and char operations are fine.\n@@ -575,8 +572,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, box (ref lhs, ref rhs))\n-            | Rvalue::CheckedBinaryOp(op, box (ref lhs, ref rhs)) => {\n+            Rvalue::BinaryOp(op, box (lhs, rhs))\n+            | Rvalue::CheckedBinaryOp(op, box (lhs, rhs)) => {\n                 let lhs_ty = lhs.ty(self.body, self.tcx);\n                 let rhs_ty = rhs.ty(self.body, self.tcx);\n \n@@ -585,13 +582,16 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 } else if lhs_ty.is_fn_ptr() || lhs_ty.is_unsafe_ptr() {\n                     assert_eq!(lhs_ty, rhs_ty);\n                     assert!(\n-                        op == BinOp::Eq\n-                            || op == BinOp::Ne\n-                            || op == BinOp::Le\n-                            || op == BinOp::Lt\n-                            || op == BinOp::Ge\n-                            || op == BinOp::Gt\n-                            || op == BinOp::Offset\n+                        matches!(\n+                            op,\n+                            BinOp::Eq\n+                            | BinOp::Ne\n+                            | BinOp::Le\n+                            | BinOp::Lt\n+                            | BinOp::Ge\n+                            | BinOp::Gt\n+                            | BinOp::Offset\n+                        )\n                     );\n \n                     self.check_op(ops::RawPtrComparison);"}, {"sha": "fae6117f8f05224616eb95d0ed345b606b785890", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n                 }\n                 _ => { /* mark as unpromotable below */ }\n             }\n-        } else if let TempState::Defined { ref mut uses, .. } = *temp {\n+        } else if let TempState::Defined { uses, .. } = temp {\n             // We always allow borrows, even mutable ones, as we need\n             // to promote mutable borrows of some ZSTs e.g., `&mut []`.\n             let allowed_use = match context {\n@@ -748,7 +748,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         if loc.statement_index < num_stmts {\n             let (mut rvalue, source_info) = {\n                 let statement = &mut self.source[loc.block].statements[loc.statement_index];\n-                let StatementKind::Assign(box (_, ref mut rhs)) = statement.kind else {\n+                let StatementKind::Assign(box (_, rhs)) = &mut statement.kind else {\n                     span_bug!(\n                         statement.source_info.span,\n                         \"{:?} is not an assignment\",\n@@ -778,9 +778,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 self.source[loc.block].terminator().clone()\n             } else {\n                 let terminator = self.source[loc.block].terminator_mut();\n-                let target = match terminator.kind {\n-                    TerminatorKind::Call { target: Some(target), .. } => target,\n-                    ref kind => {\n+                let target = match &terminator.kind {\n+                    TerminatorKind::Call { target: Some(target), .. } => *target,\n+                    kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                     }\n                 };\n@@ -814,7 +814,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         ..terminator\n                     };\n                 }\n-                ref kind => {\n+                kind => {\n                     span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                 }\n             };\n@@ -847,54 +847,50 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let local_decls = &mut self.source.local_decls;\n             let loc = candidate.location;\n             let statement = &mut blocks[loc.block].statements[loc.statement_index];\n-            match statement.kind {\n-                StatementKind::Assign(box (\n-                    _,\n-                    Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n-                )) => {\n-                    // Use the underlying local for this (necessarily interior) borrow.\n-                    let ty = local_decls[place.local].ty;\n-                    let span = statement.source_info.span;\n-\n-                    let ref_ty = tcx.mk_ref(\n-                        tcx.lifetimes.re_erased,\n-                        ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n-                    );\n+            let StatementKind::Assign(box (_, Rvalue::Ref(region, borrow_kind, place))) = &mut statement.kind else {\n+                bug!()\n+            };\n \n-                    *region = tcx.lifetimes.re_erased;\n-\n-                    let mut projection = vec![PlaceElem::Deref];\n-                    projection.extend(place.projection);\n-                    place.projection = tcx.intern_place_elems(&projection);\n-\n-                    // Create a temp to hold the promoted reference.\n-                    // This is because `*r` requires `r` to be a local,\n-                    // otherwise we would use the `promoted` directly.\n-                    let mut promoted_ref = LocalDecl::new(ref_ty, span);\n-                    promoted_ref.source_info = statement.source_info;\n-                    let promoted_ref = local_decls.push(promoted_ref);\n-                    assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n-\n-                    let promoted_ref_statement = Statement {\n-                        source_info: statement.source_info,\n-                        kind: StatementKind::Assign(Box::new((\n-                            Place::from(promoted_ref),\n-                            Rvalue::Use(promoted_operand(ref_ty, span)),\n-                        ))),\n-                    };\n-                    self.extra_statements.push((loc, promoted_ref_statement));\n-\n-                    Rvalue::Ref(\n-                        tcx.lifetimes.re_erased,\n-                        borrow_kind,\n-                        Place {\n-                            local: mem::replace(&mut place.local, promoted_ref),\n-                            projection: List::empty(),\n-                        },\n-                    )\n-                }\n-                _ => bug!(),\n-            }\n+            // Use the underlying local for this (necessarily interior) borrow.\n+            let ty = local_decls[place.local].ty;\n+            let span = statement.source_info.span;\n+\n+            let ref_ty = tcx.mk_ref(\n+                tcx.lifetimes.re_erased,\n+                ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n+            );\n+\n+            *region = tcx.lifetimes.re_erased;\n+\n+            let mut projection = vec![PlaceElem::Deref];\n+            projection.extend(place.projection);\n+            place.projection = tcx.intern_place_elems(&projection);\n+\n+            // Create a temp to hold the promoted reference.\n+            // This is because `*r` requires `r` to be a local,\n+            // otherwise we would use the `promoted` directly.\n+            let mut promoted_ref = LocalDecl::new(ref_ty, span);\n+            promoted_ref.source_info = statement.source_info;\n+            let promoted_ref = local_decls.push(promoted_ref);\n+            assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n+\n+            let promoted_ref_statement = Statement {\n+                source_info: statement.source_info,\n+                kind: StatementKind::Assign(Box::new((\n+                    Place::from(promoted_ref),\n+                    Rvalue::Use(promoted_operand(ref_ty, span)),\n+                ))),\n+            };\n+            self.extra_statements.push((loc, promoted_ref_statement));\n+\n+            Rvalue::Ref(\n+                tcx.lifetimes.re_erased,\n+                *borrow_kind,\n+                Place {\n+                    local: mem::replace(&mut place.local, promoted_ref),\n+                    projection: List::empty(),\n+                },\n+            )\n         };\n \n         assert_eq!(self.new_block(), START_BLOCK);"}, {"sha": "dd168a9ac3cd3e94078cc20e24fb4c18c4b1b35c", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 96, "deletions": 8, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,7 +1,8 @@\n //! Validates the MIR to ensure that invariants are upheld.\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n use rustc_infer::traits::Reveal;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n@@ -18,7 +19,7 @@ use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n use rustc_target::abi::{Size, VariantIdx};\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum EdgeKind {\n     Unwind,\n     Normal,\n@@ -57,18 +58,20 @@ impl<'tcx> MirPass<'tcx> for Validator {\n             .iterate_to_fixpoint()\n             .into_results_cursor(body);\n \n-        TypeChecker {\n+        let mut checker = TypeChecker {\n             when: &self.when,\n             body,\n             tcx,\n             param_env,\n             mir_phase,\n+            unwind_edge_count: 0,\n             reachable_blocks: traversal::reachable_as_bitset(body),\n             storage_liveness,\n             place_cache: Vec::new(),\n             value_cache: Vec::new(),\n-        }\n-        .visit_body(body);\n+        };\n+        checker.visit_body(body);\n+        checker.check_cleanup_control_flow();\n     }\n }\n \n@@ -78,6 +81,7 @@ struct TypeChecker<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     mir_phase: MirPhase,\n+    unwind_edge_count: usize,\n     reachable_blocks: BitSet<BasicBlock>,\n     storage_liveness: ResultsCursor<'a, 'tcx, MaybeStorageLive<'static>>,\n     place_cache: Vec<PlaceRef<'tcx>>,\n@@ -102,7 +106,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n     }\n \n-    fn check_edge(&self, location: Location, bb: BasicBlock, edge_kind: EdgeKind) {\n+    fn check_edge(&mut self, location: Location, bb: BasicBlock, edge_kind: EdgeKind) {\n         if bb == START_BLOCK {\n             self.fail(location, \"start block must not have predecessors\")\n         }\n@@ -111,10 +115,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             match (src.is_cleanup, bb.is_cleanup, edge_kind) {\n                 // Non-cleanup blocks can jump to non-cleanup blocks along non-unwind edges\n                 (false, false, EdgeKind::Normal)\n-                // Non-cleanup blocks can jump to cleanup blocks along unwind edges\n-                | (false, true, EdgeKind::Unwind)\n                 // Cleanup blocks can jump to cleanup blocks along non-unwind edges\n                 | (true, true, EdgeKind::Normal) => {}\n+                // Non-cleanup blocks can jump to cleanup blocks along unwind edges\n+                (false, true, EdgeKind::Unwind) => {\n+                    self.unwind_edge_count += 1;\n+                }\n                 // All other jumps are invalid\n                 _ => {\n                     self.fail(\n@@ -134,6 +140,88 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    fn check_cleanup_control_flow(&self) {\n+        if self.unwind_edge_count <= 1 {\n+            return;\n+        }\n+        let doms = self.body.basic_blocks.dominators();\n+        let mut post_contract_node = FxHashMap::default();\n+        // Reusing the allocation across invocations of the closure\n+        let mut dom_path = vec![];\n+        let mut get_post_contract_node = |mut bb| {\n+            let root = loop {\n+                if let Some(root) = post_contract_node.get(&bb) {\n+                    break *root;\n+                }\n+                let parent = doms.immediate_dominator(bb);\n+                dom_path.push(bb);\n+                if !self.body.basic_blocks[parent].is_cleanup {\n+                    break bb;\n+                }\n+                bb = parent;\n+            };\n+            for bb in dom_path.drain(..) {\n+                post_contract_node.insert(bb, root);\n+            }\n+            root\n+        };\n+\n+        let mut parent = IndexVec::from_elem(None, &self.body.basic_blocks);\n+        for (bb, bb_data) in self.body.basic_blocks.iter_enumerated() {\n+            if !bb_data.is_cleanup || !self.reachable_blocks.contains(bb) {\n+                continue;\n+            }\n+            let bb = get_post_contract_node(bb);\n+            for s in bb_data.terminator().successors() {\n+                let s = get_post_contract_node(s);\n+                if s == bb {\n+                    continue;\n+                }\n+                let parent = &mut parent[bb];\n+                match parent {\n+                    None => {\n+                        *parent = Some(s);\n+                    }\n+                    Some(e) if *e == s => (),\n+                    Some(e) => self.fail(\n+                        Location { block: bb, statement_index: 0 },\n+                        format!(\n+                            \"Cleanup control flow violation: The blocks dominated by {:?} have edges to both {:?} and {:?}\",\n+                            bb,\n+                            s,\n+                            *e\n+                        )\n+                    ),\n+                }\n+            }\n+        }\n+\n+        // Check for cycles\n+        let mut stack = FxHashSet::default();\n+        for i in 0..parent.len() {\n+            let mut bb = BasicBlock::from_usize(i);\n+            stack.clear();\n+            stack.insert(bb);\n+            loop {\n+                let Some(parent)= parent[bb].take() else {\n+                    break\n+                };\n+                let no_cycle = stack.insert(parent);\n+                if !no_cycle {\n+                    self.fail(\n+                        Location { block: bb, statement_index: 0 },\n+                        format!(\n+                            \"Cleanup control flow violation: Cycle involving edge {:?} -> {:?}\",\n+                            bb, parent,\n+                        ),\n+                    );\n+                    break;\n+                }\n+                bb = parent;\n+            }\n+        }\n+    }\n+\n     /// Check if src can be assigned into dest.\n     /// This is not precise, it will accept some incorrect assignments.\n     fn mir_assign_valid_types(&self, src: Ty<'tcx>, dest: Ty<'tcx>) -> bool {"}, {"sha": "9fce0e1e65cc90f416fe8fa228a861796a51a5d9", "filename": "compiler/rustc_data_structures/src/fx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -11,8 +11,8 @@ pub type IndexEntry<'a, K, V> = indexmap::map::Entry<'a, K, V>;\n #[macro_export]\n macro_rules! define_id_collections {\n     ($map_name:ident, $set_name:ident, $entry_name:ident, $key:ty) => {\n-        pub type $map_name<T> = $crate::fx::FxHashMap<$key, T>;\n-        pub type $set_name = $crate::fx::FxHashSet<$key>;\n+        pub type $map_name<T> = $crate::unord::UnordMap<$key, T>;\n+        pub type $set_name = $crate::unord::UnordSet<$key>;\n         pub type $entry_name<'a, T> = $crate::fx::StdEntry<'a, $key, T>;\n     };\n }"}, {"sha": "471457f61b2d7d105d6fde503c42e29e909ad788", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -135,7 +135,10 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n         // This loop computes the semi[w] for w.\n         semi[w] = w;\n         for v in graph.predecessors(pre_order_to_real[w]) {\n-            let v = real_to_pre_order[v].unwrap();\n+            // Reachable vertices may have unreachable predecessors, so ignore any of them\n+            let Some(v) = real_to_pre_order[v] else {\n+                continue\n+            };\n \n             // eval returns a vertex x from which semi[x] is minimum among\n             // vertices semi[v] +> x *> v.\n@@ -268,10 +271,6 @@ pub struct Dominators<N: Idx> {\n }\n \n impl<Node: Idx> Dominators<Node> {\n-    pub fn dummy() -> Self {\n-        Self { post_order_rank: IndexVec::new(), immediate_dominators: IndexVec::new() }\n-    }\n-\n     pub fn is_reachable(&self, node: Node) -> bool {\n         self.immediate_dominators[node].is_some()\n     }\n@@ -296,7 +295,7 @@ impl<Node: Idx> Dominators<Node> {\n     /// of two unrelated nodes will also be consistent, but otherwise the order has no\n     /// meaning.) This method cannot be used to determine if either Node dominates the other.\n     pub fn rank_partial_cmp(&self, lhs: Node, rhs: Node) -> Option<Ordering> {\n-        self.post_order_rank[lhs].partial_cmp(&self.post_order_rank[rhs])\n+        self.post_order_rank[rhs].partial_cmp(&self.post_order_rank[lhs])\n     }\n }\n "}, {"sha": "dc1ce1747bfa0dc1d6def1306db79460d3e907f9", "filename": "compiler/rustc_data_structures/src/graph/implementation/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Ftests.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -70,8 +70,8 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(\n             \"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n             counter, expected_incoming[counter], edge_index, edge\n         );\n-        match expected_incoming[counter] {\n-            (ref e, ref n) => {\n+        match &expected_incoming[counter] {\n+            (e, n) => {\n                 assert!(e == &edge.data);\n                 assert!(n == graph.node_data(edge.source()));\n                 assert!(start_index == edge.target);\n@@ -88,8 +88,8 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(\n             \"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n             counter, expected_outgoing[counter], edge_index, edge\n         );\n-        match expected_outgoing[counter] {\n-            (ref e, ref n) => {\n+        match &expected_outgoing[counter] {\n+            (e, n) => {\n                 assert!(e == &edge.data);\n                 assert!(start_index == edge.source);\n                 assert!(n == graph.node_data(edge.target));"}, {"sha": "8a9af300c066ef2ba1cfed4e9ef73e8606c77f9a", "filename": "compiler/rustc_data_structures/src/graph/iterate/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -317,12 +317,12 @@ where\n         _node: G::Node,\n         _prior_status: Option<NodeStatus>,\n     ) -> ControlFlow<Self::BreakVal> {\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     /// Called after all nodes reachable from this one have been examined.\n     fn node_settled(&mut self, _node: G::Node) -> ControlFlow<Self::BreakVal> {\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     /// Behave as if no edges exist from `source` to `target`.\n@@ -346,8 +346,8 @@ where\n         prior_status: Option<NodeStatus>,\n     ) -> ControlFlow<Self::BreakVal> {\n         match prior_status {\n-            Some(NodeStatus::Visited) => ControlFlow::BREAK,\n-            _ => ControlFlow::CONTINUE,\n+            Some(NodeStatus::Visited) => ControlFlow::Break(()),\n+            _ => ControlFlow::Continue(()),\n         }\n     }\n }"}, {"sha": "954e84c303b83d031cc4b2be76c56b4e90e1cea1", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -11,7 +11,6 @@\n #![feature(associated_type_bounds)]\n #![feature(auto_traits)]\n #![feature(cell_leak)]\n-#![feature(control_flow_enum)]\n #![feature(extend_one)]\n #![feature(hash_raw_entry)]\n #![feature(hasher_prefixfree_extras)]"}, {"sha": "9409057d4847e419b8960e0a389d6341f7a6d192", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,6 +1,5 @@\n use crate::stable_hasher::{HashStable, StableHasher, StableOrd};\n use std::borrow::Borrow;\n-use std::cmp::Ordering;\n use std::fmt::Debug;\n use std::mem;\n use std::ops::{Bound, Index, IndexMut, RangeBounds};\n@@ -171,7 +170,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n     where\n         F: Fn(&mut K),\n     {\n-        self.data.iter_mut().map(|&mut (ref mut k, _)| k).for_each(f);\n+        self.data.iter_mut().map(|(k, _)| k).for_each(f);\n     }\n \n     /// Inserts a presorted range of elements into the map. If the range can be\n@@ -232,22 +231,22 @@ impl<K: Ord, V> SortedMap<K, V> {\n         R: RangeBounds<K>,\n     {\n         let start = match range.start_bound() {\n-            Bound::Included(ref k) => match self.lookup_index_for(k) {\n+            Bound::Included(k) => match self.lookup_index_for(k) {\n                 Ok(index) | Err(index) => index,\n             },\n-            Bound::Excluded(ref k) => match self.lookup_index_for(k) {\n+            Bound::Excluded(k) => match self.lookup_index_for(k) {\n                 Ok(index) => index + 1,\n                 Err(index) => index,\n             },\n             Bound::Unbounded => 0,\n         };\n \n         let end = match range.end_bound() {\n-            Bound::Included(ref k) => match self.lookup_index_for(k) {\n+            Bound::Included(k) => match self.lookup_index_for(k) {\n                 Ok(index) => index + 1,\n                 Err(index) => index,\n             },\n-            Bound::Excluded(ref k) => match self.lookup_index_for(k) {\n+            Bound::Excluded(k) => match self.lookup_index_for(k) {\n                 Ok(index) | Err(index) => index,\n             },\n             Bound::Unbounded => self.data.len(),\n@@ -302,7 +301,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for SortedMap<K, V> {\n         let mut data: Vec<(K, V)> = iter.into_iter().collect();\n \n         data.sort_unstable_by(|(k1, _), (k2, _)| k1.cmp(k2));\n-        data.dedup_by(|&mut (ref k1, _), &mut (ref k2, _)| k1.cmp(k2) == Ordering::Equal);\n+        data.dedup_by(|(k1, _), (k2, _)| k1 == k2);\n \n         SortedMap { data }\n     }"}, {"sha": "814e7c7fb9ba6751aa9dbe368319bd5525df3c17", "filename": "compiler/rustc_data_structures/src/sorted_map/index_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -63,13 +63,13 @@ impl<I: Idx, K: Ord, V> SortedIndexMultiMap<I, K, V> {\n     /// Returns an iterator over the items in the map in insertion order.\n     #[inline]\n     pub fn iter(&self) -> impl '_ + DoubleEndedIterator<Item = (&K, &V)> {\n-        self.items.iter().map(|(ref k, ref v)| (k, v))\n+        self.items.iter().map(|(k, v)| (k, v))\n     }\n \n     /// Returns an iterator over the items in the map in insertion order along with their indices.\n     #[inline]\n     pub fn iter_enumerated(&self) -> impl '_ + DoubleEndedIterator<Item = (I, (&K, &V))> {\n-        self.items.iter_enumerated().map(|(i, (ref k, ref v))| (i, (k, v)))\n+        self.items.iter_enumerated().map(|(i, (k, v))| (i, (k, v)))\n     }\n \n     /// Returns the item in the map with the given index."}, {"sha": "3cc250862df42bb39b28688d564a929d400a7cc7", "filename": "compiler/rustc_data_structures/src/sorted_map/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,7 +6,7 @@ fn test_sorted_index_multi_map() {\n     let set: SortedIndexMultiMap<usize, _, _> = entries.iter().copied().collect();\n \n     // Insertion order is preserved.\n-    assert!(entries.iter().map(|(ref k, ref v)| (k, v)).eq(set.iter()));\n+    assert!(entries.iter().map(|(k, v)| (k, v)).eq(set.iter()));\n \n     // Indexing\n     for (i, expect) in entries.iter().enumerate() {"}, {"sha": "11a408f216a1465ca4335fa7879a342a82ff61ae", "filename": "compiler/rustc_data_structures/src/tiny_list.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -37,9 +37,9 @@ impl<T: PartialEq> TinyList<T> {\n \n     #[inline]\n     pub fn remove(&mut self, data: &T) -> bool {\n-        self.head = match self.head {\n-            Some(ref mut head) if head.data == *data => head.next.take().map(|x| *x),\n-            Some(ref mut head) => return head.remove_next(data),\n+        self.head = match &mut self.head {\n+            Some(head) if head.data == *data => head.next.take().map(|x| *x),\n+            Some(head) => return head.remove_next(data),\n             None => return false,\n         };\n         true\n@@ -48,7 +48,7 @@ impl<T: PartialEq> TinyList<T> {\n     #[inline]\n     pub fn contains(&self, data: &T) -> bool {\n         let mut elem = self.head.as_ref();\n-        while let Some(ref e) = elem {\n+        while let Some(e) = elem {\n             if &e.data == data {\n                 return true;\n             }\n@@ -65,15 +65,14 @@ struct Element<T> {\n }\n \n impl<T: PartialEq> Element<T> {\n-    fn remove_next(&mut self, data: &T) -> bool {\n-        let mut n = self;\n+    fn remove_next(mut self: &mut Self, data: &T) -> bool {\n         loop {\n-            match n.next {\n+            match self.next {\n                 Some(ref mut next) if next.data == *data => {\n-                    n.next = next.next.take();\n+                    self.next = next.next.take();\n                     return true;\n                 }\n-                Some(ref mut next) => n = next,\n+                Some(ref mut next) => self = next,\n                 None => return false,\n             }\n         }"}, {"sha": "4b95e62bef02b1391af37c41a4e9823bec5b3983", "filename": "compiler/rustc_data_structures/src/tiny_list/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,7 +6,7 @@ use test::{black_box, Bencher};\n impl<T> TinyList<T> {\n     fn len(&self) -> usize {\n         let (mut elem, mut count) = (self.head.as_ref(), 0);\n-        while let Some(ref e) = elem {\n+        while let Some(e) = elem {\n             count += 1;\n             elem = e.next.as_deref();\n         }"}, {"sha": "f35f18e51cb4e5339dfd8a4b88b9c291ce773256", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "modified", "additions": 233, "deletions": 6, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,13 +6,15 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use smallvec::SmallVec;\n use std::{\n     borrow::Borrow,\n+    collections::hash_map::Entry,\n     hash::Hash,\n     iter::{Product, Sum},\n+    ops::Index,\n };\n \n use crate::{\n     fingerprint::Fingerprint,\n-    stable_hasher::{HashStable, StableHasher, ToStableHashKey},\n+    stable_hasher::{HashStable, StableHasher, StableOrd, ToStableHashKey},\n };\n \n /// `UnordItems` is the order-less version of `Iterator`. It only contains methods\n@@ -38,17 +40,17 @@ impl<T, I: Iterator<Item = T>> UnordItems<T, I> {\n     }\n \n     #[inline]\n-    pub fn all<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+    pub fn all<F: Fn(T) -> bool>(mut self, f: F) -> bool {\n         self.0.all(f)\n     }\n \n     #[inline]\n-    pub fn any<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+    pub fn any<F: Fn(T) -> bool>(mut self, f: F) -> bool {\n         self.0.any(f)\n     }\n \n     #[inline]\n-    pub fn filter<U, F: Fn(&T) -> bool>(self, f: F) -> UnordItems<T, impl Iterator<Item = T>> {\n+    pub fn filter<F: Fn(&T) -> bool>(self, f: F) -> UnordItems<T, impl Iterator<Item = T>> {\n         UnordItems(self.0.filter(f))\n     }\n \n@@ -96,6 +98,15 @@ impl<T, I: Iterator<Item = T>> UnordItems<T, I> {\n     pub fn count(self) -> usize {\n         self.0.count()\n     }\n+\n+    #[inline]\n+    pub fn flat_map<U, F, O>(self, f: F) -> UnordItems<O, impl Iterator<Item = O>>\n+    where\n+        U: IntoIterator<Item = O>,\n+        F: Fn(T) -> U,\n+    {\n+        UnordItems(self.0.flat_map(f))\n+    }\n }\n \n impl<'a, T: Clone + 'a, I: Iterator<Item = &'a T>> UnordItems<&'a T, I> {\n@@ -147,6 +158,7 @@ pub struct UnordSet<V: Eq + Hash> {\n }\n \n impl<V: Eq + Hash> Default for UnordSet<V> {\n+    #[inline]\n     fn default() -> Self {\n         Self { inner: FxHashSet::default() }\n     }\n@@ -178,7 +190,16 @@ impl<V: Eq + Hash> UnordSet<V> {\n     }\n \n     #[inline]\n-    pub fn items(&self) -> UnordItems<&V, impl Iterator<Item = &V>> {\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> bool\n+    where\n+        V: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.remove(k)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -187,20 +208,75 @@ impl<V: Eq + Hash> UnordSet<V> {\n         UnordItems(self.inner.into_iter())\n     }\n \n+    /// Returns the items of this set in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `V` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn to_sorted<HCX>(&self, hcx: &HCX, cache_sort_key: bool) -> Vec<&V>\n+    where\n+        V: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.iter(), cache_sort_key, |&x| x)\n+    }\n+\n+    /// Returns the items of this set in stable sort order (as defined by\n+    /// `StableOrd`). This method is much more efficient than\n+    /// `into_sorted` because it does not need to transform keys to their\n+    /// `ToStableHashKey` equivalent.\n+    #[inline]\n+    pub fn to_sorted_stable_ord(&self) -> Vec<V>\n+    where\n+        V: Ord + StableOrd + Copy,\n+    {\n+        let mut items: Vec<V> = self.inner.iter().copied().collect();\n+        items.sort_unstable();\n+        items\n+    }\n+\n+    /// Returns the items of this set in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `V` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn into_sorted<HCX>(self, hcx: &HCX, cache_sort_key: bool) -> Vec<V>\n+    where\n+        V: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.into_iter(), cache_sort_key, |x| x)\n+    }\n+\n     // We can safely extend this UnordSet from a set of unordered values because that\n     // won't expose the internal ordering anywhere.\n     #[inline]\n     pub fn extend<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n         self.inner.extend(items.0)\n     }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.inner.clear();\n+    }\n }\n \n impl<V: Hash + Eq> Extend<V> for UnordSet<V> {\n+    #[inline]\n     fn extend<T: IntoIterator<Item = V>>(&mut self, iter: T) {\n         self.inner.extend(iter)\n     }\n }\n \n+impl<V: Hash + Eq> FromIterator<V> for UnordSet<V> {\n+    #[inline]\n+    fn from_iter<T: IntoIterator<Item = V>>(iter: T) -> Self {\n+        UnordSet { inner: FxHashSet::from_iter(iter) }\n+    }\n+}\n+\n impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordSet<V> {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n@@ -223,17 +299,33 @@ pub struct UnordMap<K: Eq + Hash, V> {\n }\n \n impl<K: Eq + Hash, V> Default for UnordMap<K, V> {\n+    #[inline]\n     fn default() -> Self {\n         Self { inner: FxHashMap::default() }\n     }\n }\n \n impl<K: Hash + Eq, V> Extend<(K, V)> for UnordMap<K, V> {\n+    #[inline]\n     fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         self.inner.extend(iter)\n     }\n }\n \n+impl<K: Hash + Eq, V> FromIterator<(K, V)> for UnordMap<K, V> {\n+    #[inline]\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> Self {\n+        UnordMap { inner: FxHashMap::from_iter(iter) }\n+    }\n+}\n+\n+impl<K: Hash + Eq, V, I: Iterator<Item = (K, V)>> From<UnordItems<(K, V), I>> for UnordMap<K, V> {\n+    #[inline]\n+    fn from(items: UnordItems<(K, V), I>) -> Self {\n+        UnordMap { inner: FxHashMap::from_iter(items.0) }\n+    }\n+}\n+\n impl<K: Eq + Hash, V> UnordMap<K, V> {\n     #[inline]\n     pub fn len(&self) -> usize {\n@@ -255,7 +347,44 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n     }\n \n     #[inline]\n-    pub fn items(&self) -> UnordItems<(&K, &V), impl Iterator<Item = (&K, &V)>> {\n+    pub fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n+\n+    #[inline]\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n+        self.inner.entry(key)\n+    }\n+\n+    #[inline]\n+    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.get(k)\n+    }\n+\n+    #[inline]\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.get_mut(k)\n+    }\n+\n+    #[inline]\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.remove(k)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<(&'a K, &'a V), impl Iterator<Item = (&'a K, &'a V)>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -270,6 +399,77 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n     pub fn extend<I: Iterator<Item = (K, V)>>(&mut self, items: UnordItems<(K, V), I>) {\n         self.inner.extend(items.0)\n     }\n+\n+    /// Returns the entries of this map in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `K` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn to_sorted<HCX>(&self, hcx: &HCX, cache_sort_key: bool) -> Vec<(&K, &V)>\n+    where\n+        K: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.iter(), cache_sort_key, |&(k, _)| k)\n+    }\n+\n+    /// Returns the entries of this map in stable sort order (as defined by `StableOrd`).\n+    /// This method can be much more efficient than `into_sorted` because it does not need\n+    /// to transform keys to their `ToStableHashKey` equivalent.\n+    #[inline]\n+    pub fn to_sorted_stable_ord(&self) -> Vec<(K, &V)>\n+    where\n+        K: Ord + StableOrd + Copy,\n+    {\n+        let mut items: Vec<(K, &V)> = self.inner.iter().map(|(&k, v)| (k, v)).collect();\n+        items.sort_unstable_by_key(|&(k, _)| k);\n+        items\n+    }\n+\n+    /// Returns the entries of this map in stable sort order (as defined by `ToStableHashKey`).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `K` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn into_sorted<HCX>(self, hcx: &HCX, cache_sort_key: bool) -> Vec<(K, V)>\n+    where\n+        K: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.into_iter(), cache_sort_key, |(k, _)| k)\n+    }\n+\n+    /// Returns the values of this map in stable sort order (as defined by K's\n+    /// `ToStableHashKey` implementation).\n+    ///\n+    /// The `cache_sort_key` parameter controls if [slice::sort_by_cached_key] or\n+    /// [slice::sort_unstable_by_key] will be used for sorting the vec. Use\n+    /// `cache_sort_key` when the [ToStableHashKey::to_stable_hash_key] implementation\n+    /// for `K` is expensive (e.g. a `DefId -> DefPathHash` lookup).\n+    #[inline]\n+    pub fn values_sorted<HCX>(&self, hcx: &HCX, cache_sort_key: bool) -> impl Iterator<Item = &V>\n+    where\n+        K: ToStableHashKey<HCX>,\n+    {\n+        to_sorted_vec(hcx, self.inner.iter(), cache_sort_key, |&(k, _)| k)\n+            .into_iter()\n+            .map(|(_, v)| v)\n+    }\n+}\n+\n+impl<K, Q: ?Sized, V> Index<&Q> for UnordMap<K, V>\n+where\n+    K: Eq + Hash + Borrow<Q>,\n+    Q: Eq + Hash,\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, key: &Q) -> &V {\n+        &self.inner[key]\n+    }\n }\n \n impl<HCX, K: Hash + Eq + HashStable<HCX>, V: HashStable<HCX>> HashStable<HCX> for UnordMap<K, V> {\n@@ -334,13 +534,40 @@ impl<T> Extend<T> for UnordBag<T> {\n     }\n }\n \n+impl<T, I: Iterator<Item = T>> From<UnordItems<T, I>> for UnordBag<T> {\n+    fn from(value: UnordItems<T, I>) -> Self {\n+        UnordBag { inner: Vec::from_iter(value.0) }\n+    }\n+}\n+\n impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordBag<V> {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n     }\n }\n \n+#[inline]\n+fn to_sorted_vec<HCX, T, K, I>(\n+    hcx: &HCX,\n+    iter: I,\n+    cache_sort_key: bool,\n+    extract_key: fn(&T) -> &K,\n+) -> Vec<T>\n+where\n+    I: Iterator<Item = T>,\n+    K: ToStableHashKey<HCX>,\n+{\n+    let mut items: Vec<T> = iter.collect();\n+    if cache_sort_key {\n+        items.sort_by_cached_key(|x| extract_key(x).to_stable_hash_key(hcx));\n+    } else {\n+        items.sort_unstable_by_key(|x| extract_key(x).to_stable_hash_key(hcx));\n+    }\n+\n+    items\n+}\n+\n fn hash_iter_order_independent<\n     HCX,\n     T: HashStable<HCX>,"}, {"sha": "f50ad0137b88aacff80bed38c6e5caeccf54cc11", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 32, "deletions": 78, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -219,7 +219,6 @@ fn run_compiler(\n         crate_cfg: cfg,\n         crate_check_cfg: check_cfg,\n         input: Input::File(PathBuf::new()),\n-        input_path: None,\n         output_file: ofile,\n         output_dir: odir,\n         file_loader,\n@@ -237,9 +236,8 @@ fn run_compiler(\n \n     match make_input(config.opts.error_format, &matches.free) {\n         Err(reported) => return Err(reported),\n-        Ok(Some((input, input_file_path))) => {\n+        Ok(Some(input)) => {\n             config.input = input;\n-            config.input_path = input_file_path;\n \n             callbacks.config(&mut config);\n         }\n@@ -261,14 +259,8 @@ fn run_compiler(\n                         describe_lints(compiler.session(), &lint_store, registered_lints);\n                         return;\n                     }\n-                    let should_stop = print_crate_info(\n-                        &***compiler.codegen_backend(),\n-                        compiler.session(),\n-                        None,\n-                        compiler.output_dir(),\n-                        compiler.output_file(),\n-                        compiler.temps_dir(),\n-                    );\n+                    let should_stop =\n+                        print_crate_info(&***compiler.codegen_backend(), compiler.session(), false);\n \n                     if should_stop == Compilation::Stop {\n                         return;\n@@ -290,18 +282,9 @@ fn run_compiler(\n \n     interface::run_compiler(config, |compiler| {\n         let sess = compiler.session();\n-        let should_stop = print_crate_info(\n-            &***compiler.codegen_backend(),\n-            sess,\n-            Some(compiler.input()),\n-            compiler.output_dir(),\n-            compiler.output_file(),\n-            compiler.temps_dir(),\n-        )\n-        .and_then(|| {\n-            list_metadata(sess, &*compiler.codegen_backend().metadata_loader(), compiler.input())\n-        })\n-        .and_then(|| try_process_rlink(sess, compiler));\n+        let should_stop = print_crate_info(&***compiler.codegen_backend(), sess, true)\n+            .and_then(|| list_metadata(sess, &*compiler.codegen_backend().metadata_loader()))\n+            .and_then(|| try_process_rlink(sess, compiler));\n \n         if should_stop == Compilation::Stop {\n             return sess.compile_status();\n@@ -315,24 +298,12 @@ fn run_compiler(\n                 if ppm.needs_ast_map() {\n                     let expanded_crate = queries.expansion()?.borrow().0.clone();\n                     queries.global_ctxt()?.enter(|tcx| {\n-                        pretty::print_after_hir_lowering(\n-                            tcx,\n-                            compiler.input(),\n-                            &*expanded_crate,\n-                            *ppm,\n-                            compiler.output_file().as_deref(),\n-                        );\n+                        pretty::print_after_hir_lowering(tcx, &*expanded_crate, *ppm);\n                         Ok(())\n                     })?;\n                 } else {\n                     let krate = queries.parse()?.steal();\n-                    pretty::print_after_parsing(\n-                        sess,\n-                        compiler.input(),\n-                        &krate,\n-                        *ppm,\n-                        compiler.output_file().as_deref(),\n-                    );\n+                    pretty::print_after_parsing(sess, &krate, *ppm);\n                 }\n                 trace!(\"finished pretty-printing\");\n                 return early_exit();\n@@ -357,21 +328,17 @@ fn run_compiler(\n                 }\n             }\n \n-            queries.expansion()?;\n+            queries.global_ctxt()?;\n             if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }\n \n-            queries.prepare_outputs()?;\n-\n             if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n                 && sess.opts.output_types.len() == 1\n             {\n                 return early_exit();\n             }\n \n-            queries.global_ctxt()?;\n-\n             if sess.opts.unstable_opts.no_analysis {\n                 return early_exit();\n             }\n@@ -384,9 +351,9 @@ fn run_compiler(\n                         save::process_crate(\n                             tcx,\n                             crate_name,\n-                            compiler.input(),\n+                            &sess.io.input,\n                             None,\n-                            DumpHandler::new(compiler.output_dir().as_deref(), crate_name),\n+                            DumpHandler::new(sess.io.output_dir.as_deref(), crate_name),\n                         )\n                     });\n                 }\n@@ -439,7 +406,7 @@ fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>)\n fn make_input(\n     error_format: ErrorOutputType,\n     free_matches: &[String],\n-) -> Result<Option<(Input, Option<PathBuf>)>, ErrorGuaranteed> {\n+) -> Result<Option<Input>, ErrorGuaranteed> {\n     if free_matches.len() == 1 {\n         let ifile = &free_matches[0];\n         if ifile == \"-\" {\n@@ -461,12 +428,12 @@ fn make_input(\n                 let line = isize::from_str_radix(&line, 10)\n                     .expect(\"UNSTABLE_RUSTDOC_TEST_LINE needs to be an number\");\n                 let file_name = FileName::doc_test_source_code(PathBuf::from(path), line);\n-                Ok(Some((Input::Str { name: file_name, input: src }, None)))\n+                Ok(Some(Input::Str { name: file_name, input: src }))\n             } else {\n-                Ok(Some((Input::Str { name: FileName::anon_source_code(&src), input: src }, None)))\n+                Ok(Some(Input::Str { name: FileName::anon_source_code(&src), input: src }))\n             }\n         } else {\n-            Ok(Some((Input::File(PathBuf::from(ifile)), Some(PathBuf::from(ifile)))))\n+            Ok(Some(Input::File(PathBuf::from(ifile))))\n         }\n     } else {\n         Ok(None)\n@@ -560,7 +527,7 @@ fn show_content_with_pager(content: &str) {\n \n pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n     if sess.opts.unstable_opts.link_only {\n-        if let Input::File(file) = compiler.input() {\n+        if let Input::File(file) = &sess.io.input {\n             // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n             sess.init_crate_types(collect_crate_types(sess, &[]));\n             let outputs = compiler.build_output_filenames(sess, &[]);\n@@ -601,13 +568,9 @@ pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Comp\n     }\n }\n \n-pub fn list_metadata(\n-    sess: &Session,\n-    metadata_loader: &dyn MetadataLoader,\n-    input: &Input,\n-) -> Compilation {\n+pub fn list_metadata(sess: &Session, metadata_loader: &dyn MetadataLoader) -> Compilation {\n     if sess.opts.unstable_opts.ls {\n-        match *input {\n+        match sess.io.input {\n             Input::File(ref ifile) => {\n                 let path = &(*ifile);\n                 let mut v = Vec::new();\n@@ -627,10 +590,7 @@ pub fn list_metadata(\n fn print_crate_info(\n     codegen_backend: &dyn CodegenBackend,\n     sess: &Session,\n-    input: Option<&Input>,\n-    odir: &Option<PathBuf>,\n-    ofile: &Option<PathBuf>,\n-    temps_dir: &Option<PathBuf>,\n+    parse_attrs: bool,\n ) -> Compilation {\n     use rustc_session::config::PrintRequest::*;\n     // NativeStaticLibs and LinkArgs are special - printed during linking\n@@ -639,18 +599,17 @@ fn print_crate_info(\n         return Compilation::Continue;\n     }\n \n-    let attrs = match input {\n-        None => None,\n-        Some(input) => {\n-            let result = parse_crate_attrs(sess, input);\n-            match result {\n-                Ok(attrs) => Some(attrs),\n-                Err(mut parse_error) => {\n-                    parse_error.emit();\n-                    return Compilation::Stop;\n-                }\n+    let attrs = if parse_attrs {\n+        let result = parse_crate_attrs(sess);\n+        match result {\n+            Ok(attrs) => Some(attrs),\n+            Err(mut parse_error) => {\n+                parse_error.emit();\n+                return Compilation::Stop;\n             }\n         }\n+    } else {\n+        None\n     };\n     for req in &sess.opts.prints {\n         match *req {\n@@ -665,14 +624,9 @@ fn print_crate_info(\n                 println!(\"{}\", serde_json::to_string_pretty(&sess.target.to_json()).unwrap());\n             }\n             FileNames | CrateName => {\n-                let input = input.unwrap_or_else(|| {\n-                    early_error(ErrorOutputType::default(), \"no input file provided\")\n-                });\n                 let attrs = attrs.as_ref().unwrap();\n-                let t_outputs = rustc_interface::util::build_output_filenames(\n-                    input, odir, ofile, temps_dir, attrs, sess,\n-                );\n-                let id = rustc_session::output::find_crate_name(sess, attrs, input);\n+                let t_outputs = rustc_interface::util::build_output_filenames(attrs, sess);\n+                let id = rustc_session::output::find_crate_name(sess, attrs);\n                 if *req == PrintRequest::CrateName {\n                     println!(\"{id}\");\n                     continue;\n@@ -1108,8 +1062,8 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     Some(matches)\n }\n \n-fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::AttrVec> {\n-    match input {\n+fn parse_crate_attrs<'a>(sess: &'a Session) -> PResult<'a, ast::AttrVec> {\n+    match &sess.io.input {\n         Input::File(ifile) => rustc_parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess),\n         Input::Str { name, input } => rustc_parse::parse_crate_attrs_from_source_str(\n             name.clone(),"}, {"sha": "ae3ac8625b1862ca109c1a216329268abc6a6557", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -9,14 +9,13 @@ use rustc_hir_pretty as pprust_hir;\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::mir::{write_mir_graphviz, write_mir_pretty};\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::config::{Input, PpAstTreeMode, PpHirMode, PpMode, PpSourceMode};\n+use rustc_session::config::{PpAstTreeMode, PpHirMode, PpMode, PpSourceMode};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::FileName;\n \n use std::cell::Cell;\n use std::fmt::Write;\n-use std::path::Path;\n \n pub use self::PpMode::*;\n pub use self::PpSourceMode::*;\n@@ -345,8 +344,8 @@ impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {\n     }\n }\n \n-fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n-    let src_name = input.source_name();\n+fn get_source(sess: &Session) -> (String, FileName) {\n+    let src_name = sess.io.input.source_name();\n     let src = String::clone(\n         sess.source_map()\n             .get_source_file(&src_name)\n@@ -358,8 +357,8 @@ fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n     (src, src_name)\n }\n \n-fn write_or_print(out: &str, ofile: Option<&Path>, sess: &Session) {\n-    match ofile {\n+fn write_or_print(out: &str, sess: &Session) {\n+    match &sess.io.output_file {\n         None => print!(\"{out}\"),\n         Some(p) => {\n             if let Err(e) = std::fs::write(p, out) {\n@@ -372,14 +371,8 @@ fn write_or_print(out: &str, ofile: Option<&Path>, sess: &Session) {\n     }\n }\n \n-pub fn print_after_parsing(\n-    sess: &Session,\n-    input: &Input,\n-    krate: &ast::Crate,\n-    ppm: PpMode,\n-    ofile: Option<&Path>,\n-) {\n-    let (src, src_name) = get_source(input, sess);\n+pub fn print_after_parsing(sess: &Session, krate: &ast::Crate, ppm: PpMode) {\n+    let (src, src_name) = get_source(sess);\n \n     let out = match ppm {\n         Source(s) => {\n@@ -407,22 +400,16 @@ pub fn print_after_parsing(\n         _ => unreachable!(),\n     };\n \n-    write_or_print(&out, ofile, sess);\n+    write_or_print(&out, sess);\n }\n \n-pub fn print_after_hir_lowering<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    input: &Input,\n-    krate: &ast::Crate,\n-    ppm: PpMode,\n-    ofile: Option<&Path>,\n-) {\n+pub fn print_after_hir_lowering<'tcx>(tcx: TyCtxt<'tcx>, krate: &ast::Crate, ppm: PpMode) {\n     if ppm.needs_analysis() {\n-        abort_on_err(print_with_analysis(tcx, ppm, ofile), tcx.sess);\n+        abort_on_err(print_with_analysis(tcx, ppm), tcx.sess);\n         return;\n     }\n \n-    let (src, src_name) = get_source(input, tcx.sess);\n+    let (src, src_name) = get_source(tcx.sess);\n \n     let out = match ppm {\n         Source(s) => {\n@@ -474,18 +461,14 @@ pub fn print_after_hir_lowering<'tcx>(\n         _ => unreachable!(),\n     };\n \n-    write_or_print(&out, ofile, tcx.sess);\n+    write_or_print(&out, tcx.sess);\n }\n \n // In an ideal world, this would be a public function called by the driver after\n // analysis is performed. However, we want to call `phase_3_run_analysis_passes`\n // with a different callback than the standard driver, so that isn't easy.\n // Instead, we call that function ourselves.\n-fn print_with_analysis(\n-    tcx: TyCtxt<'_>,\n-    ppm: PpMode,\n-    ofile: Option<&Path>,\n-) -> Result<(), ErrorGuaranteed> {\n+fn print_with_analysis(tcx: TyCtxt<'_>, ppm: PpMode) -> Result<(), ErrorGuaranteed> {\n     tcx.analysis(())?;\n     let out = match ppm {\n         Mir => {\n@@ -518,7 +501,7 @@ fn print_with_analysis(\n         _ => unreachable!(),\n     };\n \n-    write_or_print(&out, ofile, tcx.sess);\n+    write_or_print(&out, tcx.sess);\n \n     Ok(())\n }"}, {"sha": "9d5f4ad752051a41b0f23435c36c16252e9c5ea0", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -508,6 +508,7 @@ E0787: include_str!(\"./error_codes/E0787.md\"),\n E0788: include_str!(\"./error_codes/E0788.md\"),\n E0790: include_str!(\"./error_codes/E0790.md\"),\n E0791: include_str!(\"./error_codes/E0791.md\"),\n+E0792: include_str!(\"./error_codes/E0792.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "1ae01106f2014c4362d29d3a4a306dde7f091bd0", "filename": "compiler/rustc_error_codes/src/error_codes/E0208.md", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1 +1,46 @@\n #### This error code is internal to the compiler and will not be emitted with normal Rust code.\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error code shows the variance of a type's generic parameters.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+// NOTE: this feature is perma-unstable and should *only* be used for\n+//       testing purposes.\n+#![feature(rustc_attrs)]\n+\n+#[rustc_variance]\n+struct Foo<'a, T> { // error: deliberate error to display type's variance\n+    t: &'a mut T,\n+}\n+```\n+\n+which produces the following error:\n+\n+```text\n+error: [-, o]\n+ --> <anon>:4:1\n+  |\n+4 | struct Foo<'a, T> {\n+  | ^^^^^^^^^^^^^^^^^\n+```\n+\n+*Note that while `#[rustc_variance]` still exists and is used within the*\n+*compiler, it no longer is marked as `E0208` and instead has no error code.*\n+\n+This error is deliberately triggered with the `#[rustc_variance]` attribute\n+(`#![feature(rustc_attrs)]` must be enabled) and helps to show you the variance\n+of the type's generic parameters. You can read more about variance and\n+subtyping in [this section of the Rustnomicon]. For a more in depth look at\n+variance (including a more complete list of common variances) see\n+[this section of the Reference]. For information on how variance is implemented\n+in the compiler, see [this section of `rustc-dev-guide`].\n+\n+This error can be easily fixed by removing the `#[rustc_variance]` attribute,\n+the compiler's suggestion to comment it out can be applied automatically with\n+`rustfix`.\n+\n+[this section of the Rustnomicon]: https://doc.rust-lang.org/nomicon/subtyping.html\n+[this section of the Reference]: https://doc.rust-lang.org/reference/subtyping.html#variance\n+[this section of `rustc-dev-guide`]: https://rustc-dev-guide.rust-lang.org/variance.html"}, {"sha": "bad2b5abfe4d76044ed4e3914af8dc867eee24c7", "filename": "compiler/rustc_error_codes/src/error_codes/E0792.md", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0792.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0792.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0792.md?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -0,0 +1,60 @@\n+A type alias impl trait can only have its hidden type assigned\n+when used fully generically (and within their defining scope).\n+This means\n+\n+```compile_fail,E0792\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo<T> = impl std::fmt::Debug;\n+\n+fn foo() -> Foo<u32> {\n+    5u32\n+}\n+```\n+\n+is not accepted. If it were accepted, one could create unsound situations like\n+\n+```compile_fail,E0792\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo<T> = impl Default;\n+\n+fn foo() -> Foo<u32> {\n+    5u32\n+}\n+\n+fn main() {\n+    let x = Foo::<&'static mut String>::default();\n+}\n+```\n+\n+\n+Instead you need to make the function generic:\n+\n+```\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo<T> = impl std::fmt::Debug;\n+\n+fn foo<U>() -> Foo<U> {\n+    5u32\n+}\n+```\n+\n+This means that no matter the generic parameter to `foo`,\n+the hidden type will always be `u32`.\n+If you want to link the generic parameter to the hidden type,\n+you can do that, too:\n+\n+\n+```\n+#![feature(type_alias_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+type Foo<T: Debug> = impl Debug;\n+\n+fn foo<U: Debug>() -> Foo<U> {\n+    Vec::<U>::new()\n+}\n+```"}, {"sha": "5f28839f136d6276fd3fb465dd749b8edb7d5ad2", "filename": "compiler/rustc_error_messages/locales/en-US/ast_passes.ftl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -88,4 +88,5 @@ ast_passes_ty_alias_without_body =\n ast_passes_fn_without_body =\n     free function without a body\n     .suggestion = provide a definition for the function\n-    .extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block\n+\n+ast_passes_extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block"}, {"sha": "9e4332c428386ff068dd0a2f49ba859cd3b758d4", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -120,3 +120,7 @@ borrowck_cannot_move_when_borrowed =\n         [value] value\n         *[other] {$value_place}\n     } occurs here\n+\n+borrowck_opaque_type_non_generic_param =\n+    expected generic {$kind} parameter, found `{$ty}`\n+    .label = this generic parameter must be used with a generic {$kind} parameter"}, {"sha": "164d6d26d230d656f0896e69cf8269b9d8845aaa", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -193,7 +193,7 @@ infer_actual_impl_expl_expected_signature_any = {$leading_ellipsis ->\n infer_actual_impl_expl_expected_signature_some = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{lifetime_1}`...\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n infer_actual_impl_expl_expected_signature_nothing = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n@@ -209,7 +209,7 @@ infer_actual_impl_expl_expected_passive_any = {$leading_ellipsis ->\n infer_actual_impl_expl_expected_passive_some = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for some specific lifetime `'{lifetime_1}`...\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for some specific lifetime `'{$lifetime_1}`...\n infer_actual_impl_expl_expected_passive_nothing = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n@@ -225,7 +225,7 @@ infer_actual_impl_expl_expected_other_any = {$leading_ellipsis ->\n infer_actual_impl_expl_expected_other_some = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{lifetime_1}`...\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n infer_actual_impl_expl_expected_other_nothing = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n@@ -268,28 +268,28 @@ infer_but_calling_introduces = {$has_param_name ->\n     [true] `{$param_name}`\n     *[false] `fn` parameter\n } has {$lifetime_kind ->\n-    [named] lifetime `{lifetime}`\n-    *[anon] an anonymous lifetime `'_`\n-} but calling `{assoc_item}` introduces an implicit `'static` lifetime requirement\n+    [true] lifetime `{$lifetime}`\n+    *[false] an anonymous lifetime `'_`\n+} but calling `{$assoc_item}` introduces an implicit `'static` lifetime requirement\n     .label1 = {$has_lifetime ->\n-        [named] lifetime `{lifetime}`\n-        *[anon] an anonymous lifetime `'_`\n+        [true] lifetime `{$lifetime}`\n+        *[false] an anonymous lifetime `'_`\n     }\n     .label2 = ...is used and required to live as long as `'static` here because of an implicit lifetime bound on the {$has_impl_path ->\n-        [named] `impl` of `{$impl_path}`\n-        *[anon] inherent `impl`\n+        [true] `impl` of `{$impl_path}`\n+        *[false] inherent `impl`\n     }\n \n infer_but_needs_to_satisfy = {$has_param_name ->\n     [true] `{$param_name}`\n     *[false] `fn` parameter\n } has {$has_lifetime ->\n-    [named] lifetime `{lifetime}`\n-    *[anon] an anonymous lifetime `'_`\n+    [true] lifetime `{$lifetime}`\n+    *[false] an anonymous lifetime `'_`\n } but it needs to satisfy a `'static` lifetime requirement\n     .influencer = this data with {$has_lifetime ->\n-        [named] lifetime `{lifetime}`\n-        *[anon] an anonymous lifetime `'_`\n+        [true] lifetime `{$lifetime}`\n+        *[false] an anonymous lifetime `'_`\n     }...\n     .require = {$spans_empty ->\n         *[true] ...is used and required to live as long as `'static` here\n@@ -302,8 +302,8 @@ infer_more_targeted = {$has_param_name ->\n     [true] `{$param_name}`\n     *[false] `fn` parameter\n } has {$has_lifetime ->\n-    [named] lifetime `{lifetime}`\n-    *[anon] an anonymous lifetime `'_`\n+    [true] lifetime `{$lifetime}`\n+    *[false] an anonymous lifetime `'_`\n } but calling `{$ident}` introduces an implicit `'static` lifetime requirement\n \n infer_ril_introduced_here = `'static` requirement introduced here"}, {"sha": "224855fff8b56f35a7e02214a87749dd8cc89890", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -364,3 +364,5 @@ mir_build_suggest_let_else = you might want to use `let else` to handle the {$co\n         [one] variant that isn't\n         *[other] variants that aren't\n     } matched\n+\n+mir_build_suggest_attempted_int_lit = alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits"}, {"sha": "abe65a0e3fef06415599478dad5d702316a7a6df", "filename": "compiler/rustc_error_messages/locales/en-US/ty_utils.ftl", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fty_utils.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fty_utils.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fty_utils.ftl?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -10,17 +10,17 @@ ty_utils_address_and_deref_not_supported = dereferencing or taking the address i\n \n ty_utils_array_not_supported = array construction is not supported in generic constants\n \n-ty_utils_block_not_supported = blocks are not supported in generic constant\n+ty_utils_block_not_supported = blocks are not supported in generic constants\n \n-ty_utils_never_to_any_not_supported = converting nevers to any is not supported in generic constant\n+ty_utils_never_to_any_not_supported = converting nevers to any is not supported in generic constants\n \n ty_utils_tuple_not_supported = tuple construction is not supported in generic constants\n \n-ty_utils_index_not_supported = indexing is not supported in generic constant\n+ty_utils_index_not_supported = indexing is not supported in generic constants\n \n-ty_utils_field_not_supported = field access is not supported in generic constant\n+ty_utils_field_not_supported = field access is not supported in generic constants\n \n-ty_utils_const_block_not_supported = const blocks are not supported in generic constant\n+ty_utils_const_block_not_supported = const blocks are not supported in generic constants\n \n ty_utils_adt_not_supported = struct/enum construction is not supported in generic constants\n \n@@ -44,4 +44,4 @@ ty_utils_control_flow_not_supported = control flow is not supported in generic c\n \n ty_utils_inline_asm_not_supported = assembly is not supported in generic constants\n \n-ty_utils_operation_not_supported = unsupported operation in generic constant\n+ty_utils_operation_not_supported = unsupported operation in generic constants"}, {"sha": "951d59246785d08bff71641690fe154308428a34", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -63,21 +63,21 @@ pub enum Annotatable {\n \n impl Annotatable {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            Annotatable::Item(ref item) => item.span,\n-            Annotatable::TraitItem(ref trait_item) => trait_item.span,\n-            Annotatable::ImplItem(ref impl_item) => impl_item.span,\n-            Annotatable::ForeignItem(ref foreign_item) => foreign_item.span,\n-            Annotatable::Stmt(ref stmt) => stmt.span,\n-            Annotatable::Expr(ref expr) => expr.span,\n-            Annotatable::Arm(ref arm) => arm.span,\n-            Annotatable::ExprField(ref field) => field.span,\n-            Annotatable::PatField(ref fp) => fp.pat.span,\n-            Annotatable::GenericParam(ref gp) => gp.ident.span,\n-            Annotatable::Param(ref p) => p.span,\n-            Annotatable::FieldDef(ref sf) => sf.span,\n-            Annotatable::Variant(ref v) => v.span,\n-            Annotatable::Crate(ref c) => c.spans.inner_span,\n+        match self {\n+            Annotatable::Item(item) => item.span,\n+            Annotatable::TraitItem(trait_item) => trait_item.span,\n+            Annotatable::ImplItem(impl_item) => impl_item.span,\n+            Annotatable::ForeignItem(foreign_item) => foreign_item.span,\n+            Annotatable::Stmt(stmt) => stmt.span,\n+            Annotatable::Expr(expr) => expr.span,\n+            Annotatable::Arm(arm) => arm.span,\n+            Annotatable::ExprField(field) => field.span,\n+            Annotatable::PatField(fp) => fp.pat.span,\n+            Annotatable::GenericParam(gp) => gp.ident.span,\n+            Annotatable::Param(p) => p.span,\n+            Annotatable::FieldDef(sf) => sf.span,\n+            Annotatable::Variant(v) => v.span,\n+            Annotatable::Crate(c) => c.spans.inner_span,\n         }\n     }\n "}, {"sha": "1fcbdfd9be5ce14353b7f1c572e2af7d6333f42b", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -298,7 +298,7 @@ impl<'a> StripUnconfigured<'a> {\n                     Some(AttrTokenTree::Delimited(sp, delim, inner))\n                         .into_iter()\n                 }\n-                AttrTokenTree::Token(ref token, _) if let TokenKind::Interpolated(ref nt) = token.kind => {\n+                AttrTokenTree::Token(ref token, _) if let TokenKind::Interpolated(nt) = &token.kind => {\n                     panic!(\n                         \"Nonterminal should have been flattened at {:?}: {:?}\",\n                         token.span, nt"}, {"sha": "79d058d9c97360d0aec61b0128d8ad140e14593d", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -144,12 +144,12 @@ macro_rules! ast_fragments {\n             }\n \n             pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n-                match *self {\n-                    AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n+                match self {\n+                    AstFragment::OptExpr(Some(expr)) => visitor.visit_expr(expr),\n                     AstFragment::OptExpr(None) => {}\n-                    AstFragment::MethodReceiverExpr(ref expr) => visitor.visit_method_receiver_expr(expr),\n-                    $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n-                    $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n+                    AstFragment::MethodReceiverExpr(expr) => visitor.visit_method_receiver_expr(expr),\n+                    $($(AstFragment::$Kind(ast) => visitor.$visit_ast(ast),)?)*\n+                    $($(AstFragment::$Kind(ast) => for ast_elt in &ast[..] {\n                         visitor.$visit_ast_elt(ast_elt, $($args)*);\n                     })?)*\n                 }\n@@ -592,7 +592,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let expn_id = invoc.expansion_data.id;\n                     let parent_def = self.cx.resolver.invocation_parent(expn_id);\n                     let span = match &mut invoc.kind {\n-                        InvocationKind::Bang { ref mut span, .. } => span,\n+                        InvocationKind::Bang { span, .. } => span,\n                         InvocationKind::Attr { attr, .. } => &mut attr.span,\n                         InvocationKind::Derive { path, .. } => &mut path.span,\n                     };\n@@ -945,8 +945,8 @@ pub fn ensure_complete_parse<'a>(\n         let def_site_span = parser.token.span.with_ctxt(SyntaxContext::root());\n \n         let semi_span = parser.sess.source_map().next_point(span);\n-        let add_semicolon = match parser.sess.source_map().span_to_snippet(semi_span) {\n-            Ok(ref snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n+        let add_semicolon = match &parser.sess.source_map().span_to_snippet(semi_span) {\n+            Ok(snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n                 Some(span.shrink_to_hi())\n             }\n             _ => None,"}, {"sha": "5be134f4e664c80c189cefab7d41baa380b41045", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -151,9 +151,9 @@ impl<'a, T> Iterator for &'a Stack<'a, T> {\n \n     // Iterates from top to bottom of the stack.\n     fn next(&mut self) -> Option<&'a T> {\n-        match *self {\n+        match self {\n             Stack::Empty => None,\n-            Stack::Push { ref top, ref prev } => {\n+            Stack::Push { top, prev } => {\n                 *self = prev;\n                 Some(top)\n             }\n@@ -437,8 +437,8 @@ fn check_nested_occurrences(\n                 // We check that the meta-variable is correctly used.\n                 check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n             }\n-            (NestedMacroState::MacroRulesNotName, &TokenTree::Delimited(_, ref del))\n-            | (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n+            (NestedMacroState::MacroRulesNotName, TokenTree::Delimited(_, del))\n+            | (NestedMacroState::MacroName, TokenTree::Delimited(_, del))\n                 if del.delim == Delimiter::Brace =>\n             {\n                 let macro_rules = state == NestedMacroState::MacroRulesNotName;\n@@ -497,7 +497,7 @@ fn check_nested_occurrences(\n                     valid,\n                 );\n             }\n-            (_, ref tt) => {\n+            (_, tt) => {\n                 state = NestedMacroState::Empty;\n                 check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n             }"}, {"sha": "4ebd75f0185604b0038a3ea8d8c70ac489344af7", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -486,11 +486,11 @@ pub fn compile_declarative_macro(\n     let mut valid = true;\n \n     // Extract the arguments:\n-    let lhses = match argument_map[&MacroRulesNormalizedIdent::new(lhs_nm)] {\n-        MatchedSeq(ref s) => s\n+    let lhses = match &argument_map[&MacroRulesNormalizedIdent::new(lhs_nm)] {\n+        MatchedSeq(s) => s\n             .iter()\n             .map(|m| {\n-                if let MatchedTokenTree(ref tt) = *m {\n+                if let MatchedTokenTree(tt) = m {\n                     let tt = mbe::quoted::parse(\n                         TokenStream::new(vec![tt.clone()]),\n                         true,\n@@ -510,11 +510,11 @@ pub fn compile_declarative_macro(\n         _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n-    let rhses = match argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n-        MatchedSeq(ref s) => s\n+    let rhses = match &argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n+        MatchedSeq(s) => s\n             .iter()\n             .map(|m| {\n-                if let MatchedTokenTree(ref tt) = *m {\n+                if let MatchedTokenTree(tt) = m {\n                     return mbe::quoted::parse(\n                         TokenStream::new(vec![tt.clone()]),\n                         false,\n@@ -624,21 +624,21 @@ fn check_lhs_nt_follows(sess: &ParseSess, def: &ast::Item, lhs: &mbe::TokenTree)\n fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n     use mbe::TokenTree;\n     for tt in tts {\n-        match *tt {\n+        match tt {\n             TokenTree::Token(..)\n             | TokenTree::MetaVar(..)\n             | TokenTree::MetaVarDecl(..)\n             | TokenTree::MetaVarExpr(..) => (),\n-            TokenTree::Delimited(_, ref del) => {\n+            TokenTree::Delimited(_, del) => {\n                 if !check_lhs_no_empty_seq(sess, &del.tts) {\n                     return false;\n                 }\n             }\n-            TokenTree::Sequence(span, ref seq) => {\n+            TokenTree::Sequence(span, seq) => {\n                 if seq.separator.is_none()\n-                    && seq.tts.iter().all(|seq_tt| match *seq_tt {\n+                    && seq.tts.iter().all(|seq_tt| match seq_tt {\n                         TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => true,\n-                        TokenTree::Sequence(_, ref sub_seq) => {\n+                        TokenTree::Sequence(_, sub_seq) => {\n                             sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n                                 || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n                         }\n@@ -736,21 +736,21 @@ impl<'tt> FirstSets<'tt> {\n         fn build_recur<'tt>(sets: &mut FirstSets<'tt>, tts: &'tt [TokenTree]) -> TokenSet<'tt> {\n             let mut first = TokenSet::empty();\n             for tt in tts.iter().rev() {\n-                match *tt {\n+                match tt {\n                     TokenTree::Token(..)\n                     | TokenTree::MetaVar(..)\n                     | TokenTree::MetaVarDecl(..)\n                     | TokenTree::MetaVarExpr(..) => {\n                         first.replace_with(TtHandle::TtRef(tt));\n                     }\n-                    TokenTree::Delimited(span, ref delimited) => {\n+                    TokenTree::Delimited(span, delimited) => {\n                         build_recur(sets, &delimited.tts);\n                         first.replace_with(TtHandle::from_token_kind(\n                             token::OpenDelim(delimited.delim),\n                             span.open,\n                         ));\n                     }\n-                    TokenTree::Sequence(sp, ref seq_rep) => {\n+                    TokenTree::Sequence(sp, seq_rep) => {\n                         let subfirst = build_recur(sets, &seq_rep.tts);\n \n                         match sets.first.entry(sp.entire()) {\n@@ -804,22 +804,22 @@ impl<'tt> FirstSets<'tt> {\n         let mut first = TokenSet::empty();\n         for tt in tts.iter() {\n             assert!(first.maybe_empty);\n-            match *tt {\n+            match tt {\n                 TokenTree::Token(..)\n                 | TokenTree::MetaVar(..)\n                 | TokenTree::MetaVarDecl(..)\n                 | TokenTree::MetaVarExpr(..) => {\n                     first.add_one(TtHandle::TtRef(tt));\n                     return first;\n                 }\n-                TokenTree::Delimited(span, ref delimited) => {\n+                TokenTree::Delimited(span, delimited) => {\n                     first.add_one(TtHandle::from_token_kind(\n                         token::OpenDelim(delimited.delim),\n                         span.open,\n                     ));\n                     return first;\n                 }\n-                TokenTree::Sequence(sp, ref seq_rep) => {\n+                TokenTree::Sequence(sp, seq_rep) => {\n                     let subfirst_owned;\n                     let subfirst = match self.first.get(&sp.entire()) {\n                         Some(Some(subfirst)) => subfirst,\n@@ -1041,7 +1041,7 @@ fn check_matcher_core<'tt>(\n \n         // First, update `last` so that it corresponds to the set\n         // of NT tokens that might end the sequence `... token`.\n-        match *token {\n+        match token {\n             TokenTree::Token(..)\n             | TokenTree::MetaVar(..)\n             | TokenTree::MetaVarDecl(..)\n@@ -1057,7 +1057,7 @@ fn check_matcher_core<'tt>(\n                     suffix_first = build_suffix_first();\n                 }\n             }\n-            TokenTree::Delimited(span, ref d) => {\n+            TokenTree::Delimited(span, d) => {\n                 let my_suffix = TokenSet::singleton(TtHandle::from_token_kind(\n                     token::CloseDelim(d.delim),\n                     span.close,\n@@ -1070,7 +1070,7 @@ fn check_matcher_core<'tt>(\n                 // against SUFFIX\n                 continue 'each_token;\n             }\n-            TokenTree::Sequence(_, ref seq_rep) => {\n+            TokenTree::Sequence(_, seq_rep) => {\n                 suffix_first = build_suffix_first();\n                 // The trick here: when we check the interior, we want\n                 // to include the separator (if any) as a potential\n@@ -1372,8 +1372,8 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n }\n \n fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n-    match *tt {\n-        mbe::TokenTree::Token(ref token) => pprust::token_to_string(&token).into(),\n+    match tt {\n+        mbe::TokenTree::Token(token) => pprust::token_to_string(&token).into(),\n         mbe::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n         mbe::TokenTree::MetaVarDecl(_, name, Some(kind)) => format!(\"${}:{}\", name, kind),\n         mbe::TokenTree::MetaVarDecl(_, name, None) => format!(\"${}:\", name),"}, {"sha": "b79835be73a7ec1dfd04438ea4257c8cc326bda7", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -47,8 +47,7 @@ impl<'a> Iterator for Frame<'a> {\n \n     fn next(&mut self) -> Option<&'a mbe::TokenTree> {\n         match self {\n-            Frame::Delimited { tts, ref mut idx, .. }\n-            | Frame::Sequence { tts, ref mut idx, .. } => {\n+            Frame::Delimited { tts, idx, .. } | Frame::Sequence { tts, idx, .. } => {\n                 let res = tts.get(*idx);\n                 *idx += 1;\n                 res\n@@ -220,13 +219,13 @@ pub(super) fn transcribe<'a>(\n                 let ident = MacroRulesNormalizedIdent::new(original_ident);\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n                     match cur_matched {\n-                        MatchedTokenTree(ref tt) => {\n+                        MatchedTokenTree(tt) => {\n                             // `tt`s are emitted into the output stream directly as \"raw tokens\",\n                             // without wrapping them into groups.\n                             let token = tt.clone();\n                             result.push(token);\n                         }\n-                        MatchedNonterminal(ref nt) => {\n+                        MatchedNonterminal(nt) => {\n                             // Other variables are emitted into the output stream as groups with\n                             // `Delimiter::Invisible` to maintain parsing priorities.\n                             // `Interpolated` is currently used for such groups in rustc parser.\n@@ -299,12 +298,11 @@ fn lookup_cur_matched<'a>(\n     interpolations: &'a FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> Option<&'a NamedMatch> {\n-    interpolations.get(&ident).map(|matched| {\n-        let mut matched = matched;\n+    interpolations.get(&ident).map(|mut matched| {\n         for &(idx, _) in repeats {\n             match matched {\n                 MatchedTokenTree(_) | MatchedNonterminal(_) => break,\n-                MatchedSeq(ref ads) => matched = ads.get(idx).unwrap(),\n+                MatchedSeq(ads) => matched = ads.get(idx).unwrap(),\n             }\n         }\n \n@@ -339,7 +337,7 @@ impl LockstepIterSize {\n         match self {\n             LockstepIterSize::Unconstrained => other,\n             LockstepIterSize::Contradiction(_) => self,\n-            LockstepIterSize::Constraint(l_len, ref l_id) => match other {\n+            LockstepIterSize::Constraint(l_len, l_id) => match other {\n                 LockstepIterSize::Unconstrained => self,\n                 LockstepIterSize::Contradiction(_) => other,\n                 LockstepIterSize::Constraint(r_len, _) if l_len == r_len => self,\n@@ -378,33 +376,33 @@ fn lockstep_iter_size(\n     repeats: &[(usize, usize)],\n ) -> LockstepIterSize {\n     use mbe::TokenTree;\n-    match *tree {\n-        TokenTree::Delimited(_, ref delimited) => {\n+    match tree {\n+        TokenTree::Delimited(_, delimited) => {\n             delimited.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }\n-        TokenTree::Sequence(_, ref seq) => {\n+        TokenTree::Sequence(_, seq) => {\n             seq.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }\n         TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {\n-            let name = MacroRulesNormalizedIdent::new(name);\n+            let name = MacroRulesNormalizedIdent::new(*name);\n             match lookup_cur_matched(name, interpolations, repeats) {\n                 Some(matched) => match matched {\n                     MatchedTokenTree(_) | MatchedNonterminal(_) => LockstepIterSize::Unconstrained,\n-                    MatchedSeq(ref ads) => LockstepIterSize::Constraint(ads.len(), name),\n+                    MatchedSeq(ads) => LockstepIterSize::Constraint(ads.len(), name),\n                 },\n                 _ => LockstepIterSize::Unconstrained,\n             }\n         }\n-        TokenTree::MetaVarExpr(_, ref expr) => {\n+        TokenTree::MetaVarExpr(_, expr) => {\n             let default_rslt = LockstepIterSize::Unconstrained;\n             let Some(ident) = expr.ident() else { return default_rslt; };\n             let name = MacroRulesNormalizedIdent::new(ident);\n             match lookup_cur_matched(name, interpolations, repeats) {\n-                Some(MatchedSeq(ref ads)) => {\n+                Some(MatchedSeq(ads)) => {\n                     default_rslt.with(LockstepIterSize::Constraint(ads.len(), name))\n                 }\n                 _ => default_rslt,\n@@ -449,7 +447,7 @@ fn count_repetitions<'a>(\n                     Some(_) => Err(out_of_bounds_err(cx, declared_lhs_depth, sp.entire(), \"count\")),\n                 }\n             }\n-            MatchedSeq(ref named_matches) => {\n+            MatchedSeq(named_matches) => {\n                 let new_declared_lhs_depth = declared_lhs_depth + 1;\n                 match depth_opt {\n                     None => named_matches\n@@ -472,7 +470,7 @@ fn count_repetitions<'a>(\n     // before we start counting. `matched` contains the various levels of the\n     // tree as we descend, and its final value is the subtree we are currently at.\n     for &(idx, _) in repeats {\n-        if let MatchedSeq(ref ads) = matched {\n+        if let MatchedSeq(ads) = matched {\n             matched = &ads[idx];\n         }\n     }"}, {"sha": "0726d922c84a3e494ccbec353c20e6df333ccd73", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -176,9 +176,9 @@ fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n     }\n     impl<'a> visit::Visitor<'a> for PatIdentVisitor {\n         fn visit_pat(&mut self, p: &'a ast::Pat) {\n-            match p.kind {\n-                PatKind::Ident(_, ref ident, _) => {\n-                    self.spans.push(ident.span.clone());\n+            match &p.kind {\n+                PatKind::Ident(_, ident, _) => {\n+                    self.spans.push(ident.span);\n                 }\n                 _ => {\n                     visit::walk_pat(self, p);\n@@ -290,10 +290,8 @@ fn ttdelim_span() {\n         )\n         .unwrap();\n \n-        let tts: Vec<_> = match expr.kind {\n-            ast::ExprKind::MacCall(ref mac) => mac.args.tokens.clone().into_trees().collect(),\n-            _ => panic!(\"not a macro\"),\n-        };\n+        let ast::ExprKind::MacCall(mac) = &expr.kind else { panic!(\"not a macro\") };\n+        let tts: Vec<_> = mac.args.tokens.clone().into_trees().collect();\n \n         let span = tts.iter().rev().next().unwrap().span();\n \n@@ -318,11 +316,8 @@ fn out_of_line_mod() {\n         .unwrap()\n         .unwrap();\n \n-        if let ast::ItemKind::Mod(_, ref mod_kind) = item.kind {\n-            assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n-        } else {\n-            panic!();\n-        }\n+        let ast::ItemKind::Mod(_, mod_kind) = &item.kind else { panic!() };\n+        assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n     });\n }\n "}, {"sha": "341ae18541b3796a5c58c2a89cfe9c1051fc181b", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -597,8 +597,8 @@ impl server::SourceFile for Rustc<'_, '_> {\n     }\n \n     fn path(&mut self, file: &Self::SourceFile) -> String {\n-        match file.name {\n-            FileName::Real(ref name) => name\n+        match &file.name {\n+            FileName::Real(name) => name\n                 .local_path()\n                 .expect(\"attempting to get a file path in an imported file in `proc_macro::SourceFile::path`\")\n                 .to_str()"}, {"sha": "d6566860f8170a96d25bb96f3d2e08a56c88b6fc", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1787,6 +1787,14 @@ impl Expr<'_> {\n         expr\n     }\n \n+    pub fn peel_borrows(&self) -> &Self {\n+        let mut expr = self;\n+        while let ExprKind::AddrOf(.., inner) = &expr.kind {\n+            expr = inner;\n+        }\n+        expr\n+    }\n+\n     pub fn can_have_side_effects(&self) -> bool {\n         match self.peel_drop_temps().kind {\n             ExprKind::Path(_) | ExprKind::Lit(_) => false,"}, {"sha": "54fa5702fbca4b49298e49472722991f023a9751", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -291,6 +291,7 @@ language_item_table! {\n     IdentityFuture,          sym::identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n     GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n+    Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n     FromFrom,                sym::from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;"}, {"sha": "6435b05cef8a8bac5041a2fe8db5207c5d9b86d9", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -569,17 +569,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .bindings\n             .iter()\n             .map(|binding| {\n-                let kind = match binding.kind {\n-                    hir::TypeBindingKind::Equality { ref term } => match term {\n-                        hir::Term::Ty(ref ty) => {\n+                let kind = match &binding.kind {\n+                    hir::TypeBindingKind::Equality { term } => match term {\n+                        hir::Term::Ty(ty) => {\n                             ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty).into())\n                         }\n-                        hir::Term::Const(ref c) => {\n+                        hir::Term::Const(c) => {\n                             let c = Const::from_anon_const(self.tcx(), c.def_id);\n                             ConvertedBindingKind::Equality(c.into())\n                         }\n                     },\n-                    hir::TypeBindingKind::Constraint { ref bounds } => {\n+                    hir::TypeBindingKind::Constraint { bounds } => {\n                         ConvertedBindingKind::Constraint(bounds)\n                     }\n                 };\n@@ -1928,7 +1928,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorGuaranteed> {\n         let tcx = self.tcx();\n         let assoc_ident = assoc_segment.ident;\n-        let qself_res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n+        let qself_res = if let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = &qself.kind {\n             path.res\n         } else {\n             Res::Err\n@@ -1971,8 +1971,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 return;\n                             };\n                             let (qself_sugg_span, is_self) = if let hir::TyKind::Path(\n-                                hir::QPath::Resolved(_, ref path)\n-                            ) = qself.kind {\n+                                hir::QPath::Resolved(_, path)\n+                            ) = &qself.kind {\n                                 // If the path segment already has type params, we want to overwrite\n                                 // them.\n                                 match &path.segments[..] {\n@@ -2602,7 +2602,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         match path.res {\n             Res::Def(DefKind::OpaqueTy | DefKind::ImplTraitPlaceholder, did) => {\n                 // Check for desugared `impl Trait`.\n-                assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n+                assert!(tcx.is_type_alias_impl_trait(did));\n                 let item_segment = path.segments.split_last().unwrap();\n                 self.prohibit_generics(item_segment.1.iter(), |err| {\n                     err.note(\"`impl Trait` types can't have type parameters\");\n@@ -2760,7 +2760,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         \"generic `Self` types are currently not permitted in anonymous constants\",\n                     );\n                     if let Some(hir::Node::Item(&hir::Item {\n-                        kind: hir::ItemKind::Impl(ref impl_),\n+                        kind: hir::ItemKind::Impl(impl_),\n                         ..\n                     })) = tcx.hir().get_if_local(def_id)\n                     {\n@@ -2843,12 +2843,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn ast_ty_to_ty_inner(&self, ast_ty: &hir::Ty<'_>, borrowed: bool, in_path: bool) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n-        let result_ty = match ast_ty.kind {\n-            hir::TyKind::Slice(ref ty) => tcx.mk_slice(self.ast_ty_to_ty(ty)),\n-            hir::TyKind::Ptr(ref mt) => {\n+        let result_ty = match &ast_ty.kind {\n+            hir::TyKind::Slice(ty) => tcx.mk_slice(self.ast_ty_to_ty(ty)),\n+            hir::TyKind::Ptr(mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut { ty: self.ast_ty_to_ty(mt.ty), mutbl: mt.mutbl })\n             }\n-            hir::TyKind::Ref(ref region, ref mt) => {\n+            hir::TyKind::Ref(region, mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(?r);\n                 let t = self.ast_ty_to_ty_inner(mt.ty, true, false);\n@@ -2868,20 +2868,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     Some(ast_ty),\n                 ))\n             }\n-            hir::TyKind::TraitObject(bounds, ref lifetime, repr) => {\n+            hir::TyKind::TraitObject(bounds, lifetime, repr) => {\n                 self.maybe_lint_bare_trait(ast_ty, in_path);\n                 let repr = match repr {\n                     TraitObjectSyntax::Dyn | TraitObjectSyntax::None => ty::Dyn,\n                     TraitObjectSyntax::DynStar => ty::DynStar,\n                 };\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed, repr)\n             }\n-            hir::TyKind::Path(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n+            hir::TyKind::Path(hir::QPath::Resolved(maybe_qself, path)) => {\n                 debug!(?maybe_qself, ?path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n-            hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n+            &hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n                 let def_id = item_id.owner_id.to_def_id();\n \n@@ -2892,14 +2892,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 }\n             }\n-            hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+            hir::TyKind::Path(hir::QPath::TypeRelative(qself, segment)) => {\n                 debug!(?qself, ?segment);\n                 let ty = self.ast_ty_to_ty_inner(qself, false, true);\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, qself, segment, false)\n                     .map(|(ty, _, _)| ty)\n                     .unwrap_or_else(|_| tcx.ty_error())\n             }\n-            hir::TyKind::Path(hir::QPath::LangItem(lang_item, span, _)) => {\n+            &hir::TyKind::Path(hir::QPath::LangItem(lang_item, span, _)) => {\n                 let def_id = tcx.require_lang_item(lang_item, Some(span));\n                 let (substs, _) = self.create_substs_for_ast_path(\n                     span,\n@@ -2913,7 +2913,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 );\n                 EarlyBinder(tcx.at(span).type_of(def_id)).subst(tcx, substs)\n             }\n-            hir::TyKind::Array(ref ty, ref length) => {\n+            hir::TyKind::Array(ty, length) => {\n                 let length = match length {\n                     &hir::ArrayLen::Infer(_, span) => self.ct_infer(tcx.types.usize, None, span),\n                     hir::ArrayLen::Body(constant) => {\n@@ -2923,7 +2923,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length))\n             }\n-            hir::TyKind::Typeof(ref e) => {\n+            hir::TyKind::Typeof(e) => {\n                 let ty_erased = tcx.type_of(e.def_id);\n                 let ty = tcx.fold_regions(ty_erased, |r, _| {\n                     if r.is_erased() { tcx.lifetimes.re_static } else { r }"}, {"sha": "abc1c2d7b8d1754ade0e1b977b8032a7c331c787", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 62, "deletions": 17, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -267,7 +267,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n             debug!(?t, \"root_visit_ty\");\n             if t == self.opaque_identity_ty {\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             } else {\n                 t.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n                     tcx: self.tcx,\n@@ -282,7 +282,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n                 if self.references_parent_regions {\n                     ControlFlow::Break(t)\n                 } else {\n-                    ControlFlow::CONTINUE\n+                    ControlFlow::Continue(())\n                 }\n             }\n         }\n@@ -531,9 +531,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n             let it = tcx.hir().item(id);\n-            let hir::ItemKind::Impl(ref impl_) = it.kind else {\n-                return;\n-            };\n+            let hir::ItemKind::Impl(impl_) = it.kind else { return };\n             debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n                 check_impl_items_against_trait(\n@@ -548,15 +546,15 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         }\n         DefKind::Trait => {\n             let it = tcx.hir().item(id);\n-            let hir::ItemKind::Trait(_, _, _, _, ref items) = it.kind else {\n+            let hir::ItemKind::Trait(_, _, _, _, items) = it.kind else {\n                 return;\n             };\n             check_on_unimplemented(tcx, it);\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n-                match item.kind {\n-                    hir::TraitItemKind::Fn(ref sig, _) => {\n+                match &item.kind {\n+                    hir::TraitItemKind::Fn(sig, _) => {\n                         let abi = sig.header.abi;\n                         fn_maybe_err(tcx, item.ident.span, abi);\n                     }\n@@ -652,8 +650,8 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n                     }\n \n                     let item = tcx.hir().foreign_item(item.id);\n-                    match item.kind {\n-                        hir::ForeignItemKind::Fn(ref fn_decl, _, _) => {\n+                    match &item.kind {\n+                        hir::ForeignItemKind::Fn(fn_decl, _, _) => {\n                             require_c_abi_if_c_variadic(tcx, fn_decl, abi, item.span);\n                         }\n                         hir::ForeignItemKind::Static(..) => {\n@@ -1393,11 +1391,15 @@ fn async_opaque_type_cycle_error(tcx: TyCtxt<'_>, span: Span) -> ErrorGuaranteed\n ///\n /// If all the return expressions evaluate to `!`, then we explain that the error will go away\n /// after changing it. This can happen when a user uses `panic!()` or similar as a placeholder.\n-fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> ErrorGuaranteed {\n+fn opaque_type_cycle_error(\n+    tcx: TyCtxt<'_>,\n+    opaque_def_id: LocalDefId,\n+    span: Span,\n+) -> ErrorGuaranteed {\n     let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n \n     let mut label = false;\n-    if let Some((def_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n+    if let Some((def_id, visitor)) = get_owner_return_paths(tcx, opaque_def_id) {\n         let typeck_results = tcx.typeck(def_id);\n         if visitor\n             .returns\n@@ -1433,28 +1435,71 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> E\n                 .filter_map(|e| typeck_results.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n                 .filter(|(_, ty)| !matches!(ty.kind(), ty::Never))\n             {\n-                struct OpaqueTypeCollector(Vec<DefId>);\n+                #[derive(Default)]\n+                struct OpaqueTypeCollector {\n+                    opaques: Vec<DefId>,\n+                    closures: Vec<DefId>,\n+                }\n                 impl<'tcx> ty::visit::TypeVisitor<'tcx> for OpaqueTypeCollector {\n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                         match *t.kind() {\n                             ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n-                                self.0.push(def);\n-                                ControlFlow::CONTINUE\n+                                self.opaques.push(def);\n+                                ControlFlow::Continue(())\n+                            }\n+                            ty::Closure(def_id, ..) | ty::Generator(def_id, ..) => {\n+                                self.closures.push(def_id);\n+                                t.super_visit_with(self)\n                             }\n                             _ => t.super_visit_with(self),\n                         }\n                     }\n                 }\n-                let mut visitor = OpaqueTypeCollector(vec![]);\n+\n+                let mut visitor = OpaqueTypeCollector::default();\n                 ty.visit_with(&mut visitor);\n-                for def_id in visitor.0 {\n+                for def_id in visitor.opaques {\n                     let ty_span = tcx.def_span(def_id);\n                     if !seen.contains(&ty_span) {\n                         err.span_label(ty_span, &format!(\"returning this opaque type `{ty}`\"));\n                         seen.insert(ty_span);\n                     }\n                     err.span_label(sp, &format!(\"returning here with type `{ty}`\"));\n                 }\n+\n+                for closure_def_id in visitor.closures {\n+                    let Some(closure_local_did) = closure_def_id.as_local() else { continue; };\n+                    let typeck_results = tcx.typeck(closure_local_did);\n+\n+                    let mut label_match = |ty: Ty<'_>, span| {\n+                        for arg in ty.walk() {\n+                            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                                && let ty::Alias(ty::Opaque, ty::AliasTy { def_id: captured_def_id, .. }) = *ty.kind()\n+                                && captured_def_id == opaque_def_id.to_def_id()\n+                            {\n+                                err.span_label(\n+                                    span,\n+                                    format!(\n+                                        \"{} captures itself here\",\n+                                        tcx.def_kind(closure_def_id).descr(closure_def_id)\n+                                    ),\n+                                );\n+                            }\n+                        }\n+                    };\n+\n+                    // Label any closure upvars that capture the opaque\n+                    for capture in typeck_results.closure_min_captures_flattened(closure_local_did)\n+                    {\n+                        label_match(capture.place.ty(), capture.get_path_span(tcx));\n+                    }\n+                    // Label any generator locals that capture the opaque\n+                    for interior_ty in\n+                        typeck_results.generator_interior_types.as_ref().skip_binder()\n+                    {\n+                        label_match(interior_ty.ty, interior_ty.span);\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "cfebcceef3cdb1e1096907e76fd6df256d5dbdd5", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 111, "deletions": 149, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -47,42 +47,22 @@ pub(super) fn compare_impl_method<'tcx>(\n \n     let impl_m_span = tcx.def_span(impl_m.def_id);\n \n-    if let Err(_) = compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m, false) {\n-        return;\n-    }\n-\n-    if let Err(_) =\n-        compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)\n-    {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_synthetic_generics(tcx, impl_m, trait_m) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span) {\n-        return;\n-    }\n-\n-    if let Err(_) = compare_method_predicate_entailment(\n-        tcx,\n-        impl_m,\n-        impl_m_span,\n-        trait_m,\n-        impl_trait_ref,\n-        CheckImpliedWfMode::Check,\n-    ) {\n-        return;\n-    }\n+    let _: Result<_, ErrorGuaranteed> = try {\n+        compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)?;\n+        compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false)?;\n+        compare_generic_param_kinds(tcx, impl_m, trait_m, false)?;\n+        compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_synthetic_generics(tcx, impl_m, trait_m)?;\n+        compare_asyncness(tcx, impl_m, impl_m_span, trait_m, trait_item_span)?;\n+        compare_method_predicate_entailment(\n+            tcx,\n+            impl_m,\n+            impl_m_span,\n+            trait_m,\n+            impl_trait_ref,\n+            CheckImpliedWfMode::Check,\n+        )?;\n+    };\n }\n \n /// This function is best explained by example. Consider a trait:\n@@ -209,9 +189,11 @@ fn compare_method_predicate_entailment<'tcx>(\n     //\n     // We then register the obligations from the impl_m and check to see\n     // if all constraints hold.\n-    hybrid_preds\n-        .predicates\n-        .extend(trait_m_predicates.instantiate_own(tcx, trait_to_placeholder_substs).predicates);\n+    hybrid_preds.predicates.extend(\n+        trait_m_predicates\n+            .instantiate_own(tcx, trait_to_placeholder_substs)\n+            .map(|(predicate, _)| predicate),\n+    );\n \n     // Construct trait parameter environment and then shift it into the placeholder viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n@@ -230,7 +212,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds());\n \n     let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n-    for (predicate, span) in iter::zip(impl_m_own_bounds.predicates, impl_m_own_bounds.spans) {\n+    for (predicate, span) in impl_m_own_bounds {\n         let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n         let predicate = ocx.normalize(&normalize_cause, param_env, predicate);\n \n@@ -934,16 +916,14 @@ fn report_trait_method_mismatch<'tcx>(\n             // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n             // span points only at the type `Box<Self`>, but we want to cover the whole\n             // argument pattern and type.\n-            let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                ImplItemKind::Fn(ref sig, body) => tcx\n-                    .hir()\n-                    .body_param_names(body)\n-                    .zip(sig.decl.inputs.iter())\n-                    .map(|(param, ty)| param.span.to(ty.span))\n-                    .next()\n-                    .unwrap_or(impl_err_span),\n-                _ => bug!(\"{:?} is not a method\", impl_m),\n-            };\n+            let ImplItemKind::Fn(ref sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{impl_m:?} is not a method\") };\n+            let span = tcx\n+                .hir()\n+                .body_param_names(body)\n+                .zip(sig.decl.inputs.iter())\n+                .map(|(param, ty)| param.span.to(ty.span))\n+                .next()\n+                .unwrap_or(impl_err_span);\n \n             diag.span_suggestion(\n                 span,\n@@ -956,22 +936,21 @@ fn report_trait_method_mismatch<'tcx>(\n             if trait_sig.inputs().len() == *i {\n                 // Suggestion to change output type. We do not suggest in `async` functions\n                 // to avoid complex logic or incorrect output.\n-                match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                    ImplItemKind::Fn(ref sig, _) if !sig.header.asyncness.is_async() => {\n-                        let msg = \"change the output type to match the trait\";\n-                        let ap = Applicability::MachineApplicable;\n-                        match sig.decl.output {\n-                            hir::FnRetTy::DefaultReturn(sp) => {\n-                                let sugg = format!(\"-> {} \", trait_sig.output());\n-                                diag.span_suggestion_verbose(sp, msg, sugg, ap);\n-                            }\n-                            hir::FnRetTy::Return(hir_ty) => {\n-                                let sugg = trait_sig.output();\n-                                diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n-                            }\n-                        };\n-                    }\n-                    _ => {}\n+                if let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind\n+                    && !sig.header.asyncness.is_async()\n+                {\n+                    let msg = \"change the output type to match the trait\";\n+                    let ap = Applicability::MachineApplicable;\n+                    match sig.decl.output {\n+                        hir::FnRetTy::DefaultReturn(sp) => {\n+                            let sugg = format!(\"-> {} \", trait_sig.output());\n+                            diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                        }\n+                        hir::FnRetTy::Return(hir_ty) => {\n+                            let sugg = trait_sig.output();\n+                            diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                        }\n+                    };\n                 };\n             } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n                 diag.span_suggestion(\n@@ -1098,25 +1077,18 @@ fn extract_spans_for_error_reporting<'tcx>(\n     trait_m: &ty::AssocItem,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let mut impl_args = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-        ImplItemKind::Fn(ref sig, _) => {\n-            sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n-        }\n-        _ => bug!(\"{:?} is not a method\", impl_m),\n+    let mut impl_args = {\n+        let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     };\n-    let trait_args =\n-        trait_m.def_id.as_local().map(|def_id| match tcx.hir().expect_trait_item(def_id).kind {\n-            TraitItemKind::Fn(ref sig, _) => {\n-                sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n-            }\n-            _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n-        });\n+\n+    let trait_args = trait_m.def_id.as_local().map(|def_id| {\n+        let TraitItemKind::Fn(sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m) };\n+        sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n+    });\n \n     match terr {\n-        TypeError::ArgumentMutability(i) => {\n-            (impl_args.nth(i).unwrap(), trait_args.and_then(|mut args| args.nth(i)))\n-        }\n-        TypeError::ArgumentSorts(ExpectedFound { .. }, i) => {\n+        TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(ExpectedFound { .. }, i) => {\n             (impl_args.nth(i).unwrap(), trait_args.and_then(|mut args| args.nth(i)))\n         }\n         _ => (cause.span(), tcx.hir().span_if_local(trait_m.def_id)),\n@@ -1176,8 +1148,7 @@ fn compare_self_type<'tcx>(\n             } else {\n                 err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n-            let reported = err.emit();\n-            return Err(reported);\n+            return Err(err.emit());\n         }\n \n         (true, false) => {\n@@ -1196,8 +1167,8 @@ fn compare_self_type<'tcx>(\n             } else {\n                 err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n-            let reported = err.emit();\n-            return Err(reported);\n+\n+            return Err(err.emit());\n         }\n     }\n \n@@ -1379,41 +1350,39 @@ fn compare_number_of_method_arguments<'tcx>(\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n+\n     if trait_number_args != impl_number_args {\n-        let trait_span = if let Some(def_id) = trait_m.def_id.as_local() {\n-            match tcx.hir().expect_trait_item(def_id).kind {\n-                TraitItemKind::Fn(ref trait_m_sig, _) => {\n-                    let pos = if trait_number_args > 0 { trait_number_args - 1 } else { 0 };\n-                    if let Some(arg) = trait_m_sig.decl.inputs.get(pos) {\n-                        Some(if pos == 0 {\n-                            arg.span\n-                        } else {\n-                            arg.span.with_lo(trait_m_sig.decl.inputs[0].span.lo())\n-                        })\n-                    } else {\n-                        trait_item_span\n-                    }\n-                }\n-                _ => bug!(\"{:?} is not a method\", impl_m),\n-            }\n-        } else {\n-            trait_item_span\n-        };\n-        let impl_span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-            ImplItemKind::Fn(ref impl_m_sig, _) => {\n-                let pos = if impl_number_args > 0 { impl_number_args - 1 } else { 0 };\n-                if let Some(arg) = impl_m_sig.decl.inputs.get(pos) {\n+        let trait_span = trait_m\n+            .def_id\n+            .as_local()\n+            .and_then(|def_id| {\n+                let TraitItemKind::Fn(trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+                let pos = trait_number_args.saturating_sub(1);\n+                trait_m_sig.decl.inputs.get(pos).map(|arg| {\n                     if pos == 0 {\n                         arg.span\n                     } else {\n-                        arg.span.with_lo(impl_m_sig.decl.inputs[0].span.lo())\n+                        arg.span.with_lo(trait_m_sig.decl.inputs[0].span.lo())\n                     }\n+                })\n+            })\n+            .or(trait_item_span);\n+\n+        let ImplItemKind::Fn(impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let pos = impl_number_args.saturating_sub(1);\n+        let impl_span = impl_m_sig\n+            .decl\n+            .inputs\n+            .get(pos)\n+            .map(|arg| {\n+                if pos == 0 {\n+                    arg.span\n                 } else {\n-                    impl_m_span\n+                    arg.span.with_lo(impl_m_sig.decl.inputs[0].span.lo())\n                 }\n-            }\n-            _ => bug!(\"{:?} is not a method\", impl_m),\n-        };\n+            })\n+            .unwrap_or(impl_m_span);\n+\n         let mut err = struct_span_err!(\n             tcx.sess,\n             impl_span,\n@@ -1424,6 +1393,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             tcx.def_path_str(trait_m.def_id),\n             trait_number_args\n         );\n+\n         if let Some(trait_span) = trait_span {\n             err.span_label(\n                 trait_span,\n@@ -1435,6 +1405,7 @@ fn compare_number_of_method_arguments<'tcx>(\n         } else {\n             err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n         }\n+\n         err.span_label(\n             impl_span,\n             format!(\n@@ -1443,8 +1414,8 @@ fn compare_number_of_method_arguments<'tcx>(\n                 impl_number_args\n             ),\n         );\n-        let reported = err.emit();\n-        return Err(reported);\n+\n+        return Err(err.emit());\n     }\n \n     Ok(())\n@@ -1491,7 +1462,7 @@ fn compare_synthetic_generics<'tcx>(\n                 // explicit generics\n                 (true, false) => {\n                     err.span_label(impl_span, \"expected generic parameter, found `impl Trait`\");\n-                    (|| {\n+                    let _: Option<_> = try {\n                         // try taking the name from the trait impl\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n@@ -1524,33 +1495,31 @@ fn compare_synthetic_generics<'tcx>(\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n-                        Some(())\n-                    })();\n+                    };\n                 }\n                 // The case where the trait method uses `impl Trait`, but the impl method uses\n                 // explicit generics.\n                 (false, true) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n-                    (|| {\n+                    let _: Option<_> = try {\n                         let impl_m = impl_m.def_id.as_local()?;\n                         let impl_m = tcx.hir().expect_impl_item(impl_m);\n-                        let input_tys = match impl_m.kind {\n-                            hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n-                            _ => unreachable!(),\n-                        };\n+                        let hir::ImplItemKind::Fn(sig, _) = &impl_m.kind else { unreachable!() };\n+                        let input_tys = sig.decl.inputs;\n+\n                         struct Visitor(Option<Span>, hir::def_id::LocalDefId);\n                         impl<'v> intravisit::Visitor<'v> for Visitor {\n                             fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n                                 intravisit::walk_ty(self, ty);\n-                                if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) =\n-                                    ty.kind\n+                                if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = ty.kind\n                                     && let Res::Def(DefKind::TyParam, def_id) = path.res\n                                     && def_id == self.1.to_def_id()\n                                 {\n                                     self.0 = Some(ty.span);\n                                 }\n                             }\n                         }\n+\n                         let mut visitor = Visitor(None, impl_def_id);\n                         for ty in input_tys {\n                             intravisit::Visitor::visit_ty(&mut visitor, ty);\n@@ -1571,13 +1540,11 @@ fn compare_synthetic_generics<'tcx>(\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n-                        Some(())\n-                    })();\n+                    };\n                 }\n                 _ => unreachable!(),\n             }\n-            let reported = err.emit();\n-            error_found = Some(reported);\n+            error_found = Some(err.emit());\n         }\n     }\n     if let Some(reported) = error_found { Err(reported) } else { Ok(()) }\n@@ -1737,10 +1704,8 @@ pub(super) fn compare_impl_const_raw(\n         );\n \n         // Locate the Span containing just the type of the offending impl\n-        match tcx.hir().expect_impl_item(impl_const_item_def).kind {\n-            ImplItemKind::Const(ref ty, _) => cause.span = ty.span,\n-            _ => bug!(\"{:?} is not a impl const\", impl_const_item),\n-        }\n+        let ImplItemKind::Const(ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).kind else { bug!(\"{impl_const_item:?} is not a impl const\") };\n+        cause.span = ty.span;\n \n         let mut diag = struct_span_err!(\n             tcx.sess,\n@@ -1752,10 +1717,8 @@ pub(super) fn compare_impl_const_raw(\n \n         let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n             // Add a label to the Span containing just the type of the const\n-            match tcx.hir().expect_trait_item(trait_c_def_id).kind {\n-                TraitItemKind::Const(ref ty, _) => ty.span,\n-                _ => bug!(\"{:?} is not a trait const\", trait_const_item),\n-            }\n+            let TraitItemKind::Const(ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).kind else { bug!(\"{trait_const_item:?} is not a trait const\") };\n+            ty.span\n         });\n \n         infcx.err_ctxt().note_type_err(\n@@ -1797,16 +1760,16 @@ pub(super) fn compare_impl_ty<'tcx>(\n ) {\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let _: Result<(), ErrorGuaranteed> = (|| {\n+    let _: Result<(), ErrorGuaranteed> = try {\n         compare_number_of_generics(tcx, impl_ty, trait_ty, trait_item_span, false)?;\n \n         compare_generic_param_kinds(tcx, impl_ty, trait_ty, false)?;\n \n         let sp = tcx.def_span(impl_ty.def_id);\n         compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;\n \n-        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)\n-    })();\n+        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)?;\n+    };\n }\n \n /// The equivalent of [compare_method_predicate_entailment], but for associated types\n@@ -1828,8 +1791,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     check_region_bounds_on_impl_item(tcx, impl_ty, trait_ty, false)?;\n \n     let impl_ty_own_bounds = impl_ty_predicates.instantiate_own(tcx, impl_substs);\n-\n-    if impl_ty_own_bounds.is_empty() {\n+    if impl_ty_own_bounds.len() == 0 {\n         // Nothing to check.\n         return Ok(());\n     }\n@@ -1844,9 +1806,11 @@ fn compare_type_predicate_entailment<'tcx>(\n     // associated type in the trait are assumed.\n     let impl_predicates = tcx.predicates_of(impl_ty_predicates.parent.unwrap());\n     let mut hybrid_preds = impl_predicates.instantiate_identity(tcx);\n-    hybrid_preds\n-        .predicates\n-        .extend(trait_ty_predicates.instantiate_own(tcx, trait_to_impl_substs).predicates);\n+    hybrid_preds.predicates.extend(\n+        trait_ty_predicates\n+            .instantiate_own(tcx, trait_to_impl_substs)\n+            .map(|(predicate, _)| predicate),\n+    );\n \n     debug!(\"compare_type_predicate_entailment: bounds={:?}\", hybrid_preds);\n \n@@ -1862,9 +1826,7 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n-    assert_eq!(impl_ty_own_bounds.predicates.len(), impl_ty_own_bounds.spans.len());\n-    for (span, predicate) in std::iter::zip(impl_ty_own_bounds.spans, impl_ty_own_bounds.predicates)\n-    {\n+    for (predicate, span) in impl_ty_own_bounds {\n         let cause = ObligationCause::misc(span, impl_ty_hir_id);\n         let predicate = ocx.normalize(&cause, param_env, predicate);\n "}, {"sha": "82030d82f57a0536f90667df5ba79183aeed8f02", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n             }\n \n             match *op {\n-                hir::InlineAsmOperand::In { reg, ref expr } => {\n+                hir::InlineAsmOperand::In { reg, expr } => {\n                     self.check_asm_operand_type(\n                         idx,\n                         reg,\n@@ -362,7 +362,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         &target_features,\n                     );\n                 }\n-                hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n+                hir::InlineAsmOperand::Out { reg, late: _, expr } => {\n                     if let Some(expr) = expr {\n                         self.check_asm_operand_type(\n                             idx,\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         );\n                     }\n                 }\n-                hir::InlineAsmOperand::InOut { reg, late: _, ref expr } => {\n+                hir::InlineAsmOperand::InOut { reg, late: _, expr } => {\n                     self.check_asm_operand_type(\n                         idx,\n                         reg,\n@@ -386,7 +386,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                         &target_features,\n                     );\n                 }\n-                hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n+                hir::InlineAsmOperand::SplitInOut { reg, late: _, in_expr, out_expr } => {\n                     let in_ty = self.check_asm_operand_type(\n                         idx,\n                         reg,"}, {"sha": "b28bfb1d54b6ca7d1bc256a16b564ffe954a720f", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -180,7 +180,7 @@ fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir\n \n     visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n-    if let Some(hir::Guard::If(ref expr)) = arm.guard {\n+    if let Some(hir::Guard::If(expr)) = arm.guard {\n         visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n@@ -242,8 +242,8 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             // This ensures fixed size stacks.\n             hir::ExprKind::Binary(\n                 source_map::Spanned { node: hir::BinOpKind::And | hir::BinOpKind::Or, .. },\n-                ref l,\n-                ref r,\n+                l,\n+                r,\n             ) => {\n                 // expr is a short circuiting operator (|| or &&). As its\n                 // functionality can't be overridden by traits, it always\n@@ -288,20 +288,20 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                     terminating(r.hir_id.local_id);\n                 }\n             }\n-            hir::ExprKind::If(_, ref then, Some(ref otherwise)) => {\n+            hir::ExprKind::If(_, then, Some(otherwise)) => {\n                 terminating(then.hir_id.local_id);\n                 terminating(otherwise.hir_id.local_id);\n             }\n \n-            hir::ExprKind::If(_, ref then, None) => {\n+            hir::ExprKind::If(_, then, None) => {\n                 terminating(then.hir_id.local_id);\n             }\n \n-            hir::ExprKind::Loop(ref body, _, _, _) => {\n+            hir::ExprKind::Loop(body, _, _, _) => {\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprKind::DropTemps(ref expr) => {\n+            hir::ExprKind::DropTemps(expr) => {\n                 // `DropTemps(expr)` does not denote a conditional scope.\n                 // Rather, we want to achieve the same behavior as `{ let _t = expr; _t }`.\n                 terminating(expr.hir_id.local_id);\n@@ -396,7 +396,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             let body = visitor.tcx.hir().body(body);\n             visitor.visit_body(body);\n         }\n-        hir::ExprKind::AssignOp(_, ref left_expr, ref right_expr) => {\n+        hir::ExprKind::AssignOp(_, left_expr, right_expr) => {\n             debug!(\n                 \"resolve_expr - enabling pessimistic_yield, was previously {}\",\n                 prev_pessimistic\n@@ -447,7 +447,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             }\n         }\n \n-        hir::ExprKind::If(ref cond, ref then, Some(ref otherwise)) => {\n+        hir::ExprKind::If(cond, then, Some(otherwise)) => {\n             let expr_cx = visitor.cx;\n             visitor.enter_scope(Scope { id: then.hir_id.local_id, data: ScopeData::IfThen });\n             visitor.cx.var_parent = visitor.cx.parent;\n@@ -457,7 +457,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             visitor.visit_expr(otherwise);\n         }\n \n-        hir::ExprKind::If(ref cond, ref then, None) => {\n+        hir::ExprKind::If(cond, then, None) => {\n             let expr_cx = visitor.cx;\n             visitor.enter_scope(Scope { id: then.hir_id.local_id, data: ScopeData::IfThen });\n             visitor.cx.var_parent = visitor.cx.parent;\n@@ -641,21 +641,21 @@ fn resolve_local<'tcx>(\n         match pat.kind {\n             PatKind::Binding(hir::BindingAnnotation(hir::ByRef::Yes, _), ..) => true,\n \n-            PatKind::Struct(_, ref field_pats, _) => {\n+            PatKind::Struct(_, field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.pat))\n             }\n \n-            PatKind::Slice(ref pats1, ref pats2, ref pats3) => {\n+            PatKind::Slice(pats1, pats2, pats3) => {\n                 pats1.iter().any(|p| is_binding_pat(&p))\n                     || pats2.iter().any(|p| is_binding_pat(&p))\n                     || pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            PatKind::Or(ref subpats)\n-            | PatKind::TupleStruct(_, ref subpats, _)\n-            | PatKind::Tuple(ref subpats, _) => subpats.iter().any(|p| is_binding_pat(&p)),\n+            PatKind::Or(subpats)\n+            | PatKind::TupleStruct(_, subpats, _)\n+            | PatKind::Tuple(subpats, _) => subpats.iter().any(|p| is_binding_pat(&p)),\n \n-            PatKind::Box(ref subpat) => is_binding_pat(&subpat),\n+            PatKind::Box(subpat) => is_binding_pat(&subpat),\n \n             PatKind::Ref(_, _)\n             | PatKind::Binding(hir::BindingAnnotation(hir::ByRef::No, _), ..)\n@@ -704,11 +704,11 @@ fn resolve_local<'tcx>(\n                     record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 }\n             }\n-            hir::ExprKind::Cast(ref subexpr, _) => {\n+            hir::ExprKind::Cast(subexpr, _) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n-            hir::ExprKind::Block(ref block, _) => {\n-                if let Some(ref subexpr) = block.expr {\n+            hir::ExprKind::Block(block, _) => {\n+                if let Some(subexpr) = block.expr {\n                     record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 }\n             }"}, {"sha": "11237afe8a0e36f50b7153370acbe3c20e51b81b", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -32,7 +32,6 @@ use rustc_trait_selection::traits::{\n };\n \n use std::cell::LazyCell;\n-use std::iter;\n use std::ops::{ControlFlow, Deref};\n \n pub(super) struct WfCheckingCtxt<'a, 'tcx> {\n@@ -179,7 +178,7 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n-        hir::ItemKind::Impl(ref impl_) => {\n+        hir::ItemKind::Impl(impl_) => {\n             let is_auto = tcx\n                 .impl_trait_ref(def_id)\n                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.skip_binder().def_id));\n@@ -225,15 +224,15 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Const(ty, ..) => {\n             check_item_type(tcx, def_id, ty.span, false);\n         }\n-        hir::ItemKind::Struct(_, ref ast_generics) => {\n+        hir::ItemKind::Struct(_, ast_generics) => {\n             check_type_defn(tcx, item, false);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Union(_, ref ast_generics) => {\n+        hir::ItemKind::Union(_, ast_generics) => {\n             check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Enum(_, ref ast_generics) => {\n+        hir::ItemKind::Enum(_, ast_generics) => {\n             check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n@@ -1248,8 +1247,8 @@ fn check_impl<'tcx>(\n     constness: hir::Constness,\n ) {\n     enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n-        match *ast_trait_ref {\n-            Some(ref ast_trait_ref) => {\n+        match ast_trait_ref {\n+            Some(ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n@@ -1310,7 +1309,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n     let infcx = wfcx.infcx;\n     let tcx = wfcx.tcx();\n \n-    let predicates = tcx.bound_predicates_of(def_id.to_def_id());\n+    let predicates = tcx.predicates_of(def_id.to_def_id());\n     let generics = tcx.generics_of(def_id);\n \n     let is_our_default = |def: &ty::GenericParamDef| match def.kind {\n@@ -1411,7 +1410,6 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n \n     // Now we build the substituted predicates.\n     let default_obligations = predicates\n-        .0\n         .predicates\n         .iter()\n         .flat_map(|&(pred, sp)| {\n@@ -1430,7 +1428,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                 }\n \n                 fn visit_region(&mut self, _: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                    ControlFlow::BREAK\n+                    ControlFlow::Break(())\n                 }\n \n                 fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n@@ -1442,13 +1440,13 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             }\n             let mut param_count = CountParams::default();\n             let has_region = pred.visit_with(&mut param_count).is_break();\n-            let substituted_pred = predicates.rebind(pred).subst(tcx, substs);\n+            let substituted_pred = ty::EarlyBinder(pred).subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n             if substituted_pred.has_non_region_param() || param_count.params.len() > 1 || has_region\n             {\n                 None\n-            } else if predicates.0.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n+            } else if predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n                 // Avoid duplication of predicates that contain no parameters, for example.\n                 None\n             } else {\n@@ -1474,22 +1472,21 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             traits::Obligation::new(tcx, cause, wfcx.param_env, pred)\n         });\n \n-    let predicates = predicates.0.instantiate_identity(tcx);\n+    let predicates = predicates.instantiate_identity(tcx);\n \n     let predicates = wfcx.normalize(span, None, predicates);\n \n     debug!(?predicates.predicates);\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n-    let wf_obligations =\n-        iter::zip(&predicates.predicates, &predicates.spans).flat_map(|(&p, &sp)| {\n-            traits::wf::predicate_obligations(\n-                infcx,\n-                wfcx.param_env.without_const(),\n-                wfcx.body_id,\n-                p,\n-                sp,\n-            )\n-        });\n+    let wf_obligations = predicates.into_iter().flat_map(|(p, sp)| {\n+        traits::wf::predicate_obligations(\n+            infcx,\n+            wfcx.param_env.without_const(),\n+            wfcx.body_id,\n+            p,\n+            sp,\n+        )\n+    });\n \n     let obligations: Vec<_> = wf_obligations.chain(default_obligations).collect();\n     wfcx.register_obligations(obligations);"}, {"sha": "28c04087868a7d35e4677488297a5ebe865eed6f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 73, "deletions": 55, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -7,13 +7,15 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n-use rustc_infer::infer;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{self, RegionResolutionError};\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitable};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n-use rustc_trait_selection::traits::misc::{can_type_implement_copy, CopyImplementationError};\n+use rustc_trait_selection::traits::misc::{\n+    type_allowed_to_implement_copy, CopyImplementationError, InfringingFieldsReason,\n+};\n use rustc_trait_selection::traits::predicate_for_trait_def;\n use rustc_trait_selection::traits::{self, ObligationCause};\n use std::collections::BTreeMap;\n@@ -54,12 +56,9 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => {}\n     }\n \n-    let sp = match tcx.hir().expect_item(impl_did).kind {\n-        ItemKind::Impl(ref impl_) => impl_.self_ty.span,\n-        _ => bug!(\"expected Drop impl item\"),\n-    };\n+    let ItemKind::Impl(impl_) = tcx.hir().expect_item(impl_did).kind else { bug!(\"expected Drop impl item\") };\n \n-    tcx.sess.emit_err(DropImplOnWrongItem { span: sp });\n+    tcx.sess.emit_err(DropImplOnWrongItem { span: impl_.self_ty.span });\n }\n \n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n@@ -82,7 +81,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     };\n \n     let cause = traits::ObligationCause::misc(span, impl_hir_id);\n-    match can_type_implement_copy(tcx, param_env, self_type, cause) {\n+    match type_allowed_to_implement_copy(tcx, param_env, self_type, cause) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let mut err = struct_span_err!(\n@@ -97,50 +96,70 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n             let mut errors: BTreeMap<_, Vec<_>> = Default::default();\n             let mut bounds = vec![];\n \n-            for (field, ty) in fields {\n+            for (field, ty, reason) in fields {\n                 let field_span = tcx.def_span(field.did);\n-                let field_ty_span = match tcx.hir().get_if_local(field.did) {\n-                    Some(hir::Node::Field(field_def)) => field_def.ty.span,\n-                    _ => field_span,\n-                };\n                 err.span_label(field_span, \"this field does not implement `Copy`\");\n-                // Spin up a new FulfillmentContext, so we can get the _precise_ reason\n-                // why this field does not implement Copy. This is useful because sometimes\n-                // it is not immediately clear why Copy is not implemented for a field, since\n-                // all we point at is the field itself.\n-                let infcx = tcx.infer_ctxt().ignoring_regions().build();\n-                for error in traits::fully_solve_bound(\n-                    &infcx,\n-                    traits::ObligationCause::dummy_with_span(field_ty_span),\n-                    param_env,\n-                    ty,\n-                    tcx.require_lang_item(LangItem::Copy, Some(span)),\n-                ) {\n-                    let error_predicate = error.obligation.predicate;\n-                    // Only note if it's not the root obligation, otherwise it's trivial and\n-                    // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n-\n-                    // FIXME: This error could be more descriptive, especially if the error_predicate\n-                    // contains a foreign type or if it's a deeply nested type...\n-                    if error_predicate != error.root_obligation.predicate {\n-                        errors\n-                            .entry((ty.to_string(), error_predicate.to_string()))\n-                            .or_default()\n-                            .push(error.obligation.cause.span);\n+\n+                match reason {\n+                    InfringingFieldsReason::Fulfill(fulfillment_errors) => {\n+                        for error in fulfillment_errors {\n+                            let error_predicate = error.obligation.predicate;\n+                            // Only note if it's not the root obligation, otherwise it's trivial and\n+                            // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n+\n+                            // FIXME: This error could be more descriptive, especially if the error_predicate\n+                            // contains a foreign type or if it's a deeply nested type...\n+                            if error_predicate != error.root_obligation.predicate {\n+                                errors\n+                                    .entry((ty.to_string(), error_predicate.to_string()))\n+                                    .or_default()\n+                                    .push(error.obligation.cause.span);\n+                            }\n+                            if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                                ty::TraitPredicate {\n+                                    trait_ref,\n+                                    polarity: ty::ImplPolarity::Positive,\n+                                    ..\n+                                },\n+                            )) = error_predicate.kind().skip_binder()\n+                            {\n+                                let ty = trait_ref.self_ty();\n+                                if let ty::Param(_) = ty.kind() {\n+                                    bounds.push((\n+                                        format!(\"{ty}\"),\n+                                        trait_ref.print_only_trait_path().to_string(),\n+                                        Some(trait_ref.def_id),\n+                                    ));\n+                                }\n+                            }\n+                        }\n                     }\n-                    if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n-                        trait_ref,\n-                        polarity: ty::ImplPolarity::Positive,\n-                        ..\n-                    })) = error_predicate.kind().skip_binder()\n-                    {\n-                        let ty = trait_ref.self_ty();\n-                        if let ty::Param(_) = ty.kind() {\n-                            bounds.push((\n-                                format!(\"{ty}\"),\n-                                trait_ref.print_only_trait_path().to_string(),\n-                                Some(trait_ref.def_id),\n-                            ));\n+                    InfringingFieldsReason::Regions(region_errors) => {\n+                        for error in region_errors {\n+                            let ty = ty.to_string();\n+                            match error {\n+                                RegionResolutionError::ConcreteFailure(origin, a, b) => {\n+                                    let predicate = format!(\"{b}: {a}\");\n+                                    errors\n+                                        .entry((ty.clone(), predicate.clone()))\n+                                        .or_default()\n+                                        .push(origin.span());\n+                                    if let ty::RegionKind::ReEarlyBound(ebr) = *b && ebr.has_name() {\n+                                        bounds.push((b.to_string(), a.to_string(), None));\n+                                    }\n+                                }\n+                                RegionResolutionError::GenericBoundFailure(origin, a, b) => {\n+                                    let predicate = format!(\"{a}: {b}\");\n+                                    errors\n+                                        .entry((ty.clone(), predicate.clone()))\n+                                        .or_default()\n+                                        .push(origin.span());\n+                                    if let infer::region_constraints::GenericKind::Param(_) = a {\n+                                        bounds.push((a.to_string(), b.to_string(), None));\n+                                    }\n+                                }\n+                                _ => continue,\n+                            }\n                         }\n                     }\n                 }\n@@ -505,12 +524,11 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 return err_info;\n             } else if diff_fields.len() > 1 {\n                 let item = tcx.hir().expect_item(impl_did);\n-                let span =\n-                    if let ItemKind::Impl(hir::Impl { of_trait: Some(ref t), .. }) = item.kind {\n-                        t.path.span\n-                    } else {\n-                        tcx.def_span(impl_did)\n-                    };\n+                let span = if let ItemKind::Impl(hir::Impl { of_trait: Some(t), .. }) = &item.kind {\n+                    t.path.span\n+                } else {\n+                    tcx.def_span(impl_did)\n+                };\n \n                 struct_span_err!(\n                     tcx.sess,"}, {"sha": "dfb9824094346949c74b14f117fdd45dbaf6b375", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -182,7 +182,7 @@ impl<'tcx> InherentCollect<'tcx> {\n         }\n \n         let item = self.tcx.hir().item(id);\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, ref items, .. }) = item.kind else {\n+        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, items, .. }) = item.kind else {\n             return;\n         };\n "}, {"sha": "95b03eb8263fda2031504dd4ef6a22319b31b23a", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -40,7 +40,7 @@ fn do_orphan_check_impl<'tcx>(\n     let trait_def_id = trait_ref.def_id;\n \n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(ref impl_) = item.kind else {\n+    let hir::ItemKind::Impl(impl_) = item.kind else {\n         bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n     };\n     let sp = tcx.def_span(def_id);\n@@ -416,13 +416,13 @@ fn fast_reject_auto_impl<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId, self_ty:\n             if t != self.self_ty_root {\n                 for impl_def_id in tcx.non_blanket_impls_for_ty(self.trait_def_id, t) {\n                     match tcx.impl_polarity(impl_def_id) {\n-                        ImplPolarity::Negative => return ControlFlow::BREAK,\n+                        ImplPolarity::Negative => return ControlFlow::Break(()),\n                         ImplPolarity::Reservation => {}\n                         // FIXME(@lcnr): That's probably not good enough, idk\n                         //\n                         // We might just want to take the rustdoc code and somehow avoid\n                         // explicit impls for `Self`.\n-                        ImplPolarity::Positive => return ControlFlow::CONTINUE,\n+                        ImplPolarity::Positive => return ControlFlow::Continue(()),\n                     }\n                 }\n             }\n@@ -440,7 +440,7 @@ fn fast_reject_auto_impl<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId, self_ty:\n                         }\n                     }\n \n-                    ControlFlow::CONTINUE\n+                    ControlFlow::Continue(())\n                 }\n                 _ => t.super_visit_with(self),\n             }"}, {"sha": "fe6119dce873573baf819591798c33e3ecc19b92", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -11,7 +11,7 @@ use rustc_span::def_id::LocalDefId;\n pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug_assert!(matches!(tcx.def_kind(def_id), DefKind::Impl));\n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(ref impl_) = item.kind else { bug!() };\n+    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n \n     if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_ref = trait_ref.subst_identity();"}, {"sha": "c17778ce8bc090e934b82b8399a5d05aa501ac22", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -76,6 +76,7 @@ pub fn provide(providers: &mut Providers) {\n         is_foreign_item,\n         generator_kind,\n         collect_mod_item_types,\n+        is_type_alias_impl_trait,\n         ..*providers\n     };\n }\n@@ -560,15 +561,15 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n     let def_id = item_id.owner_id.def_id;\n \n-    match it.kind {\n+    match &it.kind {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n         | hir::ItemKind::Use(..)\n         | hir::ItemKind::Macro(..)\n         | hir::ItemKind::Mod(_)\n         | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod { items, .. } => {\n-            for item in items {\n+            for item in *items {\n                 let item = tcx.hir().foreign_item(item.id);\n                 tcx.ensure().generics_of(item.owner_id);\n                 tcx.ensure().type_of(item.owner_id);\n@@ -618,7 +619,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             tcx.at(it.span).super_predicates_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n         }\n-        hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n+        hir::ItemKind::Struct(struct_def, _) | hir::ItemKind::Union(struct_def, _) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n@@ -853,14 +854,14 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n     };\n \n     let repr = tcx.repr_options_of_def(def_id.to_def_id());\n-    let (kind, variants) = match item.kind {\n-        ItemKind::Enum(ref def, _) => {\n+    let (kind, variants) = match &item.kind {\n+        ItemKind::Enum(def, _) => {\n             let mut distance_from_explicit = 0;\n             let variants = def\n                 .variants\n                 .iter()\n                 .map(|v| {\n-                    let discr = if let Some(ref e) = v.disr_expr {\n+                    let discr = if let Some(e) = &v.disr_expr {\n                         distance_from_explicit = 0;\n                         ty::VariantDiscr::Explicit(e.def_id.to_def_id())\n                     } else {\n@@ -882,7 +883,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n \n             (AdtKind::Enum, variants)\n         }\n-        ItemKind::Struct(ref def, _) | ItemKind::Union(ref def, _) => {\n+        ItemKind::Struct(def, _) | ItemKind::Union(def, _) => {\n             let adt_kind = match item.kind {\n                 ItemKind::Struct(..) => AdtKind::Struct,\n                 _ => AdtKind::Union,\n@@ -1342,21 +1343,19 @@ fn suggest_impl_trait<'tcx>(\n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n     let item = tcx.hir().expect_item(def_id.expect_local());\n-    match item.kind {\n-        hir::ItemKind::Impl(ref impl_) => impl_\n-            .of_trait\n-            .as_ref()\n-            .map(|ast_trait_ref| {\n-                let selfty = tcx.type_of(def_id);\n-                icx.astconv().instantiate_mono_trait_ref(\n-                    ast_trait_ref,\n-                    selfty,\n-                    check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n-                )\n-            })\n-            .map(ty::EarlyBinder),\n-        _ => bug!(),\n-    }\n+    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    impl_\n+        .of_trait\n+        .as_ref()\n+        .map(|ast_trait_ref| {\n+            let selfty = tcx.type_of(def_id);\n+            icx.astconv().instantiate_mono_trait_ref(\n+                ast_trait_ref,\n+                selfty,\n+                check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n+            )\n+        })\n+        .map(ty::EarlyBinder)\n }\n \n fn check_impl_constness(\n@@ -1511,7 +1510,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {\n             check(input, *ty)\n         }\n-        if let hir::FnRetTy::Return(ref ty) = decl.output {\n+        if let hir::FnRetTy::Return(ty) = decl.output {\n             check(ty, fty.output().skip_binder())\n         }\n     }\n@@ -1537,3 +1536,13 @@ fn generator_kind(tcx: TyCtxt<'_>, def_id: DefId) -> Option<hir::GeneratorKind>\n         _ => bug!(\"generator_kind applied to non-local def-id {:?}\", def_id),\n     }\n }\n+\n+fn is_type_alias_impl_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+    match tcx.hir().get_if_local(def_id) {\n+        Some(Node::Item(hir::Item { kind: hir::ItemKind::OpaqueTy(opaque), .. })) => {\n+            matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias)\n+        }\n+        Some(_) => bug!(\"tried getting opaque_ty_origin for non-opaque: {:?}\", def_id),\n+        _ => bug!(\"tried getting opaque_ty_origin for non-local def-id {:?}\", def_id),\n+    }\n+}"}, {"sha": "014ee9fcc207b425b06bac78729f606d2fbc6ebd", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -110,12 +110,12 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                     // expressions' count (i.e. `N` in `[x; N]`), and explicit\n                     // `enum` discriminants (i.e. `D` in `enum Foo { Bar = D }`),\n                     // as they shouldn't be able to cause query cycle errors.\n-                    Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+                    Node::Expr(Expr { kind: ExprKind::Repeat(_, constant), .. })\n                         if constant.hir_id() == hir_id =>\n                     {\n                         Some(parent_def_id.to_def_id())\n                     }\n-                    Node::Variant(Variant { disr_expr: Some(ref constant), .. })\n+                    Node::Variant(Variant { disr_expr: Some(constant), .. })\n                         if constant.hir_id == hir_id =>\n                     {\n                         Some(parent_def_id.to_def_id())\n@@ -259,7 +259,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n \n     params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n         GenericParamKind::Lifetime { .. } => None,\n-        GenericParamKind::Type { ref default, synthetic, .. } => {\n+        GenericParamKind::Type { default, synthetic, .. } => {\n             if default.is_some() {\n                 match allow_defaults {\n                     Defaults::Allowed => {}\n@@ -426,26 +426,22 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     }\n \n     match node {\n-        Node::TraitItem(item) => match item.kind {\n-            hir::TraitItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, sig.decl)\n-            }\n+        Node::TraitItem(item) => match &item.kind {\n+            hir::TraitItemKind::Fn(sig, _) => has_late_bound_regions(tcx, &item.generics, sig.decl),\n             _ => None,\n         },\n-        Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, sig.decl)\n-            }\n+        Node::ImplItem(item) => match &item.kind {\n+            hir::ImplItemKind::Fn(sig, _) => has_late_bound_regions(tcx, &item.generics, sig.decl),\n             _ => None,\n         },\n         Node::ForeignItem(item) => match item.kind {\n-            hir::ForeignItemKind::Fn(fn_decl, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(fn_decl, _, generics) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n-        Node::Item(item) => match item.kind {\n-            hir::ItemKind::Fn(ref sig, .., ref generics, _) => {\n+        Node::Item(item) => match &item.kind {\n+            hir::ItemKind::Fn(sig, .., generics, _) => {\n                 has_late_bound_regions(tcx, generics, sig.decl)\n             }\n             _ => None,"}, {"sha": "8d479f1c3e335f37e6b6d8dab2d5fdf083055d8a", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -99,12 +99,16 @@ pub(super) fn explicit_item_bounds(\n     }\n }\n \n-pub(super) fn item_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n-    tcx.mk_predicates(\n+pub(super) fn item_bounds(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n+    let bounds = tcx.mk_predicates(\n         util::elaborate_predicates(\n             tcx,\n             tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n         )\n         .map(|obligation| obligation.predicate),\n-    )\n+    );\n+    ty::EarlyBinder(bounds)\n }"}, {"sha": "359122d4e16abd81c0f79463bcdad18cc21c4230", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -428,7 +428,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             _ => {}\n         }\n         match item.kind {\n-            hir::ItemKind::Fn(_, ref generics, _) => {\n+            hir::ItemKind::Fn(_, generics, _) => {\n                 self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n@@ -508,13 +508,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     this.with(scope, |this| intravisit::walk_item(this, item))\n                 });\n             }\n-            hir::ItemKind::TyAlias(_, ref generics)\n-            | hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::Struct(_, ref generics)\n-            | hir::ItemKind::Union(_, ref generics)\n-            | hir::ItemKind::Trait(_, _, ref generics, ..)\n-            | hir::ItemKind::TraitAlias(ref generics, ..)\n-            | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n+            hir::ItemKind::TyAlias(_, generics)\n+            | hir::ItemKind::Enum(_, generics)\n+            | hir::ItemKind::Struct(_, generics)\n+            | hir::ItemKind::Union(_, generics)\n+            | hir::ItemKind::Trait(_, _, generics, ..)\n+            | hir::ItemKind::TraitAlias(generics, ..)\n+            | hir::ItemKind::Impl(&hir::Impl { generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n                 let lifetimes = generics\n                     .params\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n-            hir::ForeignItemKind::Fn(_, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(_, _, generics) => {\n                 self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n@@ -561,7 +561,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n-            hir::TyKind::BareFn(ref c) => {\n+            hir::TyKind::BareFn(c) => {\n                 let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_ty(this, ty);\n                 });\n             }\n-            hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n+            hir::TyKind::TraitObject(bounds, lifetime, _) => {\n                 debug!(?bounds, ?lifetime, \"TraitObject\");\n                 let scope = Scope::TraitRefBoundary { s: self.scope };\n                 self.with(scope, |this| {\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     LifetimeName::Error => {}\n                 }\n             }\n-            hir::TyKind::Ref(ref lifetime_ref, ref mt) => {\n+            hir::TyKind::Ref(lifetime_ref, ref mt) => {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: self.map.defs.get(&lifetime_ref.hir_id).cloned(),\n@@ -632,7 +632,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n                 let opaque_ty = self.tcx.hir().item(item_id);\n-                match opaque_ty.kind {\n+                match &opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         origin: hir::OpaqueTyOrigin::TyAlias,\n                         ..\n@@ -655,7 +655,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n                         ..\n                     }) => {}\n-                    ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n+                    i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n                 // Resolve the lifetimes that are applied to the opaque type.\n@@ -720,7 +720,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_trait_item(this, trait_item)\n                 });\n             }\n-            Type(bounds, ref ty) => {\n+            Type(bounds, ty) => {\n                 let generics = &trait_item.generics;\n                 let lifetimes = generics\n                     .params\n@@ -766,7 +766,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Fn(..) => self.visit_early_late(impl_item.hir_id(), &impl_item.generics, |this| {\n                 intravisit::walk_impl_item(this, impl_item)\n             }),\n-            Type(ref ty) => {\n+            Type(ty) => {\n                 let generics = &impl_item.generics;\n                 let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n                     .params\n@@ -817,7 +817,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n-            if let Some(ref args) = segment.args {\n+            if let Some(args) = segment.args {\n                 self.visit_segment_args(path.res, depth, args);\n             }\n         }\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         let output = match fd.output {\n             hir::FnRetTy::DefaultReturn(_) => None,\n-            hir::FnRetTy::Return(ref ty) => Some(&**ty),\n+            hir::FnRetTy::Return(ty) => Some(ty),\n         };\n         self.visit_fn_like_elision(&fd.inputs, output, matches!(fk, intravisit::FnKind::Closure));\n         intravisit::walk_fn_kind(self, fk);\n@@ -846,13 +846,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             for param in generics.params {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n-                    GenericParamKind::Type { ref default, .. } => {\n-                        if let Some(ref ty) = default {\n-                            this.visit_ty(&ty);\n+                    GenericParamKind::Type { default, .. } => {\n+                        if let Some(ty) = default {\n+                            this.visit_ty(ty);\n                         }\n                     }\n-                    GenericParamKind::Const { ref ty, default } => {\n-                        this.visit_ty(&ty);\n+                    GenericParamKind::Const { ty, default } => {\n+                        this.visit_ty(ty);\n                         if let Some(default) = default {\n                             this.visit_body(this.tcx.hir().body(default.body));\n                         }\n@@ -863,9 +863,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 match predicate {\n                     &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                         hir_id,\n-                        ref bounded_ty,\n+                        bounded_ty,\n                         bounds,\n-                        ref bound_generic_params,\n+                        bound_generic_params,\n                         origin,\n                         ..\n                     }) => {\n@@ -905,7 +905,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         })\n                     }\n                     &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                        ref lifetime,\n+                        lifetime,\n                         bounds,\n                         ..\n                     }) => {\n@@ -914,7 +914,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                         if lifetime.res != hir::LifetimeName::Static {\n                             for bound in bounds {\n-                                let hir::GenericBound::Outlives(ref lt) = bound else {\n+                                let hir::GenericBound::Outlives(lt) = bound else {\n                                     continue;\n                                 };\n                                 if lt.res != hir::LifetimeName::Static {\n@@ -939,8 +939,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     }\n                     &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                        ref lhs_ty,\n-                        ref rhs_ty,\n+                        lhs_ty,\n+                        rhs_ty,\n                         ..\n                     }) => {\n                         this.visit_ty(lhs_ty);\n@@ -1042,7 +1042,7 @@ fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifeti\n                 }\n \n                 for bound in bound.bounds {\n-                    if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n+                    if let hir::GenericBound::Outlives(lifetime) = bound {\n                         set.insert(lifetime.res);\n                     }\n                 }\n@@ -1828,7 +1828,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n                     }\n                 }\n \n-                hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n+                hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently\n                     // valid to have them elsewhere, but even if it"}, {"sha": "46b277d9803d78db081c53ea63bc3861aa209c7c", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -85,30 +85,30 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         Node::ImplItem(item) => item.generics,\n \n         Node::Item(item) => match item.kind {\n-            ItemKind::Impl(ref impl_) => {\n+            ItemKind::Impl(impl_) => {\n                 if impl_.defaultness.is_default() {\n                     is_default_impl_trait =\n                         tcx.impl_trait_ref(def_id).map(|t| ty::Binder::dummy(t.subst_identity()));\n                 }\n-                &impl_.generics\n+                impl_.generics\n             }\n-            ItemKind::Fn(.., ref generics, _)\n-            | ItemKind::TyAlias(_, ref generics)\n-            | ItemKind::Enum(_, ref generics)\n-            | ItemKind::Struct(_, ref generics)\n-            | ItemKind::Union(_, ref generics) => *generics,\n+            ItemKind::Fn(.., generics, _)\n+            | ItemKind::TyAlias(_, generics)\n+            | ItemKind::Enum(_, generics)\n+            | ItemKind::Struct(_, generics)\n+            | ItemKind::Union(_, generics) => generics,\n \n-            ItemKind::Trait(_, _, ref generics, ..) | ItemKind::TraitAlias(ref generics, _) => {\n+            ItemKind::Trait(_, _, generics, ..) | ItemKind::TraitAlias(generics, _) => {\n                 is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                *generics\n+                generics\n             }\n-            ItemKind::OpaqueTy(OpaqueTy { ref generics, .. }) => generics,\n+            ItemKind::OpaqueTy(OpaqueTy { generics, .. }) => generics,\n             _ => NO_GENERICS,\n         },\n \n         Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Static(..) => NO_GENERICS,\n-            ForeignItemKind::Fn(_, _, ref generics) => *generics,\n+            ForeignItemKind::Fn(_, _, generics) => generics,\n             ForeignItemKind::Type => NO_GENERICS,\n         },\n \n@@ -350,7 +350,7 @@ fn const_evaluatable_predicates_of(\n     let node = tcx.hir().get(hir_id);\n \n     let mut collector = ConstCollector { tcx, preds: FxIndexSet::default() };\n-    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(ref impl_) = item.kind {\n+    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(impl_) = item.kind {\n         if let Some(of_trait) = &impl_.of_trait {\n             debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n             collector.visit_trait_ref(of_trait);\n@@ -511,8 +511,8 @@ pub(super) fn super_predicates_that_define_assoc_type(\n         };\n \n         let (generics, bounds) = match item.kind {\n-            hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-            hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+            hir::ItemKind::Trait(.., generics, supertraits, _) => (generics, supertraits),\n+            hir::ItemKind::TraitAlias(generics, supertraits) => (generics, supertraits),\n             _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n         };\n \n@@ -612,18 +612,18 @@ pub(super) fn type_param_predicates(\n \n         Node::Item(item) => {\n             match item.kind {\n-                ItemKind::Fn(.., ref generics, _)\n-                | ItemKind::Impl(hir::Impl { ref generics, .. })\n-                | ItemKind::TyAlias(_, ref generics)\n+                ItemKind::Fn(.., generics, _)\n+                | ItemKind::Impl(&hir::Impl { generics, .. })\n+                | ItemKind::TyAlias(_, generics)\n                 | ItemKind::OpaqueTy(OpaqueTy {\n-                    ref generics,\n+                    generics,\n                     origin: hir::OpaqueTyOrigin::TyAlias,\n                     ..\n                 })\n-                | ItemKind::Enum(_, ref generics)\n-                | ItemKind::Struct(_, ref generics)\n-                | ItemKind::Union(_, ref generics) => generics,\n-                ItemKind::Trait(_, _, ref generics, ..) => {\n+                | ItemKind::Enum(_, generics)\n+                | ItemKind::Struct(_, generics)\n+                | ItemKind::Union(_, generics) => generics,\n+                ItemKind::Trait(_, _, generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_hir_id {\n                         let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n@@ -637,7 +637,7 @@ pub(super) fn type_param_predicates(\n         }\n \n         Node::ForeignItem(item) => match item.kind {\n-            ForeignItemKind::Fn(_, _, ref generics) => generics,\n+            ForeignItemKind::Fn(_, _, generics) => generics,\n             _ => return result,\n         },\n \n@@ -681,8 +681,8 @@ impl<'tcx> ItemCtxt<'tcx> {\n         ast_generics\n             .predicates\n             .iter()\n-            .filter_map(|wp| match *wp {\n-                hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n+            .filter_map(|wp| match wp {\n+                hir::WherePredicate::BoundPredicate(bp) => Some(bp),\n                 _ => None,\n             })\n             .flat_map(|bp| {"}, {"sha": "5e388a2f2babb0a0a17a2196316b198748fffb0a", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -379,7 +379,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             ForeignItemKind::Type => tcx.mk_foreign(def_id.to_def_id()),\n         },\n \n-        Node::Ctor(&ref def) | Node::Variant(Variant { data: ref def, .. }) => match *def {\n+        Node::Ctor(def) | Node::Variant(Variant { data: def, .. }) => match def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n                 tcx.type_of(tcx.hir().get_parent_item(hir_id))\n             }\n@@ -404,17 +404,17 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         Node::AnonConst(_) => {\n             let parent_node = tcx.hir().get_parent(hir_id);\n             match parent_node {\n-                Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })\n-                | Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+                Node::Ty(Ty { kind: TyKind::Array(_, constant), .. })\n+                | Node::Expr(Expr { kind: ExprKind::Repeat(_, constant), .. })\n                     if constant.hir_id() == hir_id =>\n                 {\n                     tcx.types.usize\n                 }\n-                Node::Ty(&Ty { kind: TyKind::Typeof(ref e), .. }) if e.hir_id == hir_id => {\n+                Node::Ty(Ty { kind: TyKind::Typeof(e), .. }) if e.hir_id == hir_id => {\n                     tcx.typeck(def_id).node_type(e.hir_id)\n                 }\n \n-                Node::Expr(&Expr { kind: ExprKind::ConstBlock(ref anon_const), .. })\n+                Node::Expr(Expr { kind: ExprKind::ConstBlock(anon_const), .. })\n                     if anon_const.hir_id == hir_id =>\n                 {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n@@ -434,18 +434,19 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     tcx.typeck(def_id).node_type(hir_id)\n                 }\n \n-                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+                Node::Variant(Variant { disr_expr: Some(e), .. }) if e.hir_id == hir_id => {\n                     tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n                 }\n \n                 Node::TypeBinding(\n-                    binding @ &TypeBinding {\n+                    TypeBinding {\n                         hir_id: binding_id,\n-                        kind: TypeBindingKind::Equality { term: Term::Const(ref e) },\n+                        kind: TypeBindingKind::Equality { term: Term::Const(e) },\n+                        ident,\n                         ..\n                     },\n                 ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(binding_id)\n+                    tcx.hir().get_parent(*binding_id)\n                     && e.hir_id == hir_id =>\n                 {\n                     let Some(trait_def_id) = trait_ref.trait_def_id() else {\n@@ -454,7 +455,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let assoc_items = tcx.associated_items(trait_def_id);\n                     let assoc_item = assoc_items.find_by_name_and_kind(\n                         tcx,\n-                        binding.ident,\n+                        *ident,\n                         ty::AssocKind::Const,\n                         def_id.to_def_id(),\n                     );\n@@ -470,9 +471,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n \n                 Node::TypeBinding(\n-                    binding @ &TypeBinding { hir_id: binding_id, gen_args, ref kind, .. },\n+                    TypeBinding { hir_id: binding_id, gen_args, kind, ident, .. },\n                 ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(binding_id)\n+                    tcx.hir().get_parent(*binding_id)\n                     && let Some((idx, _)) =\n                         gen_args.args.iter().enumerate().find(|(_, arg)| {\n                             if let GenericArg::Const(ct) = arg {\n@@ -488,7 +489,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     let assoc_items = tcx.associated_items(trait_def_id);\n                     let assoc_item = assoc_items.find_by_name_and_kind(\n                         tcx,\n-                        binding.ident,\n+                        *ident,\n                         match kind {\n                             // I think `<A: T>` type bindings requires that `A` is a type\n                             TypeBindingKind::Constraint { .. }"}, {"sha": "56cc1d8fadc00e7ac6e9611c18dd0f5bcdf3039a", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         match *t.kind() {\n             ty::Alias(ty::Projection, ..) if !self.include_nonconstraining => {\n                 // projections are not injective\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Continue(());\n             }\n             ty::Param(data) => {\n                 self.parameters.push(Parameter::from(data));\n@@ -76,7 +76,7 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         if let ty::ReEarlyBound(data) = *r {\n             self.parameters.push(Parameter::from(data));\n         }\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {"}, {"sha": "17dbb126bd1b0f357ac0f0204d8a6d70614cc0ba", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -128,7 +128,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n             },\n             hir::Node::Item(item) => match item.kind {\n                 hir::ItemKind::Static(ty, _, _) | hir::ItemKind::Const(ty, _) => vec![ty],\n-                hir::ItemKind::Impl(ref impl_) => match &impl_.of_trait {\n+                hir::ItemKind::Impl(impl_) => match &impl_.of_trait {\n                     Some(t) => t\n                         .path\n                         .segments"}, {"sha": "02548ae893f28682a16ed0d5593c3f6e642ab524", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -114,6 +114,7 @@ use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use std::iter;\n+use std::ops::Not;\n \n use astconv::AstConv;\n use bounds::Bounds;\n@@ -203,12 +204,8 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n-                if !generics.params.is_empty() {\n-                    Some(generics.span)\n-                } else {\n-                    None\n-                }\n+            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })) => {\n+                generics.params.is_empty().not().then(|| generics.span)\n             }\n             _ => {\n                 span_bug!(tcx.def_span(def_id), \"main has a non-function type\");\n@@ -222,7 +219,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n+            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })) => {\n                 Some(generics.where_clause_span)\n             }\n             _ => {\n@@ -244,7 +241,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n-            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(ref fn_sig, _, _), .. })) => {\n+            Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(fn_sig, _, _), .. })) => {\n                 Some(fn_sig.decl.output.span())\n             }\n             _ => {\n@@ -374,7 +371,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n     match start_t.kind() {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n-                if let hir::ItemKind::Fn(ref sig, ref generics, _) = it.kind {\n+                if let hir::ItemKind::Fn(sig, generics, _) = &it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n                         struct_span_err!("}, {"sha": "9459c5f54abbf7c0105f3666c1c347b39efb5964", "filename": "compiler/rustc_hir_analysis/src/outlives/utils.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -80,40 +80,32 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                             .or_insert(span);\n                     }\n \n-                    Component::Projection(proj_ty) => {\n-                        // This would arise from something like:\n+                    Component::Alias(alias_ty) => {\n+                        // This would either arise from something like:\n                         //\n                         // ```\n                         // struct Foo<'a, T: Iterator> {\n                         //    x:  &'a <T as Iterator>::Item\n                         // }\n                         // ```\n                         //\n-                        // Here we want to add an explicit `where <T as Iterator>::Item: 'a`.\n-                        let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.def_id, proj_ty.substs);\n-                        required_predicates\n-                            .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n-                            .or_insert(span);\n-                    }\n-\n-                    Component::Opaque(def_id, substs) => {\n-                        // This would arise from something like:\n+                        // or:\n                         //\n                         // ```rust\n                         // type Opaque<T> = impl Sized;\n                         // fn defining<T>() -> Opaque<T> {}\n                         // struct Ss<'a, T>(&'a Opaque<T>);\n                         // ```\n                         //\n-                        // Here we want to have an implied bound `Opaque<T>: 'a`\n-\n-                        let ty = tcx.mk_opaque(def_id, substs);\n+                        // Here we want to add an explicit `where <T as Iterator>::Item: 'a`\n+                        // or `Opaque<T>: 'a` depending on the alias kind.\n+                        let ty = alias_ty.to_ty(tcx);\n                         required_predicates\n                             .entry(ty::OutlivesPredicate(ty.into(), outlived_region))\n                             .or_insert(span);\n                     }\n \n-                    Component::EscapingProjection(_) => {\n+                    Component::EscapingAlias(_) => {\n                         // As above, but the projection involves\n                         // late-bound regions. Therefore, the WF\n                         // requirement is not checked in type definition"}, {"sha": "9133e6540d4450e07e96f9742c8115d8553e9722", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -727,8 +727,8 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         if let Some(parent_node) = self.tcx.hir().opt_parent_id(self.path_segment.hir_id)\n         && let Some(parent_node) = self.tcx.hir().find(parent_node)\n         && let hir::Node::Expr(expr) = parent_node {\n-            match expr.kind {\n-                hir::ExprKind::Path(ref qpath) => {\n+            match &expr.kind {\n+                hir::ExprKind::Path(qpath) => {\n                     self.suggest_moving_args_from_assoc_fn_to_trait_for_qualified_path(\n                         err,\n                         qpath,"}, {"sha": "079070be27983a8c72f5d04120ffff76e660ed81", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -92,7 +92,7 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n                         a.visit_with(self)?;\n                     }\n                 }\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             } else {\n                 substs.visit_with(self)\n             }"}, {"sha": "a17edb598ad5e5eb79d86072571bbc55fda8c2c3", "filename": "compiler/rustc_hir_analysis/src/variance/solve.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -5,8 +5,7 @@\n //! optimal solution to the constraints. The final variance for each\n //! inferred is then written into the `variance_map` in the tcx.\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::DefIdMap;\n use rustc_middle::ty;\n \n use super::constraints::*;\n@@ -28,8 +27,8 @@ pub fn solve_constraints<'tcx>(\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n \n     let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];\n-    for &(id, ref variances) in &terms_cx.lang_items {\n-        let InferredIndex(start) = terms_cx.inferred_starts[&id];\n+    for (id, variances) in &terms_cx.lang_items {\n+        let InferredIndex(start) = terms_cx.inferred_starts[id];\n         for (i, &variance) in variances.iter().enumerate() {\n             solutions[start + i] = variance;\n         }\n@@ -89,14 +88,12 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         }\n     }\n \n-    fn create_map(&self) -> FxHashMap<DefId, &'tcx [ty::Variance]> {\n+    fn create_map(&self) -> DefIdMap<&'tcx [ty::Variance]> {\n         let tcx = self.terms_cx.tcx;\n \n         let solutions = &self.solutions;\n-        self.terms_cx\n-            .inferred_starts\n-            .iter()\n-            .map(|(&def_id, &InferredIndex(start))| {\n+        DefIdMap::from(self.terms_cx.inferred_starts.items().map(\n+            |(&def_id, &InferredIndex(start))| {\n                 let generics = tcx.generics_of(def_id);\n                 let count = generics.count();\n \n@@ -115,8 +112,8 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 }\n \n                 (def_id.to_def_id(), &*variances)\n-            })\n-            .collect()\n+            },\n+        ))\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "5feeb92d3378251e9e551acf2a435c9c24134c62", "filename": "compiler/rustc_hir_analysis/src/variance/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,4 +1,3 @@\n-use rustc_errors::struct_span_err;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n@@ -8,8 +7,8 @@ pub fn test_variance(tcx: TyCtxt<'_>) {\n     for id in tcx.hir().items() {\n         if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_variance) {\n             let variances_of = tcx.variances_of(id.owner_id);\n-            struct_span_err!(tcx.sess, tcx.def_span(id.owner_id), E0208, \"{:?}\", variances_of)\n-                .emit();\n+\n+            tcx.sess.struct_span_err(tcx.def_span(id.owner_id), format!(\"{variances_of:?}\")).emit();\n         }\n     }\n }"}, {"sha": "b617821fbd6528bbf6feee0f9efb8ff867a34ae5", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -375,14 +375,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if self.tcx.has_attr(def_id, sym::rustc_evaluate_where_clauses) {\n                     let predicates = self.tcx.predicates_of(def_id);\n                     let predicates = predicates.instantiate(self.tcx, subst);\n-                    for (predicate, predicate_span) in\n-                        predicates.predicates.iter().zip(&predicates.spans)\n-                    {\n+                    for (predicate, predicate_span) in predicates {\n                         let obligation = Obligation::new(\n                             self.tcx,\n                             ObligationCause::dummy_with_span(callee_expr.span),\n                             self.param_env,\n-                            *predicate,\n+                            predicate,\n                         );\n                         let result = self.evaluate_obligation(&obligation);\n                         self.tcx\n@@ -391,7 +389,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 callee_expr.span,\n                                 &format!(\"evaluate({:?}) = {:?}\", predicate, result),\n                             )\n-                            .span_label(*predicate_span, \"predicate\")\n+                            .span_label(predicate_span, \"predicate\")\n                             .emit();\n                     }\n                 }"}, {"sha": "712f9b87aed0ad623b3bcd77be096c07cb5ce5b1", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 66, "deletions": 18, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -31,7 +31,10 @@\n use super::FnCtxt;\n \n use crate::type_error_struct;\n-use rustc_errors::{struct_span_err, Applicability, DelayDm, DiagnosticBuilder, ErrorGuaranteed};\n+use hir::ExprKind;\n+use rustc_errors::{\n+    struct_span_err, Applicability, DelayDm, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+};\n use rustc_hir as hir;\n use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::mir::Mutability;\n@@ -149,7 +152,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n #[derive(Copy, Clone)]\n pub enum CastError {\n-    ErrorGuaranteed,\n+    ErrorGuaranteed(ErrorGuaranteed),\n \n     CastToBool,\n     CastToChar,\n@@ -174,8 +177,8 @@ pub enum CastError {\n }\n \n impl From<ErrorGuaranteed> for CastError {\n-    fn from(_: ErrorGuaranteed) -> Self {\n-        CastError::ErrorGuaranteed\n+    fn from(err: ErrorGuaranteed) -> Self {\n+        CastError::ErrorGuaranteed(err)\n     }\n }\n \n@@ -223,33 +226,36 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n     fn report_cast_error(&self, fcx: &FnCtxt<'a, 'tcx>, e: CastError) {\n         match e {\n-            CastError::ErrorGuaranteed => {\n+            CastError::ErrorGuaranteed(_) => {\n                 // an error has already been reported\n             }\n             CastError::NeedDeref => {\n-                let error_span = self.span;\n                 let mut err = make_invalid_casting_error(\n                     fcx.tcx.sess,\n                     self.span,\n                     self.expr_ty,\n                     self.cast_ty,\n                     fcx,\n                 );\n-                let cast_ty = fcx.ty_to_string(self.cast_ty);\n-                err.span_label(\n-                    error_span,\n-                    format!(\"cannot cast `{}` as `{}`\", fcx.ty_to_string(self.expr_ty), cast_ty),\n-                );\n-                if let Ok(snippet) = fcx.sess().source_map().span_to_snippet(self.expr_span) {\n-                    err.span_suggestion(\n-                        self.expr_span,\n-                        \"dereference the expression\",\n-                        format!(\"*{}\", snippet),\n-                        Applicability::MaybeIncorrect,\n+\n+                if matches!(self.expr.kind, ExprKind::AddrOf(..)) {\n+                    // get just the borrow part of the expression\n+                    let span = self.expr_span.with_hi(self.expr.peel_borrows().span.lo());\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        \"remove the unneeded borrow\",\n+                        \"\",\n+                        Applicability::MachineApplicable,\n                     );\n                 } else {\n-                    err.span_help(self.expr_span, \"dereference the expression with `*`\");\n+                    err.span_suggestion_verbose(\n+                        self.expr_span.shrink_to_lo(),\n+                        \"dereference the expression\",\n+                        \"*\",\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n+\n                 err.emit();\n             }\n             CastError::NeedViaThinPtr | CastError::NeedViaPtr => {\n@@ -270,6 +276,9 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         }\n                     ));\n                 }\n+\n+                self.try_suggest_collection_to_bool(fcx, &mut err);\n+\n                 err.emit();\n             }\n             CastError::NeedViaInt => {\n@@ -517,6 +526,9 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 } else {\n                     err.span_label(self.span, \"invalid cast\");\n                 }\n+\n+                self.try_suggest_collection_to_bool(fcx, &mut err);\n+\n                 err.emit();\n             }\n             CastError::SizedUnsizedCast => {\n@@ -1080,4 +1092,40 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             },\n         );\n     }\n+\n+    /// Attempt to suggest using `.is_empty` when trying to cast from a\n+    /// collection type to a boolean.\n+    fn try_suggest_collection_to_bool(&self, fcx: &FnCtxt<'a, 'tcx>, err: &mut Diagnostic) {\n+        if self.cast_ty.is_bool() {\n+            let derefed = fcx\n+                .autoderef(self.expr_span, self.expr_ty)\n+                .silence_errors()\n+                .find(|t| matches!(t.0.kind(), ty::Str | ty::Slice(..)));\n+\n+            if let Some((deref_ty, _)) = derefed {\n+                // Give a note about what the expr derefs to.\n+                if deref_ty != self.expr_ty.peel_refs() {\n+                    err.span_note(\n+                        self.expr_span,\n+                        format!(\n+                            \"this expression `Deref`s to `{}` which implements `is_empty`\",\n+                            fcx.ty_to_string(deref_ty)\n+                        ),\n+                    );\n+                }\n+\n+                // Create a multipart suggestion: add `!` and `.is_empty()` in\n+                // place of the cast.\n+                let suggestion = vec![\n+                    (self.expr_span.shrink_to_lo(), \"!\".to_string()),\n+                    (self.span.with_lo(self.expr_span.hi()), \".is_empty()\".to_string()),\n+                ];\n+\n+                err.multipart_suggestion_verbose(format!(\n+                    \"consider using the `is_empty` method on `{}` to determine if it contains anything\",\n+                    fcx.ty_to_string(self.expr_ty),\n+                ),  suggestion, Applicability::MaybeIncorrect);\n+            }\n+        }\n+    }\n }"}, {"sha": "12a2abfa76a921d5402860d134f10c68ad8805ce", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -236,7 +236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                         if t == self.expected_ty {\n-                            ControlFlow::BREAK\n+                            ControlFlow::Break(())\n                         } else {\n                             t.super_visit_with(self)\n                         }"}, {"sha": "c9609e69439812477b27d84f3d037abe82167ea0", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -2140,8 +2140,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // FIXME(compiler-errors): This could be problematic if something has two\n                         // fn-like predicates with different args, but callable types really never\n                         // do that, so it's OK.\n-                        for (predicate, span) in\n-                            std::iter::zip(instantiated.predicates, instantiated.spans)\n+                        for (predicate, span) in instantiated\n                         {\n                             if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = predicate.kind().skip_binder()\n                                 && pred.self_ty().peel_refs() == callee_ty"}, {"sha": "b3dd3031db2a98d75780d00288364133be6041f4", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -304,8 +304,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n         let mut reinit = None;\n         match expr.kind {\n             ExprKind::Assign(lhs, rhs, _) => {\n-                self.visit_expr(lhs);\n                 self.visit_expr(rhs);\n+                self.visit_expr(lhs);\n \n                 reinit = Some(lhs);\n             }\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n                     self.drop_ranges.add_control_edge(self.expr_index, *target)\n                 }),\n \n-            ExprKind::Break(destination, ..) => {\n+            ExprKind::Break(destination, value) => {\n                 // destination either points to an expression or to a block. We use\n                 // find_target_expression_from_destination to use the last expression of the block\n                 // if destination points to a block.\n@@ -443,7 +443,11 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n                 // will refer to the end of the block due to the post order traversal.\n                 self.find_target_expression_from_destination(destination).map_or((), |target| {\n                     self.drop_ranges.add_control_edge_hir_id(self.expr_index, target)\n-                })\n+                });\n+\n+                if let Some(value) = value {\n+                    self.visit_expr(value);\n+                }\n             }\n \n             ExprKind::Call(f, args) => {\n@@ -465,6 +469,12 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n \n             ExprKind::AddrOf(..)\n             | ExprKind::Array(..)\n+            // FIXME(eholk): We probably need special handling for AssignOps. The ScopeTree builder\n+            // in region.rs runs both lhs then rhs and rhs then lhs and then sets all yields to be\n+            // the latest they show up in either traversal. With the older scope-based\n+            // approximation, this was fine, but it's probably not right now. What we probably want\n+            // to do instead is still run both orders, but consider anything that showed up as a\n+            // yield in either order.\n             | ExprKind::AssignOp(..)\n             | ExprKind::Binary(..)\n             | ExprKind::Block(..)\n@@ -502,6 +512,9 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n \n         // Increment expr_count here to match what InteriorVisitor expects.\n         self.expr_index = self.expr_index + 1;\n+\n+        // Save a node mapping to get better CFG visualization\n+        self.drop_ranges.add_node_mapping(pat.hir_id, self.expr_index);\n     }\n }\n \n@@ -521,7 +534,7 @@ impl DropRangesBuilder {\n                 }\n             });\n         }\n-        debug!(\"hir_id_map: {:?}\", tracked_value_map);\n+        debug!(\"hir_id_map: {:#?}\", tracked_value_map);\n         let num_values = tracked_value_map.len();\n         Self {\n             tracked_value_map,"}, {"sha": "e8d31be79d9c9fccff6d6722db6cadf044cbb7a8", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_visualize.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -2,6 +2,7 @@\n //! flow graph when needed for debugging.\n \n use rustc_graphviz as dot;\n+use rustc_hir::{Expr, ExprKind, Node};\n use rustc_middle::ty::TyCtxt;\n \n use super::{DropRangesBuilder, PostOrderId};\n@@ -80,10 +81,14 @@ impl<'a> dot::Labeller<'a> for DropRangesGraph<'_, '_> {\n                     .post_order_map\n                     .iter()\n                     .find(|(_hir_id, &post_order_id)| post_order_id == *n)\n-                    .map_or(\"<unknown>\".into(), |(hir_id, _)| self\n-                        .tcx\n-                        .hir()\n-                        .node_to_string(*hir_id))\n+                    .map_or(\"<unknown>\".into(), |(hir_id, _)| format!(\n+                        \"{}{}\",\n+                        self.tcx.hir().node_to_string(*hir_id),\n+                        match self.tcx.hir().find(*hir_id) {\n+                            Some(Node::Expr(Expr { kind: ExprKind::Yield(..), .. })) => \" (yield)\",\n+                            _ => \"\",\n+                        }\n+                    ))\n             )\n             .into(),\n         )"}, {"sha": "7af5260538568c0d873ad2767cdbb903e5a6517e", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -71,10 +71,8 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                                 yield_data.expr_and_pat_count, self.expr_count, source_span\n                             );\n \n-                            if self.fcx.sess().opts.unstable_opts.drop_tracking\n-                                && self\n-                                    .drop_ranges\n-                                    .is_dropped_at(hir_id, yield_data.expr_and_pat_count)\n+                            if self\n+                                .is_dropped_at_yield_location(hir_id, yield_data.expr_and_pat_count)\n                             {\n                                 debug!(\"value is dropped at yield point; not recording\");\n                                 return false;\n@@ -173,6 +171,18 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    /// If drop tracking is enabled, consult drop_ranges to see if a value is\n+    /// known to be dropped at a yield point and therefore can be omitted from\n+    /// the generator witness.\n+    fn is_dropped_at_yield_location(&self, value_hir_id: HirId, yield_location: usize) -> bool {\n+        // short-circuit if drop tracking is not enabled.\n+        if !self.fcx.sess().opts.unstable_opts.drop_tracking {\n+            return false;\n+        }\n+\n+        self.drop_ranges.is_dropped_at(value_hir_id, yield_location)\n+    }\n }\n \n pub fn resolve_interior<'a, 'tcx>("}, {"sha": "3c873024c924f3837c473312fb3c0395be8eeaa1", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -105,6 +105,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             err.note(&format!(\"source type: `{}` ({})\", from, skeleton_string(from, sk_from)))\n                 .note(&format!(\"target type: `{}` ({})\", to, skeleton_string(to, sk_to)));\n+            let mut should_delay_as_bug = false;\n+            if let Err(LayoutError::Unknown(bad_from)) = sk_from && bad_from.references_error() {\n+                should_delay_as_bug = true;\n+            }\n+            if let Err(LayoutError::Unknown(bad_to)) = sk_to && bad_to.references_error() {\n+                should_delay_as_bug = true;\n+            }\n+            if should_delay_as_bug {\n+                err.delay_as_bug();\n+            }\n         }\n         err.emit();\n     }"}, {"sha": "372ea30ebd08e4877df583a8672b7b94df1bf2ae", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -19,7 +19,6 @@ use rustc_middle::ty::{InternalSubsts, UserSubsts, UserType};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits;\n \n-use std::iter;\n use std::ops::Deref;\n \n struct ConfirmContext<'a, 'tcx> {\n@@ -101,7 +100,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let filler_substs = rcvr_substs\n             .extend_to(self.tcx, pick.item.def_id, |def, _| self.tcx.mk_param_from_def(def));\n         let illegal_sized_bound = self.predicates_require_illegal_sized_bound(\n-            &self.tcx.predicates_of(pick.item.def_id).instantiate(self.tcx, filler_substs),\n+            self.tcx.predicates_of(pick.item.def_id).instantiate(self.tcx, filler_substs),\n         );\n \n         // Unify the (adjusted) self type with what the method expects.\n@@ -565,7 +564,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n     fn predicates_require_illegal_sized_bound(\n         &self,\n-        predicates: &ty::InstantiatedPredicates<'tcx>,\n+        predicates: ty::InstantiatedPredicates<'tcx>,\n     ) -> Option<Span> {\n         let sized_def_id = self.tcx.lang_items().sized_trait()?;\n \n@@ -575,10 +574,11 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n                     if trait_pred.def_id() == sized_def_id =>\n                 {\n-                    let span = iter::zip(&predicates.predicates, &predicates.spans)\n+                    let span = predicates\n+                        .iter()\n                         .find_map(\n                             |(p, span)| {\n-                                if *p == obligation.predicate { Some(*span) } else { None }\n+                                if p == obligation.predicate { Some(span) } else { None }\n                             },\n                         )\n                         .unwrap_or(rustc_span::DUMMY_SP);"}, {"sha": "a2481431363ddb55088a46b1604b265c3d089686", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             probe_cx.assemble_inherent_candidates();\n             match scope {\n                 ProbeScope::TraitsInScope => {\n-                    probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)\n+                    probe_cx.assemble_extension_candidates_for_traits_in_scope()\n                 }\n                 ProbeScope::AllTraits => probe_cx.assemble_extension_candidates_for_all_traits(),\n             };\n@@ -889,9 +889,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn assemble_extension_candidates_for_traits_in_scope(&mut self, expr_hir_id: hir::HirId) {\n+    fn assemble_extension_candidates_for_traits_in_scope(&mut self) {\n         let mut duplicates = FxHashSet::default();\n-        let opt_applicable_traits = self.tcx.in_scope_traits(expr_hir_id);\n+        let opt_applicable_traits = self.tcx.in_scope_traits(self.scope_expr_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits.iter() {\n                 let trait_did = trait_candidate.def_id;"}, {"sha": "250f4cd3f65fbf4c857e3b3366fa56148f699f54", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 55, "deletions": 37, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -448,8 +448,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (id, origin) in fcx_typeck_results.closure_kind_origins().iter() {\n-            let hir_id = hir::HirId { owner: common_hir_owner, local_id: *id };\n+        let fcx_closure_kind_origins =\n+            fcx_typeck_results.closure_kind_origins().items_in_stable_order();\n+\n+        for (local_id, origin) in fcx_closure_kind_origins {\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let place_span = origin.0;\n             let place = self.resolve(origin.1.clone(), &place_span);\n             self.typeck_results.closure_kind_origins_mut().insert(hir_id, (place_span, place));\n@@ -458,11 +461,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_coercion_casts(&mut self) {\n         let fcx_typeck_results = self.fcx.typeck_results.borrow();\n-        let fcx_coercion_casts = fcx_typeck_results.coercion_casts();\n+\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n \n+        let fcx_coercion_casts = fcx_typeck_results.coercion_casts().to_sorted_stable_ord();\n         for local_id in fcx_coercion_casts {\n-            self.typeck_results.set_coercion_cast(*local_id);\n+            self.typeck_results.set_coercion_cast(local_id);\n         }\n     }\n \n@@ -471,22 +475,15 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        let mut errors_buffer = Vec::new();\n-        for (&local_id, c_ty) in fcx_typeck_results.user_provided_types().iter() {\n-            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n-\n-            if cfg!(debug_assertions) && c_ty.needs_infer() {\n-                span_bug!(\n-                    hir_id.to_span(self.fcx.tcx),\n-                    \"writeback: `{:?}` has inference variables\",\n-                    c_ty\n-                );\n-            };\n+        if self.rustc_dump_user_substs {\n+            let sorted_user_provided_types =\n+                fcx_typeck_results.user_provided_types().items_in_stable_order();\n \n-            self.typeck_results.user_provided_types_mut().insert(hir_id, *c_ty);\n+            let mut errors_buffer = Vec::new();\n+            for (local_id, c_ty) in sorted_user_provided_types {\n+                let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n-            if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n-                if self.rustc_dump_user_substs {\n+                if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n                     // This is a unit-testing mechanism.\n                     let span = self.tcx().hir().span(hir_id);\n                     // We need to buffer the errors in order to guarantee a consistent\n@@ -498,31 +495,49 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     err.buffer(&mut errors_buffer);\n                 }\n             }\n-        }\n \n-        if !errors_buffer.is_empty() {\n-            errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n-            for mut diag in errors_buffer {\n-                self.tcx().sess.diagnostic().emit_diagnostic(&mut diag);\n+            if !errors_buffer.is_empty() {\n+                errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n+                for mut diag in errors_buffer {\n+                    self.tcx().sess.diagnostic().emit_diagnostic(&mut diag);\n+                }\n             }\n         }\n+\n+        self.typeck_results.user_provided_types_mut().extend(\n+            fcx_typeck_results.user_provided_types().items().map(|(local_id, c_ty)| {\n+                let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n+\n+                if cfg!(debug_assertions) && c_ty.needs_infer() {\n+                    span_bug!(\n+                        hir_id.to_span(self.fcx.tcx),\n+                        \"writeback: `{:?}` has inference variables\",\n+                        c_ty\n+                    );\n+                };\n+\n+                (hir_id, *c_ty)\n+            }),\n+        );\n     }\n \n     fn visit_user_provided_sigs(&mut self) {\n         let fcx_typeck_results = self.fcx.typeck_results.borrow();\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n \n-        for (&def_id, c_sig) in fcx_typeck_results.user_provided_sigs.iter() {\n-            if cfg!(debug_assertions) && c_sig.needs_infer() {\n-                span_bug!(\n-                    self.fcx.tcx.def_span(def_id),\n-                    \"writeback: `{:?}` has inference variables\",\n-                    c_sig\n-                );\n-            };\n-\n-            self.typeck_results.user_provided_sigs.insert(def_id, *c_sig);\n-        }\n+        self.typeck_results.user_provided_sigs.extend(\n+            fcx_typeck_results.user_provided_sigs.items().map(|(&def_id, c_sig)| {\n+                if cfg!(debug_assertions) && c_sig.needs_infer() {\n+                    span_bug!(\n+                        self.fcx.tcx.def_span(def_id),\n+                        \"writeback: `{:?}` has inference variables\",\n+                        c_sig\n+                    );\n+                };\n+\n+                (def_id, *c_sig)\n+            }),\n+        );\n     }\n \n     fn visit_generator_interior_types(&mut self) {\n@@ -564,7 +579,6 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 opaque_type_key,\n                 self.fcx.infcx.tcx,\n                 true,\n-                decl.origin,\n             );\n \n             self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id, hidden_type);\n@@ -642,7 +656,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&local_id, &fn_sig) in fcx_typeck_results.liberated_fn_sigs().iter() {\n+        let fcx_liberated_fn_sigs = fcx_typeck_results.liberated_fn_sigs().items_in_stable_order();\n+\n+        for (local_id, &fn_sig) in fcx_liberated_fn_sigs {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n             self.typeck_results.liberated_fn_sigs_mut().insert(hir_id, fn_sig);\n@@ -654,7 +670,9 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&local_id, ftys) in fcx_typeck_results.fru_field_types().iter() {\n+        let fcx_fru_field_types = fcx_typeck_results.fru_field_types().items_in_stable_order();\n+\n+        for (local_id, ftys) in fcx_fru_field_types {\n             let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let ftys = self.resolve(ftys.clone(), &hir_id);\n             self.typeck_results.fru_field_types_mut().insert(hir_id, ftys);"}, {"sha": "68cdc6d7711d4eb840bb49ea3faef8a6c0f121f5", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -207,7 +207,12 @@ impl<I: Idx, T> IndexVec<I, T> {\n         &'a mut self,\n         range: R,\n     ) -> impl Iterator<Item = (I, T)> + 'a {\n-        self.raw.drain(range).enumerate().map(|(n, t)| (I::new(n), t))\n+        let begin = match range.start_bound() {\n+            std::ops::Bound::Included(i) => *i,\n+            std::ops::Bound::Excluded(i) => i.checked_add(1).unwrap(),\n+            std::ops::Bound::Unbounded => 0,\n+        };\n+        self.raw.drain(range).enumerate().map(move |(n, t)| (I::new(begin + n), t))\n     }\n \n     #[inline]"}, {"sha": "8bf3a160abbb4aaf2f064fef5967b0f3b7b83e8b", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -927,6 +927,8 @@ pub struct ButNeedsToSatisfy {\n     #[subdiagnostic]\n     pub req_introduces_loc: Option<ReqIntroducedLocations>,\n \n+    pub has_param_name: bool,\n+    pub param_name: String,\n     pub spans_empty: bool,\n     pub has_lifetime: bool,\n     pub lifetime: String,"}, {"sha": "28fd03b878b2b69b2da3ef46b59a09823f1ea5f3", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -2272,10 +2272,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n-            GenericKind::Projection(ref p) => format!(\"the associated type `{}`\", p),\n-            GenericKind::Opaque(def_id, substs) => {\n-                format!(\"the opaque type `{}`\", self.tcx.def_path_str_with_substs(def_id, substs))\n-            }\n+            GenericKind::Alias(ref p) => match p.kind(self.tcx) {\n+                ty::AliasKind::Projection => format!(\"the associated type `{}`\", p),\n+                ty::AliasKind::Opaque => format!(\"the opaque type `{}`\", p),\n+            },\n         };\n \n         if let Some(SubregionOrigin::CompareImplItemObligation {"}, {"sha": "6a463583dfb0ff42573d3cbf0c308ef67fe434a1", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -98,6 +98,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let sp = var_origin.span();\n         let return_sp = sub_origin.span();\n         let param = self.find_param_with_region(*sup_r, *sub_r)?;\n+        let simple_ident = param.param.pat.simple_ident();\n         let lifetime_name = if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n \n         let (mention_influencer, influencer_point) =\n@@ -187,7 +188,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             req_introduces_loc: subdiag,\n \n             has_lifetime: sup_r.has_name(),\n-            lifetime: sup_r.to_string(),\n+            lifetime: lifetime_name.clone(),\n+            has_param_name: simple_ident.is_some(),\n+            param_name: simple_ident.map(|x| x.to_string()).unwrap_or_default(),\n             spans_empty,\n             bound,\n         };\n@@ -543,7 +546,7 @@ impl<'tcx> TypeVisitor<'tcx> for TraitObjectVisitor {\n                 if let Some(def_id) = preds.principal_def_id() {\n                     self.0.insert(def_id);\n                 }\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             }\n             _ => t.super_visit_with(self),\n         }"}, {"sha": "b18cbd404d47f8c03895ef5db759d18f4f722077", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -330,9 +330,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n         let Ok(trait_predicates) = self\n             .tcx\n-            .bound_explicit_predicates_of(trait_item_def_id)\n-            .map_bound(|p| p.predicates)\n-            .subst_iter_copied(self.tcx, trait_item_substs)\n+            .explicit_predicates_of(trait_item_def_id)\n+            .instantiate_own(self.tcx, trait_item_substs)\n             .map(|(pred, _)| {\n                 if pred.is_suggestable(self.tcx, false) {\n                     Ok(pred.to_string())"}, {"sha": "ce8aec8044bae63422a1fba1131dcd8b6aaaf746", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -251,7 +251,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     VarValue::Empty(a_universe) => {\n                         let b_data = var_values.value_mut(b_vid);\n \n-                        let changed = (|| match *b_data {\n+                        let changed = match *b_data {\n                             VarValue::Empty(b_universe) => {\n                                 // Empty regions are ordered according to the universe\n                                 // they are associated with.\n@@ -280,20 +280,20 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                                 };\n \n                                 if lub == cur_region {\n-                                    return false;\n+                                    false\n+                                } else {\n+                                    debug!(\n+                                        \"Expanding value of {:?} from {:?} to {:?}\",\n+                                        b_vid, cur_region, lub\n+                                    );\n+\n+                                    *b_data = VarValue::Value(lub);\n+                                    true\n                                 }\n-\n-                                debug!(\n-                                    \"Expanding value of {:?} from {:?} to {:?}\",\n-                                    b_vid, cur_region, lub\n-                                );\n-\n-                                *b_data = VarValue::Value(lub);\n-                                true\n                             }\n \n                             VarValue::ErrorValue => false,\n-                        })();\n+                        };\n \n                         if changed {\n                             changes.push(b_vid);"}, {"sha": "f235cb5ab4503429be84df40c85338cf0f1b4b69", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -849,7 +849,7 @@ impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n         t.super_visit_with(self);\n         self.target_index.shift_out(1);\n \n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n@@ -863,7 +863,7 @@ impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n             _ => {}\n         }\n \n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }\n "}, {"sha": "c54c66eab27998cdf0616e36d25404fdc417a143", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -440,24 +440,24 @@ where\n         t: &ty::Binder<'tcx, T>,\n     ) -> ControlFlow<Self::BreakTy> {\n         t.super_visit_with(self);\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *r {\n             // ignore bound regions, keep visiting\n-            ty::ReLateBound(_, _) => ControlFlow::CONTINUE,\n+            ty::ReLateBound(_, _) => ControlFlow::Continue(()),\n             _ => {\n                 (self.op)(r);\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             }\n         }\n     }\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         // We're only interested in types involving regions\n         if !ty.flags().intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n-            return ControlFlow::CONTINUE;\n+            return ControlFlow::Continue(());\n         }\n \n         match ty.kind() {\n@@ -479,7 +479,7 @@ where\n             }\n \n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, ref substs, .. }) => {\n-                // Skip lifetime paramters that are not captures.\n+                // Skip lifetime parameters that are not captures.\n                 let variances = self.tcx.variances_of(*def_id);\n \n                 for (v, s) in std::iter::zip(variances, substs.iter()) {\n@@ -492,7 +492,7 @@ where\n             ty::Alias(ty::Projection, proj)\n                 if self.tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n-                // Skip lifetime paramters that are not captures.\n+                // Skip lifetime parameters that are not captures.\n                 let variances = self.tcx.variances_of(proj.def_id);\n \n                 for (v, s) in std::iter::zip(variances, proj.substs.iter()) {\n@@ -507,7 +507,7 @@ where\n             }\n         }\n \n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }\n "}, {"sha": "3d86279b03cc621f6ba372c973b0c8b70ea8f013", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -3,9 +3,8 @@\n // RFC for reference.\n \n use rustc_data_structures::sso::SsoHashSet;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, SubstsRef, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n use smallvec::{smallvec, SmallVec};\n \n #[derive(Debug)]\n@@ -23,7 +22,7 @@ pub enum Component<'tcx> {\n     // is not in a position to judge which is the best technique, so\n     // we just product the projection as a component and leave it to\n     // the consumer to decide (but see `EscapingProjection` below).\n-    Projection(ty::AliasTy<'tcx>),\n+    Alias(ty::AliasTy<'tcx>),\n \n     // In the case where a projection has escaping regions -- meaning\n     // regions bound within the type itself -- we always use\n@@ -45,9 +44,7 @@ pub enum Component<'tcx> {\n     // projection, so that implied bounds code can avoid relying on\n     // them. This gives us room to improve the regionck reasoning in\n     // the future without breaking backwards compat.\n-    EscapingProjection(Vec<Component<'tcx>>),\n-\n-    Opaque(DefId, SubstsRef<'tcx>),\n+    EscapingAlias(Vec<Component<'tcx>>),\n }\n \n /// Push onto `out` all the things that must outlive `'a` for the condition\n@@ -123,17 +120,6 @@ fn compute_components<'tcx>(\n                 out.push(Component::Param(p));\n             }\n \n-            // Ignore lifetimes found in opaque types. Opaque types can\n-            // have lifetimes in their substs which their hidden type doesn't\n-            // actually use. If we inferred that an opaque type is outlived by\n-            // its parameter lifetimes, then we could prove that any lifetime\n-            // outlives any other lifetime, which is unsound.\n-            // See https://github.com/rust-lang/rust/issues/84305 for\n-            // more details.\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                out.push(Component::Opaque(def_id, substs));\n-            },\n-\n             // For projections, we prefer to generate an obligation like\n             // `<P0 as Trait<P1...Pn>>::Foo: 'a`, because this gives the\n             // regionck more ways to prove that it holds. However,\n@@ -142,23 +128,23 @@ fn compute_components<'tcx>(\n             // trait-ref. Therefore, if we see any higher-ranked regions,\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n-            ty::Alias(ty::Projection, ref data) => {\n-                if !data.has_escaping_bound_vars() {\n+            ty::Alias(_, alias_ty) => {\n+                if !alias_ty.has_escaping_bound_vars() {\n                     // best case: no escaping regions, so push the\n                     // projection and skip the subtree (thus generating no\n                     // constraints for Pi). This defers the choice between\n                     // the rules OutlivesProjectionEnv,\n                     // OutlivesProjectionTraitDef, and\n                     // OutlivesProjectionComponents to regionck.\n-                    out.push(Component::Projection(*data));\n+                    out.push(Component::Alias(alias_ty));\n                 } else {\n                     // fallback case: hard code\n                     // OutlivesProjectionComponents. Continue walking\n                     // through and constrain Pi.\n                     let mut subcomponents = smallvec![];\n                     let mut subvisited = SsoHashSet::new();\n                     compute_components_recursive(tcx, ty.into(), &mut subcomponents, &mut subvisited);\n-                    out.push(Component::EscapingProjection(subcomponents.into_iter().collect()));\n+                    out.push(Component::EscapingAlias(subcomponents.into_iter().collect()));\n                 }\n             }\n "}, {"sha": "24e3c34dd94fc40d28b22d2ea7675f62b7618144", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -138,13 +138,9 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Param(param_b), r_a));\n                 }\n-                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n+                OutlivesBound::RegionSubAlias(r_a, alias_b) => {\n                     self.region_bound_pairs\n-                        .insert(ty::OutlivesPredicate(GenericKind::Projection(projection_b), r_a));\n-                }\n-                OutlivesBound::RegionSubOpaque(r_a, def_id, substs) => {\n-                    self.region_bound_pairs\n-                        .insert(ty::OutlivesPredicate(GenericKind::Opaque(def_id, substs), r_a));\n+                        .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {\n                     if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {"}, {"sha": "0194549a8868d3c5c3506a7ddd839715fca57bfe", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 19, "deletions": 84, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -67,7 +67,6 @@ use crate::infer::{\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitable};\n@@ -266,13 +265,8 @@ where\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, *param_ty);\n                 }\n-                Component::Opaque(def_id, substs) => {\n-                    self.opaque_must_outlive(*def_id, substs, origin, region)\n-                }\n-                Component::Projection(projection_ty) => {\n-                    self.projection_must_outlive(origin, region, *projection_ty);\n-                }\n-                Component::EscapingProjection(subcomponents) => {\n+                Component::Alias(alias_ty) => self.alias_ty_must_outlive(origin, region, *alias_ty),\n+                Component::EscapingAlias(subcomponents) => {\n                     self.components_must_outlive(origin, &subcomponents, region, category);\n                 }\n                 Component::UnresolvedInferenceVariable(v) => {\n@@ -288,80 +282,26 @@ where\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn param_ty_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         param_ty: ty::ParamTy,\n     ) {\n-        debug!(\n-            \"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n-            region, param_ty, origin\n-        );\n-\n-        let generic = GenericKind::Param(param_ty);\n         let verify_bound = self.verify_bound.param_bound(param_ty);\n-        self.delegate.push_verify(origin, generic, region, verify_bound);\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn opaque_must_outlive(\n-        &mut self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) {\n-        self.generic_must_outlive(\n-            origin,\n-            region,\n-            GenericKind::Opaque(def_id, substs),\n-            def_id,\n-            substs,\n-            true,\n-            |ty| match *ty.kind() {\n-                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => (def_id, substs),\n-                _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n-            },\n-        );\n+        self.delegate.push_verify(origin, GenericKind::Param(param_ty), region, verify_bound);\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn projection_must_outlive(\n+    fn alias_ty_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n-        projection_ty: ty::AliasTy<'tcx>,\n-    ) {\n-        self.generic_must_outlive(\n-            origin,\n-            region,\n-            GenericKind::Projection(projection_ty),\n-            projection_ty.def_id,\n-            projection_ty.substs,\n-            false,\n-            |ty| match ty.kind() {\n-                ty::Alias(ty::Projection, projection_ty) => {\n-                    (projection_ty.def_id, projection_ty.substs)\n-                }\n-                _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n-            },\n-        );\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self, filter))]\n-    fn generic_must_outlive(\n-        &mut self,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        region: ty::Region<'tcx>,\n-        generic: GenericKind<'tcx>,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n-        is_opaque: bool,\n-        filter: impl Fn(Ty<'tcx>) -> (DefId, SubstsRef<'tcx>),\n+        alias_ty: ty::AliasTy<'tcx>,\n     ) {\n         // An optimization for a common case with opaque types.\n-        if substs.is_empty() {\n+        if alias_ty.substs.is_empty() {\n             return;\n         }\n \n@@ -383,14 +323,14 @@ where\n         // These are guaranteed to apply, no matter the inference\n         // results.\n         let trait_bounds: Vec<_> =\n-            self.verify_bound.declared_region_bounds(def_id, substs).collect();\n+            self.verify_bound.declared_bounds_from_definition(alias_ty).collect();\n \n         debug!(?trait_bounds);\n \n         // Compute the bounds we can derive from the environment. This\n         // is an \"approximate\" match -- in some cases, these bounds\n         // may not apply.\n-        let mut approx_env_bounds = self.verify_bound.approx_declared_bounds_from_env(generic);\n+        let mut approx_env_bounds = self.verify_bound.approx_declared_bounds_from_env(alias_ty);\n         debug!(?approx_env_bounds);\n \n         // Remove outlives bounds that we get from the environment but\n@@ -405,8 +345,8 @@ where\n             // If the declaration is `trait Trait<'b> { type Item: 'b; }`, then `projection_declared_bounds_from_trait`\n             // will be invoked with `['b => ^1]` and so we will get `^1` returned.\n             let bound = bound_outlives.skip_binder();\n-            let (def_id, substs) = filter(bound.0);\n-            self.verify_bound.declared_region_bounds(def_id, substs).all(|r| r != bound.1)\n+            let ty::Alias(_, alias_ty) = bound.0.kind() else { bug!(\"expected AliasTy\") };\n+            self.verify_bound.declared_bounds_from_definition(*alias_ty).all(|r| r != bound.1)\n         });\n \n         // If declared bounds list is empty, the only applicable rule is\n@@ -423,12 +363,12 @@ where\n         // the problem is to add `T: 'r`, which isn't true. So, if there are no\n         // inference variables, we use a verify constraint instead of adding\n         // edges, which winds up enforcing the same condition.\n-        let needs_infer = substs.needs_infer();\n-        if approx_env_bounds.is_empty() && trait_bounds.is_empty() && (needs_infer || is_opaque) {\n+        if approx_env_bounds.is_empty()\n+            && trait_bounds.is_empty()\n+            && (alias_ty.needs_infer() || alias_ty.kind(self.tcx) == ty::Opaque)\n+        {\n             debug!(\"no declared bounds\");\n-\n-            self.substs_must_outlive(substs, origin, region);\n-\n+            self.substs_must_outlive(alias_ty.substs, origin, region);\n             return;\n         }\n \n@@ -469,14 +409,9 @@ where\n         // projection outlive; in some cases, this may add insufficient\n         // edges into the inference graph, leading to inference failures\n         // even though a satisfactory solution exists.\n-        let verify_bound = self.verify_bound.projection_opaque_bounds(\n-            generic,\n-            def_id,\n-            substs,\n-            &mut Default::default(),\n-        );\n-        debug!(\"projection_must_outlive: pushing {:?}\", verify_bound);\n-        self.delegate.push_verify(origin, generic, region, verify_bound);\n+        let verify_bound = self.verify_bound.alias_bound(alias_ty, &mut Default::default());\n+        debug!(\"alias_must_outlive: pushing {:?}\", verify_bound);\n+        self.delegate.push_verify(origin, GenericKind::Alias(alias_ty), region, verify_bound);\n     }\n \n     fn substs_must_outlive("}, {"sha": "94de9bc2d02283be28c98c6c576ff4f5c1499027", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 25, "deletions": 43, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,11 +1,10 @@\n use crate::infer::outlives::components::{compute_components_recursive, Component};\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::region_constraints::VerifyIfEq;\n-use crate::infer::{GenericKind, VerifyBound};\n+use crate::infer::VerifyBound;\n use rustc_data_structures::sso::SsoHashSet;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::ty::GenericArg;\n-use rustc_middle::ty::{self, OutlivesPredicate, SubstsRef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OutlivesPredicate, Ty, TyCtxt};\n \n use smallvec::smallvec;\n \n@@ -94,29 +93,26 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// this list.\n     pub fn approx_declared_bounds_from_env(\n         &self,\n-        generic: GenericKind<'tcx>,\n+        alias_ty: ty::AliasTy<'tcx>,\n     ) -> Vec<ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>> {\n-        let projection_ty = generic.to_ty(self.tcx);\n-        let erased_projection_ty = self.tcx.erase_regions(projection_ty);\n-        self.declared_generic_bounds_from_env_for_erased_ty(erased_projection_ty)\n+        let erased_alias_ty = self.tcx.erase_regions(alias_ty.to_ty(self.tcx));\n+        self.declared_generic_bounds_from_env_for_erased_ty(erased_alias_ty)\n     }\n \n     #[instrument(level = \"debug\", skip(self, visited))]\n-    pub fn projection_opaque_bounds(\n+    pub fn alias_bound(\n         &self,\n-        generic: GenericKind<'tcx>,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        alias_ty: ty::AliasTy<'tcx>,\n         visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> VerifyBound<'tcx> {\n-        let generic_ty = generic.to_ty(self.tcx);\n+        let alias_ty_as_ty = alias_ty.to_ty(self.tcx);\n \n         // Search the env for where clauses like `P: 'a`.\n-        let projection_opaque_bounds = self\n-            .approx_declared_bounds_from_env(generic)\n+        let env_bounds = self\n+            .approx_declared_bounds_from_env(alias_ty)\n             .into_iter()\n             .map(|binder| {\n-                if let Some(ty::OutlivesPredicate(ty, r)) = binder.no_bound_vars() && ty == generic_ty {\n+                if let Some(ty::OutlivesPredicate(ty, r)) = binder.no_bound_vars() && ty == alias_ty_as_ty {\n                     // Micro-optimize if this is an exact match (this\n                     // occurs often when there are no region variables\n                     // involved).\n@@ -126,19 +122,19 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n                     VerifyBound::IfEq(verify_if_eq_b)\n                 }\n             });\n-        // Extend with bounds that we can find from the trait.\n-        let trait_bounds =\n-            self.declared_region_bounds(def_id, substs).map(|r| VerifyBound::OutlivedBy(r));\n+\n+        // Extend with bounds that we can find from the definition.\n+        let definition_bounds =\n+            self.declared_bounds_from_definition(alias_ty).map(|r| VerifyBound::OutlivedBy(r));\n \n         // see the extensive comment in projection_must_outlive\n         let recursive_bound = {\n             let mut components = smallvec![];\n-            compute_components_recursive(self.tcx, generic_ty.into(), &mut components, visited);\n+            compute_components_recursive(self.tcx, alias_ty_as_ty.into(), &mut components, visited);\n             self.bound_from_components(&components, visited)\n         };\n \n-        VerifyBound::AnyBound(projection_opaque_bounds.chain(trait_bounds).collect())\n-            .or(recursive_bound)\n+        VerifyBound::AnyBound(env_bounds.chain(definition_bounds).collect()).or(recursive_bound)\n     }\n \n     fn bound_from_components(\n@@ -149,10 +145,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         let mut bounds = components\n             .iter()\n             .map(|component| self.bound_from_single_component(component, visited))\n-            .filter(|bound| {\n-                // Remove bounds that must hold, since they are not interesting.\n-                !bound.must_hold()\n-            });\n+            // Remove bounds that must hold, since they are not interesting.\n+            .filter(|bound| !bound.must_hold());\n \n         match (bounds.next(), bounds.next()) {\n             (Some(first), None) => first,\n@@ -170,19 +164,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         match *component {\n             Component::Region(lt) => VerifyBound::OutlivedBy(lt),\n             Component::Param(param_ty) => self.param_bound(param_ty),\n-            Component::Opaque(did, substs) => self.projection_opaque_bounds(\n-                GenericKind::Opaque(did, substs),\n-                did,\n-                substs,\n-                visited,\n-            ),\n-            Component::Projection(projection_ty) => self.projection_opaque_bounds(\n-                GenericKind::Projection(projection_ty),\n-                projection_ty.def_id,\n-                projection_ty.substs,\n-                visited,\n-            ),\n-            Component::EscapingProjection(ref components) => {\n+            Component::Alias(alias_ty) => self.alias_bound(alias_ty, visited),\n+            Component::EscapingAlias(ref components) => {\n                 self.bound_from_components(components, visited)\n             }\n             Component::UnresolvedInferenceVariable(v) => {\n@@ -298,16 +281,15 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     ///\n     /// This is for simplicity, and because we are not really smart\n     /// enough to cope with such bounds anywhere.\n-    pub fn declared_region_bounds(\n+    pub fn declared_bounds_from_definition(\n         &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n+        alias_ty: ty::AliasTy<'tcx>,\n     ) -> impl Iterator<Item = ty::Region<'tcx>> {\n         let tcx = self.tcx;\n-        let bounds = tcx.bound_item_bounds(def_id);\n+        let bounds = tcx.item_bounds(alias_ty.def_id);\n         trace!(\"{:#?}\", bounds.0);\n         bounds\n-            .subst_iter(tcx, substs)\n+            .subst_iter(tcx, alias_ty.substs)\n             .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n             .map(|OutlivesPredicate(_, r)| r)"}, {"sha": "0428481b7ff0282fff2ba59b311733e25c1fbd39", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -12,10 +12,8 @@ use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify as ut;\n-use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::infer::unify_key::{RegionVidKey, UnifiedRegion};\n-use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ReStatic;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ReLateBound, ReVar};\n@@ -169,8 +167,7 @@ pub struct Verify<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TypeFoldable, TypeVisitable)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n-    Projection(ty::AliasTy<'tcx>),\n-    Opaque(DefId, SubstsRef<'tcx>),\n+    Alias(ty::AliasTy<'tcx>),\n }\n \n /// Describes the things that some `GenericKind` value `G` is known to\n@@ -749,10 +746,7 @@ impl<'tcx> fmt::Debug for GenericKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             GenericKind::Param(ref p) => write!(f, \"{:?}\", p),\n-            GenericKind::Projection(ref p) => write!(f, \"{:?}\", p),\n-            GenericKind::Opaque(def_id, substs) => ty::tls::with(|tcx| {\n-                write!(f, \"{}\", tcx.def_path_str_with_substs(def_id, tcx.lift(substs).unwrap()))\n-            }),\n+            GenericKind::Alias(ref p) => write!(f, \"{:?}\", p),\n         }\n     }\n }\n@@ -761,10 +755,7 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             GenericKind::Param(ref p) => write!(f, \"{}\", p),\n-            GenericKind::Projection(ref p) => write!(f, \"{}\", p),\n-            GenericKind::Opaque(def_id, substs) => ty::tls::with(|tcx| {\n-                write!(f, \"{}\", tcx.def_path_str_with_substs(def_id, tcx.lift(substs).unwrap()))\n-            }),\n+            GenericKind::Alias(ref p) => write!(f, \"{}\", p),\n         }\n     }\n }\n@@ -773,8 +764,7 @@ impl<'tcx> GenericKind<'tcx> {\n     pub fn to_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n-            GenericKind::Projection(ref p) => tcx.mk_projection(p.def_id, p.substs),\n-            GenericKind::Opaque(def_id, substs) => tcx.mk_opaque(def_id, substs),\n+            GenericKind::Alias(ref p) => p.to_ty(tcx),\n         }\n     }\n }"}, {"sha": "65b90aa3d79d3e285365339e8ec6812c000e09b6", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeOrConstFinder<'a, 'tcx> {\n         } else if !t.has_non_region_infer() {\n             // All const/type variables in inference types must already be resolved,\n             // no need to visit the contents.\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         } else {\n             // Otherwise, keep visiting.\n             t.super_visit_with(self)\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeOrConstFinder<'a, 'tcx> {\n         } else if !ct.has_non_region_infer() {\n             // All const/type variables in inference types must already be resolved,\n             // no need to visit the contents.\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         } else {\n             // Otherwise, keep visiting.\n             ct.super_visit_with(self)"}, {"sha": "cd5bde2a791309c6c0f6d5aa6d73a55e412e0e36", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -261,23 +261,15 @@ impl<'tcx> Elaborator<'tcx> {\n \n                             Component::UnresolvedInferenceVariable(_) => None,\n \n-                            Component::Opaque(def_id, substs) => {\n-                                let ty = tcx.mk_opaque(def_id, substs);\n-                                Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n-                                    ty::OutlivesPredicate(ty, r_min),\n-                                )))\n-                            }\n-\n-                            Component::Projection(projection) => {\n+                            Component::Alias(alias_ty) => {\n                                 // We might end up here if we have `Foo<<Bar as Baz>::Assoc>: 'a`.\n                                 // With this, we can deduce that `<Bar as Baz>::Assoc: 'a`.\n-                                let ty = tcx.mk_projection(projection.def_id, projection.substs);\n                                 Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n-                                    ty::OutlivesPredicate(ty, r_min),\n+                                    ty::OutlivesPredicate(alias_ty.to_ty(tcx), r_min),\n                                 )))\n                             }\n \n-                            Component::EscapingProjection(_) => {\n+                            Component::EscapingAlias(_) => {\n                                 // We might be able to do more here, but we don't\n                                 // want to deal with escaping vars right now.\n                                 None"}, {"sha": "7a5e45ada3f6a8f9528778435c6496d78980dc65", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -14,10 +14,10 @@ use rustc_middle::ty;\n use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_query_impl::QueryCtxt;\n use rustc_session::config::{self, CheckCfg, ErrorOutputType, Input, OutputFilenames};\n-use rustc_session::early_error;\n use rustc_session::lint;\n use rustc_session::parse::{CrateConfig, ParseSess};\n use rustc_session::Session;\n+use rustc_session::{early_error, CompilerIO};\n use rustc_span::source_map::{FileLoader, FileName};\n use rustc_span::symbol::sym;\n use std::path::PathBuf;\n@@ -35,11 +35,6 @@ pub type Result<T> = result::Result<T, ErrorGuaranteed>;\n pub struct Compiler {\n     pub(crate) sess: Lrc<Session>,\n     codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n-    pub(crate) input: Input,\n-    pub(crate) input_path: Option<PathBuf>,\n-    pub(crate) output_dir: Option<PathBuf>,\n-    pub(crate) output_file: Option<PathBuf>,\n-    pub(crate) temps_dir: Option<PathBuf>,\n     pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut LintStore) + Send + Sync>>,\n     pub(crate) override_queries:\n         Option<fn(&Session, &mut ty::query::Providers, &mut ty::query::ExternProviders)>,\n@@ -52,18 +47,6 @@ impl Compiler {\n     pub fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n         &self.codegen_backend\n     }\n-    pub fn input(&self) -> &Input {\n-        &self.input\n-    }\n-    pub fn output_dir(&self) -> &Option<PathBuf> {\n-        &self.output_dir\n-    }\n-    pub fn output_file(&self) -> &Option<PathBuf> {\n-        &self.output_file\n-    }\n-    pub fn temps_dir(&self) -> &Option<PathBuf> {\n-        &self.temps_dir\n-    }\n     pub fn register_lints(&self) -> &Option<Box<dyn Fn(&Session, &mut LintStore) + Send + Sync>> {\n         &self.register_lints\n     }\n@@ -72,14 +55,7 @@ impl Compiler {\n         sess: &Session,\n         attrs: &[ast::Attribute],\n     ) -> OutputFilenames {\n-        util::build_output_filenames(\n-            &self.input,\n-            &self.output_dir,\n-            &self.output_file,\n-            &self.temps_dir,\n-            attrs,\n-            sess,\n-        )\n+        util::build_output_filenames(attrs, sess)\n     }\n }\n \n@@ -244,7 +220,6 @@ pub struct Config {\n     pub crate_check_cfg: CheckCfg,\n \n     pub input: Input,\n-    pub input_path: Option<PathBuf>,\n     pub output_dir: Option<PathBuf>,\n     pub output_file: Option<PathBuf>,\n     pub file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n@@ -287,12 +262,19 @@ pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Se\n             crate::callbacks::setup_callbacks();\n \n             let registry = &config.registry;\n+\n+            let temps_dir = config.opts.unstable_opts.temps_dir.as_deref().map(PathBuf::from);\n             let (mut sess, codegen_backend) = util::create_session(\n                 config.opts,\n                 config.crate_cfg,\n                 config.crate_check_cfg,\n                 config.file_loader,\n-                config.input_path.clone(),\n+                CompilerIO {\n+                    input: config.input,\n+                    output_dir: config.output_dir,\n+                    output_file: config.output_file,\n+                    temps_dir,\n+                },\n                 config.lint_caps,\n                 config.make_codegen_backend,\n                 registry.clone(),\n@@ -302,16 +284,9 @@ pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Se\n                 parse_sess_created(&mut sess.parse_sess);\n             }\n \n-            let temps_dir = sess.opts.unstable_opts.temps_dir.as_deref().map(PathBuf::from);\n-\n             let compiler = Compiler {\n                 sess: Lrc::new(sess),\n                 codegen_backend: Lrc::new(codegen_backend),\n-                input: config.input,\n-                input_path: config.input_path,\n-                output_dir: config.output_dir,\n-                output_file: config.output_file,\n-                temps_dir,\n                 register_lints: config.register_lints,\n                 override_queries: config.override_queries,\n             };"}, {"sha": "82bc4770b6b471dcd60caa00fea9ed733d7e9d03", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -3,6 +3,7 @@\n #![feature(internal_output_capture)]\n #![feature(thread_spawn_unchecked)]\n #![feature(once_cell)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "379a76528f3bbba1d92aa19af21d0f15d8752d9d", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 12, "deletions": 46, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -13,7 +13,6 @@ use rustc_ast::{self as ast, visit};\n use rustc_borrowck as mir_borrowck;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::parallel;\n-use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::{ErrorGuaranteed, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n@@ -31,7 +30,7 @@ use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n-use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn};\n+use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn, Untracked};\n use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -51,8 +50,8 @@ use std::rc::Rc;\n use std::sync::LazyLock;\n use std::{env, fs, iter};\n \n-pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n-    let krate = sess.time(\"parse_crate\", || match input {\n+pub fn parse<'a>(sess: &'a Session) -> PResult<'a, ast::Crate> {\n+    let krate = sess.time(\"parse_crate\", || match &sess.io.input {\n         Input::File(file) => parse_crate_from_file(file, &sess.parse_sess),\n         Input::Str { input, name } => {\n             parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n@@ -559,7 +558,7 @@ fn write_out_deps(\n     }\n     let deps_filename = outputs.path(OutputType::DepInfo);\n \n-    let result = (|| -> io::Result<()> {\n+    let result: io::Result<()> = try {\n         // Build a list of files used to compile the output and\n         // write Makefile-compatible dependency rules\n         let mut files: Vec<String> = sess\n@@ -646,9 +645,7 @@ fn write_out_deps(\n                 writeln!(file)?;\n             }\n         }\n-\n-        Ok(())\n-    })();\n+    };\n \n     match result {\n         Ok(_) => {\n@@ -666,28 +663,20 @@ fn write_out_deps(\n \n pub fn prepare_outputs(\n     sess: &Session,\n-    compiler: &Compiler,\n     krate: &ast::Crate,\n     boxed_resolver: &RefCell<BoxedResolver>,\n     crate_name: Symbol,\n ) -> Result<OutputFilenames> {\n     let _timer = sess.timer(\"prepare_outputs\");\n \n     // FIXME: rustdoc passes &[] instead of &krate.attrs here\n-    let outputs = util::build_output_filenames(\n-        &compiler.input,\n-        &compiler.output_dir,\n-        &compiler.output_file,\n-        &compiler.temps_dir,\n-        &krate.attrs,\n-        sess,\n-    );\n+    let outputs = util::build_output_filenames(&krate.attrs, sess);\n \n     let output_paths =\n-        generated_output_paths(sess, &outputs, compiler.output_file.is_some(), crate_name);\n+        generated_output_paths(sess, &outputs, sess.io.output_file.is_some(), crate_name);\n \n     // Ensure the source file isn't accidentally overwritten during compilation.\n-    if let Some(ref input_path) = compiler.input_path {\n+    if let Some(ref input_path) = sess.io.input.opt_path() {\n         if sess.opts.will_create_output_file() {\n             if output_contains_path(&output_paths, input_path) {\n                 let reported = sess.emit_err(InputFileWouldBeOverWritten { path: input_path });\n@@ -701,7 +690,7 @@ pub fn prepare_outputs(\n         }\n     }\n \n-    if let Some(ref dir) = compiler.temps_dir {\n+    if let Some(ref dir) = sess.io.temps_dir {\n         if fs::create_dir_all(dir).is_err() {\n             let reported = sess.emit_err(TempsDirError);\n             return Err(reported);\n@@ -714,7 +703,7 @@ pub fn prepare_outputs(\n         && sess.opts.output_types.len() == 1;\n \n     if !only_dep_info {\n-        if let Some(ref dir) = compiler.output_dir {\n+        if let Some(ref dir) = sess.io.output_dir {\n             if fs::create_dir_all(dir).is_err() {\n                 let reported = sess.emit_err(OutDirError);\n                 return Err(reported);\n@@ -775,11 +764,8 @@ impl<'tcx> QueryContext<'tcx> {\n pub fn create_global_ctxt<'tcx>(\n     compiler: &'tcx Compiler,\n     lint_store: Lrc<LintStore>,\n-    krate: Lrc<ast::Crate>,\n     dep_graph: DepGraph,\n-    resolver: Rc<RefCell<BoxedResolver>>,\n-    outputs: OutputFilenames,\n-    crate_name: Symbol,\n+    untracked: Untracked,\n     queries: &'tcx OnceCell<TcxQueries<'tcx>>,\n     global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n@@ -790,8 +776,6 @@ pub fn create_global_ctxt<'tcx>(\n     // incr. comp. yet.\n     dep_graph.assert_ignored();\n \n-    let resolver_outputs = BoxedResolver::to_resolver_outputs(resolver);\n-\n     let sess = &compiler.session();\n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n \n@@ -810,12 +794,6 @@ pub fn create_global_ctxt<'tcx>(\n         TcxQueries::new(local_providers, extern_providers, query_result_on_disk_cache)\n     });\n \n-    let ty::ResolverOutputs {\n-        global_ctxt: untracked_resolutions,\n-        ast_lowering: untracked_resolver_for_lowering,\n-        untracked,\n-    } = resolver_outputs;\n-\n     let gcx = sess.time(\"setup_global_ctxt\", || {\n         global_ctxt.get_or_init(move || {\n             TyCtxt::create_global_ctxt(\n@@ -832,19 +810,7 @@ pub fn create_global_ctxt<'tcx>(\n         })\n     });\n \n-    let mut qcx = QueryContext { gcx };\n-    qcx.enter(|tcx| {\n-        let feed = tcx.feed_unit_query();\n-        feed.resolver_for_lowering(\n-            tcx.arena.alloc(Steal::new((untracked_resolver_for_lowering, krate))),\n-        );\n-        feed.resolutions(tcx.arena.alloc(untracked_resolutions));\n-        feed.output_filenames(tcx.arena.alloc(std::sync::Arc::new(outputs)));\n-        feed.features_query(sess.features_untracked());\n-        let feed = tcx.feed_local_crate();\n-        feed.crate_name(crate_name);\n-    });\n-    qcx\n+    QueryContext { gcx }\n }\n \n /// Runs the resolution, type-checking, region checking and other"}, {"sha": "d5a49dd75be6a06bf7a7efa310342a139c15335b", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -13,7 +13,7 @@ use rustc_incremental::DepGraphFuture;\n use rustc_lint::LintStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n-use rustc_middle::ty::{GlobalCtxt, TyCtxt};\n+use rustc_middle::ty::{self, GlobalCtxt, TyCtxt};\n use rustc_query_impl::Queries as TcxQueries;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n use rustc_session::{output::find_crate_name, Session};\n@@ -90,7 +90,6 @@ pub struct Queries<'tcx> {\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n     expansion: Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    prepare_outputs: Query<OutputFilenames>,\n     global_ctxt: Query<QueryContext<'tcx>>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n }\n@@ -109,7 +108,6 @@ impl<'tcx> Queries<'tcx> {\n             register_plugins: Default::default(),\n             expansion: Default::default(),\n             dep_graph: Default::default(),\n-            prepare_outputs: Default::default(),\n             global_ctxt: Default::default(),\n             ongoing_codegen: Default::default(),\n         }\n@@ -130,10 +128,8 @@ impl<'tcx> Queries<'tcx> {\n     }\n \n     pub fn parse(&self) -> Result<QueryResult<'_, ast::Crate>> {\n-        self.parse.compute(|| {\n-            passes::parse(self.session(), &self.compiler.input)\n-                .map_err(|mut parse_error| parse_error.emit())\n-        })\n+        self.parse\n+            .compute(|| passes::parse(self.session()).map_err(|mut parse_error| parse_error.emit()))\n     }\n \n     pub fn register_plugins(&self) -> Result<QueryResult<'_, (ast::Crate, Lrc<LintStore>)>> {\n@@ -161,13 +157,13 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn crate_name(&self) -> Result<QueryResult<'_, Symbol>> {\n+    fn crate_name(&self) -> Result<QueryResult<'_, Symbol>> {\n         self.crate_name.compute(|| {\n             Ok({\n                 let parse_result = self.parse()?;\n                 let krate = parse_result.borrow();\n                 // parse `#[crate_name]` even if `--crate-name` was passed, to make sure it matches.\n-                find_crate_name(self.session(), &krate.attrs, &self.compiler.input)\n+                find_crate_name(self.session(), &krate.attrs)\n             })\n         })\n     }\n@@ -211,40 +207,42 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn prepare_outputs(&self) -> Result<QueryResult<'_, OutputFilenames>> {\n-        self.prepare_outputs.compute(|| {\n-            let expansion = self.expansion()?;\n-            let (krate, boxed_resolver, _) = &*expansion.borrow();\n-            let crate_name = *self.crate_name()?.borrow();\n-            passes::prepare_outputs(\n-                self.session(),\n-                self.compiler,\n-                krate,\n-                &*boxed_resolver,\n-                crate_name,\n-            )\n-        })\n-    }\n-\n     pub fn global_ctxt(&'tcx self) -> Result<QueryResult<'_, QueryContext<'tcx>>> {\n         self.global_ctxt.compute(|| {\n             let crate_name = *self.crate_name()?.borrow();\n-            let outputs = self.prepare_outputs()?.steal();\n-            let dep_graph = self.dep_graph()?.borrow().clone();\n             let (krate, resolver, lint_store) = self.expansion()?.steal();\n-            Ok(passes::create_global_ctxt(\n+\n+            let outputs = passes::prepare_outputs(self.session(), &krate, &resolver, crate_name)?;\n+\n+            let ty::ResolverOutputs {\n+                untracked,\n+                global_ctxt: untracked_resolutions,\n+                ast_lowering: untracked_resolver_for_lowering,\n+            } = BoxedResolver::to_resolver_outputs(resolver);\n+\n+            let mut qcx = passes::create_global_ctxt(\n                 self.compiler,\n                 lint_store,\n-                krate,\n-                dep_graph,\n-                resolver,\n-                outputs,\n-                crate_name,\n+                self.dep_graph()?.steal(),\n+                untracked,\n                 &self.queries,\n                 &self.gcx,\n                 &self.arena,\n                 &self.hir_arena,\n-            ))\n+            );\n+\n+            qcx.enter(|tcx| {\n+                let feed = tcx.feed_unit_query();\n+                feed.resolver_for_lowering(\n+                    tcx.arena.alloc(Steal::new((untracked_resolver_for_lowering, krate))),\n+                );\n+                feed.resolutions(tcx.arena.alloc(untracked_resolutions));\n+                feed.output_filenames(tcx.arena.alloc(std::sync::Arc::new(outputs)));\n+                feed.features_query(tcx.sess.features_untracked());\n+                let feed = tcx.feed_local_crate();\n+                feed.crate_name(crate_name);\n+            });\n+            Ok(qcx)\n         })\n     }\n "}, {"sha": "f94bc4d4c66ac9d0fd872586a12308b6aa86731d", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -4,6 +4,7 @@ use crate::interface::parse_cfgspecs;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{emitter::HumanReadableErrorType, registry, ColorConfig};\n use rustc_session::config::rustc_optgroups;\n+use rustc_session::config::Input;\n use rustc_session::config::TraitSolver;\n use rustc_session::config::{build_configuration, build_session_options, to_crate_config};\n use rustc_session::config::{\n@@ -17,9 +18,11 @@ use rustc_session::config::{InstrumentCoverage, Passes};\n use rustc_session::lint::Level;\n use rustc_session::search_paths::SearchPath;\n use rustc_session::utils::{CanonicalizedPath, NativeLib, NativeLibKind};\n+use rustc_session::CompilerIO;\n use rustc_session::{build_session, getopts, Session};\n use rustc_span::edition::{Edition, DEFAULT_EDITION};\n use rustc_span::symbol::sym;\n+use rustc_span::FileName;\n use rustc_span::SourceFileHashAlgorithm;\n use rustc_target::spec::{CodeModel, LinkerFlavorCli, MergeFunctions, PanicStrategy, RelocModel};\n use rustc_target::spec::{RelroLevel, SanitizerSet, SplitDebuginfo, StackProtector, TlsModel};\n@@ -39,7 +42,14 @@ fn build_session_options_and_crate_config(matches: getopts::Matches) -> (Options\n fn mk_session(matches: getopts::Matches) -> (Session, CfgSpecs) {\n     let registry = registry::Registry::new(&[]);\n     let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-    let sess = build_session(sessopts, None, None, registry, Default::default(), None, None);\n+    let temps_dir = sessopts.unstable_opts.temps_dir.as_deref().map(PathBuf::from);\n+    let io = CompilerIO {\n+        input: Input::Str { name: FileName::Custom(String::new()), input: String::new() },\n+        output_dir: None,\n+        output_file: None,\n+        temps_dir,\n+    };\n+    let sess = build_session(sessopts, io, None, registry, Default::default(), None, None);\n     (sess, cfg)\n }\n "}, {"sha": "54363e07b971a2830c789a7c34336d362e480573", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -8,7 +8,7 @@ use rustc_parse::validate_attr;\n use rustc_session as session;\n use rustc_session::config::CheckCfg;\n use rustc_session::config::{self, CrateType};\n-use rustc_session::config::{ErrorOutputType, Input, OutputFilenames};\n+use rustc_session::config::{ErrorOutputType, OutputFilenames};\n use rustc_session::filesearch::sysroot_candidates;\n use rustc_session::lint::{self, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::CrateConfig;\n@@ -17,6 +17,7 @@ use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n+use session::CompilerIO;\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n use std::mem;\n@@ -58,7 +59,7 @@ pub fn create_session(\n     cfg: FxHashSet<(String, Option<String>)>,\n     check_cfg: CheckCfg,\n     file_loader: Option<Box<dyn FileLoader + Send + Sync + 'static>>,\n-    input_path: Option<PathBuf>,\n+    io: CompilerIO,\n     lint_caps: FxHashMap<lint::LintId, lint::Level>,\n     make_codegen_backend: Option<\n         Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n@@ -89,7 +90,7 @@ pub fn create_session(\n \n     let mut sess = session::build_session(\n         sopts,\n-        input_path,\n+        io,\n         bundle,\n         descriptions,\n         lint_caps,\n@@ -486,34 +487,27 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<C\n     base\n }\n \n-pub fn build_output_filenames(\n-    input: &Input,\n-    odir: &Option<PathBuf>,\n-    ofile: &Option<PathBuf>,\n-    temps_dir: &Option<PathBuf>,\n-    attrs: &[ast::Attribute],\n-    sess: &Session,\n-) -> OutputFilenames {\n-    match *ofile {\n+pub fn build_output_filenames(attrs: &[ast::Attribute], sess: &Session) -> OutputFilenames {\n+    match sess.io.output_file {\n         None => {\n             // \"-\" as input file will cause the parser to read from stdin so we\n             // have to make up a name\n             // We want to toss everything after the final '.'\n-            let dirpath = (*odir).as_ref().cloned().unwrap_or_default();\n+            let dirpath = sess.io.output_dir.clone().unwrap_or_default();\n \n             // If a crate name is present, we use it as the link name\n             let stem = sess\n                 .opts\n                 .crate_name\n                 .clone()\n                 .or_else(|| rustc_attr::find_crate_name(sess, attrs).map(|n| n.to_string()))\n-                .unwrap_or_else(|| input.filestem().to_owned());\n+                .unwrap_or_else(|| sess.io.input.filestem().to_owned());\n \n             OutputFilenames::new(\n                 dirpath,\n                 stem,\n                 None,\n-                temps_dir.clone(),\n+                sess.io.temps_dir.clone(),\n                 sess.opts.cg.extra_filename.clone(),\n                 sess.opts.output_types.clone(),\n             )\n@@ -534,15 +528,15 @@ pub fn build_output_filenames(\n                 }\n                 Some(out_file.clone())\n             };\n-            if *odir != None {\n+            if sess.io.output_dir != None {\n                 sess.warn(\"ignoring --out-dir flag due to -o flag\");\n             }\n \n             OutputFilenames::new(\n                 out_file.parent().unwrap_or_else(|| Path::new(\"\")).to_path_buf(),\n                 out_file.file_stem().unwrap_or_default().to_str().unwrap().to_string(),\n                 ofile,\n-                temps_dir.clone(),\n+                sess.io.temps_dir.clone(),\n                 sess.opts.cg.extra_filename.clone(),\n                 sess.opts.output_types.clone(),\n             )"}, {"sha": "fe188162cf85bee0c694155f9abcc97057981e88", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -72,7 +72,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_target::abi::{Abi, VariantIdx};\n use rustc_trait_selection::infer::{InferCtxtExt, TyCtxtInferExt};\n-use rustc_trait_selection::traits::{self, misc::can_type_implement_copy, EvaluationResult};\n+use rustc_trait_selection::traits::{self, misc::type_allowed_to_implement_copy};\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n \n@@ -709,12 +709,14 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n \n         // We shouldn't recommend implementing `Copy` on stateful things,\n         // such as iterators.\n-        if let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator) {\n-            if cx.tcx.infer_ctxt().build().type_implements_trait(iter_trait, [ty], param_env)\n-                == EvaluationResult::EvaluatedToOk\n-            {\n-                return;\n-            }\n+        if let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator)\n+            && cx.tcx\n+                .infer_ctxt()\n+                .build()\n+                .type_implements_trait(iter_trait, [ty], param_env)\n+                .must_apply_modulo_regions()\n+        {\n+            return;\n         }\n \n         // Default value of clippy::trivially_copy_pass_by_ref\n@@ -726,7 +728,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n             }\n         }\n \n-        if can_type_implement_copy(\n+        if type_allowed_to_implement_copy(\n             cx.tcx,\n             param_env,\n             ty,"}, {"sha": "8046cc21cea583eb73f15cb45228593a05139af6", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -825,34 +825,39 @@ pub trait LintContext: Sized {\n                     debug!(?param_span, ?use_span, ?deletion_span);\n                     db.span_label(param_span, \"this lifetime...\");\n                     db.span_label(use_span, \"...is used only here\");\n-                    let msg = \"elide the single-use lifetime\";\n-                    let (use_span, replace_lt) = if elide {\n-                        let use_span = sess.source_map().span_extend_while(\n-                            use_span,\n-                            char::is_whitespace,\n-                        ).unwrap_or(use_span);\n-                        (use_span, String::new())\n-                    } else {\n-                        (use_span, \"'_\".to_owned())\n-                    };\n-                    db.multipart_suggestion(\n-                        msg,\n-                        vec![(deletion_span, String::new()), (use_span, replace_lt)],\n-                        Applicability::MachineApplicable,\n-                    );\n+                    if let Some(deletion_span) = deletion_span {\n+                        let msg = \"elide the single-use lifetime\";\n+                        let (use_span, replace_lt) = if elide {\n+                            let use_span = sess.source_map().span_extend_while(\n+                                use_span,\n+                                char::is_whitespace,\n+                            ).unwrap_or(use_span);\n+                            (use_span, String::new())\n+                        } else {\n+                            (use_span, \"'_\".to_owned())\n+                        };\n+                        debug!(?deletion_span, ?use_span);\n+                        db.multipart_suggestion(\n+                            msg,\n+                            vec![(deletion_span, String::new()), (use_span, replace_lt)],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 },\n                 BuiltinLintDiagnostics::SingleUseLifetime {\n                     param_span: _,\n                     use_span: None,\n                     deletion_span,\n                 } => {\n                     debug!(?deletion_span);\n-                    db.span_suggestion(\n-                        deletion_span,\n-                        \"elide the unused lifetime\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n+                    if let Some(deletion_span) = deletion_span {\n+                        db.span_suggestion(\n+                            deletion_span,\n+                            \"elide the unused lifetime\",\n+                            \"\",\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 },\n                 BuiltinLintDiagnostics::NamedArgumentUsedPositionally{ position_sp_to_replace, position_sp_for_msg, named_arg_sp, named_arg_name, is_formatting_arg} => {\n                     db.span_label(named_arg_sp, \"this named argument is referred to by position in formatting string\");"}, {"sha": "337a19dd024d2fec195601c77de253036df847bf", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -248,7 +248,9 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_where_predicate(&mut self, p: &'a ast::WherePredicate) {\n+        lint_callback!(self, enter_where_predicate, p);\n         ast_visit::walk_where_predicate(self, p);\n+        lint_callback!(self, exit_where_predicate, p);\n     }\n \n     fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef) {"}, {"sha": "6cefaea2bc7da8af59508ff2cad32366ccce9d54", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -187,9 +187,9 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                         },\n                         None => cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindDiag),\n                     }\n-                } else if !ty.span.from_expansion() && path.segments.len() > 1 && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n+                } else if !ty.span.from_expansion() && path.segments.len() > 1 && let Some(ty) = is_ty_or_ty_ctxt(cx, &path) {\n                     cx.emit_spanned_lint(USAGE_OF_QUALIFIED_TY, path.span, TyQualified {\n-                        ty: t.clone(),\n+                        ty,\n                         suggestion: path.span,\n                     });\n                 }"}, {"sha": "d6be4da03286f75f1e4868e5bac454b345008a8b", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -145,7 +145,7 @@ early_lint_methods!(\n     [\n         pub BuiltinCombinedEarlyLintPass,\n         [\n-            UnusedParens: UnusedParens,\n+            UnusedParens: UnusedParens::new(),\n             UnusedBraces: UnusedBraces,\n             UnusedImportBraces: UnusedImportBraces,\n             UnsafeCode: UnsafeCode,"}, {"sha": "392e13f2fa94165d802ac24c0913934dd5d43d1b", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByValue {\n                     cx.emit_spanned_lint(\n                         PASS_BY_VALUE,\n                         ty.span,\n-                        PassByValueDiag { ty: t.clone(), suggestion: ty.span },\n+                        PassByValueDiag { ty: t, suggestion: ty.span },\n                     );\n                 }\n             }"}, {"sha": "0bf01c4e567814f1f720de66362f310cf5c0f934", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -171,6 +171,9 @@ macro_rules! early_lint_methods {\n \n             /// Counterpart to `enter_lint_attrs`.\n             fn exit_lint_attrs(a: &[ast::Attribute]);\n+\n+            fn enter_where_predicate(a: &ast::WherePredicate);\n+            fn exit_where_predicate(a: &ast::WherePredicate);\n         ]);\n     )\n }"}, {"sha": "be47a3e238c1c16ba4fcb46616264e75637718f0", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1147,7 +1147,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 if !ty.has_opaque_types() {\n-                    return ControlFlow::CONTINUE;\n+                    return ControlFlow::Continue(());\n                 }\n \n                 if let ty::Alias(ty::Opaque, ..) = ty.kind() {"}, {"sha": "4c9b3df2dbd33d706d04c3cc5e911ceeb9c70a2c", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 63, "deletions": 27, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -824,7 +824,17 @@ declare_lint! {\n     \"`if`, `match`, `while` and `return` do not need parentheses\"\n }\n \n-declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n+pub struct UnusedParens {\n+    with_self_ty_parens: bool,\n+}\n+\n+impl UnusedParens {\n+    pub fn new() -> Self {\n+        Self { with_self_ty_parens: false }\n+    }\n+}\n+\n+impl_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n \n impl UnusedDelimLint for UnusedParens {\n     const DELIM_STR: &'static str = \"parentheses\";\n@@ -999,36 +1009,58 @@ impl EarlyLintPass for UnusedParens {\n     }\n \n     fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {\n-        if let ast::TyKind::Paren(r) = &ty.kind {\n-            match &r.kind {\n-                ast::TyKind::TraitObject(..) => {}\n-                ast::TyKind::BareFn(b) if b.generic_params.len() > 0 => {}\n-                ast::TyKind::ImplTrait(_, bounds) if bounds.len() > 1 => {}\n-                ast::TyKind::Array(_, len) => {\n-                    self.check_unused_delims_expr(\n-                        cx,\n-                        &len.value,\n-                        UnusedDelimsCtx::ArrayLenExpr,\n-                        false,\n-                        None,\n-                        None,\n-                    );\n-                }\n-                _ => {\n-                    let spans = if let Some(r) = r.span.find_ancestor_inside(ty.span) {\n-                        Some((ty.span.with_hi(r.lo()), ty.span.with_lo(r.hi())))\n-                    } else {\n-                        None\n-                    };\n-                    self.emit_unused_delims(cx, ty.span, spans, \"type\", (false, false));\n+        match &ty.kind {\n+            ast::TyKind::Array(_, len) => {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &len.value,\n+                    UnusedDelimsCtx::ArrayLenExpr,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n+            ast::TyKind::Paren(r) => {\n+                match &r.kind {\n+                    ast::TyKind::TraitObject(..) => {}\n+                    ast::TyKind::BareFn(b)\n+                        if self.with_self_ty_parens && b.generic_params.len() > 0 => {}\n+                    ast::TyKind::ImplTrait(_, bounds) if bounds.len() > 1 => {}\n+                    _ => {\n+                        let spans = if let Some(r) = r.span.find_ancestor_inside(ty.span) {\n+                            Some((ty.span.with_hi(r.lo()), ty.span.with_lo(r.hi())))\n+                        } else {\n+                            None\n+                        };\n+                        self.emit_unused_delims(cx, ty.span, spans, \"type\", (false, false));\n+                    }\n                 }\n+                self.with_self_ty_parens = false;\n             }\n+            _ => {}\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         <Self as UnusedDelimLint>::check_item(self, cx, item)\n     }\n+\n+    fn enter_where_predicate(&mut self, _: &EarlyContext<'_>, pred: &ast::WherePredicate) {\n+        use rustc_ast::{WhereBoundPredicate, WherePredicate};\n+        if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                bounded_ty,\n+                bound_generic_params,\n+                ..\n+            }) = pred &&\n+            let ast::TyKind::Paren(_) = &bounded_ty.kind &&\n+            bound_generic_params.is_empty() {\n+                self.with_self_ty_parens = true;\n+        }\n+    }\n+\n+    fn exit_where_predicate(&mut self, _: &EarlyContext<'_>, _: &ast::WherePredicate) {\n+        assert!(!self.with_self_ty_parens);\n+    }\n }\n \n declare_lint! {\n@@ -1095,17 +1127,21 @@ impl UnusedDelimLint for UnusedBraces {\n                 //      ```\n                 // - the block has no attribute and was not created inside a macro\n                 // - if the block is an `anon_const`, the inner expr must be a literal\n-                //      (do not lint `struct A<const N: usize>; let _: A<{ 2 + 3 }>;`)\n-                //\n+                //   not created by a macro, i.e. do not lint on:\n+                //      ```\n+                //      struct A<const N: usize>;\n+                //      let _: A<{ 2 + 3 }>;\n+                //      let _: A<{produces_literal!()}>;\n+                //      ```\n                 // FIXME(const_generics): handle paths when #67075 is fixed.\n                 if let [stmt] = inner.stmts.as_slice() {\n                     if let ast::StmtKind::Expr(ref expr) = stmt.kind {\n                         if !Self::is_expr_delims_necessary(expr, followed_by_block, false)\n                             && (ctx != UnusedDelimsCtx::AnonConst\n-                                || matches!(expr.kind, ast::ExprKind::Lit(_)))\n+                                || (matches!(expr.kind, ast::ExprKind::Lit(_))\n+                                    && !expr.span.from_expansion()))\n                             && !cx.sess().source_map().is_multiline(value.span)\n                             && value.attrs.is_empty()\n-                            && !expr.span.from_expansion()\n                             && !value.span.from_expansion()\n                             && !inner.span.from_expansion()\n                         {"}, {"sha": "b6481d70bc8898fe2de912d9f382e90233fa28bd", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -708,7 +708,7 @@ declare_lint! {\n     ///\n     /// ### Example\n     ///\n-    /// ```rust\n+    /// ```rust,compile_fail\n     /// pub enum Enum {\n     ///     Foo,\n     ///     Bar,\n@@ -743,7 +743,7 @@ declare_lint! {\n     /// [identifier pattern]: https://doc.rust-lang.org/reference/patterns.html#identifier-patterns\n     /// [path pattern]: https://doc.rust-lang.org/reference/patterns.html#path-patterns\n     pub BINDINGS_WITH_VARIANT_NAME,\n-    Warn,\n+    Deny,\n     \"detects pattern bindings with the same name as one of the matched variants\"\n }\n \n@@ -2023,6 +2023,73 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `proc_macro_derive_resolution_fallback` lint detects proc macro\n+    /// derives using inaccessible names from parent modules.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,ignore (proc-macro)\n+    /// // foo.rs\n+    /// #![crate_type = \"proc-macro\"]\n+    ///\n+    /// extern crate proc_macro;\n+    ///\n+    /// use proc_macro::*;\n+    ///\n+    /// #[proc_macro_derive(Foo)]\n+    /// pub fn foo1(a: TokenStream) -> TokenStream {\n+    ///     drop(a);\n+    ///     \"mod __bar { static mut BAR: Option<Something> = None; }\".parse().unwrap()\n+    /// }\n+    /// ```\n+    ///\n+    /// ```rust,ignore (needs-dependency)\n+    /// // bar.rs\n+    /// #[macro_use]\n+    /// extern crate foo;\n+    ///\n+    /// struct Something;\n+    ///\n+    /// #[derive(Foo)]\n+    /// struct Another;\n+    ///\n+    /// fn main() {}\n+    /// ```\n+    ///\n+    /// This will produce:\n+    ///\n+    /// ```text\n+    /// warning: cannot find type `Something` in this scope\n+    ///  --> src/main.rs:8:10\n+    ///   |\n+    /// 8 | #[derive(Foo)]\n+    ///   |          ^^^ names from parent modules are not accessible without an explicit import\n+    ///   |\n+    ///   = note: `#[warn(proc_macro_derive_resolution_fallback)]` on by default\n+    ///   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+    ///   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+    /// ```\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// If a proc-macro generates a module, the compiler unintentionally\n+    /// allowed items in that module to refer to items in the crate root\n+    /// without importing them. This is a [future-incompatible] lint to\n+    /// transition this to a hard error in the future. See [issue #50504] for\n+    /// more details.\n+    ///\n+    /// [issue #50504]: https://github.com/rust-lang/rust/issues/50504\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n+    pub PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+    Deny,\n+    \"detects proc macro derives using inaccessible names from parent modules\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #83583 <https://github.com/rust-lang/rust/issues/83583>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n+    };\n+}\n+\n declare_lint! {\n     /// The `macro_use_extern_crate` lint detects the use of the\n     /// [`macro_use` attribute].\n@@ -2948,6 +3015,7 @@ declare_lint! {\n     \"trailing semicolon in macro body used as expression\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #79813 <https://github.com/rust-lang/rust/issues/79813>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }\n \n@@ -3261,6 +3329,7 @@ declare_lint_pass! {\n         UNSTABLE_NAME_COLLISIONS,\n         IRREFUTABLE_LET_PATTERNS,\n         WHERE_CLAUSES_OBJECT_SAFETY,\n+        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n         MACRO_USE_EXTERN_CRATE,\n         MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n         ILL_FORMED_ATTRIBUTE_INPUT,"}, {"sha": "7054d1e9f105e4392e513f197f3dc91d0632fe2c", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,8 +6,9 @@\n extern crate rustc_macros;\n \n pub use self::Level::*;\n-use rustc_ast::node_id::{NodeId, NodeMap};\n+use rustc_ast::node_id::NodeId;\n use rustc_ast::{AttrId, Attribute};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_error_messages::{DiagnosticMessage, MultiSpan};\n use rustc_hir::HashStableContext;\n@@ -502,7 +503,7 @@ pub enum BuiltinLintDiagnostics {\n         param_span: Span,\n         /// Span of the code that should be removed when eliding this lifetime.\n         /// This span should include leading or trailing comma.\n-        deletion_span: Span,\n+        deletion_span: Option<Span>,\n         /// Span of the single use, or None if the lifetime is never used.\n         /// If true, the lifetime will be fully elided.\n         use_span: Option<(Span, bool)>,\n@@ -544,7 +545,7 @@ pub struct BufferedEarlyLint {\n \n #[derive(Default)]\n pub struct LintBuffer {\n-    pub map: NodeMap<Vec<BufferedEarlyLint>>,\n+    pub map: FxIndexMap<NodeId, Vec<BufferedEarlyLint>>,\n }\n \n impl LintBuffer {"}, {"sha": "87b0e1273eb7761ed06ab0390704af2ae8c2b645", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1349,18 +1349,16 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n     return LLVMBFloatTypeKind;\n   case Type::X86_AMXTyID:\n     return LLVMX86_AMXTypeKind;\n-#if LLVM_VERSION_GE(15, 0) && LLVM_VERSION_LT(16, 0)\n-  case Type::DXILPointerTyID:\n-    report_fatal_error(\"Rust does not support DirectX typed pointers.\");\n-    break;\n-#endif\n-#if LLVM_VERSION_GE(16, 0)\n-  case Type::TypedPointerTyID:\n-    report_fatal_error(\"Rust does not support typed pointers.\");\n-    break;\n-#endif\n+  default:\n+    {\n+      std::string error;\n+      llvm::raw_string_ostream stream(error);\n+      stream << \"Rust does not support the TypeID: \" << unwrap(Ty)->getTypeID()\n+             << \" for the type: \" << *unwrap(Ty);\n+      stream.flush();\n+      report_fatal_error(error.c_str());\n+    }\n   }\n-  report_fatal_error(\"Unhandled TypeID.\");\n }\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(SMDiagnostic, LLVMSMDiagnosticRef)"}, {"sha": "1f95661ce9d5f54bb770a764c902a835bec7afe1", "filename": "compiler/rustc_macros/src/type_visitable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_visitable.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -26,7 +26,7 @@ pub fn type_visitable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n                 __visitor: &mut __V\n             ) -> ::std::ops::ControlFlow<__V::BreakTy> {\n                 match *self { #body_visit }\n-                ::std::ops::ControlFlow::CONTINUE\n+                ::std::ops::ControlFlow::Continue(())\n             }\n         },\n     )"}, {"sha": "6fd5bd52abe284c008654aee3b8272600f4199ff", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -223,6 +223,15 @@ provide! { tcx, def_id, other, cdata,\n     generator_kind => { table }\n     trait_def => { table }\n     deduced_param_attrs => { table }\n+    is_type_alias_impl_trait => {\n+        debug_assert_eq!(tcx.def_kind(def_id), DefKind::OpaqueTy);\n+        cdata\n+            .root\n+            .tables\n+            .is_type_alias_impl_trait\n+            .get(cdata, def_id.index)\n+            .is_some()\n+    }\n     collect_return_position_impl_trait_in_trait_tys => {\n         Ok(cdata\n             .root\n@@ -382,7 +391,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             // keys from the former.\n             // This is a rudimentary check that does not catch all cases,\n             // just the easiest.\n-            let mut fallback_map: DefIdMap<DefId> = Default::default();\n+            let mut fallback_map: Vec<(DefId, DefId)> = Default::default();\n \n             // Issue 46112: We want the map to prefer the shortest\n             // paths when reporting the path to an item. Therefore we\n@@ -412,12 +421,12 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n \n                 if let Some(def_id) = child.res.opt_def_id() {\n                     if child.ident.name == kw::Underscore {\n-                        fallback_map.insert(def_id, parent);\n+                        fallback_map.push((def_id, parent));\n                         return;\n                     }\n \n                     if ty::util::is_doc_hidden(tcx, parent) {\n-                        fallback_map.insert(def_id, parent);\n+                        fallback_map.push((def_id, parent));\n                         return;\n                     }\n \n@@ -451,6 +460,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             // Fill in any missing entries with the less preferable path.\n             // If this path re-exports the child as `_`, we still use this\n             // path in a diagnostic that suggests importing `::*`.\n+\n             for (child, parent) in fallback_map {\n                 visible_parent_map.entry(child).or_insert(parent);\n             }"}, {"sha": "8f7a61b72f81a2cebb7408b11ab2904e17563adf", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -888,8 +888,8 @@ fn should_encode_mir(tcx: TyCtxt<'_>, def_id: LocalDefId) -> (bool, bool) {\n         | DefKind::AssocConst\n         | DefKind::Static(..)\n         | DefKind::Const => (true, false),\n-        // Full-fledged functions\n-        DefKind::AssocFn | DefKind::Fn => {\n+        // Full-fledged functions + closures\n+        DefKind::AssocFn | DefKind::Fn | DefKind::Closure => {\n             let generics = tcx.generics_of(def_id);\n             let needs_inline = (generics.requires_monomorphization(tcx)\n                 || tcx.codegen_fn_attrs(def_id).requests_inline())\n@@ -900,15 +900,6 @@ fn should_encode_mir(tcx: TyCtxt<'_>, def_id: LocalDefId) -> (bool, bool) {\n             let always_encode_mir = tcx.sess.opts.unstable_opts.always_encode_mir;\n             (is_const_fn, needs_inline || always_encode_mir)\n         }\n-        // Closures can't be const fn.\n-        DefKind::Closure => {\n-            let generics = tcx.generics_of(def_id);\n-            let needs_inline = (generics.requires_monomorphization(tcx)\n-                || tcx.codegen_fn_attrs(def_id).requests_inline())\n-                && tcx.sess.opts.output_types.should_codegen();\n-            let always_encode_mir = tcx.sess.opts.unstable_opts.always_encode_mir;\n-            (false, needs_inline || always_encode_mir)\n-        }\n         // Generators require optimized MIR to compute layout.\n         DefKind::Generator => (false, true),\n         // The others don't have MIR.\n@@ -1196,8 +1187,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n         }\n-        let inherent_impls = tcx.crate_inherent_impls(());\n-        for (def_id, implementations) in inherent_impls.inherent_impls.iter() {\n+        let inherent_impls = tcx.with_stable_hashing_context(|hcx| {\n+            tcx.crate_inherent_impls(()).inherent_impls.to_sorted(&hcx, true)\n+        });\n+\n+        for (def_id, implementations) in inherent_impls {\n             if implementations.is_empty() {\n                 continue;\n             }\n@@ -1521,8 +1515,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(item.owner_id.def_id, m);\n             }\n-            hir::ItemKind::OpaqueTy(..) => {\n+            hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n+                if matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias) {\n+                    self.tables.is_type_alias_impl_trait.set(def_id.index, ());\n+                }\n             }\n             hir::ItemKind::Enum(..) => {\n                 let adt_def = self.tcx.adt_def(def_id);"}, {"sha": "5066dbbb90f3a60168e3bd1a2829cc70d7bd1b16", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -404,6 +404,8 @@ define_tables! {\n     proc_macro: Table<DefIndex, MacroKind>,\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n     deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,\n+    // Slot is full when opaque is TAIT.\n+    is_type_alias_impl_trait: Table<DefIndex, ()>,\n \n     trait_impl_trait_tys: Table<DefIndex, LazyValue<FxHashMap<DefId, Ty<'static>>>>,\n }"}, {"sha": "43583b5723e698f763e7c03f5a35b19b41e25108", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -68,6 +68,22 @@ pub struct CanonicalVarValues<'tcx> {\n     pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n }\n \n+impl CanonicalVarValues<'_> {\n+    pub fn is_identity(&self) -> bool {\n+        self.var_values.iter_enumerated().all(|(bv, arg)| match arg.unpack() {\n+            ty::GenericArgKind::Lifetime(r) => {\n+                matches!(*r, ty::ReLateBound(ty::INNERMOST, br) if br.var == bv)\n+            }\n+            ty::GenericArgKind::Type(ty) => {\n+                matches!(*ty.kind(), ty::Bound(ty::INNERMOST, bt) if bt.var == bv)\n+            }\n+            ty::GenericArgKind::Const(ct) => {\n+                matches!(ct.kind(), ty::ConstKind::Bound(ty::INNERMOST, bc) if bc == bv)\n+            }\n+        })\n+    }\n+}\n+\n /// When we canonicalize a value to form a query, we wind up replacing\n /// various parts of it with canonical variables. This struct stores\n /// those replaced bits to remember for when we process the query\n@@ -323,6 +339,12 @@ TrivialTypeTraversalAndLiftImpls! {\n }\n \n impl<'tcx> CanonicalVarValues<'tcx> {\n+    /// Creates dummy var values which should not be used in a\n+    /// canonical response.\n+    pub fn dummy() -> CanonicalVarValues<'tcx> {\n+        CanonicalVarValues { var_values: Default::default() }\n+    }\n+\n     #[inline]\n     pub fn len(&self) -> usize {\n         self.var_values.len()"}, {"sha": "250f3d0797eb52cdb2c503ab914967d26235a956", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -93,7 +93,7 @@ macro_rules! TrivialTypeTraversalImpls {\n                     _: &mut F)\n                     -> ::std::ops::ControlFlow<F::BreakTy>\n                 {\n-                    ::std::ops::ControlFlow::CONTINUE\n+                    ::std::ops::ControlFlow::Continue(())\n                 }\n             }\n         )+\n@@ -219,7 +219,7 @@ macro_rules! EnumTypeTraversalImpl {\n                         $($crate::ty::visit::TypeVisitable::visit_with(\n                             $variant_arg, $visitor\n                         )?;)*\n-                        ::std::ops::ControlFlow::CONTINUE\n+                        ::std::ops::ControlFlow::Continue(())\n                     }\n                     $($output)*\n                 )\n@@ -237,7 +237,7 @@ macro_rules! EnumTypeTraversalImpl {\n                         $($crate::ty::visit::TypeVisitable::visit_with(\n                             $variant_arg, $visitor\n                         )?;)*\n-                        ::std::ops::ControlFlow::CONTINUE\n+                        ::std::ops::ControlFlow::Continue(())\n                     }\n                     $($output)*\n                 )\n@@ -251,7 +251,7 @@ macro_rules! EnumTypeTraversalImpl {\n             @VisitVariants($this, $visitor)\n                 input($($input)*)\n                 output(\n-                    $variant => { ::std::ops::ControlFlow::CONTINUE }\n+                    $variant => { ::std::ops::ControlFlow::Continue(()) }\n                     $($output)*\n                 )\n         )"}, {"sha": "b3354e6e9d2a2e4c7712350e8b1a11b84113d58f", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "modified", "additions": 74, "deletions": 24, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,38 +1,44 @@\n-use crate::mir::graph_cyclic_cache::GraphIsCyclicCache;\n-use crate::mir::predecessors::{PredecessorCache, Predecessors};\n-use crate::mir::switch_sources::{SwitchSourceCache, SwitchSources};\n-use crate::mir::traversal::PostorderCache;\n-use crate::mir::{BasicBlock, BasicBlockData, Successors, START_BLOCK};\n+use crate::mir::traversal::Postorder;\n+use crate::mir::{BasicBlock, BasicBlockData, Successors, Terminator, TerminatorKind, START_BLOCK};\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::OnceCell;\n use rustc_index::vec::IndexVec;\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use smallvec::SmallVec;\n \n #[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable, TypeFoldable, TypeVisitable)]\n pub struct BasicBlocks<'tcx> {\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-    predecessor_cache: PredecessorCache,\n-    switch_source_cache: SwitchSourceCache,\n-    is_cyclic: GraphIsCyclicCache,\n-    postorder_cache: PostorderCache,\n+    cache: Cache,\n+}\n+\n+// Typically 95%+ of basic blocks have 4 or fewer predecessors.\n+pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n+\n+pub type SwitchSources = FxHashMap<(BasicBlock, BasicBlock), SmallVec<[Option<u128>; 1]>>;\n+\n+#[derive(Clone, Default, Debug)]\n+struct Cache {\n+    predecessors: OnceCell<Predecessors>,\n+    switch_sources: OnceCell<SwitchSources>,\n+    is_cyclic: OnceCell<bool>,\n+    postorder: OnceCell<Vec<BasicBlock>>,\n }\n \n impl<'tcx> BasicBlocks<'tcx> {\n     #[inline]\n     pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n-        BasicBlocks {\n-            basic_blocks,\n-            predecessor_cache: PredecessorCache::new(),\n-            switch_source_cache: SwitchSourceCache::new(),\n-            is_cyclic: GraphIsCyclicCache::new(),\n-            postorder_cache: PostorderCache::new(),\n-        }\n+        BasicBlocks { basic_blocks, cache: Cache::default() }\n     }\n \n     /// Returns true if control-flow graph contains a cycle reachable from the `START_BLOCK`.\n     #[inline]\n     pub fn is_cfg_cyclic(&self) -> bool {\n-        self.is_cyclic.is_cyclic(self)\n+        *self.cache.is_cyclic.get_or_init(|| graph::is_cyclic(self))\n     }\n \n     #[inline]\n@@ -43,20 +49,46 @@ impl<'tcx> BasicBlocks<'tcx> {\n     /// Returns predecessors for each basic block.\n     #[inline]\n     pub fn predecessors(&self) -> &Predecessors {\n-        self.predecessor_cache.compute(&self.basic_blocks)\n+        self.cache.predecessors.get_or_init(|| {\n+            let mut preds = IndexVec::from_elem(SmallVec::new(), &self.basic_blocks);\n+            for (bb, data) in self.basic_blocks.iter_enumerated() {\n+                if let Some(term) = &data.terminator {\n+                    for succ in term.successors() {\n+                        preds[succ].push(bb);\n+                    }\n+                }\n+            }\n+            preds\n+        })\n     }\n \n     /// Returns basic blocks in a postorder.\n     #[inline]\n     pub fn postorder(&self) -> &[BasicBlock] {\n-        self.postorder_cache.compute(&self.basic_blocks)\n+        self.cache.postorder.get_or_init(|| {\n+            Postorder::new(&self.basic_blocks, START_BLOCK).map(|(bb, _)| bb).collect()\n+        })\n     }\n \n     /// `switch_sources()[&(target, switch)]` returns a list of switch\n     /// values that lead to a `target` block from a `switch` block.\n     #[inline]\n     pub fn switch_sources(&self) -> &SwitchSources {\n-        self.switch_source_cache.compute(&self.basic_blocks)\n+        self.cache.switch_sources.get_or_init(|| {\n+            let mut switch_sources: SwitchSources = FxHashMap::default();\n+            for (bb, data) in self.basic_blocks.iter_enumerated() {\n+                if let Some(Terminator {\n+                    kind: TerminatorKind::SwitchInt { targets, .. }, ..\n+                }) = &data.terminator\n+                {\n+                    for (value, target) in targets.iter() {\n+                        switch_sources.entry((target, bb)).or_default().push(Some(value));\n+                    }\n+                    switch_sources.entry((targets.otherwise(), bb)).or_default().push(None);\n+                }\n+            }\n+            switch_sources\n+        })\n     }\n \n     /// Returns mutable reference to basic blocks. Invalidates CFG cache.\n@@ -88,10 +120,7 @@ impl<'tcx> BasicBlocks<'tcx> {\n     /// All other methods that allow you to mutate the basic blocks also call this method\n     /// themselves, thereby avoiding any risk of accidentally cache invalidation.\n     pub fn invalidate_cfg_cache(&mut self) {\n-        self.predecessor_cache.invalidate();\n-        self.switch_source_cache.invalidate();\n-        self.is_cyclic.invalidate();\n-        self.postorder_cache.invalidate();\n+        self.cache = Cache::default();\n     }\n }\n \n@@ -145,3 +174,24 @@ impl<'tcx> graph::WithPredecessors for BasicBlocks<'tcx> {\n         self.predecessors()[node].iter().copied()\n     }\n }\n+\n+TrivialTypeTraversalAndLiftImpls! {\n+    Cache,\n+}\n+\n+impl<S: Encoder> Encodable<S> for Cache {\n+    #[inline]\n+    fn encode(&self, _s: &mut S) {}\n+}\n+\n+impl<D: Decoder> Decodable<D> for Cache {\n+    #[inline]\n+    fn decode(_: &mut D) -> Self {\n+        Default::default()\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for Cache {\n+    #[inline]\n+    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {}\n+}"}, {"sha": "f97bf2883b3691b3f9b10f5899dd2b629f25899c", "filename": "compiler/rustc_middle/src/mir/graph_cyclic_cache.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cb7770736c15488ec816d24ed41928d513f56b4c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7770736c15488ec816d24ed41928d513f56b4c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs?ref=cb7770736c15488ec816d24ed41928d513f56b4c", "patch": "@@ -1,63 +0,0 @@\n-use rustc_data_structures::graph::{\n-    self, DirectedGraph, WithNumNodes, WithStartNode, WithSuccessors,\n-};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::OnceCell;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-\n-/// Helper type to cache the result of `graph::is_cyclic`.\n-#[derive(Clone, Debug)]\n-pub(super) struct GraphIsCyclicCache {\n-    cache: OnceCell<bool>,\n-}\n-\n-impl GraphIsCyclicCache {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        GraphIsCyclicCache { cache: OnceCell::new() }\n-    }\n-\n-    pub(super) fn is_cyclic<G>(&self, graph: &G) -> bool\n-    where\n-        G: ?Sized + DirectedGraph + WithStartNode + WithSuccessors + WithNumNodes,\n-    {\n-        *self.cache.get_or_init(|| graph::is_cyclic(graph))\n-    }\n-\n-    /// Invalidates the cache.\n-    #[inline]\n-    pub(super) fn invalidate(&mut self) {\n-        // Invalidating the cache requires mutating the MIR, which in turn requires a unique\n-        // reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n-        // callers of `invalidate` have a unique reference to the MIR and thus to the\n-        // cache. This means we never need to do synchronization when `invalidate` is called,\n-        // we can simply reinitialize the `OnceCell`.\n-        self.cache = OnceCell::new();\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for GraphIsCyclicCache {\n-    #[inline]\n-    fn encode(&self, s: &mut S) {\n-        Encodable::encode(&(), s);\n-    }\n-}\n-\n-impl<D: Decoder> Decodable<D> for GraphIsCyclicCache {\n-    #[inline]\n-    fn decode(d: &mut D) -> Self {\n-        let () = Decodable::decode(d);\n-        Self::new()\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for GraphIsCyclicCache {\n-    #[inline]\n-    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n-        // do nothing\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    GraphIsCyclicCache,\n-}"}, {"sha": "d833286dc33f008ea17ec537dd4ae8de733712d8", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -47,18 +47,15 @@ mod basic_blocks;\n pub mod coverage;\n mod generic_graph;\n pub mod generic_graphviz;\n-mod graph_cyclic_cache;\n pub mod graphviz;\n pub mod interpret;\n pub mod mono;\n pub mod patch;\n-mod predecessors;\n pub mod pretty;\n mod query;\n pub mod spanview;\n mod syntax;\n pub use syntax::*;\n-mod switch_sources;\n pub mod tcx;\n pub mod terminator;\n pub use terminator::*;"}, {"sha": "5f1fadaf3bc4ceafe376b5fe3590d07589ad53ef", "filename": "compiler/rustc_middle/src/mir/predecessors.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cb7770736c15488ec816d24ed41928d513f56b4c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7770736c15488ec816d24ed41928d513f56b4c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs?ref=cb7770736c15488ec816d24ed41928d513f56b4c", "patch": "@@ -1,78 +0,0 @@\n-//! Lazily compute the reverse control-flow graph for the MIR.\n-\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::OnceCell;\n-use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use smallvec::SmallVec;\n-\n-use crate::mir::{BasicBlock, BasicBlockData};\n-\n-// Typically 95%+ of basic blocks have 4 or fewer predecessors.\n-pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n-\n-#[derive(Clone, Debug)]\n-pub(super) struct PredecessorCache {\n-    cache: OnceCell<Predecessors>,\n-}\n-\n-impl PredecessorCache {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        PredecessorCache { cache: OnceCell::new() }\n-    }\n-\n-    /// Invalidates the predecessor cache.\n-    #[inline]\n-    pub(super) fn invalidate(&mut self) {\n-        // Invalidating the predecessor cache requires mutating the MIR, which in turn requires a\n-        // unique reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n-        // callers of `invalidate` have a unique reference to the MIR and thus to the predecessor\n-        // cache. This means we never need to do synchronization when `invalidate` is called, we can\n-        // simply reinitialize the `OnceCell`.\n-        self.cache = OnceCell::new();\n-    }\n-\n-    /// Returns the predecessor graph for this MIR.\n-    #[inline]\n-    pub(super) fn compute(\n-        &self,\n-        basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n-    ) -> &Predecessors {\n-        self.cache.get_or_init(|| {\n-            let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n-            for (bb, data) in basic_blocks.iter_enumerated() {\n-                if let Some(term) = &data.terminator {\n-                    for succ in term.successors() {\n-                        preds[succ].push(bb);\n-                    }\n-                }\n-            }\n-\n-            preds\n-        })\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for PredecessorCache {\n-    #[inline]\n-    fn encode(&self, _s: &mut S) {}\n-}\n-\n-impl<D: Decoder> Decodable<D> for PredecessorCache {\n-    #[inline]\n-    fn decode(_: &mut D) -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for PredecessorCache {\n-    #[inline]\n-    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n-        // do nothing\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    PredecessorCache,\n-}"}, {"sha": "b91c0c25782f410763a25aaf7da196cce73b824d", "filename": "compiler/rustc_middle/src/mir/switch_sources.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cb7770736c15488ec816d24ed41928d513f56b4c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7770736c15488ec816d24ed41928d513f56b4c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fswitch_sources.rs?ref=cb7770736c15488ec816d24ed41928d513f56b4c", "patch": "@@ -1,78 +0,0 @@\n-//! Lazily compute the inverse of each `SwitchInt`'s switch targets. Modeled after\n-//! `Predecessors`/`PredecessorCache`.\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::OnceCell;\n-use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use smallvec::SmallVec;\n-\n-use crate::mir::{BasicBlock, BasicBlockData, Terminator, TerminatorKind};\n-\n-pub type SwitchSources = FxHashMap<(BasicBlock, BasicBlock), SmallVec<[Option<u128>; 1]>>;\n-\n-#[derive(Clone, Debug)]\n-pub(super) struct SwitchSourceCache {\n-    cache: OnceCell<SwitchSources>,\n-}\n-\n-impl SwitchSourceCache {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        SwitchSourceCache { cache: OnceCell::new() }\n-    }\n-\n-    /// Invalidates the switch source cache.\n-    #[inline]\n-    pub(super) fn invalidate(&mut self) {\n-        self.cache = OnceCell::new();\n-    }\n-\n-    /// Returns the switch sources for this MIR.\n-    #[inline]\n-    pub(super) fn compute(\n-        &self,\n-        basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n-    ) -> &SwitchSources {\n-        self.cache.get_or_init(|| {\n-            let mut switch_sources: SwitchSources = FxHashMap::default();\n-            for (bb, data) in basic_blocks.iter_enumerated() {\n-                if let Some(Terminator {\n-                    kind: TerminatorKind::SwitchInt { targets, .. }, ..\n-                }) = &data.terminator\n-                {\n-                    for (value, target) in targets.iter() {\n-                        switch_sources.entry((target, bb)).or_default().push(Some(value));\n-                    }\n-                    switch_sources.entry((targets.otherwise(), bb)).or_default().push(None);\n-                }\n-            }\n-\n-            switch_sources\n-        })\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for SwitchSourceCache {\n-    #[inline]\n-    fn encode(&self, _s: &mut S) {}\n-}\n-\n-impl<D: Decoder> Decodable<D> for SwitchSourceCache {\n-    #[inline]\n-    fn decode(_: &mut D) -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for SwitchSourceCache {\n-    #[inline]\n-    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n-        // do nothing\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    SwitchSourceCache,\n-}"}, {"sha": "52c2b10cbbea97e286650d84ce8bf4a79be35a23", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -512,6 +512,16 @@ pub struct CopyNonOverlapping<'tcx> {\n ///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n ///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n ///     runtime.\n+///  4. The control flow between cleanup blocks must look like an upside down tree. Roughly\n+///     speaking, this means that control flow that looks like a V is allowed, while control flow\n+///     that looks like a W is not. This is necessary to ensure that landing pad information can be\n+///     correctly codegened on MSVC. More precisely:\n+///\n+///     Begin with the standard control flow graph `G`. Modify `G` as follows: for any two cleanup\n+///     vertices `u` and `v` such that `u` dominates `v`, contract `u` and `v` into a single vertex,\n+///     deleting self edges and duplicate edges in the process. Now remove all vertices from `G`\n+///     that are not cleanup vertices or are not reachable. The resulting graph must be an inverted\n+///     tree, that is each vertex may have at most one successor and there may be no cycles.\n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n pub enum TerminatorKind<'tcx> {\n     /// Block has one successor; we continue execution there."}, {"sha": "f37222cb29758cf827fe943b47d613b9be389bc9", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,7 +1,4 @@\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::OnceCell;\n use rustc_index::bit_set::BitSet;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use super::*;\n \n@@ -339,50 +336,3 @@ pub fn reverse_postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> ReversePostorderIter\n     let len = blocks.len();\n     ReversePostorderIter { body, blocks, idx: len }\n }\n-\n-#[derive(Clone, Debug)]\n-pub(super) struct PostorderCache {\n-    cache: OnceCell<Vec<BasicBlock>>,\n-}\n-\n-impl PostorderCache {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        PostorderCache { cache: OnceCell::new() }\n-    }\n-\n-    /// Invalidates the postorder cache.\n-    #[inline]\n-    pub(super) fn invalidate(&mut self) {\n-        self.cache = OnceCell::new();\n-    }\n-\n-    /// Returns the `&[BasicBlocks]` represents the postorder graph for this MIR.\n-    #[inline]\n-    pub(super) fn compute(&self, body: &IndexVec<BasicBlock, BasicBlockData<'_>>) -> &[BasicBlock] {\n-        self.cache.get_or_init(|| Postorder::new(body, START_BLOCK).map(|(bb, _)| bb).collect())\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for PostorderCache {\n-    #[inline]\n-    fn encode(&self, _s: &mut S) {}\n-}\n-\n-impl<D: Decoder> Decodable<D> for PostorderCache {\n-    #[inline]\n-    fn decode(_: &mut D) -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for PostorderCache {\n-    #[inline]\n-    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n-        // do nothing\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    PostorderCache,\n-}"}, {"sha": "d44c6809bd8305da53c92e7b9c0878475781bec4", "filename": "compiler/rustc_middle/src/mir/type_visitable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -4,6 +4,6 @@ use super::*;\n \n impl<'tcx, R: Idx, C: Idx> TypeVisitable<'tcx> for BitMatrix<R, C> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }"}, {"sha": "6bbf7fa3914e69ea746a5607cae04b6ad2db1f4e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -177,6 +177,12 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query is_type_alias_impl_trait(key: DefId) -> bool\n+    {\n+        desc { \"determine whether the opaque is a type-alias impl trait\" }\n+        separate_provide_extern\n+    }\n+\n     query analysis(key: ()) -> Result<(), ErrorGuaranteed> {\n         eval_always\n         desc { \"running analysis passes on this crate\" }\n@@ -272,7 +278,7 @@ rustc_queries! {\n     /// ```\n     ///\n     /// Bounds from the parent (e.g. with nested impl trait) are not included.\n-    query item_bounds(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n+    query item_bounds(key: DefId) -> ty::EarlyBinder<&'tcx ty::List<ty::Predicate<'tcx>>> {\n         desc { |tcx| \"elaborating item bounds for `{}`\", tcx.def_path_str(key) }\n     }\n "}, {"sha": "fcc8f457a8b7887296526a2d1093a5b3f86027a6", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -159,18 +159,20 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n             }\n             chalk_ir::TyKind::Array(ty, len) => Some(write!(fmt, \"[{:?}; {:?}]\", ty, len)),\n             chalk_ir::TyKind::Slice(ty) => Some(write!(fmt, \"[{:?}]\", ty)),\n-            chalk_ir::TyKind::Tuple(len, substs) => Some((|| {\n-                write!(fmt, \"(\")?;\n-                for (idx, substitution) in substs.interned().iter().enumerate() {\n-                    if idx == *len && *len != 1 {\n-                        // Don't add a trailing comma if the tuple has more than one element\n-                        write!(fmt, \"{:?}\", substitution)?;\n-                    } else {\n-                        write!(fmt, \"{:?},\", substitution)?;\n+            chalk_ir::TyKind::Tuple(len, substs) => Some(\n+                try {\n+                    write!(fmt, \"(\")?;\n+                    for (idx, substitution) in substs.interned().iter().enumerate() {\n+                        if idx == *len && *len != 1 {\n+                            // Don't add a trailing comma if the tuple has more than one element\n+                            write!(fmt, \"{:?}\", substitution)?;\n+                        } else {\n+                            write!(fmt, \"{:?},\", substitution)?;\n+                        }\n                     }\n-                }\n-                write!(fmt, \")\")\n-            })()),\n+                    write!(fmt, \")\")?;\n+                },\n+            ),\n             _ => None,\n         }\n     }"}, {"sha": "615154a55e586dee13ce18a7e4fbb0d87ea96310", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -8,9 +8,8 @@\n use crate::error::DropCheckOverflow;\n use crate::infer::canonical::{Canonical, QueryResponse};\n use crate::ty::error::TypeError;\n-use crate::ty::subst::{GenericArg, SubstsRef};\n+use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt};\n-use rustc_hir::def_id::DefId;\n use rustc_span::source_map::Span;\n \n pub mod type_op {\n@@ -214,6 +213,5 @@ pub struct NormalizationResult<'tcx> {\n pub enum OutlivesBound<'tcx> {\n     RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n     RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::AliasTy<'tcx>),\n-    RegionSubOpaque(ty::Region<'tcx>, DefId, SubstsRef<'tcx>),\n+    RegionSubAlias(ty::Region<'tcx>, ty::AliasTy<'tcx>),\n }"}, {"sha": "bb7fba3ee7119ad9c00af8c9f4311bfd4d5c11b2", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -37,6 +37,11 @@ impl AssocItem {\n         Ident::new(self.name, tcx.def_ident_span(self.def_id).unwrap())\n     }\n \n+    /// Gets the defaultness of the associated item.\n+    /// To get the default associated type, use the [`type_of`] query on the\n+    /// [`DefId`] of the type.\n+    ///\n+    /// [`type_of`]: crate::ty::TyCtxt::type_of\n     pub fn defaultness(&self, tcx: TyCtxt<'_>) -> hir::Defaultness {\n         tcx.impl_defaultness(self.def_id)\n     }"}, {"sha": "ce04d8d21f4cdf2e4255d13faccc98f781d61681", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1952,6 +1952,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(GeneratorWitness(types))\n     }\n \n+    /// Creates a `&mut Context<'_>` [`Ty`] with erased lifetimes.\n+    pub fn mk_task_context(self) -> Ty<'tcx> {\n+        let context_did = self.require_lang_item(LangItem::Context, None);\n+        let context_adt_ref = self.adt_def(context_did);\n+        let context_substs = self.intern_substs(&[self.lifetimes.re_erased.into()]);\n+        let context_ty = self.mk_adt(context_adt_ref, context_substs);\n+        self.mk_mut_ref(self.lifetimes.re_erased, context_ty)\n+    }\n+\n     #[inline]\n     pub fn mk_ty_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_ty_infer(TyVar(v))"}, {"sha": "4b4518f61e8d39b444bb4716a0ff13cf1966b54d", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -4,20 +4,21 @@ use std::ops::ControlFlow;\n \n use crate::ty::{\n     visit::TypeVisitable, AliasTy, Const, ConstKind, DefIdTree, InferConst, InferTy, Opaque,\n-    PolyTraitPredicate, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n+    PolyTraitPredicate, Projection, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n };\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::WherePredicate;\n use rustc_span::Span;\n use rustc_type_ir::sty::TyKind::*;\n \n impl<'tcx> IntoDiagnosticArg for Ty<'tcx> {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        format!(\"{}\", self).into_diagnostic_arg()\n+        self.to_string().into_diagnostic_arg()\n     }\n }\n \n@@ -443,7 +444,7 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n     type BreakTy = ();\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match t.kind() {\n+        match *t.kind() {\n             Infer(InferTy::TyVar(_)) if self.infer_suggestable => {}\n \n             FnDef(..)\n@@ -458,9 +459,9 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n             }\n \n             Alias(Opaque, AliasTy { def_id, .. }) => {\n-                let parent = self.tcx.parent(*def_id);\n-                if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = self.tcx.def_kind(parent)\n-                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, .. }) = self.tcx.type_of(parent).kind()\n+                let parent = self.tcx.parent(def_id);\n+                if let DefKind::TyAlias | DefKind::AssocTy = self.tcx.def_kind(parent)\n+                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, .. }) = *self.tcx.type_of(parent).kind()\n                     && parent_opaque_def_id == def_id\n                 {\n                     // Okay\n@@ -469,6 +470,12 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n                 }\n             }\n \n+            Alias(Projection, AliasTy { def_id, .. }) => {\n+                if self.tcx.def_kind(def_id) != DefKind::AssocTy {\n+                    return ControlFlow::Break(());\n+                }\n+            }\n+\n             Param(param) => {\n                 // FIXME: It would be nice to make this not use string manipulation,\n                 // but it's pretty hard to do this, since `ty::ParamTy` is missing"}, {"sha": "801ca6004456827daba7eaf84db464e153ac1387", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -341,15 +341,9 @@ impl<'tcx> GenericPredicates<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n-    ) -> InstantiatedPredicates<'tcx> {\n-        InstantiatedPredicates {\n-            predicates: self\n-                .predicates\n-                .iter()\n-                .map(|(p, _)| EarlyBinder(*p).subst(tcx, substs))\n-                .collect(),\n-            spans: self.predicates.iter().map(|(_, sp)| *sp).collect(),\n-        }\n+    ) -> impl Iterator<Item = (Predicate<'tcx>, Span)> + DoubleEndedIterator + ExactSizeIterator\n+    {\n+        EarlyBinder(self.predicates).subst_iter_copied(tcx, substs)\n     }\n \n     #[instrument(level = \"debug\", skip(self, tcx))]"}, {"sha": "7dfcd1bb5074d50863784d5168ca751851dcdd57", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -28,7 +28,6 @@ use crate::ty::util::Discr;\n pub use adt::*;\n pub use assoc::*;\n pub use generics::*;\n-use hir::OpaqueTyOrigin;\n use rustc_ast as ast;\n use rustc_ast::node_id::NodeMap;\n use rustc_attr as attr;\n@@ -39,7 +38,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LocalDefIdMap};\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n@@ -437,7 +436,7 @@ pub struct CrateVariancesMap<'tcx> {\n     /// For each item with generics, maps to a vector of the variance\n     /// of its generics. If an item has no generics, it will have no\n     /// entry.\n-    pub variances: FxHashMap<DefId, &'tcx [ty::Variance]>,\n+    pub variances: DefIdMap<&'tcx [ty::Variance]>,\n }\n \n // Contains information needed to resolve types and (in the future) look up\n@@ -1252,6 +1251,35 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     pub fn is_empty(&self) -> bool {\n         self.predicates.is_empty()\n     }\n+\n+    pub fn iter(&self) -> <&Self as IntoIterator>::IntoIter {\n+        (&self).into_iter()\n+    }\n+}\n+\n+impl<'tcx> IntoIterator for InstantiatedPredicates<'tcx> {\n+    type Item = (Predicate<'tcx>, Span);\n+\n+    type IntoIter = std::iter::Zip<std::vec::IntoIter<Predicate<'tcx>>, std::vec::IntoIter<Span>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        debug_assert_eq!(self.predicates.len(), self.spans.len());\n+        std::iter::zip(self.predicates, self.spans)\n+    }\n+}\n+\n+impl<'a, 'tcx> IntoIterator for &'a InstantiatedPredicates<'tcx> {\n+    type Item = (Predicate<'tcx>, Span);\n+\n+    type IntoIter = std::iter::Zip<\n+        std::iter::Copied<std::slice::Iter<'a, Predicate<'tcx>>>,\n+        std::iter::Copied<std::slice::Iter<'a, Span>>,\n+    >;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        debug_assert_eq!(self.predicates.len(), self.spans.len());\n+        std::iter::zip(self.predicates.iter().copied(), self.spans.iter().copied())\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable, TyEncodable, TyDecodable, Lift)]\n@@ -1316,7 +1344,6 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         // typeck errors have subpar spans for opaque types, so delay error reporting until borrowck.\n         ignore_errors: bool,\n-        origin: OpaqueTyOrigin,\n     ) -> Self {\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n@@ -1332,30 +1359,7 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n         // This zip may have several times the same lifetime in `substs` paired with a different\n         // lifetime from `id_substs`. Simply `collect`ing the iterator is the correct behaviour:\n         // it will pick the last one, which is the one we introduced in the impl-trait desugaring.\n-        let map = substs.iter().zip(id_substs);\n-\n-        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> = match origin {\n-            // HACK: The HIR lowering for async fn does not generate\n-            // any `+ Captures<'x>` bounds for the `impl Future<...>`, so all async fns with lifetimes\n-            // would now fail to compile. We should probably just make hir lowering fill this in properly.\n-            OpaqueTyOrigin::AsyncFn(_) => map.collect(),\n-            OpaqueTyOrigin::FnReturn(_) | OpaqueTyOrigin::TyAlias => {\n-                // Opaque types may only use regions that are bound. So for\n-                // ```rust\n-                // type Foo<'a, 'b, 'c> = impl Trait<'a> + 'b;\n-                // ```\n-                // we may not use `'c` in the hidden type.\n-                let variances = tcx.variances_of(def_id);\n-                debug!(?variances);\n-\n-                map.filter(|(_, v)| {\n-                    let ty::GenericArgKind::Lifetime(lt) = v.unpack() else { return true };\n-                    let ty::ReEarlyBound(ebr) = lt.kind() else { bug!() };\n-                    variances[ebr.index as usize] == ty::Variance::Invariant\n-                })\n-                .collect()\n-            }\n-        };\n+        let map = substs.iter().zip(id_substs).collect();\n         debug!(\"map = {:#?}\", map);\n \n         // Convert the type from the function into a type valid outside\n@@ -2353,6 +2357,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.trait_def(trait_def_id).has_auto_impl\n     }\n \n+    /// Returns `true` if this is a trait alias.\n+    pub fn trait_is_alias(self, trait_def_id: DefId) -> bool {\n+        self.def_kind(trait_def_id) == DefKind::TraitAlias\n+    }\n+\n     pub fn trait_is_coinductive(self, trait_def_id: DefId) -> bool {\n         self.trait_is_auto(trait_def_id) || self.lang_items().sized_trait() == Some(trait_def_id)\n     }"}, {"sha": "24f3d1acff1882e7d42deb256bbf4227c06d6cef", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -52,6 +52,7 @@ trivially_parameterized_over_tcx! {\n     usize,\n     (),\n     u32,\n+    bool,\n     std::string::String,\n     crate::metadata::ModChild,\n     crate::middle::codegen_fn_attrs::CodegenFnAttrs,"}, {"sha": "ae7c20fff0c341d0e8f8e737c75d5dce4cdb9d84", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 18, "deletions": 31, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -393,7 +393,7 @@ pub trait PrettyPrinter<'tcx>:\n         match self.tcx().trimmed_def_paths(()).get(&def_id) {\n             None => Ok((self, false)),\n             Some(symbol) => {\n-                self.write_str(symbol.as_str())?;\n+                write!(self, \"{}\", Ident::with_dummy_span(*symbol))?;\n                 Ok((self, true))\n             }\n         }\n@@ -854,24 +854,7 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n                 p!(\"]\");\n             }\n-            ty::Array(ty, sz) => {\n-                p!(\"[\", print(ty), \"; \");\n-                if self.should_print_verbose() {\n-                    p!(write(\"{:?}\", sz));\n-                } else if let ty::ConstKind::Unevaluated(..) = sz.kind() {\n-                    // Do not try to evaluate unevaluated constants. If we are const evaluating an\n-                    // array length anon const, rustc will (with debug assertions) print the\n-                    // constant's path. Which will end up here again.\n-                    p!(\"_\");\n-                } else if let Some(n) = sz.kind().try_to_bits(self.tcx().data_layout.pointer_size) {\n-                    p!(write(\"{}\", n));\n-                } else if let ty::ConstKind::Param(param) = sz.kind() {\n-                    p!(print(param));\n-                } else {\n-                    p!(\"_\");\n-                }\n-                p!(\"]\")\n-            }\n+            ty::Array(ty, sz) => p!(\"[\", print(ty), \"; \", print(sz), \"]\"),\n             ty::Slice(ty) => p!(\"[\", print(ty), \"]\"),\n         }\n \n@@ -1303,21 +1286,25 @@ pub trait PrettyPrinter<'tcx>:\n         match ct.kind() {\n             ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }) => {\n                 match self.tcx().def_kind(def.did) {\n-                    DefKind::Static(..) | DefKind::Const | DefKind::AssocConst => {\n+                    DefKind::Const | DefKind::AssocConst => {\n                         p!(print_value_path(def.did, substs))\n                     }\n-                    _ => {\n-                        if def.is_local() {\n-                            let span = self.tcx().def_span(def.did);\n-                            if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n-                                p!(write(\"{}\", snip))\n-                            } else {\n-                                print_underscore!()\n-                            }\n+                    DefKind::AnonConst => {\n+                        if def.is_local()\n+                            && let span = self.tcx().def_span(def.did)\n+                            && let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span)\n+                        {\n+                            p!(write(\"{}\", snip))\n                         } else {\n-                            print_underscore!()\n+                            // Do not call `print_value_path` as if a parent of this anon const is an impl it will\n+                            // attempt to print out the impl trait ref i.e. `<T as Trait>::{constant#0}`. This would\n+                            // cause printing to enter an infinite recursion if the anon const is in the self type i.e.\n+                            // `impl<T: Default> Default for [T; 32 - 1 - 1 - 1] {`\n+                            // where we would try to print `<[T; /* print `constant#0` again */] as Default>::{constant#0}`\n+                            p!(write(\"{}::{}\", self.tcx().crate_name(def.did.krate), self.tcx().def_path(def.did).to_string_no_crate_verbose()))\n                         }\n                     }\n+                    defkind => bug!(\"`{:?}` has unexpcted defkind {:?}\", ct, defkind),\n                 }\n             }\n             ty::ConstKind::Infer(infer_ct) => {\n@@ -1339,7 +1326,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::ConstKind::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n             // FIXME(generic_const_exprs):\n             // write out some legible representation of an abstract const?\n-            ty::ConstKind::Expr(_) => p!(\"[Const Expr]\"),\n+            ty::ConstKind::Expr(_) => p!(\"[const expr]\"),\n             ty::ConstKind::Error(_) => p!(\"[const error]\"),\n         };\n         Ok(self)\n@@ -2481,7 +2468,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                 if not_previously_inserted {\n                     ty.super_visit_with(self)\n                 } else {\n-                    ControlFlow::CONTINUE\n+                    ControlFlow::Continue(())\n                 }\n             }\n         }"}, {"sha": "7d4d35b7fdf940fd23ae8924f2db2e9a9b9a376e", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -7,7 +7,7 @@ use crate::mir::{Field, ProjectionKind};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n-use crate::ty::{self, InferConst, Lift, Term, TermKind, Ty, TyCtxt};\n+use crate::ty::{self, AliasTy, InferConst, Lift, Term, TermKind, Ty, TyCtxt};\n use rustc_data_structures::functor::IdFunctor;\n use rustc_hir::def::Namespace;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -180,6 +180,15 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Debug for AliasTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"AliasTy\")\n+            .field(\"substs\", &self.substs)\n+            .field(\"def_id\", &self.def_id)\n+            .finish()\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Atomic structs\n //\n@@ -227,6 +236,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::BoundRegionKind,\n     crate::ty::AssocItem,\n     crate::ty::AssocKind,\n+    crate::ty::AliasKind,\n     crate::ty::Placeholder<crate::ty::BoundRegionKind>,\n     crate::ty::ClosureKind,\n     crate::ty::FreeRegion,\n@@ -357,7 +367,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::AdtDef<'tcx> {\n \n impl<'tcx> TypeVisitable<'tcx> for ty::AdtDef<'tcx> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }\n \n@@ -704,7 +714,7 @@ impl<'tcx> TypeSuperVisitable<'tcx> for Ty<'tcx> {\n             | ty::Placeholder(..)\n             | ty::Param(..)\n             | ty::Never\n-            | ty::Foreign(..) => ControlFlow::CONTINUE,\n+            | ty::Foreign(..) => ControlFlow::Continue(()),\n         }\n     }\n }\n@@ -732,7 +742,7 @@ impl<'tcx> TypeSuperFoldable<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> TypeSuperVisitable<'tcx> for ty::Region<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }\n \n@@ -834,7 +844,7 @@ impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n \n impl<'tcx> TypeVisitable<'tcx> for InferConst<'tcx> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }\n "}, {"sha": "6a7b23e40a7792edb3cb7f72000cbb2f6a7321f3", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -100,6 +100,13 @@ impl BoundRegionKind {\n \n         None\n     }\n+\n+    pub fn get_id(&self) -> Option<DefId> {\n+        match *self {\n+            BoundRegionKind::BrNamed(id, _) => return Some(id),\n+            _ => None,\n+        }\n+    }\n }\n \n pub trait Article {\n@@ -1106,17 +1113,6 @@ impl<'tcx, T> Binder<'tcx, T> {\n         if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n-    pub fn no_bound_vars_ignoring_escaping(self, tcx: TyCtxt<'tcx>) -> Option<T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        if !self.0.has_escaping_bound_vars() {\n-            Some(self.skip_binder())\n-        } else {\n-            self.0.try_fold_with(&mut SkipBindersAt { index: ty::INNERMOST, tcx }).ok()\n-        }\n-    }\n-\n     /// Splits the contents into two things that share the same binder\n     /// level as the original, returning two distinct binders.\n     ///\n@@ -1226,7 +1222,7 @@ impl<'tcx> FallibleTypeFolder<'tcx> for SkipBindersAt<'tcx> {\n /// For a projection, this would be `<Ty as Trait<...>>::N`.\n ///\n /// For an opaque type, there is no explicit syntax.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct AliasTy<'tcx> {\n     /// The parameters of the associated or opaque item.\n@@ -1249,19 +1245,34 @@ pub struct AliasTy<'tcx> {\n     /// aka. `tcx.parent(def_id)`.\n     pub def_id: DefId,\n \n-    /// This field exists to prevent the creation of `ProjectionTy` without using\n+    /// This field exists to prevent the creation of `AliasTy` without using\n     /// [TyCtxt::mk_alias_ty].\n     pub(super) _use_mk_alias_ty_instead: (),\n }\n \n+impl<'tcx> AliasTy<'tcx> {\n+    pub fn kind(self, tcx: TyCtxt<'tcx>) -> ty::AliasKind {\n+        match tcx.def_kind(self.def_id) {\n+            DefKind::AssocTy | DefKind::ImplTraitPlaceholder => ty::Projection,\n+            DefKind::OpaqueTy => ty::Opaque,\n+            kind => bug!(\"unexpected DefKind in AliasTy: {kind:?}\"),\n+        }\n+    }\n+\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        tcx.mk_ty(ty::Alias(self.kind(tcx), self))\n+    }\n+}\n+\n+/// The following methods work only with associated type projections.\n impl<'tcx> AliasTy<'tcx> {\n     pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n         match tcx.def_kind(self.def_id) {\n             DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.def_id),\n             DefKind::ImplTraitPlaceholder => {\n                 tcx.parent(tcx.impl_trait_in_trait_parent(self.def_id))\n             }\n-            kind => bug!(\"unexpected DefKind in ProjectionTy: {kind:?}\"),\n+            kind => bug!(\"expected a projection AliasTy; found {kind:?}\"),\n         }\n     }\n \n@@ -2015,7 +2026,7 @@ impl<'tcx> Ty<'tcx> {\n             type BreakTy = ();\n \n             fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if self.0 == t { ControlFlow::BREAK } else { t.super_visit_with(self) }\n+                if self.0 == t { ControlFlow::Break(()) } else { t.super_visit_with(self) }\n             }\n         }\n "}, {"sha": "a07582fc8ff1ec6e8a859d4642003d90806c8bd0", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -7,6 +7,7 @@ use crate::ty::visit::{TypeVisitable, TypeVisitor};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n use rustc_data_structures::intern::Interned;\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Decodable, Encodable};\n@@ -36,6 +37,12 @@ pub struct GenericArg<'tcx> {\n     marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, ty::Const<'tcx>)>,\n }\n \n+impl<'tcx> IntoDiagnosticArg for GenericArg<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n const TAG_MASK: usize = 0b11;\n const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n@@ -538,6 +545,9 @@ impl<'tcx, T: TypeVisitable<'tcx>> TypeVisitable<'tcx> for &'tcx ty::List<T> {\n /// Similar to [`super::Binder`] except that it tracks early bound generics, i.e. `struct Foo<T>(T)`\n /// needs `T` substituted immediately. This type primarily exists to avoid forgetting to call\n /// `subst`.\n+///\n+/// If you don't have anything to `subst`, you may be looking for\n+/// [`subst_identity`](EarlyBinder::subst_identity) or [`skip_binder`](EarlyBinder::skip_binder).\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[derive(Encodable, Decodable, HashStable)]\n pub struct EarlyBinder<T>(pub T);\n@@ -578,6 +588,14 @@ impl<T> EarlyBinder<T> {\n         EarlyBinder(value)\n     }\n \n+    /// Skips the binder and returns the \"bound\" value.\n+    /// This can be used to extract data that does not depend on generic parameters\n+    /// (e.g., getting the `DefId` of the inner value or getting the number of\n+    /// arguments of an `FnSig`). Otherwise, consider using\n+    /// [`subst_identity`](EarlyBinder::subst_identity).\n+    ///\n+    /// See also [`Binder::skip_binder`](super::Binder::skip_binder), which is\n+    /// the analogous operation on [`super::Binder`].\n     pub fn skip_binder(self) -> T {\n         self.0\n     }\n@@ -639,6 +657,13 @@ where\n     }\n }\n \n+impl<'tcx, I: IntoIterator> ExactSizeIterator for SubstIter<'_, 'tcx, I>\n+where\n+    I::IntoIter: ExactSizeIterator,\n+    I::Item: TypeFoldable<'tcx>,\n+{\n+}\n+\n impl<'tcx, 's, I: IntoIterator> EarlyBinder<I>\n where\n     I::Item: Deref,\n@@ -686,6 +711,14 @@ where\n     }\n }\n \n+impl<'tcx, I: IntoIterator> ExactSizeIterator for SubstIterCopied<'_, 'tcx, I>\n+where\n+    I::IntoIter: ExactSizeIterator,\n+    I::Item: Deref,\n+    <I::Item as Deref>::Target: Copy + TypeFoldable<'tcx>,\n+{\n+}\n+\n pub struct EarlyBinderIter<T> {\n     t: T,\n }\n@@ -714,6 +747,14 @@ impl<'tcx, T: TypeFoldable<'tcx>> ty::EarlyBinder<T> {\n         self.0.fold_with(&mut folder)\n     }\n \n+    /// Makes the identity substitution `T0 => T0, ..., TN => TN`.\n+    /// Conceptually, this converts universally bound variables into placeholders\n+    /// when inside of a given item.\n+    ///\n+    /// For example, consider `for<T> fn foo<T>(){ .. }`:\n+    /// - Outside of `foo`, `T` is bound (represented by the presence of `EarlyBinder`).\n+    /// - Inside of the body of `foo`, we treat `T` as a placeholder by calling\n+    /// `subst_identity` to discharge the `EarlyBinder`.\n     pub fn subst_identity(self) -> T {\n         self.0\n     }"}, {"sha": "2902c6dc556e4140594243d2507e011055bab13a", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,7 +6,12 @@ use crate::{\n         GenericArgKind, InternalSubsts, SubstsRef, Ty, UserSubsts,\n     },\n };\n-use rustc_data_structures::{fx::FxHashMap, sync::Lrc, unord::UnordSet, vec_map::VecMap};\n+use rustc_data_structures::{\n+    fx::FxHashMap,\n+    sync::Lrc,\n+    unord::{UnordItems, UnordSet},\n+    vec_map::VecMap,\n+};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::{\n@@ -20,11 +25,7 @@ use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n use rustc_session::Session;\n use rustc_span::Span;\n-use std::{\n-    collections::hash_map::{self, Entry},\n-    hash::Hash,\n-    iter,\n-};\n+use std::{collections::hash_map::Entry, hash::Hash, iter};\n \n use super::RvalueScopes;\n \n@@ -567,8 +568,15 @@ impl<'a, V> LocalTableInContext<'a, V> {\n         self.data.get(&id.local_id)\n     }\n \n-    pub fn iter(&self) -> hash_map::Iter<'_, hir::ItemLocalId, V> {\n-        self.data.iter()\n+    pub fn items(\n+        &'a self,\n+    ) -> UnordItems<(hir::ItemLocalId, &'a V), impl Iterator<Item = (hir::ItemLocalId, &'a V)>>\n+    {\n+        self.data.items().map(|(id, value)| (*id, value))\n+    }\n+\n+    pub fn items_in_stable_order(&self) -> Vec<(ItemLocalId, &'a V)> {\n+        self.data.to_sorted_stable_ord()\n     }\n }\n \n@@ -605,6 +613,16 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n         validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.remove(&id.local_id)\n     }\n+\n+    pub fn extend(\n+        &mut self,\n+        items: UnordItems<(hir::HirId, V), impl Iterator<Item = (hir::HirId, V)>>,\n+    ) {\n+        self.data.extend(items.map(|(id, value)| {\n+            validate_hir_id_for_typeck_results(self.hir_owner, id);\n+            (id.local_id, value)\n+        }))\n+    }\n }\n \n rustc_index::newtype_index! {"}, {"sha": "d0d1dcc584f1b4f8a6222c6b9574b4e8ad7e13b4", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -659,27 +659,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty::EarlyBinder(self.explicit_item_bounds(def_id))\n     }\n \n-    pub fn bound_item_bounds(\n-        self,\n-        def_id: DefId,\n-    ) -> ty::EarlyBinder<&'tcx ty::List<ty::Predicate<'tcx>>> {\n-        ty::EarlyBinder(self.item_bounds(def_id))\n-    }\n-\n-    pub fn bound_predicates_of(\n-        self,\n-        def_id: DefId,\n-    ) -> ty::EarlyBinder<ty::generics::GenericPredicates<'tcx>> {\n-        ty::EarlyBinder(self.predicates_of(def_id))\n-    }\n-\n-    pub fn bound_explicit_predicates_of(\n-        self,\n-        def_id: DefId,\n-    ) -> ty::EarlyBinder<ty::generics::GenericPredicates<'tcx>> {\n-        ty::EarlyBinder(self.explicit_predicates_of(def_id))\n-    }\n-\n     pub fn bound_impl_subject(self, def_id: DefId) -> ty::EarlyBinder<ty::ImplSubject<'tcx>> {\n         ty::EarlyBinder(self.impl_subject(def_id))\n     }"}, {"sha": "bee3cc4d7cb9bf985a2b3b1583a472a135d51255", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -294,13 +294,13 @@ impl<'tcx> TyCtxt<'tcx> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 match *r {\n                     ty::ReLateBound(debruijn, _) if debruijn < self.outer_index => {\n-                        ControlFlow::CONTINUE\n+                        ControlFlow::Continue(())\n                     }\n                     _ => {\n                         if (self.callback)(r) {\n-                            ControlFlow::BREAK\n+                            ControlFlow::Break(())\n                         } else {\n-                            ControlFlow::CONTINUE\n+                            ControlFlow::Continue(())\n                         }\n                     }\n                 }\n@@ -311,7 +311,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 if ty.flags().intersects(TypeFlags::HAS_FREE_REGIONS) {\n                     ty.super_visit_with(self)\n                 } else {\n-                    ControlFlow::CONTINUE\n+                    ControlFlow::Continue(())\n                 }\n             }\n         }\n@@ -394,7 +394,7 @@ impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n         if t.outer_exclusive_binder() < self.binder_index\n             || !self.visited.insert((self.binder_index, t))\n         {\n-            return ControlFlow::BREAK;\n+            return ControlFlow::Break(());\n         }\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n@@ -512,7 +512,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         if t.outer_exclusive_binder() > self.outer_index {\n             ControlFlow::Break(FoundEscapingVars)\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n \n@@ -524,7 +524,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         if r.bound_at_or_above_binder(self.outer_index) {\n             ControlFlow::Break(FoundEscapingVars)\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n \n@@ -547,7 +547,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         if predicate.outer_exclusive_binder() > self.outer_index {\n             ControlFlow::Break(FoundEscapingVars)\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n }\n@@ -575,7 +575,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n \n@@ -585,7 +585,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n \n@@ -596,7 +596,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n \n@@ -605,7 +605,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         if predicate.flags().intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n }\n@@ -653,7 +653,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // in the normalized form\n         if self.just_constrained {\n             if let ty::Alias(..) = t.kind() {\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Continue(());\n             }\n         }\n \n@@ -666,7 +666,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // in the normalized form\n         if self.just_constrained {\n             if let ty::ConstKind::Unevaluated(..) = c.kind() {\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Continue(());\n             }\n         }\n \n@@ -679,7 +679,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n                 self.regions.insert(br.kind);\n             }\n         }\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }\n \n@@ -726,6 +726,6 @@ impl<'tcx> TypeVisitor<'tcx> for MaxUniverse {\n             );\n         }\n \n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }"}, {"sha": "33fdc1901cd781b2832dbcdf832271ed706d5f8b", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -86,10 +86,10 @@ pub(super) fn build_custom_mir<'tcx>(\n         block_map: FxHashMap::default(),\n     };\n \n-    let res = (|| {\n+    let res: PResult<_> = try {\n         pctxt.parse_args(&params)?;\n-        pctxt.parse_body(expr)\n-    })();\n+        pctxt.parse_body(expr)?;\n+    };\n     if let Err(err) = res {\n         tcx.sess.diagnostic().span_fatal(\n             err.span,"}, {"sha": "0bca02589bce131284365337c70dfa61bcae3596", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -12,6 +12,12 @@ use super::{parse_by_kind, PResult, ParseCtxt};\n impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     pub fn parse_statement(&self, expr_id: ExprId) -> PResult<StatementKind<'tcx>> {\n         parse_by_kind!(self, expr_id, _, \"statement\",\n+            @call(\"mir_storage_live\", args) => {\n+                Ok(StatementKind::StorageLive(self.parse_local(args[0])?))\n+            },\n+            @call(\"mir_storage_dead\", args) => {\n+                Ok(StatementKind::StorageDead(self.parse_local(args[0])?))\n+            },\n             @call(\"mir_retag\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n             },"}, {"sha": "7808368519351b145df87a3b5f38b88f9a584f25", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 //\n                 // it is usually better to focus on `the_value` rather\n                 // than the entirety of block(s) surrounding it.\n-                let adjusted_span = (|| {\n+                let adjusted_span =\n                     if let ExprKind::Block { block } = expr.kind\n                         && let Some(tail_ex) = this.thir[block].expr\n                     {\n@@ -135,10 +135,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             tail_result_is_ignored: true,\n                             span: expr.span,\n                         });\n-                        return Some(expr.span);\n-                    }\n-                    None\n-                })();\n+                        Some(expr.span)\n+                    } else {\n+                        None\n+                    };\n \n                 let temp =\n                     unpack!(block = this.as_temp(block, statement_scope, expr, Mutability::Not));"}, {"sha": "7f81aef1c73217d57f5013678b162a4bce27b82f", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -770,6 +770,8 @@ pub(crate) struct PatternNotCovered<'s, 'tcx> {\n     #[subdiagnostic]\n     pub let_suggestion: Option<SuggestLet>,\n     #[subdiagnostic]\n+    pub misc_suggestion: Option<MiscPatternSuggestion>,\n+    #[subdiagnostic]\n     pub res_defined_here: Option<ResDefinedHere>,\n }\n \n@@ -848,3 +850,16 @@ pub enum SuggestLet {\n         count: usize,\n     },\n }\n+\n+#[derive(Subdiagnostic)]\n+pub enum MiscPatternSuggestion {\n+    #[suggestion(\n+        mir_build_suggest_attempted_int_lit,\n+        code = \"_\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    AttemptedIntegerLiteral {\n+        #[primary_span]\n+        start_span: Span,\n+    },\n+}"}, {"sha": "a428180a4fa8295bb5bac16f0030fd5de8c31406", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -5,7 +5,6 @@\n #![feature(assert_matches)]\n #![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n-#![feature(control_flow_enum)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(min_specialization)]"}, {"sha": "f67f24b43c4d77f680053a394e8885760a69aaf3", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -118,7 +118,7 @@ impl<'mir, 'tcx> TriColorVisitor<BasicBlocks<'tcx>> for Search<'mir, 'tcx> {\n             // A diverging InlineAsm is treated as non-recursing\n             TerminatorKind::InlineAsm { destination, .. } => {\n                 if destination.is_some() {\n-                    ControlFlow::CONTINUE\n+                    ControlFlow::Continue(())\n                 } else {\n                     ControlFlow::Break(NonRecursive)\n                 }\n@@ -132,7 +132,7 @@ impl<'mir, 'tcx> TriColorVisitor<BasicBlocks<'tcx>> for Search<'mir, 'tcx> {\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n             | TerminatorKind::Goto { .. }\n-            | TerminatorKind::SwitchInt { .. } => ControlFlow::CONTINUE,\n+            | TerminatorKind::SwitchInt { .. } => ControlFlow::Continue(()),\n         }\n     }\n \n@@ -145,7 +145,7 @@ impl<'mir, 'tcx> TriColorVisitor<BasicBlocks<'tcx>> for Search<'mir, 'tcx> {\n             }\n         }\n \n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     fn ignore_edge(&mut self, bb: BasicBlock, target: BasicBlock) -> bool {"}, {"sha": "34e637f594842687aaec93b1075bacb16eb8df0b", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,8 +6,9 @@ use super::{PatCtxt, PatternError};\n \n use crate::errors::*;\n \n+use hir::{ExprKind, PatKind};\n use rustc_arena::TypedArena;\n-use rustc_ast::Mutability;\n+use rustc_ast::{LitKind, Mutability};\n use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n@@ -389,7 +390,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             return;\n         }\n \n-        let (inform, interpreted_as_const, res_defined_here,let_suggestion) =\n+        let (inform, interpreted_as_const, res_defined_here,let_suggestion, misc_suggestion) =\n             if let hir::PatKind::Path(hir::QPath::Resolved(\n                 None,\n                 hir::Path {\n@@ -413,6 +414,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                         }\n                     },\n                     None,\n+                    None,\n                 )\n             } else if let Some(span) = sp && self.tcx.sess.source_map().is_span_accessible(span) {\n                 let mut bindings = vec![];\n@@ -426,10 +428,19 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                 let end_span = semi_span.shrink_to_lo();\n                 let count = witnesses.len();\n \n+                // If the pattern to match is an integer literal:\n+                let int_suggestion = if\n+                    let PatKind::Lit(expr) = &pat.kind\n+                    && bindings.is_empty()\n+                    && let ExprKind::Lit(Spanned { node: LitKind::Int(_, _), span }) = expr.kind {\n+                    // Then give a suggestion, the user might've meant to create a binding instead.\n+                    Some(MiscPatternSuggestion::AttemptedIntegerLiteral { start_span: span.shrink_to_lo() })\n+                } else { None };\n+\n                 let let_suggestion = if bindings.is_empty() {SuggestLet::If{start_span, semi_span, count}} else{ SuggestLet::Else{end_span, count }};\n-                (sp.map(|_|Inform), None, None, Some(let_suggestion))\n+                (sp.map(|_|Inform), None, None, Some(let_suggestion), int_suggestion)\n             } else{\n-                (sp.map(|_|Inform), None, None,  None)\n+                (sp.map(|_|Inform), None, None,  None, None)\n             };\n \n         let adt_defined_here = try {\n@@ -453,6 +464,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             _p: (),\n             pattern_ty,\n             let_suggestion,\n+            misc_suggestion,\n             res_defined_here,\n             adt_defined_here,\n         });"}, {"sha": "aba5429da435f84292cb698a9e62d7d6b53b61ba", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -141,27 +141,22 @@ impl IntRange {\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n-            let val = (|| {\n-                match value {\n-                    mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) => {\n-                        // For this specific pattern we can skip a lot of effort and go\n-                        // straight to the result, after doing a bit of checking. (We\n-                        // could remove this branch and just fall through, which\n-                        // is more general but much slower.)\n-                        return scalar.to_bits_or_ptr_internal(target_size).unwrap().left();\n-                    }\n-                    mir::ConstantKind::Ty(c) => match c.kind() {\n-                        ty::ConstKind::Value(_) => bug!(\n-                            \"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\"\n-                        ),\n-                        _ => {}\n-                    },\n-                    _ => {}\n+            let val = if let mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) = value {\n+                // For this specific pattern we can skip a lot of effort and go\n+                // straight to the result, after doing a bit of checking. (We\n+                // could remove this branch and just fall through, which\n+                // is more general but much slower.)\n+                scalar.to_bits_or_ptr_internal(target_size).unwrap().left()?\n+            } else {\n+                if let mir::ConstantKind::Ty(c) = value\n+                    && let ty::ConstKind::Value(_) = c.kind()\n+                {\n+                    bug!(\"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\");\n                 }\n \n                 // This is a more general form of the previous case.\n-                value.try_eval_bits(tcx, param_env, ty)\n-            })()?;\n+                value.try_eval_bits(tcx, param_env, ty)?\n+            };\n             let val = val ^ bias;\n             Some(IntRange { range: val..=val, bias })\n         } else {"}, {"sha": "c54348404536ad10cf8e05e2e2f9cbd2a60b10ed", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -341,11 +341,11 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     if a.is_in_same_bcb(b) {\n                         Some(Ordering::Equal)\n                     } else {\n-                        // Sort equal spans by dominator relationship, in reverse order (so\n-                        // dominators always come after the dominated equal spans). When later\n-                        // comparing two spans in order, the first will either dominate the second,\n-                        // or they will have no dominator relationship.\n-                        self.basic_coverage_blocks.dominators().rank_partial_cmp(b.bcb, a.bcb)\n+                        // Sort equal spans by dominator relationship (so dominators always come\n+                        // before the dominated equal spans). When later comparing two spans in\n+                        // order, the first will either dominate the second, or they will have no\n+                        // dominator relationship.\n+                        self.basic_coverage_blocks.dominators().rank_partial_cmp(a.bcb, b.bcb)\n                     }\n                 } else {\n                     // Sort hi() in reverse order so shorter spans are attempted after longer spans."}, {"sha": "39c61a34afcbdab70fa189af8a82527e35993f7e", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 111, "deletions": 7, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -460,6 +460,104 @@ fn replace_local<'tcx>(\n     new_local\n }\n \n+/// Transforms the `body` of the generator applying the following transforms:\n+///\n+/// - Eliminates all the `get_context` calls that async lowering created.\n+/// - Replace all `Local` `ResumeTy` types with `&mut Context<'_>` (`context_mut_ref`).\n+///\n+/// The `Local`s that have their types replaced are:\n+/// - The `resume` argument itself.\n+/// - The argument to `get_context`.\n+/// - The yielded value of a `yield`.\n+///\n+/// The `ResumeTy` hides a `&mut Context<'_>` behind an unsafe raw pointer, and the\n+/// `get_context` function is being used to convert that back to a `&mut Context<'_>`.\n+///\n+/// Ideally the async lowering would not use the `ResumeTy`/`get_context` indirection,\n+/// but rather directly use `&mut Context<'_>`, however that would currently\n+/// lead to higher-kinded lifetime errors.\n+/// See <https://github.com/rust-lang/rust/issues/105501>.\n+///\n+/// The async lowering step and the type / lifetime inference / checking are\n+/// still using the `ResumeTy` indirection for the time being, and that indirection\n+/// is removed here. After this transform, the generator body only knows about `&mut Context<'_>`.\n+fn transform_async_context<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let context_mut_ref = tcx.mk_task_context();\n+\n+    // replace the type of the `resume` argument\n+    replace_resume_ty_local(tcx, body, Local::new(2), context_mut_ref);\n+\n+    let get_context_def_id = tcx.require_lang_item(LangItem::GetContext, None);\n+\n+    for bb in BasicBlock::new(0)..body.basic_blocks.next_index() {\n+        let bb_data = &body[bb];\n+        if bb_data.is_cleanup {\n+            continue;\n+        }\n+\n+        match &bb_data.terminator().kind {\n+            TerminatorKind::Call { func, .. } => {\n+                let func_ty = func.ty(body, tcx);\n+                if let ty::FnDef(def_id, _) = *func_ty.kind() {\n+                    if def_id == get_context_def_id {\n+                        let local = eliminate_get_context_call(&mut body[bb]);\n+                        replace_resume_ty_local(tcx, body, local, context_mut_ref);\n+                    }\n+                } else {\n+                    continue;\n+                }\n+            }\n+            TerminatorKind::Yield { resume_arg, .. } => {\n+                replace_resume_ty_local(tcx, body, resume_arg.local, context_mut_ref);\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+fn eliminate_get_context_call<'tcx>(bb_data: &mut BasicBlockData<'tcx>) -> Local {\n+    let terminator = bb_data.terminator.take().unwrap();\n+    if let TerminatorKind::Call { mut args, destination, target, .. } = terminator.kind {\n+        let arg = args.pop().unwrap();\n+        let local = arg.place().unwrap().local;\n+\n+        let arg = Rvalue::Use(arg);\n+        let assign = Statement {\n+            source_info: terminator.source_info,\n+            kind: StatementKind::Assign(Box::new((destination, arg))),\n+        };\n+        bb_data.statements.push(assign);\n+        bb_data.terminator = Some(Terminator {\n+            source_info: terminator.source_info,\n+            kind: TerminatorKind::Goto { target: target.unwrap() },\n+        });\n+        local\n+    } else {\n+        bug!();\n+    }\n+}\n+\n+#[cfg_attr(not(debug_assertions), allow(unused))]\n+fn replace_resume_ty_local<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    local: Local,\n+    context_mut_ref: Ty<'tcx>,\n+) {\n+    let local_ty = std::mem::replace(&mut body.local_decls[local].ty, context_mut_ref);\n+    // We have to replace the `ResumeTy` that is used for type and borrow checking\n+    // with `&mut Context<'_>` in MIR.\n+    #[cfg(debug_assertions)]\n+    {\n+        if let ty::Adt(resume_ty_adt, _) = local_ty.kind() {\n+            let expected_adt = tcx.adt_def(tcx.require_lang_item(LangItem::ResumeTy, None));\n+            assert_eq!(*resume_ty_adt, expected_adt);\n+        } else {\n+            panic!(\"expected `ResumeTy`, found `{:?}`\", local_ty);\n+        };\n+    }\n+}\n+\n struct LivenessInfo {\n     /// Which locals are live across any suspension point.\n     saved_locals: GeneratorSavedLocals,\n@@ -1283,13 +1381,13 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             }\n         };\n \n-        let is_async_kind = body.generator_kind().unwrap() != GeneratorKind::Gen;\n+        let is_async_kind = matches!(body.generator_kind(), Some(GeneratorKind::Async(_)));\n         let (state_adt_ref, state_substs) = if is_async_kind {\n             // Compute Poll<return_ty>\n-            let state_did = tcx.require_lang_item(LangItem::Poll, None);\n-            let state_adt_ref = tcx.adt_def(state_did);\n-            let state_substs = tcx.intern_substs(&[body.return_ty().into()]);\n-            (state_adt_ref, state_substs)\n+            let poll_did = tcx.require_lang_item(LangItem::Poll, None);\n+            let poll_adt_ref = tcx.adt_def(poll_did);\n+            let poll_substs = tcx.intern_substs(&[body.return_ty().into()]);\n+            (poll_adt_ref, poll_substs)\n         } else {\n             // Compute GeneratorState<yield_ty, return_ty>\n             let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n@@ -1303,13 +1401,19 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         // RETURN_PLACE then is a fresh unused local with type ret_ty.\n         let new_ret_local = replace_local(RETURN_PLACE, ret_ty, body, tcx);\n \n+        // Replace all occurrences of `ResumeTy` with `&mut Context<'_>` within async bodies.\n+        if is_async_kind {\n+            transform_async_context(tcx, body);\n+        }\n+\n         // We also replace the resume argument and insert an `Assign`.\n         // This is needed because the resume argument `_2` might be live across a `yield`, in which\n         // case there is no `Assign` to it that the transform can turn into a store to the generator\n         // state. After the yield the slot in the generator state would then be uninitialized.\n         let resume_local = Local::new(2);\n-        let new_resume_local =\n-            replace_local(resume_local, body.local_decls[resume_local].ty, body, tcx);\n+        let resume_ty =\n+            if is_async_kind { tcx.mk_task_context() } else { body.local_decls[resume_local].ty };\n+        let new_resume_local = replace_local(resume_local, resume_ty, body, tcx);\n \n         // When first entering the generator, move the resume argument into its new local.\n         let source_info = SourceInfo::outermost(body.span);"}, {"sha": "28c9080d38d7d38720b83e5f27e48ac8916fc803", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -542,6 +542,21 @@ impl<'tcx> Inliner<'tcx> {\n                     destination\n                 };\n \n+                // Always create a local to hold the destination, as `RETURN_PLACE` may appear\n+                // where a full `Place` is not allowed.\n+                let (remap_destination, destination_local) = if let Some(d) = dest.as_local() {\n+                    (false, d)\n+                } else {\n+                    (\n+                        true,\n+                        self.new_call_temp(\n+                            caller_body,\n+                            &callsite,\n+                            destination.ty(caller_body, self.tcx).ty,\n+                        ),\n+                    )\n+                };\n+\n                 // Copy the arguments if needed.\n                 let args: Vec<_> = self.make_call_args(args, &callsite, caller_body, &callee_body);\n \n@@ -560,7 +575,7 @@ impl<'tcx> Inliner<'tcx> {\n                     new_locals: Local::new(caller_body.local_decls.len())..,\n                     new_scopes: SourceScope::new(caller_body.source_scopes.len())..,\n                     new_blocks: BasicBlock::new(caller_body.basic_blocks.len())..,\n-                    destination: dest,\n+                    destination: destination_local,\n                     callsite_scope: caller_body.source_scopes[callsite.source_info.scope].clone(),\n                     callsite,\n                     cleanup_block: cleanup,\n@@ -591,6 +606,16 @@ impl<'tcx> Inliner<'tcx> {\n                     // To avoid repeated O(n) insert, push any new statements to the end and rotate\n                     // the slice once.\n                     let mut n = 0;\n+                    if remap_destination {\n+                        caller_body[block].statements.push(Statement {\n+                            source_info: callsite.source_info,\n+                            kind: StatementKind::Assign(Box::new((\n+                                dest,\n+                                Rvalue::Use(Operand::Move(destination_local.into())),\n+                            ))),\n+                        });\n+                        n += 1;\n+                    }\n                     for local in callee_body.vars_and_temps_iter().rev() {\n                         if !callee_body.local_decls[local].internal\n                             && integrator.always_live_locals.contains(local)\n@@ -959,7 +984,7 @@ struct Integrator<'a, 'tcx> {\n     new_locals: RangeFrom<Local>,\n     new_scopes: RangeFrom<SourceScope>,\n     new_blocks: RangeFrom<BasicBlock>,\n-    destination: Place<'tcx>,\n+    destination: Local,\n     callsite_scope: SourceScopeData<'tcx>,\n     callsite: &'a CallSite<'tcx>,\n     cleanup_block: Option<BasicBlock>,\n@@ -972,7 +997,7 @@ struct Integrator<'a, 'tcx> {\n impl Integrator<'_, '_> {\n     fn map_local(&self, local: Local) -> Local {\n         let new = if local == RETURN_PLACE {\n-            self.destination.local\n+            self.destination\n         } else {\n             let idx = local.index() - 1;\n             if idx < self.args.len() {\n@@ -1053,27 +1078,6 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n         *span = span.fresh_expansion(self.expn_data);\n     }\n \n-    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        for elem in place.projection {\n-            // FIXME: Make sure that return place is not used in an indexing projection, since it\n-            // won't be rebased as it is supposed to be.\n-            assert_ne!(ProjectionElem::Index(RETURN_PLACE), elem);\n-        }\n-\n-        // If this is the `RETURN_PLACE`, we need to rebase any projections onto it.\n-        let dest_proj_len = self.destination.projection.len();\n-        if place.local == RETURN_PLACE && dest_proj_len > 0 {\n-            let mut projs = Vec::with_capacity(dest_proj_len + place.projection.len());\n-            projs.extend(self.destination.projection);\n-            projs.extend(place.projection);\n-\n-            place.projection = self.tcx.intern_place_elems(&*projs);\n-        }\n-        // Handles integrating any locals that occur in the base\n-        // or projections\n-        self.super_place(place, context, location)\n-    }\n-\n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         self.in_cleanup_block = data.is_cleanup;\n         self.super_basic_block_data(block, data);"}, {"sha": "20b7fdcfe6d4d44a5b98de025359fb1ed99b2974", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -487,7 +487,6 @@ fn run_analysis_to_runtime_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>\n fn run_analysis_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let passes: &[&dyn MirPass<'tcx>] = &[\n         &cleanup_post_borrowck::CleanupPostBorrowck,\n-        &simplify_branches::SimplifyConstCondition::new(\"initial\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"early-opt\"),\n         &deref_separator::Derefer,"}, {"sha": "f88155e4fc7928a89b6f7cd8faa9d90cf655d391", "filename": "compiler/rustc_monomorphize/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,5 +1,4 @@\n #![feature(array_windows)]\n-#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "cf13d4584a12429d5f05e07bf28119221e8c46b5", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -300,20 +300,20 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         if !c.has_non_region_param() {\n-            return ControlFlow::CONTINUE;\n+            return ControlFlow::Continue(());\n         }\n \n         match c.kind() {\n             ty::ConstKind::Param(param) => {\n                 debug!(?param);\n                 self.unused_parameters.mark_used(param.index);\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             }\n             ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs })\n                 if matches!(self.tcx.def_kind(def.did), DefKind::AnonConst) =>\n             {\n                 self.visit_child_body(def.did, substs);\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             }\n             _ => c.super_visit_with(self),\n         }\n@@ -322,26 +322,26 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         if !ty.has_non_region_param() {\n-            return ControlFlow::CONTINUE;\n+            return ControlFlow::Continue(());\n         }\n \n         match *ty.kind() {\n             ty::Closure(def_id, substs) | ty::Generator(def_id, substs, ..) => {\n                 debug!(?def_id);\n                 // Avoid cycle errors with generators.\n                 if def_id == self.def_id {\n-                    return ControlFlow::CONTINUE;\n+                    return ControlFlow::Continue(());\n                 }\n \n                 // Consider any generic parameters used by any closures/generators as used in the\n                 // parent.\n                 self.visit_child_body(def_id, substs);\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             }\n             ty::Param(param) => {\n                 debug!(?param);\n                 self.unused_parameters.mark_used(param.index);\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             }\n             _ => ty.super_visit_with(self),\n         }"}, {"sha": "9fe8d9836ba60ca8ecfb16eea7d0383617931c0e", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -52,8 +52,15 @@ pub(crate) fn parse_token_trees<'a>(\n     }\n \n     let cursor = Cursor::new(src);\n-    let string_reader =\n-        StringReader { sess, start_pos, pos: start_pos, src, cursor, override_span };\n+    let string_reader = StringReader {\n+        sess,\n+        start_pos,\n+        pos: start_pos,\n+        src,\n+        cursor,\n+        override_span,\n+        nbsp_is_whitespace: false,\n+    };\n     tokentrees::TokenTreesReader::parse_all_token_trees(string_reader)\n }\n \n@@ -68,6 +75,10 @@ struct StringReader<'a> {\n     /// Cursor for getting lexer tokens.\n     cursor: Cursor<'a>,\n     override_span: Option<Span>,\n+    /// When a \"unknown start of token: \\u{a0}\" has already been emitted earlier\n+    /// in this file, it's safe to treat further occurrences of the non-breaking\n+    /// space character as whitespace.\n+    nbsp_is_whitespace: bool,\n }\n \n impl<'a> StringReader<'a> {\n@@ -239,6 +250,16 @@ impl<'a> StringReader<'a> {\n                     }\n                     let mut it = self.str_from_to_end(start).chars();\n                     let c = it.next().unwrap();\n+                    if c == '\\u{00a0}' {\n+                        // If an error has already been reported on non-breaking\n+                        // space characters earlier in the file, treat all\n+                        // subsequent occurrences as whitespace.\n+                        if self.nbsp_is_whitespace {\n+                            preceded_by_whitespace = true;\n+                            continue;\n+                        }\n+                        self.nbsp_is_whitespace = true;\n+                    }\n                     let repeats = it.take_while(|c1| *c1 == c).count();\n                     let mut err =\n                         self.struct_err_span_char(start, self.pos + Pos::from_usize(repeats * c.len_utf8()), \"unknown start of token\", c);\n@@ -486,7 +507,7 @@ impl<'a> StringReader<'a> {\n \n     /// Slice of the source text from `start` up to but excluding `self.pos`,\n     /// meaning the slice does not include the character `self.ch`.\n-    fn str_from(&self, start: BytePos) -> &str {\n+    fn str_from(&self, start: BytePos) -> &'a str {\n         self.str_from_to(start, self.pos)\n     }\n \n@@ -497,12 +518,12 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Slice of the source text spanning from `start` up to but excluding `end`.\n-    fn str_from_to(&self, start: BytePos, end: BytePos) -> &str {\n+    fn str_from_to(&self, start: BytePos, end: BytePos) -> &'a str {\n         &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n     /// Slice of the source text spanning from `start` until the end\n-    fn str_from_to_end(&self, start: BytePos) -> &str {\n+    fn str_from_to_end(&self, start: BytePos) -> &'a str {\n         &self.src[self.src_index(start)..]\n     }\n "}, {"sha": "34d003ccfa7b4fbde64ca4b7cf6ba25f0341cc30", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 322, "deletions": 320, "changes": 642, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -7,329 +7,331 @@ use rustc_errors::{Applicability, Diagnostic};\n use rustc_span::{symbol::kw, BytePos, Pos, Span};\n \n #[rustfmt::skip] // for line breaks\n-pub(crate) const UNICODE_ARRAY: &[(char, &str, char)] = &[\n-    ('\u2028', \"Line Separator\", ' '),\n-    ('\u2029', \"Paragraph Separator\", ' '),\n-    ('\u1680', \"Ogham Space mark\", ' '),\n-    ('\u2000', \"En Quad\", ' '),\n-    ('\u2001', \"Em Quad\", ' '),\n-    ('\u2002', \"En Space\", ' '),\n-    ('\u2003', \"Em Space\", ' '),\n-    ('\u2004', \"Three-Per-Em Space\", ' '),\n-    ('\u2005', \"Four-Per-Em Space\", ' '),\n-    ('\u2006', \"Six-Per-Em Space\", ' '),\n-    ('\u2008', \"Punctuation Space\", ' '),\n-    ('\u2009', \"Thin Space\", ' '),\n-    ('\u200a', \"Hair Space\", ' '),\n-    ('\u205f', \"Medium Mathematical Space\", ' '),\n-    ('\u00a0', \"No-Break Space\", ' '),\n-    ('\u2007', \"Figure Space\", ' '),\n-    ('\u202f', \"Narrow No-Break Space\", ' '),\n-    ('\u3000', \"Ideographic Space\", ' '),\n-\n-    ('\u07fa', \"Nko Lajanyalan\", '_'),\n-    ('\ufe4d', \"Dashed Low Line\", '_'),\n-    ('\ufe4e', \"Centreline Low Line\", '_'),\n-    ('\ufe4f', \"Wavy Low Line\", '_'),\n-    ('\uff3f', \"Fullwidth Low Line\", '_'),\n-\n-    ('\u2010', \"Hyphen\", '-'),\n-    ('\u2011', \"Non-Breaking Hyphen\", '-'),\n-    ('\u2012', \"Figure Dash\", '-'),\n-    ('\u2013', \"En Dash\", '-'),\n-    ('\u2014', \"Em Dash\", '-'),\n-    ('\ufe58', \"Small Em Dash\", '-'),\n-    ('\u06d4', \"Arabic Full Stop\", '-'),\n-    ('\u2043', \"Hyphen Bullet\", '-'),\n-    ('\u02d7', \"Modifier Letter Minus Sign\", '-'),\n-    ('\u2212', \"Minus Sign\", '-'),\n-    ('\u2796', \"Heavy Minus Sign\", '-'),\n-    ('\u2cba', \"Coptic Letter Dialect-P Ni\", '-'),\n-    ('\u30fc', \"Katakana-Hiragana Prolonged Sound Mark\", '-'),\n-    ('\uff0d', \"Fullwidth Hyphen-Minus\", '-'),\n-    ('\u2015', \"Horizontal Bar\", '-'),\n-    ('\u2500', \"Box Drawings Light Horizontal\", '-'),\n-    ('\u2501', \"Box Drawings Heavy Horizontal\", '-'),\n-    ('\u31d0', \"CJK Stroke H\", '-'),\n-    ('\ua7f7', \"Latin Epigraphic Letter Sideways I\", '-'),\n-    ('\u1173', \"Hangul Jungseong Eu\", '-'),\n-    ('\u3161', \"Hangul Letter Eu\", '-'),\n-    ('\u4e00', \"CJK Unified Ideograph-4E00\", '-'),\n-    ('\u2f00', \"Kangxi Radical One\", '-'),\n-\n-    ('\u060d', \"Arabic Date Separator\", ','),\n-    ('\u066b', \"Arabic Decimal Separator\", ','),\n-    ('\u201a', \"Single Low-9 Quotation Mark\", ','),\n-    ('\u00b8', \"Cedilla\", ','),\n-    ('\ua4f9', \"Lisu Letter Tone Na Po\", ','),\n-    ('\uff0c', \"Fullwidth Comma\", ','),\n-\n-    ('\u037e', \"Greek Question Mark\", ';'),\n-    ('\uff1b', \"Fullwidth Semicolon\", ';'),\n-    ('\ufe14', \"Presentation Form For Vertical Semicolon\", ';'),\n-\n-    ('\u0903', \"Devanagari Sign Visarga\", ':'),\n-    ('\u0a83', \"Gujarati Sign Visarga\", ':'),\n-    ('\uff1a', \"Fullwidth Colon\", ':'),\n-    ('\u0589', \"Armenian Full Stop\", ':'),\n-    ('\u0703', \"Syriac Supralinear Colon\", ':'),\n-    ('\u0704', \"Syriac Sublinear Colon\", ':'),\n-    ('\u16ec', \"Runic Multiple Punctuation\", ':'),\n-    ('\ufe30', \"Presentation Form For Vertical Two Dot Leader\", ':'),\n-    ('\u1803', \"Mongolian Full Stop\", ':'),\n-    ('\u1809', \"Mongolian Manchu Full Stop\", ':'),\n-    ('\u205a', \"Two Dot Punctuation\", ':'),\n-    ('\u05c3', \"Hebrew Punctuation Sof Pasuq\", ':'),\n-    ('\u02f8', \"Modifier Letter Raised Colon\", ':'),\n-    ('\ua789', \"Modifier Letter Colon\", ':'),\n-    ('\u2236', \"Ratio\", ':'),\n-    ('\u02d0', \"Modifier Letter Triangular Colon\", ':'),\n-    ('\ua4fd', \"Lisu Letter Tone Mya Jeu\", ':'),\n-    ('\ufe13', \"Presentation Form For Vertical Colon\", ':'),\n-\n-    ('\uff01', \"Fullwidth Exclamation Mark\", '!'),\n-    ('\u01c3', \"Latin Letter Retroflex Click\", '!'),\n-    ('\u2d51', \"Tifinagh Letter Tuareg Yang\", '!'),\n-    ('\ufe15', \"Presentation Form For Vertical Exclamation Mark\", '!'),\n-\n-    ('\u0294', \"Latin Letter Glottal Stop\", '?'),\n-    ('\u0241', \"Latin Capital Letter Glottal Stop\", '?'),\n-    ('\u097d', \"Devanagari Letter Glottal Stop\", '?'),\n-    ('\u13ae', \"Cherokee Letter He\", '?'),\n-    ('\ua6eb', \"Bamum Letter Ntuu\", '?'),\n-    ('\uff1f', \"Fullwidth Question Mark\", '?'),\n-    ('\ufe16', \"Presentation Form For Vertical Question Mark\", '?'),\n-\n-    ('\ud834\udd6d', \"Musical Symbol Combining Augmentation Dot\", '.'),\n-    ('\u2024', \"One Dot Leader\", '.'),\n-    ('\u0701', \"Syriac Supralinear Full Stop\", '.'),\n-    ('\u0702', \"Syriac Sublinear Full Stop\", '.'),\n-    ('\ua60e', \"Vai Full Stop\", '.'),\n-    ('\ud802\ude50', \"Kharoshthi Punctuation Dot\", '.'),\n-    ('\u0660', \"Arabic-Indic Digit Zero\", '.'),\n-    ('\u06f0', \"Extended Arabic-Indic Digit Zero\", '.'),\n-    ('\ua4f8', \"Lisu Letter Tone Mya Ti\", '.'),\n-    ('\u00b7', \"Middle Dot\", '.'),\n-    ('\u30fb', \"Katakana Middle Dot\", '.'),\n-    ('\uff65', \"Halfwidth Katakana Middle Dot\", '.'),\n-    ('\u16eb', \"Runic Single Punctuation\", '.'),\n-    ('\u0387', \"Greek Ano Teleia\", '.'),\n-    ('\u2e31', \"Word Separator Middle Dot\", '.'),\n-    ('\ud800\udd01', \"Aegean Word Separator Dot\", '.'),\n-    ('\u2022', \"Bullet\", '.'),\n-    ('\u2027', \"Hyphenation Point\", '.'),\n-    ('\u2219', \"Bullet Operator\", '.'),\n-    ('\u22c5', \"Dot Operator\", '.'),\n-    ('\ua78f', \"Latin Letter Sinological Dot\", '.'),\n-    ('\u1427', \"Canadian Syllabics Final Middle Dot\", '.'),\n-    ('\u1427', \"Canadian Syllabics Final Middle Dot\", '.'),\n-    ('\uff0e', \"Fullwidth Full Stop\", '.'),\n-    ('\u3002', \"Ideographic Full Stop\", '.'),\n-    ('\ufe12', \"Presentation Form For Vertical Ideographic Full Stop\", '.'),\n-\n-    ('\u055d', \"Armenian Comma\", '\\''),\n-    ('\uff07', \"Fullwidth Apostrophe\", '\\''),\n-    ('\u2018', \"Left Single Quotation Mark\", '\\''),\n-    ('\u2019', \"Right Single Quotation Mark\", '\\''),\n-    ('\u201b', \"Single High-Reversed-9 Quotation Mark\", '\\''),\n-    ('\u2032', \"Prime\", '\\''),\n-    ('\u2035', \"Reversed Prime\", '\\''),\n-    ('\u055a', \"Armenian Apostrophe\", '\\''),\n-    ('\u05f3', \"Hebrew Punctuation Geresh\", '\\''),\n-    ('`', \"Grave Accent\", '\\''),\n-    ('\u1fef', \"Greek Varia\", '\\''),\n-    ('\uff40', \"Fullwidth Grave Accent\", '\\''),\n-    ('\u00b4', \"Acute Accent\", '\\''),\n-    ('\u0384', \"Greek Tonos\", '\\''),\n-    ('\u1ffd', \"Greek Oxia\", '\\''),\n-    ('\u1fbd', \"Greek Koronis\", '\\''),\n-    ('\u1fbf', \"Greek Psili\", '\\''),\n-    ('\u1ffe', \"Greek Dasia\", '\\''),\n-    ('\u02b9', \"Modifier Letter Prime\", '\\''),\n-    ('\u0374', \"Greek Numeral Sign\", '\\''),\n-    ('\u02c8', \"Modifier Letter Vertical Line\", '\\''),\n-    ('\u02ca', \"Modifier Letter Acute Accent\", '\\''),\n-    ('\u02cb', \"Modifier Letter Grave Accent\", '\\''),\n-    ('\u02f4', \"Modifier Letter Middle Grave Accent\", '\\''),\n-    ('\u02bb', \"Modifier Letter Turned Comma\", '\\''),\n-    ('\u02bd', \"Modifier Letter Reversed Comma\", '\\''),\n-    ('\u02bc', \"Modifier Letter Apostrophe\", '\\''),\n-    ('\u02be', \"Modifier Letter Right Half Ring\", '\\''),\n-    ('\ua78c', \"Latin Small Letter Saltillo\", '\\''),\n-    ('\u05d9', \"Hebrew Letter Yod\", '\\''),\n-    ('\u07f4', \"Nko High Tone Apostrophe\", '\\''),\n-    ('\u07f5', \"Nko Low Tone Apostrophe\", '\\''),\n-    ('\u144a', \"Canadian Syllabics West-Cree P\", '\\''),\n-    ('\u16cc', \"Runic Letter Short-Twig-Sol S\", '\\''),\n-    ('\ud81b\udf51', \"Miao Sign Aspiration\", '\\''),\n-    ('\ud81b\udf52', \"Miao Sign Reformed Voicing\", '\\''),\n-\n-    ('\u1cd3', \"Vedic Sign Nihshvasa\", '\"'),\n-    ('\uff02', \"Fullwidth Quotation Mark\", '\"'),\n-    ('\u201c', \"Left Double Quotation Mark\", '\"'),\n-    ('\u201d', \"Right Double Quotation Mark\", '\"'),\n-    ('\u201f', \"Double High-Reversed-9 Quotation Mark\", '\"'),\n-    ('\u2033', \"Double Prime\", '\"'),\n-    ('\u2036', \"Reversed Double Prime\", '\"'),\n-    ('\u3003', \"Ditto Mark\", '\"'),\n-    ('\u05f4', \"Hebrew Punctuation Gershayim\", '\"'),\n-    ('\u02dd', \"Double Acute Accent\", '\"'),\n-    ('\u02ba', \"Modifier Letter Double Prime\", '\"'),\n-    ('\u02f6', \"Modifier Letter Middle Double Acute Accent\", '\"'),\n-    ('\u02f5', \"Modifier Letter Middle Double Grave Accent\", '\"'),\n-    ('\u02ee', \"Modifier Letter Double Apostrophe\", '\"'),\n-    ('\u05f2', \"Hebrew Ligature Yiddish Double Yod\", '\"'),\n-    ('\u275e', \"Heavy Double Comma Quotation Mark Ornament\", '\"'),\n-    ('\u275d', \"Heavy Double Turned Comma Quotation Mark Ornament\", '\"'),\n-\n-    ('\uff08', \"Fullwidth Left Parenthesis\", '('),\n-    ('\u2768', \"Medium Left Parenthesis Ornament\", '('),\n-    ('\ufd3e', \"Ornate Left Parenthesis\", '('),\n-\n-    ('\uff09', \"Fullwidth Right Parenthesis\", ')'),\n-    ('\u2769', \"Medium Right Parenthesis Ornament\", ')'),\n-    ('\ufd3f', \"Ornate Right Parenthesis\", ')'),\n-\n-    ('\uff3b', \"Fullwidth Left Square Bracket\", '['),\n-    ('\u2772', \"Light Left Tortoise Shell Bracket Ornament\", '['),\n-    ('\u300c', \"Left Corner Bracket\", '['),\n-    ('\u300e', \"Left White Corner Bracket\", '['),\n-    ('\u3010', \"Left Black Lenticular Bracket\", '['),\n-    ('\u3014', \"Left Tortoise Shell Bracket\", '['),\n-    ('\u3016', \"Left White Lenticular Bracket\", '['),\n-    ('\u3018', \"Left White Tortoise Shell Bracket\", '['),\n-    ('\u301a', \"Left White Square Bracket\", '['),\n-\n-    ('\uff3d', \"Fullwidth Right Square Bracket\", ']'),\n-    ('\u2773', \"Light Right Tortoise Shell Bracket Ornament\", ']'),\n-    ('\u300d', \"Right Corner Bracket\", ']'),\n-    ('\u300f', \"Right White Corner Bracket\", ']'),\n-    ('\u3011', \"Right Black Lenticular Bracket\", ']'),\n-    ('\u3015', \"Right Tortoise Shell Bracket\", ']'),\n-    ('\u3017', \"Right White Lenticular Bracket\", ']'),\n-    ('\u3019', \"Right White Tortoise Shell Bracket\", ']'),\n-    ('\u301b', \"Right White Square Bracket\", ']'),\n-\n-    ('\u2774', \"Medium Left Curly Bracket Ornament\", '{'),\n-    ('\ud834\udd14', \"Musical Symbol Brace\", '{'),\n-    ('\uff5b', \"Fullwidth Left Curly Bracket\", '{'),\n-\n-    ('\u2775', \"Medium Right Curly Bracket Ornament\", '}'),\n-    ('\uff5d', \"Fullwidth Right Curly Bracket\", '}'),\n-\n-    ('\u204e', \"Low Asterisk\", '*'),\n-    ('\u066d', \"Arabic Five Pointed Star\", '*'),\n-    ('\u2217', \"Asterisk Operator\", '*'),\n-    ('\ud800\udf1f', \"Old Italic Letter Ess\", '*'),\n-    ('\uff0a', \"Fullwidth Asterisk\", '*'),\n-\n-    ('\u1735', \"Philippine Single Punctuation\", '/'),\n-    ('\u2041', \"Caret Insertion Point\", '/'),\n-    ('\u2215', \"Division Slash\", '/'),\n-    ('\u2044', \"Fraction Slash\", '/'),\n-    ('\u2571', \"Box Drawings Light Diagonal Upper Right To Lower Left\", '/'),\n-    ('\u27cb', \"Mathematical Rising Diagonal\", '/'),\n-    ('\u29f8', \"Big Solidus\", '/'),\n-    ('\ud834\ude3a', \"Greek Instrumental Notation Symbol-47\", '/'),\n-    ('\u31d3', \"CJK Stroke Sp\", '/'),\n-    ('\u3033', \"Vertical Kana Repeat Mark Upper Half\", '/'),\n-    ('\u2cc6', \"Coptic Capital Letter Old Coptic Esh\", '/'),\n-    ('\u30ce', \"Katakana Letter No\", '/'),\n-    ('\u4e3f', \"CJK Unified Ideograph-4E3F\", '/'),\n-    ('\u2f03', \"Kangxi Radical Slash\", '/'),\n-    ('\uff0f', \"Fullwidth Solidus\", '/'),\n-\n-    ('\uff3c', \"Fullwidth Reverse Solidus\", '\\\\'),\n-    ('\ufe68', \"Small Reverse Solidus\", '\\\\'),\n-    ('\u2216', \"Set Minus\", '\\\\'),\n-    ('\u27cd', \"Mathematical Falling Diagonal\", '\\\\'),\n-    ('\u29f5', \"Reverse Solidus Operator\", '\\\\'),\n-    ('\u29f9', \"Big Reverse Solidus\", '\\\\'),\n-    ('\u29f9', \"Greek Vocal Notation Symbol-16\", '\\\\'),\n-    ('\u29f9', \"Greek Instrumental Symbol-48\", '\\\\'),\n-    ('\u31d4', \"CJK Stroke D\", '\\\\'),\n-    ('\u4e36', \"CJK Unified Ideograph-4E36\", '\\\\'),\n-    ('\u2f02', \"Kangxi Radical Dot\", '\\\\'),\n-    ('\u3001', \"Ideographic Comma\", '\\\\'),\n-    ('\u30fd', \"Katakana Iteration Mark\", '\\\\'),\n-\n-    ('\ua778', \"Latin Small Letter Um\", '&'),\n-    ('\uff06', \"Fullwidth Ampersand\", '&'),\n-\n-    ('\u16ed', \"Runic Cross Punctuation\", '+'),\n-    ('\u2795', \"Heavy Plus Sign\", '+'),\n-    ('\ud800\ude9b', \"Lycian Letter H\", '+'),\n-    ('\ufb29', \"Hebrew Letter Alternative Plus Sign\", '+'),\n-    ('\uff0b', \"Fullwidth Plus Sign\", '+'),\n-\n-    ('\u2039', \"Single Left-Pointing Angle Quotation Mark\", '<'),\n-    ('\u276e', \"Heavy Left-Pointing Angle Quotation Mark Ornament\", '<'),\n-    ('\u02c2', \"Modifier Letter Left Arrowhead\", '<'),\n-    ('\ud834\ude36', \"Greek Instrumental Symbol-40\", '<'),\n-    ('\u1438', \"Canadian Syllabics Pa\", '<'),\n-    ('\u16b2', \"Runic Letter Kauna\", '<'),\n-    ('\u276c', \"Medium Left-Pointing Angle Bracket Ornament\", '<'),\n-    ('\u27e8', \"Mathematical Left Angle Bracket\", '<'),\n-    ('\u2329', \"Left-Pointing Angle Bracket\", '<'),\n-    ('\u3008', \"Left Angle Bracket\", '<'),\n-    ('\u31db', \"CJK Stroke Pd\", '<'),\n-    ('\u304f', \"Hiragana Letter Ku\", '<'),\n-    ('\ud847\udfe8', \"CJK Unified Ideograph-21FE8\", '<'),\n-    ('\u300a', \"Left Double Angle Bracket\", '<'),\n-    ('\uff1c', \"Fullwidth Less-Than Sign\", '<'),\n-\n-    ('\u1400', \"Canadian Syllabics Hyphen\", '='),\n-    ('\u2e40', \"Double Hyphen\", '='),\n-    ('\u30a0', \"Katakana-Hiragana Double Hyphen\", '='),\n-    ('\ua4ff', \"Lisu Punctuation Full Stop\", '='),\n-    ('\uff1d', \"Fullwidth Equals Sign\", '='),\n-\n-    ('\u203a', \"Single Right-Pointing Angle Quotation Mark\", '>'),\n-    ('\u276f', \"Heavy Right-Pointing Angle Quotation Mark Ornament\", '>'),\n-    ('\u02c3', \"Modifier Letter Right Arrowhead\", '>'),\n-    ('\ud834\ude37', \"Greek Instrumental Symbol-42\", '>'),\n-    ('\u1433', \"Canadian Syllabics Po\", '>'),\n-    ('\ud81b\udf3f', \"Miao Letter Archaic Zza\", '>'),\n-    ('\u276d', \"Medium Right-Pointing Angle Bracket Ornament\", '>'),\n-    ('\u27e9', \"Mathematical Right Angle Bracket\", '>'),\n-    ('\u232a', \"Right-Pointing Angle Bracket\", '>'),\n-    ('\u3009', \"Right Angle Bracket\", '>'),\n-    ('\u300b', \"Right Double Angle Bracket\", '>'),\n-    ('\uff1e', \"Fullwidth Greater-Than Sign\", '>'),\n+pub(crate) const UNICODE_ARRAY: &[(char, &str, &str)] = &[\n+    ('\u2028', \"Line Separator\", \" \"),\n+    ('\u2029', \"Paragraph Separator\", \" \"),\n+    ('\u1680', \"Ogham Space mark\", \" \"),\n+    ('\u2000', \"En Quad\", \" \"),\n+    ('\u2001', \"Em Quad\", \" \"),\n+    ('\u2002', \"En Space\", \" \"),\n+    ('\u2003', \"Em Space\", \" \"),\n+    ('\u2004', \"Three-Per-Em Space\", \" \"),\n+    ('\u2005', \"Four-Per-Em Space\", \" \"),\n+    ('\u2006', \"Six-Per-Em Space\", \" \"),\n+    ('\u2008', \"Punctuation Space\", \" \"),\n+    ('\u2009', \"Thin Space\", \" \"),\n+    ('\u200a', \"Hair Space\", \" \"),\n+    ('\u205f', \"Medium Mathematical Space\", \" \"),\n+    ('\u00a0', \"No-Break Space\", \" \"),\n+    ('\u2007', \"Figure Space\", \" \"),\n+    ('\u202f', \"Narrow No-Break Space\", \" \"),\n+    ('\u3000', \"Ideographic Space\", \" \"),\n+\n+    ('\u07fa', \"Nko Lajanyalan\", \"_\"),\n+    ('\ufe4d', \"Dashed Low Line\", \"_\"),\n+    ('\ufe4e', \"Centreline Low Line\", \"_\"),\n+    ('\ufe4f', \"Wavy Low Line\", \"_\"),\n+    ('\uff3f', \"Fullwidth Low Line\", \"_\"),\n+\n+    ('\u2010', \"Hyphen\", \"-\"),\n+    ('\u2011', \"Non-Breaking Hyphen\", \"-\"),\n+    ('\u2012', \"Figure Dash\", \"-\"),\n+    ('\u2013', \"En Dash\", \"-\"),\n+    ('\u2014', \"Em Dash\", \"-\"),\n+    ('\ufe58', \"Small Em Dash\", \"-\"),\n+    ('\u06d4', \"Arabic Full Stop\", \"-\"),\n+    ('\u2043', \"Hyphen Bullet\", \"-\"),\n+    ('\u02d7', \"Modifier Letter Minus Sign\", \"-\"),\n+    ('\u2212', \"Minus Sign\", \"-\"),\n+    ('\u2796', \"Heavy Minus Sign\", \"-\"),\n+    ('\u2cba', \"Coptic Letter Dialect-P Ni\", \"-\"),\n+    ('\u30fc', \"Katakana-Hiragana Prolonged Sound Mark\", \"-\"),\n+    ('\uff0d', \"Fullwidth Hyphen-Minus\", \"-\"),\n+    ('\u2015', \"Horizontal Bar\", \"-\"),\n+    ('\u2500', \"Box Drawings Light Horizontal\", \"-\"),\n+    ('\u2501', \"Box Drawings Heavy Horizontal\", \"-\"),\n+    ('\u31d0', \"CJK Stroke H\", \"-\"),\n+    ('\ua7f7', \"Latin Epigraphic Letter Sideways I\", \"-\"),\n+    ('\u1173', \"Hangul Jungseong Eu\", \"-\"),\n+    ('\u3161', \"Hangul Letter Eu\", \"-\"),\n+    ('\u4e00', \"CJK Unified Ideograph-4E00\", \"-\"),\n+    ('\u2f00', \"Kangxi Radical One\", \"-\"),\n+\n+    ('\u060d', \"Arabic Date Separator\", \",\"),\n+    ('\u066b', \"Arabic Decimal Separator\", \",\"),\n+    ('\u201a', \"Single Low-9 Quotation Mark\", \",\"),\n+    ('\u00b8', \"Cedilla\", \",\"),\n+    ('\ua4f9', \"Lisu Letter Tone Na Po\", \",\"),\n+    ('\uff0c', \"Fullwidth Comma\", \",\"),\n+\n+    ('\u037e', \"Greek Question Mark\", \";\"),\n+    ('\uff1b', \"Fullwidth Semicolon\", \";\"),\n+    ('\ufe14', \"Presentation Form For Vertical Semicolon\", \";\"),\n+\n+    ('\u0903', \"Devanagari Sign Visarga\", \":\"),\n+    ('\u0a83', \"Gujarati Sign Visarga\", \":\"),\n+    ('\uff1a', \"Fullwidth Colon\", \":\"),\n+    ('\u0589', \"Armenian Full Stop\", \":\"),\n+    ('\u0703', \"Syriac Supralinear Colon\", \":\"),\n+    ('\u0704', \"Syriac Sublinear Colon\", \":\"),\n+    ('\u16ec', \"Runic Multiple Punctuation\", \":\"),\n+    ('\ufe30', \"Presentation Form For Vertical Two Dot Leader\", \":\"),\n+    ('\u1803', \"Mongolian Full Stop\", \":\"),\n+    ('\u1809', \"Mongolian Manchu Full Stop\", \":\"),\n+    ('\u205a', \"Two Dot Punctuation\", \":\"),\n+    ('\u05c3', \"Hebrew Punctuation Sof Pasuq\", \":\"),\n+    ('\u02f8', \"Modifier Letter Raised Colon\", \":\"),\n+    ('\ua789', \"Modifier Letter Colon\", \":\"),\n+    ('\u2236', \"Ratio\", \":\"),\n+    ('\u02d0', \"Modifier Letter Triangular Colon\", \":\"),\n+    ('\ua4fd', \"Lisu Letter Tone Mya Jeu\", \":\"),\n+    ('\ufe13', \"Presentation Form For Vertical Colon\", \":\"),\n+\n+    ('\uff01', \"Fullwidth Exclamation Mark\", \"!\"),\n+    ('\u01c3', \"Latin Letter Retroflex Click\", \"!\"),\n+    ('\u2d51', \"Tifinagh Letter Tuareg Yang\", \"!\"),\n+    ('\ufe15', \"Presentation Form For Vertical Exclamation Mark\", \"!\"),\n+\n+    ('\u0294', \"Latin Letter Glottal Stop\", \"?\"),\n+    ('\u0241', \"Latin Capital Letter Glottal Stop\", \"?\"),\n+    ('\u097d', \"Devanagari Letter Glottal Stop\", \"?\"),\n+    ('\u13ae', \"Cherokee Letter He\", \"?\"),\n+    ('\ua6eb', \"Bamum Letter Ntuu\", \"?\"),\n+    ('\uff1f', \"Fullwidth Question Mark\", \"?\"),\n+    ('\ufe16', \"Presentation Form For Vertical Question Mark\", \"?\"),\n+\n+    ('\ud834\udd6d', \"Musical Symbol Combining Augmentation Dot\", \".\"),\n+    ('\u2024', \"One Dot Leader\", \".\"),\n+    ('\u0701', \"Syriac Supralinear Full Stop\", \".\"),\n+    ('\u0702', \"Syriac Sublinear Full Stop\", \".\"),\n+    ('\ua60e', \"Vai Full Stop\", \".\"),\n+    ('\ud802\ude50', \"Kharoshthi Punctuation Dot\", \".\"),\n+    ('\u0660', \"Arabic-Indic Digit Zero\", \".\"),\n+    ('\u06f0', \"Extended Arabic-Indic Digit Zero\", \".\"),\n+    ('\ua4f8', \"Lisu Letter Tone Mya Ti\", \".\"),\n+    ('\u00b7', \"Middle Dot\", \".\"),\n+    ('\u30fb', \"Katakana Middle Dot\", \".\"),\n+    ('\uff65', \"Halfwidth Katakana Middle Dot\", \".\"),\n+    ('\u16eb', \"Runic Single Punctuation\", \".\"),\n+    ('\u0387', \"Greek Ano Teleia\", \".\"),\n+    ('\u2e31', \"Word Separator Middle Dot\", \".\"),\n+    ('\ud800\udd01', \"Aegean Word Separator Dot\", \".\"),\n+    ('\u2022', \"Bullet\", \".\"),\n+    ('\u2027', \"Hyphenation Point\", \".\"),\n+    ('\u2219', \"Bullet Operator\", \".\"),\n+    ('\u22c5', \"Dot Operator\", \".\"),\n+    ('\ua78f', \"Latin Letter Sinological Dot\", \".\"),\n+    ('\u1427', \"Canadian Syllabics Final Middle Dot\", \".\"),\n+    ('\u1427', \"Canadian Syllabics Final Middle Dot\", \".\"),\n+    ('\uff0e', \"Fullwidth Full Stop\", \".\"),\n+    ('\u3002', \"Ideographic Full Stop\", \".\"),\n+    ('\ufe12', \"Presentation Form For Vertical Ideographic Full Stop\", \".\"),\n+\n+    ('\u055d', \"Armenian Comma\", \"\\'\"),\n+    ('\uff07', \"Fullwidth Apostrophe\", \"\\'\"),\n+    ('\u2018', \"Left Single Quotation Mark\", \"\\'\"),\n+    ('\u2019', \"Right Single Quotation Mark\", \"\\'\"),\n+    ('\u201b', \"Single High-Reversed-9 Quotation Mark\", \"\\'\"),\n+    ('\u2032', \"Prime\", \"\\'\"),\n+    ('\u2035', \"Reversed Prime\", \"\\'\"),\n+    ('\u055a', \"Armenian Apostrophe\", \"\\'\"),\n+    ('\u05f3', \"Hebrew Punctuation Geresh\", \"\\'\"),\n+    ('`', \"Grave Accent\", \"\\'\"),\n+    ('\u1fef', \"Greek Varia\", \"\\'\"),\n+    ('\uff40', \"Fullwidth Grave Accent\", \"\\'\"),\n+    ('\u00b4', \"Acute Accent\", \"\\'\"),\n+    ('\u0384', \"Greek Tonos\", \"\\'\"),\n+    ('\u1ffd', \"Greek Oxia\", \"\\'\"),\n+    ('\u1fbd', \"Greek Koronis\", \"\\'\"),\n+    ('\u1fbf', \"Greek Psili\", \"\\'\"),\n+    ('\u1ffe', \"Greek Dasia\", \"\\'\"),\n+    ('\u02b9', \"Modifier Letter Prime\", \"\\'\"),\n+    ('\u0374', \"Greek Numeral Sign\", \"\\'\"),\n+    ('\u02c8', \"Modifier Letter Vertical Line\", \"\\'\"),\n+    ('\u02ca', \"Modifier Letter Acute Accent\", \"\\'\"),\n+    ('\u02cb', \"Modifier Letter Grave Accent\", \"\\'\"),\n+    ('\u02f4', \"Modifier Letter Middle Grave Accent\", \"\\'\"),\n+    ('\u02bb', \"Modifier Letter Turned Comma\", \"\\'\"),\n+    ('\u02bd', \"Modifier Letter Reversed Comma\", \"\\'\"),\n+    ('\u02bc', \"Modifier Letter Apostrophe\", \"\\'\"),\n+    ('\u02be', \"Modifier Letter Right Half Ring\", \"\\'\"),\n+    ('\ua78c', \"Latin Small Letter Saltillo\", \"\\'\"),\n+    ('\u05d9', \"Hebrew Letter Yod\", \"\\'\"),\n+    ('\u07f4', \"Nko High Tone Apostrophe\", \"\\'\"),\n+    ('\u07f5', \"Nko Low Tone Apostrophe\", \"\\'\"),\n+    ('\u144a', \"Canadian Syllabics West-Cree P\", \"\\'\"),\n+    ('\u16cc', \"Runic Letter Short-Twig-Sol S\", \"\\'\"),\n+    ('\ud81b\udf51', \"Miao Sign Aspiration\", \"\\'\"),\n+    ('\ud81b\udf52', \"Miao Sign Reformed Voicing\", \"\\'\"),\n+\n+    ('\u1cd3', \"Vedic Sign Nihshvasa\", \"\\\"\"),\n+    ('\uff02', \"Fullwidth Quotation Mark\", \"\\\"\"),\n+    ('\u201c', \"Left Double Quotation Mark\", \"\\\"\"),\n+    ('\u201d', \"Right Double Quotation Mark\", \"\\\"\"),\n+    ('\u201f', \"Double High-Reversed-9 Quotation Mark\", \"\\\"\"),\n+    ('\u2033', \"Double Prime\", \"\\\"\"),\n+    ('\u2036', \"Reversed Double Prime\", \"\\\"\"),\n+    ('\u3003', \"Ditto Mark\", \"\\\"\"),\n+    ('\u05f4', \"Hebrew Punctuation Gershayim\", \"\\\"\"),\n+    ('\u02dd', \"Double Acute Accent\", \"\\\"\"),\n+    ('\u02ba', \"Modifier Letter Double Prime\", \"\\\"\"),\n+    ('\u02f6', \"Modifier Letter Middle Double Acute Accent\", \"\\\"\"),\n+    ('\u02f5', \"Modifier Letter Middle Double Grave Accent\", \"\\\"\"),\n+    ('\u02ee', \"Modifier Letter Double Apostrophe\", \"\\\"\"),\n+    ('\u05f2', \"Hebrew Ligature Yiddish Double Yod\", \"\\\"\"),\n+    ('\u275e', \"Heavy Double Comma Quotation Mark Ornament\", \"\\\"\"),\n+    ('\u275d', \"Heavy Double Turned Comma Quotation Mark Ornament\", \"\\\"\"),\n+\n+    ('\uff08', \"Fullwidth Left Parenthesis\", \"(\"),\n+    ('\u2768', \"Medium Left Parenthesis Ornament\", \"(\"),\n+    ('\ufd3e', \"Ornate Left Parenthesis\", \"(\"),\n+\n+    ('\uff09', \"Fullwidth Right Parenthesis\", \")\"),\n+    ('\u2769', \"Medium Right Parenthesis Ornament\", \")\"),\n+    ('\ufd3f', \"Ornate Right Parenthesis\", \")\"),\n+\n+    ('\uff3b', \"Fullwidth Left Square Bracket\", \"[\"),\n+    ('\u2772', \"Light Left Tortoise Shell Bracket Ornament\", \"[\"),\n+    ('\u300c', \"Left Corner Bracket\", \"[\"),\n+    ('\u300e', \"Left White Corner Bracket\", \"[\"),\n+    ('\u3010', \"Left Black Lenticular Bracket\", \"[\"),\n+    ('\u3014', \"Left Tortoise Shell Bracket\", \"[\"),\n+    ('\u3016', \"Left White Lenticular Bracket\", \"[\"),\n+    ('\u3018', \"Left White Tortoise Shell Bracket\", \"[\"),\n+    ('\u301a', \"Left White Square Bracket\", \"[\"),\n+\n+    ('\uff3d', \"Fullwidth Right Square Bracket\", \"]\"),\n+    ('\u2773', \"Light Right Tortoise Shell Bracket Ornament\", \"]\"),\n+    ('\u300d', \"Right Corner Bracket\", \"]\"),\n+    ('\u300f', \"Right White Corner Bracket\", \"]\"),\n+    ('\u3011', \"Right Black Lenticular Bracket\", \"]\"),\n+    ('\u3015', \"Right Tortoise Shell Bracket\", \"]\"),\n+    ('\u3017', \"Right White Lenticular Bracket\", \"]\"),\n+    ('\u3019', \"Right White Tortoise Shell Bracket\", \"]\"),\n+    ('\u301b', \"Right White Square Bracket\", \"]\"),\n+\n+    ('\u2774', \"Medium Left Curly Bracket Ornament\", \"{\"),\n+    ('\ud834\udd14', \"Musical Symbol Brace\", \"{\"),\n+    ('\uff5b', \"Fullwidth Left Curly Bracket\", \"{\"),\n+\n+    ('\u2775', \"Medium Right Curly Bracket Ornament\", \"}\"),\n+    ('\uff5d', \"Fullwidth Right Curly Bracket\", \"}\"),\n+\n+    ('\u204e', \"Low Asterisk\", \"*\"),\n+    ('\u066d', \"Arabic Five Pointed Star\", \"*\"),\n+    ('\u2217', \"Asterisk Operator\", \"*\"),\n+    ('\ud800\udf1f', \"Old Italic Letter Ess\", \"*\"),\n+    ('\uff0a', \"Fullwidth Asterisk\", \"*\"),\n+\n+    ('\u1735', \"Philippine Single Punctuation\", \"/\"),\n+    ('\u2041', \"Caret Insertion Point\", \"/\"),\n+    ('\u2215', \"Division Slash\", \"/\"),\n+    ('\u2044', \"Fraction Slash\", \"/\"),\n+    ('\u2571', \"Box Drawings Light Diagonal Upper Right To Lower Left\", \"/\"),\n+    ('\u27cb', \"Mathematical Rising Diagonal\", \"/\"),\n+    ('\u29f8', \"Big Solidus\", \"/\"),\n+    ('\ud834\ude3a', \"Greek Instrumental Notation Symbol-47\", \"/\"),\n+    ('\u31d3', \"CJK Stroke Sp\", \"/\"),\n+    ('\u3033', \"Vertical Kana Repeat Mark Upper Half\", \"/\"),\n+    ('\u2cc6', \"Coptic Capital Letter Old Coptic Esh\", \"/\"),\n+    ('\u30ce', \"Katakana Letter No\", \"/\"),\n+    ('\u4e3f', \"CJK Unified Ideograph-4E3F\", \"/\"),\n+    ('\u2f03', \"Kangxi Radical Slash\", \"/\"),\n+    ('\uff0f', \"Fullwidth Solidus\", \"/\"),\n+\n+    ('\uff3c', \"Fullwidth Reverse Solidus\", \"\\\\\"),\n+    ('\ufe68', \"Small Reverse Solidus\", \"\\\\\"),\n+    ('\u2216', \"Set Minus\", \"\\\\\"),\n+    ('\u27cd', \"Mathematical Falling Diagonal\", \"\\\\\"),\n+    ('\u29f5', \"Reverse Solidus Operator\", \"\\\\\"),\n+    ('\u29f9', \"Big Reverse Solidus\", \"\\\\\"),\n+    ('\u29f9', \"Greek Vocal Notation Symbol-16\", \"\\\\\"),\n+    ('\u29f9', \"Greek Instrumental Symbol-48\", \"\\\\\"),\n+    ('\u31d4', \"CJK Stroke D\", \"\\\\\"),\n+    ('\u4e36', \"CJK Unified Ideograph-4E36\", \"\\\\\"),\n+    ('\u2f02', \"Kangxi Radical Dot\", \"\\\\\"),\n+    ('\u3001', \"Ideographic Comma\", \"\\\\\"),\n+    ('\u30fd', \"Katakana Iteration Mark\", \"\\\\\"),\n+\n+    ('\ua778', \"Latin Small Letter Um\", \"&\"),\n+    ('\uff06', \"Fullwidth Ampersand\", \"&\"),\n+\n+    ('\u16ed', \"Runic Cross Punctuation\", \"+\"),\n+    ('\u2795', \"Heavy Plus Sign\", \"+\"),\n+    ('\ud800\ude9b', \"Lycian Letter H\", \"+\"),\n+    ('\ufb29', \"Hebrew Letter Alternative Plus Sign\", \"+\"),\n+    ('\uff0b', \"Fullwidth Plus Sign\", \"+\"),\n+\n+    ('\u2039', \"Single Left-Pointing Angle Quotation Mark\", \"<\"),\n+    ('\u276e', \"Heavy Left-Pointing Angle Quotation Mark Ornament\", \"<\"),\n+    ('\u02c2', \"Modifier Letter Left Arrowhead\", \"<\"),\n+    ('\ud834\ude36', \"Greek Instrumental Symbol-40\", \"<\"),\n+    ('\u1438', \"Canadian Syllabics Pa\", \"<\"),\n+    ('\u16b2', \"Runic Letter Kauna\", \"<\"),\n+    ('\u276c', \"Medium Left-Pointing Angle Bracket Ornament\", \"<\"),\n+    ('\u27e8', \"Mathematical Left Angle Bracket\", \"<\"),\n+    ('\u2329', \"Left-Pointing Angle Bracket\", \"<\"),\n+    ('\u3008', \"Left Angle Bracket\", \"<\"),\n+    ('\u31db', \"CJK Stroke Pd\", \"<\"),\n+    ('\u304f', \"Hiragana Letter Ku\", \"<\"),\n+    ('\ud847\udfe8', \"CJK Unified Ideograph-21FE8\", \"<\"),\n+    ('\u300a', \"Left Double Angle Bracket\", \"<\"),\n+    ('\uff1c', \"Fullwidth Less-Than Sign\", \"<\"),\n+\n+    ('\u1400', \"Canadian Syllabics Hyphen\", \"=\"),\n+    ('\u2e40', \"Double Hyphen\", \"=\"),\n+    ('\u30a0', \"Katakana-Hiragana Double Hyphen\", \"=\"),\n+    ('\ua4ff', \"Lisu Punctuation Full Stop\", \"=\"),\n+    ('\uff1d', \"Fullwidth Equals Sign\", \"=\"),\n+\n+    ('\u203a', \"Single Right-Pointing Angle Quotation Mark\", \">\"),\n+    ('\u276f', \"Heavy Right-Pointing Angle Quotation Mark Ornament\", \">\"),\n+    ('\u02c3', \"Modifier Letter Right Arrowhead\", \">\"),\n+    ('\ud834\ude37', \"Greek Instrumental Symbol-42\", \">\"),\n+    ('\u1433', \"Canadian Syllabics Po\", \">\"),\n+    ('\ud81b\udf3f', \"Miao Letter Archaic Zza\", \">\"),\n+    ('\u276d', \"Medium Right-Pointing Angle Bracket Ornament\", \">\"),\n+    ('\u27e9', \"Mathematical Right Angle Bracket\", \">\"),\n+    ('\u232a', \"Right-Pointing Angle Bracket\", \">\"),\n+    ('\u3009', \"Right Angle Bracket\", \">\"),\n+    ('\u300b', \"Right Double Angle Bracket\", \">\"),\n+    ('\uff1e', \"Fullwidth Greater-Than Sign\", \">\"),\n+    ('\u2a75', \"Two Consecutive Equals Signs\", \"==\")\n ];\n \n // FIXME: the lexer could be used to turn the ASCII version of unicode homoglyphs, instead of\n // keeping the substitution token in this table. Ideally, this should be inside `rustc_lexer`.\n // However, we should first remove compound tokens like `<<` from `rustc_lexer`, and then add\n // fancier error recovery to it, as there will be less overall work to do this way.\n-const ASCII_ARRAY: &[(char, &str, Option<token::TokenKind>)] = &[\n-    (' ', \"Space\", None),\n-    ('_', \"Underscore\", Some(token::Ident(kw::Underscore, false))),\n-    ('-', \"Minus/Hyphen\", Some(token::BinOp(token::Minus))),\n-    (',', \"Comma\", Some(token::Comma)),\n-    (';', \"Semicolon\", Some(token::Semi)),\n-    (':', \"Colon\", Some(token::Colon)),\n-    ('!', \"Exclamation Mark\", Some(token::Not)),\n-    ('?', \"Question Mark\", Some(token::Question)),\n-    ('.', \"Period\", Some(token::Dot)),\n-    ('(', \"Left Parenthesis\", Some(token::OpenDelim(Delimiter::Parenthesis))),\n-    (')', \"Right Parenthesis\", Some(token::CloseDelim(Delimiter::Parenthesis))),\n-    ('[', \"Left Square Bracket\", Some(token::OpenDelim(Delimiter::Bracket))),\n-    (']', \"Right Square Bracket\", Some(token::CloseDelim(Delimiter::Bracket))),\n-    ('{', \"Left Curly Brace\", Some(token::OpenDelim(Delimiter::Brace))),\n-    ('}', \"Right Curly Brace\", Some(token::CloseDelim(Delimiter::Brace))),\n-    ('*', \"Asterisk\", Some(token::BinOp(token::Star))),\n-    ('/', \"Slash\", Some(token::BinOp(token::Slash))),\n-    ('\\\\', \"Backslash\", None),\n-    ('&', \"Ampersand\", Some(token::BinOp(token::And))),\n-    ('+', \"Plus Sign\", Some(token::BinOp(token::Plus))),\n-    ('<', \"Less-Than Sign\", Some(token::Lt)),\n-    ('=', \"Equals Sign\", Some(token::Eq)),\n-    ('>', \"Greater-Than Sign\", Some(token::Gt)),\n+const ASCII_ARRAY: &[(&str, &str, Option<token::TokenKind>)] = &[\n+    (\" \", \"Space\", None),\n+    (\"_\", \"Underscore\", Some(token::Ident(kw::Underscore, false))),\n+    (\"-\", \"Minus/Hyphen\", Some(token::BinOp(token::Minus))),\n+    (\",\", \"Comma\", Some(token::Comma)),\n+    (\";\", \"Semicolon\", Some(token::Semi)),\n+    (\":\", \"Colon\", Some(token::Colon)),\n+    (\"!\", \"Exclamation Mark\", Some(token::Not)),\n+    (\"?\", \"Question Mark\", Some(token::Question)),\n+    (\".\", \"Period\", Some(token::Dot)),\n+    (\"(\", \"Left Parenthesis\", Some(token::OpenDelim(Delimiter::Parenthesis))),\n+    (\")\", \"Right Parenthesis\", Some(token::CloseDelim(Delimiter::Parenthesis))),\n+    (\"[\", \"Left Square Bracket\", Some(token::OpenDelim(Delimiter::Bracket))),\n+    (\"]\", \"Right Square Bracket\", Some(token::CloseDelim(Delimiter::Bracket))),\n+    (\"{\", \"Left Curly Brace\", Some(token::OpenDelim(Delimiter::Brace))),\n+    (\"}\", \"Right Curly Brace\", Some(token::CloseDelim(Delimiter::Brace))),\n+    (\"*\", \"Asterisk\", Some(token::BinOp(token::Star))),\n+    (\"/\", \"Slash\", Some(token::BinOp(token::Slash))),\n+    (\"\\\\\", \"Backslash\", None),\n+    (\"&\", \"Ampersand\", Some(token::BinOp(token::And))),\n+    (\"+\", \"Plus Sign\", Some(token::BinOp(token::Plus))),\n+    (\"<\", \"Less-Than Sign\", Some(token::Lt)),\n+    (\"=\", \"Equals Sign\", Some(token::Eq)),\n+    (\"==\", \"Double Equals Sign\", Some(token::EqEq)),\n+    (\">\", \"Greater-Than Sign\", Some(token::Gt)),\n     // FIXME: Literals are already lexed by this point, so we can't recover gracefully just by\n     // spitting the correct token out.\n-    ('\\'', \"Single Quote\", None),\n-    ('\"', \"Quotation Mark\", None),\n+    (\"\\'\", \"Single Quote\", None),\n+    (\"\\\"\", \"Quotation Mark\", None),\n ];\n \n pub(super) fn check_for_substitution<'a>(\n@@ -339,11 +341,11 @@ pub(super) fn check_for_substitution<'a>(\n     err: &mut Diagnostic,\n     count: usize,\n ) -> Option<token::TokenKind> {\n-    let &(_u_char, u_name, ascii_char) = UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch)?;\n+    let &(_, u_name, ascii_str) = UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch)?;\n \n     let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8() * count));\n \n-    let Some((_ascii_char, ascii_name, token)) = ASCII_ARRAY.iter().find(|&&(c, _, _)| c == ascii_char) else {\n+    let Some((_, ascii_name, token)) = ASCII_ARRAY.iter().find(|&&(s, _, _)| s == ascii_str) else {\n         let msg = format!(\"substitution character not found for '{}'\", ch);\n         reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n         return None;\n@@ -354,7 +356,7 @@ pub(super) fn check_for_substitution<'a>(\n         let msg = format!(\n             \"Unicode characters '\u201c' (Left Double Quotation Mark) and \\\n              '\u201d' (Right Double Quotation Mark) look like '{}' ({}), but are not\",\n-            ascii_char, ascii_name\n+            ascii_str, ascii_name\n         );\n         err.span_suggestion(\n             Span::with_root_ctxt(\n@@ -368,12 +370,12 @@ pub(super) fn check_for_substitution<'a>(\n     } else {\n         let msg = format!(\n             \"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n-            ch, u_name, ascii_char, ascii_name\n+            ch, u_name, ascii_str, ascii_name\n         );\n         err.span_suggestion(\n             span,\n             &msg,\n-            ascii_char.to_string().repeat(count),\n+            ascii_str.to_string().repeat(count),\n             Applicability::MaybeIncorrect,\n         );\n     }"}, {"sha": "bf93a89f065557efc5535cc75ad9ad1233047d8b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1353,9 +1353,6 @@ impl<'a> Parser<'a> {\n                 err.span_label(sp, \"while parsing this `loop` expression\");\n                 err\n             })\n-        } else if self.eat_keyword(kw::Continue) {\n-            let kind = ExprKind::Continue(self.eat_label());\n-            Ok(self.mk_expr(lo.to(self.prev_token.span), kind))\n         } else if self.eat_keyword(kw::Match) {\n             let match_sp = self.prev_token.span;\n             self.parse_match_expr().map_err(|mut err| {\n@@ -1379,6 +1376,8 @@ impl<'a> Parser<'a> {\n             self.parse_try_block(lo)\n         } else if self.eat_keyword(kw::Return) {\n             self.parse_return_expr()\n+        } else if self.eat_keyword(kw::Continue) {\n+            self.parse_continue_expr(lo)\n         } else if self.eat_keyword(kw::Break) {\n             self.parse_break_expr()\n         } else if self.eat_keyword(kw::Yield) {\n@@ -1715,10 +1714,10 @@ impl<'a> Parser<'a> {\n     fn parse_break_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let mut label = self.eat_label();\n-        let kind = if label.is_some() && self.token == token::Colon {\n+        let kind = if self.token == token::Colon && let Some(label) = label.take() {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n-            let lexpr = self.parse_labeled_expr(label.take().unwrap(), true)?;\n+            let lexpr = self.parse_labeled_expr(label, true)?;\n             self.sess.emit_err(LabeledLoopInBreak {\n                 span: lexpr.span,\n                 sub: WrapExpressionInParentheses {\n@@ -1730,8 +1729,8 @@ impl<'a> Parser<'a> {\n         } else if self.token != token::OpenDelim(Delimiter::Brace)\n             || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n         {\n-            let expr = self.parse_expr_opt()?;\n-            if let Some(expr) = &expr {\n+            let mut expr = self.parse_expr_opt()?;\n+            if let Some(expr) = &mut expr {\n                 if label.is_some()\n                     && matches!(\n                         expr.kind,\n@@ -1749,7 +1748,19 @@ impl<'a> Parser<'a> {\n                         BuiltinLintDiagnostics::BreakWithLabelAndLoop(expr.span),\n                     );\n                 }\n+\n+                // Recover `break label aaaaa`\n+                if self.may_recover()\n+                    && let ExprKind::Path(None, p) = &expr.kind\n+                    && let [segment] = &*p.segments\n+                    && let &ast::PathSegment { ident, args: None, .. } = segment\n+                    && let Some(next) = self.parse_expr_opt()?\n+                {\n+                    label = Some(self.recover_ident_into_label(ident));\n+                    *expr = next;\n+                }\n             }\n+\n             expr\n         } else {\n             None\n@@ -1758,6 +1769,23 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n+    /// Parse `\"continue\" label?`.\n+    fn parse_continue_expr(&mut self, lo: Span) -> PResult<'a, P<Expr>> {\n+        let mut label = self.eat_label();\n+\n+        // Recover `continue label` -> `continue 'label`\n+        if self.may_recover()\n+            && label.is_none()\n+            && let Some((ident, _)) = self.token.ident()\n+        {\n+            self.bump();\n+            label = Some(self.recover_ident_into_label(ident));\n+        }\n+\n+        let kind = ExprKind::Continue(label);\n+        Ok(self.mk_expr(lo.to(self.prev_token.span), kind))\n+    }\n+\n     /// Parse `\"yield\" expr?`.\n     fn parse_yield_expr(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n@@ -3046,6 +3074,25 @@ impl<'a> Parser<'a> {\n         false\n     }\n \n+    /// Converts an ident into 'label and emits an \"expected a label, found an identifier\" error.\n+    fn recover_ident_into_label(&mut self, ident: Ident) -> Label {\n+        // Convert `label` -> `'label`,\n+        // so that nameres doesn't complain about non-existing label\n+        let label = format!(\"'{}\", ident.name);\n+        let ident = Ident { name: Symbol::intern(&label), span: ident.span };\n+\n+        self.struct_span_err(ident.span, \"expected a label, found an identifier\")\n+            .span_suggestion(\n+                ident.span,\n+                \"labels start with a tick\",\n+                label,\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+\n+        Label { ident }\n+    }\n+\n     /// Parses `ident (COLON expr)?`.\n     fn parse_expr_field(&mut self) -> PResult<'a, ExprField> {\n         let attrs = self.parse_outer_attributes()?;"}, {"sha": "1766b0293de52a33c2eceb3254ecfe0b44e7f0af", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -727,11 +727,13 @@ impl<'a> Parser<'a> {\n         let mut bounds = Vec::new();\n         let mut negative_bounds = Vec::new();\n \n+        // In addition to looping while we find generic bounds:\n+        // We continue even if we find a keyword. This is necessary for error recovery on,\n+        // for example, `impl fn()`. The only keyword that can go after generic bounds is\n+        // `where`, so stop if it's it.\n+        // We also continue if we find types (not traits), again for error recovery.\n         while self.can_begin_bound()\n-            // Continue even if we find a keyword.\n-            // This is necessary for error recover on, for example, `impl fn()`.\n-            //\n-            // The only keyword that can go after generic bounds is `where`, so stop if it's it.\n+            || self.token.can_begin_type()\n             || (self.token.is_reserved_ident() && !self.token.is_keyword(kw::Where))\n         {\n             if self.token.is_keyword(kw::Dyn) {\n@@ -938,6 +940,36 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(1, |tok| tok.kind == TokenKind::OpenDelim(Delimiter::Parenthesis))\n             && let Some(path) = self.recover_path_from_fn()\n         {\n+            path\n+        } else if !self.token.is_path_start() && self.token.can_begin_type() {\n+            let ty = self.parse_ty_no_plus()?;\n+            // Instead of finding a path (a trait), we found a type.\n+            let mut err = self.struct_span_err(ty.span, \"expected a trait, found type\");\n+\n+            // If we can recover, try to extract a path from the type. Note\n+            // that we do not use the try operator when parsing the type because\n+            // if it fails then we get a parser error which we don't want (we're trying\n+            // to recover from errors, not make more).\n+            let path = if self.may_recover()\n+                && matches!(ty.kind, TyKind::Ptr(..) | TyKind::Ref(..))\n+                && let TyKind::Path(_, path) = &ty.peel_refs().kind {\n+                // Just get the indirection part of the type.\n+                let span = ty.span.until(path.span);\n+\n+                err.span_suggestion_verbose(\n+                    span,\n+                    \"consider removing the indirection\",\n+                    \"\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+\n+                path.clone()\n+            } else {\n+                return Err(err);\n+            };\n+\n+            err.emit();\n+\n             path\n         } else {\n             self.parse_path(PathStyle::Type)?"}, {"sha": "7b016cadac320bcb9079fce5db9696b304377cbe", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -20,7 +20,6 @@ pub use Flag::*;\n pub use Piece::*;\n pub use Position::*;\n \n-use rustc_lexer::unescape;\n use std::iter;\n use std::str;\n use std::string;\n@@ -314,11 +313,12 @@ impl<'a> Parser<'a> {\n         append_newline: bool,\n         mode: ParseMode,\n     ) -> Parser<'a> {\n-        let input_string_kind = find_width_map_from_snippet(s, snippet, style);\n+        let input_string_kind = find_width_map_from_snippet(snippet, style);\n         let (width_map, is_literal) = match input_string_kind {\n             InputStringKind::Literal { width_mappings } => (width_mappings, true),\n             InputStringKind::NotALiteral => (Vec::new(), false),\n         };\n+\n         Parser {\n             mode,\n             input: s,\n@@ -856,7 +856,6 @@ impl<'a> Parser<'a> {\n /// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n /// in order to properly synthesise the intra-string `Span`s for error diagnostics.\n fn find_width_map_from_snippet(\n-    input: &str,\n     snippet: Option<string::String>,\n     str_style: Option<usize>,\n ) -> InputStringKind {\n@@ -869,27 +868,8 @@ fn find_width_map_from_snippet(\n         return InputStringKind::Literal { width_mappings: Vec::new() };\n     }\n \n-    // Strip quotes.\n     let snippet = &snippet[1..snippet.len() - 1];\n \n-    // Macros like `println` add a newline at the end. That technically doens't make them \"literals\" anymore, but it's fine\n-    // since we will never need to point our spans there, so we lie about it here by ignoring it.\n-    // Since there might actually be newlines in the source code, we need to normalize away all trailing newlines.\n-    // If we only trimmed it off the input, `format!(\"\\n\")` would cause a mismatch as here we they actually match up.\n-    // Alternatively, we could just count the trailing newlines and only trim one from the input if they don't match up.\n-    let input_no_nl = input.trim_end_matches('\\n');\n-    let Ok(unescaped) = unescape_string(snippet) else {\n-        return InputStringKind::NotALiteral;\n-    };\n-\n-    let unescaped_no_nl = unescaped.trim_end_matches('\\n');\n-\n-    if unescaped_no_nl != input_no_nl {\n-        // The source string that we're pointing at isn't our input, so spans pointing at it will be incorrect.\n-        // This can for example happen with proc macros that respan generated literals.\n-        return InputStringKind::NotALiteral;\n-    }\n-\n     let mut s = snippet.char_indices();\n     let mut width_mappings = vec![];\n     while let Some((pos, c)) = s.next() {\n@@ -972,19 +952,6 @@ fn find_width_map_from_snippet(\n     InputStringKind::Literal { width_mappings }\n }\n \n-fn unescape_string(string: &str) -> Result<string::String, unescape::EscapeError> {\n-    let mut buf = string::String::new();\n-    let mut error = Ok(());\n-    unescape::unescape_literal(string, unescape::Mode::Str, &mut |_, unescaped_char| {\n-        match unescaped_char {\n-            Ok(c) => buf.push(c),\n-            Err(err) => error = Err(err),\n-        }\n-    });\n-\n-    error.map(|_| buf)\n-}\n-\n // Assert a reasonable size for `Piece`\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Piece<'_>, 16);"}, {"sha": "b327ba63330ba8044ddd15daa4bc110a3ab9e023", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -195,7 +195,7 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) {\n \n     // There is no main function.\n     let mut has_filename = true;\n-    let filename = tcx.sess.local_crate_source_file.clone().unwrap_or_else(|| {\n+    let filename = tcx.sess.local_crate_source_file().unwrap_or_else(|| {\n         has_filename = false;\n         Default::default()\n     });"}, {"sha": "4c6a9b23fdf12a9ed33c99f71337ce81c64364d0", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -137,6 +137,12 @@ impl<'tcx> Visitor<'tcx> for LibFeatureCollector<'tcx> {\n }\n \n fn lib_features(tcx: TyCtxt<'_>, (): ()) -> LibFeatures {\n+    // If `staged_api` is not enabled then we aren't allowed to define lib\n+    // features; there is no point collecting them.\n+    if !tcx.features().staged_api {\n+        return new_lib_features();\n+    }\n+\n     let mut collector = LibFeatureCollector::new(tcx);\n     tcx.hir().walk_attributes(&mut collector);\n     collector.lib_features"}, {"sha": "9a5d3cceb914e48643012dd998844f8dc9c20234", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,6 +1,5 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(associated_type_defaults)]\n-#![feature(control_flow_enum)]\n #![feature(rustc_private)]\n #![feature(try_blocks)]\n #![feature(let_chains)]\n@@ -112,7 +111,11 @@ where\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<V::BreakTy> {\n         let TraitRef { def_id, substs, .. } = trait_ref;\n         self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref.print_only_trait_path())?;\n-        if self.def_id_visitor.shallow() { ControlFlow::CONTINUE } else { substs.visit_with(self) }\n+        if self.def_id_visitor.shallow() {\n+            ControlFlow::Continue(())\n+        } else {\n+            substs.visit_with(self)\n+        }\n     }\n \n     fn visit_projection_ty(&mut self, projection: ty::AliasTy<'tcx>) -> ControlFlow<V::BreakTy> {\n@@ -131,7 +134,7 @@ where\n             };\n         self.visit_trait(trait_ref)?;\n         if self.def_id_visitor.shallow() {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         } else {\n             assoc_substs.iter().try_for_each(|subst| subst.visit_with(self))\n         }\n@@ -155,7 +158,7 @@ where\n                 ty,\n                 _region,\n             ))) => ty.visit_with(self),\n-            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..)) => ControlFlow::CONTINUE,\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..)) => ControlFlow::Continue(()),\n             ty::PredicateKind::ConstEvaluatable(ct) => ct.visit_with(self),\n             ty::PredicateKind::WellFormed(arg) => arg.visit_with(self),\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),\n@@ -189,7 +192,7 @@ where\n             | ty::Generator(def_id, ..) => {\n                 self.def_id_visitor.visit_def_id(def_id, \"type\", &ty)?;\n                 if self.def_id_visitor.shallow() {\n-                    return ControlFlow::CONTINUE;\n+                    return ControlFlow::Continue(());\n                 }\n                 // Default type visitor doesn't visit signatures of fn types.\n                 // Something like `fn() -> Priv {my_func}` is considered a private type even if\n@@ -214,7 +217,7 @@ where\n                     // as visible/reachable even if both `Type` and `Trait` are private.\n                     // Ideally, associated types should be substituted in the same way as\n                     // free type aliases, but this isn't done yet.\n-                    return ControlFlow::CONTINUE;\n+                    return ControlFlow::Continue(());\n                 }\n                 // This will also visit substs if necessary, so we don't need to recurse.\n                 return self.visit_projection_ty(proj);\n@@ -274,7 +277,7 @@ where\n         }\n \n         if self.def_id_visitor.shallow() {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         } else {\n             ty.super_visit_with(self)\n         }\n@@ -319,7 +322,7 @@ impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'tcx> for FindMin<'a, 'tcx, VL>\n         if let Some(def_id) = def_id.as_local() {\n             self.min = VL::new_min(self, def_id);\n         }\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }\n \n@@ -881,7 +884,7 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n                 self.ev.update(def_id, self.level);\n             }\n         }\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }\n \n@@ -1368,9 +1371,9 @@ impl<'tcx> DefIdVisitor<'tcx> for TypePrivacyVisitor<'tcx> {\n         descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if self.check_def_id(def_id, kind, descr) {\n-            ControlFlow::BREAK\n+            ControlFlow::Break(())\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n }\n@@ -1865,9 +1868,9 @@ impl<'tcx> DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if self.check_def_id(def_id, kind, descr) {\n-            ControlFlow::BREAK\n+            ControlFlow::Break(())\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n }"}, {"sha": "eae4c9992eb08d4a6c31118b0fb73abf8d5ce2ea", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -28,9 +28,9 @@ use crate::module_to_string;\n use crate::Resolver;\n \n use rustc_ast as ast;\n-use rustc_ast::node_id::NodeMap;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{pluralize, MultiSpan};\n use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -40,7 +40,7 @@ struct UnusedImport<'a> {\n     use_tree: &'a ast::UseTree,\n     use_tree_id: ast::NodeId,\n     item_span: Span,\n-    unused: FxHashSet<ast::NodeId>,\n+    unused: UnordSet<ast::NodeId>,\n }\n \n impl<'a> UnusedImport<'a> {\n@@ -52,7 +52,7 @@ impl<'a> UnusedImport<'a> {\n struct UnusedImportCheckVisitor<'a, 'b> {\n     r: &'a mut Resolver<'b>,\n     /// All the (so far) unused imports, grouped path list\n-    unused_imports: NodeMap<UnusedImport<'a>>,\n+    unused_imports: FxIndexMap<ast::NodeId, UnusedImport<'a>>,\n     base_use_tree: Option<&'a ast::UseTree>,\n     base_id: ast::NodeId,\n     item_span: Span,\n@@ -89,7 +89,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n             use_tree,\n             use_tree_id,\n             item_span,\n-            unused: FxHashSet::default(),\n+            unused: Default::default(),\n         })\n     }\n }"}, {"sha": "36608615255586a45f76d16394429b231285e7ef", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -5,10 +5,10 @@ use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, Crate, ItemKind, ModKind, NodeId, Path, CRATE_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n use rustc_errors::{\n     pluralize, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n+use rustc_errors::{struct_span_err, SuggestionStyle};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n@@ -1033,7 +1033,7 @@ impl<'a> Resolver<'a> {\n                     let root_module = this.resolve_crate_root(root_ident);\n                     this.add_module_candidates(root_module, &mut suggestions, filter_fn, None);\n                 }\n-                Scope::Module(module) => {\n+                Scope::Module(module, _) => {\n                     this.add_module_candidates(module, &mut suggestions, filter_fn, None);\n                 }\n                 Scope::MacroUsePrelude => {\n@@ -2125,9 +2125,15 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n                 let source_map = self.r.session.source_map();\n \n+                // Make sure this is actually crate-relative.\n+                let is_definitely_crate = import\n+                    .module_path\n+                    .first()\n+                    .map_or(false, |f| f.ident.name != kw::SelfLower && f.ident.name != kw::Super);\n+\n                 // Add the import to the start, with a `{` if required.\n                 let start_point = source_map.start_point(after_crate_name);\n-                if let Ok(start_snippet) = source_map.span_to_snippet(start_point) {\n+                if is_definitely_crate && let Ok(start_snippet) = source_map.span_to_snippet(start_point) {\n                     corrections.push((\n                         start_point,\n                         if has_nested {\n@@ -2139,11 +2145,17 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             format!(\"{{{}, {}\", import_snippet, start_snippet)\n                         },\n                     ));\n-                }\n \n-                // Add a `};` to the end if nested, matching the `{` added at the start.\n-                if !has_nested {\n-                    corrections.push((source_map.end_point(after_crate_name), \"};\".to_string()));\n+                    // Add a `};` to the end if nested, matching the `{` added at the start.\n+                    if !has_nested {\n+                        corrections.push((source_map.end_point(after_crate_name), \"};\".to_string()));\n+                    }\n+                } else {\n+                    // If the root import is module-relative, add the import separately\n+                    corrections.push((\n+                        import.use_span.shrink_to_lo(),\n+                        format!(\"use {module_name}::{import_snippet};\\n\"),\n+                    ));\n                 }\n             }\n \n@@ -2418,7 +2430,7 @@ fn show_candidates(\n         }\n \n         if let Some(span) = use_placement_span {\n-            let add_use = match mode {\n+            let (add_use, trailing) = match mode {\n                 DiagnosticMode::Pattern => {\n                     err.span_suggestions(\n                         span,\n@@ -2428,21 +2440,23 @@ fn show_candidates(\n                     );\n                     return;\n                 }\n-                DiagnosticMode::Import => \"\",\n-                DiagnosticMode::Normal => \"use \",\n+                DiagnosticMode::Import => (\"\", \"\"),\n+                DiagnosticMode::Normal => (\"use \", \";\\n\"),\n             };\n             for candidate in &mut accessible_path_strings {\n                 // produce an additional newline to separate the new use statement\n                 // from the directly following item.\n-                let additional_newline = if let FoundUse::Yes = found_use { \"\" } else { \"\\n\" };\n-                candidate.0 = format!(\"{add_use}{}{append};\\n{additional_newline}\", &candidate.0);\n+                let additional_newline = if let FoundUse::No = found_use && let DiagnosticMode::Normal = mode { \"\\n\" } else { \"\" };\n+                candidate.0 =\n+                    format!(\"{add_use}{}{append}{trailing}{additional_newline}\", &candidate.0);\n             }\n \n-            err.span_suggestions(\n+            err.span_suggestions_with_style(\n                 span,\n                 &msg,\n                 accessible_path_strings.into_iter().map(|a| a.0),\n                 Applicability::MaybeIncorrect,\n+                SuggestionStyle::ShowAlways,\n             );\n             if let [first, .., last] = &path[..] {\n                 let sp = first.ident.span.until(last.ident.span);\n@@ -2463,7 +2477,7 @@ fn show_candidates(\n                 msg.push_str(&candidate.0);\n             }\n \n-            err.note(&msg);\n+            err.help(&msg);\n         }\n     } else if !matches!(mode, DiagnosticMode::Import) {\n         assert!(!inaccessible_path_strings.is_empty());"}, {"sha": "a84652a315dc2d5ef95b197acee8025c6e088ebb", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,9 +1,11 @@\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, NodeId};\n use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{DefKind, Namespace, NonMacroAttrKind, PartialRes, PerNS};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n use rustc_middle::ty;\n+use rustc_session::lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext};\n@@ -99,7 +101,7 @@ impl<'a> Resolver<'a> {\n         };\n         let mut scope = match ns {\n             _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(module),\n+            TypeNS | ValueNS => Scope::Module(module, None),\n             MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n         };\n         let mut ctxt = ctxt.normalize_to_macros_2_0();\n@@ -163,7 +165,7 @@ impl<'a> Resolver<'a> {\n                     MacroRulesScope::Invocation(invoc_id) => {\n                         Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n                     }\n-                    MacroRulesScope::Empty => Scope::Module(module),\n+                    MacroRulesScope::Empty => Scope::Module(module, None),\n                 },\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n@@ -172,10 +174,16 @@ impl<'a> Resolver<'a> {\n                     }\n                     ValueNS | MacroNS => break,\n                 },\n-                Scope::Module(module) => {\n+                Scope::Module(module, prev_lint_id) => {\n                     use_prelude = !module.no_implicit_prelude;\n-                    match self.hygienic_lexical_parent(module, &mut ctxt) {\n-                        Some(parent_module) => Scope::Module(parent_module),\n+                    let derive_fallback_lint_id = match scope_set {\n+                        ScopeSet::Late(.., lint_id) => lint_id,\n+                        _ => None,\n+                    };\n+                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n+                        Some((parent_module, lint_id)) => {\n+                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n+                        }\n                         None => {\n                             ctxt.adjust(ExpnId::root());\n                             match ns {\n@@ -207,13 +215,45 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         module: Module<'a>,\n         ctxt: &mut SyntaxContext,\n-    ) -> Option<Module<'a>> {\n+        derive_fallback_lint_id: Option<NodeId>,\n+    ) -> Option<(Module<'a>, Option<NodeId>)> {\n         if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n-            return Some(self.expn_def_scope(ctxt.remove_mark()));\n+            return Some((self.expn_def_scope(ctxt.remove_mark()), None));\n         }\n \n         if let ModuleKind::Block = module.kind {\n-            return Some(module.parent.unwrap().nearest_item_scope());\n+            return Some((module.parent.unwrap().nearest_item_scope(), None));\n+        }\n+\n+        // We need to support the next case under a deprecation warning\n+        // ```\n+        // struct MyStruct;\n+        // ---- begin: this comes from a proc macro derive\n+        // mod implementation_details {\n+        //     // Note that `MyStruct` is not in scope here.\n+        //     impl SomeTrait for MyStruct { ... }\n+        // }\n+        // ---- end\n+        // ```\n+        // So we have to fall back to the module's parent during lexical resolution in this case.\n+        if derive_fallback_lint_id.is_some() {\n+            if let Some(parent) = module.parent {\n+                // Inner module is inside the macro, parent module is outside of the macro.\n+                if module.expansion != parent.expansion\n+                    && module.expansion.is_descendant_of(parent.expansion)\n+                {\n+                    // The macro is a proc macro derive\n+                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n+                        let ext = self.get_macro_by_def_id(def_id).ext;\n+                        if ext.builtin_name.is_none()\n+                            && ext.macro_kind() == MacroKind::Derive\n+                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n+                        {\n+                            return Some((parent, derive_fallback_lint_id));\n+                        }\n+                    }\n+                }\n+            }\n         }\n \n         None\n@@ -470,7 +510,7 @@ impl<'a> Resolver<'a> {\n                             Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                         }\n                     }\n-                    Scope::Module(module) => {\n+                    Scope::Module(module, derive_fallback_lint_id) => {\n                         let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n                         let binding = this.resolve_ident_in_module_unadjusted_ext(\n                             ModuleOrUniformRoot::Module(module),\n@@ -483,6 +523,21 @@ impl<'a> Resolver<'a> {\n                         );\n                         match binding {\n                             Ok(binding) => {\n+                                if let Some(lint_id) = derive_fallback_lint_id {\n+                                    this.lint_buffer.buffer_lint_with_diagnostic(\n+                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+                                        lint_id,\n+                                        orig_ident.span,\n+                                        &format!(\n+                                            \"cannot find {} `{}` in this scope\",\n+                                            ns.descr(),\n+                                            ident\n+                                        ),\n+                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n+                                            orig_ident.span,\n+                                        ),\n+                                    );\n+                                }\n                                 let misc_flags = if ptr::eq(module, this.graph_root) {\n                                     Flags::MISC_SUGGEST_CRATE\n                                 } else if module.is_normal() {"}, {"sha": "83932c089b311afba738f9e3fb9ff652befe1079", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -3373,7 +3373,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         sugg.to_string(),\n                         Applicability::MaybeIncorrect,\n                     ))\n-                } else if res.is_none() {\n+                } else if res.is_none() && matches!(source, PathSource::Type) {\n                     this.report_missing_type_error(path)\n                 } else {\n                     None"}, {"sha": "6d448433ee6dbc940bdcde726b3a9f25efbe8997", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -2188,15 +2188,31 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             let deletion_span = || {\n                 if params.len() == 1 {\n                     // if sole lifetime, remove the entire `<>` brackets\n-                    generics_span\n+                    Some(generics_span)\n                 } else if param_index == 0 {\n                     // if removing within `<>` brackets, we also want to\n                     // delete a leading or trailing comma as appropriate\n-                    param.span().to(params[param_index + 1].span().shrink_to_lo())\n+                    match (\n+                        param.span().find_ancestor_inside(generics_span),\n+                        params[param_index + 1].span().find_ancestor_inside(generics_span),\n+                    ) {\n+                        (Some(param_span), Some(next_param_span)) => {\n+                            Some(param_span.to(next_param_span.shrink_to_lo()))\n+                        }\n+                        _ => None,\n+                    }\n                 } else {\n                     // if removing within `<>` brackets, we also want to\n                     // delete a leading or trailing comma as appropriate\n-                    params[param_index - 1].span().shrink_to_hi().to(param.span())\n+                    match (\n+                        param.span().find_ancestor_inside(generics_span),\n+                        params[param_index - 1].span().find_ancestor_inside(generics_span),\n+                    ) {\n+                        (Some(param_span), Some(prev_param_span)) => {\n+                            Some(prev_param_span.shrink_to_hi().to(param_span))\n+                        }\n+                        _ => None,\n+                    }\n                 }\n             };\n             match use_set {"}, {"sha": "1b181b714005bd7177d2a1cd1ce29358301d6020", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -105,7 +105,9 @@ enum Scope<'a> {\n     DeriveHelpersCompat,\n     MacroRules(MacroRulesScopeRef<'a>),\n     CrateRoot,\n-    Module(Module<'a>),\n+    // The node ID is for reporting the `PROC_MACRO_DERIVE_RESOLUTION_FALLBACK`\n+    // lint if it should be reported.\n+    Module(Module<'a>, Option<NodeId>),\n     MacroUsePrelude,\n     BuiltinAttrs,\n     ExternPrelude,\n@@ -1591,7 +1593,7 @@ impl<'a> Resolver<'a> {\n \n         self.visit_scopes(ScopeSet::All(TypeNS, false), parent_scope, ctxt, |this, scope, _, _| {\n             match scope {\n-                Scope::Module(module) => {\n+                Scope::Module(module, _) => {\n                     this.traits_in_module(module, assoc_item, &mut found_traits);\n                 }\n                 Scope::StdLibPrelude => {"}, {"sha": "a5f09de1c401ba0c86fac6d1df3953b109de29fa", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -112,9 +112,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     }\n \n     pub fn dump_crate_info(&mut self, name: Symbol) {\n-        let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n-        let crate_root = source_file.map(|source_file| {\n-            let source_file = Path::new(source_file);\n+        let crate_root = self.tcx.sess.local_crate_source_file().map(|source_file| {\n             match source_file.file_name() {\n                 Some(_) => source_file.parent().unwrap().display(),\n                 None => source_file.display(),\n@@ -157,10 +155,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 .enumerate()\n                 .filter(|(i, _)| !remap_arg_indices.contains(i))\n                 .map(|(_, arg)| match input {\n-                    Input::File(ref path) if path == Path::new(&arg) => {\n-                        let mapped = &self.tcx.sess.local_crate_source_file;\n-                        mapped.as_ref().unwrap().to_string_lossy().into()\n-                    }\n+                    Input::File(ref path) if path == Path::new(&arg) => self\n+                        .tcx\n+                        .sess\n+                        .local_crate_source_file()\n+                        .as_ref()\n+                        .unwrap()\n+                        .to_string_lossy()\n+                        .into(),\n                     _ => arg,\n                 });\n "}, {"sha": "e65d57bb3db3e7737ffbc18b8670df244346be6f", "filename": "compiler/rustc_save_analysis/src/span_utils.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -18,13 +18,7 @@ impl<'a> SpanUtils<'a> {\n         match &file.name {\n             FileName::Real(RealFileName::LocalPath(path)) => {\n                 if path.is_absolute() {\n-                    self.sess\n-                        .source_map()\n-                        .path_mapping()\n-                        .map_prefix(path.into())\n-                        .0\n-                        .display()\n-                        .to_string()\n+                    self.sess.source_map().path_mapping().map_prefix(path).0.display().to_string()\n                 } else {\n                     self.sess\n                         .opts"}, {"sha": "586454f76574c5b2ad62a7075674da3e9da39cd2", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -591,6 +591,24 @@ impl Input {\n             Input::Str { ref name, .. } => name.clone(),\n         }\n     }\n+\n+    pub fn opt_path(&self) -> Option<&Path> {\n+        match self {\n+            Input::File(file) => Some(file),\n+            Input::Str { name, .. } => match name {\n+                FileName::Real(real) => real.local_path(),\n+                FileName::QuoteExpansion(_) => None,\n+                FileName::Anon(_) => None,\n+                FileName::MacroExpansion(_) => None,\n+                FileName::ProcMacroSourceCode(_) => None,\n+                FileName::CfgSpec(_) => None,\n+                FileName::CliCrateAttr(_) => None,\n+                FileName::Custom(_) => None,\n+                FileName::DocTest(path, _) => Some(path),\n+                FileName::InlineAsm(_) => None,\n+            },\n+        }\n+    }\n }\n \n #[derive(Clone, Hash, Debug, HashStable_Generic)]\n@@ -2459,6 +2477,11 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let pretty = parse_pretty(&unstable_opts, error_format);\n \n+    // query-dep-graph is required if dump-dep-graph is given #106736\n+    if unstable_opts.dump_dep_graph && !unstable_opts.query_dep_graph {\n+        early_error(error_format, \"can't dump dependency graph without `-Z query-dep-graph`\");\n+    }\n+\n     // Try to find a directory containing the Rust `src`, for more details see\n     // the doc comment on the `real_rust_source_base_dir` field.\n     let tmp_buf;\n@@ -2491,12 +2514,12 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         early_error(error_format, &format!(\"Current directory is invalid: {e}\"));\n     });\n \n-    let (path, remapped) =\n-        FilePathMapping::new(remap_path_prefix.clone()).map_prefix(working_dir.clone());\n+    let remap = FilePathMapping::new(remap_path_prefix.clone());\n+    let (path, remapped) = remap.map_prefix(&working_dir);\n     let working_dir = if remapped {\n-        RealFileName::Remapped { local_path: Some(working_dir), virtual_name: path }\n+        RealFileName::Remapped { virtual_name: path.into_owned(), local_path: Some(working_dir) }\n     } else {\n-        RealFileName::LocalPath(path)\n+        RealFileName::LocalPath(path.into_owned())\n     };\n \n     Options {"}, {"sha": "c3f0c4b58f57ad61eb04cbad7be79918950af8e3", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -45,7 +45,7 @@ fn is_writeable(p: &Path) -> bool {\n     }\n }\n \n-pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input) -> Symbol {\n+pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute]) -> Symbol {\n     let validate = |s: Symbol, span: Option<Span>| {\n         validate_crate_name(sess, s, span);\n         s\n@@ -71,7 +71,7 @@ pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input)\n     if let Some((attr, s)) = attr_crate_name {\n         return validate(s, Some(attr.span));\n     }\n-    if let Input::File(ref path) = *input {\n+    if let Input::File(ref path) = sess.io.input {\n         if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n             if s.starts_with('-') {\n                 sess.emit_err(CrateNameInvalid { s });"}, {"sha": "95f199de6ff6ff0c14b781586d20f72c303819b7", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,6 +1,7 @@\n use crate::cgu_reuse_tracker::CguReuseTracker;\n use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n+use crate::config::Input;\n use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n use crate::errors::{\n     BranchProtectionRequiresAArch64, CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers,\n@@ -137,6 +138,13 @@ pub struct Limits {\n     pub const_eval_limit: Limit,\n }\n \n+pub struct CompilerIO {\n+    pub input: Input,\n+    pub output_dir: Option<PathBuf>,\n+    pub output_file: Option<PathBuf>,\n+    pub temps_dir: Option<PathBuf>,\n+}\n+\n /// Represents the data associated with a compilation\n /// session for a single crate.\n pub struct Session {\n@@ -147,9 +155,8 @@ pub struct Session {\n     pub target_tlib_path: Lrc<SearchPath>,\n     pub parse_sess: ParseSess,\n     pub sysroot: PathBuf,\n-    /// The name of the root source file of the crate, in the local file system.\n-    /// `None` means that there is no source file.\n-    pub local_crate_source_file: Option<PathBuf>,\n+    /// Input, input file path and output file path to this compilation process.\n+    pub io: CompilerIO,\n \n     crate_types: OnceCell<Vec<CrateType>>,\n     /// The `stable_crate_id` is constructed out of the crate name and all the\n@@ -228,6 +235,11 @@ impl Session {\n         self.miri_unleashed_features.lock().push((span, feature_gate));\n     }\n \n+    pub fn local_crate_source_file(&self) -> Option<PathBuf> {\n+        let path = self.io.input.opt_path()?;\n+        Some(self.opts.file_path_mapping().map_prefix(path).0.into_owned())\n+    }\n+\n     fn check_miri_unleashed_features(&self) {\n         let unleashed_features = self.miri_unleashed_features.lock();\n         if !unleashed_features.is_empty() {\n@@ -1298,7 +1310,7 @@ fn default_emitter(\n #[allow(rustc::bad_opt_access)]\n pub fn build_session(\n     sopts: config::Options,\n-    local_crate_source_file: Option<PathBuf>,\n+    io: CompilerIO,\n     bundle: Option<Lrc<rustc_errors::FluentBundle>>,\n     registry: rustc_errors::registry::Registry,\n     driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n@@ -1391,11 +1403,6 @@ pub fn build_session(\n         Lrc::new(SearchPath::from_sysroot_and_triple(&sysroot, target_triple))\n     };\n \n-    let file_path_mapping = sopts.file_path_mapping();\n-\n-    let local_crate_source_file =\n-        local_crate_source_file.map(|path| file_path_mapping.map_prefix(path).0);\n-\n     let optimization_fuel = Lock::new(OptimizationFuel {\n         remaining: sopts.unstable_opts.fuel.as_ref().map_or(0, |&(_, i)| i),\n         out_of_fuel: false,\n@@ -1427,7 +1434,7 @@ pub fn build_session(\n         target_tlib_path,\n         parse_sess,\n         sysroot,\n-        local_crate_source_file,\n+        io,\n         crate_types: OnceCell::new(),\n         stable_crate_id: OnceCell::new(),\n         features: OnceCell::new(),"}, {"sha": "2e339a9d2d2b00eca439bdbd4930e9072c1a0e7a", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 74, "deletions": 16, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{AtomicU32, Lrc, MappedReadGuard, ReadGuard, RwLock};\n use std::cmp;\n use std::hash::Hash;\n-use std::path::{Path, PathBuf};\n+use std::path::{self, Path, PathBuf};\n use std::sync::atomic::Ordering;\n \n use std::fs;\n@@ -1071,12 +1071,24 @@ impl SourceMap {\n \n     pub fn ensure_source_file_source_present(&self, source_file: Lrc<SourceFile>) -> bool {\n         source_file.add_external_src(|| {\n-            match source_file.name {\n-                FileName::Real(ref name) if let Some(local_path) = name.local_path() => {\n-                    self.file_loader.read_file(local_path).ok()\n+            let FileName::Real(ref name) = source_file.name else {\n+                return None;\n+            };\n+\n+            let local_path: Cow<'_, Path> = match name {\n+                RealFileName::LocalPath(local_path) => local_path.into(),\n+                RealFileName::Remapped { local_path: Some(local_path), .. } => local_path.into(),\n+                RealFileName::Remapped { local_path: None, virtual_name } => {\n+                    // The compiler produces better error messages if the sources of dependencies\n+                    // are available. Attempt to undo any path mapping so we can find remapped\n+                    // dependencies.\n+                    // We can only use the heuristic because `add_external_src` checks the file\n+                    // content hash.\n+                    self.path_mapping.reverse_map_prefix_heuristically(virtual_name)?.into()\n                 }\n-                _ => None,\n-            }\n+            };\n+\n+            self.file_loader.read_file(&local_path).ok()\n         })\n     }\n \n@@ -1138,7 +1150,8 @@ impl FilePathMapping {\n     /// Applies any path prefix substitution as defined by the mapping.\n     /// The return value is the remapped path and a boolean indicating whether\n     /// the path was affected by the mapping.\n-    pub fn map_prefix(&self, path: PathBuf) -> (PathBuf, bool) {\n+    pub fn map_prefix<'a>(&'a self, path: impl Into<Cow<'a, Path>>) -> (Cow<'a, Path>, bool) {\n+        let path = path.into();\n         if path.as_os_str().is_empty() {\n             // Exit early if the path is empty and therefore there's nothing to remap.\n             // This is mostly to reduce spam for `RUSTC_LOG=[remap_path_prefix]`.\n@@ -1148,7 +1161,10 @@ impl FilePathMapping {\n         return remap_path_prefix(&self.mapping, path);\n \n         #[instrument(level = \"debug\", skip(mapping), ret)]\n-        fn remap_path_prefix(mapping: &[(PathBuf, PathBuf)], path: PathBuf) -> (PathBuf, bool) {\n+        fn remap_path_prefix<'a>(\n+            mapping: &'a [(PathBuf, PathBuf)],\n+            path: Cow<'a, Path>,\n+        ) -> (Cow<'a, Path>, bool) {\n             // NOTE: We are iterating over the mapping entries from last to first\n             //       because entries specified later on the command line should\n             //       take precedence.\n@@ -1163,9 +1179,9 @@ impl FilePathMapping {\n                         // in remapped paths down the line.\n                         // So, if we have an exact match, we just return that without a call\n                         // to `Path::join()`.\n-                        to.clone()\n+                        to.into()\n                     } else {\n-                        to.join(rest)\n+                        to.join(rest).into()\n                     };\n                     debug!(\"Match - remapped\");\n \n@@ -1183,11 +1199,11 @@ impl FilePathMapping {\n     fn map_filename_prefix(&self, file: &FileName) -> (FileName, bool) {\n         match file {\n             FileName::Real(realfile) if let RealFileName::LocalPath(local_path) = realfile => {\n-                let (mapped_path, mapped) = self.map_prefix(local_path.to_path_buf());\n+                let (mapped_path, mapped) = self.map_prefix(local_path);\n                 let realfile = if mapped {\n                     RealFileName::Remapped {\n                         local_path: Some(local_path.clone()),\n-                        virtual_name: mapped_path,\n+                        virtual_name: mapped_path.into_owned(),\n                     }\n                 } else {\n                     realfile.clone()\n@@ -1228,14 +1244,17 @@ impl FilePathMapping {\n                 let (new_path, was_remapped) = self.map_prefix(unmapped_file_path);\n                 if was_remapped {\n                     // It was remapped, so don't modify further\n-                    return RealFileName::Remapped { local_path: None, virtual_name: new_path };\n+                    return RealFileName::Remapped {\n+                        local_path: None,\n+                        virtual_name: new_path.into_owned(),\n+                    };\n                 }\n \n                 if new_path.is_absolute() {\n                     // No remapping has applied to this path and it is absolute,\n                     // so the working directory cannot influence it either, so\n                     // we are done.\n-                    return RealFileName::LocalPath(new_path);\n+                    return RealFileName::LocalPath(new_path.into_owned());\n                 }\n \n                 debug_assert!(new_path.is_relative());\n@@ -1253,12 +1272,12 @@ impl FilePathMapping {\n                             RealFileName::Remapped {\n                                 // Erase the actual path\n                                 local_path: None,\n-                                virtual_name: file_path_abs,\n+                                virtual_name: file_path_abs.into_owned(),\n                             }\n                         } else {\n                             // No kind of remapping applied to this path, so\n                             // we leave it as it is.\n-                            RealFileName::LocalPath(file_path_abs)\n+                            RealFileName::LocalPath(file_path_abs.into_owned())\n                         }\n                     }\n                     RealFileName::Remapped {\n@@ -1277,4 +1296,43 @@ impl FilePathMapping {\n             }\n         }\n     }\n+\n+    /// Attempts to (heuristically) reverse a prefix mapping.\n+    ///\n+    /// Returns [`Some`] if there is exactly one mapping where the \"to\" part is\n+    /// a prefix of `path` and has at least one non-empty\n+    /// [`Normal`](path::Component::Normal) component. The component\n+    /// restriction exists to avoid reverse mapping overly generic paths like\n+    /// `/` or `.`).\n+    ///\n+    /// This is a heuristic and not guaranteed to return the actual original\n+    /// path! Do not rely on the result unless you have other means to verify\n+    /// that the mapping is correct (e.g. by checking the file content hash).\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn reverse_map_prefix_heuristically(&self, path: &Path) -> Option<PathBuf> {\n+        let mut found = None;\n+\n+        for (from, to) in self.mapping.iter() {\n+            let has_normal_component = to.components().any(|c| match c {\n+                path::Component::Normal(s) => !s.is_empty(),\n+                _ => false,\n+            });\n+\n+            if !has_normal_component {\n+                continue;\n+            }\n+\n+            let Ok(rest) = path.strip_prefix(to) else {\n+                continue;\n+            };\n+\n+            if found.is_some() {\n+                return None;\n+            }\n+\n+            found = Some(from.join(rest));\n+        }\n+\n+        found\n+    }\n }"}, {"sha": "686b3b00d7047a7120717418ce5106c118599408", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -344,6 +344,10 @@ fn map_path_prefix(mapping: &FilePathMapping, p: &str) -> String {\n     mapping.map_prefix(path(p)).0.to_string_lossy().to_string()\n }\n \n+fn reverse_map_prefix(mapping: &FilePathMapping, p: &str) -> Option<String> {\n+    mapping.reverse_map_prefix_heuristically(&path(p)).map(|q| q.to_string_lossy().to_string())\n+}\n+\n #[test]\n fn path_prefix_remapping() {\n     // Relative to relative\n@@ -387,7 +391,7 @@ fn path_prefix_remapping_expand_to_absolute() {\n     let working_directory = path(\"/foo\");\n     let working_directory = RealFileName::Remapped {\n         local_path: Some(working_directory.clone()),\n-        virtual_name: mapping.map_prefix(working_directory).0,\n+        virtual_name: mapping.map_prefix(working_directory).0.into_owned(),\n     };\n \n     assert_eq!(working_directory.remapped_path_if_available(), path(\"FOO\"));\n@@ -480,6 +484,45 @@ fn path_prefix_remapping_expand_to_absolute() {\n     );\n }\n \n+#[test]\n+fn path_prefix_remapping_reverse() {\n+    // Ignores options without alphanumeric chars.\n+    {\n+        let mapping =\n+            &FilePathMapping::new(vec![(path(\"abc\"), path(\"/\")), (path(\"def\"), path(\".\"))]);\n+\n+        assert_eq!(reverse_map_prefix(mapping, \"/hello.rs\"), None);\n+        assert_eq!(reverse_map_prefix(mapping, \"./hello.rs\"), None);\n+    }\n+\n+    // Returns `None` if multiple options match.\n+    {\n+        let mapping = &FilePathMapping::new(vec![\n+            (path(\"abc\"), path(\"/redacted\")),\n+            (path(\"def\"), path(\"/redacted\")),\n+        ]);\n+\n+        assert_eq!(reverse_map_prefix(mapping, \"/redacted/hello.rs\"), None);\n+    }\n+\n+    // Distinct reverse mappings.\n+    {\n+        let mapping = &FilePathMapping::new(vec![\n+            (path(\"abc\"), path(\"/redacted\")),\n+            (path(\"def/ghi\"), path(\"/fake/dir\")),\n+        ]);\n+\n+        assert_eq!(\n+            reverse_map_prefix(mapping, \"/redacted/path/hello.rs\"),\n+            Some(path_str(\"abc/path/hello.rs\"))\n+        );\n+        assert_eq!(\n+            reverse_map_prefix(mapping, \"/fake/dir/hello.rs\"),\n+            Some(path_str(\"def/ghi/hello.rs\"))\n+        );\n+    }\n+}\n+\n #[test]\n fn test_next_point() {\n     let sm = SourceMap::new(FilePathMapping::empty());"}, {"sha": "7597b8d126a9ceb55375ecdb2f9f523cd756e093", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -164,6 +164,7 @@ symbols! {\n         Capture,\n         Center,\n         Clone,\n+        Context,\n         Continue,\n         Copy,\n         Count,"}, {"sha": "f2c722b9a89da076e450e6bc8ceda7ce9fe3d67b", "filename": "compiler/rustc_target/src/spec/s390x_unknown_linux_gnu.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_gnu.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::Endian;\n-use crate::spec::{StackProbeType, Target};\n+use crate::spec::{SanitizerSet, StackProbeType, Target};\n \n pub fn target() -> Target {\n     let mut base = super::linux_gnu_base::opts();\n@@ -13,6 +13,8 @@ pub fn target() -> Target {\n     base.max_atomic_width = Some(64);\n     base.min_global_align = Some(16);\n     base.stack_probes = StackProbeType::Inline;\n+    base.supported_sanitizers =\n+        SanitizerSet::ADDRESS | SanitizerSet::LEAK | SanitizerSet::MEMORY | SanitizerSet::THREAD;\n \n     Target {\n         llvm_target: \"s390x-unknown-linux-gnu\".into(),"}, {"sha": "8fe9d023c527e824a7d8803f4abecfe8603328ac", "filename": "compiler/rustc_target/src/spec/s390x_unknown_linux_musl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fs390x_unknown_linux_musl.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::Endian;\n-use crate::spec::{StackProbeType, Target};\n+use crate::spec::{SanitizerSet, StackProbeType, Target};\n \n pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n@@ -14,6 +14,8 @@ pub fn target() -> Target {\n     base.min_global_align = Some(16);\n     base.static_position_independent_executables = true;\n     base.stack_probes = StackProbeType::Inline;\n+    base.supported_sanitizers =\n+        SanitizerSet::ADDRESS | SanitizerSet::LEAK | SanitizerSet::MEMORY | SanitizerSet::THREAD;\n \n     Target {\n         llvm_target: \"s390x-unknown-linux-musl\".into(),"}, {"sha": "90d879976c260cb33d84020b09a0ff33c9423d71", "filename": "compiler/rustc_trait_selection/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2FCargo.toml?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -19,6 +19,7 @@ rustc_infer = { path = \"../rustc_infer\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "6fa0941036390a675beafe5305269c0e9633c740", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -21,6 +21,7 @@\n #![feature(never_type)]\n #![feature(result_option_inspect)]\n #![feature(type_alias_impl_trait)]\n+#![feature(min_specialization)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "cdb72d49834f0101f401660171e102675bfa9e3b", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 319, "deletions": 81, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,95 +1,185 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n-use super::{\n-    instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty, EvalCtxt,\n-    Goal,\n-};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::infer::{\n-    canonical::{CanonicalVarValues, OriginalQueryValues},\n-    InferCtxt,\n-};\n use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::util::elaborate_predicates;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n \n /// A candidate is a possible way to prove a goal.\n ///\n /// It consists of both the `source`, which describes how that goal would be proven,\n /// and the `result` when using the given `source`.\n-///\n-/// For the list of possible candidates, please look at the documentation of\n-/// [super::trait_goals::CandidateSource] and [super::project_goals::CandidateSource].\n #[derive(Debug, Clone)]\n-pub(super) struct Candidate<'tcx, G: GoalKind<'tcx>> {\n-    pub(super) source: G::CandidateSource,\n+pub(super) struct Candidate<'tcx> {\n+    pub(super) source: CandidateSource,\n     pub(super) result: CanonicalResponse<'tcx>,\n }\n \n-pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n-    type CandidateSource: Debug + Copy;\n+/// Possible ways the given goal can be proven.\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum CandidateSource {\n+    /// A user written impl.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x: Vec<u32> = Vec::new();\n+    ///     // This uses the impl from the standard library to prove `Vec<T>: Clone`.\n+    ///     let y = x.clone();\n+    /// }\n+    /// ```\n+    Impl(DefId),\n+    /// A builtin impl generated by the compiler. When adding a new special\n+    /// trait, try to use actual impls whenever possible. Builtin impls should\n+    /// only be used in cases where the impl cannot be manually be written.\n+    ///\n+    /// Notable examples are auto traits, `Sized`, and `DiscriminantKind`.\n+    /// For a list of all traits with builtin impls, check out the\n+    /// [`EvalCtxt::assemble_builtin_impl_candidates`] method. Not\n+    BuiltinImpl,\n+    /// An assumption from the environment.\n+    ///\n+    /// More precicely we've used the `n-th` assumption in the `param_env`.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```rust\n+    /// fn is_clone<T: Clone>(x: T) -> (T, T) {\n+    ///     // This uses the assumption `T: Clone` from the `where`-bounds\n+    ///     // to prove `T: Clone`.\n+    ///     (x.clone(), x)\n+    /// }\n+    /// ```\n+    ParamEnv(usize),\n+    /// If the self type is an alias type, e.g. an opaque type or a projection,\n+    /// we know the bounds on that alias to hold even without knowing its concrete\n+    /// underlying type.\n+    ///\n+    /// More precisely this candidate is using the `n-th` bound in the `item_bounds` of\n+    /// the self type.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```rust\n+    /// trait Trait {\n+    ///     type Assoc: Clone;\n+    /// }\n+    ///\n+    /// fn foo<T: Trait>(x: <T as Trait>::Assoc) {\n+    ///     // We prove `<T as Trait>::Assoc` by looking at the bounds on `Assoc` in\n+    ///     // in the trait definition.\n+    ///     let _y = x.clone();\n+    /// }\n+    /// ```\n+    AliasBound(usize),\n+}\n \n+pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n     fn self_ty(self) -> Ty<'tcx>;\n \n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         impl_def_id: DefId,\n-    );\n-}\n+    ) -> QueryResult<'tcx>;\n \n-/// An abstraction which correctly deals with the canonical results for candidates.\n-///\n-/// It also deduplicates the behavior between trait and projection predicates.\n-pub(super) struct AssemblyCtxt<'a, 'tcx, G: GoalKind<'tcx>> {\n-    pub(super) cx: &'a mut EvalCtxt<'tcx>,\n-    pub(super) infcx: &'a InferCtxt<'tcx>,\n-    var_values: CanonicalVarValues<'tcx>,\n-    candidates: Vec<Candidate<'tcx, G>>,\n-}\n+    fn consider_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_auto_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n \n-impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n-    pub(super) fn assemble_and_evaluate_candidates(\n-        cx: &'a mut EvalCtxt<'tcx>,\n-        goal: CanonicalGoal<'tcx, G>,\n-    ) -> Vec<Candidate<'tcx, G>> {\n-        let (ref infcx, goal, var_values) =\n-            cx.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n-        let mut acx = AssemblyCtxt { cx, infcx, var_values, candidates: Vec::new() };\n+    fn consider_trait_alias_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n \n-        acx.assemble_candidates_after_normalizing_self_ty(goal);\n+    fn consider_builtin_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n \n-        acx.assemble_impl_candidates(goal);\n+    fn consider_builtin_copy_clone_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n \n-        acx.candidates\n-    }\n+    fn consider_builtin_pointer_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_fn_trait_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        kind: ty::ClosureKind,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_tuple_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+}\n \n-    pub(super) fn try_insert_candidate(\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    pub(super) fn assemble_and_evaluate_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n-        source: G::CandidateSource,\n-        certainty: Certainty,\n-    ) {\n-        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n-            Ok(result) => self.candidates.push(Candidate { source, result }),\n-            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n+        goal: Goal<'tcx, G>,\n+    ) -> Vec<Candidate<'tcx>> {\n+        debug_assert_eq!(goal, self.infcx.resolve_vars_if_possible(goal));\n+\n+        // HACK: `_: Trait` is ambiguous, because it may be satisfied via a builtin rule,\n+        // object bound, alias bound, etc. We are unable to determine this until we can at\n+        // least structually resolve the type one layer.\n+        if goal.predicate.self_ty().is_ty_var() {\n+            return vec![Candidate {\n+                source: CandidateSource::BuiltinImpl,\n+                result: self.make_canonical_response(Certainty::AMBIGUOUS).unwrap(),\n+            }];\n         }\n+\n+        let mut candidates = Vec::new();\n+\n+        self.assemble_candidates_after_normalizing_self_ty(goal, &mut candidates);\n+\n+        self.assemble_impl_candidates(goal, &mut candidates);\n+\n+        self.assemble_builtin_impl_candidates(goal, &mut candidates);\n+\n+        self.assemble_param_env_candidates(goal, &mut candidates);\n+\n+        self.assemble_alias_bound_candidates(goal, &mut candidates);\n+\n+        self.assemble_object_bound_candidates(goal, &mut candidates);\n+\n+        candidates\n     }\n \n     /// If the self type of a goal is a projection, computing the relevant candidates is difficult.\n     ///\n     /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n     /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n     /// this case as projections as self types add `\n-    fn assemble_candidates_after_normalizing_self_ty(&mut self, goal: Goal<'tcx, G>) {\n-        let tcx = self.cx.tcx;\n+    fn assemble_candidates_after_normalizing_self_ty<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let tcx = self.tcx();\n         // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n@@ -103,45 +193,193 @@ impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty =\n-                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n-                    Ok((_, certainty)) => certainty,\n-                    Err(NoSolution) => return,\n-                };\n+            let normalization_certainty = match self.evaluate_goal(normalizes_to_goal) {\n+                Ok((_, certainty)) => certainty,\n+                Err(NoSolution) => return,\n+            };\n+            let normalized_ty = self.infcx.resolve_vars_if_possible(normalized_ty);\n \n             // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n+            // This doesn't work as long as we use `CandidateSource` in winnowing.\n             let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let mut orig_values = OriginalQueryValues::default();\n-            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n-            let normalized_candidates =\n-                AssemblyCtxt::assemble_and_evaluate_candidates(self.cx, goal);\n-\n-            // Map each candidate from being canonical wrt the current inference context to being\n-            // canonical wrt the caller.\n-            for Candidate { source, result } in normalized_candidates {\n-                self.infcx.probe(|_| {\n-                    let candidate_certainty =\n-                        instantiate_canonical_query_response(&self.infcx, &orig_values, result);\n-\n-                    // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n-                    //\n-                    // If we have an ambiguous candidate it hides that normalization\n-                    // caused an overflow which may cause issues.\n-                    self.try_insert_candidate(\n-                        source,\n-                        normalization_certainty.unify_and(candidate_certainty),\n-                    )\n-                })\n+            // FIXME: This is broken if we care about the `usize` of `AliasBound` because the self type\n+            // could be normalized to yet another projection with different item bounds.\n+            let normalized_candidates = self.assemble_and_evaluate_candidates(goal);\n+            for mut normalized_candidate in normalized_candidates {\n+                normalized_candidate.result =\n+                    normalized_candidate.result.unchecked_map(|mut response| {\n+                        // FIXME: This currently hides overflow in the normalization step of the self type\n+                        // which is probably wrong. Maybe `unify_and` should actually keep overflow as\n+                        // we treat it as non-fatal anyways.\n+                        response.certainty = response.certainty.unify_and(normalization_certainty);\n+                        response\n+                    });\n+                candidates.push(normalized_candidate);\n             }\n         })\n     }\n \n-    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, G>) {\n-        self.cx.tcx.for_each_relevant_impl(\n-            goal.predicate.trait_def_id(self.cx.tcx),\n+    fn assemble_impl_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let tcx = self.tcx();\n+        tcx.for_each_relevant_impl(\n+            goal.predicate.trait_def_id(tcx),\n             goal.predicate.self_ty(),\n-            |impl_def_id| G::consider_impl_candidate(self, goal, impl_def_id),\n+            |impl_def_id| match G::consider_impl_candidate(self, goal, impl_def_id) {\n+                Ok(result) => candidates\n+                    .push(Candidate { source: CandidateSource::Impl(impl_def_id), result }),\n+                Err(NoSolution) => (),\n+            },\n         );\n     }\n+\n+    fn assemble_builtin_impl_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let lang_items = self.tcx().lang_items();\n+        let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n+        let result = if self.tcx().trait_is_auto(trait_def_id) {\n+            G::consider_auto_trait_candidate(self, goal)\n+        } else if self.tcx().trait_is_alias(trait_def_id) {\n+            G::consider_trait_alias_candidate(self, goal)\n+        } else if lang_items.sized_trait() == Some(trait_def_id) {\n+            G::consider_builtin_sized_candidate(self, goal)\n+        } else if lang_items.copy_trait() == Some(trait_def_id)\n+            || lang_items.clone_trait() == Some(trait_def_id)\n+        {\n+            G::consider_builtin_copy_clone_candidate(self, goal)\n+        } else if lang_items.pointer_sized() == Some(trait_def_id) {\n+            G::consider_builtin_pointer_sized_candidate(self, goal)\n+        } else if let Some(kind) = self.tcx().fn_trait_kind_from_def_id(trait_def_id) {\n+            G::consider_builtin_fn_trait_candidates(self, goal, kind)\n+        } else if lang_items.tuple_trait() == Some(trait_def_id) {\n+            G::consider_builtin_tuple_candidate(self, goal)\n+        } else {\n+            Err(NoSolution)\n+        };\n+\n+        match result {\n+            Ok(result) => {\n+                candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+            }\n+            Err(NoSolution) => (),\n+        }\n+    }\n+\n+    fn assemble_param_env_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        for (i, assumption) in goal.param_env.caller_bounds().iter().enumerate() {\n+            match G::consider_assumption(self, goal, assumption) {\n+                Ok(result) => {\n+                    candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n+                }\n+                Err(NoSolution) => (),\n+            }\n+        }\n+    }\n+\n+    fn assemble_alias_bound_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let alias_ty = match goal.predicate.self_ty().kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(_, _)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Dynamic(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(_)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Param(_)\n+            | ty::Placeholder(..)\n+            | ty::Infer(_)\n+            | ty::Error(_) => return,\n+            ty::Bound(..) => bug!(\"unexpected bound type: {goal:?}\"),\n+            ty::Alias(_, alias_ty) => alias_ty,\n+        };\n+\n+        for (i, (assumption, _)) in self\n+            .tcx()\n+            .bound_explicit_item_bounds(alias_ty.def_id)\n+            .subst_iter_copied(self.tcx(), alias_ty.substs)\n+            .enumerate()\n+        {\n+            match G::consider_assumption(self, goal, assumption) {\n+                Ok(result) => {\n+                    candidates.push(Candidate { source: CandidateSource::AliasBound(i), result })\n+                }\n+                Err(NoSolution) => (),\n+            }\n+        }\n+    }\n+\n+    fn assemble_object_bound_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let self_ty = goal.predicate.self_ty();\n+        let bounds = match *self_ty.kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(_, _)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Alias(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(_)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Param(_)\n+            | ty::Placeholder(..)\n+            | ty::Infer(_)\n+            | ty::Error(_) => return,\n+            ty::Bound(..) => bug!(\"unexpected bound type: {goal:?}\"),\n+            ty::Dynamic(bounds, ..) => bounds,\n+        };\n+\n+        let tcx = self.tcx();\n+        for assumption in\n+            elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n+        {\n+            match G::consider_assumption(self, goal, assumption.predicate) {\n+                Ok(result) => {\n+                    candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+                }\n+                Err(NoSolution) => (),\n+            }\n+        }\n+    }\n }"}, {"sha": "f1ee73a5b853f463ad9c77b2104a231bcabd3be2", "filename": "compiler/rustc_trait_selection/src/solve/cache.rs", "status": "removed", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/cb7770736c15488ec816d24ed41928d513f56b4c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7770736c15488ec816d24ed41928d513f56b4c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs?ref=cb7770736c15488ec816d24ed41928d513f56b4c", "patch": "@@ -1,291 +0,0 @@\n-//! This module both handles the global cache which stores \"finished\" goals,\n-//! and the provisional cache which contains partially computed goals.\n-//!\n-//! The provisional cache is necessary when dealing with coinductive cycles.\n-//!\n-//! For more information about the provisional cache and coinduction in general,\n-//! check out the relevant section of the rustc-dev-guide.\n-//!\n-//! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n-//! before then or if I still haven't done that before January 2023.\n-use super::overflow::OverflowData;\n-use super::{CanonicalGoal, Certainty, MaybeCause, Response};\n-use super::{EvalCtxt, QueryResult};\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n-use rustc_middle::ty::{self, TyCtxt};\n-use std::{cmp::Ordering, collections::hash_map::Entry};\n-\n-#[derive(Debug, Clone)]\n-struct ProvisionalEntry<'tcx> {\n-    // In case we have a coinductive cycle, this is the\n-    // the currently least restrictive result of this goal.\n-    response: QueryResult<'tcx>,\n-    // The lowest element on the stack on which this result\n-    // relies on. Starts out as just being the depth at which\n-    // we've proven this obligation, but gets lowered to the\n-    // depth of another goal if we rely on it in a cycle.\n-    depth: usize,\n-}\n-\n-struct StackElem<'tcx> {\n-    goal: CanonicalGoal<'tcx>,\n-    has_been_used: bool,\n-}\n-\n-/// The cache used for goals which are currently in progress or which depend\n-/// on in progress results.\n-///\n-/// Once we're done with a goal we can store it in the global trait solver\n-/// cache of the `TyCtxt`. For goals which we're currently proving, or which\n-/// have only been proven via a coinductive cycle using a goal still on our stack\n-/// we have to use this separate data structure.\n-///\n-/// The current data structure is not perfect, so there may still be room for\n-/// improvement here. We have the following requirements:\n-///\n-/// ## Is there is a provisional entry for the given goal:\n-///\n-/// ```ignore (for syntax highlighting)\n-/// self.entries.get(goal)\n-/// ```\n-///\n-/// ## Get all goals on the stack involved in a cycle:\n-///\n-/// ```ignore (for syntax highlighting)\n-/// let entry = self.entries.get(goal).unwrap();\n-/// let involved_goals = self.stack.iter().skip(entry.depth);\n-/// ```\n-///\n-/// ## Capping the depth of all entries\n-///\n-/// Needed whenever we encounter a cycle. The current implementation always\n-/// iterates over all entries instead of only the ones with a larger depth.\n-/// Changing this may result in notable performance improvements.\n-///\n-/// ```ignore (for syntax highlighting)\n-/// let cycle_depth = self.entries.get(goal).unwrap().depth;\n-/// for e in &mut self.entries {\n-///     e.depth = e.depth.min(cycle_depth);\n-/// }\n-/// ```\n-///\n-/// ## Checking whether we have to rerun the current goal\n-///\n-/// A goal has to be rerun if its provisional result was used in a cycle\n-/// and that result is different from its final result. We update\n-/// [StackElem::has_been_used] for the deepest stack element involved in a cycle.\n-///\n-/// ## Moving all finished goals into the global cache\n-///\n-/// If `stack_elem.has_been_used` is true, iterate over all entries, moving the ones\n-/// with equal depth. If not, simply move this single entry.\n-pub(super) struct ProvisionalCache<'tcx> {\n-    stack: Vec<StackElem<'tcx>>,\n-    entries: FxHashMap<CanonicalGoal<'tcx>, ProvisionalEntry<'tcx>>,\n-}\n-\n-impl<'tcx> ProvisionalCache<'tcx> {\n-    pub(super) fn empty() -> ProvisionalCache<'tcx> {\n-        ProvisionalCache { stack: Vec::new(), entries: Default::default() }\n-    }\n-\n-    pub(super) fn current_depth(&self) -> usize {\n-        self.stack.len()\n-    }\n-}\n-\n-impl<'tcx> EvalCtxt<'tcx> {\n-    /// Tries putting the new goal on the stack, returning an error if it is already cached.\n-    ///\n-    /// This correctly updates the provisional cache if there is a cycle.\n-    pub(super) fn try_push_stack(\n-        &mut self,\n-        goal: CanonicalGoal<'tcx>,\n-    ) -> Result<(), QueryResult<'tcx>> {\n-        // FIXME: start by checking the global cache\n-\n-        // Look at the provisional cache to check for cycles.\n-        let cache = &mut self.provisional_cache;\n-        match cache.entries.entry(goal) {\n-            // No entry, simply push this goal on the stack after dealing with overflow.\n-            Entry::Vacant(v) => {\n-                if self.overflow_data.has_overflow(cache.stack.len()) {\n-                    return Err(self.deal_with_overflow(goal));\n-                }\n-\n-                v.insert(ProvisionalEntry {\n-                    response: response_no_constraints(self.tcx, goal, Certainty::Yes),\n-                    depth: cache.stack.len(),\n-                });\n-                cache.stack.push(StackElem { goal, has_been_used: false });\n-                Ok(())\n-            }\n-            // We have a nested goal which relies on a goal `root` deeper in the stack.\n-            //\n-            // We first store that we may have to rerun `evaluate_goal` for `root` in case the\n-            // provisional response is not equal to the final response. We also update the depth\n-            // of all goals which recursively depend on our current goal to depend on `root`\n-            // instead.\n-            //\n-            // Finally we can return either the provisional response for that goal if we have a\n-            // coinductive cycle or an ambiguous result if the cycle is inductive.\n-            Entry::Occupied(entry) => {\n-                // FIXME: `ProvisionalEntry` should be `Copy`.\n-                let entry = entry.get().clone();\n-                cache.stack[entry.depth].has_been_used = true;\n-                for provisional_entry in cache.entries.values_mut() {\n-                    provisional_entry.depth = provisional_entry.depth.min(entry.depth);\n-                }\n-\n-                // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n-                // We can also depend on goals which aren't part of the stack but coinductively\n-                // depend on the stack themselves. We already checked whether all the goals\n-                // between these goals and their root on the stack. This means that as long as\n-                // each goal in a cycle is checked for coinductivity by itself simply checking\n-                // the stack is enough.\n-                if cache.stack[entry.depth..]\n-                    .iter()\n-                    .all(|g| g.goal.value.predicate.is_coinductive(self.tcx))\n-                {\n-                    Err(entry.response)\n-                } else {\n-                    Err(response_no_constraints(\n-                        self.tcx,\n-                        goal,\n-                        Certainty::Maybe(MaybeCause::Ambiguity),\n-                    ))\n-                }\n-            }\n-        }\n-    }\n-\n-    /// We cannot simply store the result of [EvalCtxt::compute_goal] as we have to deal with\n-    /// coinductive cycles.\n-    ///\n-    /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n-    /// while we are still computing that result. Because of this we continously recompute the\n-    /// cycle until the result of the previous iteration is equal to the final result, at which\n-    /// point we are done.\n-    ///\n-    /// This function returns `true` if we were able to finalize the goal and `false` if it has\n-    /// updated the provisional cache and we have to recompute the current goal.\n-    ///\n-    /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    pub(super) fn try_finalize_goal(\n-        &mut self,\n-        actual_goal: CanonicalGoal<'tcx>,\n-        response: QueryResult<'tcx>,\n-    ) -> bool {\n-        let cache = &mut self.provisional_cache;\n-        let StackElem { goal, has_been_used } = cache.stack.pop().unwrap();\n-        assert_eq!(goal, actual_goal);\n-\n-        let provisional_entry = cache.entries.get_mut(&goal).unwrap();\n-        // Check whether the current stack entry is the root of a cycle.\n-        //\n-        // If so, we either move all participants of that cycle to the global cache\n-        // or, in case the provisional response used in the cycle is not equal to the\n-        // final response, have to recompute the goal after updating the provisional\n-        // response to the final response of this iteration.\n-        if has_been_used {\n-            if provisional_entry.response == response {\n-                // We simply drop all entries according to an immutable condition, so\n-                // query instability is not a concern here.\n-                #[allow(rustc::potential_query_instability)]\n-                cache.entries.retain(|goal, entry| match entry.depth.cmp(&cache.stack.len()) {\n-                    Ordering::Less => true,\n-                    Ordering::Equal => {\n-                        Self::try_move_finished_goal_to_global_cache(\n-                            self.tcx,\n-                            &mut self.overflow_data,\n-                            &cache.stack,\n-                            // FIXME: these should be `Copy` :(\n-                            goal.clone(),\n-                            entry.response.clone(),\n-                        );\n-                        false\n-                    }\n-                    Ordering::Greater => bug!(\"entry with greater depth than the current leaf\"),\n-                });\n-\n-                true\n-            } else {\n-                provisional_entry.response = response;\n-                cache.stack.push(StackElem { goal, has_been_used: false });\n-                false\n-            }\n-        } else {\n-            Self::try_move_finished_goal_to_global_cache(\n-                self.tcx,\n-                &mut self.overflow_data,\n-                &cache.stack,\n-                goal,\n-                response,\n-            );\n-            cache.entries.remove(&goal);\n-            true\n-        }\n-    }\n-\n-    fn try_move_finished_goal_to_global_cache(\n-        tcx: TyCtxt<'tcx>,\n-        overflow_data: &mut OverflowData,\n-        stack: &[StackElem<'tcx>],\n-        goal: CanonicalGoal<'tcx>,\n-        response: QueryResult<'tcx>,\n-    ) {\n-        // We move goals to the global cache if we either did not hit an overflow or if it's\n-        // the root goal as that will now always hit the same overflow limit.\n-        //\n-        // NOTE: We cannot move any non-root goals to the global cache even if their final result\n-        // isn't impacted by the overflow as that goal still has unstable query dependencies\n-        // because it didn't go its full depth.\n-        //\n-        // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n-        // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n-        let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n-        if should_cache_globally {\n-            // FIXME: move the provisional entry to the global cache.\n-            let _ = (tcx, goal, response);\n-        }\n-    }\n-}\n-\n-pub(super) fn response_no_constraints<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    goal: Canonical<'tcx, impl Sized>,\n-    certainty: Certainty,\n-) -> QueryResult<'tcx> {\n-    let var_values = goal\n-        .variables\n-        .iter()\n-        .enumerate()\n-        .map(|(i, info)| match info.kind {\n-            CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {\n-                tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into())).into()\n-            }\n-            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n-                let br = ty::BoundRegion {\n-                    var: ty::BoundVar::from_usize(i),\n-                    kind: ty::BrAnon(i as u32, None),\n-                };\n-                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n-            }\n-            CanonicalVarKind::Const(_, ty) | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n-                .mk_const(ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)), ty)\n-                .into(),\n-        })\n-        .collect();\n-\n-    Ok(Canonical {\n-        max_universe: goal.max_universe,\n-        variables: goal.variables,\n-        value: Response {\n-            var_values: CanonicalVarValues { var_values },\n-            external_constraints: Default::default(),\n-            certainty,\n-        },\n-    })\n-}"}, {"sha": "a6240666ed43a86add4c87951342777d75e2ab55", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -10,7 +10,7 @@ use rustc_infer::{\n };\n use rustc_middle::ty;\n \n-use super::{Certainty, EvalCtxt};\n+use super::{search_graph, Certainty, EvalCtxt};\n \n /// A trait engine using the new trait solver.\n ///\n@@ -52,7 +52,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n             .drain(..)\n             .map(|obligation| FulfillmentError {\n                 obligation: obligation.clone(),\n-                code: FulfillmentErrorCode::CodeSelectionError(SelectionError::Unimplemented),\n+                code: FulfillmentErrorCode::CodeAmbiguity,\n                 root_obligation: obligation,\n             })\n             .collect()\n@@ -67,14 +67,17 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n \n             let mut has_changed = false;\n             for obligation in mem::take(&mut self.obligations) {\n-                let mut cx = EvalCtxt::new(infcx.tcx);\n-                let (changed, certainty) = match cx.evaluate_goal(infcx, obligation.clone().into())\n-                {\n+                let goal = obligation.clone().into();\n+                let search_graph = &mut search_graph::SearchGraph::new(infcx.tcx);\n+                let mut ecx = EvalCtxt::new_outside_solver(infcx, search_graph);\n+                let (changed, certainty) = match ecx.evaluate_goal(goal) {\n                     Ok(result) => result,\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n                             obligation: obligation.clone(),\n-                            code: FulfillmentErrorCode::CodeAmbiguity,\n+                            code: FulfillmentErrorCode::CodeSelectionError(\n+                                SelectionError::Unimplemented,\n+                            ),\n                             root_obligation: obligation,\n                         });\n                         continue;"}, {"sha": "42f597c781d257e0f97506d931d5121b5d5a83fd", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "modified", "additions": 54, "deletions": 31, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,23 +1,35 @@\n-use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::InferCtxt;\n+use rustc_infer::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc_infer::traits::query::NoSolution;\n-use rustc_middle::ty::Ty;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::ty::{self, Ty, TypeFoldable};\n use rustc_span::DUMMY_SP;\n \n-use crate::solve::ExternalConstraints;\n-\n-use super::{Certainty, QueryResult, Response};\n+use super::Goal;\n \n /// Methods used inside of the canonical queries of the solver.\n+///\n+/// Most notably these do not care about diagnostics information.\n+/// If you find this while looking for methods to use outside of the\n+/// solver, you may look at the implementation of these method for\n+/// help.\n pub(super) trait InferCtxtExt<'tcx> {\n     fn next_ty_infer(&self) -> Ty<'tcx>;\n+    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx>;\n+\n+    fn eq<T: ToTrace<'tcx>>(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution>;\n \n-    fn make_canonical_response(\n+    fn instantiate_bound_vars_with_infer<T: TypeFoldable<'tcx> + Copy>(\n         &self,\n-        var_values: CanonicalVarValues<'tcx>,\n-        certainty: Certainty,\n-    ) -> QueryResult<'tcx>;\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T;\n }\n \n impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n@@ -27,29 +39,40 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             span: DUMMY_SP,\n         })\n     }\n+    fn next_const_infer(&self, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n+        self.next_const_var(\n+            ty,\n+            ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span: DUMMY_SP },\n+        )\n+    }\n \n-    fn make_canonical_response(\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    fn eq<T: ToTrace<'tcx>>(\n         &self,\n-        var_values: CanonicalVarValues<'tcx>,\n-        certainty: Certainty,\n-    ) -> QueryResult<'tcx> {\n-        let external_constraints = take_external_constraints(self)?;\n-\n-        Ok(self.canonicalize_response(Response { var_values, external_constraints, certainty }))\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n+        self.at(&ObligationCause::dummy(), param_env)\n+            .define_opaque_types(false)\n+            .eq(lhs, rhs)\n+            .map(|InferOk { value: (), obligations }| {\n+                obligations.into_iter().map(|o| o.into()).collect()\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to equate\");\n+                NoSolution\n+            })\n     }\n-}\n \n-#[instrument(level = \"debug\", skip(infcx), ret)]\n-fn take_external_constraints<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n-    let region_obligations = infcx.take_registered_region_obligations();\n-    let opaque_types = infcx.take_opaque_types_for_query_response();\n-    Ok(ExternalConstraints {\n-        // FIXME: Now that's definitely wrong :)\n-        //\n-        // Should also do the leak check here I think\n-        regions: drop(region_obligations),\n-        opaque_types,\n-    })\n+    fn instantiate_bound_vars_with_infer<T: TypeFoldable<'tcx> + Copy>(\n+        &self,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T {\n+        self.replace_bound_vars_with_fresh_vars(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            value,\n+        )\n+    }\n }"}, {"sha": "da2a1a19957e128f491b8a1bbc3b3384da637581", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 218, "deletions": 85, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -19,27 +19,26 @@\n \n use std::mem;\n \n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues};\n use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n use rustc_middle::infer::canonical::Certainty as OldCertainty;\n-use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n+use rustc_middle::ty::{\n+    CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n+};\n use rustc_span::DUMMY_SP;\n \n use crate::traits::ObligationCause;\n \n-use self::cache::response_no_constraints;\n-use self::infcx_ext::InferCtxtExt;\n-\n mod assembly;\n-mod cache;\n mod fulfill;\n mod infcx_ext;\n-mod overflow;\n mod project_goals;\n+mod search_graph;\n mod trait_goals;\n \n pub use fulfill::FulfillmentCtxt;\n@@ -91,6 +90,8 @@ pub enum Certainty {\n }\n \n impl Certainty {\n+    pub const AMBIGUOUS: Certainty = Certainty::Maybe(MaybeCause::Ambiguity);\n+\n     /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n     /// use this function to unify the certainty of these goals\n     pub fn unify_and(self, other: Certainty) -> Certainty {\n@@ -146,45 +147,42 @@ pub trait TyCtxtExt<'tcx> {\n \n impl<'tcx> TyCtxtExt<'tcx> for TyCtxt<'tcx> {\n     fn evaluate_goal(self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n-        let mut cx = EvalCtxt::new(self);\n-        cx.evaluate_canonical_goal(goal)\n+        let mut search_graph = search_graph::SearchGraph::new(self);\n+        EvalCtxt::evaluate_canonical_goal(self, &mut search_graph, goal)\n     }\n }\n \n-struct EvalCtxt<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct EvalCtxt<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n+    var_values: CanonicalVarValues<'tcx>,\n \n-    provisional_cache: cache::ProvisionalCache<'tcx>,\n-    overflow_data: overflow::OverflowData,\n+    search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> EvalCtxt<'tcx> {\n-        EvalCtxt {\n-            tcx,\n-            provisional_cache: cache::ProvisionalCache::empty(),\n-            overflow_data: overflow::OverflowData::new(tcx),\n-        }\n+impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n     }\n \n-    /// Recursively evaluates `goal`, returning whether any inference vars have\n-    /// been constrained and the certainty of the result.\n-    fn evaluate_goal(\n-        &mut self,\n-        infcx: &InferCtxt<'tcx>,\n-        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut orig_values = OriginalQueryValues::default();\n-        let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n-        let canonical_response = self.evaluate_canonical_goal(canonical_goal)?;\n-        Ok((\n-            true, // FIXME: check whether `var_values` are an identity substitution.\n-            instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n-        ))\n+    /// Creates a new evaluation context outside of the trait solver.\n+    ///\n+    /// With this solver making a canonical response doesn't make much sense.\n+    /// The `search_graph` for this solver has to be completely empty.\n+    fn new_outside_solver(\n+        infcx: &'a InferCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+    ) -> EvalCtxt<'a, 'tcx> {\n+        assert!(search_graph.is_empty());\n+        EvalCtxt { infcx, var_values: CanonicalVarValues::dummy(), search_graph }\n     }\n \n-    fn evaluate_canonical_goal(&mut self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n-        match self.try_push_stack(goal) {\n+    #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n+    fn evaluate_canonical_goal(\n+        tcx: TyCtxt<'tcx>,\n+        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+        canonical_goal: CanonicalGoal<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        match search_graph.try_push_stack(tcx, canonical_goal) {\n             Ok(()) => {}\n             // Our goal is already on the stack, eager return.\n             Err(response) => return response,\n@@ -195,93 +193,169 @@ impl<'tcx> EvalCtxt<'tcx> {\n         //\n         // FIXME: Similar to `evaluate_all`, this has to check for overflow.\n         loop {\n-            let result = self.compute_goal(goal);\n+            let (ref infcx, goal, var_values) =\n+                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let mut ecx = EvalCtxt { infcx, var_values, search_graph };\n+            let result = ecx.compute_goal(goal);\n \n             // FIXME: `Response` should be `Copy`\n-            if self.try_finalize_goal(goal, result.clone()) {\n+            if search_graph.try_finalize_goal(tcx, canonical_goal, result.clone()) {\n                 return result;\n             }\n         }\n     }\n \n-    fn compute_goal(&mut self, canonical_goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n-        // WARNING: We're looking at a canonical value without instantiating it here.\n-        //\n-        // We have to be incredibly careful to not change the order of bound variables or\n-        // remove any. As we go from `Goal<'tcx, Predicate>` to `Goal` with the variants\n-        // of `PredicateKind` this is the case and it is and faster than instantiating and\n-        // recanonicalizing.\n-        let Goal { param_env, predicate } = canonical_goal.value;\n+    fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+        let external_constraints = take_external_constraints(self.infcx)?;\n+\n+        Ok(self.infcx.canonicalize_response(Response {\n+            var_values: self.var_values.clone(),\n+            external_constraints,\n+            certainty,\n+        }))\n+    }\n \n-        if let Some(kind) = predicate.kind().no_bound_vars_ignoring_escaping(self.tcx) {\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut orig_values = OriginalQueryValues::default();\n+        let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+        let canonical_response =\n+            EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+        Ok((\n+            !canonical_response.value.var_values.is_identity(),\n+            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response),\n+        ))\n+    }\n+\n+    fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n+        let Goal { param_env, predicate } = goal;\n+        let kind = predicate.kind();\n+        if let Some(kind) = kind.no_bound_vars() {\n             match kind {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => self.compute_trait_goal(\n-                    canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                ),\n-                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => self\n-                    .compute_projection_goal(\n-                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                    ),\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => self\n-                    .compute_type_outlives_goal(\n-                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                    ),\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => self\n-                    .compute_region_outlives_goal(\n-                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n-                    ),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    self.compute_trait_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n+                    self.compute_projection_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n+                    self.compute_type_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n+                    self.compute_region_outlives_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Subtype(predicate) => {\n+                    self.compute_subtype_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::Coerce(predicate) => {\n+                    self.compute_coerce_goal(Goal { param_env, predicate })\n+                }\n+                ty::PredicateKind::ClosureKind(def_id, substs, kind) => self\n+                    .compute_closure_kind_goal(Goal {\n+                        param_env,\n+                        predicate: (def_id, substs, kind),\n+                    }),\n+                ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::AMBIGUOUS),\n                 // FIXME: implement these predicates :)\n                 ty::PredicateKind::WellFormed(_)\n                 | ty::PredicateKind::ObjectSafe(_)\n-                | ty::PredicateKind::ClosureKind(_, _, _)\n-                | ty::PredicateKind::Subtype(_)\n-                | ty::PredicateKind::Coerce(_)\n                 | ty::PredicateKind::ConstEvaluatable(_)\n-                | ty::PredicateKind::ConstEquate(_, _)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n-                | ty::PredicateKind::Ambiguous => {\n-                    // FIXME\n-                    response_no_constraints(self.tcx, canonical_goal, Certainty::Yes)\n+                | ty::PredicateKind::ConstEquate(_, _) => {\n+                    self.make_canonical_response(Certainty::Yes)\n+                }\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n             }\n         } else {\n-            let (infcx, goal, var_values) =\n-                self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let kind = infcx.replace_bound_vars_with_placeholders(goal.predicate.kind());\n-            let goal = goal.with(self.tcx, ty::Binder::dummy(kind));\n-            let (_, certainty) = self.evaluate_goal(&infcx, goal)?;\n-            infcx.make_canonical_response(var_values, certainty)\n+            let kind = self.infcx.replace_bound_vars_with_placeholders(kind);\n+            let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n+            let (_, certainty) = self.evaluate_goal(goal)?;\n+            self.make_canonical_response(certainty)\n         }\n     }\n \n     fn compute_type_outlives_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+        _goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        // FIXME\n-        response_no_constraints(self.tcx, goal, Certainty::Yes)\n+        self.make_canonical_response(Certainty::Yes)\n     }\n \n     fn compute_region_outlives_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+        _goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        self.make_canonical_response(Certainty::Yes)\n+    }\n+\n+    fn compute_coerce_goal(\n+        &mut self,\n+        goal: Goal<'tcx, CoercePredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        self.compute_subtype_goal(Goal {\n+            param_env: goal.param_env,\n+            predicate: SubtypePredicate {\n+                a_is_expected: false,\n+                a: goal.predicate.a,\n+                b: goal.predicate.b,\n+            },\n+        })\n+    }\n+\n+    fn compute_subtype_goal(\n+        &mut self,\n+        goal: Goal<'tcx, SubtypePredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        if goal.predicate.a.is_ty_var() && goal.predicate.b.is_ty_var() {\n+            // FIXME: Do we want to register a subtype relation between these vars?\n+            // That won't actually reflect in the query response, so it seems moot.\n+            self.make_canonical_response(Certainty::AMBIGUOUS)\n+        } else {\n+            self.infcx.probe(|_| {\n+                let InferOk { value: (), obligations } = self\n+                    .infcx\n+                    .at(&ObligationCause::dummy(), goal.param_env)\n+                    .sub(goal.predicate.a, goal.predicate.b)?;\n+                self.evaluate_all_and_make_canonical_response(\n+                    obligations.into_iter().map(|pred| pred.into()).collect(),\n+                )\n+            })\n+        }\n+    }\n+\n+    fn compute_closure_kind_goal(\n+        &mut self,\n+        goal: Goal<'tcx, (DefId, ty::SubstsRef<'tcx>, ty::ClosureKind)>,\n     ) -> QueryResult<'tcx> {\n-        // FIXME\n-        response_no_constraints(self.tcx, goal, Certainty::Yes)\n+        let (_, substs, expected_kind) = goal.predicate;\n+        let found_kind = substs.as_closure().kind_ty().to_opt_closure_kind();\n+\n+        let Some(found_kind) = found_kind else {\n+            return self.make_canonical_response(Certainty::AMBIGUOUS);\n+        };\n+        if found_kind.extends(expected_kind) {\n+            self.make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n     }\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     fn evaluate_all(\n         &mut self,\n-        infcx: &InferCtxt<'tcx>,\n         mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> Result<Certainty, NoSolution> {\n         let mut new_goals = Vec::new();\n         self.repeat_while_none(|this| {\n             let mut has_changed = Err(Certainty::Yes);\n             for goal in goals.drain(..) {\n-                let (changed, certainty) = match this.evaluate_goal(infcx, goal) {\n+                let (changed, certainty) = match this.evaluate_goal(goal) {\n                     Ok(result) => result,\n                     Err(NoSolution) => return Some(Err(NoSolution)),\n                 };\n@@ -308,6 +382,28 @@ impl<'tcx> EvalCtxt<'tcx> {\n             }\n         })\n     }\n+\n+    fn evaluate_all_and_make_canonical_response(\n+        &mut self,\n+        goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n+    ) -> QueryResult<'tcx> {\n+        self.evaluate_all(goals).and_then(|certainty| self.make_canonical_response(certainty))\n+    }\n+}\n+\n+#[instrument(level = \"debug\", skip(infcx), ret)]\n+fn take_external_constraints<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+    let region_obligations = infcx.take_registered_region_obligations();\n+    let opaque_types = infcx.take_opaque_types_for_query_response();\n+    Ok(ExternalConstraints {\n+        // FIXME: Now that's definitely wrong :)\n+        //\n+        // Should also do the leak check here I think\n+        regions: drop(region_obligations),\n+        opaque_types,\n+    })\n }\n \n fn instantiate_canonical_query_response<'tcx>(\n@@ -334,3 +430,40 @@ fn instantiate_canonical_query_response<'tcx>(\n     assert!(obligations.is_empty());\n     value\n }\n+\n+pub(super) fn response_no_constraints<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: Canonical<'tcx, impl Sized>,\n+    certainty: Certainty,\n+) -> QueryResult<'tcx> {\n+    let var_values = goal\n+        .variables\n+        .iter()\n+        .enumerate()\n+        .map(|(i, info)| match info.kind {\n+            CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => {\n+                tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into())).into()\n+            }\n+            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(i),\n+                    kind: ty::BrAnon(i as u32, None),\n+                };\n+                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+            }\n+            CanonicalVarKind::Const(_, ty) | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n+                .mk_const(ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)), ty)\n+                .into(),\n+        })\n+        .collect();\n+\n+    Ok(Canonical {\n+        max_universe: goal.max_universe,\n+        variables: goal.variables,\n+        value: Response {\n+            var_values: CanonicalVarValues { var_values },\n+            external_constraints: Default::default(),\n+            certainty,\n+        },\n+    })\n+}"}, {"sha": "32e15f03998b3598431b58e417d87938e5cab02d", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 242, "deletions": 63, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,38 +1,124 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n-use super::assembly::{self, AssemblyCtxt};\n-use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use super::assembly::{self, Candidate, CandidateSource};\n+use super::infcx_ext::InferCtxtExt;\n+use super::trait_goals::structural_traits;\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n-use rustc_infer::traits::{ObligationCause, Reveal};\n+use rustc_infer::traits::Reveal;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n-use rustc_middle::ty::ProjectionPredicate;\n-use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{ProjectionPredicate, TypeSuperVisitable, TypeVisitor};\n+use rustc_middle::ty::{ToPredicate, TypeVisitable};\n use rustc_span::DUMMY_SP;\n use std::iter;\n+use std::ops::ControlFlow;\n \n-#[allow(dead_code)] // FIXME: implement and use all variants.\n-#[derive(Debug, Clone, Copy)]\n-pub(super) enum CandidateSource {\n-    Impl(DefId),\n-    ParamEnv(usize),\n-    Builtin,\n-}\n-\n-type Candidate<'tcx> = assembly::Candidate<'tcx, ProjectionPredicate<'tcx>>;\n-\n-impl<'tcx> EvalCtxt<'tcx> {\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn compute_projection_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, ProjectionPredicate<'tcx>>,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n-        self.merge_project_candidates(candidates)\n+        // To only compute normalization once for each projection we only\n+        // normalize if the expected term is an unconstrained inference variable.\n+        //\n+        // E.g. for `<T as Trait>::Assoc = u32` we recursively compute the goal\n+        // `exists<U> <T as Trait>::Assoc = U` and then take the resulting type for\n+        // `U` and equate it with `u32`. This means that we don't need a separate\n+        // projection cache in the solver.\n+        if self.term_is_fully_unconstrained(goal) {\n+            let candidates = self.assemble_and_evaluate_candidates(goal);\n+            self.merge_project_candidates(candidates)\n+        } else {\n+            let predicate = goal.predicate;\n+            let unconstrained_rhs = match predicate.term.unpack() {\n+                ty::TermKind::Ty(_) => self.infcx.next_ty_infer().into(),\n+                ty::TermKind::Const(ct) => self.infcx.next_const_infer(ct.ty()).into(),\n+            };\n+            let unconstrained_predicate = ty::Clause::Projection(ProjectionPredicate {\n+                projection_ty: goal.predicate.projection_ty,\n+                term: unconstrained_rhs,\n+            });\n+            let (_has_changed, normalize_certainty) =\n+                self.evaluate_goal(goal.with(self.tcx(), unconstrained_predicate))?;\n+\n+            let nested_eq_goals =\n+                self.infcx.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            let eval_certainty = self.evaluate_all(nested_eq_goals)?;\n+            self.make_canonical_response(normalize_certainty.unify_and(eval_certainty))\n+        }\n+    }\n+\n+    /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n+    ///\n+    /// This is the case if the `term` is an inference variable in the innermost universe\n+    /// and does not occur in any other part of the predicate.\n+    fn term_is_fully_unconstrained(&self, goal: Goal<'tcx, ProjectionPredicate<'tcx>>) -> bool {\n+        let infcx = self.infcx;\n+        let term_is_infer = match goal.predicate.term.unpack() {\n+            ty::TermKind::Ty(ty) => {\n+                if let &ty::Infer(ty::TyVar(vid)) = ty.kind() {\n+                    match infcx.probe_ty_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == infcx.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+            ty::TermKind::Const(ct) => {\n+                if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.kind() {\n+                    match self.infcx.probe_const_var(vid) {\n+                        Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n+                        Err(universe) => universe == infcx.universe(),\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+        };\n+\n+        // Guard against `<T as Trait<?0>>::Assoc = ?0>`.\n+        struct ContainsTerm<'tcx> {\n+            term: ty::Term<'tcx>,\n+        }\n+        impl<'tcx> TypeVisitor<'tcx> for ContainsTerm<'tcx> {\n+            type BreakTy = ();\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if t.needs_infer() {\n+                    if ty::Term::from(t) == self.term {\n+                        ControlFlow::BREAK\n+                    } else {\n+                        t.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n+            }\n+\n+            fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if c.needs_infer() {\n+                    if ty::Term::from(c) == self.term {\n+                        ControlFlow::BREAK\n+                    } else {\n+                        c.super_visit_with(self)\n+                    }\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n+            }\n+        }\n+\n+        let mut visitor = ContainsTerm { term: goal.predicate.term };\n+\n+        term_is_infer\n+            && goal.predicate.projection_ty.visit_with(&mut visitor).is_continue()\n+            && goal.param_env.visit_with(&mut visitor).is_continue()\n     }\n \n     fn merge_project_candidates(\n@@ -83,14 +169,13 @@ impl<'tcx> EvalCtxt<'tcx> {\n         match (candidate.source, other.source) {\n             (CandidateSource::Impl(_), _)\n             | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::Builtin, _) => unimplemented!(),\n+            | (CandidateSource::BuiltinImpl, _)\n+            | (CandidateSource::AliasBound(_), _) => unimplemented!(),\n         }\n     }\n }\n \n impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n-    type CandidateSource = CandidateSource;\n-\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()\n     }\n@@ -104,51 +189,47 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     }\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, 'tcx, ProjectionPredicate<'tcx>>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n         impl_def_id: DefId,\n-    ) {\n-        let tcx = acx.cx.tcx;\n+    ) -> QueryResult<'tcx> {\n+        let tcx = ecx.tcx();\n+\n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n         if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n-            return;\n+            return Err(NoSolution);\n         }\n \n-        acx.infcx.probe(|_| {\n-            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.infcx.probe(|_| {\n+            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let Ok(InferOk { obligations, .. }) = acx\n-                .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .define_opaque_types(false)\n-                .eq(goal_trait_ref, impl_trait_ref)\n-                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n-            else {\n-                return\n-            };\n+            let mut nested_goals = ecx.infcx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n \n-            let nested_goals = obligations.into_iter().map(|o| o.into()).chain(where_clause_bounds).collect();\n-            let Ok(trait_ref_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+            nested_goals.extend(where_clause_bounds);\n+            let trait_ref_certainty = ecx.evaluate_all(nested_goals)?;\n \n+            // In case the associated item is hidden due to specialization, we have to\n+            // return ambiguity this would otherwise be incomplete, resulting in\n+            // unsoundness during coherence (#105782).\n             let Some(assoc_def) = fetch_eligible_assoc_item_def(\n-                acx.infcx,\n+                ecx.infcx,\n                 goal.param_env,\n                 goal_trait_ref,\n                 goal.predicate.def_id(),\n                 impl_def_id\n-            ) else {\n-                return\n+            )? else {\n+                return ecx.make_canonical_response(trait_ref_certainty.unify_and(Certainty::AMBIGUOUS));\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -171,10 +252,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let impl_substs_with_gat = goal.predicate.projection_ty.substs.rebase_onto(\n                 tcx,\n                 goal_trait_ref.def_id,\n-                impl_trait_ref.substs,\n+                impl_substs,\n             );\n             let substs = translate_substs(\n-                acx.infcx,\n+                ecx.infcx,\n                 goal.param_env,\n                 impl_def_id,\n                 impl_substs_with_gat,\n@@ -185,7 +266,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let is_const = matches!(tcx.def_kind(assoc_def.item.def_id), DefKind::AssocConst);\n             let ty = tcx.bound_type_of(assoc_def.item.def_id);\n             let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n-                let identity_substs = ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n+                let identity_substs =\n+                    ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n                 let did = ty::WithOptConstParam::unknown(assoc_def.item.def_id);\n                 let kind =\n                     ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n@@ -194,23 +276,121 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            let Ok(InferOk { obligations, .. }) = acx\n+            // The term of our goal should be fully unconstrained, so this should never fail.\n+            //\n+            // It can however be ambiguous when the resolved type is a projection.\n+            let nested_goals = ecx\n                 .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .define_opaque_types(false)\n-                .eq(goal.predicate.term,  term.subst(tcx, substs))\n-                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n-            else {\n-                return\n-            };\n-\n-            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n-            let Ok(rhs_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+                .eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))\n+                .expect(\"failed to unify with unconstrained term\");\n+            let rhs_certainty =\n+                ecx.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n \n-            let certainty = trait_ref_certainty.unify_and(rhs_certainty);\n-            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+            ecx.make_canonical_response(trait_ref_certainty.unify_and(rhs_certainty))\n         })\n     }\n+\n+    fn consider_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred() {\n+            ecx.infcx.probe(|_| {\n+                let assumption_projection_pred =\n+                    ecx.infcx.instantiate_bound_vars_with_infer(poly_projection_pred);\n+                let nested_goals = ecx.infcx.eq(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n+\n+                // The term of our goal should be fully unconstrained, so this should never fail.\n+                //\n+                // It can however be ambiguous when the resolved type is a projection.\n+                let nested_goals = ecx\n+                    .infcx\n+                    .eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n+                    .expect(\"failed to unify with unconstrained term\");\n+                let rhs_certainty = ecx\n+                    .evaluate_all(nested_goals)\n+                    .expect(\"failed to unify with unconstrained term\");\n+\n+                ecx.make_canonical_response(subst_certainty.unify_and(rhs_certainty))\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n+    fn consider_auto_trait_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"auto traits do not have associated types: {:?}\", goal);\n+    }\n+\n+    fn consider_trait_alias_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"trait aliases do not have associated types: {:?}\", goal);\n+    }\n+\n+    fn consider_builtin_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Sized` does not have an associated type: {:?}\", goal);\n+    }\n+\n+    fn consider_builtin_copy_clone_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Copy`/`Clone` does not have an associated type: {:?}\", goal);\n+    }\n+\n+    fn consider_builtin_pointer_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`PointerSized` does not have an associated type: {:?}\", goal);\n+    }\n+\n+    fn consider_builtin_fn_trait_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        goal_kind: ty::ClosureKind,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(tupled_inputs_and_output) =\n+            structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                ecx.tcx(),\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )?\n+        {\n+            let pred = tupled_inputs_and_output\n+                .map_bound(|(inputs, output)| ty::ProjectionPredicate {\n+                    projection_ty: ecx\n+                        .tcx()\n+                        .mk_alias_ty(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs]),\n+                    term: output.into(),\n+                })\n+                .to_predicate(ecx.tcx());\n+            Self::consider_assumption(ecx, goal, pred)\n+        } else {\n+            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n+        }\n+    }\n+\n+    fn consider_builtin_tuple_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Tuple` does not have an associated type: {:?}\", goal);\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code.\n@@ -224,10 +404,9 @@ fn fetch_eligible_assoc_item_def<'tcx>(\n     goal_trait_ref: ty::TraitRef<'tcx>,\n     trait_assoc_def_id: DefId,\n     impl_def_id: DefId,\n-) -> Option<LeafDef> {\n+) -> Result<Option<LeafDef>, NoSolution> {\n     let node_item = specialization_graph::assoc_def(infcx.tcx, impl_def_id, trait_assoc_def_id)\n-        .map_err(|ErrorGuaranteed { .. }| ())\n-        .ok()?;\n+        .map_err(|ErrorGuaranteed { .. }| NoSolution)?;\n \n     let eligible = if node_item.is_final() {\n         // Non-specializable items are always projectable.\n@@ -246,5 +425,5 @@ fn fetch_eligible_assoc_item_def<'tcx>(\n         }\n     };\n \n-    if eligible { Some(node_item) } else { None }\n+    if eligible { Ok(Some(node_item)) } else { Ok(None) }\n }"}, {"sha": "730a8e6125887ae6fcdfb1e7379f38df33d2016e", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -0,0 +1,123 @@\n+//! This module both handles the global cache which stores \"finished\" goals,\n+//! and the provisional cache which contains partially computed goals.\n+//!\n+//! The provisional cache is necessary when dealing with coinductive cycles.\n+//!\n+//! For more information about the provisional cache and coinduction in general,\n+//! check out the relevant section of the rustc-dev-guide.\n+//!\n+//! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n+//! before then or if I still haven't done that before January 2023.\n+use super::overflow::OverflowData;\n+use super::StackDepth;\n+use crate::solve::{CanonicalGoal, QueryResult};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::TyCtxt;\n+\n+rustc_index::newtype_index! {\n+    pub struct EntryIndex {}\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(super) struct ProvisionalEntry<'tcx> {\n+    // In case we have a coinductive cycle, this is the\n+    // the currently least restrictive result of this goal.\n+    pub(super) response: QueryResult<'tcx>,\n+    // In case of a cycle, the position of deepest stack entry involved\n+    // in that cycle. This is monotonically decreasing in the stack as all\n+    // elements between the current stack element in the deepest stack entry\n+    // involved have to also be involved in that cycle.\n+    //\n+    // We can only move entries to the global cache once we're complete done\n+    // with the cycle. If this entry has not been involved in a cycle,\n+    // this is just its own depth.\n+    pub(super) depth: StackDepth,\n+\n+    // The goal for this entry. Should always be equal to the corresponding goal\n+    // in the lookup table.\n+    pub(super) goal: CanonicalGoal<'tcx>,\n+}\n+\n+pub(super) struct ProvisionalCache<'tcx> {\n+    pub(super) entries: IndexVec<EntryIndex, ProvisionalEntry<'tcx>>,\n+    // FIXME: This is only used to quickly check whether a given goal\n+    // is in the cache. We should experiment with using something like\n+    // `SsoHashSet` here because in most cases there are only a few entries.\n+    pub(super) lookup_table: FxHashMap<CanonicalGoal<'tcx>, EntryIndex>,\n+}\n+\n+impl<'tcx> ProvisionalCache<'tcx> {\n+    pub(super) fn empty() -> ProvisionalCache<'tcx> {\n+        ProvisionalCache { entries: Default::default(), lookup_table: Default::default() }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.entries.is_empty() && self.lookup_table.is_empty()\n+    }\n+\n+    /// Adds a dependency from the current leaf to `target` in the cache\n+    /// to prevent us from moving any goals which depend on the current leaf\n+    /// to the global cache while we're still computing `target`.\n+    ///\n+    /// Its important to note that `target` may already be part of a different cycle.\n+    /// In this case we have to ensure that we also depend on all other goals\n+    /// in the existing cycle in addition to the potentially direct cycle with `target`.\n+    pub(super) fn add_dependency_of_leaf_on(&mut self, target: EntryIndex) {\n+        let depth = self.entries[target].depth;\n+        for provisional_entry in &mut self.entries.raw[target.index()..] {\n+            // The depth of `target` is the position of the deepest goal in the stack\n+            // on which `target` depends. That goal is the `root` of this cycle.\n+            //\n+            // Any entry which was added after `target` is either on the stack itself\n+            // at which point its depth is definitely at least as high as the depth of\n+            // `root`. If it's not on the stack itself it has to depend on a goal\n+            // between `root` and `leaf`. If it were to depend on a goal deeper in the\n+            // stack than `root`, then `root` would also depend on that goal, at which\n+            // point `root` wouldn't be the root anymore.\n+            debug_assert!(provisional_entry.depth >= depth);\n+            provisional_entry.depth = depth;\n+        }\n+\n+        // We only update entries which were added after `target` as no other\n+        // entry should have a higher depth.\n+        //\n+        // Any entry which previously had a higher depth than target has to\n+        // be between `target` and `root`. Because of this we would have updated\n+        // its depth when calling `add_dependency_of_leaf_on(root)` for `target`.\n+        if cfg!(debug_assertions) {\n+            self.entries.iter().all(|e| e.depth <= depth);\n+        }\n+    }\n+\n+    pub(super) fn depth(&self, entry_index: EntryIndex) -> StackDepth {\n+        self.entries[entry_index].depth\n+    }\n+\n+    pub(super) fn provisional_result(&self, entry_index: EntryIndex) -> QueryResult<'tcx> {\n+        self.entries[entry_index].response.clone()\n+    }\n+}\n+\n+pub(super) fn try_move_finished_goal_to_global_cache<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    overflow_data: &mut OverflowData,\n+    stack: &IndexVec<super::StackDepth, super::StackElem<'tcx>>,\n+    goal: CanonicalGoal<'tcx>,\n+    response: QueryResult<'tcx>,\n+) {\n+    // We move goals to the global cache if we either did not hit an overflow or if it's\n+    // the root goal as that will now always hit the same overflow limit.\n+    //\n+    // NOTE: We cannot move any non-root goals to the global cache even if their final result\n+    // isn't impacted by the overflow as that goal still has unstable query dependencies\n+    // because it didn't go its full depth.\n+    //\n+    // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n+    // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n+    let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n+    if should_cache_globally {\n+        // FIXME: move the provisional entry to the global cache.\n+        let _ = (tcx, goal, response);\n+    }\n+}"}, {"sha": "0030e9aa3e5149343098dda7c96c3989f92889ae", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -0,0 +1,178 @@\n+mod cache;\n+mod overflow;\n+\n+use self::cache::ProvisionalEntry;\n+use super::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+use cache::ProvisionalCache;\n+use overflow::OverflowData;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::TyCtxt;\n+use std::collections::hash_map::Entry;\n+\n+rustc_index::newtype_index! {\n+    pub struct StackDepth {}\n+}\n+\n+struct StackElem<'tcx> {\n+    goal: CanonicalGoal<'tcx>,\n+    has_been_used: bool,\n+}\n+\n+pub(super) struct SearchGraph<'tcx> {\n+    /// The stack of goals currently being computed.\n+    ///\n+    /// An element is *deeper* in the stack if its index is *lower*.\n+    stack: IndexVec<StackDepth, StackElem<'tcx>>,\n+    overflow_data: OverflowData,\n+    provisional_cache: ProvisionalCache<'tcx>,\n+}\n+\n+impl<'tcx> SearchGraph<'tcx> {\n+    pub(super) fn new(tcx: TyCtxt<'tcx>) -> SearchGraph<'tcx> {\n+        Self {\n+            stack: Default::default(),\n+            overflow_data: OverflowData::new(tcx),\n+            provisional_cache: ProvisionalCache::empty(),\n+        }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.stack.is_empty()\n+            && self.provisional_cache.is_empty()\n+            && !self.overflow_data.did_overflow()\n+    }\n+\n+    /// Tries putting the new goal on the stack, returning an error if it is already cached.\n+    ///\n+    /// This correctly updates the provisional cache if there is a cycle.\n+    pub(super) fn try_push_stack(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        goal: CanonicalGoal<'tcx>,\n+    ) -> Result<(), QueryResult<'tcx>> {\n+        // FIXME: start by checking the global cache\n+\n+        // Look at the provisional cache to check for cycles.\n+        let cache = &mut self.provisional_cache;\n+        match cache.lookup_table.entry(goal) {\n+            // No entry, simply push this goal on the stack after dealing with overflow.\n+            Entry::Vacant(v) => {\n+                if self.overflow_data.has_overflow(self.stack.len()) {\n+                    return Err(self.deal_with_overflow(tcx, goal));\n+                }\n+\n+                let depth = self.stack.push(StackElem { goal, has_been_used: false });\n+                let response = super::response_no_constraints(tcx, goal, Certainty::Yes);\n+                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, goal });\n+                v.insert(entry_index);\n+                Ok(())\n+            }\n+            // We have a nested goal which relies on a goal `root` deeper in the stack.\n+            //\n+            // We first store that we may have to rerun `evaluate_goal` for `root` in case the\n+            // provisional response is not equal to the final response. We also update the depth\n+            // of all goals which recursively depend on our current goal to depend on `root`\n+            // instead.\n+            //\n+            // Finally we can return either the provisional response for that goal if we have a\n+            // coinductive cycle or an ambiguous result if the cycle is inductive.\n+            Entry::Occupied(entry_index) => {\n+                let entry_index = *entry_index.get();\n+\n+                cache.add_dependency_of_leaf_on(entry_index);\n+                let stack_depth = cache.depth(entry_index);\n+\n+                self.stack[stack_depth].has_been_used = true;\n+                // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n+                // We can also depend on goals which aren't part of the stack but coinductively\n+                // depend on the stack themselves. We already checked whether all the goals\n+                // between these goals and their root on the stack. This means that as long as\n+                // each goal in a cycle is checked for coinductivity by itself, simply checking\n+                // the stack is enough.\n+                if self.stack.raw[stack_depth.index()..]\n+                    .iter()\n+                    .all(|g| g.goal.value.predicate.is_coinductive(tcx))\n+                {\n+                    Err(cache.provisional_result(entry_index))\n+                } else {\n+                    Err(super::response_no_constraints(\n+                        tcx,\n+                        goal,\n+                        Certainty::Maybe(MaybeCause::Overflow),\n+                    ))\n+                }\n+            }\n+        }\n+    }\n+\n+    /// We cannot simply store the result of [super::EvalCtxt::compute_goal] as we have to deal with\n+    /// coinductive cycles.\n+    ///\n+    /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n+    /// while we are still computing that result. Because of this we continously recompute the\n+    /// cycle until the result of the previous iteration is equal to the final result, at which\n+    /// point we are done.\n+    ///\n+    /// This function returns `true` if we were able to finalize the goal and `false` if it has\n+    /// updated the provisional cache and we have to recompute the current goal.\n+    ///\n+    /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n+    pub(super) fn try_finalize_goal(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        actual_goal: CanonicalGoal<'tcx>,\n+        response: QueryResult<'tcx>,\n+    ) -> bool {\n+        let StackElem { goal, has_been_used } = self.stack.pop().unwrap();\n+        assert_eq!(goal, actual_goal);\n+\n+        let cache = &mut self.provisional_cache;\n+        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry = &mut cache.entries[provisional_entry_index];\n+        let depth = provisional_entry.depth;\n+        // Was the current goal the root of a cycle and was the provisional response\n+        // different from the final one.\n+        if has_been_used && provisional_entry.response != response {\n+            // If so, update the provisional reponse for this goal...\n+            provisional_entry.response = response;\n+            // ...remove all entries whose result depends on this goal\n+            // from the provisional cache...\n+            //\n+            // That's not completely correct, as a nested goal can also\n+            // depend on a goal which is lower in the stack so it doesn't\n+            // actually depend on the current goal. This should be fairly\n+            // rare and is hopefully not relevant for performance.\n+            #[allow(rustc::potential_query_instability)]\n+            cache.lookup_table.retain(|_key, index| *index <= provisional_entry_index);\n+            cache.entries.truncate(provisional_entry_index.index() + 1);\n+\n+            // ...and finally push our goal back on the stack and reevaluate it.\n+            self.stack.push(StackElem { goal, has_been_used: false });\n+            false\n+        } else {\n+            // If not, we're done with this goal.\n+            //\n+            // Check whether that this goal doesn't depend on a goal deeper on the stack\n+            // and if so, move it and all nested goals to the global cache.\n+            //\n+            // Note that if any nested goal were to depend on something deeper on the stack,\n+            // this would have also updated the depth of the current goal.\n+            if depth == self.stack.next_index() {\n+                for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..)\n+                {\n+                    let actual_index = cache.lookup_table.remove(&entry.goal);\n+                    debug_assert_eq!(Some(i), actual_index);\n+                    debug_assert!(entry.depth == depth);\n+                    cache::try_move_finished_goal_to_global_cache(\n+                        tcx,\n+                        &mut self.overflow_data,\n+                        &self.stack,\n+                        entry.goal,\n+                        entry.response,\n+                    );\n+                }\n+            }\n+            true\n+        }\n+    }\n+}"}, {"sha": "1dd3894c91adc009c9c9e8fbaa1103fed4beeca2", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "renamed", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -3,8 +3,8 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Limit;\n \n-use super::cache::response_no_constraints;\n-use super::{Certainty, EvalCtxt, MaybeCause, QueryResult};\n+use super::SearchGraph;\n+use crate::solve::{response_no_constraints, Certainty, EvalCtxt, MaybeCause, QueryResult};\n \n /// When detecting a solver overflow, we return ambiguity. Overflow can be\n /// *hidden* by either a fatal error in an **AND** or a trivial success in an **OR**.\n@@ -50,32 +50,35 @@ impl OverflowData {\n     }\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n-    pub(super) fn deal_with_overflow(\n+impl<'tcx> SearchGraph<'tcx> {\n+    pub fn deal_with_overflow(\n         &mut self,\n+        tcx: TyCtxt<'tcx>,\n         goal: Canonical<'tcx, impl Sized>,\n     ) -> QueryResult<'tcx> {\n         self.overflow_data.deal_with_overflow();\n-        response_no_constraints(self.tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n+        response_no_constraints(tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n     }\n+}\n \n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// A `while`-loop which tracks overflow.\n-    pub(super) fn repeat_while_none(\n+    pub fn repeat_while_none(\n         &mut self,\n         mut loop_body: impl FnMut(&mut Self) -> Option<Result<Certainty, NoSolution>>,\n     ) -> Result<Certainty, NoSolution> {\n-        let start_depth = self.overflow_data.additional_depth;\n-        let depth = self.provisional_cache.current_depth();\n-        while !self.overflow_data.has_overflow(depth) {\n+        let start_depth = self.search_graph.overflow_data.additional_depth;\n+        let depth = self.search_graph.stack.len();\n+        while !self.search_graph.overflow_data.has_overflow(depth) {\n             if let Some(result) = loop_body(self) {\n-                self.overflow_data.additional_depth = start_depth;\n+                self.search_graph.overflow_data.additional_depth = start_depth;\n                 return result;\n             }\n \n-            self.overflow_data.additional_depth += 1;\n+            self.search_graph.overflow_data.additional_depth += 1;\n         }\n-        self.overflow_data.additional_depth = start_depth;\n-        self.overflow_data.deal_with_overflow();\n+        self.search_graph.overflow_data.additional_depth = start_depth;\n+        self.search_graph.overflow_data.deal_with_overflow();\n         Ok(Certainty::Maybe(MaybeCause::Overflow))\n     }\n }", "previous_filename": "compiler/rustc_trait_selection/src/solve/overflow.rs"}, {"sha": "4b6d673c999c96fd7dab198e99a3aec327ceba70", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 170, "deletions": 70, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -2,58 +2,20 @@\n \n use std::iter;\n \n-use super::assembly::{self, AssemblyCtxt};\n-use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use super::assembly::{self, Candidate, CandidateSource};\n+use super::infcx_ext::InferCtxtExt;\n+use super::{Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::InferOk;\n+use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n-use rustc_middle::ty::TraitPredicate;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{TraitPredicate, TypeVisitable};\n use rustc_span::DUMMY_SP;\n \n-#[allow(dead_code)] // FIXME: implement and use all variants.\n-#[derive(Debug, Clone, Copy)]\n-pub(super) enum CandidateSource {\n-    /// Some user-defined impl with the given `DefId`.\n-    Impl(DefId),\n-    /// The n-th caller bound in the `param_env` of our goal.\n-    ///\n-    /// This is pretty much always a bound from the `where`-clauses of the\n-    /// currently checked item.\n-    ParamEnv(usize),\n-    /// A bound on the `self_ty` in case it is a projection or an opaque type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore (for syntax highlighting)\n-    /// trait Trait {\n-    ///     type Assoc: OtherTrait;\n-    /// }\n-    /// ```\n-    ///\n-    /// We know that `<Whatever as Trait>::Assoc: OtherTrait` holds by looking at\n-    /// the bounds on `Trait::Assoc`.\n-    AliasBound(usize),\n-    /// A builtin implementation for some specific traits, used in cases\n-    /// where we cannot rely an ordinary library implementations.\n-    ///\n-    /// The most notable examples are `Sized`, `Copy` and `Clone`. This is also\n-    /// used for the `DiscriminantKind` and `Pointee` trait, both of which have\n-    /// an associated type.\n-    Builtin,\n-    /// An automatic impl for an auto trait, e.g. `Send`. These impls recursively look\n-    /// at the constituent types of the `self_ty` to check whether the auto trait\n-    /// is implemented for those.\n-    AutoImpl,\n-}\n-\n-type Candidate<'tcx> = assembly::Candidate<'tcx, TraitPredicate<'tcx>>;\n+pub mod structural_traits;\n \n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n-    type CandidateSource = CandidateSource;\n-\n     fn self_ty(self) -> Ty<'tcx> {\n         self.self_ty()\n     }\n@@ -67,55 +29,194 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     }\n \n     fn consider_impl_candidate(\n-        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n         impl_def_id: DefId,\n-    ) {\n-        let tcx = acx.cx.tcx;\n+    ) -> QueryResult<'tcx> {\n+        let tcx = ecx.tcx();\n \n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n         if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n-            return;\n+            return Err(NoSolution);\n         }\n \n-        acx.infcx.probe(|_| {\n-            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        ecx.infcx.probe(|_| {\n+            let impl_substs = ecx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let Ok(InferOk { obligations, .. }) = acx\n-                .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .define_opaque_types(false)\n-                .eq(goal.predicate.trait_ref, impl_trait_ref)\n-                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n-            else {\n-                return\n-            };\n+            let mut nested_goals =\n+                ecx.infcx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n+            nested_goals.extend(where_clause_bounds);\n+            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+        })\n+    }\n+\n+    fn consider_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred() {\n+            // FIXME: Constness and polarity\n+            ecx.infcx.probe(|_| {\n+                let assumption_trait_pred =\n+                    ecx.infcx.instantiate_bound_vars_with_infer(poly_trait_pred);\n+                let nested_goals = ecx.infcx.eq(\n+                    goal.param_env,\n+                    goal.predicate.trait_ref,\n+                    assumption_trait_pred.trait_ref,\n+                )?;\n+                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n+    fn consider_auto_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        ecx.probe_and_evaluate_goal_for_constituent_tys(\n+            goal,\n+            structural_traits::instantiate_constituent_tys_for_auto_trait,\n+        )\n+    }\n \n-            let nested_goals =\n-                obligations.into_iter().map(|o| o.into()).chain(where_clause_bounds).collect();\n+    fn consider_trait_alias_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = ecx.tcx();\n \n-            let Ok(certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n-            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+        ecx.infcx.probe(|_| {\n+            let nested_obligations = tcx\n+                .predicates_of(goal.predicate.def_id())\n+                .instantiate(tcx, goal.predicate.trait_ref.substs);\n+            ecx.evaluate_all_and_make_canonical_response(\n+                nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)).collect(),\n+            )\n         })\n     }\n+\n+    fn consider_builtin_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        ecx.probe_and_evaluate_goal_for_constituent_tys(\n+            goal,\n+            structural_traits::instantiate_constituent_tys_for_sized_trait,\n+        )\n+    }\n+\n+    fn consider_builtin_copy_clone_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        ecx.probe_and_evaluate_goal_for_constituent_tys(\n+            goal,\n+            structural_traits::instantiate_constituent_tys_for_copy_clone_trait,\n+        )\n+    }\n+\n+    fn consider_builtin_pointer_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        if goal.predicate.self_ty().has_non_region_infer() {\n+            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+        }\n+\n+        let tcx = ecx.tcx();\n+        let self_ty = tcx.erase_regions(goal.predicate.self_ty());\n+\n+        if let Ok(layout) = tcx.layout_of(goal.param_env.and(self_ty))\n+            &&  let usize_layout = tcx.layout_of(ty::ParamEnv::empty().and(tcx.types.usize)).unwrap().layout\n+            && layout.layout.size() == usize_layout.size()\n+            && layout.layout.align().abi == usize_layout.align().abi\n+        {\n+            // FIXME: We could make this faster by making a no-constraints response\n+            ecx.make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n+    fn consider_builtin_fn_trait_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        goal_kind: ty::ClosureKind,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(tupled_inputs_and_output) =\n+            structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                ecx.tcx(),\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )?\n+        {\n+            let pred = tupled_inputs_and_output\n+                .map_bound(|(inputs, _)| {\n+                    ecx.tcx()\n+                        .mk_trait_ref(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs])\n+                })\n+                .to_predicate(ecx.tcx());\n+            Self::consider_assumption(ecx, goal, pred)\n+        } else {\n+            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n+        }\n+    }\n+\n+    fn consider_builtin_tuple_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        if let ty::Tuple(..) = goal.predicate.self_ty().kind() {\n+            ecx.make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n }\n \n-impl<'tcx> EvalCtxt<'tcx> {\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    /// Convenience function for traits that are structural, i.e. that only\n+    /// have nested subgoals that only change the self type. Unlike other\n+    /// evaluate-like helpers, this does a probe, so it doesn't need to be\n+    /// wrapped in one.\n+    fn probe_and_evaluate_goal_for_constituent_tys(\n+        &mut self,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n+        constituent_tys: impl Fn(&InferCtxt<'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n+    ) -> QueryResult<'tcx> {\n+        self.infcx.probe(|_| {\n+            self.evaluate_all_and_make_canonical_response(\n+                constituent_tys(self.infcx, goal.predicate.self_ty())?\n+                    .into_iter()\n+                    .map(|ty| {\n+                        goal.with(\n+                            self.tcx(),\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(self.tcx(), ty)),\n+                        )\n+                    })\n+                    .collect(),\n+            )\n+        })\n+    }\n+\n     pub(super) fn compute_trait_goal(\n         &mut self,\n-        goal: CanonicalGoal<'tcx, TraitPredicate<'tcx>>,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n+        let candidates = self.assemble_and_evaluate_candidates(goal);\n         self.merge_trait_candidates_discard_reservation_impls(candidates)\n     }\n \n@@ -169,14 +270,13 @@ impl<'tcx> EvalCtxt<'tcx> {\n             (CandidateSource::Impl(_), _)\n             | (CandidateSource::ParamEnv(_), _)\n             | (CandidateSource::AliasBound(_), _)\n-            | (CandidateSource::Builtin, _)\n-            | (CandidateSource::AutoImpl, _) => unimplemented!(),\n+            | (CandidateSource::BuiltinImpl, _) => unimplemented!(),\n         }\n     }\n \n     fn discard_reservation_impl(&self, candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n         if let CandidateSource::Impl(def_id) = candidate.source {\n-            if let ty::ImplPolarity::Reservation = self.tcx.impl_polarity(def_id) {\n+            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n                 debug!(\"Selected reservation impl\");\n                 // FIXME: reduce candidate to ambiguous\n                 // FIXME: replace `var_values` with identity, yeet external constraints."}, {"sha": "a11cd13cb0856b4df3ace3c1261baf9a69d9d4dc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -0,0 +1,223 @@\n+use rustc_hir::{Movability, Mutability};\n+use rustc_infer::{infer::InferCtxt, traits::query::NoSolution};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+// Calculates the constituent types of a type for `auto trait` purposes.\n+//\n+// For types with an \"existential\" binder, i.e. generator witnesses, we also\n+// instantiate the binder with placeholders eagerly.\n+pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    let tcx = infcx.tcx;\n+    match *ty.kind() {\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Str\n+        | ty::Error(_)\n+        | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::Never\n+        | ty::Char => Ok(vec![]),\n+\n+        ty::Placeholder(..)\n+        | ty::Dynamic(..)\n+        | ty::Param(..)\n+        | ty::Foreign(..)\n+        | ty::Alias(ty::Projection, ..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n+\n+        ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::RawPtr(ty::TypeAndMut { ty: element_ty, .. }) | ty::Ref(_, element_ty, _) => {\n+            Ok(vec![element_ty])\n+        }\n+\n+        ty::Array(element_ty, _) | ty::Slice(element_ty) => Ok(vec![element_ty]),\n+\n+        ty::Tuple(ref tys) => {\n+            // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n+            Ok(tys.iter().collect())\n+        }\n+\n+        ty::Closure(_, ref substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n+\n+        ty::Generator(_, ref substs, _) => {\n+            let generator_substs = substs.as_generator();\n+            Ok(vec![generator_substs.tupled_upvars_ty(), generator_substs.witness()])\n+        }\n+\n+        ty::GeneratorWitness(types) => {\n+            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+        }\n+\n+        // For `PhantomData<T>`, we pass `T`.\n+        ty::Adt(def, substs) if def.is_phantom_data() => Ok(vec![substs.type_at(0)]),\n+\n+        ty::Adt(def, substs) => Ok(def.all_fields().map(|f| f.ty(tcx, substs)).collect()),\n+\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+            // We can resolve the `impl Trait` to its concrete type,\n+            // which enforces a DAG between the functions requiring\n+            // the auto trait bounds in question.\n+            Ok(vec![tcx.bound_type_of(def_id).subst(tcx, substs)])\n+        }\n+    }\n+}\n+\n+pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    match *ty.kind() {\n+        ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::RawPtr(..)\n+        | ty::Char\n+        | ty::Ref(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(..)\n+        | ty::Array(..)\n+        | ty::Closure(..)\n+        | ty::Never\n+        | ty::Dynamic(_, _, ty::DynStar)\n+        | ty::Error(_) => Ok(vec![]),\n+\n+        ty::Str\n+        | ty::Slice(_)\n+        | ty::Dynamic(..)\n+        | ty::Foreign(..)\n+        | ty::Alias(..)\n+        | ty::Param(_)\n+        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n+\n+        ty::Placeholder(..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::Tuple(tys) => Ok(tys.to_vec()),\n+\n+        ty::Adt(def, substs) => {\n+            let sized_crit = def.sized_constraint(infcx.tcx);\n+            Ok(sized_crit\n+                .0\n+                .iter()\n+                .map(|ty| sized_crit.rebind(*ty).subst(infcx.tcx, substs))\n+                .collect())\n+        }\n+    }\n+}\n+\n+pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<Ty<'tcx>>, NoSolution> {\n+    match *ty.kind() {\n+        ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Error(_) => Ok(vec![]),\n+\n+        // Implementations are provided in core\n+        ty::Uint(_)\n+        | ty::Int(_)\n+        | ty::Bool\n+        | ty::Float(_)\n+        | ty::Char\n+        | ty::RawPtr(..)\n+        | ty::Never\n+        | ty::Ref(_, _, Mutability::Not)\n+        | ty::Array(..) => Err(NoSolution),\n+\n+        ty::Dynamic(..)\n+        | ty::Str\n+        | ty::Slice(_)\n+        | ty::Generator(_, _, Movability::Static)\n+        | ty::Foreign(..)\n+        | ty::Ref(_, _, Mutability::Mut)\n+        | ty::Adt(_, _)\n+        | ty::Alias(_, _)\n+        | ty::Param(_)\n+        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n+\n+        ty::Placeholder(..)\n+        | ty::Bound(..)\n+        | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n+\n+        ty::Tuple(tys) => Ok(tys.to_vec()),\n+\n+        ty::Closure(_, substs) => Ok(vec![substs.as_closure().tupled_upvars_ty()]),\n+\n+        ty::Generator(_, substs, Movability::Movable) => {\n+            if infcx.tcx.features().generator_clone {\n+                let generator = substs.as_generator();\n+                Ok(vec![generator.tupled_upvars_ty(), generator.witness()])\n+            } else {\n+                Err(NoSolution)\n+            }\n+        }\n+\n+        ty::GeneratorWitness(types) => {\n+            Ok(infcx.replace_bound_vars_with_placeholders(types).to_vec())\n+        }\n+    }\n+}\n+\n+pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    goal_kind: ty::ClosureKind,\n+) -> Result<Option<ty::Binder<'tcx, (Ty<'tcx>, Ty<'tcx>)>>, NoSolution> {\n+    match *self_ty.kind() {\n+        ty::FnDef(def_id, substs) => Ok(Some(\n+            tcx.bound_fn_sig(def_id)\n+                .subst(tcx, substs)\n+                .map_bound(|sig| (tcx.mk_tup(sig.inputs().iter()), sig.output())),\n+        )),\n+        ty::FnPtr(sig) => {\n+            Ok(Some(sig.map_bound(|sig| (tcx.mk_tup(sig.inputs().iter()), sig.output()))))\n+        }\n+        ty::Closure(_, substs) => {\n+            let closure_substs = substs.as_closure();\n+            match closure_substs.kind_ty().to_opt_closure_kind() {\n+                Some(closure_kind) if closure_kind.extends(goal_kind) => {}\n+                None => return Ok(None),\n+                _ => return Err(NoSolution),\n+            }\n+            Ok(Some(closure_substs.sig().map_bound(|sig| (sig.inputs()[0], sig.output()))))\n+        }\n+        ty::Bool\n+        | ty::Char\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Adt(_, _)\n+        | ty::Foreign(_)\n+        | ty::Str\n+        | ty::Array(_, _)\n+        | ty::Slice(_)\n+        | ty::RawPtr(_)\n+        | ty::Ref(_, _, _)\n+        | ty::Dynamic(_, _, _)\n+        | ty::Generator(_, _, _)\n+        | ty::GeneratorWitness(_)\n+        | ty::Never\n+        | ty::Tuple(_)\n+        | ty::Alias(_, _)\n+        | ty::Param(_)\n+        | ty::Placeholder(_)\n+        | ty::Bound(_, _)\n+        | ty::Infer(_)\n+        | ty::Error(_) => Err(NoSolution),\n+    }\n+}"}, {"sha": "225c1050c7c952fc41230b7bdde07365d65ad419", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -401,12 +401,12 @@ fn resolve_negative_obligation<'tcx>(\n     infcx.resolve_regions(&outlives_env).is_empty()\n }\n \n+#[instrument(level = \"debug\", skip(tcx), ret)]\n pub fn trait_ref_is_knowable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), Conflict> {\n-    debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n-    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n+    if orphan_check_trait_ref(trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n         // substitution of this trait-ref.\n         return Err(Conflict::Downstream);\n@@ -429,11 +429,9 @@ pub fn trait_ref_is_knowable<'tcx>(\n     // and if we are an intermediate owner, then we don't care\n     // about future-compatibility, which means that we're OK if\n     // we are an owner.\n-    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok() {\n-        debug!(\"trait_ref_is_knowable: orphan check passed\");\n+    if orphan_check_trait_ref(trait_ref, InCrate::Local).is_ok() {\n         Ok(())\n     } else {\n-        debug!(\"trait_ref_is_knowable: nonlocal, nonfundamental, unowned\");\n         Err(Conflict::Upstream)\n     }\n }\n@@ -445,6 +443,7 @@ pub fn trait_ref_is_local_or_fundamental<'tcx>(\n     trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n }\n \n+#[derive(Debug)]\n pub enum OrphanCheckErr<'tcx> {\n     NonLocalInputType(Vec<(Ty<'tcx>, bool /* Is this the first input type? */)>),\n     UncoveredTy(Ty<'tcx>, Option<Ty<'tcx>>),\n@@ -456,21 +455,20 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n+#[instrument(level = \"debug\", skip(tcx), ret)]\n pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanCheckErr<'_>> {\n-    debug!(\"orphan_check({:?})\", impl_def_id);\n-\n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().subst_identity();\n-    debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n+    debug!(?trait_ref);\n \n     // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.is_local() {\n         debug!(\"trait {:?} is local to current crate\", trait_ref.def_id);\n         return Ok(());\n     }\n \n-    orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n+    orphan_check_trait_ref(trait_ref, InCrate::Local)\n }\n \n /// Checks whether a trait-ref is potentially implementable by a crate.\n@@ -559,21 +557,19 @@ pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanChe\n ///\n /// Note that this function is never called for types that have both type\n /// parameters and inference variables.\n+#[instrument(level = \"trace\", ret)]\n fn orphan_check_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n     in_crate: InCrate,\n ) -> Result<(), OrphanCheckErr<'tcx>> {\n-    debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\", trait_ref, in_crate);\n-\n     if trait_ref.needs_infer() && trait_ref.needs_subst() {\n         bug!(\n             \"can't orphan check a trait ref with both params and inference variables {:?}\",\n             trait_ref\n         );\n     }\n \n-    let mut checker = OrphanChecker::new(tcx, in_crate);\n+    let mut checker = OrphanChecker::new(in_crate);\n     match trait_ref.visit_with(&mut checker) {\n         ControlFlow::Continue(()) => Err(OrphanCheckErr::NonLocalInputType(checker.non_local_tys)),\n         ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(ty)) => {\n@@ -592,7 +588,6 @@ fn orphan_check_trait_ref<'tcx>(\n }\n \n struct OrphanChecker<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n     in_crate: InCrate,\n     in_self_ty: bool,\n     /// Ignore orphan check failures and exclusively search for the first\n@@ -602,9 +597,8 @@ struct OrphanChecker<'tcx> {\n }\n \n impl<'tcx> OrphanChecker<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, in_crate: InCrate) -> Self {\n+    fn new(in_crate: InCrate) -> Self {\n         OrphanChecker {\n-            tcx,\n             in_crate,\n             in_self_ty: true,\n             search_first_local_ty: false,\n@@ -614,12 +608,12 @@ impl<'tcx> OrphanChecker<'tcx> {\n \n     fn found_non_local_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<OrphanCheckEarlyExit<'tcx>> {\n         self.non_local_tys.push((t, self.in_self_ty));\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     fn found_param_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<OrphanCheckEarlyExit<'tcx>> {\n         if self.search_first_local_ty {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         } else {\n             ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(t))\n         }\n@@ -641,7 +635,7 @@ enum OrphanCheckEarlyExit<'tcx> {\n impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n     type BreakTy = OrphanCheckEarlyExit<'tcx>;\n     fn visit_region(&mut self, _r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n@@ -697,13 +691,17 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n                 }\n             }\n             ty::Error(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n-            ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                self.tcx.sess.delay_span_bug(\n-                    DUMMY_SP,\n-                    format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n-                );\n-                ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+            ty::Closure(did, ..) | ty::Generator(did, ..) => {\n+                if self.def_id_is_local(did) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n             }\n+            // This should only be created when checking whether we have to check whether some\n+            // auto trait impl applies. There will never be multiple impls, so we can just\n+            // act as if it were a local type here.\n+            ty::GeneratorWitness(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n             ty::Alias(ty::Opaque, ..) => {\n                 // This merits some explanation.\n                 // Normally, opaque types are not involved when performing\n@@ -756,6 +754,6 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n     /// parameters, allowing uncovered const parameters in impls seems more useful\n     /// than allowing `impl<T> Trait<local_fn_ptr, T> for i32` to compile.\n     fn visit_const(&mut self, _c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n }"}, {"sha": "f779d9dd8d93560302988bd9d03d981eda133ae8", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -198,7 +198,7 @@ fn satisfied_from_param_env<'tcx>(\n                 // If we start allowing directly writing `ConstKind::Expr` without an intermediate anon const\n                 // this will be incorrect. It might be worth investigating making `predicates_of` elaborate\n                 // all of the `ConstEvaluatable` bounds rather than having a visitor here.\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             }\n         }\n     }"}, {"sha": "0419bb3f724f9ed86454dc73c60dc5db20502ada", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -82,9 +82,7 @@ pub fn recompute_applicable_impls<'tcx>(\n \n     let predicates =\n         tcx.predicates_of(obligation.cause.body_id.owner.to_def_id()).instantiate_identity(tcx);\n-    for obligation in\n-        elaborate_predicates_with_span(tcx, std::iter::zip(predicates.predicates, predicates.spans))\n-    {\n+    for obligation in elaborate_predicates_with_span(tcx, predicates.into_iter()) {\n         let kind = obligation.predicate.kind();\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = kind.skip_binder()\n             && param_env_candidate_may_apply(kind.rebind(trait_pred))"}, {"sha": "52971486c553e361fe1d91cf55947ca15de59b45", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1350,6 +1350,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         expected_trait_ref,\n                         obligation.cause.code(),\n                         found_node,\n+                        obligation.param_env,\n                     )\n                 } else {\n                     let (closure_span, closure_arg_span, found) = found_did\n@@ -2932,7 +2933,7 @@ impl<'tcx> ty::TypeVisitor<'tcx> for HasNumericInferVisitor {\n         if matches!(ty.kind(), ty::Infer(ty::FloatVar(_) | ty::IntVar(_))) {\n             ControlFlow::Break(())\n         } else {\n-            ControlFlow::CONTINUE\n+            ControlFlow::Continue(())\n         }\n     }\n }"}, {"sha": "39e50b2accf17af05b1f4acb4f0c8d2451267e81", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -283,6 +283,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n         expected: ty::PolyTraitRef<'tcx>,\n         cause: &ObligationCauseCode<'tcx>,\n         found_node: Option<Node<'_>>,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n \n     fn note_conflicting_closure_bounds(\n@@ -1123,7 +1124,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n                 }\n                 ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                    self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n+                    self.tcx.item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n                         if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n                         && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n                         // args tuple will always be substs[1]\n@@ -1978,6 +1979,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         expected: ty::PolyTraitRef<'tcx>,\n         cause: &ObligationCauseCode<'tcx>,\n         found_node: Option<Node<'_>>,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         pub(crate) fn build_fn_sig_ty<'tcx>(\n             infcx: &InferCtxt<'tcx>,\n@@ -2040,7 +2042,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         self.note_conflicting_closure_bounds(cause, &mut err);\n \n         if let Some(found_node) = found_node {\n-            hint_missing_borrow(span, found, expected, found_node, &mut err);\n+            hint_missing_borrow(self, param_env, span, found, expected, found_node, &mut err);\n         }\n \n         err\n@@ -2070,7 +2072,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n             // Find another predicate whose self-type is equal to the expected self type,\n             // but whose substs don't match.\n-            let other_pred = std::iter::zip(&predicates.predicates, &predicates.spans)\n+            let other_pred = predicates.into_iter()\n                 .enumerate()\n                 .find(|(other_idx, (pred, _))| match pred.kind().skip_binder() {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n@@ -2095,7 +2097,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // If we found one, then it's very likely the cause of the error.\n             if let Some((_, (_, other_pred_span))) = other_pred {\n                 err.span_note(\n-                    *other_pred_span,\n+                    other_pred_span,\n                     \"closure inferred to have a different signature due to this bound\",\n                 );\n             }\n@@ -3747,6 +3749,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n /// Add a hint to add a missing borrow or remove an unnecessary one.\n fn hint_missing_borrow<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n     found: Ty<'tcx>,\n     expected: Ty<'tcx>,\n@@ -3769,7 +3773,7 @@ fn hint_missing_borrow<'tcx>(\n     // This could be a variant constructor, for example.\n     let Some(fn_decl) = found_node.fn_decl() else { return; };\n \n-    let arg_spans = fn_decl.inputs.iter().map(|ty| ty.span);\n+    let args = fn_decl.inputs.iter().map(|ty| ty);\n \n     fn get_deref_type_and_refs(mut ty: Ty<'_>) -> (Ty<'_>, usize) {\n         let mut refs = 0;\n@@ -3785,29 +3789,42 @@ fn hint_missing_borrow<'tcx>(\n     let mut to_borrow = Vec::new();\n     let mut remove_borrow = Vec::new();\n \n-    for ((found_arg, expected_arg), arg_span) in found_args.zip(expected_args).zip(arg_spans) {\n+    for ((found_arg, expected_arg), arg) in found_args.zip(expected_args).zip(args) {\n         let (found_ty, found_refs) = get_deref_type_and_refs(*found_arg);\n         let (expected_ty, expected_refs) = get_deref_type_and_refs(*expected_arg);\n \n-        if found_ty == expected_ty {\n+        if infcx.can_eq(param_env, found_ty, expected_ty).is_ok() {\n             if found_refs < expected_refs {\n-                to_borrow.push((arg_span, expected_arg.to_string()));\n+                to_borrow.push((arg.span.shrink_to_lo(), \"&\".repeat(expected_refs - found_refs)));\n             } else if found_refs > expected_refs {\n-                remove_borrow.push((arg_span, expected_arg.to_string()));\n+                let mut span = arg.span.shrink_to_lo();\n+                let mut left = found_refs - expected_refs;\n+                let mut ty = arg;\n+                while let hir::TyKind::Ref(_, mut_ty) = &ty.kind && left > 0 {\n+                    span = span.with_hi(mut_ty.ty.span.lo());\n+                    ty = mut_ty.ty;\n+                    left -= 1;\n+                }\n+                let sugg = if left == 0 {\n+                    (span, String::new())\n+                } else {\n+                    (arg.span, expected_arg.to_string())\n+                };\n+                remove_borrow.push(sugg);\n             }\n         }\n     }\n \n     if !to_borrow.is_empty() {\n-        err.multipart_suggestion(\n+        err.multipart_suggestion_verbose(\n             \"consider borrowing the argument\",\n             to_borrow,\n             Applicability::MaybeIncorrect,\n         );\n     }\n \n     if !remove_borrow.is_empty() {\n-        err.multipart_suggestion(\n+        err.multipart_suggestion_verbose(\n             \"do not borrow the argument\",\n             remove_borrow,\n             Applicability::MaybeIncorrect,"}, {"sha": "a41a601f2db076a700bdb32b787a202268f2a914", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 70, "deletions": 23, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,29 +1,36 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n-use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, ObligationCause};\n \n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n+use rustc_infer::{infer::outlives::env::OutlivesEnvironment, traits::FulfillmentError};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n \n-use crate::traits::error_reporting::TypeErrCtxtExt;\n+use super::outlives_bounds::InferCtxtExt;\n \n-#[derive(Clone)]\n pub enum CopyImplementationError<'tcx> {\n-    InfrigingFields(Vec<(&'tcx ty::FieldDef, Ty<'tcx>)>),\n+    InfrigingFields(Vec<(&'tcx ty::FieldDef, Ty<'tcx>, InfringingFieldsReason<'tcx>)>),\n     NotAnAdt,\n     HasDestructor,\n }\n \n-pub fn can_type_implement_copy<'tcx>(\n+pub enum InfringingFieldsReason<'tcx> {\n+    Fulfill(Vec<FulfillmentError<'tcx>>),\n+    Regions(Vec<RegionResolutionError<'tcx>>),\n+}\n+\n+/// Checks that the fields of the type (an ADT) all implement copy.\n+///\n+/// If fields don't implement copy, return an error containing a list of\n+/// those violating fields. If it's not an ADT, returns `Err(NotAnAdt)`.\n+pub fn type_allowed_to_implement_copy<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     self_type: Ty<'tcx>,\n     parent_cause: ObligationCause<'tcx>,\n ) -> Result<(), CopyImplementationError<'tcx>> {\n-    // FIXME: (@jroesch) float this code up\n-    let infcx = tcx.infer_ctxt().build();\n     let (adt, substs) = match self_type.kind() {\n         // These types used to have a builtin impl.\n         // Now libcore provides that impl.\n@@ -42,42 +49,82 @@ pub fn can_type_implement_copy<'tcx>(\n         _ => return Err(CopyImplementationError::NotAnAdt),\n     };\n \n+    let copy_def_id = tcx.require_lang_item(hir::LangItem::Copy, Some(parent_cause.span));\n+\n     let mut infringing = Vec::new();\n     for variant in adt.variants() {\n         for field in &variant.fields {\n-            let ty = field.ty(tcx, substs);\n-            if ty.references_error() {\n+            // Do this per-field to get better error messages.\n+            let infcx = tcx.infer_ctxt().build();\n+            let ocx = traits::ObligationCtxt::new(&infcx);\n+\n+            let unnormalized_ty = field.ty(tcx, substs);\n+            if unnormalized_ty.references_error() {\n                 continue;\n             }\n-            let span = tcx.def_span(field.did);\n+\n+            let field_span = tcx.def_span(field.did);\n+            let field_ty_span = match tcx.hir().get_if_local(field.did) {\n+                Some(hir::Node::Field(field_def)) => field_def.ty.span,\n+                _ => field_span,\n+            };\n+\n             // FIXME(compiler-errors): This gives us better spans for bad\n             // projection types like in issue-50480.\n             // If the ADT has substs, point to the cause we are given.\n             // If it does not, then this field probably doesn't normalize\n             // to begin with, and point to the bad field's span instead.\n-            let cause = if field\n+            let normalization_cause = if field\n                 .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did()))\n                 .has_non_region_param()\n             {\n                 parent_cause.clone()\n             } else {\n-                ObligationCause::dummy_with_span(span)\n-            };\n-            match traits::fully_normalize(&infcx, cause, param_env, ty) {\n-                Ok(ty) => {\n-                    if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n-                        infringing.push((field, ty));\n-                    }\n-                }\n-                Err(errors) => {\n-                    infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n-                }\n+                ObligationCause::dummy_with_span(field_ty_span)\n             };\n+            let ty = ocx.normalize(&normalization_cause, param_env, unnormalized_ty);\n+            let normalization_errors = ocx.select_where_possible();\n+            if !normalization_errors.is_empty() {\n+                tcx.sess.delay_span_bug(field_span, format!(\"couldn't normalize struct field `{unnormalized_ty}` when checking Copy implementation\"));\n+                continue;\n+            }\n+\n+            ocx.register_bound(\n+                ObligationCause::dummy_with_span(field_ty_span),\n+                param_env,\n+                ty,\n+                copy_def_id,\n+            );\n+            let errors = ocx.select_all_or_error();\n+            if !errors.is_empty() {\n+                infringing.push((field, ty, InfringingFieldsReason::Fulfill(errors)));\n+            }\n+\n+            // Check regions assuming the self type of the impl is WF\n+            let outlives_env = OutlivesEnvironment::with_bounds(\n+                param_env,\n+                Some(&infcx),\n+                infcx.implied_bounds_tys(\n+                    param_env,\n+                    parent_cause.body_id,\n+                    FxIndexSet::from_iter([self_type]),\n+                ),\n+            );\n+            infcx.process_registered_region_obligations(\n+                outlives_env.region_bound_pairs(),\n+                param_env,\n+            );\n+            let errors = infcx.resolve_regions(&outlives_env);\n+            if !errors.is_empty() {\n+                infringing.push((field, ty, InfringingFieldsReason::Regions(errors)));\n+            }\n         }\n     }\n+\n     if !infringing.is_empty() {\n         return Err(CopyImplementationError::InfrigingFields(infringing));\n     }\n+\n     if adt.has_dtor(tcx) {\n         return Err(CopyImplementationError::HasDestructor);\n     }"}, {"sha": "f036a311d464ccc648a2989e34a0bd2824892ebc", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -115,14 +115,12 @@ pub fn predicates_for_generics<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     generic_bounds: ty::InstantiatedPredicates<'tcx>,\n ) -> impl Iterator<Item = PredicateObligation<'tcx>> {\n-    std::iter::zip(generic_bounds.predicates, generic_bounds.spans).enumerate().map(\n-        move |(idx, (predicate, span))| Obligation {\n-            cause: cause(idx, span),\n-            recursion_depth: 0,\n-            param_env,\n-            predicate,\n-        },\n-    )\n+    generic_bounds.into_iter().enumerate().map(move |(idx, (predicate, span))| Obligation {\n+        cause: cause(idx, span),\n+        recursion_depth: 0,\n+        param_env,\n+        predicate,\n+    })\n }\n \n /// Determines whether the type `ty` is known to meet `bound` and\n@@ -495,7 +493,7 @@ fn is_impossible_method(tcx: TyCtxt<'_>, (impl_def_id, trait_item_def_id): (DefI\n                 && let param_def_id = self.generics.type_param(param, self.tcx).def_id\n                 && self.tcx.parent(param_def_id) == self.trait_item_def_id\n             {\n-                return ControlFlow::BREAK;\n+                return ControlFlow::Break(());\n             }\n             t.super_visit_with(self)\n         }\n@@ -504,7 +502,7 @@ fn is_impossible_method(tcx: TyCtxt<'_>, (impl_def_id, trait_item_def_id): (DefI\n                 && let param_def_id = self.generics.region_param(&param, self.tcx).def_id\n                 && self.tcx.parent(param_def_id) == self.trait_item_def_id\n             {\n-                return ControlFlow::BREAK;\n+                return ControlFlow::Break(());\n             }\n             r.super_visit_with(self)\n         }\n@@ -513,7 +511,7 @@ fn is_impossible_method(tcx: TyCtxt<'_>, (impl_def_id, trait_item_def_id): (DefI\n                 && let param_def_id = self.generics.const_param(&param, self.tcx).def_id\n                 && self.tcx.parent(param_def_id) == self.trait_item_def_id\n             {\n-                return ControlFlow::BREAK;\n+                return ControlFlow::Break(());\n             }\n             ct.super_visit_with(self)\n         }"}, {"sha": "c9121212cd8f16b9b115ab1ac703b7895d793790", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -783,16 +783,16 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n             match t.kind() {\n                 ty::Param(_) => {\n                     if t == self.tcx.types.self_param {\n-                        ControlFlow::BREAK\n+                        ControlFlow::Break(())\n                     } else {\n-                        ControlFlow::CONTINUE\n+                        ControlFlow::Continue(())\n                     }\n                 }\n                 ty::Alias(ty::Projection, ref data)\n                     if self.tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder =>\n                 {\n                     // We'll deny these later in their own pass\n-                    ControlFlow::CONTINUE\n+                    ControlFlow::Continue(())\n                 }\n                 ty::Alias(ty::Projection, ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n@@ -820,7 +820,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n                         .contains(&data.trait_ref(self.tcx).def_id);\n \n                     if is_supertrait_of_current_trait {\n-                        ControlFlow::CONTINUE // do not walk contained types, do not report error, do collect $200\n+                        ControlFlow::Continue(()) // do not walk contained types, do not report error, do collect $200\n                     } else {\n                         t.super_visit_with(self) // DO walk contained types, POSSIBLY reporting an error\n                     }"}, {"sha": "fbc7eccedc88392d11f036ff43459322537836f6", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1375,7 +1375,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let bounds = match *obligation.predicate.self_ty().kind() {\n-        ty::Alias(_, ref data) => tcx.bound_item_bounds(data.def_id).subst(tcx, data.substs),\n+        ty::Alias(_, ref data) => tcx.item_bounds(data.def_id).subst(tcx, data.substs),\n         ty::Infer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n@@ -2259,25 +2259,23 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         tcx.predicates_of(impl_fn_def_id).instantiate(tcx, impl_fn_substs),\n         &mut obligations,\n     );\n-    obligations.extend(std::iter::zip(predicates.predicates, predicates.spans).map(\n-        |(pred, span)| {\n-            Obligation::with_depth(\n-                tcx,\n-                ObligationCause::new(\n-                    obligation.cause.span,\n-                    obligation.cause.body_id,\n-                    if span.is_dummy() {\n-                        super::ItemObligation(impl_fn_def_id)\n-                    } else {\n-                        super::BindingObligation(impl_fn_def_id, span)\n-                    },\n-                ),\n-                obligation.recursion_depth + 1,\n-                obligation.param_env,\n-                pred,\n-            )\n-        },\n-    ));\n+    obligations.extend(predicates.into_iter().map(|(pred, span)| {\n+        Obligation::with_depth(\n+            tcx,\n+            ObligationCause::new(\n+                obligation.cause.span,\n+                obligation.cause.body_id,\n+                if span.is_dummy() {\n+                    super::ItemObligation(impl_fn_def_id)\n+                } else {\n+                    super::BindingObligation(impl_fn_def_id, span)\n+                },\n+            ),\n+            obligation.recursion_depth + 1,\n+            obligation.param_env,\n+            pred,\n+        )\n+    }));\n \n     let ty = normalize_with_depth_to(\n         selcx,\n@@ -2303,10 +2301,10 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n     nested: &mut Vec<PredicateObligation<'tcx>>,\n ) {\n     let tcx = selcx.tcx();\n-    let own = tcx\n+    let predicates = tcx\n         .predicates_of(obligation.predicate.def_id)\n         .instantiate_own(tcx, obligation.predicate.substs);\n-    for (predicate, span) in std::iter::zip(own.predicates, own.spans) {\n+    for (predicate, span) in predicates {\n         let normalized = normalize_with_depth_to(\n             selcx,\n             obligation.param_env,"}, {"sha": "27247271d1f4d3f6aa0f989352ec3e38ed75e51e", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> TypeVisitor<'tcx> for MaxEscapingBoundVarVisitor {\n                 .escaping\n                 .max(t.outer_exclusive_binder().as_usize() - self.outer_index.as_usize());\n         }\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     #[inline]\n@@ -145,15 +145,15 @@ impl<'tcx> TypeVisitor<'tcx> for MaxEscapingBoundVarVisitor {\n             }\n             _ => {}\n         }\n-        ControlFlow::CONTINUE\n+        ControlFlow::Continue(())\n     }\n \n     fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match ct.kind() {\n             ty::ConstKind::Bound(debruijn, _) if debruijn >= self.outer_index => {\n                 self.escaping =\n                     self.escaping.max(debruijn.as_usize() - self.outer_index.as_usize());\n-                ControlFlow::CONTINUE\n+                ControlFlow::Continue(())\n             }\n             _ => ct.super_visit_with(self),\n         }\n@@ -201,7 +201,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n         // wait to fold the substs.\n \n         // Wrap this in a closure so we don't accidentally return from the outer function\n-        let res = (|| match *ty.kind() {\n+        let res = match *ty.kind() {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n@@ -210,7 +210,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n             {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n-                    Reveal::UserFacing => ty.try_super_fold_with(self),\n+                    Reveal::UserFacing => ty.try_super_fold_with(self)?,\n \n                     Reveal::All => {\n                         let substs = substs.try_fold_with(self)?;\n@@ -239,7 +239,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         }\n                         let folded_ty = ensure_sufficient_stack(|| self.try_fold_ty(concrete_ty));\n                         self.anon_depth -= 1;\n-                        folded_ty\n+                        folded_ty?\n                     }\n                 }\n             }\n@@ -287,9 +287,9 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // `tcx.normalize_projection_ty` may normalize to a type that still has\n                 // unevaluated consts, so keep normalizing here if that's the case.\n                 if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    Ok(res.try_super_fold_with(self)?)\n+                    res.try_super_fold_with(self)?\n                 } else {\n-                    Ok(res)\n+                    res\n                 }\n             }\n \n@@ -344,14 +344,14 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // `tcx.normalize_projection_ty` may normalize to a type that still has\n                 // unevaluated consts, so keep normalizing here if that's the case.\n                 if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    Ok(res.try_super_fold_with(self)?)\n+                    res.try_super_fold_with(self)?\n                 } else {\n-                    Ok(res)\n+                    res\n                 }\n             }\n \n-            _ => ty.try_super_fold_with(self),\n-        })()?;\n+            _ => ty.try_super_fold_with(self)?,\n+        };\n \n         self.cache.insert(ty, res);\n         Ok(res)"}, {"sha": "82a59831be30aec5ff9791487cec5b72f6df7ca6", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -160,8 +160,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => bug!(\"projection candidate for unexpected type: {:?}\", placeholder_self_ty),\n         };\n \n-        let candidate_predicate =\n-            tcx.bound_item_bounds(def_id).map_bound(|i| i[idx]).subst(tcx, substs);\n+        let candidate_predicate = tcx.item_bounds(def_id).map_bound(|i| i[idx]).subst(tcx, substs);\n         let candidate = candidate_predicate\n             .to_opt_poly_trait_pred()\n             .expect(\"projection candidate is not a trait predicate\")\n@@ -185,9 +184,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })?);\n \n         if let ty::Alias(ty::Projection, ..) = placeholder_self_ty.kind() {\n-            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates;\n-            debug!(?predicates, \"projection predicates\");\n-            for predicate in predicates {\n+            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+            for (predicate, _) in predicates {\n                 let normalized = normalize_with_depth_to(\n                     self,\n                     obligation.param_env,\n@@ -511,7 +509,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // This maybe belongs in wf, but that can't (doesn't) handle\n             // higher-ranked things.\n             // Prevent, e.g., `dyn Iterator<Item = str>`.\n-            for bound in self.tcx().bound_item_bounds(assoc_type).transpose_iter() {\n+            for bound in self.tcx().item_bounds(assoc_type).transpose_iter() {\n                 let subst_bound =\n                     if defs.count() == 0 {\n                         bound.subst(tcx, trait_predicate.trait_ref.substs)"}, {"sha": "f90da95d51668b56cfbb582cbae2231ef6db371f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1604,7 +1604,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 );\n             }\n         };\n-        let bounds = tcx.bound_item_bounds(def_id).subst(tcx, substs);\n+        let bounds = tcx.item_bounds(def_id).subst(tcx, substs);\n \n         // The bounds returned by `item_bounds` may contain duplicates after\n         // normalization, so try to deduplicate when possible to avoid\n@@ -2558,12 +2558,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n-        let predicates = tcx.bound_predicates_of(def_id);\n-        debug!(?predicates);\n-        assert_eq!(predicates.0.parent, None);\n-        let mut obligations = Vec::with_capacity(predicates.0.predicates.len());\n-        for (predicate, span) in predicates.0.predicates {\n-            let span = *span;\n+        let predicates = tcx.predicates_of(def_id);\n+        assert_eq!(predicates.parent, None);\n+        let predicates = predicates.instantiate_own(tcx, substs);\n+        let mut obligations = Vec::with_capacity(predicates.len());\n+        for (predicate, span) in predicates {\n             let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n@@ -2576,7 +2575,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 param_env,\n                 cause.clone(),\n                 recursion_depth,\n-                predicates.rebind(*predicate).subst(tcx, substs),\n+                predicate,\n                 &mut obligations,\n             );\n             obligations.push(Obligation { cause, recursion_depth, param_env, predicate });"}, {"sha": "f398fb06c187a0bb52ce0367e20244bc89cebe48", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -107,25 +107,25 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n             ty::FnDef(..) => {\n                 // Types of formals and return in `fn(_) -> _` are also irrelevant;\n                 // so we do not recur into them via `super_visit_with`\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Continue(());\n             }\n             ty::Array(_, n)\n                 if { n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0) } =>\n             {\n                 // rust-lang/rust#62336: ignore type of contents\n                 // for empty array.\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Continue(());\n             }\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Str | ty::Never => {\n                 // These primitive types are always structural match.\n                 //\n                 // `Never` is kind of special here, but as it is not inhabitable, this should be fine.\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Continue(());\n             }\n \n             ty::FnPtr(..) => {\n                 if !self.adt_const_param {\n-                    return ControlFlow::CONTINUE;\n+                    return ControlFlow::Continue(());\n                 } else {\n                     return ControlFlow::Break(ty);\n                 }\n@@ -147,15 +147,15 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n                     // Even though `NonStructural` does not implement `PartialEq`,\n                     // structural equality on `T` does not recur into the raw\n                     // pointer. Therefore, one can still use `C` in a pattern.\n-                    return ControlFlow::CONTINUE;\n+                    return ControlFlow::Continue(());\n                 } else {\n                     return ControlFlow::Break(ty);\n                 }\n             }\n \n             ty::Float(_) => {\n                 if !self.adt_const_param {\n-                    return ControlFlow::CONTINUE;\n+                    return ControlFlow::Continue(());\n                 } else {\n                     return ControlFlow::Break(ty);\n                 }\n@@ -172,13 +172,13 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n                 self.tcx.sess.delay_span_bug(self.span, \"ty::Error in structural-match check\");\n                 // We still want to check other types after encountering an error,\n                 // as this may still emit relevant errors.\n-                return ControlFlow::CONTINUE;\n+                return ControlFlow::Continue(());\n             }\n         };\n \n         if !self.seen.insert(adt_def.did()) {\n             debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-            return ControlFlow::CONTINUE;\n+            return ControlFlow::Continue(());\n         }\n \n         if !self.type_marked_structural(ty) {"}, {"sha": "64daca714c32d1e8b20d6ed3ed8a300727a0bc69", "filename": "compiler/rustc_trait_selection/src/traits/vtable.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -261,7 +261,10 @@ fn vtable_entries<'tcx>(\n                     // Note that this method could then never be called, so we\n                     // do not want to try and codegen it, in that case (see #23435).\n                     let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-                    if impossible_predicates(tcx, predicates.predicates) {\n+                    if impossible_predicates(\n+                        tcx,\n+                        predicates.map(|(predicate, _)| predicate).collect(),\n+                    ) {\n                         debug!(\"vtable_entries: predicates do not hold\");\n                         return VtblEntry::Vacant;\n                     }"}, {"sha": "12d4cb4fc6920a0d07438637415bff6980d058cb", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -654,7 +654,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                     // All of the requirements on type parameters\n                     // have already been checked for `impl Trait` in\n                     // return position. We do need to check type-alias-impl-trait though.\n-                    if ty::is_impl_trait_defn(self.tcx, def_id).is_none() {\n+                    if self.tcx.is_type_alias_impl_trait(def_id) {\n                         let obligations = self.nominal_obligations(def_id, substs);\n                         self.out.extend(obligations);\n                     }\n@@ -736,7 +736,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         trace!(\"{:#?}\", predicates);\n         debug_assert_eq!(predicates.predicates.len(), origins.len());\n \n-        iter::zip(iter::zip(predicates.predicates, predicates.spans), origins.into_iter().rev())\n+        iter::zip(predicates, origins.into_iter().rev())\n             .map(|((mut pred, span), origin_def_id)| {\n                 let code = if span.is_dummy() {\n                     traits::ItemObligation(origin_def_id)"}, {"sha": "f146de3966ba107865068631c9328f88fe2bd885", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -7,7 +7,7 @@\n //! `crate::chalk::lowering` (to lower rustc types into Chalk types).\n \n use rustc_middle::traits::ChalkRustInterner as RustInterner;\n-use rustc_middle::ty::{self, AssocKind, EarlyBinder, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable};\n+use rustc_middle::ty::{self, AssocKind, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_target::abi::{Integer, IntegerType};\n \n@@ -38,13 +38,12 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         def_id: DefId,\n         bound_vars: SubstsRef<'tcx>,\n     ) -> Vec<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        let predicates = self.interner.tcx.predicates_defined_on(def_id).predicates;\n-        predicates\n-            .iter()\n-            .map(|(wc, _)| EarlyBinder(*wc).subst(self.interner.tcx, bound_vars))\n-            .filter_map(|wc| LowerInto::<\n-                    Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>\n-                    >::lower_into(wc, self.interner)).collect()\n+        self.interner\n+            .tcx\n+            .predicates_defined_on(def_id)\n+            .instantiate_own(self.interner.tcx, bound_vars)\n+            .filter_map(|(wc, _)| LowerInto::lower_into(wc, self.interner))\n+            .collect()\n     }\n \n     fn bounds_for<T>(&self, def_id: DefId, bound_vars: SubstsRef<'tcx>) -> Vec<T>"}, {"sha": "7d2d8433c932d8d9d40b5656c1a78c99af9694de", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -154,11 +154,8 @@ fn implied_bounds_from_components<'tcx>(\n             match component {\n                 Component::Region(r) => Some(OutlivesBound::RegionSubRegion(sub_region, r)),\n                 Component::Param(p) => Some(OutlivesBound::RegionSubParam(sub_region, p)),\n-                Component::Projection(p) => Some(OutlivesBound::RegionSubProjection(sub_region, p)),\n-                Component::Opaque(def_id, substs) => {\n-                    Some(OutlivesBound::RegionSubOpaque(sub_region, def_id, substs))\n-                }\n-                Component::EscapingProjection(_) =>\n+                Component::Alias(p) => Some(OutlivesBound::RegionSubAlias(sub_region, p)),\n+                Component::EscapingAlias(_) =>\n                 // If the projection has escaping regions, don't\n                 // try to infer any implied bounds even for its\n                 // free components. This is conservative, because"}, {"sha": "f35c5e44882df38db20a578bc83cdfcd9c2f50ae", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -17,7 +17,6 @@ use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, ObligationCtxt};\n use std::fmt;\n-use std::iter::zip;\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers {\n@@ -108,9 +107,7 @@ fn relate_mir_and_user_substs<'tcx>(\n     let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n \n     debug!(?instantiated_predicates);\n-    for (instantiated_predicate, predicate_span) in\n-        zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n-    {\n+    for (instantiated_predicate, predicate_span) in instantiated_predicates {\n         let span = if span == DUMMY_SP { predicate_span } else { span };\n         let cause = ObligationCause::new(\n             span,"}, {"sha": "b3b9a67b26e3d23fcfa2ab9153847dc787145560", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,4 +1,4 @@\n-#![feature(alloc_layout_extra, control_flow_enum, decl_macro, iterator_try_reduce, never_type)]\n+#![feature(alloc_layout_extra, decl_macro, iterator_try_reduce, never_type)]\n #![allow(dead_code, unused_variables)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]"}, {"sha": "91a505a72fae7a6be74b31e2b2ff0909af29b877", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -108,21 +108,41 @@ fn fn_sig_for_fn_abi<'tcx>(\n             // `Generator::resume(...) -> GeneratorState` function in case we\n             // have an ordinary generator, or the `Future::poll(...) -> Poll`\n             // function in case this is a special generator backing an async construct.\n-            let ret_ty = if tcx.generator_is_async(did) {\n-                let state_did = tcx.require_lang_item(LangItem::Poll, None);\n-                let state_adt_ref = tcx.adt_def(state_did);\n-                let state_substs = tcx.intern_substs(&[sig.return_ty.into()]);\n-                tcx.mk_adt(state_adt_ref, state_substs)\n+            let (resume_ty, ret_ty) = if tcx.generator_is_async(did) {\n+                // The signature should be `Future::poll(_, &mut Context<'_>) -> Poll<Output>`\n+                let poll_did = tcx.require_lang_item(LangItem::Poll, None);\n+                let poll_adt_ref = tcx.adt_def(poll_did);\n+                let poll_substs = tcx.intern_substs(&[sig.return_ty.into()]);\n+                let ret_ty = tcx.mk_adt(poll_adt_ref, poll_substs);\n+\n+                // We have to replace the `ResumeTy` that is used for type and borrow checking\n+                // with `&mut Context<'_>` which is used in codegen.\n+                #[cfg(debug_assertions)]\n+                {\n+                    if let ty::Adt(resume_ty_adt, _) = sig.resume_ty.kind() {\n+                        let expected_adt =\n+                            tcx.adt_def(tcx.require_lang_item(LangItem::ResumeTy, None));\n+                        assert_eq!(*resume_ty_adt, expected_adt);\n+                    } else {\n+                        panic!(\"expected `ResumeTy`, found `{:?}`\", sig.resume_ty);\n+                    };\n+                }\n+                let context_mut_ref = tcx.mk_task_context();\n+\n+                (context_mut_ref, ret_ty)\n             } else {\n+                // The signature should be `Generator::resume(_, Resume) -> GeneratorState<Yield, Return>`\n                 let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n                 let state_adt_ref = tcx.adt_def(state_did);\n                 let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-                tcx.mk_adt(state_adt_ref, state_substs)\n+                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+\n+                (sig.resume_ty, ret_ty)\n             };\n \n             ty::Binder::bind_with_vars(\n                 tcx.mk_fn_sig(\n-                    [env_ty, sig.resume_ty].iter(),\n+                    [env_ty, resume_ty].iter(),\n                     &ret_ty,\n                     false,\n                     hir::Unsafety::Normal,\n@@ -219,8 +239,7 @@ fn adjust_for_rust_scalar<'tcx>(\n         return;\n     }\n \n-    // Scalars which have invalid values cannot be undef.\n-    if !scalar.is_always_valid(&cx) {\n+    if !scalar.is_uninit_valid() {\n         attrs.set(ArgAttribute::NoUndef);\n     }\n \n@@ -246,11 +265,6 @@ fn adjust_for_rust_scalar<'tcx>(\n                 PointerKind::SharedMutable | PointerKind::UniqueOwned => Size::ZERO,\n             };\n \n-            // `Box`, `&T`, and `&mut T` cannot be undef.\n-            // Note that this only applies to the value of the pointer itself;\n-            // this attribute doesn't make it UB for the pointed-to data to be undef.\n-            attrs.set(ArgAttribute::NoUndef);\n-\n             // The aliasing rules for `Box<T>` are still not decided, but currently we emit\n             // `noalias` for it. This can be turned off using an unstable flag.\n             // See https://github.com/rust-lang/unsafe-code-guidelines/issues/326"}, {"sha": "a9fbad55dac5540b6230dd669fdee5926cd06302", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -302,13 +302,53 @@ impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n         }\n \n         match expr.kind {\n-            thir::ExprKind::NamedConst { substs, .. } => substs.has_non_region_param(),\n+            thir::ExprKind::NamedConst { substs, .. }\n+            | thir::ExprKind::ConstBlock { substs, .. } => substs.has_non_region_param(),\n             thir::ExprKind::ConstParam { .. } => true,\n             thir::ExprKind::Repeat { value, count } => {\n                 self.visit_expr(&self.thir()[value]);\n                 count.has_non_region_param()\n             }\n-            _ => false,\n+            thir::ExprKind::Scope { .. }\n+            | thir::ExprKind::Box { .. }\n+            | thir::ExprKind::If { .. }\n+            | thir::ExprKind::Call { .. }\n+            | thir::ExprKind::Deref { .. }\n+            | thir::ExprKind::Binary { .. }\n+            | thir::ExprKind::LogicalOp { .. }\n+            | thir::ExprKind::Unary { .. }\n+            | thir::ExprKind::Cast { .. }\n+            | thir::ExprKind::Use { .. }\n+            | thir::ExprKind::NeverToAny { .. }\n+            | thir::ExprKind::Pointer { .. }\n+            | thir::ExprKind::Loop { .. }\n+            | thir::ExprKind::Let { .. }\n+            | thir::ExprKind::Match { .. }\n+            | thir::ExprKind::Block { .. }\n+            | thir::ExprKind::Assign { .. }\n+            | thir::ExprKind::AssignOp { .. }\n+            | thir::ExprKind::Field { .. }\n+            | thir::ExprKind::Index { .. }\n+            | thir::ExprKind::VarRef { .. }\n+            | thir::ExprKind::UpvarRef { .. }\n+            | thir::ExprKind::Borrow { .. }\n+            | thir::ExprKind::AddressOf { .. }\n+            | thir::ExprKind::Break { .. }\n+            | thir::ExprKind::Continue { .. }\n+            | thir::ExprKind::Return { .. }\n+            | thir::ExprKind::Array { .. }\n+            | thir::ExprKind::Tuple { .. }\n+            | thir::ExprKind::Adt(_)\n+            | thir::ExprKind::PlaceTypeAscription { .. }\n+            | thir::ExprKind::ValueTypeAscription { .. }\n+            | thir::ExprKind::Closure(_)\n+            | thir::ExprKind::Literal { .. }\n+            | thir::ExprKind::NonHirLiteral { .. }\n+            | thir::ExprKind::ZstLiteral { .. }\n+            | thir::ExprKind::StaticRef { .. }\n+            | thir::ExprKind::InlineAsm(_)\n+            | thir::ExprKind::ThreadLocalRef(_)\n+            | thir::ExprKind::Yield { .. } => false,\n         }\n     }\n     fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {"}, {"sha": "0853de601b04072100213a4f2b9d114242abd44f", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,7 +6,6 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(let_chains)]\n-#![feature(control_flow_enum)]\n #![feature(never_type)]\n #![feature(box_patterns)]\n #![recursion_limit = \"256\"]"}, {"sha": "ca75c3895f41f61547be83491e0c042102a4a927", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -106,6 +106,7 @@\n #![feature(const_size_of_val)]\n #![feature(const_align_of_val)]\n #![feature(const_ptr_read)]\n+#![feature(const_maybe_uninit_zeroed)]\n #![feature(const_maybe_uninit_write)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_refs_to_cell)]"}, {"sha": "fecacc2bb639508836b4090fa22280a368051a67", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 39, "deletions": 309, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -19,10 +19,12 @@ use core::cmp::Ordering::{self, Less};\n use core::mem::{self, SizedTypeProperties};\n #[cfg(not(no_global_oom_handling))]\n use core::ptr;\n+#[cfg(not(no_global_oom_handling))]\n+use core::slice::sort;\n \n use crate::alloc::Allocator;\n #[cfg(not(no_global_oom_handling))]\n-use crate::alloc::Global;\n+use crate::alloc::{self, Global};\n #[cfg(not(no_global_oom_handling))]\n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n@@ -206,7 +208,7 @@ impl<T> [T] {\n     where\n         T: Ord,\n     {\n-        merge_sort(self, T::lt);\n+        stable_sort(self, T::lt);\n     }\n \n     /// Sorts the slice with a comparator function.\n@@ -262,7 +264,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T, &T) -> Ordering,\n     {\n-        merge_sort(self, |a, b| compare(a, b) == Less);\n+        stable_sort(self, |a, b| compare(a, b) == Less);\n     }\n \n     /// Sorts the slice with a key extraction function.\n@@ -305,7 +307,7 @@ impl<T> [T] {\n         F: FnMut(&T) -> K,\n         K: Ord,\n     {\n-        merge_sort(self, |a, b| f(a).lt(&f(b)));\n+        stable_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n     /// Sorts the slice with a key extraction function.\n@@ -812,324 +814,52 @@ impl<T: Clone> ToOwned for [T] {\n // Sorting\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n-///\n-/// This is the integral subroutine of insertion sort.\n-#[cfg(not(no_global_oom_handling))]\n-fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n-where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n-        unsafe {\n-            // There are three ways to implement insertion here:\n-            //\n-            // 1. Swap adjacent elements until the first one gets to its final destination.\n-            //    However, this way we copy data around more than is necessary. If elements are big\n-            //    structures (costly to copy), this method will be slow.\n-            //\n-            // 2. Iterate until the right place for the first element is found. Then shift the\n-            //    elements succeeding it to make room for it and finally place it into the\n-            //    remaining hole. This is a good method.\n-            //\n-            // 3. Copy the first element into a temporary variable. Iterate until the right place\n-            //    for it is found. As we go along, copy every traversed element into the slot\n-            //    preceding it. Finally, copy data from the temporary variable into the remaining\n-            //    hole. This method is very good. Benchmarks demonstrated slightly better\n-            //    performance than with the 2nd method.\n-            //\n-            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n-            let tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n-\n-            // Intermediate state of the insertion process is always tracked by `hole`, which\n-            // serves two purposes:\n-            // 1. Protects integrity of `v` from panics in `is_less`.\n-            // 2. Fills the remaining hole in `v` in the end.\n-            //\n-            // Panic safety:\n-            //\n-            // If `is_less` panics at any point during the process, `hole` will get dropped and\n-            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n-            // initially held exactly once.\n-            let mut hole = InsertionHole { src: &*tmp, dest: &mut v[1] };\n-            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n-\n-            for i in 2..v.len() {\n-                if !is_less(&v[i], &*tmp) {\n-                    break;\n-                }\n-                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n-                hole.dest = &mut v[i];\n-            }\n-            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n-        }\n-    }\n-\n-    // When dropped, copies from `src` into `dest`.\n-    struct InsertionHole<T> {\n-        src: *const T,\n-        dest: *mut T,\n-    }\n-\n-    impl<T> Drop for InsertionHole<T> {\n-        fn drop(&mut self) {\n-            unsafe {\n-                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n-            }\n-        }\n-    }\n-}\n-\n-/// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n-/// stores the result into `v[..]`.\n-///\n-/// # Safety\n-///\n-/// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n-/// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n-#[cfg(not(no_global_oom_handling))]\n-unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n-where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    let len = v.len();\n-    let v = v.as_mut_ptr();\n-    let (v_mid, v_end) = unsafe { (v.add(mid), v.add(len)) };\n-\n-    // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n-    // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n-    // copying the lesser (or greater) one into `v`.\n-    //\n-    // As soon as the shorter run is fully consumed, the process is done. If the longer run gets\n-    // consumed first, then we must copy whatever is left of the shorter run into the remaining\n-    // hole in `v`.\n-    //\n-    // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n-    // 1. Protects integrity of `v` from panics in `is_less`.\n-    // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n-    //\n-    // Panic safety:\n-    //\n-    // If `is_less` panics at any point during the process, `hole` will get dropped and fill the\n-    // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n-    // object it initially held exactly once.\n-    let mut hole;\n-\n-    if mid <= len - mid {\n-        // The left run is shorter.\n-        unsafe {\n-            ptr::copy_nonoverlapping(v, buf, mid);\n-            hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n-        }\n-\n-        // Initially, these pointers point to the beginnings of their arrays.\n-        let left = &mut hole.start;\n-        let mut right = v_mid;\n-        let out = &mut hole.dest;\n-\n-        while *left < hole.end && right < v_end {\n-            // Consume the lesser side.\n-            // If equal, prefer the left run to maintain stability.\n-            unsafe {\n-                let to_copy = if is_less(&*right, &**left) {\n-                    get_and_increment(&mut right)\n-                } else {\n-                    get_and_increment(left)\n-                };\n-                ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n-            }\n-        }\n-    } else {\n-        // The right run is shorter.\n-        unsafe {\n-            ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n-            hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n-        }\n-\n-        // Initially, these pointers point past the ends of their arrays.\n-        let left = &mut hole.dest;\n-        let right = &mut hole.end;\n-        let mut out = v_end;\n-\n-        while v < *left && buf < *right {\n-            // Consume the greater side.\n-            // If equal, prefer the right run to maintain stability.\n-            unsafe {\n-                let to_copy = if is_less(&*right.sub(1), &*left.sub(1)) {\n-                    decrement_and_get(left)\n-                } else {\n-                    decrement_and_get(right)\n-                };\n-                ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n-            }\n-        }\n-    }\n-    // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n-    // it will now be copied into the hole in `v`.\n-\n-    unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n-        let old = *ptr;\n-        *ptr = unsafe { ptr.add(1) };\n-        old\n-    }\n-\n-    unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n-        *ptr = unsafe { ptr.sub(1) };\n-        *ptr\n-    }\n-\n-    // When dropped, copies the range `start..end` into `dest..`.\n-    struct MergeHole<T> {\n-        start: *mut T,\n-        end: *mut T,\n-        dest: *mut T,\n-    }\n-\n-    impl<T> Drop for MergeHole<T> {\n-        fn drop(&mut self) {\n-            // `T` is not a zero-sized type, and these are pointers into a slice's elements.\n-            unsafe {\n-                let len = self.end.sub_ptr(self.start);\n-                ptr::copy_nonoverlapping(self.start, self.dest, len);\n-            }\n-        }\n-    }\n-}\n-\n-/// This merge sort borrows some (but not all) ideas from TimSort, which is described in detail\n-/// [here](https://github.com/python/cpython/blob/main/Objects/listsort.txt).\n-///\n-/// The algorithm identifies strictly descending and non-descending subsequences, which are called\n-/// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n-/// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n-/// satisfied:\n-///\n-/// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n-/// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n-///\n-/// The invariants ensure that the total running time is *O*(*n* \\* log(*n*)) worst-case.\n+#[inline]\n #[cfg(not(no_global_oom_handling))]\n-fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n+fn stable_sort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n-    // Slices of up to this length get sorted using insertion sort.\n-    const MAX_INSERTION: usize = 20;\n-    // Very short runs are extended using insertion sort to span at least this many elements.\n-    const MIN_RUN: usize = 10;\n-\n-    // Sorting has no meaningful behavior on zero-sized types.\n     if T::IS_ZST {\n+        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n         return;\n     }\n \n-    let len = v.len();\n-\n-    // Short arrays get sorted in-place via insertion sort to avoid allocations.\n-    if len <= MAX_INSERTION {\n-        if len >= 2 {\n-            for i in (0..len - 1).rev() {\n-                insert_head(&mut v[i..], &mut is_less);\n-            }\n-        }\n-        return;\n-    }\n-\n-    // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n-    // shallow copies of the contents of `v` without risking the dtors running on copies if\n-    // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n-    // which will always have length at most `len / 2`.\n-    let mut buf = Vec::with_capacity(len / 2);\n+    let elem_alloc_fn = |len: usize| -> *mut T {\n+        // SAFETY: Creating the layout is safe as long as merge_sort never calls this with len >\n+        // v.len(). Alloc in general will only be used as 'shadow-region' to store temporary swap\n+        // elements.\n+        unsafe { alloc::alloc(alloc::Layout::array::<T>(len).unwrap_unchecked()) as *mut T }\n+    };\n \n-    // In order to identify natural runs in `v`, we traverse it backwards. That might seem like a\n-    // strange decision, but consider the fact that merges more often go in the opposite direction\n-    // (forwards). According to benchmarks, merging forwards is slightly faster than merging\n-    // backwards. To conclude, identifying runs by traversing backwards improves performance.\n-    let mut runs = vec![];\n-    let mut end = len;\n-    while end > 0 {\n-        // Find the next natural run, and reverse it if it's strictly descending.\n-        let mut start = end - 1;\n-        if start > 0 {\n-            start -= 1;\n-            unsafe {\n-                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n-                    while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n-                        start -= 1;\n-                    }\n-                    v[start..end].reverse();\n-                } else {\n-                    while start > 0 && !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))\n-                    {\n-                        start -= 1;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Insert some more elements into the run if it's too short. Insertion sort is faster than\n-        // merge sort on short sequences, so this significantly improves performance.\n-        while start > 0 && end - start < MIN_RUN {\n-            start -= 1;\n-            insert_head(&mut v[start..end], &mut is_less);\n+    let elem_dealloc_fn = |buf_ptr: *mut T, len: usize| {\n+        // SAFETY: Creating the layout is safe as long as merge_sort never calls this with len >\n+        // v.len(). The caller must ensure that buf_ptr was created by elem_alloc_fn with the same\n+        // len.\n+        unsafe {\n+            alloc::dealloc(buf_ptr as *mut u8, alloc::Layout::array::<T>(len).unwrap_unchecked());\n         }\n+    };\n \n-        // Push this run onto the stack.\n-        runs.push(Run { start, len: end - start });\n-        end = start;\n-\n-        // Merge some pairs of adjacent runs to satisfy the invariants.\n-        while let Some(r) = collapse(&runs) {\n-            let left = runs[r + 1];\n-            let right = runs[r];\n-            unsafe {\n-                merge(\n-                    &mut v[left.start..right.start + right.len],\n-                    left.len,\n-                    buf.as_mut_ptr(),\n-                    &mut is_less,\n-                );\n-            }\n-            runs[r] = Run { start: left.start, len: left.len + right.len };\n-            runs.remove(r + 1);\n+    let run_alloc_fn = |len: usize| -> *mut sort::TimSortRun {\n+        // SAFETY: Creating the layout is safe as long as merge_sort never calls this with an\n+        // obscene length or 0.\n+        unsafe {\n+            alloc::alloc(alloc::Layout::array::<sort::TimSortRun>(len).unwrap_unchecked())\n+                as *mut sort::TimSortRun\n         }\n-    }\n-\n-    // Finally, exactly one run must remain in the stack.\n-    debug_assert!(runs.len() == 1 && runs[0].start == 0 && runs[0].len == len);\n+    };\n \n-    // Examines the stack of runs and identifies the next pair of runs to merge. More specifically,\n-    // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n-    // algorithm should continue building a new run instead, `None` is returned.\n-    //\n-    // TimSort is infamous for its buggy implementations, as described here:\n-    // http://envisage-project.eu/timsort-specification-and-verification/\n-    //\n-    // The gist of the story is: we must enforce the invariants on the top four runs on the stack.\n-    // Enforcing them on just top three is not sufficient to ensure that the invariants will still\n-    // hold for *all* runs in the stack.\n-    //\n-    // This function correctly checks invariants for the top four runs. Additionally, if the top\n-    // run starts at index 0, it will always demand a merge operation until the stack is fully\n-    // collapsed, in order to complete the sort.\n-    #[inline]\n-    fn collapse(runs: &[Run]) -> Option<usize> {\n-        let n = runs.len();\n-        if n >= 2\n-            && (runs[n - 1].start == 0\n-                || runs[n - 2].len <= runs[n - 1].len\n-                || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)\n-                || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))\n-        {\n-            if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }\n-        } else {\n-            None\n+    let run_dealloc_fn = |buf_ptr: *mut sort::TimSortRun, len: usize| {\n+        // SAFETY: The caller must ensure that buf_ptr was created by elem_alloc_fn with the same\n+        // len.\n+        unsafe {\n+            alloc::dealloc(\n+                buf_ptr as *mut u8,\n+                alloc::Layout::array::<sort::TimSortRun>(len).unwrap_unchecked(),\n+            );\n         }\n-    }\n+    };\n \n-    #[derive(Clone, Copy)]\n-    struct Run {\n-        start: usize,\n-        len: usize,\n-    }\n+    sort::merge_sort(v, &mut is_less, elem_alloc_fn, elem_dealloc_fn, run_alloc_fn, run_dealloc_fn);\n }"}, {"sha": "afbe5cfaf8ef9dbe0cbe87436cc50e249c1d7ffa", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -559,10 +559,9 @@ impl str {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> String {\n-        let mut bytes = self.as_bytes().to_vec();\n-        bytes.make_ascii_uppercase();\n-        // make_ascii_uppercase() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(bytes) }\n+        let mut s = self.to_owned();\n+        s.make_ascii_uppercase();\n+        s\n     }\n \n     /// Returns a copy of this string where each character is mapped to its\n@@ -592,10 +591,9 @@ impl str {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> String {\n-        let mut bytes = self.as_bytes().to_vec();\n-        bytes.make_ascii_lowercase();\n-        // make_ascii_lowercase() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(bytes) }\n+        let mut s = self.to_owned();\n+        s.make_ascii_lowercase();\n+        s\n     }\n }\n "}, {"sha": "2b1a787cc549929231be0dfe33f1b8b57d1e9441", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -223,9 +223,9 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n         }\n \n         // as_slice() must only be called when iter.len() is > 0 because\n-        // vec::Splice modifies vec::Drain fields and may grow the vec which would invalidate\n-        // the iterator's internal pointers. Creating a reference to deallocated memory\n-        // is invalid even when it is zero-length\n+        // it also gets touched by vec::Splice which may turn it into a dangling pointer\n+        // which would make it and the vec pointer point to different allocations which would\n+        // lead to invalid pointer arithmetic below.\n         let drop_ptr = iter.as_slice().as_ptr();\n \n         unsafe {"}, {"sha": "cb9adf05c25b0efe8351608e7293452975bd08b9", "filename": "library/alloc/src/vec/is_zero.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -4,7 +4,8 @@ use crate::boxed::Box;\n \n #[rustc_specialization_trait]\n pub(super) unsafe trait IsZero {\n-    /// Whether this value's representation is all zeros\n+    /// Whether this value's representation is all zeros,\n+    /// or can be represented with all zeroes.\n     fn is_zero(&self) -> bool;\n }\n \n@@ -147,6 +148,23 @@ impl_is_zero_option_of_nonzero!(\n     NonZeroIsize,\n );\n \n+macro_rules! impl_is_zero_option_of_num {\n+    ($($t:ty,)+) => {$(\n+        unsafe impl IsZero for Option<$t> {\n+            #[inline]\n+            fn is_zero(&self) -> bool {\n+                const {\n+                    let none: Self = unsafe { core::mem::MaybeUninit::zeroed().assume_init() };\n+                    assert!(none.is_none());\n+                }\n+                self.is_none()\n+            }\n+        }\n+    )+};\n+}\n+\n+impl_is_zero_option_of_num!(u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, usize, isize,);\n+\n unsafe impl<T: IsZero> IsZero for Wrapping<T> {\n     #[inline]\n     fn is_zero(&self) -> bool {"}, {"sha": "1861147fe72fb676920d5a8ac8847288253e6797", "filename": "library/alloc/src/vec/splice.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -54,6 +54,12 @@ impl<I: Iterator, A: Allocator> ExactSizeIterator for Splice<'_, I, A> {}\n impl<I: Iterator, A: Allocator> Drop for Splice<'_, I, A> {\n     fn drop(&mut self) {\n         self.drain.by_ref().for_each(drop);\n+        // At this point draining is done and the only remaining tasks are splicing\n+        // and moving things into the final place.\n+        // Which means we can replace the slice::Iter with pointers that won't point to deallocated\n+        // memory, so that Drain::drop is still allowed to call iter.len(), otherwise it would break\n+        // the ptr.sub_ptr contract.\n+        self.drain.iter = (&[]).iter();\n \n         unsafe {\n             if self.drain.tail_len == 0 {"}, {"sha": "2a93a242d51744e02e5fa196579898a67f9d682d", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,7 +1,6 @@\n #![feature(allocator_api)]\n #![feature(alloc_layout_extra)]\n #![feature(assert_matches)]\n-#![feature(box_syntax)]\n #![feature(btree_drain_filter)]\n #![feature(cow_is_borrowed)]\n #![feature(const_box)]"}, {"sha": "c0fb0d993c3ed939ad5087a1dbb04f555463115e", "filename": "library/core/src/any.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -662,7 +662,8 @@ impl dyn Any + Send + Sync {\n /// While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth\n /// noting that the hashes and ordering will vary between Rust releases. Beware\n /// of relying on them inside of your code!\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+#[derive(Clone, Copy, Debug, Hash, Eq)]\n+#[derive_const(PartialEq, PartialOrd, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TypeId {\n     t: u64,"}, {"sha": "2a7ec544f9e2e138804cf0c7720b70091d2d2927", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1355,11 +1355,11 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{}\", Foo::new(2)), \"2\");\n-    /// assert_eq!(&format!(\"{}\", Foo::new(-1)), \"-1\");\n-    /// assert_eq!(&format!(\"{}\", Foo::new(0)), \"0\");\n-    /// assert_eq!(&format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n-    /// assert_eq!(&format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n+    /// assert_eq!(format!(\"{}\", Foo::new(2)), \"2\");\n+    /// assert_eq!(format!(\"{}\", Foo::new(-1)), \"-1\");\n+    /// assert_eq!(format!(\"{}\", Foo::new(0)), \"0\");\n+    /// assert_eq!(format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n+    /// assert_eq!(format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result {\n@@ -1452,8 +1452,8 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{Foo:<4}\"), \"Foo \");\n-    /// assert_eq!(&format!(\"{Foo:0>4}\"), \"0Foo\");\n+    /// assert_eq!(format!(\"{Foo:<4}\"), \"Foo \");\n+    /// assert_eq!(format!(\"{Foo:0>4}\"), \"0Foo\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pad(&mut self, s: &str) -> Result {\n@@ -1636,8 +1636,8 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{Foo}\"), \"Foo\");\n-    /// assert_eq!(&format!(\"{Foo:0>8}\"), \"Foo\");\n+    /// assert_eq!(format!(\"{Foo}\"), \"Foo\");\n+    /// assert_eq!(format!(\"{Foo:0>8}\"), \"Foo\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_str(&mut self, data: &str) -> Result {\n@@ -1659,8 +1659,8 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{}\", Foo(-1)), \"Foo -1\");\n-    /// assert_eq!(&format!(\"{:0>8}\", Foo(2)), \"Foo 2\");\n+    /// assert_eq!(format!(\"{}\", Foo(-1)), \"Foo -1\");\n+    /// assert_eq!(format!(\"{:0>8}\", Foo(2)), \"Foo 2\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result {\n@@ -1703,8 +1703,8 @@ impl<'a> Formatter<'a> {\n     /// }\n     ///\n     /// // We set alignment to the right with \">\".\n-    /// assert_eq!(&format!(\"{Foo:G>3}\"), \"GGG\");\n-    /// assert_eq!(&format!(\"{Foo:t>6}\"), \"tttttt\");\n+    /// assert_eq!(format!(\"{Foo:G>3}\"), \"GGG\");\n+    /// assert_eq!(format!(\"{Foo:t>6}\"), \"tttttt\");\n     /// ```\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n@@ -1738,10 +1738,10 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{Foo:<}\"), \"left\");\n-    /// assert_eq!(&format!(\"{Foo:>}\"), \"right\");\n-    /// assert_eq!(&format!(\"{Foo:^}\"), \"center\");\n-    /// assert_eq!(&format!(\"{Foo}\"), \"into the void\");\n+    /// assert_eq!(format!(\"{Foo:<}\"), \"left\");\n+    /// assert_eq!(format!(\"{Foo:>}\"), \"right\");\n+    /// assert_eq!(format!(\"{Foo:^}\"), \"center\");\n+    /// assert_eq!(format!(\"{Foo}\"), \"into the void\");\n     /// ```\n     #[must_use]\n     #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n@@ -1767,16 +1767,16 @@ impl<'a> Formatter<'a> {\n     ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n     ///         if let Some(width) = formatter.width() {\n     ///             // If we received a width, we use it\n-    ///             write!(formatter, \"{:width$}\", &format!(\"Foo({})\", self.0), width = width)\n+    ///             write!(formatter, \"{:width$}\", format!(\"Foo({})\", self.0), width = width)\n     ///         } else {\n     ///             // Otherwise we do nothing special\n     ///             write!(formatter, \"Foo({})\", self.0)\n     ///         }\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n-    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// assert_eq!(format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n+    /// assert_eq!(format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n@@ -1806,8 +1806,8 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n-    /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n+    /// assert_eq!(format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n+    /// assert_eq!(format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n     /// ```\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n@@ -1837,9 +1837,9 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n-    /// assert_eq!(&format!(\"{:+}\", Foo(-23)), \"Foo(-23)\");\n-    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// assert_eq!(format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n+    /// assert_eq!(format!(\"{:+}\", Foo(-23)), \"Foo(-23)\");\n+    /// assert_eq!(format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n@@ -1867,8 +1867,8 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n-    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// assert_eq!(format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n+    /// assert_eq!(format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n@@ -1895,8 +1895,8 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n-    /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n+    /// assert_eq!(format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n+    /// assert_eq!(format!(\"{}\", Foo(23)), \"23\");\n     /// ```\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n@@ -1922,7 +1922,7 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(&format!(\"{:04}\", Foo(23)), \"23\");\n+    /// assert_eq!(format!(\"{:04}\", Foo(23)), \"23\");\n     /// ```\n     #[must_use]\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]"}, {"sha": "c4fb362094664196a354070a1a8a246062734959", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -112,6 +112,10 @@ pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n     unsafe { &mut *cx.0.as_ptr().cast() }\n }\n \n+// FIXME(swatinem): This fn is currently needed to work around shortcomings\n+// in type and lifetime inference.\n+// See the comment at the bottom of `LoweringContext::make_async_expr` and\n+// <https://github.com/rust-lang/rust/issues/104826>.\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]"}, {"sha": "5a76e866923366e8716afeb1ddeb3ecc1e470ac7", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -219,6 +219,75 @@ pub fn spin_loop() {\n /// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n ///\n /// [`std::convert::identity`]: crate::convert::identity\n+///\n+/// # When is this useful?\n+///\n+/// First and foremost: `black_box` does _not_ guarantee any exact behavior and, in some cases, may\n+/// do nothing at all. As such, it **must not be relied upon to control critical program behavior.**\n+/// This _immediately_ precludes any direct use of this function for cryptographic or security\n+/// purposes.\n+///\n+/// While not suitable in those mission-critical cases, `back_box`'s functionality can generally be\n+/// relied upon for benchmarking, and should be used there. It will try to ensure that the\n+/// compiler doesn't optimize away part of the intended test code based on context. For\n+/// example:\n+///\n+/// ```\n+/// fn contains(haystack: &[&str], needle: &str) -> bool {\n+///     haystack.iter().any(|x| x == &needle)\n+/// }\n+///\n+/// pub fn benchmark() {\n+///     let haystack = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"];\n+///     let needle = \"ghi\";\n+///     for _ in 0..10 {\n+///         contains(&haystack, needle);\n+///     }\n+/// }\n+/// ```\n+///\n+/// The compiler could theoretically make optimizations like the following:\n+///\n+/// - `needle` and `haystack` are always the same, move the call to `contains` outside the loop and\n+///   delete the loop\n+/// - Inline `contains`\n+/// - `needle` and `haystack` have values known at compile time, `contains` is always true. Remove\n+///   the call and replace with `true`\n+/// - Nothing is done with the result of `contains`: delete this function call entirely\n+/// - `benchmark` now has no purpose: delete this function\n+///\n+/// It is not likely that all of the above happens, but the compiler is definitely able to make some\n+/// optimizations that could result in a very inaccurate benchmark. This is where `black_box` comes\n+/// in:\n+///\n+/// ```\n+/// use std::hint::black_box;\n+///\n+/// // Same `contains` function\n+/// fn contains(haystack: &[&str], needle: &str) -> bool {\n+///     haystack.iter().any(|x| x == &needle)\n+/// }\n+///\n+/// pub fn benchmark() {\n+///     let haystack = vec![\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"];\n+///     let needle = \"ghi\";\n+///     for _ in 0..10 {\n+///         // Adjust our benchmark loop contents\n+///         black_box(contains(black_box(&haystack), black_box(needle)));\n+///     }\n+/// }\n+/// ```\n+///\n+/// This essentially tells the compiler to block optimizations across any calls to `black_box`. So,\n+/// it now:\n+///\n+/// - Treats both arguments to `contains` as unpredictable: the body of `contains` can no longer be\n+///   optimized based on argument values\n+/// - Treats the call to `contains` and its result as volatile: the body of `benchmark` cannot\n+///   optimize this away\n+///\n+/// This makes our benchmark much more realistic to how the function would be used in situ, where\n+/// arguments are usually not known at compile time and the result is used in some way.\n #[inline]\n #[stable(feature = \"bench_black_box\", since = \"1.66.0\")]\n #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]"}, {"sha": "e3157b66902eb9dbfbfafbc505bdb786c88cbb2b", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -259,6 +259,8 @@ define!(\"mir_unreachable\", fn Unreachable() -> BasicBlock);\n define!(\"mir_drop\", fn Drop<T>(place: T, goto: BasicBlock));\n define!(\"mir_drop_and_replace\", fn DropAndReplace<T>(place: T, value: T, goto: BasicBlock));\n define!(\"mir_call\", fn Call<T>(place: T, goto: BasicBlock, call: T));\n+define!(\"mir_storage_live\", fn StorageLive<T>(local: T));\n+define!(\"mir_storage_dead\", fn StorageDead<T>(local: T));\n define!(\"mir_retag\", fn Retag<T>(place: T));\n define!(\"mir_move\", fn Move<T>(place: T) -> T);\n define!(\"mir_static\", fn Static<T>(s: T) -> &'static T);"}, {"sha": "7b1cb5488bcac650871b9ee38de84fb536bef4e7", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -202,14 +202,11 @@ impl<T: ?Sized> *const T {\n     #[must_use]\n     #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn addr(self) -> usize\n-    where\n-        T: Sized,\n-    {\n+    pub fn addr(self) -> usize {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n         // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n         // provenance).\n-        unsafe { mem::transmute(self) }\n+        unsafe { mem::transmute(self.cast::<()>()) }\n     }\n \n     /// Gets the \"address\" portion of the pointer, and 'exposes' the \"provenance\" part for future\n@@ -239,12 +236,9 @@ impl<T: ?Sized> *const T {\n     #[must_use]\n     #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn expose_addr(self) -> usize\n-    where\n-        T: Sized,\n-    {\n+    pub fn expose_addr(self) -> usize {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n-        self as usize\n+        self.cast::<()>() as usize\n     }\n \n     /// Creates a new pointer with the given address.\n@@ -262,10 +256,7 @@ impl<T: ?Sized> *const T {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn with_addr(self, addr: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn with_addr(self, addr: usize) -> Self {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n         //\n         // In the mean-time, this operation is defined to be \"as if\" it was\n@@ -288,10 +279,7 @@ impl<T: ?Sized> *const T {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self {\n         self.with_addr(f(self.addr()))\n     }\n "}, {"sha": "ed1e3bd48122761607f22a10f0bfb11608c0d892", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -208,14 +208,11 @@ impl<T: ?Sized> *mut T {\n     #[must_use]\n     #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn addr(self) -> usize\n-    where\n-        T: Sized,\n-    {\n+    pub fn addr(self) -> usize {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n         // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n         // provenance).\n-        unsafe { mem::transmute(self) }\n+        unsafe { mem::transmute(self.cast::<()>()) }\n     }\n \n     /// Gets the \"address\" portion of the pointer, and 'exposes' the \"provenance\" part for future\n@@ -245,12 +242,9 @@ impl<T: ?Sized> *mut T {\n     #[must_use]\n     #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn expose_addr(self) -> usize\n-    where\n-        T: Sized,\n-    {\n+    pub fn expose_addr(self) -> usize {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n-        self as usize\n+        self.cast::<()>() as usize\n     }\n \n     /// Creates a new pointer with the given address.\n@@ -268,10 +262,7 @@ impl<T: ?Sized> *mut T {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn with_addr(self, addr: usize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn with_addr(self, addr: usize) -> Self {\n         // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n         //\n         // In the mean-time, this operation is defined to be \"as if\" it was\n@@ -294,10 +285,7 @@ impl<T: ?Sized> *mut T {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self {\n         self.with_addr(f(self.addr()))\n     }\n "}, {"sha": "8c1a648860555bacacf1d8b9d7cce1e621f08cc0", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -268,10 +268,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn addr(self) -> NonZeroUsize\n-    where\n-        T: Sized,\n-    {\n+    pub fn addr(self) -> NonZeroUsize {\n         // SAFETY: The pointer is guaranteed by the type to be non-null,\n         // meaning that the address will be non-zero.\n         unsafe { NonZeroUsize::new_unchecked(self.pointer.addr()) }\n@@ -286,10 +283,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn with_addr(self, addr: NonZeroUsize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn with_addr(self, addr: NonZeroUsize) -> Self {\n         // SAFETY: The result of `ptr::from::with_addr` is non-null because `addr` is guaranteed to be non-zero.\n         unsafe { NonNull::new_unchecked(self.pointer.with_addr(addr.get()) as *mut _) }\n     }\n@@ -303,10 +297,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n-    pub fn map_addr(self, f: impl FnOnce(NonZeroUsize) -> NonZeroUsize) -> Self\n-    where\n-        T: Sized,\n-    {\n+    pub fn map_addr(self, f: impl FnOnce(NonZeroUsize) -> NonZeroUsize) -> Self {\n         self.with_addr(f(self.addr()))\n     }\n "}, {"sha": "90ab43d1289f0d22b3b2dcfecc81ccb5e71bdc88", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,7 +6,7 @@ mod macros;\n use crate::cmp;\n use crate::cmp::Ordering;\n use crate::fmt;\n-use crate::intrinsics::{assume, exact_div, unchecked_sub};\n+use crate::intrinsics::assume;\n use crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n use crate::marker::{PhantomData, Send, Sized, Sync};\n use crate::mem::{self, SizedTypeProperties};\n@@ -35,12 +35,6 @@ impl<'a, T> IntoIterator for &'a mut [T] {\n     }\n }\n \n-// Macro helper functions\n-#[inline(always)]\n-fn size_from_ptr<T>(_: *const T) -> usize {\n-    mem::size_of::<T>()\n-}\n-\n /// Immutable slice iterator\n ///\n /// This struct is created by the [`iter`] method on [slices]."}, {"sha": "0fd57b197aa97daa8838687de60165d6d3518372", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -9,30 +9,20 @@ macro_rules! is_empty {\n     };\n }\n \n-// To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n-// unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\n macro_rules! len {\n     ($self: ident) => {{\n         #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n \n         let start = $self.ptr;\n-        let size = size_from_ptr(start.as_ptr());\n-        if size == 0 {\n-            // This _cannot_ use `unchecked_sub` because we depend on wrapping\n+        if T::IS_ZST {\n+            // This _cannot_ use `ptr_sub` because we depend on wrapping\n             // to represent the length of long ZST slice iterators.\n             $self.end.addr().wrapping_sub(start.as_ptr().addr())\n         } else {\n-            // We know that `start <= end`, so can do better than `offset_from`,\n-            // which needs to deal in signed. By setting appropriate flags here\n-            // we can tell LLVM this, which helps it remove bounds checks.\n-            // SAFETY: By the type invariant, `start <= end`\n-            let diff = unsafe { unchecked_sub($self.end.addr(), start.as_ptr().addr()) };\n-            // By also telling LLVM that the pointers are apart by an exact\n-            // multiple of the type size, it can optimize `len() == 0` down to\n-            // `start == end` instead of `(end - start) < size`.\n-            // SAFETY: By the type invariant, the pointers are aligned so the\n-            //         distance between them must be a multiple of pointee size\n-            unsafe { exact_div(diff, size) }\n+            // To get rid of some bounds checks (see `position`), we use ptr_sub instead of\n+            // offset_from (Tested by `codegen/slice-position-bounds-check`.)\n+            // SAFETY: by the type invariant pointers are aligned and `start <= end`\n+            unsafe { $self.end.sub_ptr(start.as_ptr()) }\n         }\n     }};\n }"}, {"sha": "d93a3a57ecd27fdcdb94a4aa479a5e8ceb02be3c", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -29,13 +29,19 @@ use crate::slice;\n /// Pure rust memchr implementation, taken from rust-memchr\n pub mod memchr;\n \n+#[unstable(\n+    feature = \"slice_internals\",\n+    issue = \"none\",\n+    reason = \"exposed from core to be reused in std;\"\n+)]\n+pub mod sort;\n+\n mod ascii;\n mod cmp;\n mod index;\n mod iter;\n mod raw;\n mod rotate;\n-mod sort;\n mod specialize;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -781,6 +787,22 @@ impl<T> [T] {\n     /// let mut iter = slice.windows(4);\n     /// assert!(iter.next().is_none());\n     /// ```\n+    ///\n+    /// There's no `windows_mut`, as that existing would let safe code violate the\n+    /// \"only one `&mut` at a time to the same thing\" rule.  However, you can sometimes\n+    /// use [`Cell::as_slice_of_cells`](crate::cell::Cell::as_slice_of_cells) in\n+    /// conjunction with `windows` to accomplish something similar:\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let mut array = ['R', 'u', 's', 't', ' ', '2', '0', '1', '5'];\n+    /// let slice = &mut array[..];\n+    /// let slice_of_cells: &[Cell<char>] = Cell::from_mut(slice).as_slice_of_cells();\n+    /// for w in slice_of_cells.windows(3) {\n+    ///     Cell::swap(&w[0], &w[2]);\n+    /// }\n+    /// assert_eq!(array, ['s', 't', ' ', '2', '0', '1', '5', 'u', 'R']);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn windows(&self, size: usize) -> Windows<'_, T> {"}, {"sha": "2181f9a811855f7ac2a39352b481f0f865e193d5", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -5,6 +5,9 @@\n //!\n //! Unstable sorting is compatible with core because it doesn't allocate memory, unlike our\n //! stable sorting implementation.\n+//!\n+//! In addition it also contains the core logic of the stable sort used by `slice::sort` based on\n+//! TimSort.\n \n use crate::cmp;\n use crate::mem::{self, MaybeUninit, SizedTypeProperties};\n@@ -831,6 +834,15 @@ fn partition_at_index_loop<'a, T, F>(\n ) where\n     F: FnMut(&T, &T) -> bool,\n {\n+    // Limit the amount of iterations and fall back to heapsort, similarly to `slice::sort_unstable`.\n+    // This lowers the worst case running time from O(n^2) to O(n log n).\n+    // FIXME: Investigate whether it would be better to use something like Median of Medians\n+    // or Fast Deterministic Selection to guarantee O(n) worst case.\n+    let mut limit = usize::BITS - v.len().leading_zeros();\n+\n+    // True if the last partitioning was reasonably balanced.\n+    let mut was_balanced = true;\n+\n     loop {\n         // For slices of up to this length it's probably faster to simply sort them.\n         const MAX_INSERTION: usize = 10;\n@@ -839,6 +851,18 @@ fn partition_at_index_loop<'a, T, F>(\n             return;\n         }\n \n+        if limit == 0 {\n+            heapsort(v, is_less);\n+            return;\n+        }\n+\n+        // If the last partitioning was imbalanced, try breaking patterns in the slice by shuffling\n+        // some elements around. Hopefully we'll choose a better pivot this time.\n+        if !was_balanced {\n+            break_patterns(v);\n+            limit -= 1;\n+        }\n+\n         // Choose a pivot\n         let (pivot, _) = choose_pivot(v, is_less);\n \n@@ -863,6 +887,7 @@ fn partition_at_index_loop<'a, T, F>(\n         }\n \n         let (mid, _) = partition(v, pivot, is_less);\n+        was_balanced = cmp::min(mid, v.len() - mid) >= v.len() / 8;\n \n         // Split the slice into `left`, `pivot`, and `right`.\n         let (left, right) = v.split_at_mut(mid);\n@@ -883,6 +908,7 @@ fn partition_at_index_loop<'a, T, F>(\n     }\n }\n \n+/// Reorder the slice such that the element at `index` is at its final sorted position.\n pub fn partition_at_index<T, F>(\n     v: &mut [T],\n     index: usize,\n@@ -927,3 +953,513 @@ where\n     let pivot = &mut pivot[0];\n     (left, pivot, right)\n }\n+\n+/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n+///\n+/// This is the integral subroutine of insertion sort.\n+fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n+        // SAFETY: Copy tmp back even if panic, and ensure unique observation.\n+        unsafe {\n+            // There are three ways to implement insertion here:\n+            //\n+            // 1. Swap adjacent elements until the first one gets to its final destination.\n+            //    However, this way we copy data around more than is necessary. If elements are big\n+            //    structures (costly to copy), this method will be slow.\n+            //\n+            // 2. Iterate until the right place for the first element is found. Then shift the\n+            //    elements succeeding it to make room for it and finally place it into the\n+            //    remaining hole. This is a good method.\n+            //\n+            // 3. Copy the first element into a temporary variable. Iterate until the right place\n+            //    for it is found. As we go along, copy every traversed element into the slot\n+            //    preceding it. Finally, copy data from the temporary variable into the remaining\n+            //    hole. This method is very good. Benchmarks demonstrated slightly better\n+            //    performance than with the 2nd method.\n+            //\n+            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n+            let tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n+\n+            // Intermediate state of the insertion process is always tracked by `hole`, which\n+            // serves two purposes:\n+            // 1. Protects integrity of `v` from panics in `is_less`.\n+            // 2. Fills the remaining hole in `v` in the end.\n+            //\n+            // Panic safety:\n+            //\n+            // If `is_less` panics at any point during the process, `hole` will get dropped and\n+            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n+            // initially held exactly once.\n+            let mut hole = InsertionHole { src: &*tmp, dest: &mut v[1] };\n+            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n+\n+            for i in 2..v.len() {\n+                if !is_less(&v[i], &*tmp) {\n+                    break;\n+                }\n+                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n+                hole.dest = &mut v[i];\n+            }\n+            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n+        }\n+    }\n+\n+    // When dropped, copies from `src` into `dest`.\n+    struct InsertionHole<T> {\n+        src: *const T,\n+        dest: *mut T,\n+    }\n+\n+    impl<T> Drop for InsertionHole<T> {\n+        fn drop(&mut self) {\n+            // SAFETY: The caller must ensure that src and dest are correctly set.\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n+            }\n+        }\n+    }\n+}\n+\n+/// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n+/// stores the result into `v[..]`.\n+///\n+/// # Safety\n+///\n+/// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n+/// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n+unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    let len = v.len();\n+    let v = v.as_mut_ptr();\n+\n+    // SAFETY: mid and len must be in-bounds of v.\n+    let (v_mid, v_end) = unsafe { (v.add(mid), v.add(len)) };\n+\n+    // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n+    // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n+    // copying the lesser (or greater) one into `v`.\n+    //\n+    // As soon as the shorter run is fully consumed, the process is done. If the longer run gets\n+    // consumed first, then we must copy whatever is left of the shorter run into the remaining\n+    // hole in `v`.\n+    //\n+    // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n+    // 1. Protects integrity of `v` from panics in `is_less`.\n+    // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n+    //\n+    // Panic safety:\n+    //\n+    // If `is_less` panics at any point during the process, `hole` will get dropped and fill the\n+    // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n+    // object it initially held exactly once.\n+    let mut hole;\n+\n+    if mid <= len - mid {\n+        // The left run is shorter.\n+\n+        // SAFETY: buf must have enough capacity for `v[..mid]`.\n+        unsafe {\n+            ptr::copy_nonoverlapping(v, buf, mid);\n+            hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n+        }\n+\n+        // Initially, these pointers point to the beginnings of their arrays.\n+        let left = &mut hole.start;\n+        let mut right = v_mid;\n+        let out = &mut hole.dest;\n+\n+        while *left < hole.end && right < v_end {\n+            // Consume the lesser side.\n+            // If equal, prefer the left run to maintain stability.\n+\n+            // SAFETY: left and right must be valid and part of v same for out.\n+            unsafe {\n+                let to_copy = if is_less(&*right, &**left) {\n+                    get_and_increment(&mut right)\n+                } else {\n+                    get_and_increment(left)\n+                };\n+                ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n+            }\n+        }\n+    } else {\n+        // The right run is shorter.\n+\n+        // SAFETY: buf must have enough capacity for `v[mid..]`.\n+        unsafe {\n+            ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n+            hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n+        }\n+\n+        // Initially, these pointers point past the ends of their arrays.\n+        let left = &mut hole.dest;\n+        let right = &mut hole.end;\n+        let mut out = v_end;\n+\n+        while v < *left && buf < *right {\n+            // Consume the greater side.\n+            // If equal, prefer the right run to maintain stability.\n+\n+            // SAFETY: left and right must be valid and part of v same for out.\n+            unsafe {\n+                let to_copy = if is_less(&*right.sub(1), &*left.sub(1)) {\n+                    decrement_and_get(left)\n+                } else {\n+                    decrement_and_get(right)\n+                };\n+                ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n+            }\n+        }\n+    }\n+    // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n+    // it will now be copied into the hole in `v`.\n+\n+    unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n+        let old = *ptr;\n+\n+        // SAFETY: ptr.add(1) must still be a valid pointer and part of `v`.\n+        *ptr = unsafe { ptr.add(1) };\n+        old\n+    }\n+\n+    unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n+        // SAFETY: ptr.sub(1) must still be a valid pointer and part of `v`.\n+        *ptr = unsafe { ptr.sub(1) };\n+        *ptr\n+    }\n+\n+    // When dropped, copies the range `start..end` into `dest..`.\n+    struct MergeHole<T> {\n+        start: *mut T,\n+        end: *mut T,\n+        dest: *mut T,\n+    }\n+\n+    impl<T> Drop for MergeHole<T> {\n+        fn drop(&mut self) {\n+            // SAFETY: `T` is not a zero-sized type, and these are pointers into a slice's elements.\n+            unsafe {\n+                let len = self.end.sub_ptr(self.start);\n+                ptr::copy_nonoverlapping(self.start, self.dest, len);\n+            }\n+        }\n+    }\n+}\n+\n+/// This merge sort borrows some (but not all) ideas from TimSort, which used to be described in\n+/// detail [here](https://github.com/python/cpython/blob/main/Objects/listsort.txt). However Python\n+/// has switched to a Powersort based implementation.\n+///\n+/// The algorithm identifies strictly descending and non-descending subsequences, which are called\n+/// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n+/// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n+/// satisfied:\n+///\n+/// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n+/// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n+///\n+/// The invariants ensure that the total running time is *O*(*n* \\* log(*n*)) worst-case.\n+pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n+    v: &mut [T],\n+    is_less: &mut CmpF,\n+    elem_alloc_fn: ElemAllocF,\n+    elem_dealloc_fn: ElemDeallocF,\n+    run_alloc_fn: RunAllocF,\n+    run_dealloc_fn: RunDeallocF,\n+) where\n+    CmpF: FnMut(&T, &T) -> bool,\n+    ElemAllocF: Fn(usize) -> *mut T,\n+    ElemDeallocF: Fn(*mut T, usize),\n+    RunAllocF: Fn(usize) -> *mut TimSortRun,\n+    RunDeallocF: Fn(*mut TimSortRun, usize),\n+{\n+    // Slices of up to this length get sorted using insertion sort.\n+    const MAX_INSERTION: usize = 20;\n+    // Very short runs are extended using insertion sort to span at least this many elements.\n+    const MIN_RUN: usize = 10;\n+\n+    // The caller should have already checked that.\n+    debug_assert!(!T::IS_ZST);\n+\n+    let len = v.len();\n+\n+    // Short arrays get sorted in-place via insertion sort to avoid allocations.\n+    if len <= MAX_INSERTION {\n+        if len >= 2 {\n+            for i in (0..len - 1).rev() {\n+                insert_head(&mut v[i..], is_less);\n+            }\n+        }\n+        return;\n+    }\n+\n+    // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n+    // shallow copies of the contents of `v` without risking the dtors running on copies if\n+    // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n+    // which will always have length at most `len / 2`.\n+    let buf = BufGuard::new(len / 2, elem_alloc_fn, elem_dealloc_fn);\n+    let buf_ptr = buf.buf_ptr;\n+\n+    let mut runs = RunVec::new(run_alloc_fn, run_dealloc_fn);\n+\n+    // In order to identify natural runs in `v`, we traverse it backwards. That might seem like a\n+    // strange decision, but consider the fact that merges more often go in the opposite direction\n+    // (forwards). According to benchmarks, merging forwards is slightly faster than merging\n+    // backwards. To conclude, identifying runs by traversing backwards improves performance.\n+    let mut end = len;\n+    while end > 0 {\n+        // Find the next natural run, and reverse it if it's strictly descending.\n+        let mut start = end - 1;\n+        if start > 0 {\n+            start -= 1;\n+\n+            // SAFETY: The v.get_unchecked must be fed with correct inbound indicies.\n+            unsafe {\n+                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n+                    while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n+                        start -= 1;\n+                    }\n+                    v[start..end].reverse();\n+                } else {\n+                    while start > 0 && !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))\n+                    {\n+                        start -= 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Insert some more elements into the run if it's too short. Insertion sort is faster than\n+        // merge sort on short sequences, so this significantly improves performance.\n+        while start > 0 && end - start < MIN_RUN {\n+            start -= 1;\n+            insert_head(&mut v[start..end], is_less);\n+        }\n+\n+        // Push this run onto the stack.\n+        runs.push(TimSortRun { start, len: end - start });\n+        end = start;\n+\n+        // Merge some pairs of adjacent runs to satisfy the invariants.\n+        while let Some(r) = collapse(runs.as_slice()) {\n+            let left = runs[r + 1];\n+            let right = runs[r];\n+            // SAFETY: `buf_ptr` must hold enough capacity for the shorter of the two sides, and\n+            // neither side may be on length 0.\n+            unsafe {\n+                merge(&mut v[left.start..right.start + right.len], left.len, buf_ptr, is_less);\n+            }\n+            runs[r] = TimSortRun { start: left.start, len: left.len + right.len };\n+            runs.remove(r + 1);\n+        }\n+    }\n+\n+    // Finally, exactly one run must remain in the stack.\n+    debug_assert!(runs.len() == 1 && runs[0].start == 0 && runs[0].len == len);\n+\n+    // Examines the stack of runs and identifies the next pair of runs to merge. More specifically,\n+    // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n+    // algorithm should continue building a new run instead, `None` is returned.\n+    //\n+    // TimSort is infamous for its buggy implementations, as described here:\n+    // http://envisage-project.eu/timsort-specification-and-verification/\n+    //\n+    // The gist of the story is: we must enforce the invariants on the top four runs on the stack.\n+    // Enforcing them on just top three is not sufficient to ensure that the invariants will still\n+    // hold for *all* runs in the stack.\n+    //\n+    // This function correctly checks invariants for the top four runs. Additionally, if the top\n+    // run starts at index 0, it will always demand a merge operation until the stack is fully\n+    // collapsed, in order to complete the sort.\n+    #[inline]\n+    fn collapse(runs: &[TimSortRun]) -> Option<usize> {\n+        let n = runs.len();\n+        if n >= 2\n+            && (runs[n - 1].start == 0\n+                || runs[n - 2].len <= runs[n - 1].len\n+                || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)\n+                || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))\n+        {\n+            if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // Extremely basic versions of Vec.\n+    // Their use is super limited and by having the code here, it allows reuse between the sort\n+    // implementations.\n+    struct BufGuard<T, ElemDeallocF>\n+    where\n+        ElemDeallocF: Fn(*mut T, usize),\n+    {\n+        buf_ptr: *mut T,\n+        capacity: usize,\n+        elem_dealloc_fn: ElemDeallocF,\n+    }\n+\n+    impl<T, ElemDeallocF> BufGuard<T, ElemDeallocF>\n+    where\n+        ElemDeallocF: Fn(*mut T, usize),\n+    {\n+        fn new<ElemAllocF>(\n+            len: usize,\n+            elem_alloc_fn: ElemAllocF,\n+            elem_dealloc_fn: ElemDeallocF,\n+        ) -> Self\n+        where\n+            ElemAllocF: Fn(usize) -> *mut T,\n+        {\n+            Self { buf_ptr: elem_alloc_fn(len), capacity: len, elem_dealloc_fn }\n+        }\n+    }\n+\n+    impl<T, ElemDeallocF> Drop for BufGuard<T, ElemDeallocF>\n+    where\n+        ElemDeallocF: Fn(*mut T, usize),\n+    {\n+        fn drop(&mut self) {\n+            (self.elem_dealloc_fn)(self.buf_ptr, self.capacity);\n+        }\n+    }\n+\n+    struct RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        buf_ptr: *mut TimSortRun,\n+        capacity: usize,\n+        len: usize,\n+        run_alloc_fn: RunAllocF,\n+        run_dealloc_fn: RunDeallocF,\n+    }\n+\n+    impl<RunAllocF, RunDeallocF> RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        fn new(run_alloc_fn: RunAllocF, run_dealloc_fn: RunDeallocF) -> Self {\n+            // Most slices can be sorted with at most 16 runs in-flight.\n+            const START_RUN_CAPACITY: usize = 16;\n+\n+            Self {\n+                buf_ptr: run_alloc_fn(START_RUN_CAPACITY),\n+                capacity: START_RUN_CAPACITY,\n+                len: 0,\n+                run_alloc_fn,\n+                run_dealloc_fn,\n+            }\n+        }\n+\n+        fn push(&mut self, val: TimSortRun) {\n+            if self.len == self.capacity {\n+                let old_capacity = self.capacity;\n+                let old_buf_ptr = self.buf_ptr;\n+\n+                self.capacity = self.capacity * 2;\n+                self.buf_ptr = (self.run_alloc_fn)(self.capacity);\n+\n+                // SAFETY: buf_ptr new and old were correctly allocated and old_buf_ptr has\n+                // old_capacity valid elements.\n+                unsafe {\n+                    ptr::copy_nonoverlapping(old_buf_ptr, self.buf_ptr, old_capacity);\n+                }\n+\n+                (self.run_dealloc_fn)(old_buf_ptr, old_capacity);\n+            }\n+\n+            // SAFETY: The invariant was just checked.\n+            unsafe {\n+                self.buf_ptr.add(self.len).write(val);\n+            }\n+            self.len += 1;\n+        }\n+\n+        fn remove(&mut self, index: usize) {\n+            if index >= self.len {\n+                panic!(\"Index out of bounds\");\n+            }\n+\n+            // SAFETY: buf_ptr needs to be valid and len invariant upheld.\n+            unsafe {\n+                // the place we are taking from.\n+                let ptr = self.buf_ptr.add(index);\n+\n+                // Shift everything down to fill in that spot.\n+                ptr::copy(ptr.add(1), ptr, self.len - index - 1);\n+            }\n+            self.len -= 1;\n+        }\n+\n+        fn as_slice(&self) -> &[TimSortRun] {\n+            // SAFETY: Safe as long as buf_ptr is valid and len invariant was upheld.\n+            unsafe { &*ptr::slice_from_raw_parts(self.buf_ptr, self.len) }\n+        }\n+\n+        fn len(&self) -> usize {\n+            self.len\n+        }\n+    }\n+\n+    impl<RunAllocF, RunDeallocF> core::ops::Index<usize> for RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        type Output = TimSortRun;\n+\n+        fn index(&self, index: usize) -> &Self::Output {\n+            if index < self.len {\n+                // SAFETY: buf_ptr and len invariant must be upheld.\n+                unsafe {\n+                    return &*(self.buf_ptr.add(index));\n+                }\n+            }\n+\n+            panic!(\"Index out of bounds\");\n+        }\n+    }\n+\n+    impl<RunAllocF, RunDeallocF> core::ops::IndexMut<usize> for RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n+            if index < self.len {\n+                // SAFETY: buf_ptr and len invariant must be upheld.\n+                unsafe {\n+                    return &mut *(self.buf_ptr.add(index));\n+                }\n+            }\n+\n+            panic!(\"Index out of bounds\");\n+        }\n+    }\n+\n+    impl<RunAllocF, RunDeallocF> Drop for RunVec<RunAllocF, RunDeallocF>\n+    where\n+        RunAllocF: Fn(usize) -> *mut TimSortRun,\n+        RunDeallocF: Fn(*mut TimSortRun, usize),\n+    {\n+        fn drop(&mut self) {\n+            // As long as TimSortRun is Copy we don't need to drop them individually but just the\n+            // whole allocation.\n+            (self.run_dealloc_fn)(self.buf_ptr, self.capacity);\n+        }\n+    }\n+}\n+\n+/// Internal type used by merge_sort.\n+#[derive(Clone, Copy, Debug)]\n+pub struct TimSortRun {\n+    len: usize,\n+    start: usize,\n+}"}, {"sha": "89adfccd90135233ef2ac66b533571bbbc3eeae5", "filename": "library/core/src/task/wake.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -174,6 +174,7 @@ impl RawWakerVTable {\n /// Currently, `Context` only serves to provide access to a [`&Waker`](Waker)\n /// which can be used to wake the current task.\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+#[cfg_attr(not(bootstrap), lang = \"Context\")]\n pub struct Context<'a> {\n     waker: &'a Waker,\n     // Ensure we future-proof against variance changes by forcing"}, {"sha": "a2b9bb551e677c57672721373a2866f624a307e5", "filename": "library/core/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -15,7 +15,7 @@ macro_rules! test_literal {\n         for input in inputs {\n             assert_eq!(input.parse(), Ok(x64));\n             assert_eq!(input.parse(), Ok(x32));\n-            let neg_input = &format!(\"-{input}\");\n+            let neg_input = format!(\"-{input}\");\n             assert_eq!(neg_input.parse(), Ok(-x64));\n             assert_eq!(neg_input.parse(), Ok(-x32));\n         }"}, {"sha": "d576bd0ccee03b5d4ea32070dd410f94a1ac131c", "filename": "library/portable-simd/crates/core_simd/examples/spectral_norm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -69,7 +69,7 @@ fn dot(x: &[f64], y: &[f64]) -> f64 {\n #[cfg(test)]\n #[test]\n fn test() {\n-    assert_eq!(&format!(\"{:.9}\", spectral_norm(100)), \"1.274219991\");\n+    assert_eq!(format!(\"{:.9}\", spectral_norm(100)), \"1.274219991\");\n }\n \n fn main() {"}, {"sha": "3581484050dd1a4e506574b46d99ce609c5ed996", "filename": "library/std/src/io/error/repr_bitpacked.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -374,10 +374,10 @@ static_assert!((TAG_MASK + 1).is_power_of_two());\n static_assert!(align_of::<SimpleMessage>() >= TAG_MASK + 1);\n static_assert!(align_of::<Custom>() >= TAG_MASK + 1);\n \n-static_assert!(@usize_eq: (TAG_MASK & TAG_SIMPLE_MESSAGE), TAG_SIMPLE_MESSAGE);\n-static_assert!(@usize_eq: (TAG_MASK & TAG_CUSTOM), TAG_CUSTOM);\n-static_assert!(@usize_eq: (TAG_MASK & TAG_OS), TAG_OS);\n-static_assert!(@usize_eq: (TAG_MASK & TAG_SIMPLE), TAG_SIMPLE);\n+static_assert!(@usize_eq: TAG_MASK & TAG_SIMPLE_MESSAGE, TAG_SIMPLE_MESSAGE);\n+static_assert!(@usize_eq: TAG_MASK & TAG_CUSTOM, TAG_CUSTOM);\n+static_assert!(@usize_eq: TAG_MASK & TAG_OS, TAG_OS);\n+static_assert!(@usize_eq: TAG_MASK & TAG_SIMPLE, TAG_SIMPLE);\n \n // This is obviously true (`TAG_CUSTOM` is `0b01`), but in `Repr::new_custom` we\n // offset a pointer by this value, and expect it to both be within the same"}, {"sha": "9aea62a5b940c553cfb011ecb322f7ff7a5a9af0", "filename": "library/std/src/io/error/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -190,5 +190,5 @@ fn test_std_io_error_downcast() {\n     let io_error = io_error.downcast::<E>().unwrap_err();\n \n     assert_eq!(SIMPLE_MESSAGE.kind, io_error.kind());\n-    assert_eq!(SIMPLE_MESSAGE.message, &*format!(\"{io_error}\"));\n+    assert_eq!(SIMPLE_MESSAGE.message, format!(\"{io_error}\"));\n }"}, {"sha": "0eb59d45de727b6603bd32b1988b55fcb509e9ac", "filename": "library/std/src/net/ip_addr/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip_addr%2Ftests.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -125,8 +125,8 @@ fn ipv4_addr_to_string() {\n     assert_eq!(Ipv4Addr::new(127, 127, 127, 127).to_string(), \"127.127.127.127\");\n \n     // Test padding\n-    assert_eq!(&format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n-    assert_eq!(&format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n+    assert_eq!(format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n+    assert_eq!(format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n }\n \n #[test]\n@@ -148,8 +148,8 @@ fn ipv6_addr_to_string() {\n         \"1111:2222:3333:4444:5555:6666:7777:8888\"\n     );\n     // padding\n-    assert_eq!(&format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"1:2:3:4:5:6:7:8     \");\n-    assert_eq!(&format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"     1:2:3:4:5:6:7:8\");\n+    assert_eq!(format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"1:2:3:4:5:6:7:8     \");\n+    assert_eq!(format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"     1:2:3:4:5:6:7:8\");\n \n     // reduce a single run of zeros\n     assert_eq!("}, {"sha": "dfc6dabbed1edeace9365cd0ed3bcdb89ea4e932", "filename": "library/std/src/net/socket_addr/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fsocket_addr%2Ftests.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -64,11 +64,11 @@ fn ipv4_socket_addr_to_string() {\n \n     // Test padding.\n     assert_eq!(\n-        &format!(\"{:16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n+        format!(\"{:16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n         \"1.1.1.1:53      \"\n     );\n     assert_eq!(\n-        &format!(\"{:>16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n+        format!(\"{:>16}\", SocketAddrV4::new(Ipv4Addr::new(1, 1, 1, 1), 53)),\n         \"      1.1.1.1:53\"\n     );\n }\n@@ -111,11 +111,11 @@ fn ipv6_socket_addr_to_string() {\n \n     // Test padding.\n     assert_eq!(\n-        &format!(\"{:22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n+        format!(\"{:22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n         \"[1:2:3:4:5:6:7:8]:9   \"\n     );\n     assert_eq!(\n-        &format!(\"{:>22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n+        format!(\"{:>22}\", SocketAddrV6::new(Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8), 9, 0, 0)),\n         \"   [1:2:3:4:5:6:7:8]:9\"\n     );\n }"}, {"sha": "85065984fbbb19872e7c2935e683969b4e8feef2", "filename": "library/std/src/os/net/linux_ext/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fnet%2Flinux_ext%2Faddr.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -38,7 +38,7 @@ pub trait SocketAddrExt: Sealed {\n     ///     Ok(())\n     /// }\n     /// ```\n-    fn from_abstract_name<N>(name: &N) -> crate::io::Result<SocketAddr>\n+    fn from_abstract_name<N>(name: N) -> crate::io::Result<SocketAddr>\n     where\n         N: AsRef<[u8]>;\n "}, {"sha": "ece2b33bddf364e16c1421b68f5a37e362ee5793", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -256,7 +256,7 @@ impl linux_ext::addr::SocketAddrExt for SocketAddr {\n         if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n     }\n \n-    fn from_abstract_name<N>(name: &N) -> crate::io::Result<Self>\n+    fn from_abstract_name<N>(name: N) -> crate::io::Result<Self>\n     where\n         N: AsRef<[u8]>,\n     {"}, {"sha": "2f53cf83936910e1df1dc217f96a8884c6f53302", "filename": "library/std/src/path.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -2531,6 +2531,8 @@ impl Path {\n \n     /// Creates an owned [`PathBuf`] with `path` adjoined to `self`.\n     ///\n+    /// If `path` is absolute, it replaces the current path.\n+    ///\n     /// See [`PathBuf::push`] for more details on what it means to adjoin a path.\n     ///\n     /// # Examples\n@@ -2539,6 +2541,7 @@ impl Path {\n     /// use std::path::{Path, PathBuf};\n     ///\n     /// assert_eq!(Path::new(\"/etc\").join(\"passwd\"), PathBuf::from(\"/etc/passwd\"));\n+    /// assert_eq!(Path::new(\"/etc\").join(\"/bin/sh\"), PathBuf::from(\"/bin/sh\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]"}, {"sha": "3bc17b7754d85b7405c7eb33095cb8372e681f41", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -746,6 +746,8 @@ fn signal_string(signal: i32) -> &'static str {\n         libc::SIGWINCH => \" (SIGWINCH)\",\n         #[cfg(not(target_os = \"haiku\"))]\n         libc::SIGIO => \" (SIGIO)\",\n+        #[cfg(target_os = \"haiku\")]\n+        libc::SIGPOLL => \" (SIGPOLL)\",\n         libc::SIGSYS => \" (SIGSYS)\",\n         // For information on Linux signals, run `man 7 signal`\n         #[cfg(all("}, {"sha": "65c882fb801e5b736e8958cc7b5fcf381a67a0b5", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -47,6 +47,8 @@ fn cc2ar(cc: &Path, target: TargetSelection) -> Option<PathBuf> {\n         Some(PathBuf::from(\"ar\"))\n     } else if target.contains(\"vxworks\") {\n         Some(PathBuf::from(\"wr-ar\"))\n+    } else if target.contains(\"android\") {\n+        Some(cc.parent().unwrap().join(PathBuf::from(\"llvm-ar\")))\n     } else {\n         let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();\n@@ -219,12 +221,22 @@ fn set_compiler(\n }\n \n pub(crate) fn ndk_compiler(compiler: Language, triple: &str, ndk: &Path) -> PathBuf {\n-    let triple_translated = triple\n-        .replace(\"armv7neon\", \"arm\")\n-        .replace(\"armv7\", \"arm\")\n-        .replace(\"thumbv7neon\", \"arm\")\n-        .replace(\"thumbv7\", \"arm\");\n-    let compiler = format!(\"{}-{}\", triple_translated, compiler.clang());\n+    let mut triple_iter = triple.split(\"-\");\n+    let triple_translated = if let Some(arch) = triple_iter.next() {\n+        let arch_new = match arch {\n+            \"arm\" | \"armv7\" | \"armv7neon\" | \"thumbv7\" | \"thumbv7neon\" => \"armv7a\",\n+            other => other,\n+        };\n+        std::iter::once(arch_new).chain(triple_iter).collect::<Vec<&str>>().join(\"-\")\n+    } else {\n+        triple.to_string()\n+    };\n+\n+    // API 19 is the earliest API level supported by NDK r25b but AArch64 and x86_64 support\n+    // begins at API level 21.\n+    let api_level =\n+        if triple.contains(\"aarch64\") || triple.contains(\"x86_64\") { \"21\" } else { \"19\" };\n+    let compiler = format!(\"{}{}-{}\", triple_translated, api_level, compiler.clang());\n     ndk.join(\"bin\").join(compiler)\n }\n "}, {"sha": "2e4f753965deda9938c65f8ee353fdcb9c5331c2", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1130,12 +1130,6 @@ impl Step for RustAnalyzer {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        if target.contains(\"riscv64\") {\n-            // riscv64 currently has an LLVM bug that makes rust-analyzer unable\n-            // to build. See #74813 for details.\n-            return None;\n-        }\n-\n         let rust_analyzer = builder\n             .ensure(tool::RustAnalyzer { compiler, target })\n             .expect(\"rust-analyzer always builds\");"}, {"sha": "cb5706ca0a6516f838cc56581d580bfdf34207f8", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1105,6 +1105,12 @@ fn supported_sanitizers(\n         \"x86_64-unknown-linux-musl\" => {\n             common_libs(\"linux\", \"x86_64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])\n         }\n+        \"s390x-unknown-linux-gnu\" => {\n+            common_libs(\"linux\", \"s390x\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])\n+        }\n+        \"s390x-unknown-linux-musl\" => {\n+            common_libs(\"linux\", \"s390x\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])\n+        }\n         _ => Vec::new(),\n     }\n }"}, {"sha": "b6b4fdc67a94905a2d6e28f2b56d01c44ceeb6dc", "filename": "src/ci/docker/host-x86_64/arm-android/Dockerfile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,12 +1,12 @@\n-FROM ubuntu:22.04\n+FROM ubuntu:22.10\n \n ARG DEBIAN_FRONTEND=noninteractive\n COPY scripts/android-base-apt-get.sh /scripts/\n RUN sh /scripts/android-base-apt-get.sh\n \n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_and_make_toolchain android-ndk-r15c-linux-x86_64.zip arm 14\n+    download_ndk android-ndk-r25b-linux.zip\n \n RUN dpkg --add-architecture i386 && \\\n     apt-get update && \\\n@@ -30,7 +30,7 @@ ENV PATH=$PATH:/android/sdk/platform-tools\n \n ENV TARGETS=arm-linux-androideabi\n \n-ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/arm-14\n+ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/\n \n ENV SCRIPT python3 ../x.py --stage 2 test --host='' --target $TARGETS\n "}, {"sha": "9c6f648896b5127559decfa7d37c229650ca7173", "filename": "src/ci/docker/host-x86_64/dist-android/Dockerfile", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-android%2FDockerfile?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,19 +1,12 @@\n-FROM ubuntu:22.04\n+FROM ubuntu:22.10\n \n COPY scripts/android-base-apt-get.sh /scripts/\n RUN sh /scripts/android-base-apt-get.sh\n \n # ndk\n COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n-    download_ndk android-ndk-r15c-linux-x86_64.zip && \\\n-    make_standalone_toolchain arm 14 && \\\n-    make_standalone_toolchain x86 14 && \\\n-    make_standalone_toolchain arm 21 && \\\n-    make_standalone_toolchain x86 21 && \\\n-    make_standalone_toolchain arm64 21 && \\\n-    make_standalone_toolchain x86_64 21 && \\\n-    remove_ndk\n+    download_ndk android-ndk-r25b-linux.zip\n \n # env\n ENV TARGETS=arm-linux-androideabi\n@@ -26,12 +19,12 @@ ENV TARGETS=$TARGETS,x86_64-linux-android\n ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --enable-profiler \\\n-      --arm-linux-androideabi-ndk=/android/ndk/arm-14 \\\n-      --armv7-linux-androideabi-ndk=/android/ndk/arm-14 \\\n-      --thumbv7neon-linux-androideabi-ndk=/android/ndk/arm-14 \\\n-      --i686-linux-android-ndk=/android/ndk/x86-14 \\\n-      --aarch64-linux-android-ndk=/android/ndk/arm64-21 \\\n-      --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\\n+      --arm-linux-androideabi-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n+      --armv7-linux-androideabi-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n+      --thumbv7neon-linux-androideabi-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n+      --i686-linux-android-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n+      --aarch64-linux-android-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n+      --x86_64-linux-android-ndk=/android/ndk/toolchains/llvm/prebuilt/linux-x86_64/ \\\n       --disable-docs\n \n ENV SCRIPT python3 ../x.py dist --host='' --target $TARGETS"}, {"sha": "adb98d7ebb54541e83fbd61d1c877a169119a1cd", "filename": "src/ci/docker/host-x86_64/dist-s390x-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2FDockerfile?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -28,5 +28,5 @@ ENV \\\n \n ENV HOSTS=s390x-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --enable-profiler --disable-docs\n+ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --enable-sanitizers --enable-profiler --disable-docs\n ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "889a586b351d6f30f700d433461b5951fd80f92a", "filename": "src/ci/docker/host-x86_64/mingw-check-tidy/Dockerfile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,8 +1,6 @@\n-FROM ubuntu:18.04\n-# FIXME: when bumping the version, remove the Python 3.6-specific changes in\n-# the reuse-requirements.in file, regenerate reuse-requirements.txt and remove\n-# this comment.\n+FROM ubuntu:22.04\n \n+ARG DEBIAN_FRONTEND=noninteractive\n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n   make \\"}, {"sha": "4cc5d9f8a0dafd08bb59e6b92feb618fba17ad02", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,8 +1,6 @@\n-FROM ubuntu:18.04\n-# FIXME: when bumping the version, remove the Python 3.6-specific changes in\n-# the reuse-requirements.in file, regenerate reuse-requirements.txt and remove\n-# this comment.\n+FROM ubuntu:22.04\n \n+ARG DEBIAN_FRONTEND=noninteractive\n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n   make \\"}, {"sha": "c7b3376e2f1fb97d06a6153719677f8db7365467", "filename": "src/ci/docker/host-x86_64/mingw-check/reuse-requirements.in", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2Freuse-requirements.in", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2Freuse-requirements.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2Freuse-requirements.in?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -12,11 +12,3 @@\n #\n \n reuse\n-\n-# Some packages dropped support for Python 3.6, which is the version used in\n-# this builder (due to Ubuntu 18.04). This should be removed once we bump the\n-# Ubuntu version of the builder.\n-jinja2 < 3.1\n-markupsafe < 2.1\n-requests < 2.28\n-setuptools < 59.7"}, {"sha": "b0f598f77ea6f38bfebc810621affead94a7d82c", "filename": "src/ci/docker/host-x86_64/mingw-check/reuse-requirements.txt", "status": "modified", "additions": 68, "deletions": 129, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2Freuse-requirements.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2Freuse-requirements.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2Freuse-requirements.txt?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1,145 +1,84 @@\n #\n-# This file is autogenerated by pip-compile with python 3.10\n-# To update, run:\n+# This file is autogenerated by pip-compile with Python 3.10\n+# by the following command:\n #\n #    pip-compile --allow-unsafe --generate-hashes reuse-requirements.in\n #\n binaryornot==0.4.4 \\\n     --hash=sha256:359501dfc9d40632edc9fac890e19542db1a287bbcfa58175b66658392018061 \\\n     --hash=sha256:b8b71173c917bddcd2c16070412e369c3ed7f0528926f70cac18a6c97fd563e4\n     # via reuse\n-boolean-py==3.8 \\\n-    --hash=sha256:cc24e20f985d60cd4a3a5a1c0956dd12611159d32a75081dabd0c9ab981acaa4 \\\n-    --hash=sha256:d75da0fd0354425fa64f6bbc6cec6ae1485d0eec3447b73187ff8cbf9b572e26\n+boolean-py==4.0 \\\n+    --hash=sha256:17b9a181630e43dde1851d42bef546d616d5d9b4480357514597e78b203d06e4 \\\n+    --hash=sha256:2876f2051d7d6394a531d82dc6eb407faa0b01a0a0b3083817ccd7323b8d96bd\n     # via\n     #   license-expression\n     #   reuse\n-certifi==2022.6.15 \\\n-    --hash=sha256:84c85a9078b11105f04f3036a9482ae10e4621616db313fe045dd24743a0820d \\\n-    --hash=sha256:fe86415d55e84719d75f8b69414f6438ac3547d2078ab91b67e779ef69378412\n-    # via requests\n-chardet==5.0.0 \\\n-    --hash=sha256:0368df2bfd78b5fc20572bb4e9bb7fb53e2c094f60ae9993339e8671d0afb8aa \\\n-    --hash=sha256:d3e64f022d254183001eccc5db4040520c0f23b1a3f33d6413e099eb7f126557\n+chardet==5.1.0 \\\n+    --hash=sha256:0d62712b956bc154f85fb0a266e2a3c5913c2967e00348701b32411d6def31e5 \\\n+    --hash=sha256:362777fb014af596ad31334fde1e8c327dfdb076e1960d1694662d46a6917ab9\n     # via\n     #   binaryornot\n     #   python-debian\n-charset-normalizer==2.0.12 \\\n-    --hash=sha256:2857e29ff0d34db842cd7ca3230549d1a697f96ee6d3fb071cfa6c7393832597 \\\n-    --hash=sha256:6881edbebdb17b39b4eaaa821b438bf6eddffb4468cf344f09f89def34a8b1df\n-    # via requests\n-idna==3.3 \\\n-    --hash=sha256:84d9dd047ffa80596e0f246e2eab0b391788b0503584e8945f2368256d2735ff \\\n-    --hash=sha256:9d643ff0a55b762d5cdb124b8eaa99c66322e2157b69160bc32796e824360e6d\n-    # via requests\n-jinja2==3.0.3 \\\n-    --hash=sha256:077ce6014f7b40d03b47d1f1ca4b0fc8328a692bd284016f806ed0eaca390ad8 \\\n-    --hash=sha256:611bb273cd68f3b993fabdc4064fc858c5b47a973cb5aa7999ec1ba405c87cd7\n-    # via\n-    #   -r reuse-requirements.in\n-    #   reuse\n-license-expression==21.6.14 \\\n-    --hash=sha256:324246eed8e138b4139fefdc0e9dc4161d5075e3929e56983966d37298dca30e \\\n-    --hash=sha256:9de87a427c9a449eee7913472fb9ed03b63036295547369fdbf95f76a8b924b2\n-    # via\n-    #   -r reuse-requirements.in\n-    #   reuse\n-markupsafe==2.0.1 \\\n-    --hash=sha256:01a9b8ea66f1658938f65b93a85ebe8bc016e6769611be228d797c9d998dd298 \\\n-    --hash=sha256:023cb26ec21ece8dc3907c0e8320058b2e0cb3c55cf9564da612bc325bed5e64 \\\n-    --hash=sha256:0446679737af14f45767963a1a9ef7620189912317d095f2d9ffa183a4d25d2b \\\n-    --hash=sha256:04635854b943835a6ea959e948d19dcd311762c5c0c6e1f0e16ee57022669194 \\\n-    --hash=sha256:0717a7390a68be14b8c793ba258e075c6f4ca819f15edfc2a3a027c823718567 \\\n-    --hash=sha256:0955295dd5eec6cb6cc2fe1698f4c6d84af2e92de33fbcac4111913cd100a6ff \\\n-    --hash=sha256:0d4b31cc67ab36e3392bbf3862cfbadac3db12bdd8b02a2731f509ed5b829724 \\\n-    --hash=sha256:10f82115e21dc0dfec9ab5c0223652f7197feb168c940f3ef61563fc2d6beb74 \\\n-    --hash=sha256:168cd0a3642de83558a5153c8bd34f175a9a6e7f6dc6384b9655d2697312a646 \\\n-    --hash=sha256:1d609f577dc6e1aa17d746f8bd3c31aa4d258f4070d61b2aa5c4166c1539de35 \\\n-    --hash=sha256:1f2ade76b9903f39aa442b4aadd2177decb66525062db244b35d71d0ee8599b6 \\\n-    --hash=sha256:20dca64a3ef2d6e4d5d615a3fd418ad3bde77a47ec8a23d984a12b5b4c74491a \\\n-    --hash=sha256:2a7d351cbd8cfeb19ca00de495e224dea7e7d919659c2841bbb7f420ad03e2d6 \\\n-    --hash=sha256:2d7d807855b419fc2ed3e631034685db6079889a1f01d5d9dac950f764da3dad \\\n-    --hash=sha256:2ef54abee730b502252bcdf31b10dacb0a416229b72c18b19e24a4509f273d26 \\\n-    --hash=sha256:36bc903cbb393720fad60fc28c10de6acf10dc6cc883f3e24ee4012371399a38 \\\n-    --hash=sha256:37205cac2a79194e3750b0af2a5720d95f786a55ce7df90c3af697bfa100eaac \\\n-    --hash=sha256:3c112550557578c26af18a1ccc9e090bfe03832ae994343cfdacd287db6a6ae7 \\\n-    --hash=sha256:3dd007d54ee88b46be476e293f48c85048603f5f516008bee124ddd891398ed6 \\\n-    --hash=sha256:4296f2b1ce8c86a6aea78613c34bb1a672ea0e3de9c6ba08a960efe0b0a09047 \\\n-    --hash=sha256:47ab1e7b91c098ab893b828deafa1203de86d0bc6ab587b160f78fe6c4011f75 \\\n-    --hash=sha256:49e3ceeabbfb9d66c3aef5af3a60cc43b85c33df25ce03d0031a608b0a8b2e3f \\\n-    --hash=sha256:4dc8f9fb58f7364b63fd9f85013b780ef83c11857ae79f2feda41e270468dd9b \\\n-    --hash=sha256:4efca8f86c54b22348a5467704e3fec767b2db12fc39c6d963168ab1d3fc9135 \\\n-    --hash=sha256:53edb4da6925ad13c07b6d26c2a852bd81e364f95301c66e930ab2aef5b5ddd8 \\\n-    --hash=sha256:5855f8438a7d1d458206a2466bf82b0f104a3724bf96a1c781ab731e4201731a \\\n-    --hash=sha256:594c67807fb16238b30c44bdf74f36c02cdf22d1c8cda91ef8a0ed8dabf5620a \\\n-    --hash=sha256:5b6d930f030f8ed98e3e6c98ffa0652bdb82601e7a016ec2ab5d7ff23baa78d1 \\\n-    --hash=sha256:5bb28c636d87e840583ee3adeb78172efc47c8b26127267f54a9c0ec251d41a9 \\\n-    --hash=sha256:60bf42e36abfaf9aff1f50f52644b336d4f0a3fd6d8a60ca0d054ac9f713a864 \\\n-    --hash=sha256:611d1ad9a4288cf3e3c16014564df047fe08410e628f89805e475368bd304914 \\\n-    --hash=sha256:6300b8454aa6930a24b9618fbb54b5a68135092bc666f7b06901f897fa5c2fee \\\n-    --hash=sha256:63f3268ba69ace99cab4e3e3b5840b03340efed0948ab8f78d2fd87ee5442a4f \\\n-    --hash=sha256:6557b31b5e2c9ddf0de32a691f2312a32f77cd7681d8af66c2692efdbef84c18 \\\n-    --hash=sha256:693ce3f9e70a6cf7d2fb9e6c9d8b204b6b39897a2c4a1aa65728d5ac97dcc1d8 \\\n-    --hash=sha256:6a7fae0dd14cf60ad5ff42baa2e95727c3d81ded453457771d02b7d2b3f9c0c2 \\\n-    --hash=sha256:6c4ca60fa24e85fe25b912b01e62cb969d69a23a5d5867682dd3e80b5b02581d \\\n-    --hash=sha256:6fcf051089389abe060c9cd7caa212c707e58153afa2c649f00346ce6d260f1b \\\n-    --hash=sha256:7d91275b0245b1da4d4cfa07e0faedd5b0812efc15b702576d103293e252af1b \\\n-    --hash=sha256:89c687013cb1cd489a0f0ac24febe8c7a666e6e221b783e53ac50ebf68e45d86 \\\n-    --hash=sha256:8d206346619592c6200148b01a2142798c989edcb9c896f9ac9722a99d4e77e6 \\\n-    --hash=sha256:905fec760bd2fa1388bb5b489ee8ee5f7291d692638ea5f67982d968366bef9f \\\n-    --hash=sha256:97383d78eb34da7e1fa37dd273c20ad4320929af65d156e35a5e2d89566d9dfb \\\n-    --hash=sha256:984d76483eb32f1bcb536dc27e4ad56bba4baa70be32fa87152832cdd9db0833 \\\n-    --hash=sha256:99df47edb6bda1249d3e80fdabb1dab8c08ef3975f69aed437cb69d0a5de1e28 \\\n-    --hash=sha256:9f02365d4e99430a12647f09b6cc8bab61a6564363f313126f775eb4f6ef798e \\\n-    --hash=sha256:a30e67a65b53ea0a5e62fe23682cfe22712e01f453b95233b25502f7c61cb415 \\\n-    --hash=sha256:ab3ef638ace319fa26553db0624c4699e31a28bb2a835c5faca8f8acf6a5a902 \\\n-    --hash=sha256:aca6377c0cb8a8253e493c6b451565ac77e98c2951c45f913e0b52facdcff83f \\\n-    --hash=sha256:add36cb2dbb8b736611303cd3bfcee00afd96471b09cda130da3581cbdc56a6d \\\n-    --hash=sha256:b2f4bf27480f5e5e8ce285a8c8fd176c0b03e93dcc6646477d4630e83440c6a9 \\\n-    --hash=sha256:b7f2d075102dc8c794cbde1947378051c4e5180d52d276987b8d28a3bd58c17d \\\n-    --hash=sha256:baa1a4e8f868845af802979fcdbf0bb11f94f1cb7ced4c4b8a351bb60d108145 \\\n-    --hash=sha256:be98f628055368795d818ebf93da628541e10b75b41c559fdf36d104c5787066 \\\n-    --hash=sha256:bf5d821ffabf0ef3533c39c518f3357b171a1651c1ff6827325e4489b0e46c3c \\\n-    --hash=sha256:c47adbc92fc1bb2b3274c4b3a43ae0e4573d9fbff4f54cd484555edbf030baf1 \\\n-    --hash=sha256:cdfba22ea2f0029c9261a4bd07e830a8da012291fbe44dc794e488b6c9bb353a \\\n-    --hash=sha256:d6c7ebd4e944c85e2c3421e612a7057a2f48d478d79e61800d81468a8d842207 \\\n-    --hash=sha256:d7f9850398e85aba693bb640262d3611788b1f29a79f0c93c565694658f4071f \\\n-    --hash=sha256:d8446c54dc28c01e5a2dbac5a25f071f6653e6e40f3a8818e8b45d790fe6ef53 \\\n-    --hash=sha256:deb993cacb280823246a026e3b2d81c493c53de6acfd5e6bfe31ab3402bb37dd \\\n-    --hash=sha256:e0f138900af21926a02425cf736db95be9f4af72ba1bb21453432a07f6082134 \\\n-    --hash=sha256:e9936f0b261d4df76ad22f8fee3ae83b60d7c3e871292cd42f40b81b70afae85 \\\n-    --hash=sha256:f0567c4dc99f264f49fe27da5f735f414c4e7e7dd850cfd8e69f0862d7c74ea9 \\\n-    --hash=sha256:f5653a225f31e113b152e56f154ccbe59eeb1c7487b39b9d9f9cdb58e6c79dc5 \\\n-    --hash=sha256:f826e31d18b516f653fe296d967d700fddad5901ae07c622bb3705955e1faa94 \\\n-    --hash=sha256:f8ba0e8349a38d3001fae7eadded3f6606f0da5d748ee53cc1dab1d6527b9509 \\\n-    --hash=sha256:f9081981fe268bd86831e5c75f7de206ef275defcb82bc70740ae6dc507aee51 \\\n-    --hash=sha256:fa130dd50c57d53368c9d59395cb5526eda596d3ffe36666cd81a44d56e48872\n-    # via\n-    #   -r reuse-requirements.in\n-    #   jinja2\n-python-debian==0.1.44 \\\n-    --hash=sha256:11bd6f01c46da57982bdd66dd595e2d240feb32a85de3fd37c452102fd0337ab \\\n-    --hash=sha256:65592fe3b64f6c6c93d94e2d2599db5e0c22831d3bcff07cb7b96d3840b1333e\n+jinja2==3.1.2 \\\n+    --hash=sha256:31351a702a408a9e7595a8fc6150fc3f43bb6bf7e319770cbc0db9df9437e852 \\\n+    --hash=sha256:6088930bfe239f0e6710546ab9c19c9ef35e29792895fed6e6e31a023a182a61\n     # via reuse\n-requests==2.26.0 \\\n-    --hash=sha256:6c1246513ecd5ecd4528a0906f910e8f0f9c6b8ec72030dc9fd154dc1a6efd24 \\\n-    --hash=sha256:b8aa58f8cf793ffd8782d3d8cb19e66ef36f7aba4353eec859e74678b01b07a7\n-    # via\n-    #   -r reuse-requirements.in\n-    #   reuse\n-reuse==1.0.0 \\\n-    --hash=sha256:db3022be2d87f69c8f508b928023de3026f454ce17d01e22f770f7147ac1e8d4 \\\n-    --hash=sha256:e2605e796311c424465d741ea2a1e1ad03bbb90b921d74750119c331ca5af46e\n+license-expression==30.0.0 \\\n+    --hash=sha256:ad638292aa8493f84354909b517922cb823582c2ce2c4d880e42544a86bea8dd \\\n+    --hash=sha256:e95325110110eb2b7539ee7773b97a0724d5371ec563cc718c8cac0e38cc40cc\n+    # via reuse\n+markupsafe==2.1.1 \\\n+    --hash=sha256:0212a68688482dc52b2d45013df70d169f542b7394fc744c02a57374a4207003 \\\n+    --hash=sha256:089cf3dbf0cd6c100f02945abeb18484bd1ee57a079aefd52cffd17fba910b88 \\\n+    --hash=sha256:10c1bfff05d95783da83491be968e8fe789263689c02724e0c691933c52994f5 \\\n+    --hash=sha256:33b74d289bd2f5e527beadcaa3f401e0df0a89927c1559c8566c066fa4248ab7 \\\n+    --hash=sha256:3799351e2336dc91ea70b034983ee71cf2f9533cdff7c14c90ea126bfd95d65a \\\n+    --hash=sha256:3ce11ee3f23f79dbd06fb3d63e2f6af7b12db1d46932fe7bd8afa259a5996603 \\\n+    --hash=sha256:421be9fbf0ffe9ffd7a378aafebbf6f4602d564d34be190fc19a193232fd12b1 \\\n+    --hash=sha256:43093fb83d8343aac0b1baa75516da6092f58f41200907ef92448ecab8825135 \\\n+    --hash=sha256:46d00d6cfecdde84d40e572d63735ef81423ad31184100411e6e3388d405e247 \\\n+    --hash=sha256:4a33dea2b688b3190ee12bd7cfa29d39c9ed176bda40bfa11099a3ce5d3a7ac6 \\\n+    --hash=sha256:4b9fe39a2ccc108a4accc2676e77da025ce383c108593d65cc909add5c3bd601 \\\n+    --hash=sha256:56442863ed2b06d19c37f94d999035e15ee982988920e12a5b4ba29b62ad1f77 \\\n+    --hash=sha256:671cd1187ed5e62818414afe79ed29da836dde67166a9fac6d435873c44fdd02 \\\n+    --hash=sha256:694deca8d702d5db21ec83983ce0bb4b26a578e71fbdbd4fdcd387daa90e4d5e \\\n+    --hash=sha256:6a074d34ee7a5ce3effbc526b7083ec9731bb3cbf921bbe1d3005d4d2bdb3a63 \\\n+    --hash=sha256:6d0072fea50feec76a4c418096652f2c3238eaa014b2f94aeb1d56a66b41403f \\\n+    --hash=sha256:6fbf47b5d3728c6aea2abb0589b5d30459e369baa772e0f37a0320185e87c980 \\\n+    --hash=sha256:7f91197cc9e48f989d12e4e6fbc46495c446636dfc81b9ccf50bb0ec74b91d4b \\\n+    --hash=sha256:86b1f75c4e7c2ac2ccdaec2b9022845dbb81880ca318bb7a0a01fbf7813e3812 \\\n+    --hash=sha256:8dc1c72a69aa7e082593c4a203dcf94ddb74bb5c8a731e4e1eb68d031e8498ff \\\n+    --hash=sha256:8e3dcf21f367459434c18e71b2a9532d96547aef8a871872a5bd69a715c15f96 \\\n+    --hash=sha256:8e576a51ad59e4bfaac456023a78f6b5e6e7651dcd383bcc3e18d06f9b55d6d1 \\\n+    --hash=sha256:96e37a3dc86e80bf81758c152fe66dbf60ed5eca3d26305edf01892257049925 \\\n+    --hash=sha256:97a68e6ada378df82bc9f16b800ab77cbf4b2fada0081794318520138c088e4a \\\n+    --hash=sha256:99a2a507ed3ac881b975a2976d59f38c19386d128e7a9a18b7df6fff1fd4c1d6 \\\n+    --hash=sha256:a49907dd8420c5685cfa064a1335b6754b74541bbb3706c259c02ed65b644b3e \\\n+    --hash=sha256:b09bf97215625a311f669476f44b8b318b075847b49316d3e28c08e41a7a573f \\\n+    --hash=sha256:b7bd98b796e2b6553da7225aeb61f447f80a1ca64f41d83612e6139ca5213aa4 \\\n+    --hash=sha256:b87db4360013327109564f0e591bd2a3b318547bcef31b468a92ee504d07ae4f \\\n+    --hash=sha256:bcb3ed405ed3222f9904899563d6fc492ff75cce56cba05e32eff40e6acbeaa3 \\\n+    --hash=sha256:d4306c36ca495956b6d568d276ac11fdd9c30a36f1b6eb928070dc5360b22e1c \\\n+    --hash=sha256:d5ee4f386140395a2c818d149221149c54849dfcfcb9f1debfe07a8b8bd63f9a \\\n+    --hash=sha256:dda30ba7e87fbbb7eab1ec9f58678558fd9a6b8b853530e176eabd064da81417 \\\n+    --hash=sha256:e04e26803c9c3851c931eac40c695602c6295b8d432cbe78609649ad9bd2da8a \\\n+    --hash=sha256:e1c0b87e09fa55a220f058d1d49d3fb8df88fbfab58558f1198e08c1e1de842a \\\n+    --hash=sha256:e72591e9ecd94d7feb70c1cbd7be7b3ebea3f548870aa91e2732960fa4d57a37 \\\n+    --hash=sha256:e8c843bbcda3a2f1e3c2ab25913c80a3c5376cd00c6e8c4a86a89a28c8dc5452 \\\n+    --hash=sha256:efc1913fd2ca4f334418481c7e595c00aad186563bbc1ec76067848c7ca0a933 \\\n+    --hash=sha256:f121a1420d4e173a5d96e47e9a0c0dcff965afdf1626d28de1460815f7c4ee7a \\\n+    --hash=sha256:fc7b548b17d238737688817ab67deebb30e8073c95749d55538ed473130ec0c7\n+    # via jinja2\n+python-debian==0.1.49 \\\n+    --hash=sha256:880f3bc52e31599f2a9b432bd7691844286825087fccdcf2f6ffd5cd79a26f9f \\\n+    --hash=sha256:8cf677a30dbcb4be7a99536c17e11308a827a4d22028dc59a67f6c6dd3f0f58c\n+    # via reuse\n+reuse==1.1.0 \\\n+    --hash=sha256:7a054f6e372ad02d0b1b07368030fc38746b50ed45f5422a81994e7a88b52f1f \\\n+    --hash=sha256:b0f3fb9091ff513af04b555d14a4c529ab05f6a575ab192dd9b68244f1e0721d\n     # via -r reuse-requirements.in\n-urllib3==1.26.10 \\\n-    --hash=sha256:8298d6d56d39be0e3bc13c1c97d133f9b45d797169a0e11cdd0e0489d786f7ec \\\n-    --hash=sha256:879ba4d1e89654d9769ce13121e0f94310ea32e8d2f8cf587b77c08bbcdb30d6\n-    # via requests\n-\n-# The following packages are considered to be unsafe in a requirements file:\n-setuptools==59.6.0 \\\n-    --hash=sha256:22c7348c6d2976a52632c67f7ab0cdf40147db7789f9aed18734643fe9cf3373 \\\n-    --hash=sha256:4ce92f1e1f8f01233ee9952c04f6b81d1e02939d6e1b488428154974a4d0783e\n-    # via\n-    #   -r reuse-requirements.in\n-    #   reuse\n+setuptools==66.0.0 \\\n+    --hash=sha256:a78d01d1e2c175c474884671dde039962c9d74c7223db7369771fcf6e29ceeab \\\n+    --hash=sha256:bd6eb2d6722568de6d14b87c44a96fac54b2a45ff5e940e639979a3d1792adb6\n+    # via reuse"}, {"sha": "4dd6ac274fd5b96dfa24873a8c4e0aea6c262cbc", "filename": "src/ci/docker/scripts/android-ndk.sh", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -4,28 +4,10 @@ set -ex\n URL=https://dl.google.com/android/repository\n \n download_ndk() {\n-    mkdir -p /android/ndk\n-    cd /android/ndk\n+    mkdir /android/\n+    cd /android\n     curl -fO $URL/$1\n     unzip -q $1\n     rm $1\n     mv android-ndk-* ndk\n }\n-\n-make_standalone_toolchain() {\n-    # See https://developer.android.com/ndk/guides/standalone_toolchain.htm\n-    python3 /android/ndk/ndk/build/tools/make_standalone_toolchain.py \\\n-        --install-dir /android/ndk/$1-$2 \\\n-        --arch $1 \\\n-        --api $2\n-}\n-\n-remove_ndk() {\n-    rm -rf /android/ndk/ndk\n-}\n-\n-download_and_make_toolchain() {\n-    download_ndk $1 && \\\n-    make_standalone_toolchain $2 $3 && \\\n-    remove_ndk\n-}"}, {"sha": "2cd1b5593d26dc6a03c20f8619187ad4b2485552", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1 +1 @@\n-Subproject commit 2bd5d42c9956369132228da6409f0e68da56c51a\n+Subproject commit 2cd1b5593d26dc6a03c20f8619187ad4b2485552"}, {"sha": "960d610e7f33889a2577f5f17c26f0d5c82b30df", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1 +1 @@\n-Subproject commit 8ca261268068d80c0969260fff15199bad87b587\n+Subproject commit 960d610e7f33889a2577f5f17c26f0d5c82b30df"}, {"sha": "2cb0ed9ba56360949f492f9866afe8c293f9f9da", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1 +1 @@\n-Subproject commit 3ae62681ff236d5528ef7c8c28ba7c6b2ecc6731\n+Subproject commit 2cb0ed9ba56360949f492f9866afe8c293f9f9da"}, {"sha": "a9fb7d13eadfcc5f457962731f105b97f9a7474a", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1 +1 @@\n-Subproject commit 8888f9428fe9a48f31de6bd2cef9b9bf80791edc\n+Subproject commit a9fb7d13eadfcc5f457962731f105b97f9a7474a"}, {"sha": "7352353ae91c48b136d2ca7d03822e1448165e1e", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -1 +1 @@\n-Subproject commit b3e2a6e6c8a3aae5b5d950c63046f23bae07096d\n+Subproject commit 7352353ae91c48b136d2ca7d03822e1448165e1e"}, {"sha": "da91e25595cc760f117b1eb265748e96ce0c4c6b", "filename": "src/doc/rustc/src/instrument-coverage.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -201,6 +201,8 @@ $ RUSTFLAGS=\"-C instrument-coverage\" \\\n     cargo test --tests\n ```\n \n+> **Note**: The default for `LLVM_PROFILE_FILE` is `default_%m_%p.profraw`. Versions prior to 1.65 had a default of `default.profraw`, so if using those earlier versions, it is recommended to explicitly set `LLVM_PROFILE_FILE=\"default_%m_%p.profraw\"` to avoid having multiple tests overwrite the `.profraw` files.\n+\n Make note of the test binary file paths, displayed after the word \"`Running`\" in the test output:\n \n ```text"}, {"sha": "a302750aa1aea341359cb95ad12d718bc501eec2", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -402,15 +402,13 @@ where\n                     bound_params: Vec::new(),\n                 })\n             })\n-            .chain(\n-                lifetime_to_bounds.into_iter().filter(|&(_, ref bounds)| !bounds.is_empty()).map(\n-                    |(lifetime, bounds)| {\n-                        let mut bounds_vec = bounds.into_iter().collect();\n-                        self.sort_where_bounds(&mut bounds_vec);\n-                        WherePredicate::RegionPredicate { lifetime, bounds: bounds_vec }\n-                    },\n-                ),\n-            )\n+            .chain(lifetime_to_bounds.into_iter().filter(|(_, bounds)| !bounds.is_empty()).map(\n+                |(lifetime, bounds)| {\n+                    let mut bounds_vec = bounds.into_iter().collect();\n+                    self.sort_where_bounds(&mut bounds_vec);\n+                    WherePredicate::RegionPredicate { lifetime, bounds: bounds_vec }\n+                },\n+            ))\n             .collect()\n     }\n "}, {"sha": "da300b89a4e9b1273a168fdd4b57908834f14ae0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -9,7 +9,7 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, DefIdSet, LocalDefId};\n use rustc_hir::Mutability;\n use rustc_metadata::creader::{CStore, LoadedMacro};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -45,7 +45,7 @@ pub(crate) fn try_inline(\n     res: Res,\n     name: Symbol,\n     attrs: Option<&[ast::Attribute]>,\n-    visited: &mut FxHashSet<DefId>,\n+    visited: &mut DefIdSet,\n ) -> Option<Vec<clean::Item>> {\n     let did = res.opt_def_id()?;\n     if did.is_local() {\n@@ -162,7 +162,8 @@ pub(crate) fn try_inline(\n pub(crate) fn try_inline_glob(\n     cx: &mut DocContext<'_>,\n     res: Res,\n-    visited: &mut FxHashSet<DefId>,\n+    current_mod: LocalDefId,\n+    visited: &mut DefIdSet,\n     inlined_names: &mut FxHashSet<(ItemType, Symbol)>,\n ) -> Option<Vec<clean::Item>> {\n     let did = res.opt_def_id()?;\n@@ -172,7 +173,16 @@ pub(crate) fn try_inline_glob(\n \n     match res {\n         Res::Def(DefKind::Mod, did) => {\n-            let mut items = build_module_items(cx, did, visited, inlined_names);\n+            // Use the set of module reexports to filter away names that are not actually\n+            // reexported by the glob, e.g. because they are shadowed by something else.\n+            let reexports = cx\n+                .tcx\n+                .module_reexports(current_mod)\n+                .unwrap_or_default()\n+                .iter()\n+                .filter_map(|child| child.res.opt_def_id())\n+                .collect();\n+            let mut items = build_module_items(cx, did, visited, inlined_names, Some(&reexports));\n             items.drain_filter(|item| {\n                 if let Some(name) = item.name {\n                     // If an item with the same type and name already exists,\n@@ -558,12 +568,8 @@ pub(crate) fn build_impl(\n     ));\n }\n \n-fn build_module(\n-    cx: &mut DocContext<'_>,\n-    did: DefId,\n-    visited: &mut FxHashSet<DefId>,\n-) -> clean::Module {\n-    let items = build_module_items(cx, did, visited, &mut FxHashSet::default());\n+fn build_module(cx: &mut DocContext<'_>, did: DefId, visited: &mut DefIdSet) -> clean::Module {\n+    let items = build_module_items(cx, did, visited, &mut FxHashSet::default(), None);\n \n     let span = clean::Span::new(cx.tcx.def_span(did));\n     clean::Module { items, span }\n@@ -572,8 +578,9 @@ fn build_module(\n fn build_module_items(\n     cx: &mut DocContext<'_>,\n     did: DefId,\n-    visited: &mut FxHashSet<DefId>,\n+    visited: &mut DefIdSet,\n     inlined_names: &mut FxHashSet<(ItemType, Symbol)>,\n+    allowed_def_ids: Option<&DefIdSet>,\n ) -> Vec<clean::Item> {\n     let mut items = Vec::new();\n \n@@ -583,6 +590,11 @@ fn build_module_items(\n     for &item in cx.tcx.module_children(did).iter() {\n         if item.vis.is_public() {\n             let res = item.res.expect_non_local();\n+            if let Some(def_id) = res.opt_def_id()\n+                && let Some(allowed_def_ids) = allowed_def_ids\n+                && !allowed_def_ids.contains(&def_id) {\n+                continue;\n+            }\n             if let Some(def_id) = res.mod_def_id() {\n                 // If we're inlining a glob import, it's possible to have\n                 // two distinct modules with the same name. We don't want to"}, {"sha": "34a7068e5da53b84b75f5e5147027801a2fd9d36", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -15,7 +15,7 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet, IndexEntry};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LOCAL_CRATE};\n use rustc_hir::PredicateOrigin;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n@@ -1528,7 +1528,7 @@ fn maybe_expand_private_type_alias<'tcx>(\n     let hir::ItemKind::TyAlias(ty, generics) = alias else { return None };\n \n     let provided_params = &path.segments.last().expect(\"segments were empty\");\n-    let mut substs = FxHashMap::default();\n+    let mut substs = DefIdMap::default();\n     let generic_args = provided_params.args();\n \n     let mut indices: hir::GenericParamCount = Default::default();\n@@ -2321,7 +2321,7 @@ fn clean_extern_crate<'tcx>(\n \n     let krate_owner_def_id = krate.owner_id.to_def_id();\n     if please_inline {\n-        let mut visited = FxHashSet::default();\n+        let mut visited = DefIdSet::default();\n \n         let res = Res::Def(DefKind::Mod, crate_def_id);\n \n@@ -2440,8 +2440,9 @@ fn clean_use_statement_inner<'tcx>(\n     let path = clean_path(path, cx);\n     let inner = if kind == hir::UseKind::Glob {\n         if !denied {\n-            let mut visited = FxHashSet::default();\n-            if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited, inlined_names)\n+            let mut visited = DefIdSet::default();\n+            if let Some(items) =\n+                inline::try_inline_glob(cx, path.res, current_mod, &mut visited, inlined_names)\n             {\n                 return items;\n             }\n@@ -2458,7 +2459,7 @@ fn clean_use_statement_inner<'tcx>(\n             }\n         }\n         if !denied {\n-            let mut visited = FxHashSet::default();\n+            let mut visited = DefIdSet::default();\n             let import_def_id = import.owner_id.to_def_id();\n \n             if let Some(mut items) = inline::try_inline("}, {"sha": "dbbc25739aa078fa002422c3439b1376c6224283", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -46,7 +46,7 @@ pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> ThinVec<WP\n \n     // Look for equality predicates on associated types that can be merged into\n     // general bound predicates.\n-    equalities.retain(|&(ref lhs, ref rhs, ref bound_params)| {\n+    equalities.retain(|(lhs, rhs, bound_params)| {\n         let Some((ty, trait_did, name)) = lhs.projection() else { return true; };\n         let Some((bounds, _)) = tybounds.get_mut(ty) else { return true };\n         let bound_params = bound_params"}, {"sha": "10b606f425ea41fcd4839ff72fd0d95806428d04", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n use rustc_hir::def::{Namespace, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n+use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{HirId, Path, TraitCandidate};\n use rustc_interface::interface;\n@@ -60,11 +60,11 @@ pub(crate) struct DocContext<'tcx> {\n     pub(crate) external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n-    pub(crate) active_extern_traits: FxHashSet<DefId>,\n+    pub(crate) active_extern_traits: DefIdSet,\n     // The current set of parameter substitutions,\n     // for expanding type aliases at the HIR level:\n     /// Table `DefId` of type, lifetime, or const parameter -> substituted type, lifetime, or const\n-    pub(crate) substs: FxHashMap<DefId, clean::SubstParam>,\n+    pub(crate) substs: DefIdMap<clean::SubstParam>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n     pub(crate) impl_trait_bounds: FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n@@ -108,11 +108,7 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n-    pub(crate) fn enter_alias<F, R>(\n-        &mut self,\n-        substs: FxHashMap<DefId, clean::SubstParam>,\n-        f: F,\n-    ) -> R\n+    pub(crate) fn enter_alias<F, R>(&mut self, substs: DefIdMap<clean::SubstParam>, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n     {\n@@ -225,7 +221,6 @@ pub(crate) fn create_config(\n     // Add the doc cfg into the doc build.\n     cfgs.push(\"doc\".to_string());\n \n-    let cpath = Some(input.clone());\n     let input = Input::File(input);\n \n     // By default, rustdoc ignores all lints.\n@@ -277,7 +272,6 @@ pub(crate) fn create_config(\n         crate_cfg: interface::parse_cfgspecs(cfgs),\n         crate_check_cfg: interface::parse_check_cfg(check_cfgs),\n         input,\n-        input_path: cpath,\n         output_file: None,\n         output_dir: None,\n         file_loader: None,"}, {"sha": "c1a652c75f4a16a0999fface3e8d8f8db60752af", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0df0429c49bce88e9d81ead810804047ea26631/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=e0df0429c49bce88e9d81ead810804047ea26631", "patch": "@@ -95,7 +95,6 @@ pub(crate) fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n         crate_cfg: interface::parse_cfgspecs(cfgs),\n         crate_check_cfg: interface::parse_check_cfg(options.check_cfgs.clone()),\n         input,\n-        input_path: None,\n         output_file: None,\n         output_dir: None,\n         file_loader: None,"}]}