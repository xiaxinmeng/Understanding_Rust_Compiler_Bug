{"sha": "cb84844e83ee88684ef89cc02221a26abbf92530", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiODQ4NDRlODNlZTg4Njg0ZWY4OWNjMDIyMjFhMjZhYmJmOTI1MzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-18T14:21:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-18T14:21:07Z"}, "message": "Auto merge of #56160 - oli-obk:const_fn_let, r=nikomatsakis\n\nFix various aspects around `let` bindings inside const functions\n\n* forbid `let` bindings in const contexts that use short circuiting operators\n* harden analysis code against derefs of mutable references\n\nInitially this PR was about stabilizing `let` bindings, but too many flaws were exposed that need some more testing on nightly", "tree": {"sha": "390fa5470970618401fbb9abed17fa7eb513d35e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/390fa5470970618401fbb9abed17fa7eb513d35e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb84844e83ee88684ef89cc02221a26abbf92530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb84844e83ee88684ef89cc02221a26abbf92530", "html_url": "https://github.com/rust-lang/rust/commit/cb84844e83ee88684ef89cc02221a26abbf92530", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb84844e83ee88684ef89cc02221a26abbf92530/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "041254b81495a5aa67af839e00b890e78ed0cbeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/041254b81495a5aa67af839e00b890e78ed0cbeb", "html_url": "https://github.com/rust-lang/rust/commit/041254b81495a5aa67af839e00b890e78ed0cbeb"}, {"sha": "d815e2b870793e8793900be0aeb8ccaf5e4c7291", "url": "https://api.github.com/repos/rust-lang/rust/commits/d815e2b870793e8793900be0aeb8ccaf5e4c7291", "html_url": "https://github.com/rust-lang/rust/commit/d815e2b870793e8793900be0aeb8ccaf5e4c7291"}], "stats": {"total": 1217, "additions": 1085, "deletions": 132}, "files": [{"sha": "c8ad38c52dbe9128facf69f518bc0cd41086428c", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -121,7 +121,6 @@\n #![feature(const_slice_len)]\n #![feature(const_str_as_bytes)]\n #![feature(const_str_len)]\n-#![feature(const_let)]\n #![feature(const_int_rotate)]\n #![feature(const_int_wrapping)]\n #![feature(const_int_sign)]"}, {"sha": "9dff3277917be14134be79dcf017feba80e3dfa4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -149,6 +149,14 @@ pub struct Mir<'tcx> {\n     /// This is used for the \"rust-call\" ABI.\n     pub spread_arg: Option<Local>,\n \n+    /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n+    /// `||` expression into `&` or `|` respectively. This is problematic because if we ever stop\n+    /// this conversion from happening and use short circuiting, we will cause the following code\n+    /// to change the value of `x`: `let mut x = 42; false && { x = 55; true };`\n+    ///\n+    /// List of places where control flow was destroyed. Used for error reporting.\n+    pub control_flow_destroyed: Vec<(Span, String)>,\n+\n     /// A span representing this MIR, for error reporting\n     pub span: Span,\n \n@@ -167,6 +175,7 @@ impl<'tcx> Mir<'tcx> {\n         arg_count: usize,\n         upvar_decls: Vec<UpvarDecl>,\n         span: Span,\n+        control_flow_destroyed: Vec<(Span, String)>,\n     ) -> Self {\n         // We need `arg_count` locals, and one for the return place\n         assert!(\n@@ -191,6 +200,7 @@ impl<'tcx> Mir<'tcx> {\n             spread_arg: None,\n             span,\n             cache: cache::Cache::new(),\n+            control_flow_destroyed,\n         }\n     }\n \n@@ -421,6 +431,7 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     arg_count,\n     upvar_decls,\n     spread_arg,\n+    control_flow_destroyed,\n     span,\n     cache\n });\n@@ -1748,6 +1759,9 @@ pub enum StatementKind<'tcx> {\n     /// (e.g., inspecting constants and discriminant values), and the\n     /// kind of pattern it comes from. This is in order to adapt potential\n     /// error messages to these specific patterns.\n+    ///\n+    /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n+    /// never accessed still get some sanity checks for e.g. `let x: ! = ..;`\n     FakeRead(FakeReadCause, Place<'tcx>),\n \n     /// Write the discriminant for a variant to the enum Place.\n@@ -2984,6 +2998,7 @@ BraceStructTypeFoldableImpl! {\n         arg_count,\n         upvar_decls,\n         spread_arg,\n+        control_flow_destroyed,\n         span,\n         cache,\n     }"}, {"sha": "1d28c4fa114ef2fbc8d29b839d41f80d8317df10", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -35,6 +35,7 @@ CloneTypeFoldableAndLiftImpls! {\n     usize,\n     ::ty::layout::VariantIdx,\n     u64,\n+    String,\n     ::middle::region::Scope,\n     ::syntax::ast::FloatTy,\n     ::syntax::ast::NodeId,"}, {"sha": "d6af125debf8ec956ac4373a7dd91076c39e25b2", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -849,15 +849,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        Mir::new(self.cfg.basic_blocks,\n-                 self.source_scopes,\n-                 ClearCrossCrate::Set(self.source_scope_local_data),\n-                 IndexVec::new(),\n-                 yield_ty,\n-                 self.local_decls,\n-                 self.arg_count,\n-                 self.upvar_decls,\n-                 self.fn_span\n+        Mir::new(\n+            self.cfg.basic_blocks,\n+            self.source_scopes,\n+            ClearCrossCrate::Set(self.source_scope_local_data),\n+            IndexVec::new(),\n+            yield_ty,\n+            self.local_decls,\n+            self.arg_count,\n+            self.upvar_decls,\n+            self.fn_span,\n+            self.hir.control_flow_destroyed(),\n         )\n     }\n "}, {"sha": "f93dbce97b54a6f47fb6cd74969b726433c9b385", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -372,13 +372,21 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     // FIXME(eddyb) use logical ops in constants when\n                     // they can handle that kind of control-flow.\n                     (hir::BinOpKind::And, hir::Constness::Const) => {\n+                        cx.control_flow_destroyed.push((\n+                            op.span,\n+                            \"`&&` operator\".into(),\n+                        ));\n                         ExprKind::Binary {\n                             op: BinOp::BitAnd,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n                     (hir::BinOpKind::Or, hir::Constness::Const) => {\n+                        cx.control_flow_destroyed.push((\n+                            op.span,\n+                            \"`||` operator\".into(),\n+                        ));\n                         ExprKind::Binary {\n                             op: BinOp::BitOr,\n                             lhs: lhs.to_ref(),"}, {"sha": "5d8732bb8aee8dcf1d474a212eab6387b99c4ad3", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -56,6 +56,9 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n     /// True if this constant/function needs overflow checks.\n     check_overflow: bool,\n+\n+    /// See field with the same name on `Mir`\n+    control_flow_destroyed: Vec<(Span, String)>,\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n@@ -96,9 +99,13 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             constness,\n             body_owner_kind,\n             check_overflow,\n+            control_flow_destroyed: Vec::new(),\n         }\n     }\n \n+    pub fn control_flow_destroyed(self) -> Vec<(Span, String)> {\n+        self.control_flow_destroyed\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {"}, {"sha": "2728833251ac2f6dbd185c00bd79751ad50f3d31", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -219,7 +219,8 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         local_decls_for_sig(&sig, span),\n         sig.inputs().len(),\n         vec![],\n-        span\n+        span,\n+        vec![],\n     );\n \n     if let Some(..) = ty {\n@@ -396,7 +397,8 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             self.local_decls,\n             self.sig.inputs().len(),\n             vec![],\n-            self.span\n+            self.span,\n+            vec![],\n         )\n     }\n \n@@ -844,7 +846,8 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         local_decls,\n         sig.inputs().len(),\n         vec![],\n-        span\n+        span,\n+        vec![],\n     );\n     if let Abi::RustCall = sig.abi {\n         mir.spread_arg = Some(Local::new(sig.inputs().len()));\n@@ -921,6 +924,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         local_decls,\n         sig.inputs().len(),\n         vec![],\n-        span\n+        span,\n+        vec![],\n     )\n }"}, {"sha": "f5bf73b4300acc0955c78c1246c9194b91d2c648", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -412,7 +412,8 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 initial_locals,\n                 0,\n                 vec![],\n-                mir.span\n+                mir.span,\n+                vec![],\n             ),\n             tcx,\n             source: mir,"}, {"sha": "58a3cb97e4156470fbf715e57063a5f9d779d64d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -553,7 +553,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     this.super_place(place, context, location);\n                     match proj.elem {\n                         ProjectionElem::Deref => {\n-                            this.add(Qualif::NOT_CONST);\n+                            if context.is_mutating_use() {\n+                                // `not_const` errors out in const contexts\n+                                this.not_const()\n+                            } else {\n+                                // just make sure this doesn't get promoted\n+                                this.add(Qualif::NOT_CONST);\n+                            }\n                             let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n                             match this.mode {\n                                 Mode::Fn => {},\n@@ -1178,7 +1184,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             if self.mir.local_kind(index) == LocalKind::Var &&\n                self.const_fn_arg_vars.insert(index) &&\n                !self.tcx.features().const_let {\n-\n                 // Direct use of an argument is permitted.\n                 match *rvalue {\n                     Rvalue::Use(Operand::Copy(Place::Local(local))) |\n@@ -1189,7 +1194,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n                     _ => {}\n                 }\n-\n                 // Avoid a generic error for other uses of arguments.\n                 if self.qualif.contains(Qualif::FN_ARGUMENT) {\n                     let decl = &self.mir.local_decls[index];\n@@ -1348,6 +1352,37 @@ impl MirPass for QualifyAndPromoteConstants {\n             // Do the actual promotion, now that we know what's viable.\n             promote_consts::promote_candidates(mir, tcx, temps, candidates);\n         } else {\n+            if !mir.control_flow_destroyed.is_empty() {\n+                let mut locals = mir.vars_iter();\n+                if let Some(local) = locals.next() {\n+                    let span = mir.local_decls[local].source_info.span;\n+                    let mut error = tcx.sess.struct_span_err(\n+                        span,\n+                        &format!(\n+                            \"new features like let bindings are not permitted in {}s \\\n+                            which also use short circuiting operators\",\n+                            mode,\n+                        ),\n+                    );\n+                    for (span, kind) in mir.control_flow_destroyed.iter() {\n+                        error.span_note(\n+                            *span,\n+                            &format!(\"use of {} here does not actually short circuit due to \\\n+                            the const evaluator presently not being able to do control flow. \\\n+                            See https://github.com/rust-lang/rust/issues/49146 for more \\\n+                            information.\", kind),\n+                        );\n+                    }\n+                    for local in locals {\n+                        let span = mir.local_decls[local].source_info.span;\n+                        error.span_note(\n+                            span,\n+                            \"more locals defined here\",\n+                        );\n+                    }\n+                    error.emit();\n+                }\n+            }\n             let promoted_temps = if mode == Mode::Const {\n                 // Already computed by `mir_const_qualif`.\n                 const_promoted_temps.unwrap()"}, {"sha": "eee167c3579370a2df560a395c57b0ca67dd8857", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -230,7 +230,7 @@ fn check_statement(\n             check_rvalue(tcx, mir, rval, span)\n         }\n \n-        StatementKind::FakeRead(..) => Err((span, \"match in const fn is unstable\".into())),\n+        StatementKind::FakeRead(_, place) => check_place(tcx, mir, place, span, PlaceMode::Read),\n \n         // just an assignment\n         StatementKind::SetDiscriminant { .. } => Ok(()),"}, {"sha": "397bc7efd633c8541568c482bf62c41603cdd3a7", "filename": "src/test/compile-fail/const-fn-error.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(const_fn)]\n+#![feature(const_fn, const_let)]\n \n const X : usize = 2;\n \n const fn f(x: usize) -> usize {\n     let mut sum = 0;\n-    //~^ let bindings in constant functions are unstable\n-    //~| statements in constant functions are unstable\n     for i in 0..x {\n         //~^ ERROR E0015\n         //~| ERROR E0019"}, {"sha": "88f0d0714f9a1a66d08dbdaff8b85d61608b354a", "filename": "src/test/run-pass/ctfe/const-fn-destructuring-arg.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Ftest%2Frun-pass%2Fctfe%2Fconst-fn-destructuring-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/041254b81495a5aa67af839e00b890e78ed0cbeb/src%2Ftest%2Frun-pass%2Fctfe%2Fconst-fn-destructuring-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fconst-fn-destructuring-arg.rs?ref=041254b81495a5aa67af839e00b890e78ed0cbeb", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// run-pass\n-#![allow(dead_code)]\n-\n-// test that certain things are disallowed in constant functions\n-\n-#![feature(const_fn, const_let)]\n-\n-// no destructuring\n-const fn i((\n-            a,\n-            b\n-           ): (u32, u32)) -> u32 {\n-    a + b\n-}\n-\n-fn main() {}"}, {"sha": "63e5bcccf5d3488a3e7e10d8c523d541cfcac7a7", "filename": "src/test/ui/consts/const-eval/assign-to-static-within-other-static-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static-2.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -24,7 +24,7 @@ unsafe impl Sync for Foo {}\n static FOO: Foo = Foo(UnsafeCell::new(42));\n \n static BAR: () = unsafe {\n-    *FOO.0.get() = 5; //~ ERROR could not evaluate static initializer\n+    *FOO.0.get() = 5; //~ ERROR contains unimplemented expression type\n };\n \n fn main() {}"}, {"sha": "740954c6c66239bf92bda010b1e9c4645eeec5ae", "filename": "src/test/ui/consts/const-eval/assign-to-static-within-other-static-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fassign-to-static-within-other-static-2.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -1,9 +1,9 @@\n-error[E0080]: could not evaluate static initializer\n+error[E0019]: static contains unimplemented expression type\n   --> $DIR/assign-to-static-within-other-static-2.rs:27:5\n    |\n-LL |     *FOO.0.get() = 5; //~ ERROR could not evaluate static initializer\n-   |     ^^^^^^^^^^^^^^^^ tried to modify a static's initial value from another static's initializer\n+LL |     *FOO.0.get() = 5; //~ ERROR contains unimplemented expression type\n+   |     ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`.\n+For more information about this error, try `rustc --explain E0019`."}, {"sha": "6c2fdcc8615c893f89b60507b675c212268cb1bf", "filename": "src/test/ui/consts/const-eval/mod-static-with-const-fn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -27,9 +27,7 @@ fn foo() {}\n \n static BAR: () = unsafe {\n     *FOO.0.get() = 5;\n-    // we do not error on the above access, because that is not detectable statically. Instead,\n-    // const evaluation will error when trying to evaluate it. Due to the error below, we never even\n-    // attempt to const evaluate `BAR`, so we don't see the error\n+    //~^ contains unimplemented expression\n \n     foo();\n     //~^ ERROR calls in statics are limited to constant functions, tuple structs and tuple variants"}, {"sha": "49b39e2f5c6c933b115e25ec314cdec2a5ccf475", "filename": "src/test/ui/consts/const-eval/mod-static-with-const-fn.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmod-static-with-const-fn.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -1,9 +1,16 @@\n+error[E0019]: static contains unimplemented expression type\n+  --> $DIR/mod-static-with-const-fn.rs:29:5\n+   |\n+LL |     *FOO.0.get() = 5;\n+   |     ^^^^^^^^^^^^^^^^\n+\n error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/mod-static-with-const-fn.rs:34:5\n+  --> $DIR/mod-static-with-const-fn.rs:32:5\n    |\n LL |     foo();\n    |     ^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors occurred: E0015, E0019.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "2f7e2ecaa4e40085336a7db5dc67b05d65e948bc", "filename": "src/test/ui/consts/const-fn-not-safe-for-const.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -37,15 +37,13 @@ const fn get_Y_addr() -> &'static u32 {\n }\n \n const fn get() -> u32 {\n-    let x = 22;\n-    //~^ ERROR let bindings in constant functions are unstable\n-    //~| ERROR statements in constant functions are unstable\n-    let y = 44;\n-    //~^ ERROR let bindings in constant functions are unstable\n-    //~| ERROR statements in constant functions are unstable\n+    let x = 22; //~ ERROR let bindings in constant functions are unstable\n+//~^ ERROR statements in constant functions\n+    let y = 44; //~ ERROR let bindings in constant functions are unstable\n+//~^ ERROR statements in constant functions\n     x + y\n-    //~^ ERROR let bindings in constant functions are unstable\n-    //~| ERROR let bindings in constant functions are unstable\n+//~^ ERROR let bindings in constant functions are unstable\n+//~| ERROR let bindings in constant functions are unstable\n }\n \n fn main() {}"}, {"sha": "1a8c5f558a212a305e8f49a908f55223e1bfa6a1", "filename": "src/test/ui/consts/const-fn-not-safe-for-const.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -19,45 +19,45 @@ LL |     &Y\n error[E0658]: let bindings in constant functions are unstable (see issue #48821)\n   --> $DIR/const-fn-not-safe-for-const.rs:40:13\n    |\n-LL |     let x = 22;\n+LL |     let x = 22; //~ ERROR let bindings in constant functions are unstable\n    |             ^^\n    |\n    = help: add #![feature(const_let)] to the crate attributes to enable\n \n error[E0658]: statements in constant functions are unstable (see issue #48821)\n   --> $DIR/const-fn-not-safe-for-const.rs:40:13\n    |\n-LL |     let x = 22;\n+LL |     let x = 22; //~ ERROR let bindings in constant functions are unstable\n    |             ^^\n    |\n    = help: add #![feature(const_let)] to the crate attributes to enable\n \n error[E0658]: let bindings in constant functions are unstable (see issue #48821)\n-  --> $DIR/const-fn-not-safe-for-const.rs:43:13\n+  --> $DIR/const-fn-not-safe-for-const.rs:42:13\n    |\n-LL |     let y = 44;\n+LL |     let y = 44; //~ ERROR let bindings in constant functions are unstable\n    |             ^^\n    |\n    = help: add #![feature(const_let)] to the crate attributes to enable\n \n error[E0658]: statements in constant functions are unstable (see issue #48821)\n-  --> $DIR/const-fn-not-safe-for-const.rs:43:13\n+  --> $DIR/const-fn-not-safe-for-const.rs:42:13\n    |\n-LL |     let y = 44;\n+LL |     let y = 44; //~ ERROR let bindings in constant functions are unstable\n    |             ^^\n    |\n    = help: add #![feature(const_let)] to the crate attributes to enable\n \n error[E0658]: let bindings in constant functions are unstable (see issue #48821)\n-  --> $DIR/const-fn-not-safe-for-const.rs:46:5\n+  --> $DIR/const-fn-not-safe-for-const.rs:44:5\n    |\n LL |     x + y\n    |     ^\n    |\n    = help: add #![feature(const_let)] to the crate attributes to enable\n \n error[E0658]: let bindings in constant functions are unstable (see issue #48821)\n-  --> $DIR/const-fn-not-safe-for-const.rs:46:9\n+  --> $DIR/const-fn-not-safe-for-const.rs:44:9\n    |\n LL |     x + y\n    |         ^"}, {"sha": "c2ed6cd85ab5c176b795a4ad4d8eba8453cbd8da", "filename": "src/test/ui/consts/const_let_assign3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -8,6 +8,7 @@ struct S {\n impl S {\n     const fn foo(&mut self, x: u32) {\n         self.state = x;\n+        //~^ contains unimplemented expression\n     }\n }\n "}, {"sha": "0f294616d255c3f73c7eba1f3b2687a53702427e", "filename": "src/test/ui/consts/const_let_assign3.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -1,9 +1,16 @@\n+error[E0019]: constant function contains unimplemented expression type\n+  --> $DIR/const_let_assign3.rs:10:9\n+   |\n+LL |         self.state = x;\n+   |         ^^^^^^^^^^^^^^\n+\n error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/const_let_assign3.rs:16:5\n+  --> $DIR/const_let_assign3.rs:17:5\n    |\n LL |     s.foo(3); //~ ERROR references in constants may only refer to immutable values\n    |     ^ constants require immutable values\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0017`.\n+Some errors occurred: E0017, E0019.\n+For more information about an error, try `rustc --explain E0017`."}, {"sha": "8739cb80e9403cf6d780d51f9d01931f8b9ca511", "filename": "src/test/ui/consts/const_let_eq.rs", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -0,0 +1,470 @@\n+#![feature(const_let, const_fn)]\n+\n+// run-pass\n+\n+struct Foo<T>(T);\n+struct Bar<T> { x: T }\n+struct W(u32);\n+struct A { a: u32 }\n+\n+const fn basics((a,): (u32,)) -> u32 {\n+    // Deferred assignment:\n+    let b: u32;\n+    b = a + 1;\n+\n+    // Immediate assignment:\n+    let c: u32 = b + 1;\n+\n+    // Mutables:\n+    let mut d: u32 = c + 1;\n+    d = d + 1;\n+    // +4 so far.\n+\n+    // No effect statements work:\n+    ; ;\n+    1;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [0];\n+    arr[0] = 1;\n+    d = d + arr[0];\n+    // +5\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(0);\n+    let mut bar: Bar<u32> = Bar { x: 0 };\n+    foo.0 = 1;\n+    bar.x = 1;\n+    d = d + foo.0 + bar.x;\n+    // +7\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(0)];\n+    arr[0].0 = 1;\n+    d = d + arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 0 }];\n+    arr[0].x = 1;\n+    d = d + arr[0].x;\n+    // +9\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([0]);\n+    (arr.0)[0] = 1;\n+    d = d + (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [0] };\n+    arr.x[0] = 1;\n+    d = d + arr.x[0];\n+    // +11\n+\n+    d\n+}\n+\n+const fn add_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a + 1;\n+    d += 1;\n+    // +2 so far.\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [0];\n+    arr[0] += 1;\n+    d += arr[0];\n+    // +3\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(0);\n+    let mut bar: Bar<u32> = Bar { x: 0 };\n+    foo.0 += 1;\n+    bar.x += 1;\n+    d += foo.0 + bar.x;\n+    // +5\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(0)];\n+    arr[0].0 += 1;\n+    d += arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 0 }];\n+    arr[0].x += 1;\n+    d += arr[0].x;\n+    // +7\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([0]);\n+    (arr.0)[0] += 1;\n+    d += (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [0] };\n+    arr.x[0] += 1;\n+    d += arr.x[0];\n+    // +9\n+\n+    d\n+}\n+\n+const fn mul_assign(A { a }: A) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a + 1;\n+    d *= 2;\n+    // 2^1 * (a + 1)\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [1];\n+    arr[0] *= 2;\n+    d *= arr[0];\n+    // 2^2 * (a + 1)\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(1);\n+    let mut bar: Bar<u32> = Bar { x: 1 };\n+    foo.0 *= 2;\n+    bar.x *= 2;\n+    d *= foo.0 + bar.x;\n+    // 2^4 * (a + 1)\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(1)];\n+    arr[0].0 *= 2;\n+    d *= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 1 }];\n+    arr[0].x *= 2;\n+    d *= arr[0].x;\n+    // 2^6 * (a + 1)\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([1]);\n+    (arr.0)[0] *= 2;\n+    d *= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [1] };\n+    arr.x[0] *= 2;\n+    d *= arr.x[0];\n+    // 2^8 * (a + 1)\n+\n+    d\n+}\n+\n+const fn div_assign(a: [u32; 1]) -> u32 {\n+    let a = a[0];\n+    // Mutables:\n+    let mut d: u32 = 1024 * a;\n+    d /= 2;\n+    // 512\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [4];\n+    arr[0] /= 2;\n+    d /= arr[0];\n+    // 256\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(4);\n+    let mut bar: Bar<u32> = Bar { x: 4 };\n+    foo.0 /= 2;\n+    bar.x /= 2;\n+    d /= foo.0;\n+    d /= bar.x;\n+    // 64\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(4)];\n+    arr[0].0 /= 2;\n+    d /= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 4 }];\n+    arr[0].x /= 2;\n+    d /= arr[0].x;\n+    // 16\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([4]);\n+    (arr.0)[0] /= 2;\n+    d /= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [4] };\n+    arr.x[0] /= 2;\n+    d /= arr.x[0];\n+    // 4\n+\n+    d\n+}\n+\n+const fn rem_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d %= 10;\n+    d += 10;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [3];\n+    arr[0] %= 2;\n+    d %= 9 + arr[0];\n+    d += 10;\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(5);\n+    let mut bar: Bar<u32> = Bar { x: 7 };\n+    foo.0 %= 2;\n+    bar.x %= 2;\n+    d %= 8 + foo.0 + bar.x;\n+    d += 10;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(4)];\n+    arr[0].0 %= 3;\n+    d %= 9 + arr[0].0;\n+    d += 10;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 7 }];\n+    arr[0].x %= 3;\n+    d %= 9 + arr[0].x;\n+    d += 10;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([6]);\n+    (arr.0)[0] %= 5;\n+    d %= 9 + (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [11] };\n+    arr.x[0] %= 5;\n+    d %= 9 + arr.x[0];\n+\n+    d\n+}\n+\n+const fn sub_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d -= 1;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [2];\n+    arr[0] -= 1;\n+    d -= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(2);\n+    let mut bar: Bar<u32> = Bar { x: 2 };\n+    foo.0 -= 1;\n+    bar.x -= 1;\n+    d -= foo.0 + bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(2)];\n+    arr[0].0 -= 1;\n+    d -= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 2 }];\n+    arr[0].x -= 1;\n+    d -= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([2]);\n+    (arr.0)[0] -= 1;\n+    d -= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [2] };\n+    arr.x[0] -= 1;\n+    d -= arr.x[0];\n+\n+    d\n+}\n+\n+const fn shl_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d <<= 1; // 10\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [1];\n+    arr[0] <<= 1;\n+    d <<= arr[0]; // 10 << 2\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(1);\n+    let mut bar: Bar<u32> = Bar { x: 1 };\n+    foo.0 <<= 1;\n+    bar.x <<= 1;\n+    d <<= foo.0 + bar.x; // 1000 << 4\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(1)];\n+    arr[0].0 <<= 1;\n+    d <<= arr[0].0; // 1000_0000 << 2\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 1 }];\n+    arr[0].x <<= 1;\n+    d <<= arr[0].x; // 1000_0000_00 << 2\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([1]);\n+    (arr.0)[0] <<= 1;\n+    d <<= (arr.0)[0]; // 1000_0000_0000 << 2\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [1] };\n+    arr.x[0] <<= 1;\n+    d <<= arr.x[0]; // 1000_0000_0000_00 << 2\n+\n+    d\n+}\n+\n+const fn shr_assign(W(a): W) -> u32 {\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d >>= 1; // /= 2\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [2];\n+    arr[0] >>= 1;\n+    d >>= arr[0]; // /= 4\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(2);\n+    let mut bar: Bar<u32> = Bar { x: 2 };\n+    foo.0 >>= 1;\n+    bar.x >>= 1;\n+    d >>= foo.0 + bar.x; // /= 16\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(2)];\n+    arr[0].0 >>= 1;\n+    d >>= arr[0].0; // /= 32\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: 2 }];\n+    arr[0].x >>= 1;\n+    d >>= arr[0].x; // /= 64\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([2]);\n+    (arr.0)[0] >>= 1;\n+    d >>= (arr.0)[0]; // /= 128\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [2] };\n+    arr.x[0] >>= 1;\n+    d >>= arr.x[0]; // /= 256\n+\n+    d\n+}\n+\n+const fn bit_and_assign(W(a): W) -> u32 {\n+    let f = 0b1111_1111_1111_1111;\n+\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d &= 0b1111_1111_1111_1110;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [f];\n+    arr[0] &= 0b1111_1111_1111_1101;\n+    d &= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(f);\n+    let mut bar: Bar<u32> = Bar { x: f };\n+    foo.0 &= 0b1111_1111_1111_0111;\n+    bar.x &= 0b1111_1111_1101_1111;\n+    d &= foo.0 & bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(f)];\n+    arr[0].0 &= 0b1111_1110_1111_1111;\n+    d &= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: f }];\n+    arr[0].x &= 0b1111_1101_1111_1111;\n+    d &= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([f]);\n+    (arr.0)[0] &= 0b1011_1111_1111_1111;\n+    d &= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [f] };\n+    arr.x[0] &= 0b0111_1111_1111_1111;\n+    d &= arr.x[0];\n+\n+    d\n+}\n+\n+const fn bit_or_assign(W(a): W) -> u32 {\n+    let f = 0b0000_0000_0000_0000;\n+\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d |= 0b0000_0000_0000_0001;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [f];\n+    arr[0] |= 0b0000_0000_0000_1001;\n+    d |= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(f);\n+    let mut bar: Bar<u32> = Bar { x: f };\n+    foo.0 |= 0b0000_0000_0001_0000;\n+    bar.x |= 0b0000_0000_0100_0000;\n+    d |= foo.0 | bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(f)];\n+    arr[0].0 |= 0b0000_0001_0000_0000;\n+    d |= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: f }];\n+    arr[0].x |= 0b0000_0010_0000_0000;\n+    d |= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([f]);\n+    (arr.0)[0] |= 0b1000_0000_0000_0000;\n+    d |= (arr.0)[0]; // /= 128\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [f] };\n+    arr.x[0] |= 0b1100_0000_0000_0000;\n+    d |= arr.x[0]; // /= 256\n+\n+    d\n+}\n+\n+const fn bit_xor_assign(W(a): W) -> u32 {\n+    let f = 0b0000_0000_0000_0000;\n+\n+    // Mutables:\n+    let mut d: u32 = a;\n+    d ^= 0b0000_0000_0000_0001;\n+\n+    // Array projection\n+    let mut arr: [u32; 1] = [f];\n+    arr[0] ^= 0b0000_0000_0000_0010;\n+    d ^= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<u32> = Foo(f);\n+    let mut bar: Bar<u32> = Bar { x: f };\n+    foo.0 ^= 0b0000_0000_0001_0000;\n+    bar.x ^= 0b0000_0000_1000_0000;\n+    d ^= foo.0 ^ bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<u32>; 1] = [Foo(f)];\n+    arr[0].0 ^= 0b0000_0001_0000_0000;\n+    d ^= arr[0].0;\n+    let mut arr: [Bar<u32>; 1] = [Bar { x: f }];\n+    arr[0].x ^= 0b0000_0010_0000_0000;\n+    d ^= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[u32; 1]> = Foo([f]);\n+    (arr.0)[0] ^= 0b0100_0000_0000_0000;\n+    d ^= (arr.0)[0];\n+    let mut arr: Bar<[u32; 1]> = Bar { x: [f] };\n+    arr.x[0] ^= 0b1000_0000_0000_0000;\n+    d ^= arr.x[0];\n+\n+    d\n+}\n+\n+macro_rules! test {\n+    ($c:ident, $e:expr, $r:expr) => {\n+        const $c: u32 = $e;\n+        assert_eq!($c, $r);\n+        assert_eq!($e, $r);\n+    }\n+}\n+\n+fn main() {\n+    test!(BASICS, basics((2,)), 13);\n+    test!(ADD, add_assign(W(1)), 10);\n+    test!(MUL, mul_assign(A { a: 0 }), 256);\n+    test!(DIV, div_assign([1]), 4);\n+    test!(REM, rem_assign(W(5)), 5);\n+    test!(SUB, sub_assign(W(8)), 0);\n+    test!(SHL, shl_assign(W(1)), 0b1000_0000_0000_0000);\n+    test!(SHR, shr_assign(W(256)), 1);\n+    test!(AND, bit_and_assign(W(0b1011_1111_1111_1111_1111)), 0b0011_1100_1101_0100);\n+    test!(OR, bit_or_assign(W(0b1011_0000_0000_0000)), 0b1111_0011_0101_1001);\n+    test!(XOR, bit_xor_assign(W(0b0000_0000_0000_0000)), 0b1100_0011_1001_0011);\n+}"}, {"sha": "2c7262df367a399d9a10d1ccfc592519c41a7f22", "filename": "src/test/ui/consts/const_let_eq_float.rs", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_eq_float.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -0,0 +1,279 @@\n+// compile-pass\n+\n+#![feature(const_let, const_fn)]\n+\n+struct Foo<T>(T);\n+struct Bar<T> { x: T }\n+struct W(f32);\n+struct A { a: f32 }\n+\n+const fn basics((a,): (f32,)) -> f32 {\n+    // Deferred assignment:\n+    let b: f32;\n+    b = a + 1.0;\n+\n+    // Immediate assignment:\n+    let c: f32 = b + 1.0;\n+\n+    // Mutables:\n+    let mut d: f32 = c + 1.0;\n+    d = d + 1.0;\n+    // +4 so far.\n+\n+    // No effect statements work:\n+    ; ;\n+    1;\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [0.0];\n+    arr[0] = 1.0;\n+    d = d + arr[0];\n+    // +5\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(0.0);\n+    let mut bar: Bar<f32> = Bar { x: 0.0 };\n+    foo.0 = 1.0;\n+    bar.x = 1.0;\n+    d = d + foo.0 + bar.x;\n+    // +7\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(0.0)];\n+    arr[0].0 = 1.0;\n+    d = d + arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 0.0 }];\n+    arr[0].x = 1.0;\n+    d = d + arr[0].x;\n+    // +9\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([0.0]);\n+    (arr.0)[0] = 1.0;\n+    d = d + (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [0.0] };\n+    arr.x[0] = 1.0;\n+    d = d + arr.x[0];\n+    // +11\n+\n+    d\n+}\n+\n+const fn add_assign(W(a): W) -> f32 {\n+    // Mutables:\n+    let mut d: f32 = a + 1.0;\n+    d += 1.0;\n+    // +2 so far.\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [0.0];\n+    arr[0] += 1.0;\n+    d += arr[0];\n+    // +3\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(0.0);\n+    let mut bar: Bar<f32> = Bar { x: 0.0 };\n+    foo.0 += 1.0;\n+    bar.x += 1.0;\n+    d += foo.0 + bar.x;\n+    // +5\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(0.0)];\n+    arr[0].0 += 1.0;\n+    d += arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 0.0 }];\n+    arr[0].x += 1.0;\n+    d += arr[0].x;\n+    // +7\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([0.0]);\n+    (arr.0)[0] += 1.0;\n+    d += (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [0.0] };\n+    arr.x[0] += 1.0;\n+    d += arr.x[0];\n+    // +9\n+\n+    d\n+}\n+\n+const fn mul_assign(A { a }: A) -> f32 {\n+    // Mutables:\n+    let mut d: f32 = a + 1.0;\n+    d *= 2.0;\n+    // 2^1 * (a + 1)\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [1.0];\n+    arr[0] *= 2.0;\n+    d *= arr[0];\n+    // 2^2 * (a + 1)\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(1.0);\n+    let mut bar: Bar<f32> = Bar { x: 1.0 };\n+    foo.0 *= 2.0;\n+    bar.x *= 2.0;\n+    d *= foo.0 + bar.x;\n+    // 2^4 * (a + 1)\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(1.0)];\n+    arr[0].0 *= 2.0;\n+    d *= arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 1.0 }];\n+    arr[0].x *= 2.0;\n+    d *= arr[0].x;\n+    // 2^6 * (a + 1)\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([1.0]);\n+    (arr.0)[0] *= 2.0;\n+    d *= (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [1.0] };\n+    arr.x[0] *= 2.0;\n+    d *= arr.x[0];\n+    // 2^8 * (a + 1)\n+\n+    d\n+}\n+\n+const fn div_assign(a: [f32; 1]) -> f32 {\n+    let a = a[0];\n+    // Mutables:\n+    let mut d: f32 = 1024.0 * a;\n+    d /= 2.0;\n+    // 512\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [4.0];\n+    arr[0] /= 2.0;\n+    d /= arr[0];\n+    // 256\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(4.0);\n+    let mut bar: Bar<f32> = Bar { x: 4.0 };\n+    foo.0 /= 2.0;\n+    bar.x /= 2.0;\n+    d /= foo.0;\n+    d /= bar.x;\n+    // 64\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(4.0)];\n+    arr[0].0 /= 2.0;\n+    d /= arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 4.0 }];\n+    arr[0].x /= 2.0;\n+    d /= arr[0].x;\n+    // 16\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([4.0]);\n+    (arr.0)[0] /= 2.0;\n+    d /= (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [4.0] };\n+    arr.x[0] /= 2.0;\n+    d /= arr.x[0];\n+    // 4\n+\n+    d\n+}\n+\n+const fn rem_assign(W(a): W) -> f32 {\n+    // Mutables:\n+    let mut d: f32 = a;\n+    d %= 10.0;\n+    d += 10.0;\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [3.0];\n+    arr[0] %= 2.0;\n+    d %= 9.0 + arr[0];\n+    d += 10.0;\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(5.0);\n+    let mut bar: Bar<f32> = Bar { x: 7.0 };\n+    foo.0 %= 2.0;\n+    bar.x %= 2.0;\n+    d %= 8.0 + foo.0 + bar.x;\n+    d += 10.0;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(4.0)];\n+    arr[0].0 %= 3.0;\n+    d %= 9.0 + arr[0].0;\n+    d += 10.0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 7.0 }];\n+    arr[0].x %= 3.0;\n+    d %= 9.0 + arr[0].x;\n+    d += 10.0;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([6.0]);\n+    (arr.0)[0] %= 5.0;\n+    d %= 9.0 + (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [11.0] };\n+    arr.x[0] %= 5.0;\n+    d %= 9.0 + arr.x[0];\n+\n+    d\n+}\n+\n+const fn sub_assign(W(a): W) -> f32 {\n+    // Mutables:\n+    let mut d: f32 = a;\n+    d -= 1.0;\n+\n+    // Array projection\n+    let mut arr: [f32; 1] = [2.0];\n+    arr[0] -= 1.0;\n+    d -= arr[0];\n+\n+    // Field projection:\n+    let mut foo: Foo<f32> = Foo(2.0);\n+    let mut bar: Bar<f32> = Bar { x: 2.0 };\n+    foo.0 -= 1.0;\n+    bar.x -= 1.0;\n+    d -= foo.0 + bar.x;\n+\n+    // Array + Field projection:\n+    let mut arr: [Foo<f32>; 1] = [Foo(2.0)];\n+    arr[0].0 -= 1.0;\n+    d -= arr[0].0;\n+    let mut arr: [Bar<f32>; 1] = [Bar { x: 2.0 }];\n+    arr[0].x -= 1.0;\n+    d -= arr[0].x;\n+\n+    // Field + Array projection:\n+    let mut arr: Foo<[f32; 1]> = Foo([2.0]);\n+    (arr.0)[0] -= 1.0;\n+    d -= (arr.0)[0];\n+    let mut arr: Bar<[f32; 1]> = Bar { x: [2.0] };\n+    arr.x[0] -= 1.0;\n+    d -= arr.x[0];\n+\n+    d\n+}\n+\n+macro_rules! test {\n+    ($c:ident, $e:expr, $r:expr) => {\n+        const $c: f32 = $e;\n+        assert_eq!($c, $r);\n+        assert_eq!($e, $r);\n+    }\n+}\n+\n+fn main() {\n+    test!(BASICS, basics((2.0,)), 13.0);\n+    test!(ADD, add_assign(W(1.0)), 10.0);\n+    test!(MUL, mul_assign(A { a: 0.0 }), 256.0);\n+    test!(DIV, div_assign([1.0]), 4.0);\n+    test!(REM, rem_assign(W(5.0)), 5.0);\n+    test!(SUB, sub_assign(W(8.0)), 0.0);\n+}"}, {"sha": "cc49e4696e58fd9d803cabfede462415844ca35a", "filename": "src/test/ui/consts/const_short_circuit.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_short_circuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_short_circuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_short_circuit.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -0,0 +1,16 @@\n+#![feature(underscore_const_names, const_let)]\n+\n+const _: bool = false && false;\n+const _: bool = true && false;\n+const _: bool = {\n+    let mut x = true && false;\n+    //~^ ERROR new features like let bindings are not permitted\n+    x\n+};\n+const _: bool = {\n+    let x = true && false;\n+    //~^ ERROR new features like let bindings are not permitted\n+    x\n+};\n+\n+fn main() {}"}, {"sha": "a67bb0b1b6d98d3592ac65d4d9de4794e19017b5", "filename": "src/test/ui/consts/const_short_circuit.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_short_circuit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fconst_short_circuit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_short_circuit.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -0,0 +1,26 @@\n+error: new features like let bindings are not permitted in constants which also use short circuiting operators\n+  --> $DIR/const_short_circuit.rs:6:9\n+   |\n+LL |     let mut x = true && false;\n+   |         ^^^^^\n+   |\n+note: use of `&&` operator here does not actually short circuit due to the const evaluator presently not being able to do control flow. See https://github.com/rust-lang/rust/issues/49146 for more information.\n+  --> $DIR/const_short_circuit.rs:6:22\n+   |\n+LL |     let mut x = true && false;\n+   |                      ^^\n+\n+error: new features like let bindings are not permitted in constants which also use short circuiting operators\n+  --> $DIR/const_short_circuit.rs:11:9\n+   |\n+LL |     let x = true && false;\n+   |         ^\n+   |\n+note: use of `&&` operator here does not actually short circuit due to the const evaluator presently not being able to do control flow. See https://github.com/rust-lang/rust/issues/49146 for more information.\n+  --> $DIR/const_short_circuit.rs:11:18\n+   |\n+LL |     let x = true && false;\n+   |                  ^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "6c4e9e0a067d7dcf74c6249fa1b49e2a5808d3b0", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -115,7 +115,7 @@ LL | const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n error: local variables in const fn are unstable\n   --> $DIR/min_const_fn.rs:109:34\n    |\n-LL | const fn foo30_6() -> bool { let x = true; x } //~ ERROR local variables in const fn are unstable\n+LL | const fn foo30_6() -> bool { let x = true; x } //~ ERROR local variables in const fn\n    |                                  ^\n \n error: `if`, `match`, `&&` and `||` are not stable in const fn"}, {"sha": "ad983da4df9d81a6a71df9846b0b285ec04a5849", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -106,7 +106,7 @@ const fn foo30_2(x: *mut u32) -> usize { x as usize }\n const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n //~^ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n-const fn foo30_6() -> bool { let x = true; x } //~ ERROR local variables in const fn are unstable\n+const fn foo30_6() -> bool { let x = true; x } //~ ERROR local variables in const fn\n const fn foo36(a: bool, b: bool) -> bool { a && b }\n //~^ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n const fn foo37(a: bool, b: bool) -> bool { a || b }"}, {"sha": "a93a4f817fc14d1aaeaaeca770572a81e5889287", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -115,7 +115,7 @@ LL | const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n error: local variables in const fn are unstable\n   --> $DIR/min_const_fn.rs:109:34\n    |\n-LL | const fn foo30_6() -> bool { let x = true; x } //~ ERROR local variables in const fn are unstable\n+LL | const fn foo30_6() -> bool { let x = true; x } //~ ERROR local variables in const fn\n    |                                  ^\n \n error: `if`, `match`, `&&` and `||` are not stable in const fn"}, {"sha": "3dd76b630a883401acf05ed0179268d498c7fb3a", "filename": "src/test/ui/consts/min_const_fn/mutable_borrow.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -0,0 +1,17 @@\n+const fn mutable_ref_in_const() -> u8 {\n+    let mut a = 0; //~ ERROR local variables in const fn\n+    let b = &mut a;\n+    *b\n+}\n+\n+struct X;\n+\n+impl X {\n+    const fn inherent_mutable_ref_in_const() -> u8 {\n+        let mut a = 0; //~ ERROR local variables in const fn\n+        let b = &mut a;\n+        *b\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fa46f5c804fe0eaed14f4360e024bfa122ed4a6a", "filename": "src/test/ui/consts/min_const_fn/mutable_borrow.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmutable_borrow.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -0,0 +1,14 @@\n+error: local variables in const fn are unstable\n+  --> $DIR/mutable_borrow.rs:2:9\n+   |\n+LL |     let mut a = 0; //~ ERROR local variables in const fn\n+   |         ^^^^^\n+\n+error: local variables in const fn are unstable\n+  --> $DIR/mutable_borrow.rs:11:13\n+   |\n+LL |         let mut a = 0; //~ ERROR local variables in const fn\n+   |             ^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "5863429a2f2c5ddd19ad6e7efc57eb130582155f", "filename": "src/test/ui/consts/projection_qualif.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -7,6 +7,7 @@ const FOO: &u32 = {\n     {\n         let b: *mut u32 = &mut a; //~ ERROR may only refer to immutable values\n         unsafe { *b = 5; } //~ ERROR dereferencing raw pointers in constants\n+        //~^ contains unimplemented expression\n     }\n     &{a}\n };"}, {"sha": "cc3635a979b370f792afd0c1e34da3b5a3141daa", "filename": "src/test/ui/consts/projection_qualif.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -4,6 +4,12 @@ error[E0017]: references in constants may only refer to immutable values\n LL |         let b: *mut u32 = &mut a; //~ ERROR may only refer to immutable values\n    |                           ^^^^^^ constants require immutable values\n \n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/projection_qualif.rs:9:18\n+   |\n+LL |         unsafe { *b = 5; } //~ ERROR dereferencing raw pointers in constants\n+   |                  ^^^^^^\n+\n error[E0658]: dereferencing raw pointers in constants is unstable (see issue #51911)\n   --> $DIR/projection_qualif.rs:9:18\n    |\n@@ -12,7 +18,7 @@ LL |         unsafe { *b = 5; } //~ ERROR dereferencing raw pointers in constant\n    |\n    = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors occurred: E0017, E0658.\n+Some errors occurred: E0017, E0019, E0658.\n For more information about an error, try `rustc --explain E0017`."}, {"sha": "79dde3c18e8fa995ed58414fb85beb8dec9a39b1", "filename": "src/test/ui/consts/single_variant_match_ice.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -2,6 +2,14 @@ enum Foo {\n     Prob,\n }\n \n+const FOO: u32 = match Foo::Prob {\n+    Foo::Prob => 42, //~ ERROR unimplemented expression type\n+};\n+\n+const BAR: u32 = match Foo::Prob {\n+    x => 42, //~ ERROR unimplemented expression type\n+};\n+\n impl Foo {\n     pub const fn as_val(&self) -> u8 {\n         use self::Foo::*;"}, {"sha": "f5c2cb5e0e9dcb95931e6e7d07a0cea6f4ac8967", "filename": "src/test/ui/consts/single_variant_match_ice.stderr", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -1,8 +1,21 @@\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/single_variant_match_ice.rs:6:5\n+   |\n+LL |     Foo::Prob => 42, //~ ERROR unimplemented expression type\n+   |     ^^^^^^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/single_variant_match_ice.rs:10:5\n+   |\n+LL |     x => 42, //~ ERROR unimplemented expression type\n+   |     ^\n+\n error: `if`, `match`, `&&` and `||` are not stable in const fn\n-  --> $DIR/single_variant_match_ice.rs:10:13\n+  --> $DIR/single_variant_match_ice.rs:18:13\n    |\n LL |             Prob => 0x1, //~ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n    |             ^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0019`."}, {"sha": "9bf957a5f1e05988a3f0de479442d264e8f86000", "filename": "src/test/ui/feature-gates/feature-gate-const_let.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_let.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -10,13 +10,22 @@\n \n // Test use of const let without feature gate.\n \n-#![feature(const_fn)]\n+const FOO: usize = {\n+    //~^ ERROR statements in constants are unstable\n+    //~| ERROR: let bindings in constants are unstable\n+    let x = 42;\n+    //~^ ERROR statements in constants are unstable\n+    //~| ERROR: let bindings in constants are unstable\n+    42\n+};\n \n-const fn foo() -> usize {\n+static BAR: usize = {\n+    //~^ ERROR statements in statics are unstable\n+    //~| ERROR: let bindings in statics are unstable\n     let x = 42;\n-    //~^ ERROR statements in constant functions are unstable\n-    //~| ERROR: let bindings in constant functions are unstable\n+    //~^ ERROR statements in statics are unstable\n+    //~| ERROR: let bindings in statics are unstable\n     42\n-}\n+};\n \n fn main() {}"}, {"sha": "acb5165918e2a6caefb6236e83adcd7548f8fd5f", "filename": "src/test/ui/feature-gates/feature-gate-const_let.stderr", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_let.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -1,19 +1,91 @@\n-error[E0658]: let bindings in constant functions are unstable (see issue #48821)\n+error[E0658]: let bindings in constants are unstable (see issue #48821)\n   --> $DIR/feature-gate-const_let.rs:16:13\n    |\n LL |     let x = 42;\n    |             ^^\n    |\n    = help: add #![feature(const_let)] to the crate attributes to enable\n \n-error[E0658]: statements in constant functions are unstable (see issue #48821)\n+error[E0658]: statements in constants are unstable (see issue #48821)\n   --> $DIR/feature-gate-const_let.rs:16:13\n    |\n LL |     let x = 42;\n    |             ^^\n    |\n    = help: add #![feature(const_let)] to the crate attributes to enable\n \n-error: aborting due to 2 previous errors\n+error[E0658]: let bindings in constants are unstable (see issue #48821)\n+  --> $DIR/feature-gate-const_let.rs:13:1\n+   |\n+LL | / const FOO: usize = {\n+LL | |     //~^ ERROR statements in constants are unstable\n+LL | |     //~| ERROR: let bindings in constants are unstable\n+LL | |     let x = 42;\n+...  |\n+LL | |     42\n+LL | | };\n+   | |__^\n+   |\n+   = help: add #![feature(const_let)] to the crate attributes to enable\n+\n+error[E0658]: statements in constants are unstable (see issue #48821)\n+  --> $DIR/feature-gate-const_let.rs:13:1\n+   |\n+LL | / const FOO: usize = {\n+LL | |     //~^ ERROR statements in constants are unstable\n+LL | |     //~| ERROR: let bindings in constants are unstable\n+LL | |     let x = 42;\n+...  |\n+LL | |     42\n+LL | | };\n+   | |__^\n+   |\n+   = help: add #![feature(const_let)] to the crate attributes to enable\n+\n+error[E0658]: let bindings in statics are unstable (see issue #48821)\n+  --> $DIR/feature-gate-const_let.rs:25:13\n+   |\n+LL |     let x = 42;\n+   |             ^^\n+   |\n+   = help: add #![feature(const_let)] to the crate attributes to enable\n+\n+error[E0658]: statements in statics are unstable (see issue #48821)\n+  --> $DIR/feature-gate-const_let.rs:25:13\n+   |\n+LL |     let x = 42;\n+   |             ^^\n+   |\n+   = help: add #![feature(const_let)] to the crate attributes to enable\n+\n+error[E0658]: let bindings in statics are unstable (see issue #48821)\n+  --> $DIR/feature-gate-const_let.rs:22:1\n+   |\n+LL | / static BAR: usize = {\n+LL | |     //~^ ERROR statements in statics are unstable\n+LL | |     //~| ERROR: let bindings in statics are unstable\n+LL | |     let x = 42;\n+...  |\n+LL | |     42\n+LL | | };\n+   | |__^\n+   |\n+   = help: add #![feature(const_let)] to the crate attributes to enable\n+\n+error[E0658]: statements in statics are unstable (see issue #48821)\n+  --> $DIR/feature-gate-const_let.rs:22:1\n+   |\n+LL | / static BAR: usize = {\n+LL | |     //~^ ERROR statements in statics are unstable\n+LL | |     //~| ERROR: let bindings in statics are unstable\n+LL | |     let x = 42;\n+...  |\n+LL | |     42\n+LL | | };\n+   | |__^\n+   |\n+   = help: add #![feature(const_let)] to the crate attributes to enable\n+\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "a2f40b3f5396c2f48461809aa96ae1b502108071", "filename": "src/test/ui/issues/issue-37550.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fissues%2Fissue-37550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fissues%2Fissue-37550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37550.rs?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -8,15 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(const_fn)]\n-\n const fn x() {\n-    let t = true;\n-    //~^ ERROR let bindings in constant functions are unstable\n-    //~| ERROR statements in constant functions are unstable\n+    let t = true; //~ ERROR local variables in const fn\n     let x = || t;\n-    //~^ ERROR let bindings in constant functions are unstable\n-    //~| ERROR statements in constant functions are unstable\n }\n \n fn main() {}"}, {"sha": "5a7d1ad043ee47a0cbd2aaf51ac0869d87481cf5", "filename": "src/test/ui/issues/issue-37550.stderr", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fissues%2Fissue-37550.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cb84844e83ee88684ef89cc02221a26abbf92530/src%2Ftest%2Fui%2Fissues%2Fissue-37550.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37550.stderr?ref=cb84844e83ee88684ef89cc02221a26abbf92530", "patch": "@@ -1,35 +1,8 @@\n-error[E0658]: let bindings in constant functions are unstable (see issue #48821)\n-  --> $DIR/issue-37550.rs:14:13\n+error: local variables in const fn are unstable\n+  --> $DIR/issue-37550.rs:12:9\n    |\n-LL |     let t = true;\n-   |             ^^^^\n-   |\n-   = help: add #![feature(const_let)] to the crate attributes to enable\n-\n-error[E0658]: statements in constant functions are unstable (see issue #48821)\n-  --> $DIR/issue-37550.rs:14:13\n-   |\n-LL |     let t = true;\n-   |             ^^^^\n-   |\n-   = help: add #![feature(const_let)] to the crate attributes to enable\n-\n-error[E0658]: let bindings in constant functions are unstable (see issue #48821)\n-  --> $DIR/issue-37550.rs:17:13\n-   |\n-LL |     let x = || t;\n-   |             ^^^^\n-   |\n-   = help: add #![feature(const_let)] to the crate attributes to enable\n-\n-error[E0658]: statements in constant functions are unstable (see issue #48821)\n-  --> $DIR/issue-37550.rs:17:13\n-   |\n-LL |     let x = || t;\n-   |             ^^^^\n-   |\n-   = help: add #![feature(const_let)] to the crate attributes to enable\n+LL |     let t = true; //~ ERROR local variables in const fn\n+   |         ^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}]}