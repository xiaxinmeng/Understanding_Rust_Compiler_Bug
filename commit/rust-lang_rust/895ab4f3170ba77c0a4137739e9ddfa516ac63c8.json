{"sha": "895ab4f3170ba77c0a4137739e9ddfa516ac63c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NWFiNGYzMTcwYmE3N2MwYTQxMzc3MzllOWRkZmE1MTZhYzYzYzg=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2016-02-16T03:10:01Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2016-02-17T01:36:11Z"}, "message": "Implement placement-in protocol for `LinkedList`\n\nCC #30172.", "tree": {"sha": "3f156e96a220ca342c4ebe687e09d28a24cb8aa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f156e96a220ca342c4ebe687e09d28a24cb8aa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/895ab4f3170ba77c0a4137739e9ddfa516ac63c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/895ab4f3170ba77c0a4137739e9ddfa516ac63c8", "html_url": "https://github.com/rust-lang/rust/commit/895ab4f3170ba77c0a4137739e9ddfa516ac63c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/895ab4f3170ba77c0a4137739e9ddfa516ac63c8/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17d284b4b5af8aa2d58c3bf05b937d5b9d1adeb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/17d284b4b5af8aa2d58c3bf05b937d5b9d1adeb0", "html_url": "https://github.com/rust-lang/rust/commit/17d284b4b5af8aa2d58c3bf05b937d5b9d1adeb0"}], "stats": {"total": 152, "additions": 150, "deletions": 2}, "files": [{"sha": "abf50a5fe3ec10604d431bdbc7dfebb0e17b53c8", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/895ab4f3170ba77c0a4137739e9ddfa516ac63c8/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/895ab4f3170ba77c0a4137739e9ddfa516ac63c8/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=895ab4f3170ba77c0a4137739e9ddfa516ac63c8", "patch": "@@ -45,6 +45,8 @@\n #![feature(nonzero)]\n #![feature(num_bits_bytes)]\n #![feature(pattern)]\n+#![feature(placement_in)]\n+#![feature(placement_new_protocol)]\n #![feature(shared)]\n #![feature(slice_bytes)]\n #![feature(slice_patterns)]"}, {"sha": "cb669a9bf9ef8863c5ba5a6d714e0bbf5aadbf3d", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 148, "deletions": 2, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/895ab4f3170ba77c0a4137739e9ddfa516ac63c8/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/895ab4f3170ba77c0a4137739e9ddfa516ac63c8/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=895ab4f3170ba77c0a4137739e9ddfa516ac63c8", "patch": "@@ -21,13 +21,14 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use alloc::boxed::Box;\n+use alloc::boxed::{Box, IntermediateBox};\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::iter::FromIterator;\n use core::mem;\n-use core::ptr::Shared;\n+use core::ops::{BoxPlace, InPlace, Place, Placer};\n+use core::ptr::{self, Shared};\n \n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -660,6 +661,56 @@ impl<T> LinkedList<T> {\n \n         second_part\n     }\n+\n+    /// Returns a place for insertion at the front of the list.\n+    ///\n+    /// Using this method with placement syntax is equivalent to [`push_front`]\n+    /// (#method.push_front), but may be more efficient.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collection_placement)]\n+    /// #![feature(placement_in_syntax)]\n+    ///\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut list = LinkedList::new();\n+    /// list.front_place() <- 2;\n+    /// list.front_place() <- 4;\n+    /// assert!(list.iter().eq(&[4, 2]));\n+    /// ```\n+    #[unstable(feature = \"collection_placement\",\n+               reason = \"method name and placement protocol are subject to change\",\n+               issue = \"30172\")]\n+    pub fn front_place(&mut self) -> FrontPlace<T> {\n+        FrontPlace { list: self, node: IntermediateBox::make_place() }\n+    }\n+\n+    /// Returns a place for insertion at the back of the list.\n+    ///\n+    /// Using this method with placement syntax is equivalent to [`push_back`](#method.push_back),\n+    /// but may be more efficient.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collection_placement)]\n+    /// #![feature(placement_in_syntax)]\n+    ///\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut list = LinkedList::new();\n+    /// list.back_place() <- 2;\n+    /// list.back_place() <- 4;\n+    /// assert!(list.iter().eq(&[2, 4]));\n+    /// ```\n+    #[unstable(feature = \"collection_placement\",\n+               reason = \"method name and placement protocol are subject to change\",\n+               issue = \"30172\")]\n+    pub fn back_place(&mut self) -> BackPlace<T> {\n+        BackPlace { list: self, node: IntermediateBox::make_place() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -984,6 +1035,101 @@ impl<A: Hash> Hash for LinkedList<A> {\n     }\n }\n \n+unsafe fn finalize<T>(node: IntermediateBox<Node<T>>) -> Box<Node<T>> {\n+    let mut node = node.finalize();\n+    ptr::write(&mut node.next, None);\n+    ptr::write(&mut node.prev, Rawlink::none());\n+    node\n+}\n+\n+/// A place for insertion at the front of a `LinkedList`.\n+///\n+/// See [`LinkedList::front_place`](struct.LinkedList.html#method.front_place) for details.\n+#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol are subject to change\",\n+           issue = \"30172\")]\n+pub struct FrontPlace<'a, T: 'a> {\n+    list: &'a mut LinkedList<T>,\n+    node: IntermediateBox<Node<T>>,\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Placer<T> for FrontPlace<'a, T> {\n+    type Place = Self;\n+\n+    fn make_place(self) -> Self {\n+        self\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Place<T> for FrontPlace<'a, T> {\n+    fn pointer(&mut self) -> *mut T {\n+        unsafe { &mut (*self.node.pointer()).value }\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> InPlace<T> for FrontPlace<'a, T> {\n+    type Owner = ();\n+\n+    unsafe fn finalize(self) {\n+        let FrontPlace { list, node } = self;\n+        list.push_front_node(finalize(node));\n+    }\n+}\n+\n+/// A place for insertion at the back of a `LinkedList`.\n+///\n+/// See [`LinkedList::back_place`](struct.LinkedList.html#method.back_place) for details.\n+#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol are subject to change\",\n+           issue = \"30172\")]\n+pub struct BackPlace<'a, T: 'a> {\n+    list: &'a mut LinkedList<T>,\n+    node: IntermediateBox<Node<T>>,\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Placer<T> for BackPlace<'a, T> {\n+    type Place = Self;\n+\n+    fn make_place(self) -> Self {\n+        self\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Place<T> for BackPlace<'a, T> {\n+    fn pointer(&mut self) -> *mut T {\n+        unsafe { &mut (*self.node.pointer()).value }\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> InPlace<T> for BackPlace<'a, T> {\n+    type Owner = ();\n+\n+    unsafe fn finalize(self) {\n+        let BackPlace { list, node } = self;\n+        list.push_back_node(finalize(node));\n+    }\n+}\n+\n // Ensure that `LinkedList` and its read-only iterators are covariant in their type parameters.\n #[allow(dead_code)]\n fn assert_covariance() {"}]}