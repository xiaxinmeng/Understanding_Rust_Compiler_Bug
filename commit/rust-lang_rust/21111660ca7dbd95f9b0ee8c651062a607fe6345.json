{"sha": "21111660ca7dbd95f9b0ee8c651062a607fe6345", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMTExNjYwY2E3ZGJkOTVmOWIwZWU4YzY1MTA2MmE2MDdmZTYzNDU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-25T20:54:05Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-26T17:34:58Z"}, "message": "Improve type inference to compute LUB/GLB", "tree": {"sha": "64443ae02ec95793bbad1fff3c3b22da7304ad47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64443ae02ec95793bbad1fff3c3b22da7304ad47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21111660ca7dbd95f9b0ee8c651062a607fe6345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21111660ca7dbd95f9b0ee8c651062a607fe6345", "html_url": "https://github.com/rust-lang/rust/commit/21111660ca7dbd95f9b0ee8c651062a607fe6345", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21111660ca7dbd95f9b0ee8c651062a607fe6345/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2112c391cd13a67cfbf9064b17a51640add5053e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2112c391cd13a67cfbf9064b17a51640add5053e", "html_url": "https://github.com/rust-lang/rust/commit/2112c391cd13a67cfbf9064b17a51640add5053e"}], "stats": {"total": 949, "additions": 765, "deletions": 184}, "files": [{"sha": "8c849051c6dc50d39c4a5484ba3b12eafbca6260", "filename": "src/libcore/result.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=21111660ca7dbd95f9b0ee8c651062a607fe6345", "patch": "@@ -109,20 +109,21 @@ fn chain_err<T: copy, U: copy, V: copy>(\n     }\n }\n \n-// ______________________________________________________________________\n-// Note:\n-//\n-// These helper functions are written in a \"pre-chained\" (a.k.a,\n-// deforested) style because I have found that, in practice, this is\n-// the most concise way to do things.  That means that they do not not\n-// terminate with a call to `ok(v)` but rather `nxt(v)`.  If you would\n-// like to just get the result, just pass in `ok` as `nxt`.\n+impl methods<T:copy,E:copy> for result<T,E> {\n+    fn chain<U:copy>(op: fn(T) -> result<U,E>) -> result<U,E> {\n+        chain(self, op)\n+    }\n+\n+    fn chain_err<F:copy>(op: fn(E) -> result<T,F>) -> result<T,F> {\n+        chain_err(self, op)\n+    }\n+}\n \n #[doc = \"\n Maps each element in the vector `ts` using the operation `op`.  Should an\n error occur, no further mappings are performed and the error is returned.\n Should no error occur, a vector containing the result of each map is\n-passed to the `nxt` function.\n+returned.\n \n Here is an example which increments every integer in a vector,\n checking for overflow:\n@@ -131,27 +132,11 @@ checking for overflow:\n         if x == uint::max_value { ret err(\\\"overflow\\\"); }\n         else { ret ok(x+1u); }\n     }\n-    map([1u, 2u, 3u], inc_conditionally) {|incd|\n-        assert incd == [2u, 3u, 4u];\n-    }\n-\n-Note: if you have to combine a deforested style transform with map,\n-you should use `ok` for the `nxt` operation, as shown here (this is an\n-alternate version of the previous example where the\n-`inc_conditionally()` routine is deforested):\n-\n-    fn inc_conditionally<T>(x: uint,\n-                            nxt: fn(uint) -> result<T,str>) -> result<T,str> {\n-        if x == uint::max_value { ret err(\\\"overflow\\\"); }\n-        else { ret nxt(x+1u); }\n-    }\n-    map([1u, 2u, 3u], inc_conditionally(_, ok)) {|incd|\n+    map([1u, 2u, 3u], inc_conditionally).chain {|incd|\n         assert incd == [2u, 3u, 4u];\n     }\n \"]\n-fn map<T,U:copy,V:copy,W>(ts: [T],\n-                          op: fn(T) -> result<V,U>,\n-                          nxt: fn([V]) -> result<W,U>) -> result<W,U> {\n+fn map<T,U:copy,V:copy>(ts: [T], op: fn(T) -> result<V,U>) -> result<[V],U> {\n     let mut vs: [V] = [];\n     vec::reserve(vs, vec::len(ts));\n     for t in ts {\n@@ -160,7 +145,7 @@ fn map<T,U:copy,V:copy,W>(ts: [T],\n           err(u) { ret err(u); }\n         }\n     }\n-    ret nxt(vs);\n+    ret ok(vs);\n }\n \n #[doc = \"Same as map, but it operates over two parallel vectors.\n@@ -170,11 +155,9 @@ length.  While we do not often use preconditions in the standard\n library, a precondition is used here because result::t is generally\n used in 'careful' code contexts where it is both appropriate and easy\n to accommodate an error like the vectors being of different lengths.\"]\n-fn map2<S,T,U:copy,V:copy,W>(ss: [S], ts: [T],\n-                             op: fn(S,T) -> result<V,U>,\n-                             nxt: fn([V]) -> result<W,U>)\n-    : vec::same_length(ss, ts)\n-    -> result<W,U> {\n+fn map2<S,T,U:copy,V:copy>(ss: [S], ts: [T], op: fn(S,T) -> result<V,U>)\n+    : vec::same_length(ss, ts) -> result<[V],U> {\n+\n     let n = vec::len(ts);\n     let mut vs = [];\n     vec::reserve(vs, n);\n@@ -186,13 +169,19 @@ fn map2<S,T,U:copy,V:copy,W>(ss: [S], ts: [T],\n         }\n         i += 1u;\n     }\n-    ret nxt(vs);\n+    ret ok(vs);\n }\n \n+#[doc = \"\n+Applies op to the pairwise elements from `ss` and `ts`, aborting on\n+error.  This could be implemented using `map2()` but it is more efficient\n+on its own as no result vector is built.\n+\"]\n fn iter2<S,T,U:copy>(ss: [S], ts: [T],\n                      op: fn(S,T) -> result<(),U>)\n     : vec::same_length(ss, ts)\n     -> result<(),U> {\n+\n     let n = vec::len(ts);\n     let mut i = 0u;\n     while i < n {"}, {"sha": "c0bd70c270c0d1c43e02476c488a66daaee91632", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=21111660ca7dbd95f9b0ee8c651062a607fe6345", "patch": "@@ -27,7 +27,6 @@ export rsplit;\n export rsplitn;\n export shift;\n export pop;\n-export clear;\n export push;\n export grow;\n export grow_fn;\n@@ -321,7 +320,7 @@ fn rsplitn<T: copy>(v: [const T], n: uint, f: fn(T) -> bool) -> [[T]] {\n // Mutators\n \n #[doc = \"Removes the first element from a vector and return it\"]\n-fn shift<T: copy>(&v: [const T]) -> T {\n+fn shift<T: copy>(&v: [T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n     let e = v[0];\n@@ -331,6 +330,9 @@ fn shift<T: copy>(&v: [const T]) -> T {\n \n #[doc = \"Prepend an element to a vector\"]\n fn unshift<T: copy>(&v: [const T], +t: T) {\n+    // n.b.---for most callers, using unshift() ought not to type check, but\n+    // it does. It's because the type system is unaware of the mutability of\n+    // `v` and so allows the vector to be covariant.\n     v = [const t] + v;\n }\n \n@@ -344,14 +346,6 @@ fn pop<T>(&v: [const T]) -> T unsafe {\n     val\n }\n \n-#[doc = \"\n-Removes all elements from a vector without affecting\n-how much space is reserved.\n-\"]\n-fn clear<T>(&v: [const T]) unsafe {\n-    unsafe::set_len(v, 0u);\n-}\n-\n #[doc = \"Append an element to a vector\"]\n fn push<T>(&v: [const T], +initval: T) {\n     v += [initval];"}, {"sha": "320e2b349c64d38f2d7f7b039f1bf331217a9d7e", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 729, "deletions": 134, "changes": 863, "blob_url": "https://github.com/rust-lang/rust/blob/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=21111660ca7dbd95f9b0ee8c651062a607fe6345", "patch": "@@ -3,8 +3,9 @@ import std::smallintmap::smallintmap;\n import std::smallintmap::map;\n import middle::ty;\n import syntax::ast;\n+import syntax::ast::{ret_style};\n import util::ppaux::{ty_to_str, mt_to_str};\n-import result::{result, chain, chain_err, ok, iter2};\n+import result::{result, methods, chain, chain_err, ok, err, map, map2, iter2};\n import ty::type_is_bot;\n \n export infer_ctxt;\n@@ -46,24 +47,22 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n }\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    #debug[\">> mk_subty(%s <: %s)\", cx.ty_to_str(a), cx.ty_to_str(b)];\n+    #debug[\">> mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n     cx.commit {||\n         cx.tys(a, b)\n     }\n }\n \n fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    #debug[\"> mk_eqty(%s <: %s)\", cx.ty_to_str(a), cx.ty_to_str(b)];\n+    #debug[\">> mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n     cx.commit {||\n-        mk_subty(cx, a, b).then {||\n-            mk_subty(cx, b, a)\n-        }\n+        cx.eq_tys(a, b)\n     }\n }\n \n fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n     let infcx = new_infer_ctxt(tcx);\n-    #debug[\"> compare_tys(%s == %s)\", infcx.ty_to_str(a), infcx.ty_to_str(b)];\n+    #debug[\">> compare_tys(%s == %s)\", a.to_str(infcx), b.to_str(infcx)];\n     infcx.commit {||\n         mk_subty(infcx, a, b).then {||\n             mk_subty(infcx, b, a)\n@@ -90,6 +89,48 @@ impl methods for ures {\n     }\n }\n \n+iface to_str {\n+    fn to_str(cx: infer_ctxt) -> str;\n+}\n+\n+impl of to_str for ty::t {\n+    fn to_str(cx: infer_ctxt) -> str {\n+        ty_to_str(cx.tcx, self)\n+    }\n+}\n+\n+impl of to_str for ty::mt {\n+    fn to_str(cx: infer_ctxt) -> str {\n+        mt_to_str(cx.tcx, self)\n+    }\n+}\n+\n+impl<V:copy to_str> of to_str for bound<V> {\n+    fn to_str(cx: infer_ctxt) -> str {\n+        alt self {\n+          some(v) { v.to_str(cx) }\n+          none { \"none \" }\n+        }\n+    }\n+}\n+\n+impl<V:copy to_str> of to_str for bounds<V> {\n+    fn to_str(cx: infer_ctxt) -> str {\n+        #fmt[\"{%s <: %s}\",\n+             self.lb.to_str(cx),\n+             self.ub.to_str(cx)]\n+    }\n+}\n+\n+impl<V:copy to_str> of to_str for var_value<V> {\n+    fn to_str(cx: infer_ctxt) -> str {\n+        alt self {\n+          redirect(id) { #fmt(\"redirect(%u)\", id) }\n+          bounded(bnds) { #fmt(\"bounded(%s)\", bnds.to_str(cx)) }\n+        }\n+    }\n+}\n+\n // Most of these methods, like tys() and so forth, take two parameters\n // a and b and they are tasked with \"ensuring that a is a subtype of\n // b\".  They return success or failure.  They make changes in-place to\n@@ -102,53 +143,32 @@ impl methods for ures {\n impl unify_methods for infer_ctxt {\n     fn uok() -> ures {\n         #debug[\"Unification OK\"];\n-        result::ok(())\n+        ok(())\n     }\n \n     fn uerr(e: ty::type_err) -> ures {\n         #debug[\"Unification error: %?\", e];\n-        result::err(e)\n-    }\n-\n-    fn ty_to_str(t: ty::t) -> str {\n-        ty_to_str(self.tcx, t)\n-    }\n-\n-    fn ty_bound_to_str(b: bound<ty::t>) -> str {\n-        alt b {\n-          none { \"none\" }\n-          some(t) { self.ty_to_str(t) }\n-        }\n-    }\n-\n-    fn ty_bounds_to_str(v: bounds<ty::t>) -> str {\n-        #fmt[\"{%s <: X <: %s}\",\n-             self.ty_bound_to_str(v.lb),\n-             self.ty_bound_to_str(v.ub)]\n-    }\n-\n-    fn ty_var_value_to_str(v: var_value<ty::t>) -> str {\n-        alt v {\n-          redirect(v) { #fmt[\"redirect(%u)\", v] }\n-          bounded(b) { self.ty_bounds_to_str(b) }\n-        }\n+        err(e)\n     }\n \n-    fn set<T:copy>(vb: vals_and_bindings<T>, vid: uint,\n-                   +new_v: var_value<T>) {\n+    fn set<T:copy to_str>(\n+        vb: vals_and_bindings<T>, vid: uint,\n+        +new_v: var_value<T>) {\n \n         let old_v = vb.vals.get(vid);\n         vec::push(vb.bindings, (vid, old_v));\n         vb.vals.insert(vid, new_v);\n+\n+        #debug[\"Updating variable <%u> from %s to %s\",\n+               vid, old_v.to_str(self), new_v.to_str(self)];\n     }\n \n     fn set_ty(vid: uint, +new_v: var_value<ty::t>) {\n         let old_v = self.vb.vals.get(vid);\n         self.set(self.vb, vid, new_v);\n+\n         #debug[\"Updating variable <T%u> from %s to %s\",\n-               vid,\n-               self.ty_var_value_to_str(old_v),\n-               self.ty_var_value_to_str(new_v)];\n+               vid, old_v.to_str(self), new_v.to_str(self)];\n     }\n \n     fn rollback_to<T:copy>(vb: vals_and_bindings<T>, len: uint) {\n@@ -170,6 +190,8 @@ impl unify_methods for infer_ctxt {\n         self.vb.bindings = [];\n         self.rb.bindings = [];\n \n+        #debug[\">> Commit result: %?\", r];\n+\n         ret r;\n     }\n \n@@ -227,38 +249,47 @@ impl unify_methods for infer_ctxt {\n         ret self.get(self.rb, rid);\n     }\n \n-    // Combines the two bounds.  Returns a bounds r where (r.lb <:\n-    // a,b) and (a,b <: r.ub) (if such a bounds exists).\n-    //\n-    // TODO: Generalize this to region bounds too.\n-    fn merge_bnds(a: bound<ty::t>, b: bound<ty::t>)\n-            -> result<bounds<ty::t>, ty::type_err> {\n+    // Combines the two bounds into a more general bound.\n+    fn merge_bnd<V:copy to_str>(\n+        a: bound<V>, b: bound<V>,\n+        merge_op: fn(V,V) -> cres<V>) -> cres<bound<V>> {\n \n         alt (a, b) {\n           (none, none) {\n-            ok({lb: none, ub: none})\n+            ok(none)\n           }\n           (some(_), none) {\n-            ok({lb: a, ub: a})\n+            ok(a)\n           }\n           (none, some(_)) {\n-            ok({lb: b, ub: b})\n+            ok(b)\n           }\n-          (some(t_a), some(t_b)) {\n-            let r1 = self.try {||\n-                self.tys(t_a, t_b).then {||\n-                    ok({lb: a, ub: b})\n-                }\n-            };\n-            chain_err(r1) {|_e|\n-                self.tys(t_b, t_a).then {||\n-                    ok({lb: b, ub: a})\n-                }\n+          (some(v_a), some(v_b)) {\n+            merge_op(v_a, v_b).chain {|v|\n+                ok(some(v))\n             }\n           }\n         }\n     }\n \n+    fn merge_bnds<V:copy to_str>(\n+        a: bounds<V>, b: bounds<V>,\n+        lub: fn(V,V) -> cres<V>,\n+        glb: fn(V,V) -> cres<V>) -> cres<bounds<V>> {\n+\n+        self.merge_bnd(a.ub, b.ub, glb).chain {|ub|\n+            #debug[\"glb of ubs %s and %s is %s\",\n+                   a.ub.to_str(self), b.ub.to_str(self),\n+                   ub.to_str(self)];\n+            self.merge_bnd(a.lb, b.lb, lub).chain {|lb|\n+                #debug[\"lub of lbs %s and %s is %s\",\n+                       a.lb.to_str(self), b.lb.to_str(self),\n+                       lb.to_str(self)];\n+                ok({lb: lb, ub: ub})\n+            }\n+        }\n+    }\n+\n     // Updates the bounds for the variable `v_id` to be the intersection\n     // of `a` and `b`.  That is, the new bounds for `v_id` will be\n     // a bounds c such that:\n@@ -267,9 +298,9 @@ impl unify_methods for infer_ctxt {\n     //    a.lb <: c.lb\n     //    b.lb <: c.lb\n     // If this cannot be achieved, the result is failure.\n-    //\n-    // TODO: Generalize to regions.\n-    fn merge(v_id: uint, a: bounds<ty::t>, b: bounds<ty::t>) -> ures {\n+    fn set_ty_var_to_merged_bounds(\n+        v_id: uint, a: bounds<ty::t>, b: bounds<ty::t>) -> ures {\n+\n         // Think of the two diamonds, we want to find the\n         // intersection.  There are basically four possibilities (you\n         // can swap A/B in these pictures):\n@@ -287,21 +318,33 @@ impl unify_methods for infer_ctxt {\n \n         #debug[\"merge(<T%u>,%s,%s)\",\n                v_id,\n-               self.ty_bounds_to_str(a),\n-               self.ty_bounds_to_str(b)];\n-\n-        chain(self.merge_bnds(a.ub, b.ub)) {|ub|\n-            chain(self.merge_bnds(a.lb, b.lb)) {|lb|\n-                let bnds = {lb: lb.ub, ub: ub.lb};\n-\n-                // the new bounds must themselves\n-                // be relatable:\n-                self.bnds(lb.ub, ub.lb).then {||\n-                    self.set(self.vb, v_id, bounded(bnds));\n-                    self.uok()\n-                }\n+               a.to_str(self),\n+               b.to_str(self)];\n+\n+        // First, relate the lower/upper bounds of A and B.\n+        // Note that these relations *must* hold for us to\n+        // to be able to merge A and B at all, and relating\n+        // them explicitly gives the type inferencer more\n+        // information and helps to produce tighter bounds\n+        // when necessary.\n+        self.bnds(a.lb, b.ub).then {||\n+        self.bnds(b.lb, a.ub).then {||\n+        self.merge_bnds(\n+            a, b,\n+            {|a_ty, b_ty| lub(self).c_tys(a_ty, b_ty) },\n+            {|a_ty, b_ty| glb(self).c_tys(a_ty, b_ty) }).chain {|bnds|\n+\n+            #debug[\"merge(<T%u>): bnds=%s\",\n+                   v_id,\n+                   bnds.to_str(self)];\n+\n+            // the new bounds must themselves\n+            // be relatable:\n+            self.bnds(bnds.lb, bnds.ub).then {||\n+            self.set_ty(v_id, bounded(bnds));\n+            self.uok()\n             }\n-        }\n+        }}}\n     }\n \n     // TODO: Generalize to regions.\n@@ -311,8 +354,8 @@ impl unify_methods for infer_ctxt {\n         let {root: b_id, bounds: b_bounds} = self.get(self.vb, b_id);\n \n         #debug[\"vars(<T%u>=%s <: <T%u>=%s)\",\n-               a_id, self.ty_bounds_to_str(a_bounds),\n-               b_id, self.ty_bounds_to_str(b_bounds)];\n+               a_id, a_bounds.to_str(self),\n+               b_id, b_bounds.to_str(self)];\n \n         if a_id == b_id { ret self.uok(); }\n \n@@ -322,44 +365,41 @@ impl unify_methods for infer_ctxt {\n           (some(a_ub), some(b_lb)) {\n             let r = self.try {|| self.tys(a_ub, b_lb) };\n             alt r {\n-              result::ok(()) { ret result::ok(()); }\n-              result::err(_) { /*fallthrough */ }\n+              ok(()) { ret result::ok(()); }\n+              err(_) { /*fallthrough */ }\n             }\n           }\n           _ { /*fallthrough*/ }\n         }\n \n+        // For max perf, we should consider the rank here.  But for now,\n+        // we always make b redirect to a.\n+        self.set_ty(b_id, redirect(a_id));\n+\n         // Otherwise, we need to merge A and B so as to guarantee that\n         // A remains a subtype of B.  Actually, there are other options,\n         // but that's the route we choose to take.\n-        self.merge(a_id, a_bounds, b_bounds).then {||\n-            // For max perf, we should consider the rank here.\n-            self.set(self.vb, b_id, redirect(a_id));\n+        self.set_ty_var_to_merged_bounds(a_id, a_bounds, b_bounds).then {||\n             self.uok()\n         }\n     }\n \n     fn varty(a_id: uint, b: ty::t) -> ures {\n         let {root: a_id, bounds: a_bounds} = self.get(self.vb, a_id);\n         #debug[\"varty(<T%u>=%s <: %s)\",\n-               a_id, self.ty_bounds_to_str(a_bounds),\n-               self.ty_to_str(b)];\n+               a_id, a_bounds.to_str(self),\n+               b.to_str(self)];\n         let b_bounds = {lb: none, ub: some(b)};\n-        self.merge(a_id, a_bounds, b_bounds)\n+        self.set_ty_var_to_merged_bounds(a_id, a_bounds, b_bounds)\n     }\n \n     fn tyvar(a: ty::t, b_id: uint) -> ures {\n         let a_bounds = {lb: some(a), ub: none};\n         let {root: b_id, bounds: b_bounds} = self.get(self.vb, b_id);\n         #debug[\"tyvar(%s <: <T%u>=%s)\",\n-               self.ty_to_str(a),\n-               b_id, self.ty_bounds_to_str(b_bounds)];\n-        self.merge(b_id, a_bounds, b_bounds)\n-    }\n-\n-    fn tyvecs(as: [ty::t], bs: [ty::t])\n-        : vec::same_length(as, bs) -> ures {\n-        iter2(as, bs) {|a,b| self.tys(a,b) }\n+               a.to_str(self),\n+               b_id, b_bounds.to_str(self)];\n+        self.set_ty_var_to_merged_bounds(b_id, a_bounds, b_bounds)\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> ures {\n@@ -400,21 +440,17 @@ impl unify_methods for infer_ctxt {\n     }\n \n     fn mts(a: ty::mt, b: ty::mt) -> ures {\n-        #debug(\"mts(%s <: %s)\",\n-               mt_to_str(self.tcx, a),\n-               mt_to_str(self.tcx, b));\n+        #debug(\"mts(%s <: %s)\", a.to_str(self), b.to_str(self));\n \n         if a.mutbl != b.mutbl && b.mutbl != ast::m_const {\n             ret self.uerr(ty::terr_mutability);\n         }\n \n         alt b.mutbl {\n           ast::m_mutbl {\n-            // If supertype is mutable, subtype must mtach exactly\n+            // If supertype is mutable, subtype must match exactly\n             // (i.e., invariant if mutable):\n-            self.tys(a.ty, b.ty).then {||\n-                self.tys(b.ty, a.ty)\n-            }\n+            self.eq_tys(a.ty, b.ty)\n           }\n           ast::m_imm | ast::m_const {\n             // Otherwise we can be covariant:\n@@ -432,7 +468,7 @@ impl unify_methods for infer_ctxt {\n \n     fn tps(as: [ty::t], bs: [ty::t]) -> ures {\n         if check vec::same_length(as, bs) {\n-            self.tyvecs(as, bs)\n+            iter2(as, bs) {|a, b| self.tys(a, b) }\n         } else {\n             self.uerr(ty::terr_ty_param_size(as.len(), bs.len()))\n         }\n@@ -448,8 +484,8 @@ impl unify_methods for infer_ctxt {\n     }\n \n     fn ret_styles(\n-        a_ret_style: ast::ret_style,\n-        b_ret_style: ast::ret_style) -> ures {\n+        a_ret_style: ret_style,\n+        b_ret_style: ret_style) -> ures {\n \n         if b_ret_style != ast::noreturn && b_ret_style != a_ret_style {\n             /* even though typestate checking is mostly\n@@ -465,8 +501,8 @@ impl unify_methods for infer_ctxt {\n \n     fn modes(a: ast::mode, b: ast::mode) -> ures {\n         alt ty::unify_mode(self.tcx, a, b) {\n-          result::ok(_) { self.uok() }\n-          result::err(e) { self.uerr(e) }\n+          ok(_) { self.uok() }\n+          err(e) { self.uerr(e) }\n         }\n     }\n \n@@ -492,8 +528,10 @@ impl unify_methods for infer_ctxt {\n             self.ret_styles(a_f.ret_style, b_f.ret_style).then {||\n                 self.argvecs(a_f.inputs, b_f.inputs).then {||\n                     self.tys(a_f.output, b_f.output).then {||\n-                        // FIXME---constraints\n-                        self.uok()\n+                        //TODO self.constrvecs(a_f.constraints,\n+                        //TODO                 b_f.constraints).then {||\n+                            self.uok()\n+                        //TODO }\n                     }\n                 }\n             }\n@@ -546,14 +584,36 @@ impl unify_methods for infer_ctxt {\n     // TODO: Generalize this.\n     fn bnds(a: bound<ty::t>, b: bound<ty::t>) -> ures {\n         #debug(\"bnds(%s <: %s)\",\n-               self.ty_bound_to_str(a),\n-               self.ty_bound_to_str(b));\n+               a.to_str(self),\n+               b.to_str(self));\n \n         alt (a, b) {\n           (none, none) |\n           (some(_), none) |\n-          (none, some(_)) { self.uok() }\n-          (some(t_a), some(t_b)) { self.tys(t_a, t_b) }\n+          (none, some(_)) {\n+            self.uok()\n+          }\n+          (some(t_a), some(t_b)) {\n+            self.tys(t_a, t_b)\n+          }\n+        }\n+    }\n+\n+    fn constrvecs(\n+        as: [@ty::type_constr], bs: [@ty::type_constr]) -> ures {\n+\n+        if check vec::same_length(as, bs) {\n+            iter2(as, bs) {|a,b|\n+                self.constrs(a, b)\n+            }\n+        } else {\n+            self.uerr(ty::terr_constr_len(as.len(), bs.len()))\n+        }\n+    }\n+\n+    fn eq_tys(a: ty::t, b: ty::t) -> ures {\n+        self.tys(a, b).then {||\n+            self.tys(b, a)\n         }\n     }\n \n@@ -637,7 +697,7 @@ impl unify_methods for infer_ctxt {\n \n           (ty::ty_tup(a_tys), ty::ty_tup(b_tys)) {\n             if check vec::same_length(a_tys, b_tys) {\n-                self.tyvecs(a_tys, b_tys)\n+                iter2(a_tys, b_tys) {|a,b| self.tys(a,b) }\n             } else {\n                 self.uerr(ty::terr_tuple_size(a_tys.len(), b_tys.len()))\n             }\n@@ -649,14 +709,7 @@ impl unify_methods for infer_ctxt {\n \n           (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n             self.tys(a_t, b_t).then {||\n-                if check vec::same_length(a_constrs, b_constrs) {\n-                    iter2(a_constrs, b_constrs) {|a,b|\n-                        self.constrs(a, b)\n-                    }\n-                } else {\n-                    self.uerr(ty::terr_constr_len(a_constrs.len(),\n-                                                  b_constrs.len()))\n-                }\n+                self.constrvecs(a_constrs, b_constrs)\n             }\n           }\n \n@@ -667,30 +720,34 @@ impl unify_methods for infer_ctxt {\n \n impl resolve_methods for infer_ctxt {\n     fn rok(t: ty::t) -> fres<ty::t> {\n-        #debug[\"Resolve OK: %s\", self.ty_to_str(t)];\n-        result::ok(t)\n+        #debug[\"Resolve OK: %s\", t.to_str(self)];\n+        ok(t)\n     }\n \n     fn rerr<T>(v: int) -> fres<T> {\n         #debug[\"Resolve error: %?\", v];\n-        result::err(v)\n+        err(v)\n     }\n \n-    fn resolve_var<T:copy>(vb: vals_and_bindings<T>, bot_guard: fn(T)->bool,\n-                           vid: int) -> fres<T> {\n+    fn resolve_var<T:copy to_str>(\n+        vb: vals_and_bindings<T>, bot_guard: fn(T)->bool,\n+        vid: int) -> fres<T> {\n \n         let {root:_, bounds} = self.get(vb, vid as uint);\n \n+        #debug[\"resolve_var(%d) bounds=%s\",\n+               vid, bounds.to_str(self)];\n+\n         // Nonobvious: prefer the most specific type\n         // (i.e., the lower bound) to the more general\n         // one.  More general types in Rust (e.g., fn())\n         // tend to carry more restrictions or higher\n         // perf. penalties, so it pays to know more.\n \n         alt bounds {\n-          { ub:_, lb:some(t) } if !bot_guard(t) { result::ok(t) }\n-          { ub:some(t), lb:_ } { result::ok(t) }\n-          { ub:_, lb:some(t) } { result::ok(t) }\n+          { ub:_, lb:some(t) } if !bot_guard(t) { ok(t) }\n+          { ub:some(t), lb:_ } { ok(t) }\n+          { ub:_, lb:some(t) } { ok(t) }\n           { ub:none, lb:none } { self.rerr(vid) }\n         }\n     }\n@@ -704,8 +761,8 @@ impl resolve_methods for infer_ctxt {\n           ty::ty_var(vid) { self.resolve_ty_var(vid) }\n           ty::ty_rptr(ty::re_var(rid), base_ty) {\n             alt self.resolve_region(rid as int) {\n-              result::err(terr)  { result::err(terr) }\n-              result::ok(region) {\n+              err(terr)  { err(terr) }\n+              ok(region) {\n                 self.rok(ty::mk_rptr(self.tcx, region, base_ty))\n               }\n             }\n@@ -720,11 +777,11 @@ impl resolve_methods for infer_ctxt {\n         // Should really return a fixup_result instead of a t, but fold_ty\n         // doesn't allow returning anything but a t.\n         alt self.resolve_ty_var(vid) {\n-          result::err(vid) {\n+          err(vid) {\n             *unresolved = some(vid);\n             ret ty::mk_var(self.tcx, vid);\n           }\n-          result::ok(rt) {\n+          ok(rt) {\n             let mut give_up = false;\n             std::list::iter(vars_seen) {|v|\n                 if v == vid {\n@@ -776,7 +833,7 @@ impl resolve_methods for infer_ctxt {\n         alt bounds {\n           { ub:_, lb:some(r) } |\n           { ub:some(r), lb:_ } |\n-          { ub:_, lb:some(r) } { result::ok(r) }\n+          { ub:_, lb:some(r) } { ok(r) }\n           { ub:none, lb:none } { self.rerr(rid) }\n         }\n     }\n@@ -787,11 +844,11 @@ impl resolve_methods for infer_ctxt {\n         // Should really return a fixup_result instead of a t, but fold_ty\n         // doesn't allow returning anything but a t.\n         alt self.resolve_region(rid) {\n-          result::err(rid) {\n+          err(rid) {\n             *unresolved = some(rid);\n             ret ty::re_var(rid as uint);\n           }\n-          result::ok(rr) {\n+          ok(rr) {\n             let mut give_up = false;\n             std::list::iter(regions_seen) {|r|\n                 if r == rid {\n@@ -822,3 +879,541 @@ impl resolve_methods for infer_ctxt {\n         }\n     }\n }\n+\n+// ______________________________________________________________________\n+// Type combining\n+//\n+// There are two type combiners, lub and gub.  The first computes the\n+// Least Upper Bound of two types `a` and `b`---that is, a mutual\n+// supertype type `c` where `a <: c` and `a <: c`.  As the name\n+// implies, it tries to pick the most precise `c` possible.  `glb`\n+// computes the greatest lower bound---that is, it computes a mutual\n+// subtype, aiming for the most general such type possible.  Both\n+// computations may fail.\n+//\n+// There is a lot of common code for these operations, which is\n+// abstracted out into functions named `c_X()` which take a combiner\n+// instance as the first parameter.  This would be better implemented\n+// using traits.\n+//\n+// In principle, the subtyping relation computed above could be built\n+// on the combine framework---this would result in less code but would\n+// be less efficient.  There is a significant performance gain from\n+// not recreating types unless we need to.  Even so, we could write\n+// the routines with a few more generics in there to mask type\n+// construction (which is, after all, the significant expense) but I\n+// haven't gotten around to it.\n+\n+type cres<T> = result<T,ty::type_err>;\n+\n+iface combine {\n+    fn infcx() -> infer_ctxt;\n+    fn tag() -> str;\n+    fn bnd<V:copy>(b: bounds<V>) -> option<V>;\n+    fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V>;\n+    fn c_bot(b: ty::t) -> cres<ty::t>;\n+    fn c_regions(a: ty::region, b: ty::region) -> cres<ty::region>;\n+    fn c_mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n+    fn c_contratys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n+    fn c_tys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n+    fn c_protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto>;\n+    fn c_ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n+}\n+\n+enum lub = infer_ctxt;\n+enum glb = infer_ctxt;\n+\n+fn c_ty_vars<C:combine>(self: C, a_id: uint, b_id: uint) -> cres<ty::t> {\n+    // Need to find a type that is a supertype of both a and b:\n+    let {root: a_id, bounds: a_bounds} = self.infcx().get_var(a_id);\n+    let {root: b_id, bounds: b_bounds} = self.infcx().get_var(b_id);\n+\n+    #debug[\"%s.c_ty_vars(<T%u>=%s <: <T%u>=%s)\",\n+           self.tag(),\n+           a_id, a_bounds.to_str(self.infcx()),\n+           b_id, b_bounds.to_str(self.infcx())];\n+\n+    let tcx = self.infcx().tcx;\n+\n+    if a_id == b_id {\n+        ret ok(ty::mk_var(tcx, a_id as int));\n+    }\n+\n+    // The comments in this function are written for LUB, but they\n+    // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n+\n+    // If both A and B have an UB type, then we can just compute the\n+    // LUB of those types:\n+    let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n+    alt (a_bnd, b_bnd) {\n+      (some(a_ty), some(b_ty)) {\n+        alt self.infcx().try {|| self.c_tys(a_ty, b_ty) } {\n+            ok(t) { ret ok(t); }\n+            err(_) { /*fallthrough */ }\n+        }\n+      }\n+      _ {/*fallthrough*/}\n+    }\n+\n+    // Otherwise, we need to merge A and B into one variable.  We can\n+    // then use either variable as an upper bound:\n+    self.infcx().vars(a_id, b_id).then {||\n+        ok(ty::mk_var(tcx, a_id as int))\n+    }\n+}\n+\n+fn c_ty_var_ty<C:combine>(self: C, a_id: uint, b: ty::t) -> cres<ty::t> {\n+    let {root: a_id, bounds: a_bounds} = self.infcx().get_var(a_id);\n+\n+    // The comments in this function are written for LUB, but they\n+    // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n+\n+    #debug[\"%s.c_ty_var_ty(<T%u>=%s <: %s)\",\n+           self.tag(),\n+           a_id, a_bounds.to_str(self.infcx()),\n+           b.to_str(self.infcx())];\n+\n+    alt self.bnd(a_bounds) {\n+      some(a_ty) {\n+        // If a has an upper bound, return it.\n+        ret self.c_tys(a_ty, b);\n+      }\n+      none {\n+        // If a does not have an upper bound, make b the upper bound of a\n+        // and then return b.\n+        let a_bounds = self.with_bnd(a_bounds, b);\n+        self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n+            self.infcx().set_ty(a_id, bounded(a_bounds));\n+            ok(b)\n+        }\n+      }\n+    }\n+}\n+\n+fn c_tuptys<C:combine>(self: C, as: [ty::t], bs: [ty::t])\n+    -> cres<[ty::t]> {\n+\n+    if check vec::same_length(as, bs) {\n+        map2(as, bs) {|a, b| self.c_tys(a, b) }\n+    } else {\n+        err(ty::terr_tuple_size(as.len(), bs.len()))\n+    }\n+}\n+\n+fn c_tps<C:combine>(self: C, _did: ast::def_id, as: [ty::t], bs: [ty::t])\n+    -> cres<[ty::t]> {\n+    // FIXME #1973 lookup the declared variance of the type parameters\n+    // based on did\n+    if check vec::same_length(as, bs) {\n+        map2(as, bs) {|a,b| self.c_tys(a, b) }\n+    } else {\n+        err(ty::terr_ty_param_size(as.len(), bs.len()))\n+    }\n+}\n+\n+fn c_fieldvecs<C:combine>(self: C, as: [ty::field], bs: [ty::field])\n+    -> cres<[ty::field]> {\n+\n+    if check vec::same_length(as, bs) {\n+        map2(as, bs) {|a,b| c_flds(self, a, b) }\n+    } else {\n+        err(ty::terr_record_size(as.len(), bs.len()))\n+    }\n+}\n+\n+fn c_flds<C:combine>(self: C, a: ty::field, b: ty::field) -> cres<ty::field> {\n+    if a.ident == b.ident {\n+        self.c_mts(a.mt, b.mt).chain {|mt|\n+            ok({ident: a.ident, mt: mt})\n+        }\n+    } else {\n+        err(ty::terr_record_fields(a.ident, b.ident))\n+    }\n+}\n+\n+fn c_modes<C:combine>(self: C, a: ast::mode, b: ast::mode)\n+    -> cres<ast::mode> {\n+\n+    let tcx = self.infcx().tcx;\n+    ty::unify_mode(tcx, a, b)\n+}\n+\n+fn c_args<C:combine>(self: C, a: ty::arg, b: ty::arg)\n+    -> cres<ty::arg> {\n+\n+    c_modes(self, a.mode, b.mode).chain {|m|\n+        // Note: contravariant\n+        self.c_contratys(b.ty, a.ty).chain {|t|\n+            ok({mode: m, ty: t})\n+        }\n+    }\n+}\n+\n+fn c_argvecs<C:combine>(\n+    self: C, a_args: [ty::arg], b_args: [ty::arg]) -> cres<[ty::arg]> {\n+\n+    if check vec::same_length(a_args, b_args) {\n+        map2(a_args, b_args) {|a, b| c_args(self, a, b) }\n+    } else {\n+        err(ty::terr_arg_count)\n+    }\n+}\n+\n+fn c_fns<C:combine>(\n+    self: C, a_f: ty::fn_ty, b_f: ty::fn_ty) -> cres<ty::fn_ty> {\n+\n+    self.c_protos(a_f.proto, b_f.proto).chain {|p|\n+        self.c_ret_styles(a_f.ret_style, b_f.ret_style).chain {|rs|\n+            c_argvecs(self, a_f.inputs, b_f.inputs).chain {|inputs|\n+                self.c_tys(a_f.output, b_f.output).chain {|output|\n+                    //FIXME self.infcx().constrvecs(a_f.constraints,\n+                    //FIXME                         b_f.constraints).then {||\n+                        ok({proto: p,\n+                            inputs: inputs,\n+                            output: output,\n+                            ret_style: rs,\n+                            constraints: a_f.constraints})\n+                    //FIXME }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn c_tys<C:combine>(\n+    self: C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+\n+    let tcx = self.infcx().tcx;\n+\n+    #debug(\"%s.c_tys(%s, %s)\",\n+           self.tag(),\n+           ty_to_str(tcx, a),\n+           ty_to_str(tcx, b));\n+\n+    // Fast path.\n+    if a == b { ret ok(a); }\n+\n+    alt (ty::get(a).struct, ty::get(b).struct) {\n+      (ty::ty_bot, _) { self.c_bot(b) }\n+      (_, ty::ty_bot) { self.c_bot(b) }\n+\n+      (ty::ty_var(a_id), ty::ty_var(b_id)) {\n+        c_ty_vars(self, a_id as uint, b_id as uint)\n+      }\n+\n+      // Note that the LUB/GLB operations are commutative:\n+      (ty::ty_var(a_id), _) {\n+        c_ty_var_ty(self, a_id as uint, b)\n+      }\n+      (_, ty::ty_var(b_id)) {\n+        c_ty_var_ty(self, b_id as uint, a)\n+      }\n+\n+      (ty::ty_nil, _) |\n+      (ty::ty_bool, _) |\n+      (ty::ty_int(_), _) |\n+      (ty::ty_uint(_), _) |\n+      (ty::ty_float(_), _) |\n+      (ty::ty_str, _) {\n+        let cfg = tcx.sess.targ_cfg;\n+        if ty::mach_sty(cfg, a) == ty::mach_sty(cfg, b) {\n+            ok(a)\n+        } else {\n+            err(ty::terr_mismatch)\n+        }\n+      }\n+\n+      (ty::ty_param(a_n, _), ty::ty_param(b_n, _)) if a_n == b_n {\n+        ok(a)\n+      }\n+\n+      (ty::ty_enum(a_id, a_tps), ty::ty_enum(b_id, b_tps))\n+      if a_id == b_id {\n+        c_tps(self, a_id, a_tps, b_tps).chain {|tps|\n+            ok(ty::mk_enum(tcx, a_id, tps))\n+        }\n+      }\n+\n+      (ty::ty_iface(a_id, a_tps), ty::ty_iface(b_id, b_tps))\n+      if a_id == b_id {\n+        c_tps(self, a_id, a_tps, b_tps).chain {|tps|\n+            ok(ty::mk_iface(tcx, a_id, tps))\n+        }\n+      }\n+\n+      (ty::ty_class(a_id, a_tps), ty::ty_class(b_id, b_tps))\n+      if a_id == b_id {\n+        // FIXME variance\n+        c_tps(self, a_id, a_tps, b_tps).chain {|tps|\n+            ok(ty::mk_class(tcx, a_id, tps))\n+        }\n+      }\n+\n+      (ty::ty_box(a_mt), ty::ty_box(b_mt)) {\n+        self.c_mts(a_mt, b_mt).chain {|mt|\n+            ok(ty::mk_box(tcx, mt))\n+        }\n+      }\n+\n+      (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) {\n+        self.c_mts(a_mt, b_mt).chain {|mt|\n+            ok(ty::mk_uniq(tcx, mt))\n+        }\n+      }\n+\n+      (ty::ty_vec(a_mt), ty::ty_vec(b_mt)) {\n+        self.c_mts(a_mt, b_mt).chain {|mt|\n+            ok(ty::mk_vec(tcx, mt))\n+        }\n+      }\n+\n+      (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) {\n+        self.c_mts(a_mt, b_mt).chain {|mt|\n+            ok(ty::mk_ptr(tcx, mt))\n+        }\n+      }\n+\n+      (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n+        self.c_regions(a_r, b_r).chain {|r|\n+            self.c_mts(a_mt, b_mt).chain {|mt|\n+                ok(ty::mk_rptr(tcx, r, mt))\n+            }\n+        }\n+      }\n+\n+      (ty::ty_res(a_id, a_t, a_tps), ty::ty_res(b_id, b_t, b_tps))\n+      if a_id == b_id {\n+        self.c_tys(a_t, b_t).chain {|t|\n+            c_tps(self, a_id, a_tps, b_tps).chain {|tps|\n+                ok(ty::mk_res(tcx, a_id, t, tps))\n+            }\n+        }\n+      }\n+\n+      (ty::ty_rec(a_fields), ty::ty_rec(b_fields)) {\n+        c_fieldvecs(self, a_fields, b_fields).chain {|fs|\n+            ok(ty::mk_rec(tcx, fs))\n+        }\n+      }\n+\n+      (ty::ty_tup(a_tys), ty::ty_tup(b_tys)) {\n+        c_tuptys(self, a_tys, b_tys).chain {|ts|\n+            ok(ty::mk_tup(tcx, ts))\n+        }\n+      }\n+\n+      (ty::ty_fn(a_fty), ty::ty_fn(b_fty)) {\n+        c_fns(self, a_fty, b_fty).chain {|fty|\n+            ok(ty::mk_fn(tcx, fty))\n+        }\n+      }\n+\n+      (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n+        self.c_tys(a_t, b_t).chain {|t|\n+            self.infcx().constrvecs(a_constrs, b_constrs).then {||\n+                ok(ty::mk_constr(tcx, t, a_constrs))\n+            }\n+        }\n+      }\n+\n+      _ { err(ty::terr_mismatch) }\n+    }\n+}\n+\n+impl of combine for lub {\n+    fn infcx() -> infer_ctxt { *self }\n+\n+    fn tag() -> str { \"lub\" }\n+\n+    fn bnd<V:copy>(b: bounds<V>) -> option<V> {\n+        b.ub\n+    }\n+\n+    fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V> {\n+        assert b.ub == none;\n+        {ub: some(v) with b}\n+    }\n+\n+    fn c_bot(b: ty::t) -> cres<ty::t> {\n+        ok(b)\n+    }\n+\n+    fn c_regions(a: ty::region, _b: ty::region) -> cres<ty::region> {\n+        ok(a) // FIXME\n+    }\n+\n+    fn c_mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+        let tcx = self.infcx().tcx;\n+\n+        #debug(\"%s.c_mts(%s, %s)\",\n+               self.tag(),\n+               mt_to_str(tcx, a),\n+               mt_to_str(tcx, b));\n+\n+        let m = if a.mutbl == b.mutbl {\n+            a.mutbl\n+        } else {\n+            ast::m_const\n+        };\n+\n+        alt m {\n+          ast::m_imm | ast::m_const {\n+            self.c_tys(a.ty, b.ty).chain {|t|\n+                ok({ty: t, mutbl: m})\n+            }\n+          }\n+\n+          ast::m_mutbl {\n+            self.infcx().try {||\n+                self.infcx().eq_tys(a.ty, b.ty).then {||\n+                    ok({ty: a.ty, mutbl: m})\n+                }\n+            }.chain_err {|_e|\n+                self.c_tys(a.ty, b.ty).chain {|t|\n+                    ok({ty: t, mutbl: ast::m_const})\n+                }\n+            }\n+          }\n+        }\n+    }\n+\n+    fn c_contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        glb(self.infcx()).c_tys(a, b)\n+    }\n+\n+    fn c_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        c_tys(self, a, b)\n+    }\n+\n+    fn c_protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto> {\n+        if p1 == ast::proto_bare {\n+            ok(p2)\n+        } else if p2 == ast::proto_bare {\n+            ok(p1)\n+        } else if p1 == p2 {\n+            ok(p1)\n+        } else {\n+            ok(ast::proto_any)\n+        }\n+    }\n+\n+    fn c_ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n+        alt (r1, r2) {\n+          (ast::return_val, _) |\n+          (_, ast::return_val) {\n+            ok(ast::return_val)\n+          }\n+          (ast::noreturn, ast::noreturn) {\n+            ok(ast::noreturn)\n+          }\n+        }\n+    }\n+}\n+\n+impl of combine for glb {\n+    fn infcx() -> infer_ctxt { *self }\n+\n+    fn tag() -> str { \"glb\" }\n+\n+    fn bnd<V:copy>(b: bounds<V>) -> option<V> {\n+        b.lb\n+    }\n+\n+    fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V> {\n+        assert b.lb == none;\n+        {lb: some(v) with b}\n+    }\n+\n+    fn c_bot(_b: ty::t) -> cres<ty::t> {\n+        ok(ty::mk_bot(self.infcx().tcx))\n+    }\n+\n+    fn c_regions(a: ty::region, _b: ty::region) -> cres<ty::region> {\n+        ok(a) // FIXME\n+    }\n+\n+    fn c_mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+        let tcx = self.infcx().tcx;\n+\n+        #debug(\"%s.c_mts(%s, %s)\",\n+               self.tag(),\n+               mt_to_str(tcx, a),\n+               mt_to_str(tcx, b));\n+\n+        alt (a.mutbl, b.mutbl) {\n+          // If one side or both is mutable, then the GLB must use\n+          // the precise type from the mutable side.\n+          (ast::m_mutbl, ast::m_const) {\n+            self.infcx().tys(a.ty, b.ty).then {||\n+                ok({ty: a.ty, mutbl: ast::m_mutbl})\n+            }\n+          }\n+          (ast::m_const, ast::m_mutbl) {\n+            self.infcx().tys(b.ty, a.ty).then {||\n+                ok({ty: b.ty, mutbl: ast::m_mutbl})\n+            }\n+          }\n+          (ast::m_mutbl, ast::m_mutbl) {\n+            self.infcx().eq_tys(a.ty, b.ty).then {||\n+                ok({ty: a.ty, mutbl: ast::m_mutbl})\n+            }\n+          }\n+\n+          // If one side or both is immutable, we can use the GLB of\n+          // both sides but mutbl must be `m_imm`.\n+          (ast::m_imm, ast::m_const) |\n+          (ast::m_const, ast::m_imm) |\n+          (ast::m_imm, ast::m_imm) {\n+            self.c_tys(a.ty, b.ty).chain {|t|\n+                ok({ty: t, mutbl: ast::m_imm})\n+            }\n+          }\n+\n+          // If both sides are const, then we can use GLB of both\n+          // sides and mutbl of only `m_const`.\n+          (ast::m_const, ast::m_const) {\n+            self.c_tys(a.ty, b.ty).chain {|t|\n+                ok({ty: t, mutbl: ast::m_const})\n+            }\n+          }\n+\n+          // There is no mutual subtype of these combinations.\n+          (ast::m_mutbl, ast::m_imm) |\n+          (ast::m_imm, ast::m_mutbl) {\n+              err(ty::terr_mutability)\n+          }\n+        }\n+    }\n+\n+    fn c_contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        lub(self.infcx()).c_tys(a, b)\n+    }\n+\n+    fn c_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        c_tys(self, a, b)\n+    }\n+\n+    fn c_protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto> {\n+        if p1 == ast::proto_any {\n+            ok(p2)\n+        } else if p2 == ast::proto_any {\n+            ok(p1)\n+        } else if p1 == p2 {\n+            ok(p1)\n+        } else {\n+            ok(ast::proto_bare)\n+        }\n+    }\n+\n+    fn c_ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n+        alt (r1, r2) {\n+          (ast::return_val, ast::return_val) {\n+            ok(ast::return_val)\n+          }\n+          (ast::noreturn, _) |\n+          (_, ast::noreturn) {\n+            ok(ast::noreturn)\n+          }\n+        }\n+    }\n+}"}, {"sha": "ff8511aeae5e8f86698673ec1adefacf6d5f38a3", "filename": "src/test/compile-fail/fn-variance-3.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs?ref=21111660ca7dbd95f9b0ee8c651062a607fe6345", "patch": "@@ -12,10 +12,13 @@ fn main() {\n \n     // @int <: X\n     //\n-    // Note: this is really an inference failure.\n-    // The correct answer would be to make X\n-    // equal to @const int, but we are not (yet)\n-    // smart enough.\n-    r(@3); //! ERROR (values differ in mutability)\n+    // This constraint forces X to be\n+    // @const int.\n+    r(@3);\n \n+    // Here the type check succeeds but the\n+    // mutability check will fail, because the\n+    // type of r has been inferred to be\n+    // fn(@const int) -> @const int\n+    *r(@mut 3) = 4; //! ERROR assigning to immutable box\n }"}, {"sha": "732c9a4311f283f2b2995464ed8c2b6ea4a48c0f", "filename": "src/test/compile-fail/mode-inference-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21111660ca7dbd95f9b0ee8c651062a607fe6345/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs?ref=21111660ca7dbd95f9b0ee8c651062a607fe6345", "patch": "@@ -7,5 +7,5 @@ fn apply_int(f: fn(int) -> int, a: int) -> int { f(a) }\n fn main() {\n     let f = {|i| i};\n     assert apply_int(f, 2) == 2;\n-    assert apply(f, 2) == 2; //! ERROR expected argument mode &&\n+    assert apply(f, 2) == 2; //! ERROR expected argument mode ++\n }"}]}