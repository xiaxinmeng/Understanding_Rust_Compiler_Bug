{"sha": "b12708f7f40463b2131f0c47d1e8a4ffb543a422", "node_id": "C_kwDOAAsO6NoAKGIxMjcwOGY3ZjQwNDYzYjIxMzFmMGM0N2QxZThhNGZmYjU0M2E0MjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T13:24:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-20T13:24:31Z"}, "message": "Auto merge of #98292 - Dylan-DPC:rollup-hueb8tm, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #93080 (Implement `core::slice::IterMut::as_mut_slice` and `impl<T> AsMut<[T]> for IterMut<'_, T>`)\n - #94855 (Panic when advance_slices()'ing too far and update docs.)\n - #96609 (Add `{Arc, Rc}::downcast_unchecked`)\n - #96719 (Fix the generator example for `pin!()`)\n - #97149 (Windows: `CommandExt::async_pipes`)\n - #97150 (`Stdio::makes_pipe`)\n - #97837 (Document Rust's stance on `/proc/self/mem`)\n - #98159 (Include ForeignItem when visiting types for WF check)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "fbde1d289f8eda1a64d846142d65d5c0ef7b060c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbde1d289f8eda1a64d846142d65d5c0ef7b060c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b12708f7f40463b2131f0c47d1e8a4ffb543a422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b12708f7f40463b2131f0c47d1e8a4ffb543a422", "html_url": "https://github.com/rust-lang/rust/commit/b12708f7f40463b2131f0c47d1e8a4ffb543a422", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b12708f7f40463b2131f0c47d1e8a4ffb543a422/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d6010816c37186e2bee316709f0c0197c427513", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6010816c37186e2bee316709f0c0197c427513", "html_url": "https://github.com/rust-lang/rust/commit/1d6010816c37186e2bee316709f0c0197c427513"}, {"sha": "7bde23bb4f0cc74c5566e85501a43426c1be1bef", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bde23bb4f0cc74c5566e85501a43426c1be1bef", "html_url": "https://github.com/rust-lang/rust/commit/7bde23bb4f0cc74c5566e85501a43426c1be1bef"}], "stats": {"total": 311, "additions": 282, "deletions": 29}, "files": [{"sha": "4392b9aada9783d324e0b6f81a224b514fd24683", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -1,7 +1,7 @@\n use crate::collect::ItemCtxt;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::HirId;\n+use rustc_hir::{ForeignItem, ForeignItemKind, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::TraitEngine;\n use rustc_infer::traits::{ObligationCause, WellFormedLoc};\n@@ -141,6 +141,9 @@ fn diagnostic_hir_wf_check<'tcx>(\n                 ref item => bug!(\"Unexpected item {:?}\", item),\n             },\n             hir::Node::Field(field) => Some(field.ty),\n+            hir::Node::ForeignItem(ForeignItem {\n+                kind: ForeignItemKind::Static(ty, _), ..\n+            }) => Some(*ty),\n             ref node => bug!(\"Unexpected node {:?}\", node),\n         },\n         WellFormedLoc::Param { function: _, param_idx } => {"}, {"sha": "a248cd458df81b40b9ceb7a048d1f64457a4924d", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -1254,8 +1254,6 @@ impl<T: Clone> Rc<T> {\n }\n \n impl Rc<dyn Any> {\n-    #[inline]\n-    #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n     /// Attempt to downcast the `Rc<dyn Any>` to a concrete type.\n     ///\n     /// # Examples\n@@ -1274,6 +1272,8 @@ impl Rc<dyn Any> {\n     /// print_if_string(Rc::new(my_string));\n     /// print_if_string(Rc::new(0i8));\n     /// ```\n+    #[inline]\n+    #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n     pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<dyn Any>> {\n         if (*self).is::<T>() {\n             unsafe {\n@@ -1285,6 +1285,42 @@ impl Rc<dyn Any> {\n             Err(self)\n         }\n     }\n+\n+    /// Downcasts the `Rc<dyn Any>` to a concrete type.\n+    ///\n+    /// For a safe alternative see [`downcast`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x: Rc<dyn Any> = Rc::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The contained value must be of type `T`. Calling this method\n+    /// with the incorrect type is *undefined behavior*.\n+    ///\n+    ///\n+    /// [`downcast`]: Self::downcast\n+    #[inline]\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    pub unsafe fn downcast_unchecked<T: Any>(self) -> Rc<T> {\n+        unsafe {\n+            let ptr = self.ptr.cast::<RcBox<T>>();\n+            mem::forget(self);\n+            Rc::from_inner(ptr)\n+        }\n+    }\n }\n \n impl<T: ?Sized> Rc<T> {"}, {"sha": "2670b15982ad92c665d2a656ee00203a09aa8981", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -1705,8 +1705,6 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n }\n \n impl Arc<dyn Any + Send + Sync> {\n-    #[inline]\n-    #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n     /// Attempt to downcast the `Arc<dyn Any + Send + Sync>` to a concrete type.\n     ///\n     /// # Examples\n@@ -1725,9 +1723,11 @@ impl Arc<dyn Any + Send + Sync> {\n     /// print_if_string(Arc::new(my_string));\n     /// print_if_string(Arc::new(0i8));\n     /// ```\n+    #[inline]\n+    #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n     pub fn downcast<T>(self) -> Result<Arc<T>, Self>\n     where\n-        T: Any + Send + Sync + 'static,\n+        T: Any + Send + Sync,\n     {\n         if (*self).is::<T>() {\n             unsafe {\n@@ -1739,6 +1739,45 @@ impl Arc<dyn Any + Send + Sync> {\n             Err(self)\n         }\n     }\n+\n+    /// Downcasts the `Arc<dyn Any + Send + Sync>` to a concrete type.\n+    ///\n+    /// For a safe alternative see [`downcast`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(downcast_unchecked)]\n+    ///\n+    /// use std::any::Any;\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x: Arc<dyn Any + Send + Sync> = Arc::new(1_usize);\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// The contained value must be of type `T`. Calling this method\n+    /// with the incorrect type is *undefined behavior*.\n+    ///\n+    ///\n+    /// [`downcast`]: Self::downcast\n+    #[inline]\n+    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n+    pub unsafe fn downcast_unchecked<T>(self) -> Arc<T>\n+    where\n+        T: Any + Send + Sync,\n+    {\n+        unsafe {\n+            let ptr = self.ptr.cast::<ArcInner<T>>();\n+            mem::forget(self);\n+            Arc::from_inner(ptr)\n+        }\n+    }\n }\n \n impl<T> Weak<T> {"}, {"sha": "ccef35b45325a4001603c6edc7f6fc6c73d017f2", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -1006,9 +1006,10 @@ impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n ///  // Allow generator to be self-referential (not `Unpin`)\n ///  // vvvvvv        so that locals can cross yield points.\n ///     static || {\n-///         let foo = String::from(\"foo\"); // --+\n-///         yield 0;                         // | <- crosses yield point!\n-///         println!(\"{}\", &foo); // <----------+\n+///         let foo = String::from(\"foo\");\n+///         let foo_ref = &foo; // ------+\n+///         yield 0;                  // | <- crosses yield point!\n+///         println!(\"{foo_ref}\"); // <--+\n ///         yield foo.len();\n ///     }\n /// }"}, {"sha": "35d00b9dda6639aa4335ab3a654db29595828182", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -306,6 +306,47 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn as_slice(&self) -> &[T] {\n         self.make_slice()\n     }\n+\n+    /// Views the underlying data as a mutable subslice of the original data.\n+    ///\n+    /// To avoid creating `&mut [T]` references that alias, the returned slice\n+    /// borrows its lifetime from the iterator the method is applied on.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(slice_iter_mut_as_mut_slice)]\n+    ///\n+    /// let mut slice: &mut [usize] = &mut [1, 2, 3];\n+    ///\n+    /// // First, we get the iterator:\n+    /// let mut iter = slice.iter_mut();\n+    /// // Then, we get a mutable slice from it:\n+    /// let mut_slice = iter.as_mut_slice();\n+    /// // So if we check what the `as_mut_slice` method returned, we have \"[1, 2, 3]\":\n+    /// assert_eq!(mut_slice, &mut [1, 2, 3]);\n+    ///\n+    /// // We can use it to mutate the slice:\n+    /// mut_slice[0] = 4;\n+    /// mut_slice[2] = 5;\n+    ///\n+    /// // Next, we can move to the second element of the slice, checking that\n+    /// // it yields the value we just wrote:\n+    /// assert_eq!(iter.next(), Some(&mut 4));\n+    /// // Now `as_mut_slice` returns \"[2, 5]\":\n+    /// assert_eq!(iter.as_mut_slice(), &mut [2, 5]);\n+    /// ```\n+    #[must_use]\n+    // FIXME: Uncomment the `AsMut<[T]>` impl when this gets stabilized.\n+    #[unstable(feature = \"slice_iter_mut_as_mut_slice\", issue = \"93079\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        // SAFETY: the iterator was created from a mutable slice with pointer\n+        // `self.ptr` and length `len!(self)`. This guarantees that all the prerequisites\n+        // for `from_raw_parts_mut` are fulfilled.\n+        unsafe { from_raw_parts_mut(self.ptr.as_ptr(), len!(self)) }\n+    }\n }\n \n #[stable(feature = \"slice_iter_mut_as_slice\", since = \"1.53.0\")]\n@@ -315,6 +356,13 @@ impl<T> AsRef<[T]> for IterMut<'_, T> {\n     }\n }\n \n+// #[stable(feature = \"slice_iter_mut_as_mut_slice\", since = \"FIXME\")]\n+// impl<T> AsMut<[T]> for IterMut<'_, T> {\n+//     fn as_mut(&mut self) -> &mut [T] {\n+//         self.as_mut_slice()\n+//     }\n+// }\n+\n iterator! {struct IterMut -> *mut T, &'a mut T, mut, {mut}, {}}\n \n /// An internal abstraction over the splitting iterators, so that"}, {"sha": "cad1fab7b8f840ca6ab7ae1fff35c4dc6a3762a9", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -1084,6 +1084,10 @@ impl<'a> IoSliceMut<'a> {\n     /// Also see [`IoSliceMut::advance_slices`] to advance the cursors of\n     /// multiple buffers.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics when trying to advance beyond the end of the slice.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1105,15 +1109,18 @@ impl<'a> IoSliceMut<'a> {\n         self.0.advance(n)\n     }\n \n-    /// Advance the internal cursor of the slices.\n+    /// Advance a slice of slices.\n     ///\n-    /// # Notes\n+    /// Shrinks the slice to remove any `IoSliceMut`s that are fully advanced over.\n+    /// If the cursor ends up in the middle of an `IoSliceMut`, it is modified\n+    /// to start at that cursor.\n     ///\n-    /// Elements in the slice may be modified if the cursor is not advanced to\n-    /// the end of the slice. For example if we have a slice of buffers with 2\n-    /// `IoSliceMut`s, both of length 8, and we advance the cursor by 10 bytes\n-    /// the first `IoSliceMut` will be untouched however the second will be\n-    /// modified to remove the first 2 bytes (10 - 8).\n+    /// For example, if we have a slice of two 8-byte `IoSliceMut`s, and we advance by 10 bytes,\n+    /// the result will only include the second `IoSliceMut`, advanced by 2 bytes.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when trying to advance beyond the end of the slices.\n     ///\n     /// # Examples\n     ///\n@@ -1154,7 +1161,9 @@ impl<'a> IoSliceMut<'a> {\n         }\n \n         *bufs = &mut replace(bufs, &mut [])[remove..];\n-        if !bufs.is_empty() {\n+        if bufs.is_empty() {\n+            assert!(n == accumulated_len, \"advancing io slices beyond their length\");\n+        } else {\n             bufs[0].advance(n - accumulated_len)\n         }\n     }\n@@ -1219,6 +1228,10 @@ impl<'a> IoSlice<'a> {\n     /// Also see [`IoSlice::advance_slices`] to advance the cursors of multiple\n     /// buffers.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics when trying to advance beyond the end of the slice.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1240,15 +1253,18 @@ impl<'a> IoSlice<'a> {\n         self.0.advance(n)\n     }\n \n-    /// Advance the internal cursor of the slices.\n+    /// Advance a slice of slices.\n     ///\n-    /// # Notes\n+    /// Shrinks the slice to remove any `IoSlice`s that are fully advanced over.\n+    /// If the cursor ends up in the middle of an `IoSlice`, it is modified\n+    /// to start at that cursor.\n     ///\n-    /// Elements in the slice may be modified if the cursor is not advanced to\n-    /// the end of the slice. For example if we have a slice of buffers with 2\n-    /// `IoSlice`s, both of length 8, and we advance the cursor by 10 bytes the\n-    /// first `IoSlice` will be untouched however the second will be modified to\n-    /// remove the first 2 bytes (10 - 8).\n+    /// For example, if we have a slice of two 8-byte `IoSlice`s, and we advance by 10 bytes,\n+    /// the result will only include the second `IoSlice`, advanced by 2 bytes.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics when trying to advance beyond the end of the slices.\n     ///\n     /// # Examples\n     ///\n@@ -1288,7 +1304,9 @@ impl<'a> IoSlice<'a> {\n         }\n \n         *bufs = &mut replace(bufs, &mut [])[remove..];\n-        if !bufs.is_empty() {\n+        if bufs.is_empty() {\n+            assert!(n == accumulated_len, \"advancing io slices beyond their length\");\n+        } else {\n             bufs[0].advance(n - accumulated_len)\n         }\n     }"}, {"sha": "d5a8c93b0ce9f35cbc48a2b9300813be558e8582", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -423,18 +423,18 @@ fn io_slice_mut_advance_slices() {\n }\n \n #[test]\n+#[should_panic]\n fn io_slice_mut_advance_slices_empty_slice() {\n     let mut empty_bufs = &mut [][..];\n-    // Shouldn't panic.\n     IoSliceMut::advance_slices(&mut empty_bufs, 1);\n }\n \n #[test]\n+#[should_panic]\n fn io_slice_mut_advance_slices_beyond_total_length() {\n     let mut buf1 = [1; 8];\n     let mut bufs = &mut [IoSliceMut::new(&mut buf1)][..];\n \n-    // Going beyond the total length should be ok.\n     IoSliceMut::advance_slices(&mut bufs, 9);\n     assert!(bufs.is_empty());\n }\n@@ -463,18 +463,18 @@ fn io_slice_advance_slices() {\n }\n \n #[test]\n+#[should_panic]\n fn io_slice_advance_slices_empty_slice() {\n     let mut empty_bufs = &mut [][..];\n-    // Shouldn't panic.\n     IoSlice::advance_slices(&mut empty_bufs, 1);\n }\n \n #[test]\n+#[should_panic]\n fn io_slice_advance_slices_beyond_total_length() {\n     let buf1 = [1; 8];\n     let mut bufs = &mut [IoSlice::new(&buf1)][..];\n \n-    // Going beyond the total length should be ok.\n     IoSlice::advance_slices(&mut bufs, 9);\n     assert!(bufs.is_empty());\n }"}, {"sha": "3ab5606f8897dc778a3066bd331dd1efeca8196f", "filename": "library/std/src/os/unix/io/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -54,6 +54,25 @@\n //! Like boxes, `OwnedFd` values conceptually own the resource they point to,\n //! and free (close) it when they are dropped.\n //!\n+//! ## `/proc/self/mem` and similar OS features\n+//!\n+//! Some platforms have special files, such as `/proc/self/mem`, which\n+//! provide read and write access to the process's memory. Such reads\n+//! and writes happen outside the control of the Rust compiler, so they do not\n+//! uphold Rust's memory safety guarantees.\n+//!\n+//! This does not mean that all APIs that might allow `/proc/self/mem`\n+//! to be opened and read from or written must be `unsafe`. Rust's safety guarantees\n+//! only cover what the program itself can do, and not what entities outside\n+//! the program can do to it. `/proc/self/mem` is considered to be such an\n+//! external entity, along with debugging interfaces, and people with physical access to\n+//! the hardware. This is true even in cases where the program is controlling\n+//! the external entity.\n+//!\n+//! If you desire to comprehensively prevent programs from reaching out and\n+//! causing external entities to reach back in and violate memory safety, it's\n+//! necessary to use *sandboxing*, which is outside the scope of `std`.\n+//!\n //! [`BorrowedFd<'a>`]: crate::os::unix::io::BorrowedFd\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "a6b75493e6e6000837853df23f5b9a396b46b0c3", "filename": "library/std/src/os/windows/process.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -161,6 +161,37 @@ pub trait CommandExt: Sealed {\n     /// `CommandLineToArgvW` escaping rules.\n     #[stable(feature = \"windows_process_extensions_raw_arg\", since = \"1.62.0\")]\n     fn raw_arg<S: AsRef<OsStr>>(&mut self, text_to_append_as_is: S) -> &mut process::Command;\n+\n+    /// When [`process::Command`] creates pipes, request that our side is always async.\n+    ///\n+    /// By default [`process::Command`] may choose to use pipes where both ends\n+    /// are opened for synchronous read or write operations. By using\n+    /// `async_pipes(true)`, this behavior is overridden so that our side is\n+    /// always async.\n+    ///\n+    /// This is important because if doing async I/O a pipe or a file has to be\n+    /// opened for async access.\n+    ///\n+    /// The end of the pipe sent to the child process will always be synchronous\n+    /// regardless of this option.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(windows_process_extensions_async_pipes)]\n+    /// use std::os::windows::process::CommandExt;\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// # let program = \"\";\n+    ///\n+    /// Command::new(program)\n+    ///     .async_pipes(true)\n+    ///     .stdin(Stdio::piped())\n+    ///     .stdout(Stdio::piped())\n+    ///     .stderr(Stdio::piped());\n+    /// ```\n+    #[unstable(feature = \"windows_process_extensions_async_pipes\", issue = \"98289\")]\n+    fn async_pipes(&mut self, always_async: bool) -> &mut process::Command;\n }\n \n #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n@@ -179,6 +210,15 @@ impl CommandExt for process::Command {\n         self.as_inner_mut().raw_arg(raw_text.as_ref());\n         self\n     }\n+\n+    fn async_pipes(&mut self, always_async: bool) -> &mut process::Command {\n+        // FIXME: This currently has an intentional no-op implementation.\n+        // For the time being our side of the pipes will always be async.\n+        // Once the ecosystem has adjusted, we may then be able to start making\n+        // use of synchronous pipes within the standard library.\n+        let _ = always_async;\n+        self\n+    }\n }\n \n #[unstable(feature = \"windows_process_extensions_main_thread_handle\", issue = \"96723\")]"}, {"sha": "ab1a1e6c76fa4566c02aea580114d673e64150d8", "filename": "library/std/src/process.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -1273,6 +1273,22 @@ impl Stdio {\n     pub fn null() -> Stdio {\n         Stdio(imp::Stdio::Null)\n     }\n+\n+    /// Returns `true` if this requires [`Command`] to create a new pipe.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(stdio_makes_pipe)]\n+    /// use std::process::Stdio;\n+    ///\n+    /// let io = Stdio::piped();\n+    /// assert_eq!(io.makes_pipe(), true);\n+    /// ```\n+    #[unstable(feature = \"stdio_makes_pipe\", issue = \"98288\")]\n+    pub fn makes_pipe(&self) -> bool {\n+        matches!(self.0, imp::Stdio::MakePipe)\n+    }\n }\n \n impl FromInner<imp::Stdio> for Stdio {"}, {"sha": "67923cbb2d6b5a4812fba3a8221e18f21bcaeaae", "filename": "src/test/ui/wf/issue-95665.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/src%2Ftest%2Fui%2Fwf%2Fissue-95665.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/src%2Ftest%2Fui%2Fwf%2Fissue-95665.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fissue-95665.rs?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -0,0 +1,18 @@\n+// Regression test for the ICE described in #95665.\n+// Ensure that the expected error is output (and thus that there is no ICE)\n+\n+pub trait Trait: {}\n+\n+pub struct Struct<T: Trait> {\n+    member: T,\n+}\n+\n+// uncomment and bug goes away\n+// impl Trait for u8 {}\n+\n+extern \"C\" {\n+    static VAR: Struct<u8>;\n+                //~^ 14:17: 14:27: the trait bound `u8: Trait` is not satisfied [E0277]\n+}\n+\n+fn main() {}"}, {"sha": "b1cda59a9165b0751c0225dce2926cd7e8a40ffa", "filename": "src/test/ui/wf/issue-95665.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b12708f7f40463b2131f0c47d1e8a4ffb543a422/src%2Ftest%2Fui%2Fwf%2Fissue-95665.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b12708f7f40463b2131f0c47d1e8a4ffb543a422/src%2Ftest%2Fui%2Fwf%2Fissue-95665.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fissue-95665.stderr?ref=b12708f7f40463b2131f0c47d1e8a4ffb543a422", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `u8: Trait` is not satisfied\n+  --> $DIR/issue-95665.rs:14:17\n+   |\n+LL |     static VAR: Struct<u8>;\n+   |                 ^^^^^^^^^^ the trait `Trait` is not implemented for `u8`\n+   |\n+note: required by a bound in `Struct`\n+  --> $DIR/issue-95665.rs:6:22\n+   |\n+LL | pub struct Struct<T: Trait> {\n+   |                      ^^^^^ required by this bound in `Struct`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}