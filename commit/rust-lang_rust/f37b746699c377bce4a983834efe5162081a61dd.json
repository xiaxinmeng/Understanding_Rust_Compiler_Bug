{"sha": "f37b746699c377bce4a983834efe5162081a61dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzN2I3NDY2OTljMzc3YmNlNGE5ODM4MzRlZmU1MTYyMDgxYTYxZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-30T12:32:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-30T12:32:09Z"}, "message": "auto merge of #11182 : luisbg/rust/crateid, r=cmr\n\nIssue #11048", "tree": {"sha": "f9deac7335977bc1d214a2968815d590f9736c66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9deac7335977bc1d214a2968815d590f9736c66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f37b746699c377bce4a983834efe5162081a61dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f37b746699c377bce4a983834efe5162081a61dd", "html_url": "https://github.com/rust-lang/rust/commit/f37b746699c377bce4a983834efe5162081a61dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f37b746699c377bce4a983834efe5162081a61dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac0c376c3677c9da86a41bb0d8b14e20d0da30ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac0c376c3677c9da86a41bb0d8b14e20d0da30ac", "html_url": "https://github.com/rust-lang/rust/commit/ac0c376c3677c9da86a41bb0d8b14e20d0da30ac"}, {"sha": "51b5f32d331709e4af0f3613bf4e1aa5f63e913e", "url": "https://api.github.com/repos/rust-lang/rust/commits/51b5f32d331709e4af0f3613bf4e1aa5f63e913e", "html_url": "https://github.com/rust-lang/rust/commit/51b5f32d331709e4af0f3613bf4e1aa5f63e913e"}], "stats": {"total": 862, "additions": 432, "deletions": 430}, "files": [{"sha": "c9627a87cb03eeb10cde7763756c0752fb6b2a77", "filename": "doc/rust.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -610,7 +610,7 @@ the behavior of the compiler.\n \n ~~~~\n // Package ID\n-#[ pkgid = \"projx#2.5\" ];\n+#[ crate_id = \"projx#2.5\" ];\n \n // Additional metadata attributes\n #[ desc = \"Project X\" ];\n@@ -776,9 +776,9 @@ as the `ident` provided in the `extern_mod_decl`.\n The external crate is resolved to a specific `soname` at compile time, and a\n runtime linkage requirement to that `soname` is passed to the linker for\n loading at runtime.  The `soname` is resolved at compile time by scanning the\n-compiler's library path and matching the optional `pkgid` provided as a string literal\n-against the `pkgid` attributes that were declared on the external crate when\n-it was compiled.  If no `pkgid` is provided, a default `name` attribute is\n+compiler's library path and matching the optional `crateid` provided as a string literal\n+against the `crateid` attributes that were declared on the external crate when\n+it was compiled.  If no `crateid` is provided, a default `name` attribute is\n assumed, equal to the `ident` given in the `extern_mod_decl`.\n \n Four examples of `extern mod` declarations:\n@@ -1729,7 +1729,7 @@ names are effectively reserved. Some significant attributes include:\n * The `cfg` attribute, for conditional-compilation by build-configuration.\n * The `lang` attribute, for custom definitions of traits and functions that are known to the Rust compiler (see [Language items](#language-items)).\n * The `link` attribute, for describing linkage metadata for a extern blocks.\n-* The `pkgid` attribute, for describing the package ID of a crate.\n+* The `crate_id` attribute, for describing the package ID of a crate.\n * The `test` attribute, for marking functions as unit tests.\n * The `allow`, `warn`, `forbid`, and `deny` attributes, for\n   controlling lint checks (see [Lint check attributes](#lint-check-attributes)).\n@@ -3792,7 +3792,7 @@ specified then log level 4 is assumed.  Debug messages can be omitted\n by passing `--cfg ndebug` to `rustc`.\n \n As an example, to see all the logs generated by the compiler, you would set\n-`RUST_LOG` to `rustc`, which is the crate name (as specified in its `pkgid`\n+`RUST_LOG` to `rustc`, which is the crate name (as specified in its `crate_id`\n [attribute](#attributes)). To narrow down the logs to just crate resolution,\n you would set it to `rustc::metadata::creader`. To see just error logging\n use `rustc=0`."}, {"sha": "684c10405354fb19fb7a9a07bb63074747c71215", "filename": "doc/rustdoc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/doc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/doc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustdoc.md?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -13,7 +13,7 @@ comments\":\n ~~~\n // the \"link\" crate attribute is currently required for rustdoc, but normally\n // isn't needed.\n-#[pkgid = \"universe\"];\n+#[crate_id = \"universe\"];\n #[crate_type=\"lib\"];\n \n //! Tools for dealing with universes (this is a doc comment, and is shown on"}, {"sha": "f36cbe7153cfe86121aca3c29e6433fb9316fb22", "filename": "doc/rustpkg.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/doc%2Frustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/doc%2Frustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustpkg.md?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -90,7 +90,7 @@ then both `bar` and `bar/extras/baz` are valid package identifiers\n in the workspace `foo`.\n \n Because rustpkg uses generic source file names as the main inputs, you will\n-need to specify the package identifier in them using the `pkgid` attribute\n+need to specify the package identifier in them using the `crate_id` attribute\n on the crate.\n \n ## Source files"}, {"sha": "e87187abbcbf4d25c524432444cb04b8341bc03d", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -45,7 +45,7 @@ def scrub(b):\n \"\"\"\n // AUTO-GENERATED FILE: DO NOT EDIT\n #[crate_id=\\\"run_pass_stage2#0.1\\\"];\n-#[pkgid=\\\"run_pass_stage2#0.1\\\"];\n+#[crate_id=\\\"run_pass_stage2#0.1\\\"];\n #[feature(globs, macro_rules, struct_variant, managed_boxes)];\n #[allow(warnings)];\n \"\"\""}, {"sha": "786c05de20465258a4d5f0b608c09854578032d4", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -41,7 +41,7 @@ use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::pkgid::PkgId;\n+use syntax::crateid::CrateId;\n \n #[deriving(Clone, Eq)]\n pub enum output_type {\n@@ -444,13 +444,13 @@ pub mod write {\n  *\n  * So here is what we do:\n  *\n- *  - Consider the package id; every crate has one (specified with pkgid\n+ *  - Consider the package id; every crate has one (specified with crate_id\n  *    attribute).  If a package id isn't provided explicitly, we infer a\n  *    versionless one from the output name. The version will end up being 0.0\n  *    in this case. CNAME and CVERS are taken from this package id. For\n  *    example, github.com/mozilla/CNAME#CVERS.\n  *\n- *  - Define CMH as SHA256(pkgid).\n+ *  - Define CMH as SHA256(crateid).\n  *\n  *  - Define CMH8 as the first 8 characters of CMH.\n  *\n@@ -469,13 +469,13 @@ pub fn build_link_meta(sess: Session,\n                        symbol_hasher: &mut Sha256)\n                        -> LinkMeta {\n     // This calculates CMH as defined above\n-    fn crate_hash(symbol_hasher: &mut Sha256, pkgid: &PkgId) -> @str {\n+    fn crate_hash(symbol_hasher: &mut Sha256, crateid: &CrateId) -> @str {\n         symbol_hasher.reset();\n-        symbol_hasher.input_str(pkgid.to_str());\n+        symbol_hasher.input_str(crateid.to_str());\n         truncated_hash_result(symbol_hasher).to_managed()\n     }\n \n-    let pkgid = match attr::find_pkgid(attrs) {\n+    let crateid = match attr::find_crateid(attrs) {\n         None => {\n             let stem = session::expect(\n                 sess,\n@@ -487,10 +487,10 @@ pub fn build_link_meta(sess: Session,\n         Some(s) => s,\n     };\n \n-    let hash = crate_hash(symbol_hasher, &pkgid);\n+    let hash = crate_hash(symbol_hasher, &crateid);\n \n     LinkMeta {\n-        pkgid: pkgid,\n+        crateid: crateid,\n         crate_hash: hash,\n     }\n }\n@@ -509,7 +509,7 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(link_meta.pkgid.name);\n+    symbol_hasher.input_str(link_meta.crateid.name);\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash);\n     symbol_hasher.input_str(\"-\");\n@@ -669,7 +669,7 @@ pub fn mangle_exported_name(ccx: &CrateContext,\n     let hash = get_symbol_hash(ccx, t);\n     return exported_name(ccx.sess, path,\n                          hash,\n-                         ccx.link_meta.pkgid.version_or_default());\n+                         ccx.link_meta.crateid.version_or_default());\n }\n \n pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n@@ -710,9 +710,9 @@ pub fn mangle_internal_name_by_path(ccx: &CrateContext, path: path) -> ~str {\n \n pub fn output_lib_filename(lm: &LinkMeta) -> ~str {\n     format!(\"{}-{}-{}\",\n-            lm.pkgid.name,\n+            lm.crateid.name,\n             lm.crate_hash.slice_chars(0, 8),\n-            lm.pkgid.version_or_default())\n+            lm.crateid.version_or_default())\n }\n \n pub fn get_cc_prog(sess: Session) -> ~str {"}, {"sha": "dba811d822feb59c1e6469fabc6338fea9f7a6a9", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -1030,12 +1030,12 @@ pub fn build_output_filenames(input: &input,\n               str_input(_) => @\"rust_out\"\n           };\n \n-          // If a pkgid is present, we use it as the link name\n-          let pkgid = attr::find_pkgid(attrs);\n-          match pkgid {\n+          // If a crateid is present, we use it as the link name\n+          let crateid = attr::find_crateid(attrs);\n+          match crateid {\n               None => {}\n-              Some(pkgid) => {\n-                  stem = pkgid.name.to_managed()\n+              Some(crateid) => {\n+                  stem = crateid.name.to_managed()\n               }\n           }\n "}, {"sha": "7b2697b1d28e9b8a961e14ac93edaca7a20c616c", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -384,7 +384,7 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n }\n \n fn is_extra(crate: &ast::Crate) -> bool {\n-    match attr::find_pkgid(crate.attrs) {\n+    match attr::find_crateid(crate.attrs) {\n         Some(ref s) if \"extra\" == s.name => true,\n         _ => false\n     }"}, {"sha": "828e65b76487043351657ed0af6ff53a6a73a52b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -292,18 +292,18 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n         let t_outputs = d::build_output_filenames(&input, &odir, &ofile,\n                                                   attrs, sess);\n         if crate_id || crate_name {\n-            let pkgid = match attr::find_pkgid(attrs) {\n-                Some(pkgid) => pkgid,\n+            let crateid = match attr::find_crateid(attrs) {\n+                Some(crateid) => crateid,\n                 None => {\n                     sess.fatal(\"No crate_id and --crate-id or \\\n                                 --crate-name requested\")\n                 }\n             };\n             if crate_id {\n-                println(pkgid.to_str());\n+                println(crateid.to_str());\n             }\n             if crate_name {\n-                println(pkgid.name);\n+                println(crateid.name);\n             }\n         }\n "}, {"sha": "8b3d5062e15190c980f6d9d68f54b3f4f2b8f5db", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::cast;\n-use syntax::pkgid::PkgId;\n+use syntax::crateid::CrateId;\n \n // EBML enum definitions and utils shared by the encoder and decoder\n \n@@ -206,6 +206,6 @@ pub static tag_native_libraries_kind: uint = 0x106;\n \n #[deriving(Clone)]\n pub struct LinkMeta {\n-    pkgid: PkgId,\n+    crateid: CrateId,\n     crate_hash: @str,\n }"}, {"sha": "8fa1e5563947f3693a7702731604eca5246c9be0", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -25,7 +25,7 @@ use syntax::codemap::{Span, dummy_sp};\n use syntax::diagnostic::span_handler;\n use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n-use syntax::pkgid::PkgId;\n+use syntax::crateid::CrateId;\n use syntax::visit;\n \n // Traverses an AST, reading all the information about use'd crates and extern\n@@ -73,7 +73,7 @@ struct cache_entry {\n     cnum: ast::CrateNum,\n     span: Span,\n     hash: @str,\n-    pkgid: PkgId,\n+    crateid: CrateId,\n }\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n@@ -89,10 +89,10 @@ fn warn_if_multiple_versions(e: &mut Env,\n                              diag: @mut span_handler,\n                              crate_cache: &[cache_entry]) {\n     if crate_cache.len() != 0u {\n-        let name = crate_cache[crate_cache.len() - 1].pkgid.name.clone();\n+        let name = crate_cache[crate_cache.len() - 1].crateid.name.clone();\n \n         let (matches, non_matches) = crate_cache.partitioned(|entry|\n-            name == entry.pkgid.name);\n+            name == entry.crateid.name);\n \n         assert!(!matches.is_empty());\n \n@@ -101,7 +101,7 @@ fn warn_if_multiple_versions(e: &mut Env,\n                 format!(\"using multiple versions of crate `{}`\", name));\n             for match_ in matches.iter() {\n                 diag.span_note(match_.span, \"used here\");\n-                loader::note_pkgid_attr(diag, &match_.pkgid);\n+                loader::note_crateid_attr(diag, &match_.crateid);\n             }\n         }\n \n@@ -138,15 +138,15 @@ fn visit_view_item(e: &mut Env, i: &ast::view_item) {\n                  ident, path_opt);\n           let (name, version) = match path_opt {\n               Some((path_str, _)) => {\n-                  let pkgid: Option<PkgId> = from_str(path_str);\n-                  match pkgid {\n+                  let crateid: Option<CrateId> = from_str(path_str);\n+                  match crateid {\n                       None => (@\"\", @\"\"),\n-                      Some(pkgid) => {\n-                          let version = match pkgid.version {\n+                      Some(crateid) => {\n+                          let version = match crateid.version {\n                               None => @\"\",\n                               Some(ref ver) => ver.to_managed(),\n                           };\n-                          (pkgid.name.to_managed(), version)\n+                          (crateid.name.to_managed(), version)\n                       }\n                   }\n               }\n@@ -245,12 +245,12 @@ fn visit_item(e: &Env, i: @ast::item) {\n fn existing_match(e: &Env, name: @str, version: @str, hash: &str) -> Option<ast::CrateNum> {\n     let crate_cache = e.crate_cache.borrow();\n     for c in crate_cache.get().iter() {\n-        let pkgid_version = match c.pkgid.version {\n+        let crateid_version = match c.crateid.version {\n             None => @\"0.0\",\n             Some(ref ver) => ver.to_managed(),\n         };\n-        if (name.is_empty() || c.pkgid.name.to_managed() == name) &&\n-            (version.is_empty() || pkgid_version == version) &&\n+        if (name.is_empty() || c.crateid.name.to_managed() == name) &&\n+            (version.is_empty() || crateid_version == version) &&\n             (hash.is_empty() || c.hash.as_slice() == hash) {\n             return Some(c.cnum);\n         }\n@@ -282,7 +282,7 @@ fn resolve_crate(e: &mut Env,\n         } = load_ctxt.load_library_crate();\n \n         let attrs = decoder::get_crate_attributes(metadata.as_slice());\n-        let pkgid = attr::find_pkgid(attrs).unwrap();\n+        let crateid = attr::find_crateid(attrs).unwrap();\n         let hash = decoder::get_crate_hash(metadata.as_slice());\n \n         // Claim this crate number and cache it\n@@ -293,7 +293,7 @@ fn resolve_crate(e: &mut Env,\n                 cnum: cnum,\n                 span: span,\n                 hash: hash,\n-                pkgid: pkgid,\n+                crateid: crateid,\n             });\n         }\n         e.next_crate_num += 1;"}, {"sha": "b4c19c771dc0aacb2c8e112a37e794f0b1ee9ffd", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -1173,9 +1173,9 @@ pub fn get_crate_hash(data: &[u8]) -> @str {\n \n pub fn get_crate_vers(data: &[u8]) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n-    match attr::find_pkgid(attrs) {\n+    match attr::find_crateid(attrs) {\n         None => @\"0.0\",\n-        Some(pkgid) => pkgid.version_or_default().to_managed(),\n+        Some(crateid) => crateid.version_or_default().to_managed(),\n     }\n }\n "}, {"sha": "73b0ac46cbda96cffe978eea5f3bfd468c02ff15", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -1559,19 +1559,19 @@ fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[Attribute]) {\n     ebml_w.end_tag();\n }\n \n-// So there's a special crate attribute called 'pkgid' which defines the\n+// So there's a special crate attribute called 'crate_id' which defines the\n // metadata that Rust cares about for linking crates. If the user didn't\n // provide it we will throw it in anyway with a default value.\n fn synthesize_crate_attrs(ecx: &EncodeContext,\n                           crate: &Crate) -> ~[Attribute] {\n \n-    fn synthesize_pkgid_attr(ecx: &EncodeContext) -> Attribute {\n-        assert!(!ecx.link_meta.pkgid.name.is_empty());\n+    fn synthesize_crateid_attr(ecx: &EncodeContext) -> Attribute {\n+        assert!(!ecx.link_meta.crateid.name.is_empty());\n \n         attr::mk_attr(\n             attr::mk_name_value_item_str(\n                 @\"crate_id\",\n-                ecx.link_meta.pkgid.to_str().to_managed()))\n+                ecx.link_meta.crateid.to_str().to_managed()))\n     }\n \n     let mut attrs = ~[];\n@@ -1580,7 +1580,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n             attrs.push(*attr);\n         }\n     }\n-    attrs.push(synthesize_pkgid_attr(ecx));\n+    attrs.push(synthesize_crateid_attr(ecx));\n \n     attrs\n }"}, {"sha": "481a43d1cedd2581b063b72c602dceaf941c5cd9", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -21,7 +21,7 @@ use metadata::filesearch;\n use syntax::codemap::Span;\n use syntax::diagnostic::span_handler;\n use syntax::parse::token::ident_interner;\n-use syntax::pkgid::PkgId;\n+use syntax::crateid::CrateId;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n \n@@ -112,7 +112,7 @@ impl Context {\n                             Some(cvec) =>\n                                 if crate_matches(cvec.as_slice(), self.name,\n                                                  self.version, self.hash) {\n-                                    debug!(\"found {} with matching pkgid\",\n+                                    debug!(\"found {} with matching crate_id\",\n                                            path.display());\n                                     let (rlib, dylib) = if file.ends_with(\".rlib\") {\n                                         (Some(path.clone()), None)\n@@ -126,7 +126,7 @@ impl Context {\n                                     });\n                                     FileMatches\n                                 } else {\n-                                    debug!(\"skipping {}, pkgid doesn't match\",\n+                                    debug!(\"skipping {}, crate_id doesn't match\",\n                                            path.display());\n                                     FileDoesntMatch\n                                 },\n@@ -165,10 +165,10 @@ impl Context {\n                     }\n                     let data = lib.metadata.as_slice();\n                     let attrs = decoder::get_crate_attributes(data);\n-                    match attr::find_pkgid(attrs) {\n+                    match attr::find_crateid(attrs) {\n                         None => {}\n-                        Some(pkgid) => {\n-                            note_pkgid_attr(self.sess.diagnostic(), &pkgid);\n+                        Some(crateid) => {\n+                            note_crateid_attr(self.sess.diagnostic(), &crateid);\n                         }\n                     }\n                 }\n@@ -231,25 +231,25 @@ impl Context {\n     }\n }\n \n-pub fn note_pkgid_attr(diag: @mut span_handler,\n-                       pkgid: &PkgId) {\n-    diag.handler().note(format!(\"pkgid: {}\", pkgid.to_str()));\n+pub fn note_crateid_attr(diag: @mut span_handler,\n+                       crateid: &CrateId) {\n+    diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()));\n }\n \n fn crate_matches(crate_data: &[u8],\n                  name: @str,\n                  version: @str,\n                  hash: @str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n-    match attr::find_pkgid(attrs) {\n+    match attr::find_crateid(attrs) {\n         None => false,\n-        Some(pkgid) => {\n+        Some(crateid) => {\n             if !hash.is_empty() {\n                 let chash = decoder::get_crate_hash(crate_data);\n                 if chash != hash { return false; }\n             }\n-            name == pkgid.name.to_managed() &&\n-                (version.is_empty() || version == pkgid.version_or_default().to_managed())\n+            name == crateid.name.to_managed() &&\n+                (version.is_empty() || version == crateid.version_or_default().to_managed())\n         }\n     }\n }"}, {"sha": "ce953ab3ab70f7d26ad4e2a3f5f83d189e1ea5fd", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -3048,8 +3048,8 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     let sym_name = if is_top {\n         ~\"_rust_crate_map_toplevel\"\n     } else {\n-        symname(sess, \"_rust_crate_map_\" + mapmeta.pkgid.name, mapmeta.crate_hash,\n-                mapmeta.pkgid.version_or_default())\n+        symname(sess, \"_rust_crate_map_\" + mapmeta.crateid.name, mapmeta.crate_hash,\n+                mapmeta.crateid.version_or_default())\n     };\n \n     let slicetype = Type::struct_([int_type, int_type], false);\n@@ -3168,8 +3168,8 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n                         flate::deflate_bytes(metadata);\n     let llmeta = C_bytes(compressed);\n     let llconst = C_struct([llmeta], false);\n-    let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.pkgid.name,\n-                       cx.link_meta.pkgid.version_or_default(), cx.link_meta.crate_hash);\n+    let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.crateid.name,\n+                       cx.link_meta.crateid.version_or_default(), cx.link_meta.crate_hash);\n     let llglobal = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.metadata_llmod, val_ty(llconst).to_ref(), buf)\n@@ -3205,7 +3205,7 @@ pub fn trans_crate(sess: session::Session,\n     // crashes if the module identifer is same as other symbols\n     // such as a function name in the module.\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let llmod_id = link_meta.pkgid.name.clone() + \".rc\";\n+    let llmod_id = link_meta.crateid.name.clone() + \".rc\";\n \n     let ccx = @CrateContext::new(sess,\n                                      llmod_id,"}, {"sha": "3e9aae4730e34cb6008f1c3fff0d93cd8df0d9e5", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -2827,7 +2827,7 @@ fn namespace_for_item(cx: &CrateContext,\n \n         if def_id.crate == ast::LOCAL_CRATE {\n             // prepend crate name if not already present\n-            let crate_namespace_ident = token::str_to_ident(cx.link_meta.pkgid.name);\n+            let crate_namespace_ident = token::str_to_ident(cx.link_meta.crateid.name);\n             item_path.insert(0, ast_map::path_mod(crate_namespace_ident));\n         }\n "}, {"sha": "9fcd0f458b3b5ae62afe65e81635df2b47b53147", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -1855,7 +1855,7 @@ pub fn trans_log_level(bcx: @Block) -> DatumBlock {\n                 Some(&src) => {\n                     ccx.sess.cstore.get_crate_data(src.crate).name\n                 }\n-                None => ccx.link_meta.pkgid.name.to_managed(),\n+                None => ccx.link_meta.crateid.name.to_managed(),\n             };\n         };\n         let mut modpath = ~[path_mod(ccx.sess.ident_of(srccrate))];"}, {"sha": "ab36079585fc4fd2f8529b1889160f1641ba11ce", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -73,7 +73,7 @@ pub struct Crate {\n \n impl Clean<Crate> for visit_ast::RustdocVisitor {\n     fn clean(&self) -> Crate {\n-        use syntax::attr::find_pkgid;\n+        use syntax::attr::find_crateid;\n         let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n \n         let mut externs = HashMap::new();\n@@ -82,7 +82,7 @@ impl Clean<Crate> for visit_ast::RustdocVisitor {\n         });\n \n         Crate {\n-            name: match find_pkgid(self.attrs) {\n+            name: match find_crateid(self.attrs) {\n                 Some(n) => n.name,\n                 None => fail!(\"rustdoc requires a `crate_id` crate attribute\"),\n             },"}, {"sha": "0730a6fc3a210d35ce2ab7ac2b0ac3ade4798e92", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -10,7 +10,7 @@\n \n use context::*;\n use crate::*;\n-use package_id::*;\n+use crate_id::*;\n use package_source::*;\n use path_util::{platform_library_name, target_build_dir};\n use target::*;\n@@ -92,7 +92,7 @@ pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str,\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n         start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: PkgId{ version: version, ..PkgId::new(name)},\n+        id: CrateId{ version: version, ..CrateId::new(name)},\n         // n.b. This assumes the package only has one crate\n         libs: ~[mk_crate(lib)],\n         mains: ~[],\n@@ -115,7 +115,7 @@ pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str,\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n         start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: PkgId{ version: version, ..PkgId::new(name)},\n+        id: CrateId{ version: version, ..CrateId::new(name)},\n         libs: ~[],\n         // n.b. This assumes the package only has one crate\n         mains: ~[mk_crate(main)],\n@@ -132,8 +132,8 @@ pub fn install_pkg(cx: &BuildContext,\n                    version: Version,\n                    // For now, these inputs are assumed to be inputs to each of the crates\n                    more_inputs: ~[(~str, Path)]) { // pairs of Kind and Path\n-    let pkgid = PkgId{ version: version, ..PkgId::new(name)};\n-    cx.install(PkgSrc::new(workspace.clone(), workspace, false, pkgid),\n+    let crateid = CrateId{ version: version, ..CrateId::new(name)};\n+    cx.install(PkgSrc::new(workspace.clone(), workspace, false, crateid),\n                &WhatToBuild{ build_type: Inferred,\n                              inputs_to_discover: more_inputs,\n                              sources: Everything });\n@@ -157,10 +157,10 @@ pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n     let out_name = workspace_build_dir.join_many([package_name.to_str(),\n                                                   platform_library_name(output)]);\n     // make paths absolute\n-    let pkgid = PkgId::new(package_name);\n+    let crateid = CrateId::new(package_name);\n     let absolute_paths = paths.map(|s| {\n             let whatever = workspace.join_many([~\"src\",\n-                                pkgid.to_str(),\n+                                crateid.to_str(),\n                                 s.to_owned()]);\n             whatever.as_str().unwrap().to_owned()\n         });\n@@ -190,8 +190,8 @@ pub fn my_workspace(context: &Context, package_name: &str) -> Path {\n     use bad_pkg_id     = conditions::bad_pkg_id::cond;\n \n     // (this assumes no particular version is requested)\n-    let pkgid = PkgId::new(package_name);\n-    let workspaces = pkg_parent_workspaces(context, &pkgid);\n+    let crateid = CrateId::new(package_name);\n+    let workspaces = pkg_parent_workspaces(context, &crateid);\n     if workspaces.is_empty() {\n         bad_pkg_id.raise((Path::new(package_name), package_name.to_owned()));\n     }"}, {"sha": "6c38d63a518019a90990c8b1265e154e5be80ceb", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -10,7 +10,7 @@\n \n // Useful conditions\n \n-pub use package_id::PkgId;\n+pub use crate_id::CrateId;\n pub use std::io::FileStat;\n pub use std::io::process::ProcessExit;\n pub use std::path::Path;\n@@ -20,15 +20,15 @@ condition! {\n }\n \n condition! {\n-    pub nonexistent_package: (PkgId, ~str) -> Path;\n+    pub nonexistent_package: (CrateId, ~str) -> Path;\n }\n \n condition! {\n-    pub missing_pkg_files: (PkgId) -> ();\n+    pub missing_pkg_files: (CrateId) -> ();\n }\n \n condition! {\n-    pub bad_pkg_id: (Path, ~str) -> PkgId;\n+    pub bad_pkg_id: (Path, ~str) -> CrateId;\n }\n \n condition! {"}, {"sha": "7ff8417f23c7861a28c783a42a4089ece984bc2a", "filename": "src/librustpkg/crate_id.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fcrate_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fcrate_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate_id.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -17,7 +17,7 @@ use std::hash;\n /// 'github.com/graydon/test'; path must be a relative\n /// path with >=1 component.\n #[deriving(Clone)]\n-pub struct PkgId {\n+pub struct CrateId {\n     /// This is a path, on the local filesystem, referring to where the\n     /// files for this package live. For example:\n     /// github.com/mozilla/quux-whatever (it's assumed that if we're\n@@ -35,14 +35,14 @@ pub struct PkgId {\n     version: Version\n }\n \n-impl Eq for PkgId {\n-    fn eq(&self, other: &PkgId) -> bool {\n+impl Eq for CrateId {\n+    fn eq(&self, other: &CrateId) -> bool {\n         self.path == other.path && self.version == other.version\n     }\n }\n \n-impl PkgId {\n-    pub fn new(s: &str) -> PkgId {\n+impl CrateId {\n+    pub fn new(s: &str) -> CrateId {\n         use conditions::bad_pkg_id::cond;\n \n         let mut given_version = None;\n@@ -60,10 +60,10 @@ impl PkgId {\n \n         let path = Path::new(s);\n         if !path.is_relative() {\n-            return cond.raise((path, ~\"absolute pkgid\"));\n+            return cond.raise((path, ~\"absolute crate_id\"));\n         }\n         if path.filename().is_none() {\n-            return cond.raise((path, ~\"0-length pkgid\"));\n+            return cond.raise((path, ~\"0-length crate_id\"));\n         }\n         let short_name = path.filestem_str().expect(format!(\"Strange path! {}\", s));\n \n@@ -78,7 +78,7 @@ impl PkgId {\n             }\n         };\n \n-        PkgId {\n+        CrateId {\n             path: path.clone(),\n             short_name: short_name.to_owned(),\n             version: version\n@@ -142,7 +142,7 @@ impl Iterator<(Path, Path)> for Prefixes {\n     }\n }\n \n-impl ToStr for PkgId {\n+impl ToStr for CrateId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n         format!(\"{}-{}\", self.path.as_str().unwrap(), self.version.to_str())", "previous_filename": "src/librustpkg/package_id.rs"}, {"sha": "67ba5d2b8e83f822ed2cdd7c0dc59db3179875ad", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -16,7 +16,7 @@ use std::os;\n use std::io;\n use std::io::fs;\n \n-pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n+pub fn list_installed_packages(f: |&CrateId| -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n         let binfiles = {\n@@ -28,7 +28,7 @@ pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n             match exec.filestem_str() {\n                 None => (),\n                 Some(exec_path) => {\n-                    if !f(&PkgId::new(exec_path)) {\n+                    if !f(&CrateId::new(exec_path)) {\n                         return false;\n                     }\n                 }\n@@ -50,7 +50,7 @@ pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n                     let rel_path = rel_p.join(basename);\n                     rel_path.display().with_str(|s| {\n                         debug!(\"Rel name: {}\", s);\n-                        f(&PkgId::new(s));\n+                        f(&CrateId::new(s));\n                     });\n                 }\n                 None => ()\n@@ -78,7 +78,7 @@ pub fn has_library(p: &Path) -> Option<~str> {\n     None\n }\n \n-pub fn package_is_installed(p: &PkgId) -> bool {\n+pub fn package_is_installed(p: &CrateId) -> bool {\n     let mut is_installed = false;\n     list_installed_packages(|installed| {\n         if installed == p {"}, {"sha": "2b54a6d6f1c150da6187a108bbdf6dae882f835a", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -45,7 +45,7 @@ use workspace::determine_destination;\n use context::{Context, BuildContext,\n                        RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n                        LLVMAssemble, LLVMCompileBitcode};\n-use package_id::PkgId;\n+use crate_id::CrateId;\n use package_source::PkgSrc;\n use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n use target::{Main, Tests, MaybeCustom, Inferred, JustOne};\n@@ -59,7 +59,7 @@ mod crate;\n pub mod exit_codes;\n mod installed_packages;\n mod messages;\n-pub mod package_id;\n+pub mod crate_id;\n pub mod package_source;\n mod path_util;\n mod source_control;\n@@ -78,7 +78,7 @@ pub mod usage;\n /// an explicit package script.\n struct PkgScript<'a> {\n     /// Uniquely identifies this package\n-    id: &'a PkgId,\n+    id: &'a CrateId,\n     /// File path for the package script\n     input: Path,\n     /// The session to use *only* for compiling the custom\n@@ -99,7 +99,7 @@ impl<'a> PkgScript<'a> {\n     fn parse<'a>(sysroot: Path,\n                  script: Path,\n                  workspace: &Path,\n-                 id: &'a PkgId) -> PkgScript<'a> {\n+                 id: &'a CrateId) -> PkgScript<'a> {\n         // Get the executable name that was invoked\n         let binary = os::args()[0].to_managed();\n         // Build the rustc session data structures to pass\n@@ -208,10 +208,10 @@ pub trait CtxMethods {\n     fn run(&self, cmd: &str, args: ~[~str]);\n     fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n     /// Returns a pair of the selected package ID, and the destination workspace\n-    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(PkgId, Path)>;\n+    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(CrateId, Path)>;\n     /// Returns the destination workspace\n     fn build(&self, pkg_src: &mut PkgSrc, what: &WhatToBuild);\n-    fn clean(&self, workspace: &Path, id: &PkgId);\n+    fn clean(&self, workspace: &Path, id: &CrateId);\n     fn info(&self);\n     /// Returns a pair. First component is a list of installed paths,\n     /// second is a list of declared and discovered inputs\n@@ -221,24 +221,24 @@ pub trait CtxMethods {\n                         build_workspace: &Path,\n                         build_inputs: &[Path],\n                         target_workspace: &Path,\n-                        id: &PkgId) -> ~[~str];\n+                        id: &CrateId) -> ~[~str];\n     fn prefer(&self, _id: &str, _vers: Option<~str>);\n-    fn test(&self, id: &PkgId, workspace: &Path);\n+    fn test(&self, id: &CrateId, workspace: &Path);\n     fn uninstall(&self, _id: &str, _vers: Option<~str>);\n     fn unprefer(&self, _id: &str, _vers: Option<~str>);\n     fn init(&self);\n }\n \n impl CtxMethods for BuildContext {\n-    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(PkgId, Path)> {\n+    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(CrateId, Path)> {\n         let cwd = os::getcwd();\n \n         if args.len() < 1 {\n             match cwd_to_workspace() {\n                 None  if dir_has_crate_file(&cwd) => {\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n-                    let pkgid = PkgId::new(cwd.filename_str().unwrap());\n-                    let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, pkgid);\n+                    let crateid = CrateId::new(cwd.filename_str().unwrap());\n+                    let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, crateid);\n                     self.build(&mut pkg_src, what);\n                     match pkg_src {\n                         PkgSrc { destination_workspace: ws,\n@@ -248,8 +248,8 @@ impl CtxMethods for BuildContext {\n                     }\n                 }\n                 None => { usage::build(); None }\n-                Some((ws, pkgid)) => {\n-                    let mut pkg_src = PkgSrc::new(ws.clone(), ws, false, pkgid);\n+                Some((ws, crateid)) => {\n+                    let mut pkg_src = PkgSrc::new(ws.clone(), ws, false, crateid);\n                     self.build(&mut pkg_src, what);\n                     match pkg_src {\n                         PkgSrc { destination_workspace: ws,\n@@ -262,23 +262,23 @@ impl CtxMethods for BuildContext {\n         } else {\n             // The package id is presumed to be the first command-line\n             // argument\n-            let pkgid = PkgId::new(args[0].clone());\n+            let crateid = CrateId::new(args[0].clone());\n             let mut dest_ws = default_workspace();\n-            each_pkg_parent_workspace(&self.context, &pkgid, |workspace| {\n+            each_pkg_parent_workspace(&self.context, &crateid, |workspace| {\n                 debug!(\"found pkg {} in workspace {}, trying to build\",\n-                       pkgid.to_str(), workspace.display());\n+                       crateid.to_str(), workspace.display());\n                 dest_ws = determine_destination(os::getcwd(),\n                                                 self.context.use_rust_path_hack,\n                                                 workspace);\n                 let mut pkg_src = PkgSrc::new(workspace.clone(), dest_ws.clone(),\n-                                              false, pkgid.clone());\n+                                              false, crateid.clone());\n                 self.build(&mut pkg_src, what);\n                 true\n             });\n             // n.b. If this builds multiple packages, it only returns the workspace for\n             // the last one. The whole building-multiple-packages-with-the-same-ID is weird\n             // anyway and there are no tests for it, so maybe take it out\n-            Some((pkgid, dest_ws))\n+            Some((crateid, dest_ws))\n         }\n     }\n     fn run(&self, cmd: &str, args: ~[~str]) {\n@@ -293,15 +293,15 @@ impl CtxMethods for BuildContext {\n                         None => { usage::clean(); return }\n                         // tjc: Maybe clean should clean all the packages in the\n                         // current workspace, though?\n-                        Some((ws, pkgid)) => self.clean(&ws, &pkgid)\n+                        Some((ws, crateid)) => self.clean(&ws, &crateid)\n                     }\n \n                 }\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0].clone());\n-                    self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n+                    let crateid = CrateId::new(args[0].clone());\n+                    self.clean(&cwd, &crateid); // tjc: should use workspace, not cwd\n                 }\n             }\n             \"do\" => {\n@@ -320,15 +320,15 @@ impl CtxMethods for BuildContext {\n                         None if dir_has_crate_file(&cwd) => {\n                             // FIXME (#9639): This needs to handle non-utf8 paths\n \n-                            let inferred_pkgid =\n-                                PkgId::new(cwd.filename_str().unwrap());\n+                            let inferred_crateid =\n+                                CrateId::new(cwd.filename_str().unwrap());\n                             self.install(PkgSrc::new(cwd, default_workspace(),\n-                                                     true, inferred_pkgid),\n+                                                     true, inferred_crateid),\n                                          &WhatToBuild::new(MaybeCustom, Everything));\n                         }\n                         None  => { usage::install(); return; }\n-                        Some((ws, pkgid))                => {\n-                            let pkg_src = PkgSrc::new(ws.clone(), ws.clone(), false, pkgid);\n+                        Some((ws, crateid))                => {\n+                            let pkg_src = PkgSrc::new(ws.clone(), ws.clone(), false, crateid);\n                             self.install(pkg_src, &WhatToBuild::new(MaybeCustom,\n                                                                     Everything));\n                       }\n@@ -337,13 +337,13 @@ impl CtxMethods for BuildContext {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0]);\n-                    let workspaces = pkg_parent_workspaces(&self.context, &pkgid);\n+                    let crateid = CrateId::new(args[0]);\n+                    let workspaces = pkg_parent_workspaces(&self.context, &crateid);\n                     debug!(\"package ID = {}, found it in {:?} workspaces\",\n-                           pkgid.to_str(), workspaces.len());\n+                           crateid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n                         let d = default_workspace();\n-                        let src = PkgSrc::new(d.clone(), d, false, pkgid.clone());\n+                        let src = PkgSrc::new(d.clone(), d, false, crateid.clone());\n                         self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n                     }\n                     else {\n@@ -354,7 +354,7 @@ impl CtxMethods for BuildContext {\n                             let src = PkgSrc::new(workspace.clone(),\n                                                   dest,\n                                                   self.context.use_rust_path_hack,\n-                                                  pkgid.clone());\n+                                                  crateid.clone());\n                             self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n                         };\n                     }\n@@ -400,19 +400,19 @@ impl CtxMethods for BuildContext {\n                     return usage::uninstall();\n                 }\n \n-                let pkgid = PkgId::new(args[0]);\n-                if !installed_packages::package_is_installed(&pkgid) {\n+                let crateid = CrateId::new(args[0]);\n+                if !installed_packages::package_is_installed(&crateid) {\n                     warn(format!(\"Package {} doesn't seem to be installed! \\\n                                   Doing nothing.\", args[0]));\n                     return;\n                 }\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n-                    each_pkg_parent_workspace(&self.context, &pkgid, |workspace| {\n-                        path_util::uninstall_package_from(workspace, &pkgid);\n+                    each_pkg_parent_workspace(&self.context, &crateid, |workspace| {\n+                        path_util::uninstall_package_from(workspace, &crateid);\n                         note(format!(\"Uninstalled package {} (was installed in {})\",\n-                                  pkgid.to_str(), workspace.display()));\n+                                  crateid.to_str(), workspace.display()));\n                         true\n                     });\n                 }\n@@ -437,34 +437,34 @@ impl CtxMethods for BuildContext {\n         use conditions::git_checkout_failed::cond;\n \n         let workspace = pkg_src.source_workspace.clone();\n-        let pkgid = pkg_src.id.clone();\n+        let crateid = pkg_src.id.clone();\n \n         debug!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n-                pkgid = {} pkgsrc start_dir = {}\", workspace.display(),\n-               in_rust_path(&workspace), is_git_dir(&workspace.join(&pkgid.path)),\n-               pkgid.to_str(), pkg_src.start_dir.display());\n+                crateid = {} pkgsrc start_dir = {}\", workspace.display(),\n+               in_rust_path(&workspace), is_git_dir(&workspace.join(&crateid.path)),\n+               crateid.to_str(), pkg_src.start_dir.display());\n         debug!(\"build: what to build = {:?}\", what_to_build);\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n-        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(&pkgid.path)) {\n+        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(&crateid.path)) {\n             let mut out_dir = default_workspace().join(\"src\");\n-            out_dir.push(&pkgid.path);\n-            let git_result = source_control::safe_git_clone(&workspace.join(&pkgid.path),\n-                                                            &pkgid.version,\n+            out_dir.push(&crateid.path);\n+            let git_result = source_control::safe_git_clone(&workspace.join(&crateid.path),\n+                                                            &crateid.version,\n                                                             &out_dir);\n             match git_result {\n                 CheckedOutSources => make_read_only(&out_dir),\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                _ => cond.raise((pkgid.path.as_str().unwrap().to_owned(), out_dir.clone()))\n+                _ => cond.raise((crateid.path.as_str().unwrap().to_owned(), out_dir.clone()))\n             };\n             let default_ws = default_workspace();\n             debug!(\"Calling build recursively with {:?} and {:?}\", default_ws.display(),\n-                   pkgid.to_str());\n+                   crateid.to_str());\n             return self.build(&mut PkgSrc::new(default_ws.clone(),\n                                                default_ws,\n                                                false,\n-                                               pkgid.clone()), what_to_build);\n+                                               crateid.clone()), what_to_build);\n         }\n \n         // Is there custom build logic? If so, use it\n@@ -482,7 +482,7 @@ impl CtxMethods for BuildContext {\n                     let subsysroot = sysroot.clone();\n                     let psp = package_script_path.clone();\n                     let ws = workspace.clone();\n-                    let pid = pkgid.clone();\n+                    let pid = crateid.clone();\n                     prep.exec(proc(exec) {\n                         let mut pscript = PkgScript::parse(subsysroot.clone(),\n                                                            psp.clone(),\n@@ -550,7 +550,7 @@ impl CtxMethods for BuildContext {\n         }\n     }\n \n-    fn clean(&self, workspace: &Path, id: &PkgId)  {\n+    fn clean(&self, workspace: &Path, id: &CrateId)  {\n         // Could also support a custom build hook in the pkg\n         // script for cleaning files rustpkg doesn't know about.\n         // Do something reasonable for now\n@@ -616,7 +616,7 @@ impl CtxMethods for BuildContext {\n                         build_workspace: &Path,\n                         build_inputs: &[Path],\n                         target_workspace: &Path,\n-                        id: &PkgId) -> ~[~str] {\n+                        id: &CrateId) -> ~[~str] {\n \n         debug!(\"install_no_build: assuming {} comes from {} with target {}\",\n                id.to_str(), build_workspace.display(), target_workspace.display());\n@@ -705,8 +705,8 @@ impl CtxMethods for BuildContext {\n         fail!(\"prefer not yet implemented\");\n     }\n \n-    fn test(&self, pkgid: &PkgId, workspace: &Path)  {\n-        match built_test_in_workspace(pkgid, workspace) {\n+    fn test(&self, crateid: &CrateId, workspace: &Path)  {\n+        match built_test_in_workspace(crateid, workspace) {\n             Some(test_exec) => {\n                 debug!(\"test: test_exec = {}\", test_exec.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -723,7 +723,7 @@ impl CtxMethods for BuildContext {\n             None => {\n                 error(format!(\"Internal error: test executable for package ID {} in workspace {} \\\n                            wasn't built! Please report this as a bug.\",\n-                           pkgid.to_str(), workspace.display()));\n+                           crateid.to_str(), workspace.display()));\n             }\n         }\n     }"}, {"sha": "651d64aa9d32f50bd214912c4ad6c116077133be", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -11,7 +11,7 @@\n extern mod extra;\n \n use target::*;\n-use package_id::PkgId;\n+use crate_id::CrateId;\n use std::io;\n use std::io::fs;\n use std::os;\n@@ -49,7 +49,7 @@ pub struct PkgSrc {\n     // Directory to start looking in for packages -- normally\n     // this is workspace/src/id but it may be just workspace\n     start_dir: Path,\n-    id: PkgId,\n+    id: CrateId,\n     libs: ~[Crate],\n     mains: ~[Crate],\n     tests: ~[Crate],\n@@ -77,7 +77,7 @@ impl PkgSrc {\n     pub fn new(mut source_workspace: Path,\n                destination_workspace: Path,\n                use_rust_path_hack: bool,\n-               id: PkgId) -> PkgSrc {\n+               id: CrateId) -> PkgSrc {\n         use conditions::nonexistent_package::cond;\n \n         debug!(\"Checking package source for package ID {}, \\\n@@ -133,14 +133,14 @@ impl PkgSrc {\n                 // See if any of the prefixes of this package ID form a valid package ID\n                 // That is, is this a package ID that points into the middle of a workspace?\n                 for (prefix, suffix) in id.prefixes() {\n-                    let package_id = PkgId::new(prefix.as_str().unwrap());\n-                    let path = build_dir.join(&package_id.path);\n+                    let crate_id = CrateId::new(prefix.as_str().unwrap());\n+                    let path = build_dir.join(&crate_id.path);\n                     debug!(\"in loop: checking if {} is a directory\", path.display());\n                     if path.is_dir() {\n                         let ps = PkgSrc::new(source_workspace,\n                                              destination_workspace,\n                                              use_rust_path_hack,\n-                                             package_id);\n+                                             crate_id);\n                         match ps {\n                             PkgSrc {\n                                 source_workspace: source,\n@@ -264,36 +264,36 @@ impl PkgSrc {\n     /// if this was successful, None otherwise. Similarly, if the package id\n     /// refers to a git repo on the local version, also check it out.\n     /// (right now we only support git)\n-    pub fn fetch_git(local: &Path, pkgid: &PkgId) -> Option<Path> {\n+    pub fn fetch_git(local: &Path, crateid: &CrateId) -> Option<Path> {\n         use conditions::git_checkout_failed::cond;\n \n         let cwd = os::getcwd();\n         debug!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n-                pkgid.to_str(), pkgid.path.display(),\n+                crateid.to_str(), crateid.path.display(),\n                 cwd.display(),\n-                pkgid.path.exists());\n+                crateid.path.exists());\n \n-        match safe_git_clone(&pkgid.path, &pkgid.version, local) {\n+        match safe_git_clone(&crateid.path, &crateid.version, local) {\n             CheckedOutSources => {\n                 make_read_only(local);\n                 Some(local.clone())\n             }\n             DirToUse(clone_target) => {\n-                if pkgid.path.components().nth(1).is_none() {\n+                if crateid.path.components().nth(1).is_none() {\n                     // If a non-URL, don't bother trying to fetch\n                     return None;\n                 }\n \n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                let url = format!(\"https://{}\", pkgid.path.as_str().unwrap());\n+                let url = format!(\"https://{}\", crateid.path.as_str().unwrap());\n                 debug!(\"Fetching package: git clone {} {} [version={}]\",\n-                        url, clone_target.display(), pkgid.version.to_str());\n+                        url, clone_target.display(), crateid.version.to_str());\n \n                 let mut failed = false;\n \n                 cond.trap(|_| {\n                     failed = true;\n-                }).inside(|| git_clone_url(url, &clone_target, &pkgid.version));\n+                }).inside(|| git_clone_url(url, &clone_target, &crateid.version));\n \n                 if failed {\n                     return None;"}, {"sha": "1b8a988ab2c5a570fa493aa400a15ccf4548e0fe", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -12,7 +12,7 @@\n \n #[allow(dead_code)];\n \n-pub use package_id::PkgId;\n+pub use crate_id::CrateId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n pub use version::{Version, NoVersion, split_version_general, try_parsing_version};\n pub use rustc::metadata::filesearch::rust_path;\n@@ -59,12 +59,12 @@ pub fn make_dir_rwx_recursive(p: &Path) -> bool {\n // now. Should fix that.\n \n /// True if there's a directory in <workspace> with\n-/// pkgid's short name\n-pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n-    workspace_contains_package_id_(pkgid, workspace, |p| p.join(\"src\")).is_some()\n+/// crateid's short name\n+pub fn workspace_contains_crate_id(crateid: &CrateId, workspace: &Path) -> bool {\n+    workspace_contains_crate_id_(crateid, workspace, |p| p.join(\"src\")).is_some()\n }\n \n-pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n+pub fn workspace_contains_crate_id_(crateid: &CrateId, workspace: &Path,\n // Returns the directory it was actually found in\n              workspace_to_src_dir: |&Path| -> Path) -> Option<Path> {\n     if !workspace.is_dir() {\n@@ -77,14 +77,14 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     let mut found = None;\n     for p in fs::walk_dir(&src_dir) {\n         if p.is_dir() {\n-            if p == src_dir.join(&pkgid.path) || {\n+            if p == src_dir.join(&crateid.path) || {\n                 let pf = p.filename_str();\n                 pf.iter().any(|&g| {\n                     match split_version_general(g, '-') {\n                         None => false,\n                         Some((ref might_match, ref vers)) => {\n-                            *might_match == pkgid.short_name\n-                                && (pkgid.version == *vers || pkgid.version == NoVersion)\n+                            *might_match == crateid.short_name\n+                                && (crateid.version == *vers || crateid.version == NoVersion)\n                         }\n                     }\n                 })\n@@ -96,9 +96,9 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     }\n \n     if found.is_some() {\n-        debug!(\"Found {} in {}\", pkgid.to_str(), workspace.display());\n+        debug!(\"Found {} in {}\", crateid.to_str(), workspace.display());\n     } else {\n-        debug!(\"Didn't find {} in {}\", pkgid.to_str(), workspace.display());\n+        debug!(\"Didn't find {} in {}\", crateid.to_str(), workspace.display());\n     }\n     found\n }\n@@ -126,11 +126,11 @@ fn target_bin_dir(workspace: &Path) -> Path {\n     workspace.join(\"bin\")\n }\n \n-/// Figure out what the executable name for <pkgid> in <workspace>'s build\n+/// Figure out what the executable name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_executable_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n     let mut result = target_build_dir(workspace);\n-    result = mk_output_path(Main, Build, pkgid, result);\n+    result = mk_output_path(Main, Build, crateid, result);\n     debug!(\"built_executable_in_workspace: checking whether {} exists\",\n            result.display());\n     if result.exists() {\n@@ -142,22 +142,22 @@ pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<\n     }\n }\n \n-/// Figure out what the test name for <pkgid> in <workspace>'s build\n+/// Figure out what the test name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    output_in_workspace(pkgid, workspace, Test)\n+pub fn built_test_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n+    output_in_workspace(crateid, workspace, Test)\n }\n \n-/// Figure out what the test name for <pkgid> in <workspace>'s build\n+/// Figure out what the test name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    output_in_workspace(pkgid, workspace, Bench)\n+pub fn built_bench_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n+    output_in_workspace(crateid, workspace, Bench)\n }\n \n-fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Option<Path> {\n+fn output_in_workspace(crateid: &CrateId, workspace: &Path, what: OutputType) -> Option<Path> {\n     let mut result = target_build_dir(workspace);\n     // should use a target-specific subdirectory\n-    result = mk_output_path(what, Build, pkgid, result);\n+    result = mk_output_path(what, Build, crateid, result);\n     debug!(\"output_in_workspace: checking whether {} exists\",\n            result.display());\n     if result.exists() {\n@@ -169,10 +169,11 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n     }\n }\n \n-/// Figure out what the library name for <pkgid> in <workspace>'s build\n+/// Figure out what the library name for <crateid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    library_in_workspace(&pkgid.path, pkgid.short_name, Build, workspace, \"build\", &pkgid.version)\n+pub fn built_library_in_workspace(crateid: &CrateId, workspace: &Path) -> Option<Path> {\n+    library_in_workspace(&crateid.path, crateid.short_name, Build, workspace, \"build\",\n+                         &crateid.version)\n }\n \n /// Does the actual searching stuff\n@@ -292,45 +293,45 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n     abs_path\n }\n \n-/// Returns the executable that would be installed for <pkgid>\n+/// Returns the executable that would be installed for <crateid>\n /// in <workspace>\n /// As a side effect, creates the bin-dir if it doesn't exist\n-pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Main, Install)\n+pub fn target_executable_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n+    target_file_in_workspace(crateid, workspace, Main, Install)\n }\n \n \n-/// Returns the executable that would be installed for <pkgid>\n+/// Returns the executable that would be installed for <crateid>\n /// in <workspace>\n /// As a side effect, creates the lib-dir if it doesn't exist\n-pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n+pub fn target_library_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n     if !workspace.is_dir() {\n         cond.raise(((*workspace).clone(),\n                     format!(\"Workspace supplied to target_library_in_workspace \\\n                              is not a directory! {}\", workspace.display())));\n     }\n-    target_file_in_workspace(pkgid, workspace, Lib, Install)\n+    target_file_in_workspace(crateid, workspace, Lib, Install)\n }\n \n-/// Returns the test executable that would be installed for <pkgid>\n+/// Returns the test executable that would be installed for <crateid>\n /// in <workspace>\n /// note that we *don't* install test executables, so this is just for unit testing\n-pub fn target_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Test, Install)\n+pub fn target_test_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n+    target_file_in_workspace(crateid, workspace, Test, Install)\n }\n \n-/// Returns the bench executable that would be installed for <pkgid>\n+/// Returns the bench executable that would be installed for <crateid>\n /// in <workspace>\n /// note that we *don't* install bench executables, so this is just for unit testing\n-pub fn target_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Bench, Install)\n+pub fn target_bench_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n+    target_file_in_workspace(crateid, workspace, Bench, Install)\n }\n \n \n-/// Returns the path that pkgid `pkgid` would have if placed `where`\n+/// Returns the path that crateid `crateid` would have if placed `where`\n /// in `workspace`\n-fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n+fn target_file_in_workspace(crateid: &CrateId, workspace: &Path,\n                             what: OutputType, where: Target) -> Path {\n     use conditions::bad_path::cond;\n \n@@ -340,33 +341,33 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     // Artifacts in the build directory live in a package-ID-specific subdirectory,\n     // but installed ones don't.\n     let result = match (where, what) {\n-                (Build, _)      => target_build_dir(workspace).join(&pkgid.path),\n+                (Build, _)      => target_build_dir(workspace).join(&crateid.path),\n                 (Install, Lib)  => target_lib_dir(workspace),\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n     if io::result(|| fs::mkdir_recursive(&result, io::UserRWX)).is_err() {\n         cond.raise((result.clone(), format!(\"target_file_in_workspace couldn't \\\n-            create the {} dir (pkgid={}, workspace={}, what={:?}, where={:?}\",\n-            subdir, pkgid.to_str(), workspace.display(), what, where)));\n+            create the {} dir (crateid={}, workspace={}, what={:?}, where={:?}\",\n+            subdir, crateid.to_str(), workspace.display(), what, where)));\n     }\n-    mk_output_path(what, where, pkgid, result)\n+    mk_output_path(what, where, crateid, result)\n }\n \n-/// Return the directory for <pkgid>'s build artifacts in <workspace>.\n+/// Return the directory for <crateid>'s build artifacts in <workspace>.\n /// Creates it if it doesn't exist.\n-pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n+pub fn build_pkg_id_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n     let mut result = target_build_dir(workspace);\n-    result.push(&pkgid.path);\n+    result.push(&crateid.path);\n     debug!(\"Creating build dir {} for package id {}\", result.display(),\n-           pkgid.to_str());\n+           crateid.to_str());\n     fs::mkdir_recursive(&result, io::UserRWX);\n     return result;\n }\n \n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n pub fn mk_output_path(what: OutputType, where: Target,\n-                      pkg_id: &PkgId, workspace: Path) -> Path {\n+                      pkg_id: &CrateId, workspace: Path) -> Path {\n     let short_name_with_version = format!(\"{}-{}\", pkg_id.short_name,\n                                           pkg_id.version.to_str());\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n@@ -399,22 +400,22 @@ pub fn mk_output_path(what: OutputType, where: Target,\n     output_path\n }\n \n-/// Removes files for the package `pkgid`, assuming it's installed in workspace `workspace`\n-pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n+/// Removes files for the package `crateid`, assuming it's installed in workspace `workspace`\n+pub fn uninstall_package_from(workspace: &Path, crateid: &CrateId) {\n     let mut did_something = false;\n-    let installed_bin = target_executable_in_workspace(pkgid, workspace);\n+    let installed_bin = target_executable_in_workspace(crateid, workspace);\n     if installed_bin.exists() {\n         fs::unlink(&installed_bin);\n         did_something = true;\n     }\n-    let installed_lib = target_library_in_workspace(pkgid, workspace);\n+    let installed_lib = target_library_in_workspace(crateid, workspace);\n     if installed_lib.exists() {\n         fs::unlink(&installed_lib);\n         did_something = true;\n     }\n     if !did_something {\n         warn(format!(\"Warning: there don't seem to be any files for {} installed in {}\",\n-             pkgid.to_str(), workspace.display()));\n+             crateid.to_str(), workspace.display()));\n     }\n \n }\n@@ -429,7 +430,7 @@ fn dir_has_file(dir: &Path, file: &str) -> bool {\n     dir.join(file).exists()\n }\n \n-pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {\n+pub fn find_dir_using_rust_path_hack(p: &CrateId) -> Option<Path> {\n     let rp = rust_path();\n     for dir in rp.iter() {\n         // Require that the parent directory match the package ID"}, {"sha": "7f6342dba5c794eb47159475f01ff8d61d9de68c", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 124, "deletions": 123, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -24,7 +24,7 @@ use extra::treemap::TreeMap;\n use extra::getopts::groups::getopts;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n-use package_id::{PkgId};\n+use crate_id::{CrateId};\n use version::{ExactRevision, NoVersion, Version, Tagged};\n use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                target_bench_in_workspace, make_dir_rwx,\n@@ -59,25 +59,25 @@ fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n     }\n }\n \n-fn fake_pkg() -> PkgId {\n+fn fake_pkg() -> CrateId {\n     let sn = ~\"bogus\";\n-    PkgId {\n+    CrateId {\n         path: Path::new(sn.as_slice()),\n         short_name: sn,\n         version: NoVersion\n     }\n }\n \n-fn git_repo_pkg() -> PkgId {\n-    PkgId {\n+fn git_repo_pkg() -> CrateId {\n+    CrateId {\n         path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: NoVersion\n     }\n }\n \n-fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n-    PkgId {\n+fn git_repo_pkg_with_tag(a_tag: ~str) -> CrateId {\n+    CrateId {\n         path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n         short_name: ~\"test-pkg\",\n         version: Tagged(a_tag)\n@@ -302,15 +302,16 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n     }\n }\n \n-fn create_local_package(pkgid: &PkgId) -> TempDir {\n-    let (workspace, parent_dir) = mk_temp_workspace(&pkgid.path, &pkgid.version);\n-    debug!(\"Created empty package dir for {}, returning {}\", pkgid.to_str(), parent_dir.display());\n+fn create_local_package(crateid: &CrateId) -> TempDir {\n+    let (workspace, parent_dir) = mk_temp_workspace(&crateid.path, &crateid.version);\n+    debug!(\"Created empty package dir for {}, returning {}\", crateid.to_str(),\n+           parent_dir.display());\n     workspace\n }\n \n-fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n+fn create_local_package_in(crateid: &CrateId, pkgdir: &Path) -> Path {\n \n-    let package_dir = pkgdir.join_many([~\"src\", pkgid.to_str()]);\n+    let package_dir = pkgdir.join_many([~\"src\", crateid.to_str()]);\n \n     // Create main, lib, test, and bench files\n     fs::mkdir_recursive(&package_dir, io::UserRWX);\n@@ -329,29 +330,29 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n     package_dir\n }\n \n-fn create_local_package_with_test(pkgid: &PkgId) -> TempDir {\n-    debug!(\"Dry run -- would create package {:?} with test\", pkgid);\n-    create_local_package(pkgid) // Already has tests???\n+fn create_local_package_with_test(crateid: &CrateId) -> TempDir {\n+    debug!(\"Dry run -- would create package {:?} with test\", crateid);\n+    create_local_package(crateid) // Already has tests???\n }\n \n-fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> TempDir {\n-    let package_dir = create_local_package(pkgid);\n-    create_local_package_in(subord_pkgid, package_dir.path());\n-    // Write a main.rs file into pkgid that references subord_pkgid\n-    writeFile(&package_dir.path().join_many([~\"src\", pkgid.to_str(), ~\"main.rs\"]),\n+fn create_local_package_with_dep(crateid: &CrateId, subord_crateid: &CrateId) -> TempDir {\n+    let package_dir = create_local_package(crateid);\n+    create_local_package_in(subord_crateid, package_dir.path());\n+    // Write a main.rs file into crateid that references subord_crateid\n+    writeFile(&package_dir.path().join_many([~\"src\", crateid.to_str(), ~\"main.rs\"]),\n               format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n-                   subord_pkgid.short_name));\n-    // Write a lib.rs file into subord_pkgid that has something in it\n-    writeFile(&package_dir.path().join_many([~\"src\", subord_pkgid.to_str(), ~\"lib.rs\"]),\n+                   subord_crateid.short_name));\n+    // Write a lib.rs file into subord_crateid that has something in it\n+    writeFile(&package_dir.path().join_many([~\"src\", subord_crateid.to_str(), ~\"lib.rs\"]),\n               \"pub fn f() {}\");\n     package_dir\n }\n \n-fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n+fn create_local_package_with_custom_build_hook(crateid: &CrateId,\n                                                custom_build_hook: &str) -> TempDir {\n     debug!(\"Dry run -- would create package {} with custom build hook {}\",\n-           pkgid.to_str(), custom_build_hook);\n-    create_local_package(pkgid)\n+           crateid.to_str(), custom_build_hook);\n+    create_local_package(crateid)\n     // actually write the pkg.rs with the custom build hook\n \n }\n@@ -376,18 +377,18 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n \n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n+    let exec = target_executable_in_workspace(&CrateId::new(short_name), repo);\n     exec.exists() && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n+    let exec = built_test_in_workspace(&CrateId::new(short_name), repo);\n     exec.map_default(false, |exec| exec.exists() && is_rwx(&exec))\n }\n \n-fn remove_executable_file(p: &PkgId, workspace: &Path) {\n-    let exec = target_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n+fn remove_executable_file(p: &CrateId, workspace: &Path) {\n+    let exec = target_executable_in_workspace(&CrateId::new(p.short_name), workspace);\n     if exec.exists() {\n         fs::unlink(&exec);\n     }\n@@ -400,15 +401,15 @@ fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n             repo.display(), short_name);\n-    let exec = built_executable_in_workspace(&PkgId::new(short_name), repo);\n+    let exec = built_executable_in_workspace(&CrateId::new(short_name), repo);\n     exec.is_some() && {\n        let execname = exec.get_ref();\n        execname.exists() && is_rwx(execname)\n     }\n }\n \n-fn remove_built_executable_file(p: &PkgId, workspace: &Path) {\n-    let exec = built_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n+fn remove_built_executable_file(p: &CrateId, workspace: &Path) {\n+    let exec = built_executable_in_workspace(&CrateId::new(p.short_name), workspace);\n     match exec {\n         Some(r) => fs::unlink(&r),\n         None    => ()\n@@ -443,7 +444,7 @@ fn assert_built_library_exists(repo: &Path, short_name: &str) {\n \n fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let lib = built_library_in_workspace(&PkgId::new(short_name), repo);\n+    let lib = built_library_in_workspace(&CrateId::new(short_name), repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n         libname.exists() && is_rwx(libname)\n@@ -493,9 +494,9 @@ fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n }\n \n #[cfg(target_os = \"linux\")]\n-fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n+fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n     let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n@@ -513,9 +514,9 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n }\n \n #[cfg(not(target_os = \"linux\"))]\n-fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n+fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n     let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n@@ -532,9 +533,9 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n }\n \n /// Add a comment at the end\n-fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n+fn frob_source_file(workspace: &Path, crateid: &CrateId, filename: &str) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n     let mut maybe_p = None;\n     let maybe_file = pkg_src_dir.join(filename);\n     debug!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n@@ -618,7 +619,7 @@ fn test_install_valid() {\n #[ignore]\n fn test_install_invalid() {\n     let sysroot = test_sysroot();\n-    let pkgid = fake_pkg();\n+    let crateid = fake_pkg();\n     let temp_workspace = TempDir::new(\"test\").expect(\"couldn't create temp dir\");\n     let temp_workspace = temp_workspace.path().clone();\n     let ctxt = fake_ctxt(sysroot, &temp_workspace);\n@@ -628,7 +629,7 @@ fn test_install_invalid() {\n         let pkg_src = PkgSrc::new(temp_workspace.clone(),\n                                   temp_workspace.clone(),\n                                   false,\n-                                  pkgid.clone());\n+                                  crateid.clone());\n         ctxt.install(pkg_src, &WhatToBuild::new(MaybeCustom, Everything));\n     };\n     assert!(result.unwrap_err()\n@@ -637,7 +638,7 @@ fn test_install_invalid() {\n \n #[test]\n fn test_install_valid_external() {\n-    let temp_pkg_id = PkgId::new(\"foo\");\n+    let temp_pkg_id = CrateId::new(\"foo\");\n     let (tempdir, _) = mk_temp_workspace(&temp_pkg_id.path,\n                                          &temp_pkg_id.version);\n     let temp_workspace = tempdir.path();\n@@ -724,7 +725,7 @@ fn test_install_git() {\n }\n \n #[test]\n-fn test_package_ids_must_be_relative_path_like() {\n+fn test_crate_ids_must_be_relative_path_like() {\n     use conditions::bad_pkg_id::cond;\n \n     /*\n@@ -738,30 +739,30 @@ fn test_package_ids_must_be_relative_path_like() {\n \n     */\n \n-    let whatever = PkgId::new(\"foo\");\n+    let whatever = CrateId::new(\"foo\");\n \n     assert_eq!(~\"foo-0.0\", whatever.to_str());\n     assert!(\"github.com/catamorphism/test-pkg-0.0\" ==\n-            PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n+            CrateId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n     cond.trap(|(p, e)| {\n         assert!(p.filename().is_none())\n-        assert!(\"0-length pkgid\" == e);\n+        assert!(\"0-length crate_id\" == e);\n         whatever.clone()\n     }).inside(|| {\n-        let x = PkgId::new(\"\");\n+        let x = CrateId::new(\"\");\n         assert_eq!(~\"foo-0.0\", x.to_str());\n     });\n \n     cond.trap(|(p, e)| {\n         let abs = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         assert_eq!(p, abs);\n-        assert!(\"absolute pkgid\" == e);\n+        assert!(\"absolute crate_id\" == e);\n         whatever.clone()\n     }).inside(|| {\n         let zp = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let z = PkgId::new(zp.as_str().unwrap());\n+        let z = CrateId::new(zp.as_str().unwrap());\n         assert_eq!(~\"foo-0.0\", z.to_str());\n     })\n }\n@@ -785,7 +786,7 @@ fn test_package_version() {\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n     // It won't pick up the 0.4 version because the dir isn't in the RUST_PATH, but...\n-    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version\");\n+    let temp_pkg_id = CrateId::new(\"mockgithub.com/catamorphism/test_pkg_version\");\n     // This should look at the prefix, clone into a workspace, then build.\n     command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg_version\"],\n                       repo);\n@@ -837,7 +838,7 @@ fn test_package_request_version() {\n         }\n         None    => false\n     });\n-    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n+    let temp_pkg_id = CrateId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n     assert!(target_executable_in_workspace(&temp_pkg_id, &repo.join(\".rust\"))\n             == repo.join_many([\".rust\", \"bin\", \"test_pkg_version\"]));\n \n@@ -880,15 +881,15 @@ fn rustpkg_library_target() {\n \n #[test]\n fn rustpkg_local_pkg() {\n-    let dir = create_local_package(&PkgId::new(\"foo\"));\n+    let dir = create_local_package(&CrateId::new(\"foo\"));\n     command_line_test([~\"install\", ~\"foo\"], dir.path());\n     assert_executable_exists(dir.path(), \"foo\");\n }\n \n #[test]\n #[ignore(reason=\"busted\")]\n fn package_script_with_default_build() {\n-    let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n+    let dir = create_local_package(&CrateId::new(\"fancy-lib\"));\n     let dir = dir.path();\n     debug!(\"dir = {}\", dir.display());\n     let mut source = test_sysroot().dir_path();\n@@ -945,7 +946,7 @@ fn rustpkg_clean_no_arg() {\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n-    let res = built_executable_in_workspace(&PkgId::new(\"foo\"), &tmp);\n+    let res = built_executable_in_workspace(&CrateId::new(\"foo\"), &tmp);\n     assert!(!res.as_ref().map_default(false, |m| m.exists()));\n }\n \n@@ -1003,11 +1004,11 @@ fn rust_path_parse() {\n fn test_list() {\n     let dir = TempDir::new(\"test_list\").expect(\"test_list failed\");\n     let dir = dir.path();\n-    let foo = PkgId::new(\"foo\");\n+    let foo = CrateId::new(\"foo\");\n     create_local_package_in(&foo, dir);\n-    let bar = PkgId::new(\"bar\");\n+    let bar = CrateId::new(\"bar\");\n     create_local_package_in(&bar, dir);\n-    let quux = PkgId::new(\"quux\");\n+    let quux = CrateId::new(\"quux\");\n     create_local_package_in(&quux, dir);\n \n // list doesn't output very much right now...\n@@ -1033,9 +1034,9 @@ fn test_list() {\n fn install_remove() {\n     let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n     let dir = dir.path();\n-    let foo = PkgId::new(\"foo\");\n-    let bar = PkgId::new(\"bar\");\n-    let quux = PkgId::new(\"quux\");\n+    let foo = CrateId::new(\"foo\");\n+    let bar = CrateId::new(\"bar\");\n+    let quux = CrateId::new(\"quux\");\n     create_local_package_in(&foo, dir);\n     create_local_package_in(&bar, dir);\n     create_local_package_in(&quux, dir);\n@@ -1062,13 +1063,13 @@ fn install_check_duplicates() {\n     // check invariant that there are no dups in the pkg database\n     let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n     let dir = dir.path();\n-    let foo = PkgId::new(\"foo\");\n+    let foo = CrateId::new(\"foo\");\n     create_local_package_in(&foo, dir);\n \n     command_line_test([~\"install\", ~\"foo\"], dir);\n     command_line_test([~\"install\", ~\"foo\"], dir);\n     let mut contents = ~[];\n-    let check_dups = |p: &PkgId| {\n+    let check_dups = |p: &CrateId| {\n         if contents.contains(p) {\n             fail!(\"package {} appears in `list` output more than once\", p.path.display());\n         }\n@@ -1082,7 +1083,7 @@ fn install_check_duplicates() {\n \n #[test]\n fn no_rebuilding() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1103,7 +1104,7 @@ fn no_rebuilding() {\n #[test]\n #[ignore]\n fn no_recopying() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"install\", ~\"foo\"], workspace);\n@@ -1122,8 +1123,8 @@ fn no_recopying() {\n \n #[test]\n fn no_rebuilding_dep() {\n-    let p_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"bar\");\n+    let p_id = CrateId::new(\"foo\");\n+    let dep_id = CrateId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1141,8 +1142,8 @@ fn no_rebuilding_dep() {\n \n #[test]\n fn do_rebuild_dep_dates_change() {\n-    let p_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"bar\");\n+    let p_id = CrateId::new(\"foo\");\n+    let dep_id = CrateId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1161,8 +1162,8 @@ fn do_rebuild_dep_dates_change() {\n \n #[test]\n fn do_rebuild_dep_only_contents_change() {\n-    let p_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"bar\");\n+    let p_id = CrateId::new(\"foo\");\n+    let dep_id = CrateId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1182,8 +1183,8 @@ fn do_rebuild_dep_only_contents_change() {\n \n #[test]\n fn test_versions() {\n-    let workspace = create_local_package(&PkgId::new(\"foo#0.1\"));\n-    let _other_workspace = create_local_package(&PkgId::new(\"foo#0.2\"));\n+    let workspace = create_local_package(&CrateId::new(\"foo#0.1\"));\n+    let _other_workspace = create_local_package(&CrateId::new(\"foo#0.2\"));\n     command_line_test([~\"install\", ~\"foo#0.1\"], workspace.path());\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n@@ -1193,7 +1194,7 @@ fn test_versions() {\n #[test]\n #[ignore(reason = \"do not yet implemented\")]\n fn test_build_hooks() {\n-    let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\"),\n+    let workspace = create_local_package_with_custom_build_hook(&CrateId::new(\"foo\"),\n                                                                 \"frob\");\n     command_line_test([~\"do\", ~\"foo\", ~\"frob\"], workspace.path());\n }\n@@ -1203,14 +1204,14 @@ fn test_build_hooks() {\n #[ignore(reason = \"info not yet implemented\")]\n fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n-    let workspace = create_local_package(&PkgId::new(\"foo\"));\n+    let workspace = create_local_package(&CrateId::new(\"foo\"));\n     let output = command_line_test([~\"info\", ~\"foo\"], workspace.path());\n     assert_eq!(str::from_utf8_owned(output.output), expected_info);\n }\n \n #[test]\n fn test_uninstall() {\n-    let workspace = create_local_package(&PkgId::new(\"foo\"));\n+    let workspace = create_local_package(&CrateId::new(\"foo\"));\n     command_line_test([~\"uninstall\", ~\"foo\"], workspace.path());\n     let output = command_line_test([~\"list\"], workspace.path());\n     assert!(!str::from_utf8(output.output).contains(\"foo\"));\n@@ -1346,7 +1347,7 @@ fn test_extern_mod_simpler() {\n \n #[test]\n fn test_import_rustpkg() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n@@ -1359,7 +1360,7 @@ fn test_import_rustpkg() {\n \n #[test]\n fn test_macro_pkg_script() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n@@ -1386,7 +1387,7 @@ fn multiple_workspaces() {\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.as_str().unwrap(),\n                                             b_loc.as_str().unwrap()))]);\n-    let c_loc = create_local_package_with_dep(&PkgId::new(\"bar\"), &PkgId::new(\"foo\"));\n+    let c_loc = create_local_package_with_dep(&CrateId::new(\"bar\"), &CrateId::new(\"foo\"));\n     command_line_test_with_env([~\"install\", ~\"bar\"], c_loc.path(), env);\n }\n \n@@ -1399,7 +1400,7 @@ fn rust_path_hack_test(hack_flag: bool) {\n       make sure built files for foo are in B\n       make sure nothing gets built into A or A/../build[lib,bin]\n */\n-   let p_id = PkgId::new(\"foo\");\n+   let p_id = CrateId::new(\"foo\");\n    let workspace = create_local_package(&p_id);\n    let workspace = workspace.path();\n    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n@@ -1524,8 +1525,8 @@ fn rust_path_hack_build_no_arg() {\n \n #[test]\n fn rust_path_hack_build_with_dependency() {\n-    let foo_id = PkgId::new(\"foo\");\n-    let dep_id = PkgId::new(\"dep\");\n+    let foo_id = CrateId::new(\"foo\");\n+    let dep_id = CrateId::new(\"dep\");\n     // Tests that when --rust-path-hack is in effect, dependencies get built\n     // into the destination workspace and not the source directory\n     let work_dir = create_local_package(&foo_id);\n@@ -1573,7 +1574,7 @@ fn rust_path_install_target() {\n \n #[test]\n fn sysroot_flag() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // no-op sysroot setting; I'm not sure how else to test this\n@@ -1589,7 +1590,7 @@ fn sysroot_flag() {\n \n #[test]\n fn compile_flag_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1606,7 +1607,7 @@ fn compile_flag_build() {\n #[test]\n fn compile_flag_fail() {\n     // --no-link shouldn't be accepted for install\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1622,7 +1623,7 @@ fn compile_flag_fail() {\n \n #[test]\n fn notrans_flag_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n@@ -1647,7 +1648,7 @@ fn notrans_flag_build() {\n #[test]\n fn notrans_flag_fail() {\n     // --no-trans shouldn't be accepted for install\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n@@ -1668,7 +1669,7 @@ fn notrans_flag_fail() {\n \n #[test]\n fn dash_S() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1685,7 +1686,7 @@ fn dash_S() {\n \n #[test]\n fn dash_S_fail() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1702,7 +1703,7 @@ fn dash_S_fail() {\n \n #[test]\n fn test_cfg_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // If the cfg flag gets messed up, this won't compile\n@@ -1721,7 +1722,7 @@ fn test_cfg_build() {\n \n #[test]\n fn test_cfg_fail() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]),\n@@ -1740,7 +1741,7 @@ fn test_cfg_fail() {\n \n #[test]\n fn test_emit_llvm_S_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1758,7 +1759,7 @@ fn test_emit_llvm_S_build() {\n \n #[test]\n fn test_emit_llvm_S_fail() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1778,7 +1779,7 @@ fn test_emit_llvm_S_fail() {\n \n #[test]\n fn test_emit_llvm_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1797,7 +1798,7 @@ fn test_emit_llvm_build() {\n \n #[test]\n fn test_emit_llvm_fail() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1818,7 +1819,7 @@ fn test_emit_llvm_fail() {\n \n #[test]\n fn test_linker_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let matches = getopts([], optgroups());\n@@ -1863,7 +1864,7 @@ fn test_build_install_flags_fail() {\n \n #[test]\n fn test_optimized_build() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1877,7 +1878,7 @@ fn test_optimized_build() {\n }\n \n #[test]\n-fn pkgid_pointing_to_subdir() {\n+fn crateid_pointing_to_subdir() {\n     // The actual repo is mockgithub.com/mozilla/some_repo\n     // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n     let workspace = TempDir::new(\"parent_repo\").expect(\"Couldn't create temp dir\");\n@@ -1913,9 +1914,9 @@ fn pkgid_pointing_to_subdir() {\n \n #[test]\n fn test_recursive_deps() {\n-    let a_id = PkgId::new(\"a\");\n-    let b_id = PkgId::new(\"b\");\n-    let c_id = PkgId::new(\"c\");\n+    let a_id = CrateId::new(\"a\");\n+    let b_id = CrateId::new(\"b\");\n+    let c_id = CrateId::new(\"c\");\n     let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n     let b_workspace = b_workspace.path();\n     writeFile(&b_workspace.join_many([\"src\", \"c-0.0\", \"lib.rs\"]),\n@@ -1939,7 +1940,7 @@ fn test_recursive_deps() {\n \n #[test]\n fn test_install_to_rust_path() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let second_workspace = create_local_package(&p_id);\n     let second_workspace = second_workspace.path();\n     let first_workspace = mk_empty_workspace(&Path::new(\"p\"), &NoVersion, \"dest\");\n@@ -1963,7 +1964,7 @@ fn test_install_to_rust_path() {\n \n #[test]\n fn test_target_specific_build_dir() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1979,7 +1980,7 @@ fn test_target_specific_build_dir() {\n \n #[test]\n fn test_target_specific_install_dir() {\n-    let p_id = PkgId::new(\"foo\");\n+    let p_id = CrateId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1998,7 +1999,7 @@ fn test_target_specific_install_dir() {\n #[test]\n #[ignore(reason = \"See #7240\")]\n fn test_dependencies_terminate() {\n-    let b_id = PkgId::new(\"b\");\n+    let b_id = CrateId::new(\"b\");\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n     let b_dir = workspace.join_many([\"src\", \"b-0.0\"]);\n@@ -2011,7 +2012,7 @@ fn test_dependencies_terminate() {\n \n #[test]\n fn install_after_build() {\n-    let b_id = PkgId::new(\"b\");\n+    let b_id = CrateId::new(\"b\");\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"b\"], workspace);\n@@ -2022,7 +2023,7 @@ fn install_after_build() {\n \n #[test]\n fn reinstall() {\n-    let b = PkgId::new(\"b\");\n+    let b = CrateId::new(\"b\");\n     let workspace = create_local_package(&b);\n     let workspace = workspace.path();\n     // 1. Install, then remove executable file, then install again,\n@@ -2061,8 +2062,8 @@ fn correct_package_name_with_rust_path_hack() {\n     */\n \n     // Set RUST_PATH to something containing only the sources for foo\n-    let foo_id = PkgId::new(\"foo\");\n-    let bar_id = PkgId::new(\"bar\");\n+    let foo_id = CrateId::new(\"foo\");\n+    let bar_id = CrateId::new(\"bar\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n@@ -2091,7 +2092,7 @@ fn correct_package_name_with_rust_path_hack() {\n \n #[test]\n fn test_rustpkg_test_creates_exec() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2102,7 +2103,7 @@ fn test_rustpkg_test_creates_exec() {\n \n #[test]\n fn test_rustpkg_test_output() {\n-    let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n+    let workspace = create_local_package_with_test(&CrateId::new(\"foo\"));\n     let output = command_line_test([~\"test\", ~\"foo\"], workspace.path());\n     let output_str = str::from_utf8(output.output);\n     // The first two assertions are separate because test output may\n@@ -2114,7 +2115,7 @@ fn test_rustpkg_test_output() {\n \n #[test]\n fn test_rustpkg_test_failure_exit_status() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2128,7 +2129,7 @@ fn test_rustpkg_test_failure_exit_status() {\n \n #[test]\n fn test_rustpkg_test_cfg() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2141,7 +2142,7 @@ fn test_rustpkg_test_cfg() {\n \n #[test]\n fn test_rebuild_when_needed() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n@@ -2162,7 +2163,7 @@ fn test_rebuild_when_needed() {\n #[test]\n #[ignore] // FIXME (#10257): This doesn't work as is since a read only file can't execute\n fn test_no_rebuilding() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n@@ -2196,7 +2197,7 @@ fn test_installed_read_only() {\n     writeFile(&repo_subdir.join(\"lib.rs\"),\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n-    // update pkgid to what will be auto-detected\n+    // update crateid to what will be auto-detected\n     temp_pkg_id.version = ExactRevision(~\"0.1\");\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -2281,7 +2282,7 @@ fn test_installed_local_changes() {\n \n #[test]\n fn test_7402() {\n-    let dir = create_local_package(&PkgId::new(\"foo\"));\n+    let dir = create_local_package(&CrateId::new(\"foo\"));\n     let dest_workspace = TempDir::new(\"more_rust\").expect(\"test_7402\");\n     let dest_workspace = dest_workspace.path();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -2295,7 +2296,7 @@ fn test_7402() {\n \n #[test]\n fn test_compile_error() {\n-    let foo_id = PkgId::new(\"foo\");\n+    let foo_id = CrateId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let main_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]);\n@@ -2329,7 +2330,7 @@ fn test_c_dependency_ok() {\n     // registers a hook to build it if it's not fresh\n     // After running `build`, test that the C library built\n \n-    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = create_local_package(&CrateId::new(\"cdep\"));\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2352,7 +2353,7 @@ fn test_c_dependency_ok() {\n #[test]\n #[ignore(reason=\"busted\")]\n fn test_c_dependency_no_rebuilding() {\n-    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = create_local_package(&CrateId::new(\"cdep\"));\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2386,7 +2387,7 @@ fn test_c_dependency_no_rebuilding() {\n #[test]\n #[ignore(reason=\"busted\")]\n fn test_c_dependency_yes_rebuilding() {\n-    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = create_local_package(&CrateId::new(\"cdep\"));\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2407,7 +2408,7 @@ fn test_c_dependency_yes_rebuilding() {\n     assert!(c_library_path.exists());\n \n     // Now, make the Rust library read-only so rebuilding will fail\n-    match built_library_in_workspace(&PkgId::new(\"cdep\"), dir) {\n+    match built_library_in_workspace(&CrateId::new(\"cdep\"), dir) {\n         Some(ref pth) => assert!(chmod_read_only(pth)),\n         None => assert_built_library_exists(dir, \"cdep\")\n     }\n@@ -2425,7 +2426,7 @@ fn test_c_dependency_yes_rebuilding() {\n fn correct_error_dependency() {\n     // Supposing a package we're trying to install via a dependency doesn't\n     // exist, we should throw a condition, and not ICE\n-    let workspace_dir = create_local_package(&PkgId::new(\"badpkg\"));\n+    let workspace_dir = create_local_package(&CrateId::new(\"badpkg\"));\n \n     let dir = workspace_dir.path();\n     let main_rs = dir.join_many([\"src\", \"badpkg-0.0\", \"main.rs\"]);"}, {"sha": "4ec752aeb391abffd5c9f0fcf21b169a1733746a", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -29,7 +29,7 @@ use syntax::util::small_vector::SmallVector;\n use rustc::back::link::output_type_exe;\n use rustc::back::link;\n use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n-use package_id::PkgId;\n+use crate_id::CrateId;\n use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n use path_util::{system_library, target_build_dir};\n@@ -52,7 +52,7 @@ static COMMANDS: &'static [&'static str] =\n pub type ExitCode = int; // For now\n \n pub struct Pkg {\n-    id: PkgId,\n+    id: CrateId,\n     bins: ~[~str],\n     libs: ~[~str],\n }\n@@ -170,7 +170,7 @@ pub fn ready_crate(sess: session::Session,\n \n pub fn compile_input(context: &BuildContext,\n                      exec: &mut workcache::Exec,\n-                     pkg_id: &PkgId,\n+                     pkg_id: &CrateId,\n                      in_file: &Path,\n                      workspace: &Path,\n                      deps: &mut DepMap,\n@@ -303,17 +303,17 @@ pub fn compile_input(context: &BuildContext,\n                                       addl_lib_search_paths.get().insert(p);\n                                   });\n \n-    // Inject the pkgid attribute so we get the right package name and version\n+    // Inject the crate_id attribute so we get the right package name and version\n     if !attr::contains_name(crate.attrs, \"crate_id\") {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let pkgid_attr =\n+        let crateid_attr =\n             attr::mk_name_value_item_str(@\"crate_id\",\n                                          format!(\"{}\\\\#{}\",\n                                                  pkg_id.path.as_str().unwrap(),\n                                                  pkg_id.version.to_str()).to_managed());\n \n-        debug!(\"pkgid attr: {:?}\", pkgid_attr);\n-        crate.attrs.push(attr::mk_attr(pkgid_attr));\n+        debug!(\"crateid attr: {:?}\", crateid_attr);\n+        crate.attrs.push(attr::mk_attr(crateid_attr));\n     }\n \n     debug!(\"calling compile_crate_from_input, workspace = {},\n@@ -428,7 +428,7 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n // Called by build_crates\n pub fn compile_crate(ctxt: &BuildContext,\n                      exec: &mut workcache::Exec,\n-                     pkg_id: &PkgId,\n+                     pkg_id: &CrateId,\n                      crate: &Path,\n                      workspace: &Path,\n                      deps: &mut DepMap,\n@@ -446,7 +446,7 @@ pub fn compile_crate(ctxt: &BuildContext,\n \n struct ViewItemVisitor<'a> {\n     context: &'a BuildContext,\n-    parent: &'a PkgId,\n+    parent: &'a CrateId,\n     parent_crate: &'a Path,\n     sess: session::Session,\n     exec: &'a mut workcache::Exec,\n@@ -491,7 +491,7 @@ impl<'a> Visitor<()> for ViewItemVisitor<'a> {\n                         debug!(\"Trying to install library {}, rebuilding it\",\n                                lib_name.to_str());\n                         // Try to install it\n-                        let pkg_id = PkgId::new(lib_name);\n+                        let pkg_id = CrateId::new(lib_name);\n                         // Find all the workspaces in the RUST_PATH that contain this package.\n                         let workspaces = pkg_parent_workspaces(&self.context.context,\n                                                                &pkg_id);\n@@ -607,7 +607,7 @@ impl<'a> Visitor<()> for ViewItemVisitor<'a> {\n /// try to install their targets, failing if any target\n /// can't be found.\n pub fn find_and_install_dependencies(context: &BuildContext,\n-                                     parent: &PkgId,\n+                                     parent: &CrateId,\n                                      parent_crate: &Path,\n                                      sess: session::Session,\n                                      exec: &mut workcache::Exec,"}, {"sha": "d6e617d2d5071fbdc9fa1b7a042d28ab24328f6c", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -13,23 +13,23 @@\n use std::os;\n use std::path::Path;\n use context::Context;\n-use path_util::{workspace_contains_package_id, find_dir_using_rust_path_hack, default_workspace};\n+use path_util::{workspace_contains_crate_id, find_dir_using_rust_path_hack, default_workspace};\n use path_util::rust_path;\n use util::option_to_vec;\n-use package_id::PkgId;\n+use crate_id::CrateId;\n \n pub fn each_pkg_parent_workspace(cx: &Context,\n-                                 pkgid: &PkgId,\n+                                 crateid: &CrateId,\n                                  action: |&Path| -> bool)\n                                  -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n-    let workspaces = pkg_parent_workspaces(cx, pkgid);\n+    let workspaces = pkg_parent_workspaces(cx, crateid);\n     if workspaces.is_empty() {\n         // tjc: make this a condition\n         fail!(\"Package {} not found in any of \\\n                     the following workspaces: {}\",\n-                   pkgid.path.display(),\n+                   crateid.path.display(),\n                    rust_path().map(|p| p.display().to_str()).to_str());\n     }\n     for ws in workspaces.iter() {\n@@ -42,12 +42,12 @@ pub fn each_pkg_parent_workspace(cx: &Context,\n \n /// Given a package ID, return a vector of all of the workspaces in\n /// the RUST_PATH that contain it\n-pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n+pub fn pkg_parent_workspaces(cx: &Context, crateid: &CrateId) -> ~[Path] {\n     let rs: ~[Path] = rust_path().move_iter()\n-        .filter(|ws| workspace_contains_package_id(pkgid, ws))\n+        .filter(|ws| workspace_contains_crate_id(crateid, ws))\n         .collect();\n     if cx.use_rust_path_hack {\n-        rs + option_to_vec(find_dir_using_rust_path_hack(pkgid))\n+        rs + option_to_vec(find_dir_using_rust_path_hack(crateid))\n     }\n     else {\n         rs\n@@ -56,15 +56,15 @@ pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n \n /// Construct a workspace and package-ID name based on the current directory.\n /// This gets used when rustpkg gets invoked without a package-ID argument.\n-pub fn cwd_to_workspace() -> Option<(Path, PkgId)> {\n+pub fn cwd_to_workspace() -> Option<(Path, CrateId)> {\n     let cwd = os::getcwd();\n     for path in rust_path().move_iter() {\n         let srcpath = path.join(\"src\");\n         if srcpath.is_ancestor_of(&cwd) {\n             let rel = cwd.path_relative_from(&srcpath);\n             let rel_s = rel.as_ref().and_then(|p|p.as_str());\n             if rel_s.is_some() {\n-                return Some((path, PkgId::new(rel_s.unwrap())));\n+                return Some((path, CrateId::new(rel_s.unwrap())));\n             }\n         }\n     }"}, {"sha": "f2526c29b9a802b7adf47cf93470670f5d8cabec", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -16,7 +16,7 @@ use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use pkgid::PkgId;\n+use crateid::CrateId;\n \n use std::hashmap::HashSet;\n \n@@ -234,10 +234,10 @@ pub fn find_linkage_metas(attrs: &[Attribute]) -> ~[@MetaItem] {\n     result\n }\n \n-pub fn find_pkgid(attrs: &[Attribute]) -> Option<PkgId> {\n+pub fn find_crateid(attrs: &[Attribute]) -> Option<CrateId> {\n     match first_attr_value_str_by_name(attrs, \"crate_id\") {\n         None => None,\n-        Some(id) => from_str::<PkgId>(id),\n+        Some(id) => from_str::<CrateId>(id),\n     }\n }\n "}, {"sha": "0bb1eec512bf7b1b82027ea09be4635dd013c240", "filename": "src/libsyntax/crateid.rs", "status": "renamed", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// PkgIds identify crates and include the crate name and optionall a path and\n-/// version. In the full form, they look like relative URLs. Example:\n+/// CrateIds identify crates and include the crate name and optionally a path\n+/// and version. In the full form, they look like relative URLs. Example:\n /// `github.com/mozilla/rust#std:1.0` would be a package ID with a path of\n /// `gitub.com/mozilla/rust` and a crate name of `std` with a version of\n /// `1.0`. If no crate name is given after the hash, the name is inferred to\n /// be the last component of the path. If no version is given, it is inferred\n /// to be `0.0`.\n #[deriving(Clone, Eq)]\n-pub struct PkgId {\n+pub struct CrateId {\n     /// A path which represents the codes origin. By convention this is the\n     /// URL, without `http://` or `https://` prefix, to the crate's repository\n     path: ~str,\n@@ -26,7 +26,7 @@ pub struct PkgId {\n     version: Option<~str>,\n }\n \n-impl ToStr for PkgId {\n+impl ToStr for CrateId {\n     fn to_str(&self) -> ~str {\n         let version = match self.version {\n             None => \"0.0\",\n@@ -40,8 +40,8 @@ impl ToStr for PkgId {\n     }\n }\n \n-impl FromStr for PkgId {\n-    fn from_str(s: &str) -> Option<PkgId> {\n+impl FromStr for CrateId {\n+    fn from_str(s: &str) -> Option<CrateId> {\n         let pieces: ~[&str] = s.splitn('#', 1).collect();\n         let path = pieces[0].to_owned();\n \n@@ -78,15 +78,15 @@ impl FromStr for PkgId {\n             (name, version)\n         };\n \n-        Some(PkgId {\n+        Some(CrateId {\n             path: path,\n             name: name,\n             version: version,\n         })\n     }\n }\n \n-impl PkgId {\n+impl CrateId {\n     pub fn version_or_default<'a>(&'a self) -> &'a str {\n         match self.version {\n             None => \"0.0\",\n@@ -97,90 +97,90 @@ impl PkgId {\n \n #[test]\n fn bare_name() {\n-    let pkgid: PkgId = from_str(\"foo\").expect(\"valid pkgid\");\n-    assert_eq!(pkgid.name, ~\"foo\");\n-    assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"foo\");\n+    let crateid: CrateId = from_str(\"foo\").expect(\"valid crateid\");\n+    assert_eq!(crateid.name, ~\"foo\");\n+    assert_eq!(crateid.version, None);\n+    assert_eq!(crateid.path, ~\"foo\");\n }\n \n #[test]\n fn bare_name_single_char() {\n-    let pkgid: PkgId = from_str(\"f\").expect(\"valid pkgid\");\n-    assert_eq!(pkgid.name, ~\"f\");\n-    assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"f\");\n+    let crateid: CrateId = from_str(\"f\").expect(\"valid crateid\");\n+    assert_eq!(crateid.name, ~\"f\");\n+    assert_eq!(crateid.version, None);\n+    assert_eq!(crateid.path, ~\"f\");\n }\n \n #[test]\n-fn empty_pkgid() {\n-    let pkgid: Option<PkgId> = from_str(\"\");\n-    assert!(pkgid.is_none());\n+fn empty_crateid() {\n+    let crateid: Option<CrateId> = from_str(\"\");\n+    assert!(crateid.is_none());\n }\n \n #[test]\n fn simple_path() {\n-    let pkgid: PkgId = from_str(\"example.com/foo/bar\").expect(\"valid pkgid\");\n-    assert_eq!(pkgid.name, ~\"bar\");\n-    assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"example.com/foo/bar\");\n+    let crateid: CrateId = from_str(\"example.com/foo/bar\").expect(\"valid crateid\");\n+    assert_eq!(crateid.name, ~\"bar\");\n+    assert_eq!(crateid.version, None);\n+    assert_eq!(crateid.path, ~\"example.com/foo/bar\");\n }\n \n #[test]\n fn simple_version() {\n-    let pkgid: PkgId = from_str(\"foo#1.0\").expect(\"valid pkgid\");\n-    assert_eq!(pkgid.name, ~\"foo\");\n-    assert_eq!(pkgid.version, Some(~\"1.0\"));\n-    assert_eq!(pkgid.path, ~\"foo\");\n+    let crateid: CrateId = from_str(\"foo#1.0\").expect(\"valid crateid\");\n+    assert_eq!(crateid.name, ~\"foo\");\n+    assert_eq!(crateid.version, Some(~\"1.0\"));\n+    assert_eq!(crateid.path, ~\"foo\");\n }\n \n #[test]\n fn absolute_path() {\n-    let pkgid: Option<PkgId> = from_str(\"/foo/bar\");\n-    assert!(pkgid.is_none());\n+    let crateid: Option<CrateId> = from_str(\"/foo/bar\");\n+    assert!(crateid.is_none());\n }\n \n #[test]\n fn path_ends_with_slash() {\n-    let pkgid: Option<PkgId> = from_str(\"foo/bar/\");\n-    assert!(pkgid.is_none());\n+    let crateid: Option<CrateId> = from_str(\"foo/bar/\");\n+    assert!(crateid.is_none());\n }\n \n #[test]\n fn path_and_version() {\n-    let pkgid: PkgId = from_str(\"example.com/foo/bar#1.0\").expect(\"valid pkgid\");\n-    assert_eq!(pkgid.name, ~\"bar\");\n-    assert_eq!(pkgid.version, Some(~\"1.0\"));\n-    assert_eq!(pkgid.path, ~\"example.com/foo/bar\");\n+    let crateid: CrateId = from_str(\"example.com/foo/bar#1.0\").expect(\"valid crateid\");\n+    assert_eq!(crateid.name, ~\"bar\");\n+    assert_eq!(crateid.version, Some(~\"1.0\"));\n+    assert_eq!(crateid.path, ~\"example.com/foo/bar\");\n }\n \n #[test]\n fn single_chars() {\n-    let pkgid: PkgId = from_str(\"a/b#1\").expect(\"valid pkgid\");\n-    assert_eq!(pkgid.name, ~\"b\");\n-    assert_eq!(pkgid.version, Some(~\"1\"));\n-    assert_eq!(pkgid.path, ~\"a/b\");\n+    let crateid: CrateId = from_str(\"a/b#1\").expect(\"valid crateid\");\n+    assert_eq!(crateid.name, ~\"b\");\n+    assert_eq!(crateid.version, Some(~\"1\"));\n+    assert_eq!(crateid.path, ~\"a/b\");\n }\n \n #[test]\n fn missing_version() {\n-    let pkgid: PkgId = from_str(\"foo#\").expect(\"valid pkgid\");\n-    assert_eq!(pkgid.name, ~\"foo\");\n-    assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"foo\");\n+    let crateid: CrateId = from_str(\"foo#\").expect(\"valid crateid\");\n+    assert_eq!(crateid.name, ~\"foo\");\n+    assert_eq!(crateid.version, None);\n+    assert_eq!(crateid.path, ~\"foo\");\n }\n \n #[test]\n fn path_and_name() {\n-    let pkgid: PkgId = from_str(\"foo/rust-bar#bar:1.0\").expect(\"valid pkgid\");\n-    assert_eq!(pkgid.name, ~\"bar\");\n-    assert_eq!(pkgid.version, Some(~\"1.0\"));\n-    assert_eq!(pkgid.path, ~\"foo/rust-bar\");\n+    let crateid: CrateId = from_str(\"foo/rust-bar#bar:1.0\").expect(\"valid crateid\");\n+    assert_eq!(crateid.name, ~\"bar\");\n+    assert_eq!(crateid.version, Some(~\"1.0\"));\n+    assert_eq!(crateid.path, ~\"foo/rust-bar\");\n }\n \n #[test]\n fn empty_name() {\n-    let pkgid: PkgId = from_str(\"foo/bar#:1.0\").expect(\"valid pkgid\");\n-    assert_eq!(pkgid.name, ~\"bar\");\n-    assert_eq!(pkgid.version, Some(~\"1.0\"));\n-    assert_eq!(pkgid.path, ~\"foo/bar\");\n+    let crateid: CrateId = from_str(\"foo/bar#:1.0\").expect(\"valid crateid\");\n+    assert_eq!(crateid.name, ~\"bar\");\n+    assert_eq!(crateid.version, Some(~\"1.0\"));\n+    assert_eq!(crateid.path, ~\"foo/bar\");\n }", "previous_filename": "src/libsyntax/pkgid.rs"}, {"sha": "9631849235e8628d3253f078084acc6b5e730db5", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -47,7 +47,7 @@ pub mod fold;\n \n \n pub mod parse;\n-pub mod pkgid;\n+pub mod crateid;\n \n pub mod print {\n     pub mod pp;"}, {"sha": "3b8eda8f78388ee69aa2ae5d251d433d5ea6b25a", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f37b746699c377bce4a983834efe5162081a61dd/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37b746699c377bce4a983834efe5162081a61dd/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=f37b746699c377bce4a983834efe5162081a61dd", "patch": "@@ -8,23 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct PkgId {\n+pub struct CrateId {\n     local_path: ~str,\n     junk: ~str\n }\n \n-impl PkgId {\n-    fn new(s: &str) -> PkgId {\n-        PkgId {\n+impl CrateId {\n+    fn new(s: &str) -> CrateId {\n+        CrateId {\n             local_path: s.to_owned(),\n             junk: ~\"wutevs\"\n         }\n     }\n }\n \n pub fn remove_package_from_database() {\n-    let mut lines_to_use: ~[&PkgId] = ~[]; //~ ERROR cannot infer an appropriate lifetime\n-    let push_id = |installed_id: &PkgId| {\n+    let mut lines_to_use: ~[&CrateId] = ~[]; //~ ERROR cannot infer an appropriate lifetime\n+    let push_id = |installed_id: &CrateId| {\n         lines_to_use.push(installed_id);\n     };\n     list_database(push_id);\n@@ -35,11 +35,11 @@ pub fn remove_package_from_database() {\n \n }\n \n-pub fn list_database(f: |&PkgId|) {\n+pub fn list_database(f: |&CrateId|) {\n     let stuff = [\"foo\", \"bar\"];\n \n     for l in stuff.iter() {\n-        f(&PkgId::new(*l));\n+        f(&CrateId::new(*l));\n     }\n }\n "}]}