{"sha": "df7ce33b3dc6455ce954100241b3b3494295674e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmN2NlMzNiM2RjNjQ1NWNlOTU0MTAwMjQxYjNiMzQ5NDI5NTY3NGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-18T17:14:28Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-18T17:14:28Z"}, "message": "rustdoc: Make rustdoc no longer resolve names.\n\nIt relies on being able to ignore errors, which doesn't make sense; resolve\nis meaningless if errors are ignored. It also doesn't perform macro expansion.\nMost of what is affected will be reexports, which are changing anyway.", "tree": {"sha": "a9658a8cb003a416629aa5ef4d1ca9861e651737", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9658a8cb003a416629aa5ef4d1ca9861e651737"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df7ce33b3dc6455ce954100241b3b3494295674e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df7ce33b3dc6455ce954100241b3b3494295674e", "html_url": "https://github.com/rust-lang/rust/commit/df7ce33b3dc6455ce954100241b3b3494295674e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df7ce33b3dc6455ce954100241b3b3494295674e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30d94fe9a2fe9c526e63700da3f3012f579caafd", "url": "https://api.github.com/repos/rust-lang/rust/commits/30d94fe9a2fe9c526e63700da3f3012f579caafd", "html_url": "https://github.com/rust-lang/rust/commit/30d94fe9a2fe9c526e63700da3f3012f579caafd"}], "stats": {"total": 863, "additions": 11, "deletions": 852}, "files": [{"sha": "cb081c00d36e3ce3908cd2b8a10f1cb594827877", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 11, "deletions": 73, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/df7ce33b3dc6455ce954100241b3b3494295674e/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7ce33b3dc6455ce954100241b3b3494295674e/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=df7ce33b3dc6455ce954100241b3b3494295674e", "patch": "@@ -20,8 +20,6 @@ import syntax::ast_map;\n import rustc::back::link;\n import rustc::metadata::filesearch;\n import rustc::front;\n-import rustc::middle::resolve;\n-import rustc::middle::resolve3;\n \n export ctxt;\n export ctxt_handler;\n@@ -32,9 +30,7 @@ export exec;\n \n type ctxt = {\n     ast: @ast::crate,\n-    ast_map: ast_map::map,\n-    exp_map: resolve::exp_map,\n-    impl_map: resolve::impl_map\n+    ast_map: ast_map::map\n };\n \n type srv_owner<T> = fn(srv: srv) -> T;\n@@ -72,12 +68,11 @@ fn run<T>(owner: srv_owner<T>, source: ~str, +parse: parser) -> T {\n }\n \n fn act(po: comm::port<msg>, source: ~str, parse: parser) {\n-    let (sess, ignore_errors) = build_session();\n+    let sess = build_session();\n \n     let ctxt = build_ctxt(\n         sess,\n-        parse(sess, source),\n-        ignore_errors\n+        parse(sess, source)\n     );\n \n     let mut keep_going = true;\n@@ -107,41 +102,34 @@ fn exec<T:send>(\n }\n \n fn build_ctxt(sess: session,\n-              ast: @ast::crate,\n-              ignore_errors: @mut bool) -> ctxt {\n+              ast: @ast::crate) -> ctxt {\n \n     import rustc::front::config;\n \n     let ast = config::strip_unconfigured_items(ast);\n     let ast = front::test::modify_for_testing(sess, ast);\n     let ast_map = ast_map::map_crate(sess.diagnostic(), *ast);\n-    *ignore_errors = true;\n-    let {exp_map, impl_map, _} = resolve3::resolve_crate(sess, ast_map, ast);\n-    *ignore_errors = false;\n \n     {\n         ast: ast,\n         ast_map: ast_map,\n-        exp_map: exp_map,\n-        impl_map: impl_map\n     }\n }\n \n-fn build_session() -> (session, @mut bool) {\n+fn build_session() -> session {\n     let sopts: @options = basic_options();\n     let codemap = codemap::new_codemap();\n     let error_handlers = build_error_handlers(codemap);\n-    let {emitter, span_handler, ignore_errors} = error_handlers;\n+    let {emitter, span_handler} = error_handlers;\n \n     let session = driver::build_session_(sopts, codemap, emitter,\n                                          span_handler);\n-    (session, ignore_errors)\n+    session\n }\n \n type error_handlers = {\n     emitter: diagnostic::emitter,\n-    span_handler: diagnostic::span_handler,\n-    ignore_errors: @mut bool\n+    span_handler: diagnostic::span_handler\n };\n \n // Build a custom error handler that will allow us to ignore non-fatal\n@@ -152,16 +140,13 @@ fn build_error_handlers(\n \n     type diagnostic_handler = {\n         inner: diagnostic::handler,\n-        ignore_errors: @mut bool\n     };\n \n     impl of diagnostic::handler for diagnostic_handler {\n         fn fatal(msg: ~str) -> ! { self.inner.fatal(msg) }\n         fn err(msg: ~str) { self.inner.err(msg) }\n         fn bump_err_count() {\n-            if !(*self.ignore_errors) {\n-                self.inner.bump_err_count();\n-            }\n+            self.inner.bump_err_count();\n         }\n         fn has_errors() -> bool { self.inner.has_errors() }\n         fn abort_if_errors() { self.inner.abort_if_errors() }\n@@ -175,25 +160,20 @@ fn build_error_handlers(\n         }\n     }\n \n-    let ignore_errors = @mut false;\n     let emitter = fn@(cmsp: option<(codemap::codemap, codemap::span)>,\n                        msg: ~str, lvl: diagnostic::level) {\n-        if !(*ignore_errors) {\n-            diagnostic::emit(cmsp, msg, lvl);\n-        }\n+        diagnostic::emit(cmsp, msg, lvl);\n     };\n     let inner_handler = diagnostic::mk_handler(some(emitter));\n     let handler = {\n         inner: inner_handler,\n-        ignore_errors: ignore_errors\n     };\n     let span_handler = diagnostic::mk_span_handler(\n         handler as diagnostic::handler, codemap);\n \n     {\n         emitter: emitter,\n-        span_handler: span_handler,\n-        ignore_errors: ignore_errors\n+        span_handler: span_handler\n     }\n }\n \n@@ -217,48 +197,6 @@ fn srv_should_build_ast_map() {\n     }\n }\n \n-#[test]\n-fn srv_should_build_reexport_map() {\n-    let source = ~\"import a::b; export b; mod a { mod b { } }\";\n-    do from_str(source) |srv| {\n-        do exec(srv) |ctxt| {\n-            assert ctxt.exp_map.size() != 0u\n-        };\n-    }\n-}\n-\n-#[test]\n-fn srv_should_resolve_external_crates() {\n-    let source = ~\"use std;\\\n-                  fn f() -> std::sha1::sha1 {\\\n-                  std::sha1::mk_sha1() }\";\n-    // Just testing that resolve doesn't crash\n-    from_str(source, |_srv| { } )\n-}\n-\n-#[test]\n-fn srv_should_resolve_core_crate() {\n-    let source = ~\"fn a() -> option { fail }\";\n-    // Just testing that resolve doesn't crash\n-    from_str(source, |_srv| { } )\n-}\n-\n-#[test]\n-fn srv_should_resolve_non_existant_imports() {\n-    // XXX: XFAIL'd\n-\n-    // We want to ignore things we can't resolve. Shouldn't\n-    // need to be able to find external crates to create docs.\n-    //let source = ~\"import wooboo; fn a() { }\";\n-    //from_str(source, |_srv| { } )\n-}\n-\n-#[test]\n-fn srv_should_resolve_non_existant_uses() {\n-    let source = ~\"use forble; fn a() { }\";\n-    from_str(source, |_srv| { } )\n-}\n-\n #[test]\n fn should_ignore_external_import_paths_that_dont_exist() {\n     let source = ~\"use forble; import forble::bippy;\";"}, {"sha": "03d8a3de127ac7bf61272375cba97975054b2eb2", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "removed", "additions": 0, "deletions": 247, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/30d94fe9a2fe9c526e63700da3f3012f579caafd/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d94fe9a2fe9c526e63700da3f3012f579caafd/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=30d94fe9a2fe9c526e63700da3f3012f579caafd", "patch": "@@ -1,247 +0,0 @@\n-//! Prunes branches of the tree that are not exported\n-\n-import doc::item_utils;\n-import syntax::ast;\n-import syntax::ast_util;\n-import syntax::ast_map;\n-import std::map::hashmap;\n-\n-export mk_pass;\n-\n-fn mk_pass() -> pass {\n-    {\n-        name: ~\"prune_unexported\",\n-        f: run\n-    }\n-}\n-\n-fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n-    let fold = fold::fold({\n-        fold_mod: fold_mod\n-        with *fold::default_any_fold(srv)\n-    });\n-    fold.fold_doc(fold, doc)\n-}\n-\n-fn fold_mod(fold: fold::fold<astsrv::srv>, doc: doc::moddoc) -> doc::moddoc {\n-    let doc = fold::default_any_fold_mod(fold, doc);\n-    doc::moddoc_({\n-        items: exported_items(fold.ctxt, doc)\n-        with *doc\n-    })\n-}\n-\n-fn exported_items(srv: astsrv::srv, doc: doc::moddoc) -> ~[doc::itemtag] {\n-    exported_things(\n-        srv, doc,\n-        exported_items_from_crate,\n-        exported_items_from_mod\n-    )\n-}\n-\n-fn exported_things<T>(\n-    srv: astsrv::srv,\n-    doc: doc::moddoc,\n-    from_crate: fn(astsrv::srv, doc::moddoc) -> ~[T],\n-    from_mod: fn(astsrv::srv, doc::moddoc) -> ~[T]\n-) -> ~[T] {\n-    if doc.id() == ast::crate_node_id {\n-        from_crate(srv, doc)\n-    } else {\n-        from_mod(srv, doc)\n-    }\n-}\n-\n-fn exported_items_from_crate(\n-    srv: astsrv::srv,\n-    doc: doc::moddoc\n-) -> ~[doc::itemtag] {\n-    exported_items_from(srv, doc, is_exported_from_crate)\n-}\n-\n-fn exported_items_from_mod(\n-    srv: astsrv::srv,\n-    doc: doc::moddoc\n-) -> ~[doc::itemtag] {\n-    exported_items_from(srv, doc, |a,b| {\n-        is_exported_from_mod(a, doc.id(), b)\n-    })\n-}\n-\n-fn exported_items_from(\n-    srv: astsrv::srv,\n-    doc: doc::moddoc,\n-    is_exported: fn(astsrv::srv, ~str) -> bool\n-) -> ~[doc::itemtag] {\n-    do vec::filter_map(doc.items) |itemtag| {\n-        let itemtag = alt itemtag {\n-          doc::enumtag(enumdoc) {\n-            // Also need to check variant exportedness\n-            doc::enumtag({\n-                variants: exported_variants_from(srv, enumdoc, is_exported)\n-                with enumdoc\n-            })\n-          }\n-          _ { itemtag }\n-        };\n-\n-        if itemtag.item().reexport || is_exported(srv, itemtag.name()) {\n-            some(itemtag)\n-        } else {\n-            none\n-        }\n-    }\n-}\n-\n-fn exported_variants_from(\n-    srv: astsrv::srv,\n-    doc: doc::enumdoc,\n-    is_exported: fn(astsrv::srv, ~str) -> bool\n-) -> ~[doc::variantdoc] {\n-    do vec::filter_map(doc.variants) |doc| {\n-        if is_exported(srv, doc.name) {\n-            some(doc)\n-        } else {\n-            none\n-        }\n-    }\n-}\n-\n-fn is_exported_from_mod(\n-    srv: astsrv::srv,\n-    mod_id: doc::ast_id,\n-    item_name: ~str\n-) -> bool {\n-    do astsrv::exec(srv) |ctxt| {\n-        alt ctxt.ast_map.get(mod_id) {\n-          ast_map::node_item(item, _) {\n-            alt item.node {\n-              ast::item_mod(m) {\n-                ast_util::is_exported(@item_name, m)\n-              }\n-              _ {\n-                fail ~\"is_exported_from_mod: not a mod\";\n-              }\n-            }\n-          }\n-          _ { fail ~\"is_exported_from_mod: not an item\"; }\n-        }\n-    }\n-}\n-\n-fn is_exported_from_crate(\n-    srv: astsrv::srv,\n-    item_name: ~str\n-) -> bool {\n-    do astsrv::exec(srv) |ctxt| {\n-        ast_util::is_exported(@item_name, ctxt.ast.node.module)\n-    }\n-}\n-\n-#[test]\n-fn should_prune_unexported_fns() {\n-    let doc = test::mk_doc(~\"mod b { export a; fn a() { } fn b() { } }\");\n-    assert vec::len(doc.cratemod().mods()[0].fns()) == 1u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_fns_from_top_mod() {\n-    let doc = test::mk_doc(~\"export a; fn a() { } fn b() { }\");\n-    assert vec::len(doc.cratemod().fns()) == 1u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_modules() {\n-    let doc = test::mk_doc(~\"mod a { export a; mod a { } mod b { } }\");\n-    assert vec::len(doc.cratemod().mods()[0].mods()) == 1u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_modules_from_top_mod() {\n-    let doc = test::mk_doc(~\"export a; mod a { } mod b { }\");\n-    assert vec::len(doc.cratemod().mods()) == 1u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_consts() {\n-    let doc = test::mk_doc(\n-        ~\"mod a { export a; \\\n-         const a: bool = true; \\\n-         const b: bool = true; }\");\n-    assert vec::len(doc.cratemod().mods()[0].consts()) == 1u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_consts_from_top_mod() {\n-    let doc = test::mk_doc(\n-        ~\"export a; const a: bool = true; const b: bool = true;\");\n-    assert vec::len(doc.cratemod().consts()) == 1u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_enums_from_top_mod() {\n-    let doc = test::mk_doc(~\"export a; mod a { } enum b { c }\");\n-    assert vec::len(doc.cratemod().enums()) == 0u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_enums() {\n-    let doc = test::mk_doc(~\"mod a { export a; mod a { } enum b { c } }\");\n-    assert vec::len(doc.cratemod().mods()[0].enums()) == 0u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_variants_from_top_mod() {\n-    let doc = test::mk_doc(~\"export b::{}; enum b { c }\");\n-    assert vec::len(doc.cratemod().enums()[0].variants) == 0u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_variants() {\n-    let doc = test::mk_doc(~\"mod a { export b::{}; enum b { c } }\");\n-    assert vec::len(doc.cratemod().mods()[0].enums()[0].variants) == 0u;\n-}\n-\n-#[test]\n-fn should_prune_unexported_traits_from_top_mod() {\n-    let doc = test::mk_doc(~\"export a; mod a { } iface b { fn c(); }\");\n-    assert vec::is_empty(doc.cratemod().traits());\n-}\n-\n-#[test]\n-fn should_prune_unexported_impls_from_top_mod() {\n-    let doc = test::mk_doc(\n-        ~\"export a; mod a { } impl b for int { fn c() { } }\");\n-    assert vec::is_empty(doc.cratemod().impls())\n-}\n-\n-#[test]\n-fn should_prune_unexported_types() {\n-    let doc = test::mk_doc(~\"export a; mod a { } type b = int;\");\n-    assert vec::is_empty(doc.cratemod().types());\n-}\n-\n-#[test]\n-fn should_not_prune_reexports() {\n-    fn mk_doc(source: ~str) -> doc::doc {\n-        do astsrv::from_str(source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            let doc = reexport_pass::mk_pass().f(srv, doc);\n-            run(srv, doc)\n-        }\n-    }\n-    let doc = mk_doc(~\"import a::b; \\\n-                      export b; \\\n-                      mod a { fn b() { } }\");\n-    assert vec::is_not_empty(doc.cratemod().fns());\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    fn mk_doc(source: ~str) -> doc::doc {\n-        do astsrv::from_str(source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            run(srv, doc)\n-        }\n-    }\n-}"}, {"sha": "29f76d162259875aaedb5efb87f891988e5c7e38", "filename": "src/rustdoc/reexport_pass.rs", "status": "removed", "additions": 0, "deletions": 528, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/30d94fe9a2fe9c526e63700da3f3012f579caafd/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d94fe9a2fe9c526e63700da3f3012f579caafd/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=30d94fe9a2fe9c526e63700da3f3012f579caafd", "patch": "@@ -1,528 +0,0 @@\n-//! Finds docs for reexported items and duplicates them\n-\n-import doc::item_utils;\n-import std::map;\n-import std::map::hashmap;\n-import std::list;\n-import syntax::ast;\n-import syntax::ast_util;\n-import syntax::ast_map;\n-import syntax::visit;\n-import syntax::codemap;\n-import rustc::middle::resolve;\n-\n-export mk_pass;\n-\n-fn mk_pass() -> pass {\n-    {\n-        name: ~\"reexport\",\n-        f: run\n-    }\n-}\n-\n-type def_set = map::set<ast::def_id>;\n-type def_map = map::hashmap<ast::def_id, doc::itemtag>;\n-type path_map = map::hashmap<~str, ~[(~str, doc::itemtag)]>;\n-\n-fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n-\n-    // First gather the set of defs that are used as reexports\n-    let def_set = build_reexport_def_set(srv);\n-\n-    // Now find the docs that go with those defs\n-    let def_map = build_reexport_def_map(srv, doc, def_set);\n-\n-    // Now create a map that tells us where to insert the duplicated\n-    // docs into the existing doc tree\n-    let path_map = build_reexport_path_map(srv, def_map);\n-\n-    // Finally update the doc tree\n-    merge_reexports(doc, path_map)\n-}\n-\n-// Hash maps are not sendable so converting them back and forth\n-// to association lists. Yuck.\n-fn to_assoc_list<K:copy, V:copy>(\n-    map: map::hashmap<K, V>\n-) -> ~[(K, V)] {\n-\n-    let mut vec = ~[];\n-    for map.each |k, v| {\n-        vec += ~[(k, v)];\n-    }\n-    ret vec;\n-}\n-\n-fn from_assoc_list<K:copy, V:copy>(\n-    list: ~[(K, V)],\n-    new_hash: fn() -> map::hashmap<K, V>\n-) -> map::hashmap<K, V> {\n-\n-    let map = new_hash();\n-    do vec::iter(list) |elt| {\n-        let (k, v) = elt;\n-        map.insert(k, v);\n-    }\n-    ret map;\n-}\n-\n-fn from_def_assoc_list<V:copy>(\n-    list: ~[(ast::def_id, V)]\n-) -> map::hashmap<ast::def_id, V> {\n-    from_assoc_list(list, ast_util::new_def_hash)\n-}\n-\n-fn from_str_assoc_list<V:copy>(\n-    list: ~[(~str, V)]\n-) -> map::hashmap<~str, V> {\n-    from_assoc_list(list, map::str_hash)\n-}\n-\n-fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n-    let assoc_list = do astsrv::exec(srv) |ctxt| {\n-        let def_set = ast_util::new_def_hash();\n-        for ctxt.exp_map.each |_id, defs| {\n-            for defs.each |def| {\n-                if def.reexp {\n-                    def_set.insert(def.id, ());\n-                }\n-            }\n-        }\n-        for find_reexport_impls(ctxt).each |def| {\n-            def_set.insert(def, ());\n-        }\n-        to_assoc_list(def_set)\n-    };\n-\n-    from_def_assoc_list(assoc_list)\n-}\n-\n-fn find_reexport_impls(ctxt: astsrv::ctxt) -> ~[ast::def_id] {\n-    let defs = @mut ~[];\n-    do for_each_reexported_impl(ctxt) |_mod_id, i| {\n-        *defs += ~[i.did]\n-    }\n-    ret *defs;\n-}\n-\n-fn build_reexport_def_map(\n-    srv: astsrv::srv,\n-    doc: doc::doc,\n-    def_set: def_set\n-) -> def_map {\n-\n-    type ctxt = {\n-        srv: astsrv::srv,\n-        def_set: def_set,\n-        def_map: def_map\n-    };\n-\n-    let ctxt = {\n-        srv: srv,\n-        def_set: def_set,\n-        def_map: ast_util::new_def_hash()\n-    };\n-\n-    // FIXME: Do a parallel fold (#2597)\n-    let fold = fold::fold({\n-        fold_mod: fold_mod,\n-        fold_nmod: fold_nmod\n-        with *fold::default_seq_fold(ctxt)\n-    });\n-\n-    fold.fold_doc(fold, doc);\n-\n-    ret ctxt.def_map;\n-\n-    fn fold_mod(fold: fold::fold<ctxt>, doc: doc::moddoc) -> doc::moddoc {\n-        let doc = fold::default_seq_fold_mod(fold, doc);\n-\n-        for doc.items.each |item| {\n-            let def_id = ast_util::local_def(item.id());\n-            if fold.ctxt.def_set.contains_key(def_id) {\n-                fold.ctxt.def_map.insert(def_id, item);\n-            }\n-        }\n-\n-        ret doc;\n-    }\n-\n-    fn fold_nmod(fold: fold::fold<ctxt>, doc: doc::nmoddoc) -> doc::nmoddoc {\n-        let doc = fold::default_seq_fold_nmod(fold, doc);\n-\n-        for doc.fns.each |fndoc| {\n-            let def_id = ast_util::local_def(fndoc.id());\n-            if fold.ctxt.def_set.contains_key(def_id) {\n-                fold.ctxt.def_map.insert(def_id, doc::fntag(fndoc));\n-            }\n-        }\n-\n-        ret doc;\n-    }\n-}\n-\n-fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n-\n-    // This is real unfortunate. Lots of copying going on here\n-    let def_assoc_list = to_assoc_list(def_map);\n-    #debug(\"def_map: %?\", def_assoc_list);\n-\n-    let assoc_list = do astsrv::exec(srv) |ctxt| {\n-\n-        let def_map = from_def_assoc_list(def_assoc_list);\n-        let path_map = map::str_hash::<~[(~str,doc::itemtag)]>();\n-\n-        for ctxt.exp_map.each |exp_id, defs| {\n-            let path = alt check ctxt.ast_map.get(exp_id) {\n-              ast_map::node_export(_, path) { path }\n-            };\n-          // should be a constraint on the node_export constructor\n-          // that guarantees path is non-empty\n-            let name = alt check vec::last(*path) {\n-              ast_map::path_name(nm) { nm }\n-            };\n-            let modpath = ast_map::path_to_str(vec::init(*path));\n-\n-            let mut reexportdocs = ~[];\n-            for defs.each |def| {\n-                if !def.reexp { again; }\n-                alt def_map.find(def.id) {\n-                  some(itemtag) {\n-                    reexportdocs += ~[(*name, itemtag)];\n-                  }\n-                  _ {}\n-                }\n-            }\n-\n-            if reexportdocs.len() > 0u {\n-                do option::iter(path_map.find(modpath)) |docs| {\n-                    reexportdocs = docs + vec::filter(reexportdocs, |x| {\n-                        !vec::contains(docs, x)\n-                    });\n-                }\n-                path_map.insert(modpath, reexportdocs);\n-                #debug(\"path_map entry: %? - %?\",\n-                       modpath, (name, reexportdocs));\n-            }\n-        }\n-\n-        for find_reexport_impl_docs(ctxt, def_map).each |elt| {\n-            let (path, doc) = elt;\n-            let docs = alt path_map.find(path) {\n-              some(docs) { docs + ~[(doc)] }\n-              none { ~[doc] }\n-            };\n-            path_map.insert(path, docs);\n-        }\n-\n-        to_assoc_list(path_map)\n-    };\n-\n-    from_str_assoc_list(assoc_list)\n-}\n-\n-fn find_reexport_impl_docs(\n-    ctxt: astsrv::ctxt,\n-    def_map: def_map\n-) -> ~[(~str, (~str, doc::itemtag))] {\n-    let docs = @mut ~[];\n-\n-    do for_each_reexported_impl(ctxt) |mod_id, i| {\n-        let path = alt ctxt.ast_map.find(mod_id) {\n-          some(ast_map::node_item(item, path)) {\n-            let path = ast_map::path_to_str(*path);\n-            if str::is_empty(path) {\n-                *item.ident\n-            } else {\n-                path + ~\"::\" + *item.ident\n-            }\n-          }\n-          _ {\n-            assert mod_id == ast::crate_node_id;\n-            ~\"\"\n-          }\n-        };\n-        let ident = *i.ident;\n-        let doc = alt check def_map.find(i.did) {\n-          some(doc) { doc }\n-        };\n-        *docs += ~[(path, (ident, doc))];\n-    }\n-\n-    ret *docs;\n-}\n-\n-fn for_each_reexported_impl(\n-    ctxt: astsrv::ctxt,\n-    f: fn@(ast::node_id, resolve::_impl)\n-) {\n-    let visitor = @{\n-        visit_mod: |a,b,c| visit_mod(ctxt, f, a, b, c)\n-        with *visit::default_simple_visitor()\n-    };\n-    let visitor = visit::mk_simple_visitor(visitor);\n-    visit::visit_crate(*ctxt.ast, (), visitor);\n-\n-    fn visit_mod(\n-        ctxt: astsrv::ctxt,\n-        f: fn@(ast::node_id, resolve::_impl),\n-        m: ast::_mod,\n-        _sp: codemap::span,\n-        mod_id: ast::node_id\n-    ) {\n-        let all_impls = all_impls(m);\n-        alt *ctxt.impl_map.get(mod_id) {\n-          list::cons(impls, _) {\n-            for vec::each(*impls) |i| {\n-                // This impl is not an item in the current mod\n-                if !all_impls.contains_key(i.did) {\n-                    // Ignore external impls because I don't\n-                    // know what to do with them yet\n-                    if i.did.crate == ast::local_crate {\n-                        f(mod_id, *i);\n-                    }\n-                }\n-            }\n-          }\n-          list::nil {\n-            // Do nothing -- mod has no impls\n-          }\n-        }\n-    }\n-}\n-\n-fn all_impls(m: ast::_mod) -> map::set<ast::def_id> {\n-    let all_impls = ast_util::new_def_hash();\n-    for m.items.each |item| {\n-        alt item.node {\n-          ast::item_impl(_, _, _, _) {\n-            all_impls.insert(ast_util::local_def(item.id), ());\n-          }\n-          _ { }\n-        }\n-    }\n-    ret all_impls;\n-}\n-\n-fn merge_reexports(\n-    doc: doc::doc,\n-    path_map: path_map\n-) -> doc::doc {\n-\n-    let fold = fold::fold({\n-        fold_mod: fold_mod\n-        with *fold::default_seq_fold(path_map)\n-    });\n-\n-    ret fold.fold_doc(fold, doc);\n-\n-    fn fold_mod(fold: fold::fold<path_map>, doc: doc::moddoc) -> doc::moddoc {\n-        let doc = fold::default_seq_fold_mod(fold, doc);\n-\n-        let is_topmod = doc.id() == ast::crate_node_id;\n-\n-        // In the case of the top mod, it really doesn't have a name;\n-        // the name we have here is actually the crate name\n-        let path = if is_topmod {\n-            doc.path()\n-        } else {\n-            doc.path() + ~[doc.name()]\n-        };\n-\n-        let new_items = get_new_items(path, fold.ctxt);\n-        #debug(\"merging into %?: %?\", path, new_items);\n-\n-        doc::moddoc_({\n-            items: (doc.items + new_items)\n-            with *doc\n-        })\n-    }\n-\n-    fn get_new_items(path: ~[~str], path_map: path_map) -> ~[doc::itemtag] {\n-        #debug(\"looking for reexports in path %?\", path);\n-        alt path_map.find(str::connect(path, ~\"::\")) {\n-          some(name_docs) {\n-            do vec::foldl(~[], name_docs) |v, name_doc| {\n-                let (name, doc) = name_doc;\n-                v + ~[reexport_doc(doc, name)]\n-            }\n-          }\n-          none { ~[] }\n-        }\n-    }\n-\n-    fn reexport_doc(doc: doc::itemtag, name: ~str) -> doc::itemtag {\n-        alt doc {\n-          doc::modtag(doc @ doc::moddoc_({item, _})) {\n-            doc::modtag(doc::moddoc_({\n-                item: reexport(item, name)\n-                with *doc\n-            }))\n-          }\n-          doc::nmodtag(_) { fail }\n-          doc::consttag(doc @ {item, _}) {\n-            doc::consttag({\n-                item: reexport(item, name)\n-                with doc\n-            })\n-          }\n-          doc::fntag(doc @ {item, _}) {\n-            doc::fntag({\n-                item: reexport(item, name)\n-                with doc\n-            })\n-          }\n-          doc::enumtag(doc @ {item, _}) {\n-            doc::enumtag({\n-                item: reexport(item, name)\n-                with doc\n-            })\n-          }\n-          doc::traittag(doc @ {item, _}) {\n-            doc::traittag({\n-                item: reexport(item, name)\n-                with doc\n-            })\n-          }\n-          doc::impltag(doc @ {item, _}) {\n-            doc::impltag({\n-                item: reexport(item, name)\n-                with doc\n-            })\n-          }\n-          doc::tytag(doc @ {item, _}) {\n-            doc::tytag({\n-                item: reexport(item, name)\n-                with doc\n-            })\n-          }\n-        }\n-    }\n-\n-    fn reexport(doc: doc::itemdoc, name: ~str) -> doc::itemdoc {\n-        {\n-            name: name,\n-            reexport: true\n-            with doc\n-        }\n-    }\n-}\n-\n-#[test]\n-fn should_duplicate_reexported_items() {\n-    let source = ~\"mod a { export b; fn b() { } } \\\n-                  mod c { import a::b; export b; }\";\n-    let doc = test::mk_doc(source);\n-    assert doc.cratemod().mods()[1].fns()[0].name() == ~\"b\";\n-}\n-\n-#[test]\n-fn should_mark_reepxorts_as_such() {\n-    let source = ~\"mod a { export b; fn b() { } } \\\n-                  mod c { import a::b; export b; }\";\n-    let doc = test::mk_doc(source);\n-    assert doc.cratemod().mods()[1].fns()[0].item.reexport == true;\n-}\n-\n-#[test]\n-fn should_duplicate_reexported_impls() {\n-    let source = ~\"mod a { impl b for int { fn c() { } } } \\\n-                  mod d { import a::b; export b; }\";\n-    let doc = test::mk_doc(source);\n-    assert doc.cratemod().mods()[1].impls()[0].name() == ~\"b\";\n-}\n-\n-#[test]\n-fn should_duplicate_reexported_impls_deep() {\n-    let source = ~\"mod a { impl b for int { fn c() { } } } \\\n-                  mod d { mod e { import a::b; export b; } }\";\n-    let doc = test::mk_doc(source);\n-    assert doc.cratemod().mods()[1].mods()[0].impls()[0].name() == ~\"b\";\n-}\n-\n-#[test]\n-fn should_duplicate_reexported_impls_crate() {\n-    let source = ~\"import a::b; export b; \\\n-                  mod a { impl b for int { fn c() { } } }\";\n-    let doc = test::mk_doc(source);\n-    assert doc.cratemod().impls()[0].name() == ~\"b\";\n-}\n-\n-#[test]\n-fn should_duplicate_reexported_foreign_fns() {\n-    let source = ~\"extern mod a { fn b(); } \\\n-                  mod c { import a::b; export b; }\";\n-    let doc = test::mk_doc(source);\n-    assert doc.cratemod().mods()[0].fns()[0].name() == ~\"b\";\n-}\n-\n-#[test]\n-fn should_duplicate_multiple_reexported_items() {\n-    let source = ~\"mod a { \\\n-                  export b; export c; \\\n-                  fn b() { } fn c() { } \\\n-                  } \\\n-                  mod d { \\\n-                  import a::b; import a::c; \\\n-                  export b; export c; \\\n-                  }\";\n-    do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv, ~\"\");\n-        let doc = path_pass::mk_pass().f(srv, doc);\n-        let doc = run(srv, doc);\n-        // Reexports may not be in any specific order\n-        let doc = sort_item_name_pass::mk_pass().f(srv, doc);\n-        assert doc.cratemod().mods()[1].fns()[0].name() == ~\"b\";\n-        assert doc.cratemod().mods()[1].fns()[1].name() == ~\"c\";\n-    }\n-}\n-\n-#[test]\n-fn should_rename_items_reexported_with_different_names() {\n-    let source = ~\"mod a { export b; fn b() { } } \\\n-                  mod c { import x = a::b; export x; }\";\n-    let doc = test::mk_doc(source);\n-    assert doc.cratemod().mods()[1].fns()[0].name() == ~\"x\";\n-}\n-\n-#[test]\n-fn should_reexport_in_topmod() {\n-    fn mk_doc(source: ~str) -> doc::doc {\n-        do astsrv::from_str(source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"core\");\n-            let doc = path_pass::mk_pass().f(srv, doc);\n-            run(srv, doc)\n-        }\n-    }\n-    let source = ~\"import option::{some, none}; \\\n-                  import option = option::t; \\\n-                  export option, some, none; \\\n-                  mod option { \\\n-                  enum t { some, none } \\\n-                  }\";\n-    let doc = mk_doc(source);\n-    assert doc.cratemod().enums()[0].name() == ~\"option\";\n-}\n-\n-#[test]\n-fn should_not_reexport_multiple_times() {\n-    let source = ~\"import option = option::t; \\\n-                  export option; \\\n-                  export option; \\\n-                  mod option { \\\n-                  enum t { none, some } \\\n-                  }\";\n-    let doc = test::mk_doc(source);\n-    assert vec::len(doc.cratemod().enums()) == 1u;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    fn mk_doc(source: ~str) -> doc::doc {\n-        do astsrv::from_str(source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            let doc = path_pass::mk_pass().f(srv, doc);\n-            run(srv, doc)\n-        }\n-    }\n-}"}, {"sha": "36067b2db6fe1607bbdfc2000c33470c91a3d733", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df7ce33b3dc6455ce954100241b3b3494295674e/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/df7ce33b3dc6455ce954100241b3b3494295674e/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=df7ce33b3dc6455ce954100241b3b3494295674e", "patch": "@@ -33,7 +33,6 @@ mod fold;\n mod path_pass;\n mod attr_pass;\n mod tystr_pass;\n-mod prune_unexported_pass;\n mod prune_hidden_pass;\n mod desc_to_brief_pass;\n mod text_pass;\n@@ -44,7 +43,6 @@ mod demo;\n mod sort_pass;\n mod sort_item_name_pass;\n mod sort_item_type_pass;\n-mod reexport_pass;\n mod page_pass;\n mod sectionalize_pass;\n mod escape_pass;"}, {"sha": "7a23dbd9d9db068c269e9f20174d841c346735ce", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df7ce33b3dc6455ce954100241b3b3494295674e/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df7ce33b3dc6455ce954100241b3b3494295674e/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=df7ce33b3dc6455ce954100241b3b3494295674e", "patch": "@@ -139,8 +139,6 @@ fn run(config: config::config) {\n             extract::from_srv(srv, default_name)\n         });\n         run_passes(srv, doc, ~[\n-            reexport_pass::mk_pass(),\n-            prune_unexported_pass::mk_pass(),\n             tystr_pass::mk_pass(),\n             path_pass::mk_pass(),\n             attr_pass::mk_pass(),"}]}