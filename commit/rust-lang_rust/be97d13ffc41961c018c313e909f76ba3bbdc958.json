{"sha": "be97d13ffc41961c018c313e909f76ba3bbdc958", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlOTdkMTNmZmM0MTk2MWMwMThjMzEzZTkwOWY3NmJhM2JiZGM5NTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-18T18:43:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-18T18:43:50Z"}, "message": "Auto merge of #75657 - TimDiekmann:allocref-cleanup, r=Amanieu\n\nClean up AllocRef implementation and documentation\n\nr? @Amanieu", "tree": {"sha": "122ed2e56e07d8b63ec5e7ea280fd9565f1b3dd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/122ed2e56e07d8b63ec5e7ea280fd9565f1b3dd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be97d13ffc41961c018c313e909f76ba3bbdc958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be97d13ffc41961c018c313e909f76ba3bbdc958", "html_url": "https://github.com/rust-lang/rust/commit/be97d13ffc41961c018c313e909f76ba3bbdc958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be97d13ffc41961c018c313e909f76ba3bbdc958/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b287b56f97288cc4605329f76e31cb7604474aef", "url": "https://api.github.com/repos/rust-lang/rust/commits/b287b56f97288cc4605329f76e31cb7604474aef", "html_url": "https://github.com/rust-lang/rust/commit/b287b56f97288cc4605329f76e31cb7604474aef"}, {"sha": "63d241a7b78f129477d980bf5a6baa818f47b4f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/63d241a7b78f129477d980bf5a6baa818f47b4f8", "html_url": "https://github.com/rust-lang/rust/commit/63d241a7b78f129477d980bf5a6baa818f47b4f8"}], "stats": {"total": 361, "additions": 183, "deletions": 178}, "files": [{"sha": "fa5eb1823f1a0755c721abbed9a13b5e5e5a0b84", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/be97d13ffc41961c018c313e909f76ba3bbdc958/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be97d13ffc41961c018c313e909f76ba3bbdc958/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=be97d13ffc41961c018c313e909f76ba3bbdc958", "patch": "@@ -161,30 +161,69 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n     unsafe { __rust_alloc_zeroed(layout.size(), layout.align()) }\n }\n \n+impl Global {\n+    #[inline]\n+    fn alloc_impl(&mut self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n+        match layout.size() {\n+            0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n+            // SAFETY: `layout` is non-zero in size,\n+            size => unsafe {\n+                let raw_ptr = if zeroed { alloc_zeroed(layout) } else { alloc(layout) };\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                Ok(NonNull::slice_from_raw_parts(ptr, size))\n+            },\n+        }\n+    }\n+\n+    // Safety: Same as `AllocRef::grow`\n+    #[inline]\n+    unsafe fn grow_impl(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+        zeroed: bool,\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        debug_assert!(\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n+\n+        match layout.size() {\n+            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+            0 => unsafe {\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                self.alloc_impl(new_layout, zeroed)\n+            },\n+\n+            // SAFETY: `new_size` is non-zero as `old_size` is greater than or equal to `new_size`\n+            // as required by safety conditions. Other conditions must be upheld by the caller\n+            old_size => unsafe {\n+                // `realloc` probably checks for `new_size >= size` or something similar.\n+                intrinsics::assume(new_size >= layout.size());\n+\n+                let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                if zeroed {\n+                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+                }\n+                Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+            },\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n     fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n-        let size = layout.size();\n-        let ptr = if size == 0 {\n-            layout.dangling()\n-        } else {\n-            // SAFETY: `layout` is non-zero in size,\n-            unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr)? }\n-        };\n-        Ok(NonNull::slice_from_raw_parts(ptr, size))\n+        self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n     fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n-        let size = layout.size();\n-        let ptr = if size == 0 {\n-            layout.dangling()\n-        } else {\n-            // SAFETY: `layout` is non-zero in size,\n-            unsafe { NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr)? }\n-        };\n-        Ok(NonNull::slice_from_raw_parts(ptr, size))\n+        self.alloc_impl(layout, true)\n     }\n \n     #[inline]\n@@ -203,26 +242,8 @@ unsafe impl AllocRef for Global {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n-        debug_assert!(\n-            new_size >= layout.size(),\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n-        );\n-\n-        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n-        // If `new_size` is zero, then `old_size` has to be zero as well.\n-        // Other conditions must be upheld by the caller\n-        unsafe {\n-            match layout.size() {\n-                0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n-                old_size => {\n-                    // `realloc` probably checks for `new_size >= size` or something similar.\n-                    intrinsics::assume(new_size >= old_size);\n-                    let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n-                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n-                }\n-            }\n-        }\n+        // SAFETY: all conditions must be upheld by the caller\n+        unsafe { self.grow_impl(ptr, layout, new_size, false) }\n     }\n \n     #[inline]\n@@ -232,27 +253,8 @@ unsafe impl AllocRef for Global {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n-        debug_assert!(\n-            new_size >= layout.size(),\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n-        );\n-\n-        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n-        // If `new_size` is zero, then `old_size` has to be zero as well.\n-        // Other conditions must be upheld by the caller\n-        unsafe {\n-            match layout.size() {\n-                0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n-                old_size => {\n-                    // `realloc` probably checks for `new_size >= size` or something similar.\n-                    intrinsics::assume(new_size >= old_size);\n-                    let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n-                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n-                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n-                }\n-            }\n-        }\n+        // SAFETY: all conditions must be upheld by the caller\n+        unsafe { self.grow_impl(ptr, layout, new_size, true) }\n     }\n \n     #[inline]\n@@ -262,30 +264,28 @@ unsafe impl AllocRef for Global {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n-        let old_size = layout.size();\n         debug_assert!(\n-            new_size <= old_size,\n+            new_size <= layout.size(),\n             \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        let ptr = if new_size == 0 {\n+        match new_size {\n             // SAFETY: conditions must be upheld by the caller\n-            unsafe {\n+            0 => unsafe {\n                 self.dealloc(ptr, layout);\n-            }\n-            layout.dangling()\n-        } else {\n-            // SAFETY: new_size is not zero,\n-            // Other conditions must be upheld by the caller\n-            let raw_ptr = unsafe {\n-                // `realloc` probably checks for `new_size <= old_size` or something similar.\n-                intrinsics::assume(new_size <= old_size);\n-                realloc(ptr.as_ptr(), layout, new_size)\n-            };\n-            NonNull::new(raw_ptr).ok_or(AllocErr)?\n-        };\n+                Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0))\n+            },\n \n-        Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+            // SAFETY: `new_size` is non-zero. Other conditions must be upheld by the caller\n+            new_size => unsafe {\n+                // `realloc` probably checks for `new_size <= size` or something similar.\n+                intrinsics::assume(new_size <= layout.size());\n+\n+                let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+            },\n+        }\n     }\n }\n "}, {"sha": "ad4f8bf1397c2de696b727dc4ab927204ac3cd4d", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/be97d13ffc41961c018c313e909f76ba3bbdc958/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be97d13ffc41961c018c313e909f76ba3bbdc958/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=be97d13ffc41961c018c313e909f76ba3bbdc958", "patch": "@@ -151,6 +151,11 @@ pub unsafe trait AllocRef {\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n     /// allocation referenced by `ptr` to fit the new layout.\n     ///\n+    /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n+    /// transferred to this allocator. The memory may or may not have been freed, and should be\n+    /// considered unusable unless it was transferred back to the caller again via the return value\n+    /// of this method.\n+    ///\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n     ///\n@@ -192,12 +197,9 @@ pub unsafe trait AllocRef {\n             \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        let new_layout =\n-            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-            // The caller must ensure that `new_size` is greater than or equal to zero. If it's equal\n-            // to zero, it's catched beforehand.\n-            unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n         let new_ptr = self.alloc(new_layout)?;\n \n         // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n@@ -206,10 +208,11 @@ pub unsafe trait AllocRef {\n         // `copy_nonoverlapping` is safe.\n         // The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_non_null_ptr().as_ptr(), size);\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), size);\n             self.dealloc(ptr, layout);\n-            Ok(new_ptr)\n         }\n+\n+        Ok(new_ptr)\n     }\n \n     /// Behaves like `grow`, but also ensures that the new contents are set to zero before being\n@@ -218,12 +221,12 @@ pub unsafe trait AllocRef {\n     /// The memory block will contain the following contents after a successful call to\n     /// `grow_zeroed`:\n     ///   * Bytes `0..layout.size()` are preserved from the original allocation.\n-    ///   * Bytes `layout.size()..old_size` will either be preserved or zeroed,\n-    ///     depending on the allocator implementation. `old_size` refers to the size of\n-    ///     the `MemoryBlock` prior to the `grow_zeroed` call, which may be larger than the size\n-    ///     that was originally requested when it was allocated.\n-    ///   * Bytes `old_size..new_size` are zeroed. `new_size` refers to\n-    ///     the size of the `MemoryBlock` returned by the `grow` call.\n+    ///   * Bytes `layout.size()..old_size` will either be preserved or zeroed, depending on the\n+    ///     allocator implementation. `old_size` refers to the size of the memory block prior to\n+    ///     the `grow_zeroed` call, which may be larger than the size that was originally requested\n+    ///     when it was allocated.\n+    ///   * Bytes `old_size..new_size` are zeroed. `new_size` refers to the size of the memory\n+    ///     block returned by the `grow` call.\n     ///\n     /// # Safety\n     ///\n@@ -261,12 +264,9 @@ pub unsafe trait AllocRef {\n             \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        let new_layout =\n-            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-            // The caller must ensure that `new_size` is greater than or equal to zero. If it's equal\n-            // to zero, it's caught beforehand.\n-            unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n         let new_ptr = self.alloc_zeroed(new_layout)?;\n \n         // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n@@ -275,10 +275,11 @@ pub unsafe trait AllocRef {\n         // `copy_nonoverlapping` is safe.\n         // The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_non_null_ptr().as_ptr(), size);\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), size);\n             self.dealloc(ptr, layout);\n-            Ok(new_ptr)\n         }\n+\n+        Ok(new_ptr)\n     }\n \n     /// Attempts to shrink the memory block.\n@@ -290,8 +291,8 @@ pub unsafe trait AllocRef {\n     ///\n     /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n     /// transferred to this allocator. The memory may or may not have been freed, and should be\n-    /// considered unusable unless it was transferred back to the caller again via the\n-    /// return value of this method.\n+    /// considered unusable unless it was transferred back to the caller again via the return value\n+    /// of this method.\n     ///\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n@@ -332,11 +333,9 @@ pub unsafe trait AllocRef {\n             \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        let new_layout =\n         // SAFETY: the caller must ensure that the `new_size` does not overflow.\n         // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-        // The caller must ensure that `new_size` is greater than zero.\n-            unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n         let new_ptr = self.alloc(new_layout)?;\n \n         // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n@@ -345,10 +344,11 @@ pub unsafe trait AllocRef {\n         // `copy_nonoverlapping` is safe.\n         // The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_non_null_ptr().as_ptr(), size);\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), size);\n             self.dealloc(ptr, layout);\n-            Ok(new_ptr)\n         }\n+\n+        Ok(new_ptr)\n     }\n \n     /// Creates a \"by reference\" adaptor for this instance of `AllocRef`."}, {"sha": "b4009c86419d5148e3fb6f79a17e6d43b1d692e0", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 80, "deletions": 75, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/be97d13ffc41961c018c313e909f76ba3bbdc958/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be97d13ffc41961c018c313e909f76ba3bbdc958/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=be97d13ffc41961c018c313e909f76ba3bbdc958", "patch": "@@ -131,40 +131,83 @@ pub use alloc_crate::alloc::*;\n #[derive(Debug, Default, Copy, Clone)]\n pub struct System;\n \n+impl System {\n+    #[inline]\n+    fn alloc_impl(&mut self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n+        match layout.size() {\n+            0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n+            // SAFETY: `layout` is non-zero in size,\n+            size => unsafe {\n+                let raw_ptr = if zeroed {\n+                    GlobalAlloc::alloc_zeroed(self, layout)\n+                } else {\n+                    GlobalAlloc::alloc(self, layout)\n+                };\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                Ok(NonNull::slice_from_raw_parts(ptr, size))\n+            },\n+        }\n+    }\n+\n+    // Safety: Same as `AllocRef::grow`\n+    #[inline]\n+    unsafe fn grow_impl(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+        zeroed: bool,\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n+        debug_assert!(\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n+\n+        match layout.size() {\n+            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+            0 => unsafe {\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                self.alloc_impl(new_layout, zeroed)\n+            },\n+\n+            // SAFETY: `new_size` is non-zero as `old_size` is greater than or equal to `new_size`\n+            // as required by safety conditions. Other conditions must be upheld by the caller\n+            old_size => unsafe {\n+                // `realloc` probably checks for `new_size >= size` or something similar.\n+                intrinsics::assume(new_size >= layout.size());\n+\n+                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                if zeroed {\n+                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+                }\n+                Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+            },\n+        }\n+    }\n+}\n+\n // The AllocRef impl checks the layout size to be non-zero and forwards to the GlobalAlloc impl,\n // which is in `std::sys::*::alloc`.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n     fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n-        let size = layout.size();\n-        let ptr = if size == 0 {\n-            layout.dangling()\n-        } else {\n-            // SAFETY: `layout` is non-zero in size,\n-            unsafe { NonNull::new(GlobalAlloc::alloc(&System, layout)).ok_or(AllocErr)? }\n-        };\n-        Ok(NonNull::slice_from_raw_parts(ptr, size))\n+        self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n     fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n-        let size = layout.size();\n-        let ptr = if size == 0 {\n-            layout.dangling()\n-        } else {\n-            // SAFETY: `layout` is non-zero in size,\n-            unsafe { NonNull::new(GlobalAlloc::alloc_zeroed(&System, layout)).ok_or(AllocErr)? }\n-        };\n-        Ok(NonNull::slice_from_raw_parts(ptr, size))\n+        self.alloc_impl(layout, true)\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n             // SAFETY: `layout` is non-zero in size,\n             // other conditions must be upheld by the caller\n-            unsafe { GlobalAlloc::dealloc(&System, ptr.as_ptr(), layout) }\n+            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -175,26 +218,8 @@ unsafe impl AllocRef for System {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n-        debug_assert!(\n-            new_size >= layout.size(),\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n-        );\n-\n-        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n-        // If `new_size` is zero, then `old_size` has to be zero as well.\n-        // Other conditions must be upheld by the caller\n-        unsafe {\n-            match layout.size() {\n-                0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n-                old_size => {\n-                    // `realloc` probably checks for `new_size >= size` or something similar.\n-                    intrinsics::assume(new_size >= old_size);\n-                    let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n-                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n-                }\n-            }\n-        }\n+        // SAFETY: all conditions must be upheld by the caller\n+        unsafe { self.grow_impl(ptr, layout, new_size, false) }\n     }\n \n     #[inline]\n@@ -204,27 +229,8 @@ unsafe impl AllocRef for System {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n-        debug_assert!(\n-            new_size >= layout.size(),\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n-        );\n-\n-        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n-        // If `new_size` is zero, then `old_size` has to be zero as well.\n-        // Other conditions must be upheld by the caller\n-        unsafe {\n-            match layout.size() {\n-                0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n-                old_size => {\n-                    // `realloc` probably checks for `new_size >= size` or something similar.\n-                    intrinsics::assume(new_size >= old_size);\n-                    let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n-                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n-                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n-                }\n-            }\n-        }\n+        // SAFETY: all conditions must be upheld by the caller\n+        unsafe { self.grow_impl(ptr, layout, new_size, true) }\n     }\n \n     #[inline]\n@@ -234,32 +240,31 @@ unsafe impl AllocRef for System {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n-        let old_size = layout.size();\n         debug_assert!(\n-            new_size <= old_size,\n+            new_size <= layout.size(),\n             \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        let ptr = if new_size == 0 {\n+        match new_size {\n             // SAFETY: conditions must be upheld by the caller\n-            unsafe {\n+            0 => unsafe {\n                 self.dealloc(ptr, layout);\n-            }\n-            layout.dangling()\n-        } else {\n-            // SAFETY: new_size is not zero,\n-            // Other conditions must be upheld by the caller\n-            let raw_ptr = unsafe {\n-                // `realloc` probably checks for `new_size <= old_size` or something similar.\n-                intrinsics::assume(new_size <= old_size);\n-                GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size)\n-            };\n-            NonNull::new(raw_ptr).ok_or(AllocErr)?\n-        };\n+                Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0))\n+            },\n+\n+            // SAFETY: `new_size` is non-zero. Other conditions must be upheld by the caller\n+            new_size => unsafe {\n+                // `realloc` probably checks for `new_size <= size` or something similar.\n+                intrinsics::assume(new_size <= layout.size());\n \n-        Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+            },\n+        }\n     }\n }\n+\n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n \n /// Registers a custom allocation error hook, replacing any that was previously registered."}]}