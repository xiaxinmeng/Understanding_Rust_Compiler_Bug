{"sha": "27843133448df3315af1a07dc6700d7754709a97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ODQzMTMzNDQ4ZGYzMzE1YWYxYTA3ZGM2NzAwZDc3NTQ3MDlhOTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-17T20:12:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-18T18:49:32Z"}, "message": "rustc: Clean up error reporting\n\nThis commit re-works how the monitor() function works and how it both receives\nand transmits errors. There are a few cases in which the compiler can abort:\n\n1. A normal compiler error. In this case, the compiler raises a FatalError as\n   the failure value of the task. If this happens, then the monitor task does\n   nothing. It ignores all stderr output of the child task and it also\n   suppresses the failure message of the main task itself. This means that on a\n   normal compiler error just the error message itself is printed.\n\n2. A normal internal compiler error. These are invoked from sess.span_bug() and\n   friends. In these cases, they follow the same path (raising a FatalError),\n   but they will also print an ICE message which has a URL to go report a bug.\n\n3. An actual compiler bug. This happens whenever anything calls fail!() instead\n   of going through the session itself. In this case, we print out stuff about\n   RUST_LOG=2 and we by default capture all stderr and print via warn!() so it's\n   only printed out with the RUST_LOG var set.", "tree": {"sha": "9280de945155c54f99d1ee6abfc6baa56097e6f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9280de945155c54f99d1ee6abfc6baa56097e6f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27843133448df3315af1a07dc6700d7754709a97", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27843133448df3315af1a07dc6700d7754709a97", "html_url": "https://github.com/rust-lang/rust/commit/27843133448df3315af1a07dc6700d7754709a97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27843133448df3315af1a07dc6700d7754709a97/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3f2e697d8d21190bb99e86bae2de39f012162aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f2e697d8d21190bb99e86bae2de39f012162aa", "html_url": "https://github.com/rust-lang/rust/commit/f3f2e697d8d21190bb99e86bae2de39f012162aa"}], "stats": {"total": 115, "additions": 28, "deletions": 87}, "files": [{"sha": "26b20fb49dc74d271351955264f488c8751d6350", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 21, "deletions": 85, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/27843133448df3315af1a07dc6700d7754709a97/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27843133448df3315af1a07dc6700d7754709a97/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=27843133448df3315af1a07dc6700d7754709a97", "patch": "@@ -38,21 +38,16 @@ use middle::lint;\n \n use d = driver::driver;\n \n-use std::cast;\n-use std::comm;\n use std::io;\n-use std::io::Reader;\n use std::num;\n use std::os;\n-use std::result;\n use std::str;\n use std::task;\n use std::vec;\n use extra::getopts::groups;\n use extra::getopts;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap;\n use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n use syntax::parse;\n@@ -126,21 +121,6 @@ pub mod lib {\n     pub mod llvmdeps;\n }\n \n-// A curious inner module that allows ::std::foo to be available in here for\n-// macros.\n-/*\n-mod std {\n-    pub use std::clone;\n-    pub use std::cmp;\n-    pub use std::os;\n-    pub use std::str;\n-    pub use std::sys;\n-    pub use std::to_bytes;\n-    pub use std::unstable;\n-    pub use extra::serialize;\n-}\n-*/\n-\n pub fn version(argv0: &str) {\n     let vers = match option_env!(\"CFG_VERSION\") {\n         Some(vers) => vers,\n@@ -344,45 +324,12 @@ fn parse_crate_attrs(sess: session::Session,\n     }\n }\n \n-#[deriving(Eq)]\n-pub enum monitor_msg {\n-    fatal,\n-    done,\n-}\n-\n-struct RustcEmitter {\n-    ch_capture: comm::SharedChan<monitor_msg>\n-}\n-\n-impl diagnostic::Emitter for RustcEmitter {\n-    fn emit(&self,\n-            cmsp: Option<(&codemap::CodeMap, codemap::Span)>,\n-            msg: &str,\n-            lvl: diagnostic::Level) {\n-        if lvl == diagnostic::Fatal {\n-            let this = unsafe { cast::transmute_mut(self) };\n-            this.ch_capture.send(fatal)\n-        }\n-\n-        diagnostic::DefaultEmitter.emit(cmsp, msg, lvl)\n-    }\n-}\n-\n-/*\n-This is a sanity check that any failure of the compiler is performed\n-through the diagnostic module and reported properly - we shouldn't be calling\n-plain-old-fail on any execution path that might be taken. Since we have\n-console logging off by default, hitting a plain fail statement would make the\n-compiler silently exit, which would be terrible.\n-\n-This method wraps the compiler in a subtask and injects a function into the\n-diagnostic emitter which records when we hit a fatal error. If the task\n-fails without recording a fatal error then we've encountered a compiler\n-bug and need to present an error.\n-*/\n+/// Run a procedure which will detect failures in the compiler and print nicer\n+/// error messages rather than just failing the test.\n+///\n+/// The diagnostic emitter yielded to the procedure should be used for reporting\n+/// errors of the compiler.\n pub fn monitor(f: proc(@diagnostic::Emitter)) {\n-    use std::comm::*;\n-\n     // XXX: This is a hack for newsched since it doesn't support split stacks.\n     // rustc needs a lot of stack! When optimizations are disabled, it needs\n     // even *more* stack than usual as well.\n@@ -391,8 +338,6 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n     #[cfg(not(rtopt))]\n     static STACK_SIZE: uint = 20000000; // 20MB\n \n-    let (p, ch) = SharedChan::new();\n-    let ch_capture = ch.clone();\n     let mut task_builder = task::task();\n     task_builder.name(\"rustc\");\n \n@@ -402,30 +347,18 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n         task_builder.opts.stack_size = Some(STACK_SIZE);\n     }\n \n-    match task_builder.try(proc() {\n-        let ch = ch_capture.clone();\n-        // The 'diagnostics emitter'. Every error, warning, etc. should\n-        // go through this function.\n-        let demitter = @RustcEmitter {\n-            ch_capture: ch.clone(),\n-        } as @diagnostic::Emitter;\n-\n-        struct finally {\n-            ch: SharedChan<monitor_msg>,\n-        }\n+    let (p, c) = Chan::new();\n+    let w = io::ChanWriter::new(c);\n+    let mut r = io::PortReader::new(p);\n \n-        impl Drop for finally {\n-            fn drop(&mut self) { self.ch.send(done); }\n-        }\n-\n-        let _finally = finally { ch: ch };\n-\n-        f(demitter);\n+    match task_builder.try(proc() {\n+        io::stdio::set_stderr(~w as ~io::Writer);\n+        f(@diagnostic::DefaultEmitter)\n     }) {\n-        result::Ok(_) => { /* fallthrough */ }\n-        result::Err(_) => {\n+        Ok(()) => { /* fallthrough */ }\n+        Err(value) => {\n             // Task failed without emitting a fatal diagnostic\n-            if p.recv() == done {\n+            if !value.is::<diagnostic::FatalError>() {\n                 diagnostic::DefaultEmitter.emit(\n                     None,\n                     diagnostic::ice_msg(\"unexpected failure\"),\n@@ -434,17 +367,20 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n                 let xs = [\n                     ~\"the compiler hit an unexpected failure path. \\\n                      this is a bug\",\n-                    ~\"try running with RUST_LOG=rustc=1 \\\n-                     to get further details and report the results \\\n-                     to github.com/mozilla/rust/issues\"\n                 ];\n                 for note in xs.iter() {\n                     diagnostic::DefaultEmitter.emit(None,\n                                                     *note,\n                                                     diagnostic::Note)\n                 }\n+\n+                println!(\"{}\", r.read_to_str());\n             }\n-            // Fail so the process returns a failure code\n+\n+            // Fail so the process returns a failure code, but don't pollute the\n+            // output with some unnecessary failure messages, we've already\n+            // printed everything that we needed to.\n+            io::stdio::set_stderr(~io::util::NullWriter as ~io::Writer);\n             fail!();\n         }\n     }"}, {"sha": "0eca56e2691ba81e60a4cf483b073f81b4dcc3d5", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27843133448df3315af1a07dc6700d7754709a97/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27843133448df3315af1a07dc6700d7754709a97/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=27843133448df3315af1a07dc6700d7754709a97", "patch": "@@ -27,6 +27,11 @@ pub trait Emitter {\n             lvl: Level);\n }\n \n+/// This structure is used to signify that a task has failed with a fatal error\n+/// from the diagnostics. You can use this with the `Any` trait to figure out\n+/// how a rustc task died (if so desired).\n+pub struct FatalError;\n+\n // a span-handler is like a handler but also\n // accepts span information for source-location\n // reporting.\n@@ -38,7 +43,7 @@ pub struct SpanHandler {\n impl SpanHandler {\n     pub fn span_fatal(@self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((&*self.cm, sp)), msg, Fatal);\n-        fail!();\n+        fail!(FatalError);\n     }\n     pub fn span_err(@self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&*self.cm, sp)), msg, Error);\n@@ -72,7 +77,7 @@ pub struct Handler {\n impl Handler {\n     pub fn fatal(@self, msg: &str) -> ! {\n         self.emit.emit(None, msg, Fatal);\n-        fail!();\n+        fail!(FatalError);\n     }\n     pub fn err(@self, msg: &str) {\n         self.emit.emit(None, msg, Error);"}]}