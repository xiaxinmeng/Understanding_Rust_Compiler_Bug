{"sha": "3e0400fb86170baff30282edcdccff73e243fd6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMDQwMGZiODYxNzBiYWZmMzAyODJlZGNkY2NmZjczZTI0M2ZkNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-11T00:56:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-11T00:56:02Z"}, "message": "auto merge of #6223 : alexcrichton/rust/issue-6183, r=pcwalton\n\nCloses #6183.\r\n\r\nThe first commit changes the compiler's method of treating a `for` loop, and all the remaining commits are just dealing with the fallout.\r\n\r\nThe biggest fallout was the `IterBytes` trait, although it's really a whole lot nicer now because all of the `iter_bytes_XX` methods are just and-ed together. Sadly there was a huge amount of stuff that's `cfg(stage0)` gated, but whoever lands the next snapshot is going to have a lot of fun deleting all this code!", "tree": {"sha": "ec7cc5de5ce7c80845c77fdcbb670cd54c120783", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec7cc5de5ce7c80845c77fdcbb670cd54c120783"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e0400fb86170baff30282edcdccff73e243fd6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e0400fb86170baff30282edcdccff73e243fd6e", "html_url": "https://github.com/rust-lang/rust/commit/3e0400fb86170baff30282edcdccff73e243fd6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e0400fb86170baff30282edcdccff73e243fd6e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d546493096f35e68cbcd9b5d3d7654e7a9345744", "url": "https://api.github.com/repos/rust-lang/rust/commits/d546493096f35e68cbcd9b5d3d7654e7a9345744", "html_url": "https://github.com/rust-lang/rust/commit/d546493096f35e68cbcd9b5d3d7654e7a9345744"}, {"sha": "606bd75586419948f109de313ab37e31397ca7a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/606bd75586419948f109de313ab37e31397ca7a3", "html_url": "https://github.com/rust-lang/rust/commit/606bd75586419948f109de313ab37e31397ca7a3"}], "stats": {"total": 3247, "additions": 2943, "deletions": 304}, "files": [{"sha": "a5df97e3d574f84ef0467abd46cc8c381ea443a4", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -127,6 +127,7 @@ struct AnnihilateStats {\n     n_bytes_freed: uint\n }\n \n+#[cfg(stage0)]\n unsafe fn each_live_alloc(read_next_before: bool,\n                           f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n     //! Walks the internal list of allocations\n@@ -141,8 +142,8 @@ unsafe fn each_live_alloc(read_next_before: bool,\n         let uniq =\n             (*box).header.ref_count == managed::raw::RC_MANAGED_UNIQUE;\n \n-        if ! f(box, uniq) {\n-            break\n+        if !f(box, uniq) {\n+            return;\n         }\n \n         if read_next_before {\n@@ -152,6 +153,33 @@ unsafe fn each_live_alloc(read_next_before: bool,\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+unsafe fn each_live_alloc(read_next_before: bool,\n+                          f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) -> bool {\n+    //! Walks the internal list of allocations\n+\n+    use managed;\n+\n+    let task: *Task = transmute(rustrt::rust_get_task());\n+    let box = (*task).boxed_region.live_allocs;\n+    let mut box: *mut BoxRepr = transmute(copy box);\n+    while box != mut_null() {\n+        let next_before = transmute(copy (*box).header.next);\n+        let uniq =\n+            (*box).header.ref_count == managed::raw::RC_MANAGED_UNIQUE;\n+\n+        if !f(box, uniq) {\n+            return false;\n+        }\n+\n+        if read_next_before {\n+            box = next_before;\n+        } else {\n+            box = transmute(copy (*box).header.next);\n+        }\n+    }\n+    return true;\n+}\n \n #[cfg(unix)]\n fn debug_mem() -> bool {"}, {"sha": "1d5d77649549e294573c8d47a42728f0a399b87f", "filename": "src/libcore/container.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -30,16 +30,32 @@ pub trait Map<K, V>: Mutable {\n     fn contains_key(&self, key: &K) -> bool;\n \n     // Visits all keys and values\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool);\n+    // Visits all keys and values\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool) -> bool;\n \n     /// Visit all keys\n+    #[cfg(stage0)]\n     fn each_key(&self, f: &fn(&K) -> bool);\n+    /// Visit all keys\n+    #[cfg(not(stage0))]\n+    fn each_key(&self, f: &fn(&K) -> bool) -> bool;\n \n     /// Visit all values\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool);\n+    /// Visit all values\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool;\n \n     /// Iterate over the map and mutate the contained values\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n+    /// Iterate over the map and mutate the contained values\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool;\n \n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n@@ -65,6 +81,7 @@ pub trait Map<K, V>: Mutable {\n     fn pop(&mut self, k: &K) -> Option<V>;\n }\n \n+#[cfg(stage0)]\n pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool;\n@@ -99,3 +116,39 @@ pub trait Set<T>: Mutable {\n     /// Visit the values representing the union\n     fn union(&self, other: &Self, f: &fn(&T) -> bool);\n }\n+\n+#[cfg(not(stage0))]\n+pub trait Set<T>: Mutable {\n+    /// Return true if the set contains a value\n+    fn contains(&self, value: &T) -> bool;\n+\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    fn insert(&mut self, value: T) -> bool;\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    fn remove(&mut self, value: &T) -> bool;\n+\n+    /// Return true if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    fn is_disjoint(&self, other: &Self) -> bool;\n+\n+    /// Return true if the set is a subset of another\n+    fn is_subset(&self, other: &Self) -> bool;\n+\n+    /// Return true if the set is a superset of another\n+    fn is_superset(&self, other: &Self) -> bool;\n+\n+    /// Visit the values representing the difference\n+    fn difference(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+\n+    /// Visit the values representing the symmetric difference\n+    fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+\n+    /// Visit the values representing the intersection\n+    fn intersection(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+\n+    /// Visit the values representing the union\n+    fn union(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n+}"}, {"sha": "790c07db685e3464ca485f2b30084f1c2d68ce15", "filename": "src/libcore/core", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fcore", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fcore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore?ref=3e0400fb86170baff30282edcdccff73e243fd6e"}, {"sha": "6a427297cc22d795ffdf604d1b631153a617dd44", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -129,7 +129,7 @@ type Visitor<'self> = &'self fn(root: **Word, tydesc: *Word) -> bool;\n \n // Walks the list of roots for the given safe point, and calls visitor\n // on each root.\n-unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n+unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n     let fp_bytes: *u8 = cast::transmute(fp);\n     let sp_meta: *u32 = cast::transmute(sp.sp_meta);\n \n@@ -155,7 +155,7 @@ unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n             } else {\n                 ptr::null()\n             };\n-            if !visitor(root, tydesc) { return; }\n+            if !visitor(root, tydesc) { return false; }\n         }\n         sri += 1;\n     }\n@@ -168,6 +168,16 @@ unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n         }\n         rri += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n+    _walk_safe_point(fp, sp, visitor);\n+}\n+#[cfg(not(stage0))]\n+unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n+    _walk_safe_point(fp, sp, visitor)\n }\n \n // Is fp contained in segment?\n@@ -222,7 +232,7 @@ static need_cleanup:    Memory = exchange_heap | stack;\n \n // Walks stack, searching for roots of the requested type, and passes\n // each root to the visitor.\n-unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n+unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> bool {\n     let mut segment = rustrt::rust_get_stack_segment();\n     let mut last_ret: *Word = ptr::null();\n     // To avoid collecting memory used by the GC itself, skip stack\n@@ -274,14 +284,14 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n                     // Root is a generic box.\n                     let refcount = **root;\n                     if mem | task_local_heap != 0 && refcount != -1 {\n-                        if !visitor(root, tydesc) { return; }\n+                        if !visitor(root, tydesc) { return false; }\n                     } else if mem | exchange_heap != 0 && refcount == -1 {\n-                        if !visitor(root, tydesc) { return; }\n+                        if !visitor(root, tydesc) { return false; }\n                     }\n                 } else {\n                     // Root is a non-immediate.\n                     if mem | stack != 0 {\n-                        if !visitor(root, tydesc) { return; }\n+                        if !visitor(root, tydesc) { return false; }\n                     }\n                 }\n             }\n@@ -290,8 +300,17 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n         }\n         reached_sentinel = delay_reached_sentinel;\n     }\n+    return true;\n }\n \n+#[cfg(stage0)]\n+unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n+    _walk_gc_roots(mem, sentinel, visitor);\n+}\n+#[cfg(not(stage0))]\n+unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> bool {\n+    _walk_gc_roots(mem, sentinel, visitor)\n+}\n pub fn gc() {\n     unsafe {\n         // Abort when GC is disabled."}, {"sha": "b5ae07208fc6689c6e4a64f98d6669e6175426c9", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 99, "deletions": 9, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -88,18 +88,32 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n     }\n \n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn bucket_sequence(&self, hash: uint,\n-                            op: &fn(uint) -> bool) -> uint {\n+                       op: &fn(uint) -> bool) {\n         let start_idx = self.to_bucket(hash);\n         let len_buckets = self.buckets.len();\n         let mut idx = start_idx;\n         loop {\n-            if !op(idx) {\n-                return idx;\n+            if !op(idx) { return; }\n+            idx = self.next_bucket(idx, len_buckets);\n+            if idx == start_idx {\n+                return;\n             }\n+        }\n+    }\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn bucket_sequence(&self, hash: uint,\n+                       op: &fn(uint) -> bool) -> bool {\n+        let start_idx = self.to_bucket(hash);\n+        let len_buckets = self.buckets.len();\n+        let mut idx = start_idx;\n+        loop {\n+            if !op(idx) { return false; }\n             idx = self.next_bucket(idx, len_buckets);\n             if idx == start_idx {\n-                return start_idx;\n+                return true;\n             }\n         }\n     }\n@@ -122,14 +136,14 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n                                 hash: uint,\n                                 k: &K)\n                              -> SearchResult {\n-        let _ = for self.bucket_sequence(hash) |i| {\n+        for self.bucket_sequence(hash) |i| {\n             match self.buckets[i] {\n                 Some(ref bkt) => if bkt.hash == hash && *k == bkt.key {\n                     return FoundEntry(i);\n                 },\n                 None => return FoundHole(i)\n             }\n-        };\n+        }\n         TableFull\n     }\n \n@@ -138,7 +152,7 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n                                                   hash: uint,\n                                                   k: &Q)\n                                                -> SearchResult {\n-        let _ = for self.bucket_sequence(hash) |i| {\n+        for self.bucket_sequence(hash) |i| {\n             match self.buckets[i] {\n                 Some(ref bkt) => {\n                     if bkt.hash == hash && k.equiv(&bkt.key) {\n@@ -147,7 +161,7 @@ priv impl<K:Hash + Eq,V> HashMap<K, V> {\n                 },\n                 None => return FoundHole(i)\n             }\n-        };\n+        }\n         TableFull\n     }\n \n@@ -311,7 +325,8 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all key-value pairs\n-    fn each<'a>(&'a self, blk: &fn(&'a K, &'a V) -> bool) {\n+    #[cfg(stage0)]\n+    fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             for self.buckets[i].each |bucket| {\n                 if !blk(&bucket.key, &bucket.value) {\n@@ -321,17 +336,45 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n+    /// Visit all key-value pairs\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) -> bool {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            for self.buckets[i].each |bucket| {\n+                if !blk(&bucket.key, &bucket.value) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n     /// Visit all keys\n+    #[cfg(stage0)]\n     fn each_key(&self, blk: &fn(k: &K) -> bool) {\n         self.each(|k, _| blk(k))\n     }\n \n+    /// Visit all keys\n+    #[cfg(not(stage0))]\n+    fn each_key(&self, blk: &fn(k: &K) -> bool) -> bool {\n+        self.each(|k, _| blk(k))\n+    }\n+\n     /// Visit all values\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n \n+    /// Visit all values\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) -> bool {\n+        self.each(|_, v| blk(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             match self.buckets[i] {\n@@ -343,6 +386,20 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n+    /// Iterate over the map and mutate the contained values\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) -> bool {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            match self.buckets[i] {\n+              Some(Bucket{key: ref key, value: ref mut value, _}) => {\n+                if !blk(key, value) { return false; }\n+              }\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n         match self.bucket_for_key(k) {\n@@ -632,7 +689,10 @@ pub struct HashSet<T> {\n \n impl<T:Hash + Eq> BaseIter<T> for HashSet<T> {\n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n@@ -683,6 +743,7 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     }\n \n     /// Visit the values representing the difference\n+    #[cfg(stage0)]\n     fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n         for self.each |v| {\n             if !other.contains(v) {\n@@ -691,15 +752,31 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n         }\n     }\n \n+    /// Visit the values representing the difference\n+    #[cfg(not(stage0))]\n+    fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n+        self.each(|v| other.contains(v) || f(v))\n+    }\n+\n     /// Visit the values representing the symmetric difference\n+    #[cfg(stage0)]\n     fn symmetric_difference(&self,\n                             other: &HashSet<T>,\n                             f: &fn(&T) -> bool) {\n         self.difference(other, f);\n         other.difference(self, f);\n     }\n \n+    /// Visit the values representing the symmetric difference\n+    #[cfg(not(stage0))]\n+    fn symmetric_difference(&self,\n+                            other: &HashSet<T>,\n+                            f: &fn(&T) -> bool) -> bool {\n+        self.difference(other, f) && other.difference(self, f)\n+    }\n+\n     /// Visit the values representing the intersection\n+    #[cfg(stage0)]\n     fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n         for self.each |v| {\n             if other.contains(v) {\n@@ -708,7 +785,14 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n         }\n     }\n \n+    /// Visit the values representing the intersection\n+    #[cfg(not(stage0))]\n+    fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n+        self.each(|v| !other.contains(v) || f(v))\n+    }\n+\n     /// Visit the values representing the union\n+    #[cfg(stage0)]\n     fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) {\n         for self.each |v| {\n             if !f(v) { return }\n@@ -720,6 +804,12 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n             }\n         }\n     }\n+\n+    /// Visit the values representing the union\n+    #[cfg(not(stage0))]\n+    fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n+        self.each(f) && other.each(|v| self.contains(v) || f(v))\n+    }\n }\n \n pub impl <T:Hash + Eq> HashSet<T> {"}, {"sha": "67fc71a941e06b0e4ada8b5a99cb62a9f65f3893", "filename": "src/libcore/io.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -247,7 +247,10 @@ pub trait ReaderUtil {\n     *\n     * None right now.\n     */\n+    #[cfg(stage0)]\n     fn each_byte(&self, it: &fn(int) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_byte(&self, it: &fn(int) -> bool) -> bool;\n \n     /**\n     * Iterate over every char until EOF or the iterator breaks.\n@@ -256,7 +259,10 @@ pub trait ReaderUtil {\n     *\n     * None right now.\n     */\n+    #[cfg(stage0)]\n     fn each_char(&self, it: &fn(char) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_char(&self, it: &fn(char) -> bool) -> bool;\n \n     /**\n     * Iterate over every line until EOF or the iterator breaks.\n@@ -265,7 +271,10 @@ pub trait ReaderUtil {\n     *\n     * None right now.\n     */\n+    #[cfg(stage0)]\n     fn each_line(&self, it: &fn(&str) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_line(&self, it: &fn(&str) -> bool) -> bool;\n \n     /**\n     * Reads all of the lines in the stream.\n@@ -676,18 +685,35 @@ impl<T:Reader> ReaderUtil for T {\n         bytes\n     }\n \n+    #[cfg(stage0)]\n     fn each_byte(&self, it: &fn(int) -> bool) {\n         while !self.eof() {\n             if !it(self.read_byte()) { break; }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_byte(&self, it: &fn(int) -> bool) -> bool {\n+        while !self.eof() {\n+            if !it(self.read_byte()) { return false; }\n+        }\n+        return true;\n+    }\n \n+    #[cfg(stage0)]\n     fn each_char(&self, it: &fn(char) -> bool) {\n         while !self.eof() {\n             if !it(self.read_char()) { break; }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_char(&self, it: &fn(char) -> bool) -> bool {\n+        while !self.eof() {\n+            if !it(self.read_char()) { return false; }\n+        }\n+        return true;\n+    }\n \n+    #[cfg(stage0)]\n     fn each_line(&self, it: &fn(s: &str) -> bool) {\n         while !self.eof() {\n             // include the \\n, so that we can distinguish an entirely empty\n@@ -707,6 +733,27 @@ impl<T:Reader> ReaderUtil for T {\n             if !it(line) { break; }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_line(&self, it: &fn(s: &str) -> bool) -> bool {\n+        while !self.eof() {\n+            // include the \\n, so that we can distinguish an entirely empty\n+            // line read after \"...\\n\", and the trailing empty line in\n+            // \"...\\n\\n\".\n+            let mut line = self.read_until('\\n' as u8, true);\n+\n+            // blank line at the end of the reader is ignored\n+            if self.eof() && line.is_empty() { break; }\n+\n+            // trim the \\n, so that each_line is consistent with read_line\n+            let n = str::len(line);\n+            if line[n-1] == '\\n' as u8 {\n+                unsafe { str::raw::set_len(&mut line, n-1); }\n+            }\n+\n+            if !it(line) { return false; }\n+        }\n+        return true;\n+    }\n \n     fn read_lines(&self) -> ~[~str] {\n         do vec::build |push| {"}, {"sha": "d5649d3dfd297bab082fa470b024382fa95e4d22", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -40,12 +40,17 @@ much easier to implement.\n \n */\n \n-use cmp::Ord;\n-use option::{Option, Some, None};\n+#[cfg(not(stage0))] use cmp::Ord;\n+#[cfg(not(stage0))] use option::{Option, Some, None};\n \n+#[cfg(stage0)]\n pub trait Times {\n     fn times(&self, it: &fn() -> bool);\n }\n+#[cfg(not(stage0))]\n+pub trait Times {\n+    fn times(&self, it: &fn() -> bool) -> bool;\n+}\n \n /**\n  * Transform an internal iterator into an owned vector.\n@@ -59,7 +64,8 @@ pub trait Times {\n  * ~~~\n  */\n #[inline(always)]\n-pub fn to_vec<T>(iter: &fn(f: &fn(T) -> bool)) -> ~[T] {\n+#[cfg(not(stage0))]\n+pub fn to_vec<T>(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n     let mut v = ~[];\n     for iter |x| { v.push(x) }\n     v\n@@ -77,13 +83,15 @@ pub fn to_vec<T>(iter: &fn(f: &fn(T) -> bool)) -> ~[T] {\n  * ~~~~\n  */\n #[inline(always)]\n-pub fn any<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n+#[cfg(not(stage0))]\n+pub fn any<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n     for iter |x| {\n         if predicate(x) {\n-            return true\n+            return true;\n         }\n     }\n-    false\n+    return false;\n }\n \n /**\n@@ -97,13 +105,34 @@ pub fn any<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n  * ~~~~\n  */\n #[inline(always)]\n-pub fn all<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n+#[cfg(stage0)]\n+pub fn all<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool)) -> bool {\n     for iter |x| {\n         if !predicate(x) {\n-            return false\n+            return false;\n         }\n     }\n-    true\n+    return true;\n+}\n+\n+/**\n+ * Return true if `predicate` is true for all values yielded by an internal iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~~\n+ * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n+ * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n+ * ~~~~\n+ */\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn all<T>(predicate: &fn(T) -> bool,\n+              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n+    // If we ever break, iter will return false, so this will only return true\n+    // if predicate returns true for everything.\n+    iter(|x| predicate(x))\n }\n \n /**\n@@ -117,7 +146,9 @@ pub fn all<T>(predicate: &fn(T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> bool {\n  * ~~~~\n  */\n #[inline(always)]\n-pub fn find<T>(predicate: &fn(&T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n+#[cfg(not(stage0))]\n+pub fn find<T>(predicate: &fn(&T) -> bool,\n+               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     for iter |x| {\n         if predicate(&x) {\n             return Some(x);\n@@ -137,7 +168,8 @@ pub fn find<T>(predicate: &fn(&T) -> bool, iter: &fn(f: &fn(T) -> bool)) -> Opti\n  * ~~~~\n  */\n #[inline]\n-pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n+#[cfg(not(stage0))]\n+pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     let mut result = None;\n     for iter |x| {\n         match result {\n@@ -163,7 +195,8 @@ pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n  * ~~~~\n  */\n #[inline]\n-pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool)) -> Option<T> {\n+#[cfg(not(stage0))]\n+pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     let mut result = None;\n     for iter |x| {\n         match result {"}, {"sha": "40c9637f692bc79835bf5cac2b90672cf011aaf5", "filename": "src/libcore/iterator.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiterator.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -41,7 +41,10 @@ pub trait IteratorUtil<A> {\n     fn take(self, n: uint) -> TakeIterator<Self>;\n     fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n         -> ScanIterator<'r, A, B, Self, St>;\n+    #[cfg(stage0)]\n     fn advance(&mut self, f: &fn(A) -> bool);\n+    #[cfg(not(stage0))]\n+    fn advance(&mut self, f: &fn(A) -> bool) -> bool;\n }\n \n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n@@ -103,13 +106,28 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     /// A shim implementing the `for` loop iteration protocol for iterator objects\n     #[inline]\n+    #[cfg(stage0)]\n     fn advance(&mut self, f: &fn(A) -> bool) {\n         loop {\n             match self.next() {\n                 Some(x) => {\n-                    if !f(x) { return }\n+                    if !f(x) { return; }\n                 }\n-                None => return\n+                None => { return; }\n+            }\n+        }\n+    }\n+\n+    /// A shim implementing the `for` loop iteration protocol for iterator objects\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n+        loop {\n+            match self.next() {\n+                Some(x) => {\n+                    if !f(x) { return false; }\n+                }\n+                None => { return true; }\n             }\n         }\n     }"}, {"sha": "f2bba6a4639042527893f284ef8802af8a3b6aca", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -86,38 +86,63 @@ pub fn gt(x: T, y: T) -> bool { x > y }\n ///\n #[inline(always)]\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n-pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n+pub fn _range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n     } else if step > 0 { // ascending\n         while i < stop {\n-            if !it(i) { break }\n+            if !it(i) { return false; }\n             // avoiding overflow. break if i + step > max_value\n-            if i > max_value - step { break; }\n+            if i > max_value - step { return true; }\n             i += step;\n         }\n     } else { // descending\n         while i > stop {\n-            if !it(i) { break }\n+            if !it(i) { return false; }\n             // avoiding underflow. break if i + step < min_value\n-            if i < min_value - step { break; }\n+            if i < min_value - step { return true; }\n             i += step;\n         }\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n+    _range_step(start, stop, step, it);\n+}\n+#[cfg(not(stage0))]\n+pub fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) -> bool {\n+    _range_step(start, stop, step, it)\n }\n \n #[inline(always)]\n+#[cfg(stage0)]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T, it);\n }\n \n #[inline(always)]\n+#[cfg(not(stage0))]\n+/// Iterate over the range [`lo`..`hi`)\n+pub fn range(lo: T, hi: T, it: &fn(T) -> bool) -> bool {\n+    range_step(lo, hi, 1 as T, it)\n+}\n+\n+#[inline(always)]\n+#[cfg(stage0)]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T, it);\n }\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+/// Iterate over the range [`hi`..`lo`)\n+pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) -> bool {\n+    range_step(hi, lo, -1 as T, it)\n+}\n \n /// Computes the bitwise complement\n #[inline(always)]"}, {"sha": "1c115ee507203cde52ef740da88697d5c5618692", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -51,43 +51,69 @@ pub fn gt(x: T, y: T) -> bool { x > y }\n ///\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n ///\n-pub fn range_step(start: T,\n-                       stop: T,\n-                       step: T_SIGNED,\n-                       it: &fn(T) -> bool) {\n+pub fn _range_step(start: T,\n+                   stop: T,\n+                   step: T_SIGNED,\n+                   it: &fn(T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n     }\n     if step >= 0 {\n         while i < stop {\n-            if !it(i) { break }\n+            if !it(i) { return false; }\n             // avoiding overflow. break if i + step > max_value\n-            if i > max_value - (step as T) { break; }\n+            if i > max_value - (step as T) { return true; }\n             i += step as T;\n         }\n     } else {\n         while i > stop {\n-            if !it(i) { break }\n+            if !it(i) { return false; }\n             // avoiding underflow. break if i + step < min_value\n-            if i < min_value + ((-step) as T) { break; }\n+            if i < min_value + ((-step) as T) { return true; }\n             i -= -step as T;\n         }\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn range_step(start: T, stop: T, step: T_SIGNED, it: &fn(T) -> bool) {\n+    _range_step(start, stop, step, it);\n+}\n+#[cfg(not(stage0))]\n+pub fn range_step(start: T, stop: T, step: T_SIGNED, it: &fn(T) -> bool) -> bool {\n+    _range_step(start, stop, step, it)\n }\n \n #[inline(always)]\n+#[cfg(stage0)]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T_SIGNED, it);\n }\n \n #[inline(always)]\n+#[cfg(not(stage0))]\n+/// Iterate over the range [`lo`..`hi`)\n+pub fn range(lo: T, hi: T, it: &fn(T) -> bool) -> bool {\n+    range_step(lo, hi, 1 as T_SIGNED, it)\n+}\n+\n+#[inline(always)]\n+#[cfg(stage0)]\n /// Iterate over the range [`hi`..`lo`)\n pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T_SIGNED, it);\n }\n \n+#[inline(always)]\n+#[cfg(not(stage0))]\n+/// Iterate over the range [`hi`..`lo`)\n+pub fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) -> bool {\n+    range_step(hi, lo, -1 as T_SIGNED, it)\n+}\n+\n /// Computes the bitwise complement\n #[inline(always)]\n pub fn compl(i: T) -> T {"}, {"sha": "d8a4ec19304f36cb409fbe4804b0ca1355cc03c9", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -154,6 +154,7 @@ pub mod inst {\n         return true;\n     }\n \n+    #[cfg(stage0)]\n     impl iter::Times for uint {\n         #[inline(always)]\n         ///\n@@ -175,6 +176,29 @@ pub mod inst {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    impl iter::Times for uint {\n+        #[inline(always)]\n+        ///\n+        /// A convenience form for basic iteration. Given a uint `x`,\n+        /// `for x.times { ... }` executes the given block x times.\n+        ///\n+        /// Equivalent to `for uint::range(0, x) |_| { ... }`.\n+        ///\n+        /// Not defined on all integer types to permit unambiguous\n+        /// use with integer literals of inferred integer-type as\n+        /// the self-value (eg. `for 100.times { ... }`).\n+        ///\n+        fn times(&self, it: &fn() -> bool) -> bool {\n+            let mut i = *self;\n+            while i > 0 {\n+                if !it() { return false; }\n+                i -= 1;\n+            }\n+            return true;\n+        }\n+    }\n+\n     /// Returns the smallest power of 2 greater than or equal to `n`\n     #[inline(always)]\n     pub fn next_power_of_two(n: uint) -> uint {"}, {"sha": "8e31bbfd8781b71c3d6f040a6e8090dc0ff4e950", "filename": "src/libcore/old_iter.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fold_iter.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -22,21 +22,40 @@ use vec;\n /// A function used to initialize the elements of a sequence\n pub type InitOp<'self,T> = &'self fn(uint) -> T;\n \n+#[cfg(stage0)]\n pub trait BaseIter<A> {\n     fn each(&self, blk: &fn(v: &A) -> bool);\n     fn size_hint(&self) -> Option<uint>;\n }\n+#[cfg(not(stage0))]\n+pub trait BaseIter<A> {\n+    fn each(&self, blk: &fn(v: &A) -> bool) -> bool;\n+    fn size_hint(&self) -> Option<uint>;\n+}\n \n+#[cfg(stage0)]\n pub trait ReverseIter<A>: BaseIter<A> {\n     fn each_reverse(&self, blk: &fn(&A) -> bool);\n }\n+#[cfg(not(stage0))]\n+pub trait ReverseIter<A>: BaseIter<A> {\n+    fn each_reverse(&self, blk: &fn(&A) -> bool) -> bool;\n+}\n \n+#[cfg(stage0)]\n pub trait MutableIter<A>: BaseIter<A> {\n     fn each_mut(&mut self, blk: &fn(&mut A) -> bool);\n }\n+#[cfg(not(stage0))]\n+pub trait MutableIter<A>: BaseIter<A> {\n+    fn each_mut(&mut self, blk: &fn(&mut A) -> bool) -> bool;\n+}\n \n pub trait ExtendedIter<A> {\n+    #[cfg(stage0)]\n     fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n+    #[cfg(not(stage0))]\n+    fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool;\n     fn all(&self, blk: &fn(&A) -> bool) -> bool;\n     fn any(&self, blk: &fn(&A) -> bool) -> bool;\n     fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n@@ -45,9 +64,14 @@ pub trait ExtendedIter<A> {\n     fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n+#[cfg(stage0)]\n pub trait ExtendedMutableIter<A> {\n     fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool);\n }\n+#[cfg(not(stage0))]\n+pub trait ExtendedMutableIter<A> {\n+    fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool) -> bool;\n+}\n \n pub trait EqIter<A:Eq> {\n     fn contains(&self, x: &A) -> bool;\n@@ -92,12 +116,22 @@ pub trait Buildable<A> {\n }\n \n #[inline(always)]\n-pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) {\n+pub fn _eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n     let mut i = 0;\n     for self.each |a| {\n-        if !blk(i, a) { break; }\n+        if !blk(i, a) { return false; }\n         i += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) {\n+    _eachi(self, blk);\n+}\n+#[cfg(not(stage0))]\n+pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n+    _eachi(self, blk)\n }\n \n #[inline(always)]\n@@ -199,13 +233,24 @@ pub fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n // it would have to be implemented with foldr, which is too inefficient.\n \n #[inline(always)]\n+#[cfg(stage0)]\n pub fn repeat(times: uint, blk: &fn() -> bool) {\n     let mut i = 0;\n     while i < times {\n         if !blk() { break }\n         i += 1;\n     }\n }\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn repeat(times: uint, blk: &fn() -> bool) -> bool {\n+    let mut i = 0;\n+    while i < times {\n+        if !blk() { return false; }\n+        i += 1;\n+    }\n+    return true;\n+}\n \n #[inline(always)]\n pub fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {"}, {"sha": "7cb408767058cfc35c5cca05b47214e55c81f836", "filename": "src/libcore/option.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -101,9 +101,16 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n     }\n+    /// Performs an operation on the contained value by reference\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) -> bool {\n+        match *self { None => true, Some(ref t) => { f(t) } }\n+    }\n \n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> {\n@@ -112,16 +119,27 @@ impl<T> BaseIter<T> for Option<T> {\n }\n \n impl<T> MutableIter<T> for Option<T> {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) {\n         match *self { None => (), Some(ref mut t) => { f(t); } }\n     }\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) -> bool {\n+        match *self { None => true, Some(ref mut t) => { f(t) } }\n+    }\n }\n \n impl<A> ExtendedIter<A> for Option<A> {\n+    #[cfg(stage0)]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }"}, {"sha": "299b9429ac3ee353cbc8f1493d2755266b57fd00", "filename": "src/libcore/os.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -550,6 +550,7 @@ pub fn tmpdir() -> Path {\n     }\n }\n /// Recursively walk a directory structure\n+#[cfg(stage0)]\n pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) {\n \n     walk_dir_(p, f);\n@@ -577,6 +578,14 @@ pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) {\n         return keepgoing;\n     }\n }\n+/// Recursively walk a directory structure\n+#[cfg(not(stage0))]\n+pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n+    list_dir(p).each(|q| {\n+        let path = &p.push(*q);\n+        f(path) && (!path_is_dir(path) || walk_dir(path, f))\n+    })\n+}\n \n /// Indicates whether a path represents a directory\n pub fn path_is_dir(p: &Path) -> bool {"}, {"sha": "e86416f2499024f59f7c0ad718a516fcf3fb2329", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -24,6 +24,7 @@ pub fn Frame(fp: *Word) -> Frame {\n     }\n }\n \n+#[cfg(stage0)]\n pub fn walk_stack(visit: &fn(Frame) -> bool) {\n \n     debug!(\"beginning stack walk\");\n@@ -51,6 +52,35 @@ pub fn walk_stack(visit: &fn(Frame) -> bool) {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+pub fn walk_stack(visit: &fn(Frame) -> bool) -> bool {\n+\n+    debug!(\"beginning stack walk\");\n+\n+    do frame_address |frame_pointer| {\n+        let mut frame_address: *Word = unsafe {\n+            transmute(frame_pointer)\n+        };\n+        loop {\n+            let fr = Frame(frame_address);\n+\n+            debug!(\"frame: %x\", unsafe { transmute(fr.fp) });\n+            visit(fr);\n+\n+            unsafe {\n+                let next_fp: **Word = transmute(frame_address);\n+                frame_address = *next_fp;\n+                if *frame_address == 0u {\n+                    debug!(\"encountered task_start_wrapper. ending walk\");\n+                    // This is the task_start_wrapper_frame. There is\n+                    // no stack beneath it and it is a foreign frame.\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    return true;\n+}\n \n #[test]\n fn test_simple() {"}, {"sha": "d7b27f53e7a78a7b8a83320939b1c6c465d9dbab", "filename": "src/libcore/str.rs", "status": "modified", "additions": 412, "deletions": 25, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -566,14 +566,30 @@ pub fn slice<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n+#[cfg(stage0)]\n pub fn each_split_char<'a>(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), true, true, it);\n+}\n+\n+/// Splits a string into substrings at each occurrence of a given character\n+#[cfg(not(stage0))]\n+pub fn each_split_char<'a>(s: &'a str, sep: char,\n+                           it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_inner(s, sep, len(s), true, true, it)\n }\n \n /// Like `each_split_char`, but a trailing empty string is omitted\n+#[cfg(stage0)]\n pub fn each_split_char_no_trailing<'a>(s: &'a str,\n                                        sep: char,\n                                        it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), true, false, it);\n+}\n+/// Like `each_split_char`, but a trailing empty string is omitted\n+#[cfg(not(stage0))]\n+pub fn each_split_char_no_trailing<'a>(s: &'a str,\n+                                       sep: char,\n+                                       it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_inner(s, sep, len(s), true, false, it)\n }\n \n@@ -583,17 +599,39 @@ pub fn each_split_char_no_trailing<'a>(s: &'a str,\n  *\n  * The character must be a valid UTF-8/ASCII character\n  */\n+#[cfg(stage0)]\n pub fn each_splitn_char<'a>(s: &'a str,\n                             sep: char,\n                             count: uint,\n                             it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, count, true, true, it);\n+}\n+/**\n+ * Splits a string into substrings at each occurrence of a given\n+ * character up to 'count' times.\n+ *\n+ * The character must be a valid UTF-8/ASCII character\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_splitn_char<'a>(s: &'a str,\n+                            sep: char,\n+                            count: uint,\n+                            it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_inner(s, sep, count, true, true, it)\n }\n \n /// Like `each_split_char`, but omits empty strings\n+#[cfg(stage0)]\n pub fn each_split_char_nonempty<'a>(s: &'a str,\n                                     sep: char,\n                                     it: &fn(&'a str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), false, false, it);\n+}\n+/// Like `each_split_char`, but omits empty strings\n+#[cfg(not(stage0))]\n+pub fn each_split_char_nonempty<'a>(s: &'a str,\n+                                    sep: char,\n+                                    it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_inner(s, sep, len(s), false, false, it)\n }\n \n@@ -602,15 +640,17 @@ fn each_split_char_inner<'a>(s: &'a str,\n                              count: uint,\n                              allow_empty: bool,\n                              allow_trailing_empty: bool,\n-                             it: &fn(&'a str) -> bool) {\n+                             it: &fn(&'a str) -> bool) -> bool {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut done = 0u;\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i {\n-                    if !it( unsafe{ raw::slice_bytes(s, start, i) } ) { return; }\n+                    if !it( unsafe{ raw::slice_bytes(s, start, i) } ) {\n+                        return false;\n+                    }\n                 }\n                 start = i + 1u;\n                 done += 1u;\n@@ -619,42 +659,79 @@ fn each_split_char_inner<'a>(s: &'a str,\n         }\n         // only slice a non-empty trailing substring\n         if allow_trailing_empty || start < l {\n-            if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return; }\n+            if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return false; }\n         }\n-    } else {\n-        each_split_inner(s, |cur| cur == sep, count, allow_empty, allow_trailing_empty, it)\n+        return true;\n     }\n+    return each_split_inner(s, |cur| cur == sep, count,\n+                            allow_empty, allow_trailing_empty, it)\n }\n \n /// Splits a string into substrings using a character function\n+#[cfg(stage0)]\n pub fn each_split<'a>(s: &'a str,\n                       sepfn: &fn(char) -> bool,\n                       it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), true, true, it);\n+}\n+/// Splits a string into substrings using a character function\n+#[cfg(not(stage0))]\n+pub fn each_split<'a>(s: &'a str,\n+                      sepfn: &fn(char) -> bool,\n+                      it: &fn(&'a str) -> bool) -> bool {\n     each_split_inner(s, sepfn, len(s), true, true, it)\n }\n \n /// Like `each_split`, but a trailing empty string is omitted\n+#[cfg(stage0)]\n pub fn each_split_no_trailing<'a>(s: &'a str,\n                                   sepfn: &fn(char) -> bool,\n                                   it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), true, false, it);\n+}\n+/// Like `each_split`, but a trailing empty string is omitted\n+#[cfg(not(stage0))]\n+pub fn each_split_no_trailing<'a>(s: &'a str,\n+                                  sepfn: &fn(char) -> bool,\n+                                  it: &fn(&'a str) -> bool) -> bool {\n     each_split_inner(s, sepfn, len(s), true, false, it)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n+#[cfg(stage0)]\n pub fn each_splitn<'a>(s: &'a str,\n                        sepfn: &fn(char) -> bool,\n                        count: uint,\n                        it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, count, true, true, it);\n+}\n+/**\n+ * Splits a string into substrings using a character function, cutting at\n+ * most `count` times.\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_splitn<'a>(s: &'a str,\n+                       sepfn: &fn(char) -> bool,\n+                       count: uint,\n+                       it: &fn(&'a str) -> bool) -> bool {\n     each_split_inner(s, sepfn, count, true, true, it)\n }\n \n /// Like `each_split`, but omits empty strings\n+#[cfg(stage0)]\n pub fn each_split_nonempty<'a>(s: &'a str,\n                                sepfn: &fn(char) -> bool,\n                                it: &fn(&'a str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), false, false, it);\n+}\n+/// Like `each_split`, but omits empty strings\n+#[cfg(not(stage0))]\n+pub fn each_split_nonempty<'a>(s: &'a str,\n+                               sepfn: &fn(char) -> bool,\n+                               it: &fn(&'a str) -> bool) -> bool {\n     each_split_inner(s, sepfn, len(s), false, false, it)\n }\n \n@@ -663,27 +740,32 @@ fn each_split_inner<'a>(s: &'a str,\n                         count: uint,\n                         allow_empty: bool,\n                         allow_trailing_empty: bool,\n-                        it: &fn(&'a str) -> bool) {\n+                        it: &fn(&'a str) -> bool) -> bool {\n     let l = len(s);\n     let mut i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n         let CharRange {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i {\n-                if !it( unsafe{ raw::slice_bytes(s, start, i) } ) { return; }\n+                if !it( unsafe{ raw::slice_bytes(s, start, i) } ) {\n+                    return false;\n+                }\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_trailing_empty || start < l {\n-        if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return;  }\n+        if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return false; }\n     }\n+    return true;\n }\n \n // See Issue #1932 for why this is a naive search\n-fn iter_matches<'a,'b>(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n+#[cfg(stage0)]\n+fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n+                       f: &fn(uint, uint) -> bool) {\n     let sep_len = len(sep), l = len(s);\n     assert!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -709,7 +791,38 @@ fn iter_matches<'a,'b>(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n         }\n     }\n }\n+// See Issue #1932 for why this is a naive search\n+#[cfg(not(stage0))]\n+fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n+                       f: &fn(uint, uint) -> bool) -> bool {\n+    let sep_len = len(sep), l = len(s);\n+    assert!(sep_len > 0u);\n+    let mut i = 0u, match_start = 0u, match_i = 0u;\n+\n+    while i < l {\n+        if s[i] == sep[match_i] {\n+            if match_i == 0u { match_start = i; }\n+            match_i += 1u;\n+            // Found a match\n+            if match_i == sep_len {\n+                if !f(match_start, i + 1u) { return false; }\n+                match_i = 0u;\n+            }\n+            i += 1u;\n+        } else {\n+            // Failed match, backtrack\n+            if match_i > 0u {\n+                match_i = 0u;\n+                i = match_start + 1u;\n+            } else {\n+                i += 1u;\n+            }\n+        }\n+    }\n+    return true;\n+}\n \n+#[cfg(stage0)]\n fn iter_between_matches<'a,'b>(s: &'a str,\n                                sep: &'b str,\n                                f: &fn(uint, uint) -> bool) {\n@@ -720,6 +833,17 @@ fn iter_between_matches<'a,'b>(s: &'a str,\n     }\n     f(last_end, len(s));\n }\n+#[cfg(not(stage0))]\n+fn iter_between_matches<'a,'b>(s: &'a str,\n+                               sep: &'b str,\n+                               f: &fn(uint, uint) -> bool) -> bool {\n+    let mut last_end = 0u;\n+    for iter_matches(s, sep) |from, to| {\n+        if !f(last_end, from) { return false; }\n+        last_end = to;\n+    }\n+    return f(last_end, len(s));\n+}\n \n /**\n  * Splits a string into a vector of the substrings separated by a given string\n@@ -732,14 +856,36 @@ fn iter_between_matches<'a,'b>(s: &'a str,\n  * assert!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n  * ~~~\n  */\n+#[cfg(stage0)]\n pub fn each_split_str<'a,'b>(s: &'a str,\n                              sep: &'b str,\n                              it: &fn(&'a str) -> bool) {\n     for iter_between_matches(s, sep) |from, to| {\n         if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n     }\n }\n+/**\n+ * Splits a string into a vector of the substrings separated by a given string\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * let mut v = ~[];\n+ * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n+ * assert!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n+ * ~~~\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_split_str<'a,'b>(s: &'a str,\n+                             sep: &'b str,\n+                             it: &fn(&'a str) -> bool) -> bool {\n+    for iter_between_matches(s, sep) |from, to| {\n+        if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return false; }\n+    }\n+    return true;\n+}\n \n+#[cfg(stage0)]\n pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n                                       sep: &'b str,\n                                       it: &fn(&'a str) -> bool) {\n@@ -750,6 +896,18 @@ pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn each_split_str_nonempty<'a,'b>(s: &'a str,\n+                                      sep: &'b str,\n+                                      it: &fn(&'a str) -> bool) -> bool {\n+    for iter_between_matches(s, sep) |from, to| {\n+        if to > from {\n+            if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return false; }\n+        }\n+    }\n+    return true;\n+}\n+\n /// Levenshtein Distance between two strings\n pub fn levdistance(s: &str, t: &str) -> uint {\n \n@@ -787,14 +945,23 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n /**\n  * Splits a string into substrings separated by LF ('\\n').\n  */\n+#[cfg(stage0)]\n pub fn each_line<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n+    each_split_char_no_trailing(s, '\\n', it);\n+}\n+/**\n+ * Splits a string into substrings separated by LF ('\\n').\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_line<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n     each_split_char_no_trailing(s, '\\n', it)\n }\n \n /**\n  * Splits a string into substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n+#[cfg(stage0)]\n pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n     for each_line(s) |s| {\n         let l = s.len();\n@@ -805,9 +972,31 @@ pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n         }\n     }\n }\n+/**\n+ * Splits a string into substrings separated by LF ('\\n')\n+ * and/or CR LF (\"\\r\\n\")\n+ */\n+#[cfg(not(stage0))]\n+pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n+    for each_line(s) |s| {\n+        let l = s.len();\n+        if l > 0u && s[l - 1u] == '\\r' as u8 {\n+            if !it( unsafe { raw::slice_bytes(s, 0, l - 1) } ) { return false; }\n+        } else {\n+            if !it( s ) { return false; }\n+        }\n+    }\n+    return true;\n+}\n \n /// Splits a string into substrings separated by whitespace\n+#[cfg(stage0)]\n pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n+    each_split_nonempty(s, char::is_whitespace, it);\n+}\n+/// Splits a string into substrings separated by whitespace\n+#[cfg(not(stage0))]\n+pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) -> bool {\n     each_split_nonempty(s, char::is_whitespace, it)\n }\n \n@@ -820,9 +1009,9 @@ pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n  *  Fails during iteration if the string contains a non-whitespace\n  *  sequence longer than the limit.\n  */\n-pub fn each_split_within<'a>(ss: &'a str,\n-                             lim: uint,\n-                             it: &fn(&'a str) -> bool) {\n+pub fn _each_split_within<'a>(ss: &'a str,\n+                              lim: uint,\n+                              it: &fn(&'a str) -> bool) -> bool {\n     // Just for fun, let's write this as an state machine:\n \n     enum SplitWithinState {\n@@ -880,6 +1069,20 @@ pub fn each_split_within<'a>(ss: &'a str,\n         machine(fake_i, ' ');\n         fake_i += 1;\n     }\n+    return cont;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each_split_within<'a>(ss: &'a str,\n+                             lim: uint,\n+                             it: &fn(&'a str) -> bool) {\n+    _each_split_within(ss, lim, it);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_split_within<'a>(ss: &'a str,\n+                             lim: uint,\n+                             it: &fn(&'a str) -> bool) -> bool {\n+    _each_split_within(ss, lim, it)\n }\n \n /**\n@@ -1158,12 +1361,20 @@ pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each(s: &str, it: &fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b))\n }\n+/// Iterate over the bytes in a string\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each(s: &str, it: &fn(u8) -> bool) -> bool {\n+    eachi(s, |_i, b| it(b))\n+}\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut pos = 0;\n     let len = s.len();\n@@ -1174,24 +1385,58 @@ pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n     }\n }\n \n+/// Iterate over the bytes in a string, with indices\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n+    let mut pos = 0;\n+    let len = s.len();\n+\n+    while pos < len {\n+        if !it(pos, s[pos]) { return false; }\n+        pos += 1;\n+    }\n+    return true;\n+}\n+\n /// Iterate over the bytes in a string in reverse\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_reverse(s: &str, it: &fn(u8) -> bool) {\n     eachi_reverse(s, |_i, b| it(b) )\n }\n+/// Iterate over the bytes in a string in reverse\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_reverse(s: &str, it: &fn(u8) -> bool) -> bool {\n+    eachi_reverse(s, |_i, b| it(b) )\n+}\n \n /// Iterate over the bytes in a string in reverse, with indices\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut pos = s.len();\n     while pos > 0 {\n         pos -= 1;\n         if !it(pos, s[pos]) { break; }\n     }\n }\n+/// Iterate over the bytes in a string in reverse, with indices\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n+    let mut pos = s.len();\n+    while pos > 0 {\n+        pos -= 1;\n+        if !it(pos, s[pos]) { return false; }\n+    }\n+    return true;\n+}\n \n /// Iterate over each char of a string, without allocating\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_char(s: &str, it: &fn(char) -> bool) {\n     let mut i = 0;\n     let len = len(s);\n@@ -1201,9 +1446,23 @@ pub fn each_char(s: &str, it: &fn(char) -> bool) {\n         i = next;\n     }\n }\n+/// Iterate over each char of a string, without allocating\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_char(s: &str, it: &fn(char) -> bool) -> bool {\n+    let mut i = 0;\n+    let len = len(s);\n+    while i < len {\n+        let CharRange {ch, next} = char_range_at(s, i);\n+        if !it(ch) { return false; }\n+        i = next;\n+    }\n+    return true;\n+}\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n     let mut pos = 0;\n     let mut ch_pos = 0u;\n@@ -1215,15 +1474,38 @@ pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n         ch_pos += 1u;\n     }\n }\n+/// Iterates over the chars in a string, with indices\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) -> bool {\n+    let mut pos = 0;\n+    let mut ch_pos = 0u;\n+    let len = s.len();\n+    while pos < len {\n+        let CharRange {ch, next} = char_range_at(s, pos);\n+        pos = next;\n+        if !it(ch_pos, ch) { return false; }\n+        ch_pos += 1u;\n+    }\n+    return true;\n+}\n \n /// Iterates over the chars in a string in reverse\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) {\n     each_chari_reverse(s, |_, c| it(c))\n }\n+/// Iterates over the chars in a string in reverse\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) -> bool {\n+    each_chari_reverse(s, |_, c| it(c))\n+}\n \n // Iterates over the chars in a string in reverse, with indices\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n     let mut pos = s.len();\n     let mut ch_pos = s.char_len();\n@@ -1236,6 +1518,21 @@ pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n \n     }\n }\n+// Iterates over the chars in a string in reverse, with indices\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) -> bool {\n+    let mut pos = s.len();\n+    let mut ch_pos = s.char_len();\n+    while pos > 0 {\n+        let CharRange {ch, next} = char_range_at_reverse(s, pos);\n+        pos = next;\n+        ch_pos -= 1;\n+\n+        if !it(ch_pos, ch) { return false; }\n+    }\n+    return true;\n+}\n \n /*\n Section: Searching\n@@ -2473,24 +2770,41 @@ pub trait StrSlice<'self> {\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n     fn char_iter(&self) -> StrCharIterator<'self>;\n-    fn each(&self, it: &fn(u8) -> bool);\n-    fn eachi(&self, it: &fn(uint, u8) -> bool);\n-    fn each_reverse(&self, it: &fn(u8) -> bool);\n-    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n-    fn each_char(&self, it: &fn(char) -> bool);\n-    fn each_chari(&self, it: &fn(uint, char) -> bool);\n-    fn each_char_reverse(&self, it: &fn(char) -> bool);\n-    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n+    #[cfg(stage0)]      fn each(&self, it: &fn(u8) -> bool);\n+    #[cfg(not(stage0))] fn each(&self, it: &fn(u8) -> bool) -> bool;\n+    #[cfg(stage0)]      fn eachi(&self, it: &fn(uint, u8) -> bool);\n+    #[cfg(not(stage0))] fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_reverse(&self, it: &fn(u8) -> bool);\n+    #[cfg(not(stage0))] fn each_reverse(&self, it: &fn(u8) -> bool) -> bool;\n+    #[cfg(stage0)]      fn eachi_reverse(&self, it: &fn(uint, u8) -> bool);\n+    #[cfg(not(stage0))] fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_char(&self, it: &fn(char) -> bool);\n+    #[cfg(not(stage0))] fn each_char(&self, it: &fn(char) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_chari(&self, it: &fn(uint, char) -> bool);\n+    #[cfg(not(stage0))] fn each_chari(&self, it: &fn(uint, char) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_char_reverse(&self, it: &fn(char) -> bool);\n+    #[cfg(not(stage0))] fn each_char_reverse(&self, it: &fn(char) -> bool) -> bool;\n+    #[cfg(stage0)]      fn each_chari_reverse(&self, it: &fn(uint, char) -> bool);\n+    #[cfg(not(stage0))] fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) -> bool;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n+    #[cfg(stage0)]\n     fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) -> bool;\n+    #[cfg(stage0)]\n     fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) -> bool;\n+    #[cfg(stage0)]\n     fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) -> bool;\n     fn starts_with<'a>(&self, needle: &'a str) -> bool;\n     fn substr(&self, begin: uint, n: uint) -> &'self str;\n     fn escape_default(&self) -> ~str;\n@@ -2543,39 +2857,86 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Iterate over the bytes in a string\n     #[inline]\n+    #[cfg(stage0)]\n     fn each(&self, it: &fn(u8) -> bool) { each(*self, it) }\n+    /// Iterate over the bytes in a string\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each(&self, it: &fn(u8) -> bool) -> bool { each(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n+    #[cfg(stage0)]\n     fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n+    /// Iterate over the bytes in a string, with indices\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool { eachi(*self, it) }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    fn each_reverse(&self, it: &fn(u8) -> bool) {\n-        each_reverse(*self, it)\n-    }\n+    #[cfg(stage0)]\n+    fn each_reverse(&self, it: &fn(u8) -> bool) { each_reverse(*self, it) }\n+    /// Iterate over the bytes in a string\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_reverse(&self, it: &fn(u8) -> bool) -> bool { each_reverse(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n+    #[cfg(stage0)]\n     fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) {\n         eachi_reverse(*self, it)\n     }\n+    /// Iterate over the bytes in a string, with indices\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool {\n+        eachi_reverse(*self, it)\n+    }\n     /// Iterate over the chars in a string\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n+    /// Iterate over the chars in a string\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_char(&self, it: &fn(char) -> bool) -> bool { each_char(*self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_chari(&self, it: &fn(uint, char) -> bool) {\n         each_chari(*self, it)\n     }\n+    /// Iterate over the chars in a string, with indices\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_chari(&self, it: &fn(uint, char) -> bool) -> bool {\n+        each_chari(*self, it)\n+    }\n     /// Iterate over the chars in a string in reverse\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_char_reverse(&self, it: &fn(char) -> bool) {\n         each_char_reverse(*self, it)\n     }\n+    /// Iterate over the chars in a string in reverse\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_char_reverse(&self, it: &fn(char) -> bool) -> bool {\n+        each_char_reverse(*self, it)\n+    }\n     /// Iterate over the chars in a string in reverse, with indices from the\n     /// end\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) {\n         each_chari_reverse(*self, it)\n     }\n+    /// Iterate over the chars in a string in reverse, with indices from the\n+    /// end\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) -> bool {\n+        each_chari_reverse(*self, it)\n+    }\n     /// Returns true if one string ends with another\n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n@@ -2617,24 +2978,50 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) {\n         each_split(*self, sepfn, it)\n     }\n+    /// Splits a string into substrings using a character function\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&'self str) -> bool) -> bool {\n+        each_split(*self, sepfn, it)\n+    }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) {\n         each_split_char(*self, sep, it)\n     }\n+    /**\n+     * Splits a string into substrings at each occurrence of a given character\n+     */\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_split_char(&self, sep: char, it: &fn(&'self str) -> bool) -> bool {\n+        each_split_char(*self, sep, it)\n+    }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) {\n         each_split_str(*self, sep, it)\n     }\n+    /**\n+     * Splits a string into a vector of the substrings separated by a given\n+     * string\n+     */\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_split_str<'a>(&self, sep: &'a str, it: &fn(&'self str) -> bool) -> bool {\n+        each_split_str(*self, sep, it)\n+    }\n     /// Returns true if one string starts with another\n     #[inline]\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n@@ -3017,7 +3404,7 @@ mod tests {\n         let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n         let crlf = ~\"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n-        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool), u: &[~str]) {\n+        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n             assert!(vec::all2(v, u, |a,b| a == b));\n@@ -3037,7 +3424,7 @@ mod tests {\n \n     #[test]\n     fn test_words () {\n-        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool), u: &[~str]) {\n+        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n             assert!(vec::all2(v, u, |a,b| a == b));"}, {"sha": "846d4a349508bb776a461d4dc3e7c3abeb4ad4f2", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -110,9 +110,14 @@ fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     assert!(was_present);\n }\n+#[cfg(stage0)]\n pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) {\n     tasks.each(|k| blk(*k))\n }\n+#[cfg(not(stage0))]\n+pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) -> bool {\n+    tasks.each(|k| blk(*k))\n+}\n \n // One of these per group of linked-failure tasks.\n struct TaskGroupData {\n@@ -685,13 +690,11 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n                 };\n                 // Attempt to join every ancestor group.\n                 result =\n-                    for each_ancestor(ancestors, Some(bail)) |ancestor_tg| {\n+                    each_ancestor(ancestors, Some(bail), |ancestor_tg| {\n                         // Enlist as a descendant, not as an actual member.\n                         // Descendants don't kill ancestor groups on failure.\n-                        if !enlist_in_taskgroup(ancestor_tg, child, false) {\n-                            break;\n-                        }\n-                    };\n+                        enlist_in_taskgroup(ancestor_tg, child, false)\n+                    });\n                 // If any ancestor group fails, need to exit this group too.\n                 if !result {\n                     do access_group(child_arc) |child_tg| {"}, {"sha": "182a03da4b1c6904accc38d0a474e39e81ee090c", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 328, "deletions": 66, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -21,13 +21,19 @@ use str;\n \n pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n \n+#[cfg(stage0)]\n+pub trait IterBytes {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb);\n+}\n+\n /**\n  * A trait to implement in order to make a type hashable;\n  * This works in combination with the trait `Hash::Hash`, and\n  * may in the future be merged with that trait or otherwise\n  * modified when default methods and trait inheritence are\n  * completed.\n  */\n+#[cfg(not(stage0))]\n pub trait IterBytes {\n     /**\n      * Call the provided callback `f` one or more times with\n@@ -43,9 +49,10 @@ pub trait IterBytes {\n      * left-to-right in declaration order, regardless of\n      * underlying memory endianness.\n      */\n-    fn iter_bytes(&self, lsb0: bool, f: Cb);\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool;\n }\n \n+#[cfg(stage0)]\n impl IterBytes for bool {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -54,7 +61,17 @@ impl IterBytes for bool {\n         ]);\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for bool {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        f([\n+            *self as u8\n+        ])\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for u8 {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -63,7 +80,17 @@ impl IterBytes for u8 {\n         ]);\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for u8 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        f([\n+            *self\n+        ])\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for u16 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -80,7 +107,25 @@ impl IterBytes for u16 {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for u16 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        if lsb0 {\n+            f([\n+                *self as u8,\n+                (*self >> 8) as u8\n+            ])\n+        } else {\n+            f([\n+                (*self >> 8) as u8,\n+                *self as u8\n+            ])\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for u32 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -101,7 +146,29 @@ impl IterBytes for u32 {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for u32 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        if lsb0 {\n+            f([\n+                *self as u8,\n+                (*self >> 8) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 24) as u8,\n+            ])\n+        } else {\n+            f([\n+                (*self >> 24) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 8) as u8,\n+                *self as u8\n+            ])\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for u64 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -130,73 +197,157 @@ impl IterBytes for u64 {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for u64 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        if lsb0 {\n+            f([\n+                *self as u8,\n+                (*self >> 8) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 24) as u8,\n+                (*self >> 32) as u8,\n+                (*self >> 40) as u8,\n+                (*self >> 48) as u8,\n+                (*self >> 56) as u8\n+            ])\n+        } else {\n+            f([\n+                (*self >> 56) as u8,\n+                (*self >> 48) as u8,\n+                (*self >> 40) as u8,\n+                (*self >> 32) as u8,\n+                (*self >> 24) as u8,\n+                (*self >> 16) as u8,\n+                (*self >> 8) as u8,\n+                *self as u8\n+            ])\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for i8 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for i8 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for i16 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u16).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for i16 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u16).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for i32 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for i32 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u32).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for i64 {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for i64 {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u64).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for char {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n-\n-#[cfg(target_word_size = \"32\")]\n-pub mod x32 {\n-    use to_bytes::{Cb, IterBytes};\n-\n-    impl IterBytes for uint {\n-        #[inline(always)]\n-        fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-            (*self as u32).iter_bytes(lsb0, f)\n-        }\n+#[cfg(not(stage0))]\n+impl IterBytes for char {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n-#[cfg(target_word_size = \"64\")]\n-pub mod x64 {\n-    use to_bytes::{Cb, IterBytes};\n+#[cfg(target_word_size = \"32\", stage0)]\n+impl IterBytes for uint {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as u32).iter_bytes(lsb0, f)\n+    }\n+}\n+#[cfg(target_word_size = \"32\", not(stage0))]\n+impl IterBytes for uint {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u32).iter_bytes(lsb0, f)\n+    }\n+}\n \n-    impl IterBytes for uint {\n-        #[inline(always)]\n-        fn iter_bytes(&self, lsb0: bool, f: Cb) {\n-            (*self as u64).iter_bytes(lsb0, f)\n-        }\n+#[cfg(target_word_size = \"64\", stage0)]\n+impl IterBytes for uint {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) {\n+        (*self as u64).iter_bytes(lsb0, f)\n+    }\n+}\n+#[cfg(target_word_size = \"64\", not(stage0))]\n+impl IterBytes for uint {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n+#[cfg(stage0)]\n impl IterBytes for int {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for int {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<'self,A:IterBytes> IterBytes for &'self [A] {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -207,7 +358,15 @@ impl<'self,A:IterBytes> IterBytes for &'self [A] {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'self,A:IterBytes> IterBytes for &'self [A] {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        self.each(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n   #[inline(always)]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -218,7 +377,17 @@ impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n     }\n   }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n+  #[inline(always)]\n+  fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+    match *self {\n+      (ref a, ref b) => { a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) }\n+    }\n+  }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n   #[inline(always)]\n   fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -229,46 +398,90 @@ impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n     }\n   }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n+  #[inline(always)]\n+  fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+    match *self {\n+      (ref a, ref b, ref c) => {\n+        a.iter_bytes(lsb0, f) && b.iter_bytes(lsb0, f) && c.iter_bytes(lsb0, f)\n+      }\n+    }\n+  }\n+}\n \n // Move this to vec, probably.\n fn borrow<'x,A>(a: &'x [A]) -> &'x [A] {\n     a\n }\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for ~[A] {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for ~[A] {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        borrow(*self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for @[A] {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for @[A] {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        borrow(*self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+// NOTE: remove all of these after a snapshot, the new for-loop iteration\n+//       protocol makes these unnecessary.\n \n+#[cfg(stage0)]\n pub fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n                                             lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n+#[cfg(not(stage0))]\n+pub fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n+                                             lsb0: bool, z: Cb) -> bool {\n+    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z)\n+}\n \n+#[cfg(stage0)]\n pub fn iter_bytes_3<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes>(a: &A, b: &B, c: &C,\n-                              lsb0: bool, z: Cb) {\n+                    B: IterBytes,\n+                    C: IterBytes>(a: &A, b: &B, c: &C,\n+                                  lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n+#[cfg(not(stage0))]\n+pub fn iter_bytes_3<A: IterBytes,\n+                    B: IterBytes,\n+                    C: IterBytes>(a: &A, b: &B, c: &C, lsb0: bool, z: Cb) -> bool {\n+    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z)\n+}\n \n+#[cfg(stage0)]\n pub fn iter_bytes_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n@@ -284,33 +497,24 @@ pub fn iter_bytes_4<A: IterBytes,\n     if !flag { return; }\n     d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n-\n-pub fn iter_bytes_5<A: IterBytes,\n+#[cfg(not(stage0))]\n+pub fn iter_bytes_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n-                D: IterBytes,\n-                E: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D, e: &E,\n-                              lsb0: bool, z: Cb) {\n-    let mut flag = true;\n-    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+                D: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D,\n+                              lsb0: bool, z: Cb) -> bool {\n+    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z) &&\n+        d.iter_bytes(lsb0, z)\n }\n \n-pub fn iter_bytes_6<A: IterBytes,\n+#[cfg(stage0)]\n+pub fn iter_bytes_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n-                E: IterBytes,\n-                F: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D, e: &E, f: &F,\n+                E: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D, e: &E,\n                               lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n@@ -322,36 +526,20 @@ pub fn iter_bytes_6<A: IterBytes,\n     d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n-\n-pub fn iter_bytes_7<A: IterBytes,\n+#[cfg(not(stage0))]\n+pub fn iter_bytes_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n-                E: IterBytes,\n-                F: IterBytes,\n-                G: IterBytes>(a: &A, b: &B, c: &C,\n-                              d: &D, e: &E, f: &F,\n-                              g: &G,\n-                              lsb0: bool, z: Cb) {\n-    let mut flag = true;\n-    a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n-    if !flag { return; }\n-    g.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n+                E: IterBytes>(a: &A, b: &B, c: &C,\n+                              d: &D, e: &E,\n+                              lsb0: bool, z: Cb) -> bool {\n+    a.iter_bytes(lsb0, z) && b.iter_bytes(lsb0, z) && c.iter_bytes(lsb0, z) &&\n+        d.iter_bytes(lsb0, z) && e.iter_bytes(lsb0, z)\n }\n \n+#[cfg(stage0)]\n impl<'self> IterBytes for &'self str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -360,7 +548,17 @@ impl<'self> IterBytes for &'self str {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'self> IterBytes for &'self str {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        do str::byte_slice(*self) |bytes| {\n+            f(bytes)\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for ~str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -369,7 +567,17 @@ impl IterBytes for ~str {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for ~str {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        do str::byte_slice(*self) |bytes| {\n+            f(bytes)\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl IterBytes for @str {\n     #[inline(always)]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) {\n@@ -378,7 +586,17 @@ impl IterBytes for @str {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for @str {\n+    #[inline(always)]\n+    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n+        do str::byte_slice(*self) |bytes| {\n+            f(bytes)\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for Option<A> {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n@@ -388,36 +606,80 @@ impl<A:IterBytes> IterBytes for Option<A> {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for Option<A> {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        match *self {\n+          Some(ref a) => 0u8.iter_bytes(lsb0, f) && a.iter_bytes(lsb0, f),\n+          None => 1u8.iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<'self,A:IterBytes> IterBytes for &'self A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'self,A:IterBytes> IterBytes for &'self A {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for @A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for @A {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<A:IterBytes> IterBytes for ~A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<A:IterBytes> IterBytes for ~A {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n+#[cfg(stage0)]\n impl<A> IterBytes for *const A {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n+// NB: raw-pointer IterBytes does _not_ dereference\n+// to the target; it just gives you the pointer-bytes.\n+#[cfg(not(stage0))]\n+impl<A> IterBytes for *const A {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n pub trait ToBytes {\n     fn to_bytes(&self, lsb0: bool) -> ~[u8];"}, {"sha": "05ef1cf433faf208a2a0174f7859923daf84c8db", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -57,28 +57,60 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all key-value pairs in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n         self.root.each(f);\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+        self.root.each(f)\n+    }\n+\n     /// Visit all keys in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_key(&self, f: &fn(&uint) -> bool) {\n         self.each(|k, _| f(k))\n     }\n \n+    /// Visit all keys in order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_key(&self, f: &fn(&uint) -> bool) -> bool {\n+        self.each(|k, _| f(k))\n+    }\n+\n     /// Visit all values in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) {\n         self.each(|_, v| f(v))\n     }\n \n+    /// Visit all values in order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) -> bool {\n+        self.each(|_, v| f(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) {\n         self.root.mutate_values(f);\n     }\n \n+    /// Iterate over the map and mutate the contained values\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n+        self.root.mutate_values(f)\n+    }\n+\n     /// Return a reference to the value corresponding to the key\n     #[inline(hint)]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n@@ -151,21 +183,43 @@ pub impl<T> TrieMap<T> {\n \n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n         self.root.each_reverse(f);\n     }\n \n+    /// Visit all key-value pairs in reverse order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+        self.root.each_reverse(f)\n+    }\n+\n     /// Visit all keys in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n         self.each_reverse(|k, _| f(k))\n     }\n+    /// Visit all keys in reverse order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+        self.each_reverse(|k, _| f(k))\n+    }\n \n     /// Visit all values in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n         self.each_reverse(|_, v| f(v))\n     }\n+    /// Visit all values in reverse order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+        self.each_reverse(|_, v| f(v))\n+    }\n }\n \n pub struct TrieSet {\n@@ -175,17 +229,25 @@ pub struct TrieSet {\n impl BaseIter<uint> for TrieSet {\n     /// Visit all values in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&uint) -> bool) { self.map.each_key(f) }\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl ReverseIter<uint> for TrieSet {\n     /// Visit all values in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_reverse(&self, f: &fn(&uint) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n+    #[cfg(not(stage0))]\n+    fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+        self.map.each_key_reverse(f)\n+    }\n }\n \n impl Container for TrieSet {"}, {"sha": "7eba2cbf0ccc455d487d802fafded8f20dd39294", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 216, "deletions": 25, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -1489,13 +1489,14 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n  * ~~~\n  */\n #[inline(always)]\n-pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n+pub fn _each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n     //             ^^^^\n     // NB---this CANNOT be &const [T]!  The reason\n     // is that you are passing it to `f()` using\n     // an immutable.\n \n-    do vec::as_imm_buf(v) |p, n| {\n+    let mut broke = false;\n+    do as_imm_buf(v) |p, n| {\n         let mut n = n;\n         let mut p = p;\n         while n > 0u {\n@@ -1506,42 +1507,69 @@ pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n             }\n             n -= 1u;\n         }\n+        broke = n > 0;\n     }\n+    return true;\n }\n \n+#[cfg(stage0)]\n+pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) { _each(v, f); }\n+#[cfg(not(stage0))]\n+pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool { _each(v, f) }\n+\n /// Like `each()`, but for the case where you have\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n-    do vec::as_mut_buf(v) |p, n| {\n+pub fn _each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool {\n+    let mut broke = false;\n+    do as_mut_buf(v) |p, n| {\n         let mut n = n;\n         let mut p = p;\n         while n > 0 {\n             unsafe {\n                 let q: &'r mut T = cast::transmute_mut_region(&mut *p);\n-                if !f(q) {\n-                    break;\n-                }\n+                if !f(q) { break; }\n                 p = p.offset(1);\n             }\n             n -= 1;\n         }\n+        broke = n > 0;\n     }\n+    return broke;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n+    _each_mut(v, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) -> bool {\n+    _each_mut(v, f)\n }\n \n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) {\n+pub fn _each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) -> bool {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n         if !f(&const v[i]) {\n-            return;\n+            return false;\n         }\n         i += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each_const<t>(v: &const [t], f: &fn(elem: &const t) -> bool) {\n+    _each_const(v, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_const<t>(v: &const [t], f: &fn(elem: &const t) -> bool) -> bool {\n+    _each_const(v, f)\n }\n \n /**\n@@ -1550,12 +1578,20 @@ pub fn each_const<T>(v: &const [T], f: &fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n+pub fn _eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n     let mut i = 0;\n     for each(v) |p| {\n-        if !f(i, p) { return; }\n+        if !f(i, p) { return false; }\n         i += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) { _eachi(v, f); }\n+#[cfg(not(stage0))]\n+pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n+    _eachi(v, f)\n }\n \n /**\n@@ -1564,14 +1600,26 @@ pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn eachi_mut<'r,T>(v: &'r mut [T], f: &fn(uint, v: &'r mut T) -> bool) {\n+pub fn _eachi_mut<'r,T>(v: &'r mut [T],\n+                        f: &fn(uint, v: &'r mut T) -> bool) -> bool {\n     let mut i = 0;\n     for each_mut(v) |p| {\n         if !f(i, p) {\n-            return;\n+            return false;\n         }\n         i += 1;\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn eachi_mut<'r,T>(v: &'r mut [T], f: &fn(uint, v: &'r mut T) -> bool) {\n+    _eachi_mut(v, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn eachi_mut<'r,T>(v: &'r mut [T],\n+                       f: &fn(uint, v: &'r mut T) -> bool) -> bool {\n+    _eachi_mut(v, f)\n }\n \n /**\n@@ -1580,8 +1628,17 @@ pub fn eachi_mut<'r,T>(v: &'r mut [T], f: &fn(uint, v: &'r mut T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n+pub fn _each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n+    _eachi_reverse(v, |_i, v| blk(v))\n+}\n+\n+#[cfg(stage0)]\n pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n-    eachi_reverse(v, |_i, v| blk(v))\n+    _each_reverse(v, blk);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n+    _each_reverse(v, blk)\n }\n \n /**\n@@ -1590,14 +1647,26 @@ pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub fn eachi_reverse<'r,T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n+pub fn _eachi_reverse<'r,T>(v: &'r [T],\n+                            blk: &fn(i: uint, v: &'r T) -> bool) -> bool {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n         if !blk(i, &v[i]) {\n-            return;\n+            return false;\n         }\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn eachi_reverse<'r,T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n+    _eachi_reverse(v, blk);\n+}\n+#[cfg(not(stage0))]\n+pub fn eachi_reverse<'r,T>(v: &'r [T],\n+                           blk: &fn(i: uint, v: &'r T) -> bool) -> bool {\n+    _eachi_reverse(v, blk)\n }\n \n /**\n@@ -1608,13 +1677,23 @@ pub fn eachi_reverse<'r,T>(v: &'r [T], blk: &fn(i: uint, v: &'r T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n+pub fn _each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n     assert!(len(v1) == len(v2));\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n-            return;\n+            return false;\n         }\n     }\n+    return true;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n+    _each2(v1, v2, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) -> bool {\n+    _each2(v1, v2, f)\n }\n \n /**\n@@ -1627,7 +1706,8 @@ pub fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n+#[cfg(not(stage0))]\n+pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) -> bool {\n     let ln = len(v);\n     if ln <= 1 {\n         put(v);\n@@ -1641,12 +1721,13 @@ pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n             rest.push_all(const_slice(v, i+1u, ln));\n             for each_permutation(rest) |permutation| {\n                 if !put(append(~[elt], permutation)) {\n-                    return;\n+                    return false;\n                 }\n             }\n             i += 1u;\n         }\n     }\n+    return true;\n }\n \n /**\n@@ -1663,13 +1744,37 @@ pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n  * ~~~\n  *\n  */\n+#[cfg(stage0)]\n pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) {\n     assert!(1u <= n);\n     if n > v.len() { return; }\n     for uint::range(0, v.len() - n + 1) |i| {\n         if !it(v.slice(i, i + n)) { return }\n     }\n }\n+/**\n+ * Iterate over all contiguous windows of length `n` of the vector `v`.\n+ *\n+ * # Example\n+ *\n+ * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`, `[3,4]`)\n+ *\n+ * ~~~\n+ * for windowed(2, &[1,2,3,4]) |v| {\n+ *     io::println(fmt!(\"%?\", v));\n+ * }\n+ * ~~~\n+ *\n+ */\n+#[cfg(not(stage0))]\n+pub fn windowed<'r, T>(n: uint, v: &'r [T], it: &fn(&'r [T]) -> bool) -> bool {\n+    assert!(1u <= n);\n+    if n > v.len() { return true; }\n+    for uint::range(0, v.len() - n + 1) |i| {\n+        if !it(v.slice(i, i + n)) { return false; }\n+    }\n+    return true;\n+}\n \n /**\n  * Work with the buffer of a vector.\n@@ -1932,8 +2037,14 @@ pub trait ImmutableVector<'self, T> {\n     fn initn(&self, n: uint) -> &'self [T];\n     fn last(&self) -> &'self T;\n     fn last_opt(&self) -> Option<&'self T>;\n+    #[cfg(stage0)]\n     fn each_reverse(&self, blk: &fn(&T) -> bool);\n+    #[cfg(not(stage0))]\n+    fn each_reverse(&self, blk: &fn(&T) -> bool) -> bool;\n+    #[cfg(stage0)]\n     fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n+    #[cfg(not(stage0))]\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) -> bool;\n     fn foldr<'a, U>(&'a self, z: U, p: &fn(t: &'a T, u: U) -> U) -> U;\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n     fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n@@ -1995,15 +2106,29 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n \n     /// Iterates over a vector's elements in reverse.\n     #[inline]\n+    #[cfg(stage0)]\n     fn each_reverse(&self, blk: &fn(&T) -> bool) {\n         each_reverse(*self, blk)\n     }\n+    /// Iterates over a vector's elements in reverse.\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn each_reverse(&self, blk: &fn(&T) -> bool) -> bool {\n+        each_reverse(*self, blk)\n+    }\n \n     /// Iterates over a vector's elements and indices in reverse.\n+    #[cfg(stage0)]\n     #[inline]\n     fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n         eachi_reverse(*self, blk)\n     }\n+    /// Iterates over a vector's elements and indices in reverse.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) -> bool {\n+        eachi_reverse(*self, blk)\n+    }\n \n     /// Reduce a vector from right to left\n     #[inline]\n@@ -2555,55 +2680,105 @@ pub mod bytes {\n // ITERATION TRAIT METHODS\n \n impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n+    #[cfg(stage0)]\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) {\n+        each(*self, blk)\n+    }\n+    #[cfg(not(stage0))]\n     #[inline(always)]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n+        each(*self, blk)\n+    }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for ~[A] {\n+    #[cfg(stage0)]\n     #[inline(always)]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) {\n+        each(*self, blk)\n+    }\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n+        each(*self, blk)\n+    }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::BaseIter<A> for @[A] {\n+    #[cfg(stage0)]\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) {\n+        each(*self, blk)\n+    }\n+    #[cfg(not(stage0))]\n     #[inline(always)]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n+        each(*self, blk)\n+    }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<'self,A> old_iter::MutableIter<A> for &'self mut [A] {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) -> bool {\n+        each_mut(*self, blk)\n+    }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::MutableIter<A> for ~[A] {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) -> bool {\n+        each_mut(*self, blk)\n+    }\n }\n \n // FIXME(#4148): This should be redundant\n+#[cfg(stage0)]\n impl<A> old_iter::MutableIter<A> for @mut [A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<A> old_iter::MutableIter<A> for @mut [A] {\n+    #[inline(always)]\n+    fn each_mut(&mut self, blk: &fn(v: &mut A) -> bool) -> bool {\n+        each_mut(*self, blk)\n+    }\n+}\n+\n impl<'self,A> old_iter::ExtendedIter<A> for &'self [A] {\n+    #[cfg(stage0)]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }\n@@ -2627,16 +2802,27 @@ impl<'self,A> old_iter::ExtendedIter<A> for &'self [A] {\n \n impl<'self,A> old_iter::ExtendedMutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     pub fn eachi_mut(&mut self, blk: &fn(uint, v: &mut A) -> bool) {\n         eachi_mut(*self, blk)\n     }\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    pub fn eachi_mut(&mut self, blk: &fn(uint, v: &mut A) -> bool) -> bool {\n+        eachi_mut(*self, blk)\n+    }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::ExtendedIter<A> for ~[A] {\n+    #[cfg(stage0)]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }\n@@ -2660,9 +2846,14 @@ impl<A> old_iter::ExtendedIter<A> for ~[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A> old_iter::ExtendedIter<A> for @[A] {\n+    #[cfg(stage0)]\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n     pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }\n@@ -4399,7 +4590,7 @@ mod tests {\n             }\n             i += 0;\n             false\n-        }\n+        };\n     }\n \n     #[test]\n@@ -4414,7 +4605,7 @@ mod tests {\n             }\n             i += 0;\n             false\n-        }\n+        };\n     }\n \n     #[test]"}, {"sha": "d8117a87480b730ad7c0d2982a4e733344f8fb3e", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -44,14 +44,24 @@ pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::def_id)\n }\n \n /// Iterates over all the language items in the given crate.\n+#[cfg(stage0)]\n pub fn each_lang_item(cstore: @mut cstore::CStore,\n                       cnum: ast::crate_num,\n                       f: &fn(ast::node_id, uint) -> bool) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     decoder::each_lang_item(crate_data, f)\n }\n+/// Iterates over all the language items in the given crate.\n+#[cfg(not(stage0))]\n+pub fn each_lang_item(cstore: @mut cstore::CStore,\n+                      cnum: ast::crate_num,\n+                      f: &fn(ast::node_id, uint) -> bool) -> bool {\n+    let crate_data = cstore::get_crate_data(cstore, cnum);\n+    decoder::each_lang_item(crate_data, f)\n+}\n \n /// Iterates over all the paths in the given crate.\n+#[cfg(stage0)]\n pub fn each_path(cstore: @mut cstore::CStore,\n                  cnum: ast::crate_num,\n                  f: &fn(&str, decoder::def_like) -> bool) {\n@@ -61,6 +71,17 @@ pub fn each_path(cstore: @mut cstore::CStore,\n     };\n     decoder::each_path(cstore.intr, crate_data, get_crate_data, f);\n }\n+/// Iterates over all the paths in the given crate.\n+#[cfg(not(stage0))]\n+pub fn each_path(cstore: @mut cstore::CStore,\n+                 cnum: ast::crate_num,\n+                 f: &fn(&str, decoder::def_like) -> bool) -> bool {\n+    let crate_data = cstore::get_crate_data(cstore, cnum);\n+    let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n+        cstore::get_crate_data(cstore, cnum)\n+    };\n+    decoder::each_path(cstore.intr, crate_data, get_crate_data, f)\n+}\n \n pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     let cstore = tcx.cstore;"}, {"sha": "d1c1369487763de83d3fa8fe19dbe9b65381b80f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -196,13 +196,23 @@ fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n                                                     |d| parse_def_id(d)));\n }\n \n+#[cfg(stage0)]\n fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) {\n     for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n             return;\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n+    for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n+        if !f(reexport_doc) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n \n fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n     do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n@@ -454,6 +464,7 @@ fn def_like_to_def(def_like: def_like) -> ast::def {\n }\n \n /// Iterates over the language items in the given crate.\n+#[cfg(stage0)]\n pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n@@ -469,11 +480,29 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n         }\n     }\n }\n+/// Iterates over the language items in the given crate.\n+#[cfg(not(stage0))]\n+pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) -> bool {\n+    let root = reader::Doc(cdata.data);\n+    let lang_items = reader::get_doc(root, tag_lang_items);\n+    for reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n+        let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n+        let id = reader::doc_as_u32(id_doc) as uint;\n+        let node_id_doc = reader::get_doc(item_doc,\n+                                          tag_lang_items_item_node_id);\n+        let node_id = reader::doc_as_u32(node_id_doc) as ast::node_id;\n+\n+        if !f(node_id, id) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n \n /// Iterates over all the paths in the given crate.\n-pub fn each_path(intr: @ident_interner, cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like) -> bool) {\n+pub fn _each_path(intr: @ident_interner, cdata: cmd,\n+                  get_crate_data: GetCrateDataCb,\n+                  f: &fn(&str, def_like) -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let items = reader::get_doc(root, tag_items);\n     let items_data = reader::get_doc(items, tag_items_data);\n@@ -555,10 +584,20 @@ pub fn each_path(intr: @ident_interner, cdata: cmd,\n         }\n     }\n \n-    // If broken, stop here.\n-    if broken {\n-        return;\n-    }\n+    return broken;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each_path(intr: @ident_interner, cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: &fn(&str, def_like) -> bool) {\n+    _each_path(intr, cdata, get_crate_data, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_path(intr: @ident_interner, cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: &fn(&str, def_like) -> bool) -> bool {\n+    _each_path(intr, cdata, get_crate_data, f)\n }\n \n pub fn get_item_path(intr: @ident_interner, cdata: cmd, id: ast::node_id)"}, {"sha": "7d25d5f3ec92e982c181a24cea6eb89e0c2c857f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -1391,11 +1391,10 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     ecx.stats.total_bytes = *wr.pos;\n \n     if (tcx.sess.meta_stats()) {\n-        do wr.bytes.each |e| {\n+        for wr.bytes.each |e| {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n             }\n-            true\n         }\n \n         io::println(\"metadata stats:\");"}, {"sha": "0708b7d38d321741c6b3b9ec286de466ed2bf07d", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -21,7 +21,10 @@ pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n \n pub trait FileSearch {\n     fn sysroot(&self) -> @Path;\n+    #[cfg(stage0)]\n     fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool);\n+    #[cfg(not(stage0))]\n+    fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool;\n     fn get_target_lib_path(&self) -> Path;\n     fn get_target_lib_file_path(&self, file: &Path) -> Path;\n }\n@@ -37,6 +40,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     }\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n+        #[cfg(stage0)]\n         fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) {\n             debug!(\"filesearch: searching additional lib search paths\");\n             // a little weird\n@@ -60,6 +64,30 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n               result::Err(_) => true\n            };\n         }\n+        #[cfg(not(stage0))]\n+        fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool {\n+            debug!(\"filesearch: searching additional lib search paths\");\n+            // a little weird\n+            self.addl_lib_search_paths.each(f);\n+\n+            debug!(\"filesearch: searching target lib path\");\n+            if !f(&make_target_lib_path(self.sysroot,\n+                                        self.target_triple)) {\n+                return false;\n+            }\n+            debug!(\"filesearch: searching rustpkg lib path nearest\");\n+            if match get_rustpkg_lib_path_nearest() {\n+                    result::Ok(ref p) => f(p),\n+                    result::Err(_) => true\n+                } {\n+                    return true;\n+                }\n+           debug!(\"filesearch: searching rustpkg lib path\");\n+           match get_rustpkg_lib_path() {\n+              result::Ok(ref p) => f(p),\n+              result::Err(_) => true\n+           }\n+        }\n         fn get_target_lib_path(&self) -> Path {\n             make_target_lib_path(self.sysroot, self.target_triple)\n         }"}, {"sha": "27f6ae33ba3d1e5bd133778c7b07b1a72fa4c9ec", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -67,6 +67,7 @@ enum MoveError {\n pub impl<'self> CheckLoanCtxt<'self> {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n+    #[cfg(stage0)]\n     fn each_issued_loan(&self,\n                         scope_id: ast::node_id,\n                         op: &fn(&Loan) -> bool)\n@@ -84,7 +85,27 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_issued_loan(&self,\n+                        scope_id: ast::node_id,\n+                        op: &fn(&Loan) -> bool) -> bool\n+    {\n+        //! Iterates over each loan that that has been issued\n+        //! on entrance to `scope_id`, regardless of whether it is\n+        //! actually *in scope* at that point.  Sometimes loans\n+        //! are issued for future scopes and thus they may have been\n+        //! *issued* but not yet be in effect.\n+\n+        for self.dfcx.each_bit_on_entry(scope_id) |loan_index| {\n+            let loan = &self.all_loans[loan_index];\n+            if !op(loan) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n \n+    #[cfg(stage0)]\n     fn each_in_scope_loan(&self,\n                           scope_id: ast::node_id,\n                           op: &fn(&Loan) -> bool)\n@@ -101,7 +122,26 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_in_scope_loan(&self,\n+                          scope_id: ast::node_id,\n+                          op: &fn(&Loan) -> bool) -> bool\n+    {\n+        //! Like `each_issued_loan()`, but only considers loans that are\n+        //! currently in scope.\n \n+        let region_maps = self.tcx().region_maps;\n+        for self.each_issued_loan(scope_id) |loan| {\n+            if region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n+                if !op(loan) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    #[cfg(stage0)]\n     fn each_in_scope_restriction(&self,\n                                  scope_id: ast::node_id,\n                                  loan_path: @LoanPath,\n@@ -120,6 +160,26 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_in_scope_restriction(&self,\n+                                 scope_id: ast::node_id,\n+                                 loan_path: @LoanPath,\n+                                 op: &fn(&Loan, &Restriction) -> bool) -> bool\n+    {\n+        //! Iterates through all the in-scope restrictions for the\n+        //! given `loan_path`\n+\n+        for self.each_in_scope_loan(scope_id) |loan| {\n+            for loan.restrictions.each |restr| {\n+                if restr.loan_path == loan_path {\n+                    if !op(loan, restr) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n \n     fn loans_generated_by(&self, scope_id: ast::node_id) -> ~[uint] {\n         //! Returns a vector of the loans that are generated as"}, {"sha": "f1fa5144f4c7530594662acd7e58754485894411", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -182,6 +182,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     }\n \n \n+    #[cfg(stage0)]\n     pub fn each_bit_on_entry(&self,\n                              id: ast::node_id,\n                              f: &fn(uint) -> bool) {\n@@ -194,7 +195,21 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f);\n     }\n+    #[cfg(not(stage0))]\n+    pub fn each_bit_on_entry(&self,\n+                             id: ast::node_id,\n+                             f: &fn(uint) -> bool) -> bool {\n+        //! Iterates through each bit that is set on entry to `id`.\n+        //! Only useful after `propagate()` has been called.\n+\n+        let (start, end) = self.compute_id_range(id);\n+        let on_entry = vec::slice(self.on_entry, start, end);\n+        debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n+               id, bits_to_str(on_entry));\n+        self.each_bit(on_entry, f)\n+    }\n \n+    #[cfg(stage0)]\n     pub fn each_gen_bit(&self,\n                         id: ast::node_id,\n                         f: &fn(uint) -> bool) {\n@@ -206,7 +221,20 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn each_gen_bit(&self,\n+                        id: ast::node_id,\n+                        f: &fn(uint) -> bool) -> bool {\n+        //! Iterates through each bit in the gen set for `id`.\n \n+        let (start, end) = self.compute_id_range(id);\n+        let gens = vec::slice(self.gens, start, end);\n+        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+               id, bits_to_str(gens));\n+        self.each_bit(gens, f)\n+    }\n+\n+    #[cfg(stage0)]\n     fn each_bit(&self,\n                 words: &[uint],\n                 f: &fn(uint) -> bool) {\n@@ -236,6 +264,39 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_bit(&self,\n+                words: &[uint],\n+                f: &fn(uint) -> bool) -> bool {\n+        //! Helper for iterating over the bits in a bit set.\n+\n+        for words.eachi |word_index, &word| {\n+            if word != 0 {\n+                let base_index = word_index * uint::bits;\n+                for uint::range(0, uint::bits) |offset| {\n+                    let bit = 1 << offset;\n+                    if (word & bit) != 0 {\n+                        // NB: we round up the total number of bits\n+                        // that we store in any given bit set so that\n+                        // it is an even multiple of uint::bits.  This\n+                        // means that there may be some stray bits at\n+                        // the end that do not correspond to any\n+                        // actual value.  So before we callback, check\n+                        // whether the bit_index is greater than the\n+                        // actual value the user specified and stop\n+                        // iterating if so.\n+                        let bit_index = base_index + offset;\n+                        if bit_index >= self.bits_per_id {\n+                            return true;\n+                        } else if !f(bit_index) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n }\n \n impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {"}, {"sha": "e2b4684696a904f266d78aae8b2288c636e67b1d", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -86,13 +86,18 @@ pub impl LanguageItems {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) {\n         for self.items.eachi |i, &item| {\n             if !f(item.get(), i) {\n                 break;\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) -> bool {\n+        self.items.eachi(|i, &item| f(item.get(), i))\n+    }\n \n     pub fn item_name(index: uint) -> &'static str {\n         match index {"}, {"sha": "4d04fa7f73c774eba730d949776ed05ccd4f9cae", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -2408,14 +2408,14 @@ pub impl Resolver {\n         let merge_import_resolution = |ident,\n                                        name_bindings: @mut NameBindings| {\n             let dest_import_resolution;\n-            match module_.import_resolutions.find(ident) {\n+            match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @mut ImportResolution(privacy,\n                                                                    span,\n                                                                    state);\n                     module_.import_resolutions.insert\n-                        (*ident, dest_import_resolution);\n+                        (ident, dest_import_resolution);\n                 }\n                 Some(&existing_import_resolution) => {\n                     dest_import_resolution = existing_import_resolution;\n@@ -2424,7 +2424,7 @@ pub impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   *self.session.str_of(*ident),\n+                   *self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    copy dest_import_resolution.privacy);\n@@ -2443,13 +2443,13 @@ pub impl Resolver {\n         };\n \n         // Add all children from the containing module.\n-        for containing_module.children.each |ident, name_bindings| {\n+        for containing_module.children.each |&ident, name_bindings| {\n             merge_import_resolution(ident, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n         for containing_module.external_module_children.each\n-                |ident, module| {\n+                |&ident, module| {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n             merge_import_resolution(ident, name_bindings);"}, {"sha": "4fd2e9670832ce8dcd51e4ab65ede7bdecf095fc", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -2424,14 +2424,14 @@ pub impl Resolver {\n         let merge_import_resolution = |ident,\n                                        name_bindings: @mut NameBindings| {\n             let dest_import_resolution;\n-            match module_.import_resolutions.find(ident) {\n+            match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @mut ImportResolution(privacy,\n                                                                    span,\n                                                                    state);\n                     module_.import_resolutions.insert\n-                        (*ident, dest_import_resolution);\n+                        (ident, dest_import_resolution);\n                 }\n                 Some(existing_import_resolution) => {\n                     dest_import_resolution = *existing_import_resolution;\n@@ -2440,7 +2440,7 @@ pub impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   *self.session.str_of(*ident),\n+                   *self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    copy dest_import_resolution.privacy);\n@@ -2459,13 +2459,13 @@ pub impl Resolver {\n         };\n \n         // Add all children from the containing module.\n-        for containing_module.children.each |ident, name_bindings| {\n+        for containing_module.children.each |&ident, name_bindings| {\n             merge_import_resolution(ident, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n         for containing_module.external_module_children.each\n-                |ident, module| {\n+                |&ident, module| {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n             merge_import_resolution(ident, name_bindings);"}, {"sha": "70a0a7d06d351e4a0e0b35360bbec8644cc3b74d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -550,7 +550,14 @@ pub fn trans_call_inner(in_cx: block,\n                 // drop the value if it is not being saved.\n                 unsafe {\n                     if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n-                        if ty::type_is_immediate(ret_ty) {\n+                        if ty::type_is_nil(ret_ty) {\n+                            // When implementing the for-loop sugar syntax, the\n+                            // type of the for-loop is nil, but the function\n+                            // it's invoking returns a bool. This is a special\n+                            // case to ignore instead of invoking the Store\n+                            // below into a scratch pointer of a mismatched\n+                            // type.\n+                        } else if ty::type_is_immediate(ret_ty) {\n                             let llscratchptr = alloc_ty(bcx, ret_ty);\n                             Store(bcx, llresult, llscratchptr);\n                             bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);"}, {"sha": "aff45cbb9939077c7f06dab51176171ae55f2edd", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -1369,6 +1369,7 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for mono_param_id {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -1382,18 +1383,46 @@ impl to_bytes::IterBytes for mono_param_id {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for mono_param_id {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+            mono_precise(t, ref mids) =>\n+                to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), mids, lsb0, f),\n+\n+            mono_any => 1u8.iter_bytes(lsb0, f),\n \n+            mono_repr(ref a, ref b, ref c, ref d) =>\n+                to_bytes::iter_bytes_5(&2u8, a, b, c, d, lsb0, f)\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl to_bytes::IterBytes for MonoDataClass {\n     fn iter_bytes(&self, lsb0: bool, f:to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for MonoDataClass {\n+    fn iter_bytes(&self, lsb0: bool, f:to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for mono_id_ {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for mono_id_ {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f)\n+    }\n+}\n \n pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);"}, {"sha": "374bb23f2cb578d9d84c2e04f28a864c800a2932", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -155,11 +155,18 @@ pub impl DatumMode {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for DatumMode {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for DatumMode {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n /// See `Datum cleanup styles` section at the head of this module.\n #[deriving(Eq)]"}, {"sha": "737548ee868691cb402fd52bb38e7328756dec9e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -121,11 +121,18 @@ pub struct creader_cache_key {\n \n type creader_cache = @mut HashMap<creader_cache_key, t>;\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for creader_cache_key {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for creader_cache_key {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f)\n+    }\n+}\n \n struct intern_key {\n     sty: *sty,\n@@ -145,13 +152,22 @@ impl cmp::Eq for intern_key {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for intern_key {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         unsafe {\n             (*self.sty).iter_bytes(lsb0, f);\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for intern_key {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        unsafe {\n+            (*self.sty).iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n \n pub enum ast_ty_to_ty_cache_entry {\n     atttce_unresolved,  /* not resolved yet */\n@@ -382,18 +398,33 @@ pub struct FnSig {\n     output: t\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for BareFnTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for BareFnTy {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for ClosureTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n                                &self.region, &self.sig, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for ClosureTy {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n+                               &self.region, &self.sig, lsb0, f)\n+    }\n+}\n \n #[deriving(Eq, IterBytes)]\n pub struct param_ty {\n@@ -705,6 +736,7 @@ pub enum InferTy {\n     FloatVar(FloatVid)\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for InferTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -714,6 +746,16 @@ impl to_bytes::IterBytes for InferTy {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for InferTy {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n+          IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n+          FloatVar(ref fv) => to_bytes::iter_bytes_2(&2u8, fv, lsb0, f),\n+        }\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -722,6 +764,7 @@ pub enum InferRegion {\n     ReSkolemized(uint, bound_region)\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for InferRegion {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -730,6 +773,15 @@ impl to_bytes::IterBytes for InferRegion {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for InferRegion {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+            ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n+            ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n+        }\n+    }\n+}\n \n impl cmp::Eq for InferRegion {\n     fn eq(&self, other: &InferRegion) -> bool {\n@@ -810,29 +862,57 @@ impl ToStr for IntVarValue {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for TyVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for TyVid {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_uint().iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for IntVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for IntVid {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_uint().iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for FloatVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for FloatVid {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_uint().iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for RegionVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for RegionVid {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_uint().iter_bytes(lsb0, f)\n+    }\n+}\n \n pub struct TypeParameterDef {\n     def_id: ast::def_id,\n@@ -2637,6 +2717,7 @@ impl cmp::TotalEq for bound_region {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for vstore {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -2651,37 +2732,87 @@ impl to_bytes::IterBytes for vstore {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for vstore {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          vstore_fixed(ref u) =>\n+          to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n \n+          vstore_uniq => 1u8.iter_bytes(lsb0, f),\n+          vstore_box => 2u8.iter_bytes(lsb0, f),\n+\n+          vstore_slice(ref r) =>\n+          to_bytes::iter_bytes_2(&3u8, r, lsb0, f),\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl to_bytes::IterBytes for substs {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n                                  &self.self_ty,\n                                  &self.tps, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for substs {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+          to_bytes::iter_bytes_3(&self.self_r,\n+                                 &self.self_ty,\n+                                 &self.tps, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for mt {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for mt {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+          to_bytes::iter_bytes_2(&self.ty,\n+                                 &self.mutbl, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for field {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for field {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+          to_bytes::iter_bytes_2(&self.ident,\n+                                 &self.mt, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for FnSig {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n                                &self.output,\n                                lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for FnSig {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.inputs,\n+                               &self.output,\n+                               lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for sty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -2756,6 +2887,81 @@ impl to_bytes::IterBytes for sty {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for sty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          ty_nil => 0u8.iter_bytes(lsb0, f),\n+          ty_bool => 1u8.iter_bytes(lsb0, f),\n+\n+          ty_int(ref t) =>\n+          to_bytes::iter_bytes_2(&2u8, t, lsb0, f),\n+\n+          ty_uint(ref t) =>\n+          to_bytes::iter_bytes_2(&3u8, t, lsb0, f),\n+\n+          ty_float(ref t) =>\n+          to_bytes::iter_bytes_2(&4u8, t, lsb0, f),\n+\n+          ty_estr(ref v) =>\n+          to_bytes::iter_bytes_2(&5u8, v, lsb0, f),\n+\n+          ty_enum(ref did, ref substs) =>\n+          to_bytes::iter_bytes_3(&6u8, did, substs, lsb0, f),\n+\n+          ty_box(ref mt) =>\n+          to_bytes::iter_bytes_2(&7u8, mt, lsb0, f),\n+\n+          ty_evec(ref mt, ref v) =>\n+          to_bytes::iter_bytes_3(&8u8, mt, v, lsb0, f),\n+\n+          ty_unboxed_vec(ref mt) =>\n+          to_bytes::iter_bytes_2(&9u8, mt, lsb0, f),\n+\n+          ty_tup(ref ts) =>\n+          to_bytes::iter_bytes_2(&10u8, ts, lsb0, f),\n+\n+          ty_bare_fn(ref ft) =>\n+          to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n+\n+          ty_self(ref did) => to_bytes::iter_bytes_2(&13u8, did, lsb0, f),\n+\n+          ty_infer(ref v) =>\n+          to_bytes::iter_bytes_2(&14u8, v, lsb0, f),\n+\n+          ty_param(ref p) =>\n+          to_bytes::iter_bytes_2(&15u8, p, lsb0, f),\n+\n+          ty_type => 16u8.iter_bytes(lsb0, f),\n+          ty_bot => 17u8.iter_bytes(lsb0, f),\n+\n+          ty_ptr(ref mt) =>\n+          to_bytes::iter_bytes_2(&18u8, mt, lsb0, f),\n+\n+          ty_uniq(ref mt) =>\n+          to_bytes::iter_bytes_2(&19u8, mt, lsb0, f),\n+\n+          ty_trait(ref did, ref substs, ref v, ref mutbl) =>\n+          to_bytes::iter_bytes_5(&20u8, did, substs, v, mutbl, lsb0, f),\n+\n+          ty_opaque_closure_ptr(ref ck) =>\n+          to_bytes::iter_bytes_2(&21u8, ck, lsb0, f),\n+\n+          ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n+\n+          ty_struct(ref did, ref substs) =>\n+          to_bytes::iter_bytes_3(&23u8, did, substs, lsb0, f),\n+\n+          ty_rptr(ref r, ref mt) =>\n+          to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n+\n+          ty_err => 25u8.iter_bytes(lsb0, f),\n+\n+          ty_closure(ref ct) =>\n+          to_bytes::iter_bytes_2(&26u8, ct, lsb0, f),\n+        }\n+    }\n+}\n \n pub fn node_id_to_trait_ref(cx: ctxt, id: ast::node_id) -> @ty::TraitRef {\n     match cx.trait_refs.find(&id) {\n@@ -4284,6 +4490,7 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::node_id),\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n+#[cfg(stage0)]\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         bounds: &ParamBounds,\n                                         f: &fn(@TraitRef) -> bool) {\n@@ -4323,6 +4530,52 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n         }\n     }\n }\n+// Iterate over a type parameter's bounded traits and any supertraits\n+// of those traits, ignoring kinds.\n+// Here, the supertraits are the transitive closure of the supertrait\n+// relation on the supertraits from each bounded trait's constraint\n+// list.\n+#[cfg(not(stage0))]\n+pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n+                                        bounds: &ParamBounds,\n+                                        f: &fn(@TraitRef) -> bool) -> bool {\n+    for bounds.trait_bounds.each |&bound_trait_ref| {\n+        let mut supertrait_set = HashMap::new();\n+        let mut trait_refs = ~[];\n+        let mut i = 0;\n+\n+        // Seed the worklist with the trait from the bound\n+        supertrait_set.insert(bound_trait_ref.def_id, ());\n+        trait_refs.push(bound_trait_ref);\n+\n+        // Add the given trait ty to the hash map\n+        while i < trait_refs.len() {\n+            debug!(\"each_bound_trait_and_supertraits(i=%?, trait_ref=%s)\",\n+                   i, trait_refs[i].repr(tcx));\n+\n+            if !f(trait_refs[i]) {\n+                return false;\n+            }\n+\n+            // Add supertraits to supertrait_set\n+            let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n+            for supertrait_refs.each |&supertrait_ref| {\n+                debug!(\"each_bound_trait_and_supertraits(supertrait_ref=%s)\",\n+                       supertrait_ref.repr(tcx));\n+\n+                let d_id = supertrait_ref.def_id;\n+                if !supertrait_set.contains_key(&d_id) {\n+                    // FIXME(#5527) Could have same trait multiple times\n+                    supertrait_set.insert(d_id, ());\n+                    trait_refs.push(supertrait_ref);\n+                }\n+            }\n+\n+            i += 1;\n+        }\n+    }\n+    return true;\n+}\n \n pub fn count_traits_and_supertraits(tcx: ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {"}, {"sha": "baa28b649827808b75bc61780f3b28ed8336736b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -828,13 +828,22 @@ pub impl FnCtxt {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn opt_node_ty_substs(&self, id: ast::node_id,\n                           f: &fn(&ty::substs) -> bool) {\n         match self.inh.node_type_substs.find(&id) {\n             Some(s) => { f(s); }\n             None => ()\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn opt_node_ty_substs(&self, id: ast::node_id,\n+                          f: &fn(&ty::substs) -> bool) -> bool {\n+        match self.inh.node_type_substs.find(&id) {\n+            Some(s) => f(s),\n+            None => true\n+        }\n+    }\n \n     fn mk_subty(&self,\n                 a_is_expected: bool,\n@@ -1294,6 +1303,26 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // The callee checks for bot / err, we don't need to\n     }\n \n+    fn write_call(fcx: @mut FnCtxt,\n+                  call_expr: @ast::expr,\n+                  output: ty::t,\n+                  sugar: ast::CallSugar) {\n+        let ret_ty = match sugar {\n+            ast::ForSugar => {\n+                match ty::get(output).sty {\n+                    ty::ty_bool => {}\n+                    _ => fcx.type_error_message(call_expr.span, |actual| {\n+                            fmt!(\"expected `for` closure to return `bool`, \\\n+                                  but found `%s`\", actual) },\n+                            output, None)\n+                }\n+                ty::mk_nil()\n+            }\n+            _ => output\n+        };\n+        fcx.write_ty(call_expr.id, ret_ty);\n+    }\n+\n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @mut FnCtxt,\n                   call_expr: @ast::expr,\n@@ -1344,8 +1373,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n                              args, sugar, DontDerefArgs);\n \n-        // Pull the return type out of the type of the function.\n-        fcx.write_ty(call_expr.id, fn_sig.output);\n+        write_call(fcx, call_expr, fn_sig.output, sugar);\n     }\n \n     // Checks a method call.\n@@ -1401,8 +1429,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                  fn_ty, expr, args, sugar,\n                                                  DontDerefArgs);\n \n-        // Pull the return type out of the type of the function.\n-        fcx.write_ty(expr.id, ret_ty);\n+        write_call(fcx, expr, ret_ty, sugar);\n     }\n \n     // A generic function for checking the then and else in an if"}, {"sha": "260d3f440f9cfdf23ba03a283a1c5b024e3cb59d", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -524,6 +524,7 @@ pub impl CoherenceChecker {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn each_provided_trait_method(&self,\n             trait_did: ast::def_id,\n             f: &fn(x: @ty::method) -> bool) {\n@@ -543,6 +544,27 @@ pub impl CoherenceChecker {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_provided_trait_method(&self,\n+            trait_did: ast::def_id,\n+            f: &fn(x: @ty::method) -> bool) -> bool {\n+        // Make a list of all the names of the provided methods.\n+        // XXX: This is horrible.\n+        let mut provided_method_idents = HashSet::new();\n+        let tcx = self.crate_context.tcx;\n+        for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n+            provided_method_idents.insert(*ident);\n+        }\n+\n+        for ty::trait_methods(tcx, trait_did).each |&method| {\n+            if provided_method_idents.contains(&method.ident) {\n+                if !f(method) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n \n     fn polytypes_unify(&self, polytype_a: ty_param_bounds_and_ty,\n                        polytype_b: ty_param_bounds_and_ty)"}, {"sha": "73c120ad35dd3e6dbe69d9c209a27a53e1c195cc", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -560,6 +560,7 @@ enum Constraint {\n     ConstrainVarSubReg(RegionVid, Region)\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Constraint {\n    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -574,6 +575,21 @@ impl to_bytes::IterBytes for Constraint {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Constraint {\n+   fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          ConstrainVarSubVar(ref v0, ref v1) =>\n+          to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n+\n+          ConstrainRegSubVar(ref ra, ref va) =>\n+          to_bytes::iter_bytes_3(&1u8, ra, va, lsb0, f),\n+\n+          ConstrainVarSubReg(ref va, ref ra) =>\n+          to_bytes::iter_bytes_3(&2u8, va, ra, lsb0, f)\n+        }\n+    }\n+}\n \n #[deriving(Eq, IterBytes)]\n struct TwoRegions {\n@@ -1756,6 +1772,7 @@ pub impl RegionVarBindings {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn each_edge(&mut self,\n                  graph: &Graph,\n                  node_idx: RegionVid,\n@@ -1771,6 +1788,23 @@ pub impl RegionVarBindings {\n             edge_idx = edge_ptr.next_edge[dir as uint];\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_edge(&mut self,\n+                 graph: &Graph,\n+                 node_idx: RegionVid,\n+                 dir: Direction,\n+                 op: &fn(edge: &GraphEdge) -> bool) -> bool {\n+        let mut edge_idx =\n+            graph.nodes[node_idx.to_uint()].head_edge[dir as uint];\n+        while edge_idx != uint::max_value {\n+            let edge_ptr = &graph.edges[edge_idx];\n+            if !op(edge_ptr) {\n+                return false;\n+            }\n+            edge_idx = edge_ptr.next_edge[dir as uint];\n+        }\n+        return true;\n+    }\n }\n \n fn iterate_until_fixed_point("}, {"sha": "c589ab52874218a178db905d11a916ca36f65cc5", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -49,6 +49,7 @@ pub impl<E:CLike> EnumSet<E> {\n         (self.bits & bit(e)) != 0\n     }\n \n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(E) -> bool) {\n         let mut bits = self.bits;\n         let mut index = 0;\n@@ -63,6 +64,22 @@ pub impl<E:CLike> EnumSet<E> {\n             bits >>= 1;\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(E) -> bool) -> bool {\n+        let mut bits = self.bits;\n+        let mut index = 0;\n+        while bits != 0 {\n+            if (bits & 1) != 0 {\n+                let e = CLike::from_uint(index);\n+                if !f(e) {\n+                    return false;\n+                }\n+            }\n+            index += 1;\n+            bits >>= 1;\n+        }\n+        return true;\n+    }\n }\n \n impl<E:CLike> core::Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {"}, {"sha": "94b94d373e6b60e5a0e1cc207f17916504bce06b", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -14,7 +14,7 @@ use path_util::{rust_path, workspace_contains_package_id};\n use util::PkgId;\n use core::path::Path;\n \n-pub fn pkg_parent_workspaces(pkgid: PkgId, action: &fn(&Path) -> bool) {\n+pub fn pkg_parent_workspaces(pkgid: PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n     let workspaces = rust_path().filtered(|ws|\n@@ -31,4 +31,5 @@ pub fn pkg_parent_workspaces(pkgid: PkgId, action: &fn(&Path) -> bool) {\n             break;\n         }\n     }\n-}\n\\ No newline at end of file\n+    return true;\n+}"}, {"sha": "09f86f30d320fcd2de908a92f5bf7c2276083dbb", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 63, "deletions": 31, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -143,14 +143,20 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) {\n         for uint::range(0, self.storage.len()) |i| {\n             let mut w = self.storage[i];\n             let b = op(&mut w);\n             self.storage[i] = w;\n             if !b { break; }\n         }\n-     }\n+    }\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n+        uint::range(0, self.storage.len(), |i| op(&mut self.storage[i]))\n+    }\n \n     #[inline(always)]\n     fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n@@ -193,6 +199,7 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n@@ -203,6 +210,19 @@ pub impl BigBitv {\n         }\n     }\n \n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n+        let len = b.storage.len();\n+        for uint::iterate(0, len) |i| {\n+            let mask = big_mask(nbits, i);\n+            if mask & self.storage[i] != mask & b.storage[i] {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n }\n \n enum BitvVariant { Big(~BigBitv), Small(~SmallBitv) }\n@@ -387,13 +407,24 @@ pub impl Bitv {\n     }\n \n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(bool) -> bool) {\n         let mut i = 0;\n         while i < self.nbits {\n             if !f(self.get(i)) { break; }\n             i += 1;\n         }\n     }\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(bool) -> bool) -> bool {\n+        let mut i = 0;\n+        while i < self.nbits {\n+            if !f(self.get(i)) { return false; }\n+            i += 1;\n+        }\n+        return true;\n+    }\n \n     /// Returns true if all bits are 0\n     fn is_false(&self) -> bool {\n@@ -488,13 +519,18 @@ pub impl Bitv {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn ones(&self, f: &fn(uint) -> bool) {\n         for uint::range(0, self.nbits) |i| {\n             if self.get(i) {\n                 if !f(i) { break }\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn ones(&self, f: &fn(uint) -> bool) -> bool {\n+        uint::range(0, self.nbits, |i| !self.get(i) || f(i))\n+    }\n \n }\n \n@@ -661,18 +697,21 @@ pub impl BitvSet {\n     }\n }\n \n+#[cfg(not(stage0))]\n impl BaseIter<uint> for BitvSet {\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n-    fn each(&self, blk: &fn(v: &uint) -> bool) {\n+    fn each(&self, blk: &fn(v: &uint) -> bool) -> bool {\n         for self.bitv.storage.eachi |i, &w| {\n             if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n-                return;\n+                return false;\n             }\n         }\n+        return true;\n     }\n }\n \n+#[cfg(not(stage0))]\n impl cmp::Eq for BitvSet {\n     fn eq(&self, other: &BitvSet) -> bool {\n         if self.size != other.size {\n@@ -706,6 +745,7 @@ impl Mutable for BitvSet {\n     }\n }\n \n+#[cfg(not(stage0))]\n impl Set<uint> for BitvSet {\n     fn contains(&self, value: &uint) -> bool {\n         *value < self.bitv.storage.len() * uint::bits && self.bitv.get(*value)\n@@ -773,64 +813,55 @@ impl Set<uint> for BitvSet {\n         other.is_subset(self)\n     }\n \n-    fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n-                return;\n+                return false;\n             }\n         }\n         /* everything we have that they don't also shows up */\n         self.each_outlier(other, |mine, i, w|\n             !mine || iterate_bits(i, w, |b| f(&b))\n-        );\n+        )\n     }\n \n     fn symmetric_difference(&self, other: &BitvSet,\n-                                 f: &fn(&uint) -> bool) {\n+                            f: &fn(&uint) -> bool) -> bool {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n-                return;\n+                return false;\n             }\n         }\n-        self.each_outlier(other, |_, i, w|\n-            iterate_bits(i, w, |b| f(&b))\n-        );\n+        self.each_outlier(other, |_, i, w| iterate_bits(i, w, |b| f(&b)))\n     }\n \n-    fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n-        for self.each_common(other) |i, w1, w2| {\n-            if !iterate_bits(i, w1 & w2, |b| f(&b)) {\n-                return;\n-            }\n-        }\n+    fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+        self.each_common(other, |i, w1, w2| iterate_bits(i, w1 & w2, |b| f(&b)))\n     }\n \n-    fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n-                return;\n+                return false;\n             }\n         }\n-        self.each_outlier(other, |_, i, w|\n-            iterate_bits(i, w, |b| f(&b))\n-        );\n+        self.each_outlier(other, |_, i, w| iterate_bits(i, w, |b| f(&b)))\n     }\n }\n \n+#[cfg(not(stage0))]\n priv impl BitvSet {\n     /// Visits each of the words that the two bit vectors (self and other)\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn each_common(&self, other: &BitvSet,\n-                        f: &fn(uint, uint, uint) -> bool) {\n+                   f: &fn(uint, uint, uint) -> bool) -> bool {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n-        for self.bitv.storage.slice(0, min).eachi |i, &w| {\n-            if !f(i * uint::bits, w, other.bitv.storage[i]) {\n-                return;\n-            }\n-        }\n+        self.bitv.storage.slice(0, min).eachi(|i, &w| {\n+            f(i * uint::bits, w, other.bitv.storage[i])\n+        })\n     }\n \n     /// Visits each word in self or other that extends beyond the other. This\n@@ -841,22 +872,23 @@ priv impl BitvSet {\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n     fn each_outlier(&self, other: &BitvSet,\n-                         f: &fn(bool, uint, uint) -> bool) {\n+                    f: &fn(bool, uint, uint) -> bool) -> bool {\n         let len1 = self.bitv.storage.len();\n         let len2 = other.bitv.storage.len();\n         let min = uint::min(len1, len2);\n \n         /* only one of these loops will execute and that's the point */\n         for self.bitv.storage.slice(min, len1).eachi |i, &w| {\n             if !f(true, (i + min) * uint::bits, w) {\n-                return;\n+                return false;\n             }\n         }\n         for other.bitv.storage.slice(min, len2).eachi |i, &w| {\n             if !f(false, (i + min) * uint::bits, w) {\n-                return;\n+                return false;\n             }\n         }\n+        return true;\n     }\n }\n "}, {"sha": "4eb359e48a84d518f4ea4b40443a1586f438a93e", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -63,15 +63,25 @@ pub impl<T> Deque<T> {\n     }\n \n     /// Iterate over the elements in the deque\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&T) -> bool) {\n         self.eachi(|_i, e| f(e))\n     }\n+    /// Iterate over the elements in the deque\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&T) -> bool) -> bool {\n+        self.eachi(|_i, e| f(e))\n+    }\n \n     /// Iterate over the elements in the deque by index\n+    #[cfg(stage0)]\n     fn eachi(&self, f: &fn(uint, &T) -> bool) {\n-        for uint::range(0, self.nelts) |i| {\n-            if !f(i, self.get(i as int)) { return; }\n-        }\n+        uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n+    }\n+    /// Iterate over the elements in the deque by index\n+    #[cfg(not(stage0))]\n+    fn eachi(&self, f: &fn(uint, &T) -> bool) -> bool {\n+        uint::range(0, self.nelts, |i| f(i, self.get(i as int)))\n     }\n \n     /// Remove and return the first element in the deque"}, {"sha": "741bd62968018fcad2eb77c6c76e7e01d982644a", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -393,6 +393,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n+    #[cfg(stage0)]\n     fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n@@ -401,6 +402,17 @@ pub impl<T> DList<T> {\n             link = nobe.next_link();\n         }\n     }\n+    /// Iterate over nodes.\n+    #[cfg(not(stage0))]\n+    fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) -> bool {\n+        let mut link = self.peek_n();\n+        while link.is_some() {\n+            let nobe = link.get();\n+            if !f(nobe) { return false; }\n+            link = nobe.next_link();\n+        }\n+        return true;\n+    }\n \n     /// Check data structure integrity. O(n).\n     fn assert_consistent(@mut self) {\n@@ -492,12 +504,13 @@ pub impl<T:Copy> DList<T> {\n \n impl<T> BaseIter<T> for @mut DList<T> {\n     /**\n-    * Iterates through the current contents.\n-    *\n-    * Attempts to access this dlist during iteration are allowed (to\n-    * allow for e.g. breadth-first search with in-place enqueues), but\n-    * removing the current node is forbidden.\n-    */\n+     * Iterates through the current contents.\n+     *\n+     * Attempts to access this dlist during iteration are allowed (to\n+     * allow for e.g. breadth-first search with in-place enqueues), but\n+     * removing the current node is forbidden.\n+     */\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(v: &T) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n@@ -525,6 +538,42 @@ impl<T> BaseIter<T> for @mut DList<T> {\n             link = nobe.next_link();\n         }\n     }\n+    /**\n+     * Iterates through the current contents.\n+     *\n+     * Attempts to access this dlist during iteration are allowed (to\n+     * allow for e.g. breadth-first search with in-place enqueues), but\n+     * removing the current node is forbidden.\n+     */\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(v: &T) -> bool) -> bool {\n+        let mut link = self.peek_n();\n+        while link.is_some() {\n+            let nobe = link.get();\n+            assert!(nobe.linked);\n+\n+            {\n+                let frozen_nobe = &*nobe;\n+                if !f(&frozen_nobe.data) { return false; }\n+            }\n+\n+            // Check (weakly) that the user didn't do a remove.\n+            if self.size == 0 {\n+                fail!(\"The dlist became empty during iteration??\")\n+            }\n+            if !nobe.linked ||\n+                (!((nobe.prev.is_some()\n+                    || managed::mut_ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+                                           nobe))\n+                   && (nobe.next.is_some()\n+                    || managed::mut_ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+                                           nobe)))) {\n+                fail!(\"Removing a dlist node during iteration is forbidden!\")\n+            }\n+            link = nobe.next_link();\n+        }\n+        return true;\n+    }\n \n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }"}, {"sha": "a57a16fb87daea53230b53a18e480ef484f70f32", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -200,6 +200,7 @@ pub mod reader {\n         }\n     }\n \n+    #[cfg(stage0)]\n     pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) {\n         let mut pos = d.start;\n         while pos < d.end {\n@@ -212,7 +213,22 @@ pub mod reader {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) -> bool {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n+            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+            if !it(elt_tag.val, doc) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n \n+    #[cfg(stage0)]\n     pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) {\n         let mut pos = d.start;\n         while pos < d.end {\n@@ -228,6 +244,23 @@ pub mod reader {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) -> bool {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n+            if elt_tag.val == tg {\n+                let doc = Doc { data: d.data, start: elt_size.next,\n+                                end: pos };\n+                if !it(doc) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n \n     pub fn doc_data(d: Doc) -> ~[u8] {\n         vec::slice::<u8>(*d.data, d.start, d.end).to_vec()"}, {"sha": "2c5cbc1cbf9274b47053dc439f889e495329f04e", "filename": "src/libstd/fileinput.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffileinput.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -256,10 +256,21 @@ impl FileInput {\n     (line numbers and file names, see documentation for\n     `FileInputState`). Otherwise identical to `lines_each`.\n     */\n+    #[cfg(stage0)]\n     pub fn each_line_state(&self,\n                             f: &fn(&str, FileInputState) -> bool) {\n          self.each_line(|line| f(line, copy self.fi.state));\n     }\n+    /**\n+    Apply `f` to each line successively, along with some state\n+    (line numbers and file names, see documentation for\n+    `FileInputState`). Otherwise identical to `lines_each`.\n+    */\n+    #[cfg(not(stage0))]\n+    pub fn each_line_state(&self,\n+                            f: &fn(&str, FileInputState) -> bool) -> bool {\n+         self.each_line(|line| f(line, copy self.fi.state))\n+    }\n \n \n     /**\n@@ -367,10 +378,22 @@ reading from `stdin`).\n \n Fails when attempting to read from a file that can't be opened.\n */\n+#[cfg(stage0)]\n pub fn input(f: &fn(&str) -> bool) {\n     let mut i = FileInput::from_args();\n     i.each_line(f);\n }\n+/**\n+Iterate directly over the command line arguments (no arguments implies\n+reading from `stdin`).\n+\n+Fails when attempting to read from a file that can't be opened.\n+*/\n+#[cfg(not(stage0))]\n+pub fn input(f: &fn(&str) -> bool) -> bool {\n+    let mut i = FileInput::from_args();\n+    i.each_line(f)\n+}\n \n /**\n Iterate directly over the command line arguments (no arguments\n@@ -379,32 +402,69 @@ provided at each call.\n \n Fails when attempting to read from a file that can't be opened.\n */\n+#[cfg(stage0)]\n pub fn input_state(f: &fn(&str, FileInputState) -> bool) {\n     let mut i = FileInput::from_args();\n     i.each_line_state(f);\n }\n+/**\n+Iterate directly over the command line arguments (no arguments\n+implies reading from `stdin`) with the current state of the iteration\n+provided at each call.\n+\n+Fails when attempting to read from a file that can't be opened.\n+*/\n+#[cfg(not(stage0))]\n+pub fn input_state(f: &fn(&str, FileInputState) -> bool) -> bool {\n+    let mut i = FileInput::from_args();\n+    i.each_line_state(f)\n+}\n \n /**\n Iterate over a vector of files (an empty vector implies just `stdin`).\n \n Fails when attempting to read from a file that can't be opened.\n */\n+#[cfg(stage0)]\n pub fn input_vec(files: ~[Option<Path>], f: &fn(&str) -> bool) {\n     let mut i = FileInput::from_vec(files);\n     i.each_line(f);\n }\n+/**\n+Iterate over a vector of files (an empty vector implies just `stdin`).\n+\n+Fails when attempting to read from a file that can't be opened.\n+*/\n+#[cfg(not(stage0))]\n+pub fn input_vec(files: ~[Option<Path>], f: &fn(&str) -> bool) -> bool {\n+    let mut i = FileInput::from_vec(files);\n+    i.each_line(f)\n+}\n \n /**\n Iterate over a vector of files (an empty vector implies just `stdin`)\n with the current state of the iteration provided at each call.\n \n Fails when attempting to read from a file that can't be opened.\n */\n+#[cfg(stage0)]\n pub fn input_vec_state(files: ~[Option<Path>],\n                        f: &fn(&str, FileInputState) -> bool) {\n     let mut i = FileInput::from_vec(files);\n     i.each_line_state(f);\n }\n+/**\n+Iterate over a vector of files (an empty vector implies just `stdin`)\n+with the current state of the iteration provided at each call.\n+\n+Fails when attempting to read from a file that can't be opened.\n+*/\n+#[cfg(not(stage0))]\n+pub fn input_vec_state(files: ~[Option<Path>],\n+                       f: &fn(&str, FileInputState) -> bool) -> bool {\n+    let mut i = FileInput::from_vec(files);\n+    i.each_line_state(f)\n+}\n \n #[cfg(test)]\n mod test {"}, {"sha": "13ef377fabeb26be6c5a93b78a051f61613c3895", "filename": "src/libstd/list.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -140,6 +140,7 @@ pub fn iter<T>(l: @List<T>, f: &fn(&T)) {\n }\n \n /// Iterate over a list\n+#[cfg(stage0)]\n pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n     let mut cur = l;\n     loop {\n@@ -152,9 +153,24 @@ pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n         }\n     }\n }\n+/// Iterate over a list\n+#[cfg(not(stage0))]\n+pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) -> bool {\n+    let mut cur = l;\n+    loop {\n+        cur = match *cur {\n+          Cons(ref hd, tl) => {\n+            if !f(hd) { return false; }\n+            tl\n+          }\n+          Nil => { return true; }\n+        }\n+    }\n+}\n \n impl<T> MutList<T> {\n     /// Iterate over a mutable list\n+    #[cfg(stage0)]\n     pub fn each(@mut self, f: &fn(&mut T) -> bool) {\n         let mut cur = self;\n         loop {\n@@ -170,6 +186,24 @@ impl<T> MutList<T> {\n             }\n         }\n     }\n+    /// Iterate over a mutable list\n+    #[cfg(not(stage0))]\n+    pub fn each(@mut self, f: &fn(&mut T) -> bool) -> bool {\n+        let mut cur = self;\n+        loop {\n+            let borrowed = &mut *cur;\n+            cur = match *borrowed {\n+                MutCons(ref mut hd, tl) => {\n+                    if !f(hd) {\n+                        return false;\n+                    }\n+                    tl\n+                }\n+                MutNil => break\n+            }\n+        }\n+        return true;\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "e7cf710cf67978e381a06edeb96f6be98302df5a", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -703,11 +703,18 @@ impl ToStr for Url {\n     }\n }\n \n+#[cfg(stage0)]\n impl IterBytes for Url {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_str().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl IterBytes for Url {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_str().iter_bytes(lsb0, f)\n+    }\n+}\n \n // Put a few tests outside of the 'test' module so they can test the internal\n // functions and those functions don't need 'pub'"}, {"sha": "bdb93142472fbc583d56039915a73a08eb604b19", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -28,7 +28,14 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n     /// Visit all values in the underlying vector.\n     ///\n     /// The values are **not** visited in order.\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&T) -> bool) { self.data.each(f) }\n+    /// Visit all values in the underlying vector.\n+    ///\n+    /// The values are **not** visited in order.\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&T) -> bool) -> bool { self.data.each(f) }\n+\n     fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n }\n "}, {"sha": "afc1d0fe65fcb2dfc8f1a88034816fa23cc136bb", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -51,6 +51,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all key-value pairs in order\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n@@ -60,25 +61,62 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n     /// Visit all keys in order\n+    #[cfg(stage0)]\n     fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n         self.each(|k, _| blk(k))\n     }\n+    #[cfg(not(stage0))]\n+    /// Visit all keys in order\n+    fn each_key(&self, blk: &fn(key: &uint) -> bool) -> bool {\n+        self.each(|k, _| blk(k))\n+    }\n \n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n \n+    /// Visit all values in order\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) -> bool {\n+        self.each(|_, v| blk(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n-              Some(ref mut elt) => if !it(&i, elt) { break },\n+              Some(ref mut elt) => if !it(&i, elt) { return; },\n               None => ()\n             }\n         }\n     }\n+    /// Iterate over the map and mutate the contained values\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref mut elt) => if !it(&i, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n \n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n@@ -149,6 +187,7 @@ pub impl<V> SmallIntMap<V> {\n     fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n     /// Visit all key-value pairs in reverse order\n+    #[cfg(stage0)]\n     fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n@@ -158,6 +197,18 @@ pub impl<V> SmallIntMap<V> {\n         }\n     }\n \n+    /// Visit all key-value pairs in reverse order\n+    #[cfg(not(stage0))]\n+    fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n+        for uint::range_rev(self.v.len(), 0) |i| {\n+            match self.v[i - 1] {\n+              Some(ref elt) => if !it(i - 1, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n     fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }"}, {"sha": "252bb1a6af8e98db450e2db4345c1499a8221da0", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 207, "deletions": 11, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -105,24 +105,48 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Visit all key-value pairs in order\n+    #[cfg(stage0)]\n     fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n+        each(&self.root, f);\n+    }\n+    /// Visit all key-value pairs in order\n+    #[cfg(not(stage0))]\n+    fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n         each(&self.root, f)\n     }\n \n     /// Visit all keys in order\n+    #[cfg(stage0)]\n     fn each_key(&self, f: &fn(&K) -> bool) {\n         self.each(|k, _| f(k))\n     }\n+    /// Visit all keys in order\n+    #[cfg(not(stage0))]\n+    fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n+        self.each(|k, _| f(k))\n+    }\n \n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) {\n         self.each(|_, v| f(v))\n     }\n+    /// Visit all values in order\n+    #[cfg(not(stage0))]\n+    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n+        self.each(|_, v| f(v))\n+    }\n \n     /// Iterate over the map and mutate the contained values\n+    #[cfg(stage0)]\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) {\n         mutate_values(&mut self.root, f);\n     }\n+    /// Iterate over the map and mutate the contained values\n+    #[cfg(not(stage0))]\n+    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n+        mutate_values(&mut self.root, f)\n+    }\n \n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n@@ -177,6 +201,7 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n+#[cfg(stage0)]\n pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n@@ -202,6 +227,32 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n+#[cfg(not(stage0))]\n+pub impl<K: TotalOrd, V> TreeMap<K, V> {\n+    /// Create an empty TreeMap\n+    fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n+\n+    /// Visit all key-value pairs in reverse order\n+    fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n+        each_reverse(&self.root, f)\n+    }\n+\n+    /// Visit all keys in reverse order\n+    fn each_key_reverse(&self, f: &fn(&K) -> bool) -> bool {\n+        self.each_reverse(|k, _| f(k))\n+    }\n+\n+    /// Visit all values in reverse order\n+    fn each_value_reverse(&self, f: &fn(&V) -> bool) -> bool {\n+        self.each_reverse(|_, v| f(v))\n+    }\n+\n+    /// Get a lazy iterator over the key-value pairs in the map.\n+    /// Requires that it be frozen (immutable).\n+    fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n+        TreeMapIterator{stack: ~[], node: &self.root}\n+    }\n+}\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<'self, K, V> {\n@@ -246,17 +297,29 @@ pub struct TreeSet<T> {\n impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n+    /// Visit all values in order\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_reverse(&self, f: &fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n+    /// Visit all values in reverse order\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+        self.map.each_key_reverse(f)\n+    }\n }\n \n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n@@ -361,6 +424,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the difference\n+    #[cfg(stage0)]\n     fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -389,8 +453,38 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             }\n         }\n     }\n+    /// Visit the values (in-order) representing the difference\n+    #[cfg(not(stage0))]\n+    fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+\n+        let mut a = x.next();\n+        let mut b = y.next();\n+\n+        while a.is_some() {\n+            if b.is_none() {\n+                return f(a.unwrap()) && x.advance(f);\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            let cmp = a1.cmp(b1);\n+\n+            if cmp == Less {\n+                if !f(a1) { return false; }\n+                a = x.next();\n+            } else {\n+                if cmp == Equal { a = x.next() }\n+                b = y.next();\n+            }\n+        }\n+        return true;\n+    }\n \n     /// Visit the values (in-order) representing the symmetric difference\n+    #[cfg(stage0)]\n     fn symmetric_difference(&self, other: &TreeSet<T>,\n                                  f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n@@ -427,8 +521,43 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             if f(b1) { y.next() } else { None }\n         }\n     }\n+    /// Visit the values (in-order) representing the symmetric difference\n+    #[cfg(not(stage0))]\n+    fn symmetric_difference(&self, other: &TreeSet<T>,\n+                            f: &fn(&T) -> bool) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+\n+        let mut a = x.next();\n+        let mut b = y.next();\n+\n+        while a.is_some() {\n+            if b.is_none() {\n+                return f(a.unwrap()) && x.advance(f);\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            let cmp = a1.cmp(b1);\n+\n+            if cmp == Less {\n+                if !f(a1) { return false; }\n+                a = x.next();\n+            } else {\n+                if cmp == Greater {\n+                    if !f(b1) { return false; }\n+                } else {\n+                    a = x.next();\n+                }\n+                b = y.next();\n+            }\n+        }\n+        return b.each(|&x| f(x)) && y.advance(f);\n+    }\n \n     /// Visit the values (in-order) representing the intersection\n+    #[cfg(stage0)]\n     fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -452,8 +581,35 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             }\n         }\n     }\n+    /// Visit the values (in-order) representing the intersection\n+    #[cfg(not(stage0))]\n+    fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+\n+        let mut a = x.next();\n+        let mut b = y.next();\n+\n+        while a.is_some() && b.is_some() {\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            let cmp = a1.cmp(b1);\n+\n+            if cmp == Less {\n+                a = x.next();\n+            } else {\n+                if cmp == Equal {\n+                    if !f(a1) { return false }\n+                }\n+                b = y.next();\n+            }\n+        }\n+        return true;\n+    }\n \n     /// Visit the values (in-order) representing the union\n+    #[cfg(stage0)]\n     fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -488,6 +644,38 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n             if f(b1) { y.next() } else { None }\n         }\n     }\n+    /// Visit the values (in-order) representing the union\n+    #[cfg(not(stage0))]\n+    fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+\n+        let mut a = x.next();\n+        let mut b = y.next();\n+\n+        while a.is_some() {\n+            if b.is_none() {\n+                return f(a.unwrap()) && x.advance(f);\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            let cmp = a1.cmp(b1);\n+\n+            if cmp == Greater {\n+                if !f(b1) { return false; }\n+                b = y.next();\n+            } else {\n+                if !f(a1) { return false; }\n+                if cmp == Equal {\n+                    b = y.next();\n+                }\n+                a = x.next();\n+            }\n+        }\n+        return b.each(|&x| f(x)) && y.advance(f);\n+    }\n }\n \n pub impl <T: TotalOrd> TreeSet<T> {\n@@ -525,20 +713,28 @@ pub impl<K: TotalOrd, V> TreeNode<K, V> {\n     }\n }\n \n+#[cfg(stage0)]\n+fn each<'r, K: TotalOrd, V>(_: &'r Option<~TreeNode<K, V>>,\n+                            _: &fn(&'r K, &'r V) -> bool) -> bool {\n+    fail!(~\"don't use me in stage0!\")\n+}\n+#[cfg(not(stage0))]\n fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                            f: &fn(&'r K, &'r V) -> bool) {\n-    for node.each |x| {\n-        each(&x.left, f);\n-        if f(&x.key, &x.value) { each(&x.right, f) }\n-    }\n+                            f: &fn(&'r K, &'r V) -> bool) -> bool {\n+    node.each(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n+                  each(&x.right, f))\n }\n \n+#[cfg(stage0)]\n+fn each_reverse<'r, K: TotalOrd, V>(_: &'r Option<~TreeNode<K, V>>,\n+                                    _: &fn(&'r K, &'r V) -> bool) -> bool {\n+    fail!(~\"don't use me in stage0!\")\n+}\n+#[cfg(not(stage0))]\n fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                                    f: &fn(&'r K, &'r V) -> bool) {\n-    for node.each |x| {\n-        each_reverse(&x.right, f);\n-        if f(&x.key, &x.value) { each_reverse(&x.left, f) }\n-    }\n+                                    f: &fn(&'r K, &'r V) -> bool) -> bool {\n+    node.each(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&\n+                  each_reverse(&x.left, f))\n }\n \n fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n@@ -1130,7 +1326,7 @@ mod test_set {\n     }\n \n     fn check(a: &[int], b: &[int], expected: &[int],\n-             f: &fn(&TreeSet<int>, &TreeSet<int>, f: &fn(&int) -> bool)) {\n+             f: &fn(&TreeSet<int>, &TreeSet<int>, f: &fn(&int) -> bool) -> bool) {\n         let mut set_a = TreeSet::new();\n         let mut set_b = TreeSet::new();\n "}, {"sha": "9b0a6cb6226c191050151e6c4556801d52ce14dc", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -99,6 +99,7 @@ struct WorkKey {\n     name: ~str\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for WorkKey {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n@@ -108,6 +109,13 @@ impl to_bytes::IterBytes for WorkKey {\n         self.name.iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for WorkKey {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.kind.iter_bytes(lsb0, f) && self.name.iter_bytes(lsb0, f)\n+    }\n+}\n \n impl cmp::Ord for WorkKey {\n     fn lt(&self, other: &WorkKey) -> bool {"}, {"sha": "f266b8871a225189d6aafca75e8a638d4a3873b7", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -81,6 +81,7 @@ static AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\", abi_arch: RustArch},\n ];\n \n+#[cfg(stage0)]\n fn each_abi(op: &fn(abi: Abi) -> bool) {\n     /*!\n      *\n@@ -93,6 +94,15 @@ fn each_abi(op: &fn(abi: Abi) -> bool) {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+fn each_abi(op: &fn(abi: Abi) -> bool) -> bool {\n+    /*!\n+     *\n+     * Iterates through each of the defined ABIs.\n+     */\n+\n+    AbiDatas.each(|abi_data| op(abi_data.abi))\n+}\n \n pub fn lookup(name: &str) -> Option<Abi> {\n     /*!\n@@ -189,6 +199,7 @@ pub impl AbiSet {\n         self.bits |= (1 << abi.index());\n     }\n \n+    #[cfg(stage0)]\n     fn each(&self, op: &fn(abi: Abi) -> bool) {\n         for each_abi |abi| {\n             if self.contains(abi) {\n@@ -198,6 +209,10 @@ pub impl AbiSet {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each(&self, op: &fn(abi: Abi) -> bool) -> bool {\n+        each_abi(|abi| !self.contains(abi) || op(abi))\n+    }\n \n     fn is_empty(&self) -> bool {\n         self.bits == 0\n@@ -252,17 +267,31 @@ pub impl AbiSet {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Abi {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.index().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Abi {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.index().iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for AbiSet {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.bits.iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for AbiSet {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.bits.iter_bytes(lsb0, f)\n+    }\n+}\n \n impl ToStr for Abi {\n     fn to_str(&self) -> ~str {"}, {"sha": "f4e3e6832292adf36e4831d0d5c58861872460c3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -97,11 +97,18 @@ impl<D:Decoder> Decodable<D> for ident {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for ident {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for ident {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.repr.iter_bytes(lsb0, f)\n+    }\n+}\n \n // Functions may or may not have names.\n pub type fn_ident = Option<ident>;\n@@ -284,6 +291,7 @@ pub enum binding_mode {\n     bind_infer\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for binding_mode {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -297,6 +305,18 @@ impl to_bytes::IterBytes for binding_mode {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for binding_mode {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          bind_by_copy => 0u8.iter_bytes(lsb0, f),\n+\n+          bind_by_ref(ref m) => to_bytes::iter_bytes_2(&1u8, m, lsb0, f),\n+\n+          bind_infer => 2u8.iter_bytes(lsb0, f),\n+        }\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -330,11 +350,18 @@ pub enum pat_ {\n #[deriving(Eq)]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for mutability {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for mutability {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -345,11 +372,18 @@ pub enum Sigil {\n     ManagedSigil\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Sigil {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Sigil {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl ToStr for Sigil {\n     fn to_str(&self) -> ~str {\n@@ -744,11 +778,18 @@ impl ToStr for int_ty {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for int_ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for int_ty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -761,11 +802,18 @@ impl ToStr for uint_ty {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for uint_ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for uint_ty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -778,11 +826,18 @@ impl ToStr for float_ty {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for float_ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for float_ty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n // NB Eq method appears below.\n #[auto_encode]\n@@ -823,11 +878,18 @@ impl ToStr for Onceness {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Onceness {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Onceness {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -874,11 +936,18 @@ pub enum ty_ {\n     ty_infer,\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Ty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Ty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -941,11 +1010,18 @@ impl ToStr for purity {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for purity {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for purity {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -956,11 +1032,18 @@ pub enum ret_style {\n     return_val, // everything else\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for ret_style {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for ret_style {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]"}, {"sha": "ceff868d11f21b5688d0287a22c199ab8d9dd335", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -191,12 +191,21 @@ pub fn is_call_expr(e: @expr) -> bool {\n }\n \n // This makes def_id hashable\n+#[cfg(stage0)]\n impl to_bytes::IterBytes for def_id {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n     }\n }\n+// This makes def_id hashable\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for def_id {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f)\n+    }\n+}\n \n pub fn block_from_expr(e: @expr) -> blk {\n     let blk_ = default_block(~[], option::Some::<@expr>(e), e.id);"}, {"sha": "053ed76d66b2a911a6a3fe3c90c8c9dd4153a6d9", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -65,11 +65,18 @@ impl Sub<BytePos, BytePos> for BytePos {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for BytePos {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for BytePos {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl Pos for CharPos {\n     fn from_uint(n: uint) -> CharPos { CharPos(n) }\n@@ -83,11 +90,18 @@ impl cmp::Ord for CharPos {\n     fn gt(&self, other: &CharPos) -> bool { **self > **other }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for CharPos {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for CharPos {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n impl Add<CharPos,CharPos> for CharPos {\n     fn add(&self, rhs: &CharPos) -> CharPos {"}, {"sha": "9eb246ffe2228815ba3c9dba23956f92b2d1abab", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{meta_item, item, expr};\n+use ast::{meta_item, item, expr, and};\n use codemap::span;\n use ext::base::ext_ctxt;\n use ext::build;\n@@ -31,7 +31,7 @@ pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n                     Literal(Path::new(~[~\"bool\"])),\n                     Literal(Path::new(~[~\"core\", ~\"to_bytes\", ~\"Cb\"]))\n                 ],\n-                ret_ty: nil_ty(),\n+                ret_ty: Literal(Path::new(~[~\"bool\"])),\n                 const_nonmatching: false,\n                 combine_substructure: iter_bytes_substructure\n             }\n@@ -58,13 +58,11 @@ fn iter_bytes_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) ->\n     };\n     let iter_bytes_ident = substr.method_ident;\n     let call_iterbytes = |thing_expr| {\n-        build::mk_stmt(\n-            cx, span,\n-            build::mk_method_call(cx, span,\n-                                  thing_expr, iter_bytes_ident,\n-                                  copy lsb0_f))\n+        build::mk_method_call(cx, span,\n+                              thing_expr, iter_bytes_ident,\n+                              copy lsb0_f)\n     };\n-    let mut stmts = ~[];\n+    let mut exprs = ~[];\n     let fields;\n     match *substr.fields {\n         Struct(ref fs) => {\n@@ -78,16 +76,22 @@ fn iter_bytes_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) ->\n                 None => build::mk_uint(cx, span, index)\n             };\n \n-            stmts.push(call_iterbytes(discriminant));\n+            exprs.push(call_iterbytes(discriminant));\n \n             fields = fs;\n         }\n         _ => cx.span_bug(span, \"Impossible substructure in `deriving(IterBytes)`\")\n     }\n \n     for fields.each |&(_, field, _)| {\n-        stmts.push(call_iterbytes(field));\n+        exprs.push(call_iterbytes(field));\n     }\n \n-    build::mk_block(cx, span, ~[], stmts, None)\n+    if exprs.len() == 0 {\n+        cx.span_bug(span, \"#[deriving(IterBytes)] needs at least one field\");\n+    }\n+\n+    do vec::foldl(exprs[0], exprs.slice(1, exprs.len())) |prev, me| {\n+        build::mk_binary(cx, span, and, prev, *me)\n+    }\n }"}, {"sha": "5129fa6ebd2aa06b950b31514c1d372a53c39c08", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -195,18 +195,8 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n }\n \n // does this attribute list contain \"macro_escape\" ?\n-pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool{\n-    let mut accum = false;\n-    do attrs.each |attr| {\n-        let mname = attr::get_attr_name(attr);\n-        if (mname == @~\"macro_escape\") {\n-            accum = true;\n-            false\n-        } else {\n-            true\n-        }\n-    }\n-    accum\n+pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool {\n+    attrs.any(|attr| \"macro_escape\" == *attr::get_attr_name(attr))\n }\n \n // this macro disables (one layer of) macro"}, {"sha": "7c78ec066d03188090af5e2010191da8abfbae5d", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -100,6 +100,7 @@ pub impl state_ {\n \n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n+    #[cfg(stage0)]\n     fn reachable(&self, f: &fn(state) -> bool) {\n         for self.messages.each |m| {\n             match *m {\n@@ -111,6 +112,21 @@ pub impl state_ {\n             }\n         }\n     }\n+    /// Iterate over the states that can be reached in one message\n+    /// from this state.\n+    #[cfg(not(stage0))]\n+    fn reachable(&self, f: &fn(state) -> bool) -> bool {\n+        for self.messages.each |m| {\n+            match *m {\n+              message(_, _, _, _, Some(next_state { state: ref id, _ })) => {\n+                let state = self.proto.get_state((*id));\n+                if !f(state) { return false; }\n+              }\n+              _ => ()\n+            }\n+        }\n+        return true;\n+    }\n }\n \n pub type protocol = @mut protocol_;"}, {"sha": "6110579863dbfe3c9c9ea9c21880a356c38fc1ec", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -132,12 +132,20 @@ impl<A:Eq> Eq for OptVec<A> {\n }\n \n impl<A> BaseIter<A> for OptVec<A> {\n+    #[cfg(stage0)]\n     fn each(&self, blk: &fn(v: &A) -> bool) {\n         match *self {\n             Empty => {}\n             Vec(ref v) => v.each(blk)\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each(&self, blk: &fn(v: &A) -> bool) -> bool {\n+        match *self {\n+            Empty => true,\n+            Vec(ref v) => v.each(blk)\n+        }\n+    }\n \n     fn size_hint(&self) -> Option<uint> {\n         Some(self.len())\n@@ -146,10 +154,16 @@ impl<A> BaseIter<A> for OptVec<A> {\n \n impl<A> old_iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) {\n         old_iter::eachi(self, blk)\n     }\n     #[inline(always)]\n+    #[cfg(not(stage0))]\n+    fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) -> bool {\n+        old_iter::eachi(self, blk)\n+    }\n+    #[inline(always)]\n     fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         old_iter::all(self, blk)\n     }"}, {"sha": "a4ac038cf466f442d05f05500bb50426e98aba48", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -62,12 +62,20 @@ pub enum ObsoleteSyntax {\n     ObsoleteFixedLengthVectorType,\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for ObsoleteSyntax {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for ObsoleteSyntax {\n+    #[inline(always)]\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n pub impl Parser {\n     /// Reports an obsolete syntax non-fatal error."}, {"sha": "5688678b06ac4a4cac1fdee452c65b2b6c5a24e4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -355,11 +355,18 @@ impl<'self> Equiv<@~str> for StringRef<'self> {\n     fn equiv(&self, other: &@~str) -> bool { str::eq_slice(**self, **other) }\n }\n \n+#[cfg(stage0)]\n impl<'self> to_bytes::IterBytes for StringRef<'self> {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'self> to_bytes::IterBytes for StringRef<'self> {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (**self).iter_bytes(lsb0, f)\n+    }\n+}\n \n /**\n  * Maps a token to a record specifying the corresponding binary"}, {"sha": "fb27672354371edd42a62e2ca536eb428b066162", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -10,8 +10,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(deprecated_mode)];\n-\n /*!\n \n An implementation of the Graph500 Breadth First Search problem in Rust.\n@@ -23,7 +21,7 @@ use std::arc;\n use std::time;\n use std::deque::Deque;\n use std::par;\n-use core::hashmap::{HashMap, HashSet};\n+use core::hashmap::HashSet;\n use core::int::abs;\n use core::rand::RngUtil;\n \n@@ -83,14 +81,13 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n         HashSet::new()\n     };\n \n-    do vec::each(edges) |e| {\n+    for vec::each(edges) |e| {\n         match *e {\n             (i, j) => {\n                 graph[i].insert(j);\n                 graph[j].insert(i);\n             }\n         }\n-        true\n     }\n \n     do vec::map_consume(graph) |mut v| {"}, {"sha": "7ff51eff8eeb64612b4a1cf9b343a0f8aea10775", "filename": "src/test/compile-fail/bad-for-loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -11,4 +11,5 @@\n fn main() {\n     fn baz(_x: &fn(y: int) -> int) {}\n     for baz |_e| { } //~ ERROR A `for` loop iterator should expect a closure that returns `bool`\n+                     //~^ ERROR expected `for` closure to return `bool`\n }"}, {"sha": "f7a72d6e6108c36d9ac2cf203ed31a0304709f33", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -17,7 +17,7 @@\n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n fn cond() -> bool { fail!() }\n-fn for_func(_f: &fn() -> bool) { fail!() }\n+fn for_func(_f: &fn() -> bool) -> bool { fail!() }\n fn produce<T>() -> T { fail!(); }\n \n fn inc(v: &mut ~int) {"}, {"sha": "17b0d88a6a827712fda6a2bb7f11cc0cae4bdb83", "filename": "src/test/compile-fail/issue-2817-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn not_bool(f: &fn(int) -> ~str) {}\n+fn not_bool(f: &fn(int) -> ~str) -> bool {}\n \n fn main() {\n     for uint::range(0, 100000) |_i| { //~ ERROR A for-loop body must return (), but"}, {"sha": "77585d15b6b3ebbcd8d7c79f73590472d0d836cd", "filename": "src/test/compile-fail/issue-2817.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fissue-2817.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fissue-2817.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2817.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -16,10 +16,10 @@ fn uuid_random() -> uint { fail!(); }\n \n fn main() {\n     do uint::range(0, 100000) |_i| { //~ ERROR Do-block body must return bool, but\n-    }\n+    };\n     // should get a more general message if the callback\n     // doesn't return nil\n     do uint::range(0, 100000) |_i| { //~ ERROR mismatched types\n         ~\"str\"\n-    }\n+    };\n }"}, {"sha": "98a02b6b74691c4b390ffda638b472245a4c2baa", "filename": "src/test/compile-fail/issue-3651-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fissue-3651-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fissue-3651-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3651-2.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    do 5.times {} //~ ERROR Do-block body must return bool, but returns () here. Perhaps\n+    do 5.times {}; //~ ERROR Do-block body must return bool, but returns () here. Perhaps\n }"}, {"sha": "8d704859fe57453cea89fb547a83aa3b27883088", "filename": "src/test/compile-fail/issue-3651.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fissue-3651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fissue-3651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3651.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     for task::spawn { return true; } //~ ERROR A `for` loop iterator should expect a closure that\n+                                     //~^ ERROR expected `for` closure to return `bool`\n }"}, {"sha": "0d84bc2fc605c040713fb9f05efb67f65241327a", "filename": "src/test/compile-fail/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -18,7 +18,7 @@ mod kitties {\n     }\n \n     pub impl cat {\n-        priv fn nap(&self) { uint::range(1u, 10000u, |_i| false)}\n+        priv fn nap(&self) { uint::range(1u, 10000u, |_i| false); }\n     }\n \n     pub fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "6946ed3fbcfc0dfaa7c1aba7ff83db95617b6b0b", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -13,22 +13,18 @@\n // it.\n \n trait iterable<A> {\n-    fn iterate(&self, blk: &fn(x: &A) -> bool);\n+    fn iterate(&self, blk: &fn(x: &A) -> bool) -> bool;\n }\n \n impl<'self,A> iterable<A> for &'self [A] {\n-    fn iterate(&self, f: &fn(x: &A) -> bool) {\n-        for vec::each(*self) |e| {\n-            if !f(e) { break; }\n-        }\n+    fn iterate(&self, f: &fn(x: &A) -> bool) -> bool {\n+        vec::each(*self, f)\n     }\n }\n \n impl<A> iterable<A> for ~[A] {\n-    fn iterate(&self, f: &fn(x: &A) -> bool) {\n-        for vec::each(*self) |e| {\n-            if !f(e) { break; }\n-        }\n+    fn iterate(&self, f: &fn(x: &A) -> bool) -> bool {\n+        vec::each(*self, f)\n     }\n }\n "}, {"sha": "778637701c5fd6dca724ed10df0d2301cea5c152", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -18,7 +18,7 @@ fn add_int(x: &mut Ints, v: int) {\n     x.values <-> values;\n }\n \n-fn iter_ints(x: &Ints, f: &fn(x: &int) -> bool) {\n+fn iter_ints(x: &Ints, f: &fn(x: &int) -> bool) -> bool {\n     let l = x.values.len();\n     uint::range(0, l, |i| f(&x.values[i]))\n }"}, {"sha": "39d4b25f262be118b8fed83b9168d8ffc4821bd9", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -59,25 +59,26 @@ impl<T> Mutable for cat<T> {\n }\n \n impl<T> Map<int, T> for cat<T> {\n-    fn each<'a>(&'a self, f: &fn(&int, &'a T) -> bool) {\n+    fn each<'a>(&'a self, f: &fn(&int, &'a T) -> bool) -> bool {\n         let mut n = int::abs(self.meows);\n         while n > 0 {\n-            if !f(&n, &self.name) { break; }\n+            if !f(&n, &self.name) { return false; }\n             n -= 1;\n         }\n+        return true;\n     }\n \n     fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n \n-    fn each_key(&self, f: &fn(v: &int) -> bool) {\n-        for self.each |k, _| { if !f(k) { break; } loop;};\n+    fn each_key(&self, f: &fn(v: &int) -> bool) -> bool {\n+        self.each(|k, _| f(k))\n     }\n \n-    fn each_value<'a>(&'a self, f: &fn(v: &'a T) -> bool) {\n-        for self.each |_, v| { if !f(v) { break; } loop;};\n+    fn each_value<'a>(&'a self, f: &fn(v: &'a T) -> bool) -> bool {\n+        self.each(|_, v| f(v))\n     }\n \n-    fn mutate_values(&mut self, _f: &fn(&int, &mut T) -> bool) {\n+    fn mutate_values(&mut self, _f: &fn(&int, &mut T) -> bool) -> bool {\n         fail!(~\"nope\")\n     }\n "}, {"sha": "fb1bc37fd5efabd4e989c091a0e9cb06bf5461a5", "filename": "src/test/run-pass/do-for-empty-args.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fdo-for-empty-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fdo-for-empty-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-for-empty-args.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -11,14 +11,15 @@\n // no-reformat\n // Testing various forms of `do` and `for` with empty arg lists\n \n-fn f(f: &fn() -> bool) {\n+fn f(f: &fn() -> bool) -> bool {\n+    true\n }\n \n pub fn main() {\n-    do f() || { true }\n-    do f() { true }\n-    do f || { true }\n-    do f { true }\n+    do f() || { true };\n+    do f() { true };\n+    do f || { true };\n+    do f { true };\n     for f() || { }\n     for f() { }\n     for f || { }"}, {"sha": "e9d7c946a9a11ee2351a96ccfaa43d27dff887dc", "filename": "src/test/run-pass/do-for-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fdo-for-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fdo-for-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-for-no-args.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -10,7 +10,7 @@\n \n // Testing that we can drop the || in for/do exprs\n \n-fn f(f: @fn() -> bool) { }\n+fn f(f: @fn() -> bool) -> bool { true }\n \n fn d(f: @fn()) { }\n "}, {"sha": "1792a89d64f1ea485cf919aedbde8447e47ed06d", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0400fb86170baff30282edcdccff73e243fd6e/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=3e0400fb86170baff30282edcdccff73e243fd6e", "patch": "@@ -12,12 +12,13 @@\n \n use core::cmp::Eq;\n \n-fn iter<T>(v: ~[T], it: &fn(&T) -> bool) {\n+fn iter<T>(v: ~[T], it: &fn(&T) -> bool) -> bool {\n     let mut i = 0u, l = v.len();\n     while i < l {\n-        if !it(&v[i]) { break; }\n+        if !it(&v[i]) { return false; }\n         i += 1u;\n     }\n+    return true;\n }\n \n fn find_pos<T:Eq + Copy + Clone>(n: T, h: ~[T]) -> Option<uint> {"}]}