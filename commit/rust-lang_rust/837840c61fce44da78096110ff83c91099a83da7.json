{"sha": "837840c61fce44da78096110ff83c91099a83da7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNzg0MGM2MWZjZTQ0ZGE3ODA5NjExMGZmODNjOTEwOTlhODNkYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-19T19:28:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-19T19:28:59Z"}, "message": "Auto merge of #28516 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #28400, #28430, #28443, #28483, #28485, #28496, #28511, #28515\n- Failed merges:", "tree": {"sha": "b886e39a6db6a0f7fbd85096a1658e255f7561c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b886e39a6db6a0f7fbd85096a1658e255f7561c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/837840c61fce44da78096110ff83c91099a83da7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/837840c61fce44da78096110ff83c91099a83da7", "html_url": "https://github.com/rust-lang/rust/commit/837840c61fce44da78096110ff83c91099a83da7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/837840c61fce44da78096110ff83c91099a83da7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6db1a0ea7c150c0d3ac361996a993cd9548f6daa", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db1a0ea7c150c0d3ac361996a993cd9548f6daa", "html_url": "https://github.com/rust-lang/rust/commit/6db1a0ea7c150c0d3ac361996a993cd9548f6daa"}, {"sha": "234f81c4a91f58abf44bed68d1ff446a6828b425", "url": "https://api.github.com/repos/rust-lang/rust/commits/234f81c4a91f58abf44bed68d1ff446a6828b425", "html_url": "https://github.com/rust-lang/rust/commit/234f81c4a91f58abf44bed68d1ff446a6828b425"}], "stats": {"total": 275, "additions": 192, "deletions": 83}, "files": [{"sha": "546164c1492aa26892ec9212ea01e16d71ce2a9b", "filename": "COMPILER_TESTS.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/COMPILER_TESTS.md", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/COMPILER_TESTS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COMPILER_TESTS.md?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -1,6 +1,6 @@\n # Compiler Test Documentation\n \n-In the Rust project, we use a special set of comands imbedded in\n+In the Rust project, we use a special set of comands embedded in\n comments to test the Rust compiler. There are two groups of commands:\n \n 1. Header commands\n@@ -29,11 +29,11 @@ The error levels that you can have are:\n 3. `NOTE`\n 4. `HELP` and `SUGGESTION`*\n \n-\\* **Note**: `SUGGESTION` must follow emediatly after `HELP`.\n+\\* **Note**: `SUGGESTION` must follow immediately after `HELP`.\n \n ## Summary of Header Commands\n \n-Header commands specify something about the entire test file, as a\n+Header commands specify something about the entire test file as a\n whole, instead of just a few lines inside the test.\n \n * `ignore-X` where `X` is an architecture, OS or stage will ignore the test accordingly"}, {"sha": "baa7e77394a0da49f690c804860af26e528771e7", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -26,7 +26,7 @@\n #\n #   * check - Run the complete test suite\n #\n-#   * clean - Clean the build repertory. It is advised to run this\n+#   * clean - Clean the build repository. It is advised to run this\n #             command if you want to build Rust again, after an update\n #             of the git repository.\n #"}, {"sha": "18ce93ea06a64b038c952e0f856a886d5196a9b4", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -28,7 +28,7 @@ systems may want to jump around.\n     * [The `Result` type](#the-result-type)\n         * [Parsing integers](#parsing-integers)\n         * [The `Result` type alias idiom](#the-result-type-alias-idiom)\n-    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isnt-evil)\n+    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude:-unwrapping-isn't-evil)\n * [Working with multiple error types](#working-with-multiple-error-types)\n     * [Composing `Option` and `Result`](#composing-option-and-result)\n     * [The limits of combinators](#the-limits-of-combinators)\n@@ -41,11 +41,11 @@ systems may want to jump around.\n     * [The real `try!` macro](#the-real-try!-macro)\n     * [Composing custom error types](#composing-custom-error-types)\n     * [Advice for library writers](#advice-for-library-writers)\n-* [Case study: A program to read population data](#case-study-a-program-to-read-population-data)\n+* [Case study: A program to read population data](#case-study:-a-program-to-read-population-data)\n     * [Initial setup](#initial-setup)\n     * [Argument parsing](#argument-parsing)\n     * [Writing the logic](#writing-the-logic)\n-    * [Error handling with `Box<Error>`](#error-handling-with-box<error>)\n+    * [Error handling with `Box<Error>`](#error-handling-with-box%3Cerror%3E)\n     * [Reading from stdin](#reading-from-stdin)\n     * [Error handling with a custom type](#error-handling-with-a-custom-type)\n     * [Adding functionality](#adding-functionality)\n@@ -87,9 +87,9 @@ thread '<main>' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5\n Here's another example that is slightly less contrived. A program that accepts\n an integer as an argument, doubles it and prints it.\n \n-<div id=\"code-unwrap-double\">\n-```rust,should_panic\n+<a name=\"code-unwrap-double\"></a>\n \n+```rust,should_panic\n use std::env;\n \n fn main() {\n@@ -99,7 +99,6 @@ fn main() {\n     println!(\"{}\", 2 * n);\n }\n ```\n-</div>\n \n If you give this program zero arguments (error 1) or if the first argument\n isn't an integer (error 2), the program will panic just like in the first\n@@ -140,7 +139,8 @@ system is an important concept because it will cause the compiler to force the\n programmer to handle that absence. Let's take a look at an example that tries\n to find a character in a string:\n \n-<div id=\"code-option-ex-string-find\">\n+<a name=\"code-option-ex-string-find\"></a>\n+\n ```rust\n // Searches `haystack` for the Unicode character `needle`. If one is found, the\n // byte offset of the character is returned. Otherwise, `None` is returned.\n@@ -153,7 +153,6 @@ fn find(haystack: &str, needle: char) -> Option<usize> {\n     None\n }\n ```\n-</div>\n \n Notice that when this function finds a matching character, it doen't just\n return the `offset`. Instead, it returns `Some(offset)`. `Some` is a variant or\n@@ -187,6 +186,8 @@ But wait, what about `unwrap` used in [`unwrap-double`](#code-unwrap-double)?\n There was no case analysis there! Instead, the case analysis was put inside the\n `unwrap` method for you. You could define it yourself if you want:\n \n+<a name=\"code-option-def-unwrap\"></a>\n+\n ```rust\n enum Option<T> {\n     None,\n@@ -210,7 +211,7 @@ that makes `unwrap` ergonomic to use. Unfortunately, that `panic!` means that\n \n ### Composing `Option<T>` values\n \n-In [`option-ex-string-find`](#code-option-ex-string-find-2)\n+In [`option-ex-string-find`](#code-option-ex-string-find)\n we saw how to use `find` to discover the extension in a file name. Of course,\n not all file names have a `.` in them, so it's possible that the file name has\n no extension. This *possibility of absence* is encoded into the types using\n@@ -252,6 +253,8 @@ option is `None`, in which case, just return `None`.\n Rust has parametric polymorphism, so it is very easy to define a combinator\n that abstracts this pattern:\n \n+<a name=\"code-option-map\"></a>\n+\n ```rust\n fn map<F, T, A>(option: Option<T>, f: F) -> Option<A> where F: FnOnce(T) -> A {\n     match option {\n@@ -391,6 +394,8 @@ remove choices because they will panic if `Option<T>` is `None`.\n The `Result` type is also\n [defined in the standard library][6]:\n \n+<a name=\"code-result-def-1\"></a>\n+\n ```rust\n enum Result<T, E> {\n     Ok(T),\n@@ -667,6 +672,8 @@ with both an `Option` and a `Result`, the solution is *usually* to convert the\n (from `env::args()`) means the user didn't invoke the program correctly. We\n could just use a `String` to describe the error. Let's try:\n \n+<a name=\"code-error-double-string\"></a>\n+\n ```rust\n use std::env;\n \n@@ -899,6 +906,8 @@ seen above.\n \n Here is a simplified definition of a `try!` macro:\n \n+<a nama name=\"code-try-def-simple\"></a>\n+\n ```rust\n macro_rules! try {\n     ($e:expr) => (match $e {\n@@ -1159,6 +1168,8 @@ The `std::convert::From` trait is\n [defined in the standard\n library](../std/convert/trait.From.html):\n \n+<a name=\"code-from-def\"></a>\n+\n ```rust\n trait From<T> {\n     fn from(T) -> Self;\n@@ -1236,9 +1247,11 @@ macro_rules! try {\n }\n ```\n \n-This is not it's real definition. It's real definition is\n+This is not its real definition. Its real definition is\n [in the standard library](../std/macro.try!.html):\n \n+<a name=\"code-try-def\"></a>\n+\n ```rust\n macro_rules! try {\n     ($e:expr) => (match $e {\n@@ -1457,7 +1470,7 @@ representation. But certainly, this will vary depending on use cases.\n At a minimum, you should probably implement the\n [`Error`](../std/error/trait.Error.html)\n trait. This will give users of your library some minimum flexibility for\n-[composing errors](#the-real-try-macro). Implementing the `Error` trait also\n+[composing errors](#the-real-try!-macro). Implementing the `Error` trait also\n means that users are guaranteed the ability to obtain a string representation\n of an error (because it requires impls for both `fmt::Debug` and\n `fmt::Display`)."}, {"sha": "94280aa4a33173505c7abd7565bbd48259472437", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -147,7 +147,7 @@ a few tricks up their sleeves.\n \n For example, they\u2019re [immutable][immutable] by default. That\u2019s why our example\n uses `mut`: it makes a binding mutable, rather than immutable. `let` doesn\u2019t\n-take a name on the left hand side, it actually accepts a\n+take a name on the left hand side of the assignment, it actually accepts a\n \u2018[pattern][patterns]\u2019. We\u2019ll use patterns later. It\u2019s easy enough\n to use for now:\n "}, {"sha": "43e9cdd73c43349237e2d884fa80b0e9fe3b4206", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -464,40 +464,36 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n-                    self.bccx.span_err(\n-                        new_loan.span,\n-                        &format!(\"cannot borrow `{}`{} as mutable \\\n-                                more than once at a time\",\n-                                nl, new_loan_msg))\n+                    span_err!(self.bccx, new_loan.span, E0499,\n+                              \"cannot borrow `{}`{} as mutable \\\n+                               more than once at a time\",\n+                              nl, new_loan_msg);\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n-                    self.bccx.span_err(\n-                        new_loan.span,\n-                        &format!(\"closure requires unique access to `{}` \\\n-                                but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg));\n+                    span_err!(self.bccx, new_loan.span, E0500,\n+                              \"closure requires unique access to `{}` \\\n+                               but {} is already borrowed{}\",\n+                              nl, ol_pronoun, old_loan_msg);\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n-                    self.bccx.span_err(\n-                        new_loan.span,\n-                        &format!(\"cannot borrow `{}`{} as {} because \\\n-                                previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str()));\n+                    span_err!(self.bccx, new_loan.span, E0501,\n+                              \"cannot borrow `{}`{} as {} because \\\n+                               previous closure requires unique access\",\n+                              nl, new_loan_msg, new_loan.kind.to_user_str());\n                 }\n \n                 (_, _) => {\n-                    self.bccx.span_err(\n-                        new_loan.span,\n-                        &format!(\"cannot borrow `{}`{} as {} because \\\n-                                {} is also borrowed as {}{}\",\n-                                nl,\n-                                new_loan_msg,\n-                                new_loan.kind.to_user_str(),\n-                                ol_pronoun,\n-                                old_loan.kind.to_user_str(),\n-                                old_loan_msg));\n+                    span_err!(self.bccx, new_loan.span, E0502,\n+                              \"cannot borrow `{}`{} as {} because \\\n+                               {} is also borrowed as {}{}\",\n+                              nl,\n+                              new_loan_msg,\n+                              new_loan.kind.to_user_str(),\n+                              ol_pronoun,\n+                              old_loan.kind.to_user_str(),\n+                              old_loan_msg);\n                 }\n             }\n \n@@ -617,11 +613,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n-                self.bccx.span_err(\n-                    span,\n-                    &format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            &self.bccx.loan_path_to_string(copy_path))\n-                    );\n+                span_err!(self.bccx, span, E0503,\n+                          \"cannot use `{}` because it was mutably borrowed\",\n+                          &self.bccx.loan_path_to_string(copy_path));\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n@@ -642,18 +636,19 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         match self.analyze_restrictions_on_use(id, move_path, ty::MutBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n-                let err_message = match move_kind {\n+                match move_kind {\n                     move_data::Captured =>\n-                        format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                &self.bccx.loan_path_to_string(move_path)),\n+                        span_err!(self.bccx, span, E0504,\n+                                  \"cannot move `{}` into closure because it is borrowed\",\n+                                  &self.bccx.loan_path_to_string(move_path)),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n-                        format!(\"cannot move out of `{}` because it is borrowed\",\n-                                &self.bccx.loan_path_to_string(move_path))\n+                        span_err!(self.bccx, span, E0505,\n+                                  \"cannot move out of `{}` because it is borrowed\",\n+                                  &self.bccx.loan_path_to_string(move_path))\n                 };\n \n-                self.bccx.span_err(span, &err_message[..]);\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n@@ -820,10 +815,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    loan_path: &LoanPath<'tcx>,\n                                    loan: &Loan) {\n-        self.bccx.span_err(\n-            span,\n-            &format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path)));\n+        span_err!(self.bccx, span, E0506,\n+                  \"cannot assign to `{}` because it is borrowed\",\n+                  self.bccx.loan_path_to_string(loan_path));\n         self.bccx.span_note(\n             loan.span,\n             &format!(\"borrow of `{}` occurs here\","}, {"sha": "bbcf51933422ea41b9036e6a5b8215f1c7f2abd6", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -119,18 +119,18 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n         mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n         mc::cat_static_item => {\n-            bccx.span_err(move_from.span,\n-                          &format!(\"cannot move out of {}\",\n-                                  move_from.descriptive_string(bccx.tcx)));\n+            span_err!(bccx, move_from.span, E0507,\n+                      \"cannot move out of {}\",\n+                      move_from.descriptive_string(bccx.tcx));\n         }\n \n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n             let expr = bccx.tcx.map.expect_expr(move_from.id);\n             if let hir::ExprIndex(..) = expr.node {\n-                bccx.span_err(move_from.span,\n-                              &format!(\"cannot move out of type `{}`, \\\n-                                        a non-copy fixed-size array\",\n-                                       b.ty));\n+                span_err!(bccx, move_from.span, E0508,\n+                          \"cannot move out of type `{}`, \\\n+                           a non-copy fixed-size array\",\n+                          b.ty);\n             }\n         }\n \n@@ -139,11 +139,10 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             match b.ty.sty {\n                 ty::TyStruct(def, _) |\n                 ty::TyEnum(def, _) if def.has_dtor() => {\n-                    bccx.span_err(\n-                        move_from.span,\n-                        &format!(\"cannot move out of type `{}`, \\\n-                                 which defines the `Drop` trait\",\n-                                b.ty));\n+                    span_err!(bccx, move_from.span, E0509,\n+                              \"cannot move out of type `{}`, \\\n+                               which defines the `Drop` trait\",\n+                              b.ty);\n                 },\n                 _ => {\n                     bccx.span_bug(move_from.span, \"this path should not cause illegal move\")"}, {"sha": "4db7974f0944433e27d92fd636da71728acf1cb2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -803,6 +803,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(s, m);\n     }\n \n+    pub fn span_err_with_code(&self, s: Span, msg: &str, code: &str) {\n+        self.tcx.sess.span_err_with_code(s, msg, code);\n+    }\n+\n     pub fn span_bug(&self, s: Span, m: &str) {\n         self.tcx.sess.span_bug(s, m);\n     }"}, {"sha": "a5b313e2dd67ee90098f893ae341c0939c7c85be", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -263,12 +263,50 @@ fn mutable() {\n You can read more about cell types in the API documentation:\n \n https://doc.rust-lang.org/std/cell/\n-\"##\n+\"##,\n+\n+E0499: r##\"\n+A variable was borrowed as mutable more than once. Erroneous code example:\n+\n+```\n+let mut i = 0;\n+let mut x = &mut i;\n+let mut a = &mut i;\n+// error: cannot borrow `i` as mutable more than once at a time\n+```\n+\n+Please note that in rust, you can either have many immutable references, or one\n+mutable reference. Take a look at\n+https://doc.rust-lang.org/stable/book/references-and-borrowing.html for more\n+information. Example:\n+\n+\n+```\n+let mut i = 0;\n+let mut x = &mut i; // ok!\n+\n+// or:\n+let mut i = 0;\n+let a = &i; // ok!\n+let b = &i; // still ok!\n+let c = &i; // still ok!\n+```\n+\"##,\n \n }\n \n register_diagnostics! {\n     E0385, // {} in an aliasable location\n     E0388, // {} in a static location\n-    E0389  // {} in a `&` reference\n+    E0389, // {} in a `&` reference\n+    E0500, // closure requires unique access to `..` but .. is already borrowed\n+    E0501, // cannot borrow `..`.. as .. because previous closure requires unique access\n+    E0502, // cannot borrow `..`.. as .. because .. is also borrowed as ...\n+    E0503, // cannot use `..` because it was mutably borrowed\n+    E0504, // cannot move `..` into closure because it is borrowed\n+    E0505, // cannot move out of `..` because it is borrowed\n+    E0506, // cannot assign to `..` because it is borrowed\n+    E0507, // cannot move out of ..\n+    E0508, // cannot move out of type `..`, a non-copy fixed-size array\n+    E0509, // cannot move out of type `..`, which defines the `Drop` trait\n }"}, {"sha": "f1997054fa394e7cc0549806bdd57195e683cae0", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -542,7 +542,11 @@ fn link_binary_output(sess: &Session,\n         }\n     }\n \n-    let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n+    let tmpdir = match TempDir::new(\"rustc\") {\n+        Ok(tmpdir) => tmpdir,\n+        Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n+    };\n+\n     match crate_type {\n         config::CrateTypeRlib => {\n             link_rlib(sess, Some(trans), &objects, &out_filename,"}, {"sha": "dd7c3834e564a1dea6887213c656020dd4454b7e", "filename": "src/librustc_trans/diagnostics.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_long_diagnostics! {\n+\n+}\n+\n+register_diagnostics! {\n+    E0510, // invalid use of `return_address` intrinsic: function does not use out pointer\n+    E0511, // invalid monomorphization of `{}` intrinsic\n+    E0512, // transmute called on types with potentially different sizes...\n+}"}, {"sha": "049d8fbe390a44fe6827f7a9975e743265e21466", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -80,6 +80,8 @@ pub mod back {\n     pub mod msvc;\n }\n \n+pub mod diagnostics;\n+\n pub mod trans;\n pub mod save;\n "}, {"sha": "b43a4b3fc889d809c7364ab5b126aa08104f2299", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -44,6 +44,9 @@ use syntax::ast;\n use syntax::ptr::P;\n use syntax::parse::token;\n \n+use rustc::session::Session;\n+use syntax::codemap::Span;\n+\n use std::cmp::Ordering;\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &hir::ForeignItem) -> Option<ValueRef> {\n@@ -99,6 +102,10 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &hir::ForeignItem) -> Opti\n     Some(ccx.get_intrinsic(&name))\n }\n \n+pub fn span_transmute_size_error(a: &Session, b: Span, msg: &str) {\n+    span_err!(a, b, E0512, \"{}\", msg);\n+}\n+\n /// Performs late verification that intrinsics are used correctly. At present,\n /// the only intrinsic that needs such verification is `transmute`.\n pub fn check_intrinsics(ccx: &CrateContext) {\n@@ -127,8 +134,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n             last_failing_id = Some(transmute_restriction.id);\n \n             if transmute_restriction.original_from != transmute_restriction.substituted_from {\n-                ccx.sess().span_err(\n-                    transmute_restriction.span,\n+                span_transmute_size_error(ccx.sess(), transmute_restriction.span,\n                     &format!(\"transmute called on types with potentially different sizes: \\\n                               {} (could be {} bit{}) to {} (could be {} bit{})\",\n                              transmute_restriction.original_from,\n@@ -138,8 +144,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                              to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             } else {\n-                ccx.sess().span_err(\n-                    transmute_restriction.span,\n+                span_transmute_size_error(ccx.sess(), transmute_restriction.span,\n                     &format!(\"transmute called on types with different sizes: \\\n                               {} ({} bit{}) to {} ({} bit{})\",\n                              transmute_restriction.original_from,\n@@ -798,9 +803,9 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         (_, \"return_address\") => {\n             if !fcx.caller_expects_out_pointer {\n-                tcx.sess.span_err(call_info.span,\n-                                  \"invalid use of `return_address` intrinsic: function \\\n-                                   does not use out pointer\");\n+                span_err!(tcx.sess, call_info.span, E0510,\n+                          \"invalid use of `return_address` intrinsic: function \\\n+                           does not use out pointer\");\n                 C_null(Type::i8p(ccx))\n             } else {\n                 PointerCast(bcx, llvm::get_param(fcx.llfn, 0), Type::i8p(ccx))\n@@ -1439,6 +1444,10 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     return rust_try\n }\n \n+fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n+    span_err!(a, b, E0511, \"{}\", c);\n+}\n+\n fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     (bcx: Block<'blk, 'tcx>,\n      name: &str,\n@@ -1457,10 +1466,11 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n             emit_error!($msg, )\n         };\n         ($msg: tt, $($fmt: tt)*) => {\n-            bcx.sess().span_err(call_info.span,\n-                                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n-                                                 $msg),\n-                                         name, $($fmt)*));\n+            span_invalid_monomorphization_error(\n+                bcx.sess(), call_info.span,\n+                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n+                                 $msg),\n+                         name, $($fmt)*));\n         }\n     }\n     macro_rules! require {"}, {"sha": "5b0b19b95af197da09c7e058b070db216635bf9e", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -54,7 +54,8 @@\n     }\n \n     function browserSupportsHistoryApi() {\n-        return window.history && typeof window.history.pushState === \"function\";\n+        return document.location.protocol != \"file:\" &&\n+          window.history && typeof window.history.pushState === \"function\";\n     }\n \n     function highlightSourceLines(ev) {"}, {"sha": "a07d21add8db9c5fcb870d092f0c35a5f8383f69", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -68,6 +68,10 @@ macro_rules! panic {\n /// necessary to use `io::stdout().flush()` to ensure the output is emitted\n /// immediately.\n ///\n+/// # Panics\n+///\n+/// Panics if writing to `io::stdout()` fails.\n+///\n /// # Examples\n ///\n /// ```\n@@ -99,6 +103,10 @@ macro_rules! print {\n /// Use the `format!` syntax to write data to the standard output.\n /// See `std::fmt` for more information.\n ///\n+/// # Panics\n+///\n+/// Panics if writing to `io::stdout()` fails.\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "28502f67e0747255d1feba8577051e6b05db5196", "filename": "src/test/run-make/issue-14698/Makefile", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Ftest%2Frun-make%2Fissue-14698%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Ftest%2Frun-make%2Fissue-14698%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-14698%2FMakefile?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -0,0 +1,4 @@\n+-include ../tools.mk\n+\n+all:\n+\tTMP=fake TMPDIR=fake $(RUSTC) foo.rs 2>&1 | grep \"couldn't create a temp dir:\""}, {"sha": "7dc79f2043ba84fcfd20a4d9feaab2a0f674506a", "filename": "src/test/run-make/issue-14698/foo.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/837840c61fce44da78096110ff83c91099a83da7/src%2Ftest%2Frun-make%2Fissue-14698%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837840c61fce44da78096110ff83c91099a83da7/src%2Ftest%2Frun-make%2Fissue-14698%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-14698%2Ffoo.rs?ref=837840c61fce44da78096110ff83c91099a83da7", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {}"}]}