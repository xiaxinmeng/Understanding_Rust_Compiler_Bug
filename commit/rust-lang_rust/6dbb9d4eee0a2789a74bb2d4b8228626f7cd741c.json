{"sha": "6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYmI5ZDRlZWUwYTI3ODlhNzRiYjJkNGI4MjI4NjI2ZjdjZDc0MWM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-09-20T19:23:21Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-09-20T19:37:11Z"}, "message": "Don't use projection cache or candidate cache in intercrate mode\n\nFixes #88969\n\nIt appears that *just* disabling the evaluation cache (in #88994)\nleads to other issues involving intercrate mode caching. I suspect\nthat since we now always end up performing the full evaluation\nin intercrate mode, we end up 'polluting' the candidate and projection\ncaches with results that depend on being in intercrate mode in some way.\nPreviously, we might have hit a cached evaluation (stored during\nnon-intercrate mode), and skipped doing this extra work in\nintercrate mode.\n\nThe whole situation with intercrate mode caching is turning into\na mess. Ideally, we would remove intercrate mode entirely - however,\nthis might require waiting on Chalk.", "tree": {"sha": "63687381aa9574035a9b1012c5bd7189da233e19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63687381aa9574035a9b1012c5bd7189da233e19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmFI4ucACgkQtAh+UQ6Y\nsWT2KQ/9H+6MxQNjZcIz3GCWtuHvcZpbq/zDPdrTMADRoaS6d2LO4Hor53wgr8L4\nmkPBpQmt9nHdCzm+p36FNlOVCEDpI9RsCcoRQpcd3Nsv/PAp4oWV+DHyGGyiskpI\nXw/vESGmdVVoLvxDmhvGo8RvTLX1jQJmIG4bhl75YqyqpUhjV83Wot+7IWYn0lNX\nTKeZwDc5yXWIa+JYD9uwgMPMYhu86X6JY1RVJCPT5TSTAZqZNCR/5zIbAlp4K0Cq\nBhaDIUHLb0jskENQmfqpY3mC1PrL4Sndepm8dpQWinjsa4mSoEfvkhh+YEsW86eM\neaPIONf4+8dHDn5btBJZMMu0d4ofWHMOSxnwb53qjqHERW2JIbOCXYLfdkGbulmH\n6GWBDbDFMvVX9EurWvtuTOJa7b1D03VxnDvtL2QtOtyXs7xcj5vSRDi6l5WbSVOc\niJe6rAHEE9pYS/QDVFjlqKwp7cT0cQ+bEZeNTh79hf9OdXxSV+hpjkqa2MAKAM8T\niFryihqiEdSWJtCCw8I316pCpprmfb6XO8joUTRzTrCnRdQocqNtcLq7moeUJaJT\nsp8H+NFfGPSZU/4mWHu1Cck3gNmGSy2LxPYa9HRAnJ2SYEg5Em5FjCwIgr4JeRTj\n9u/FFrIj3bgqCN6aJ63PFzL0JClROAcbfK1u5loNPd0/GNB8fBs=\n=XTkQ\n-----END PGP SIGNATURE-----", "payload": "tree 63687381aa9574035a9b1012c5bd7189da233e19\nparent db1fb85cff63ad5fffe435e17128f99f9e1d970c\nauthor Aaron Hill <aa1ronham@gmail.com> 1632165801 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1632166631 -0500\n\nDon't use projection cache or candidate cache in intercrate mode\n\nFixes #88969\n\nIt appears that *just* disabling the evaluation cache (in #88994)\nleads to other issues involving intercrate mode caching. I suspect\nthat since we now always end up performing the full evaluation\nin intercrate mode, we end up 'polluting' the candidate and projection\ncaches with results that depend on being in intercrate mode in some way.\nPreviously, we might have hit a cached evaluation (stored during\nnon-intercrate mode), and skipped doing this extra work in\nintercrate mode.\n\nThe whole situation with intercrate mode caching is turning into\na mess. Ideally, we would remove intercrate mode entirely - however,\nthis might require waiting on Chalk.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c", "html_url": "https://github.com/rust-lang/rust/commit/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db1fb85cff63ad5fffe435e17128f99f9e1d970c", "url": "https://api.github.com/repos/rust-lang/rust/commits/db1fb85cff63ad5fffe435e17128f99f9e1d970c", "html_url": "https://github.com/rust-lang/rust/commit/db1fb85cff63ad5fffe435e17128f99f9e1d970c"}], "stats": {"total": 49, "additions": 43, "deletions": 6}, "files": [{"sha": "3b4d175a9a3e14ef64b5a68b8a94e6fac34873c4", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c", "patch": "@@ -844,6 +844,10 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     obligations: &mut Vec<PredicateObligation<'tcx>>,\n ) -> Result<Option<Ty<'tcx>>, InProgress> {\n     let infcx = selcx.infcx();\n+    // Don't use the projection cache in intercrate mode -\n+    // the `infcx` may be re-used between intercrate in non-intercrate\n+    // mode, which could lead to using incorrect cache results.\n+    let use_cache = !selcx.is_intercrate();\n \n     let projection_ty = infcx.resolve_vars_if_possible(projection_ty);\n     let cache_key = ProjectionCacheKey::new(projection_ty);\n@@ -856,7 +860,11 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     // bounds. It might be the case that we want two distinct caches,\n     // or else another kind of cache entry.\n \n-    let cache_result = infcx.inner.borrow_mut().projection_cache().try_start(cache_key);\n+    let cache_result = if use_cache {\n+        infcx.inner.borrow_mut().projection_cache().try_start(cache_key)\n+    } else {\n+        Ok(())\n+    };\n     match cache_result {\n         Ok(()) => debug!(\"no cache\"),\n         Err(ProjectionCacheEntry::Ambiguous) => {\n@@ -881,7 +889,9 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // should ensure that, unless this happens within a snapshot that's\n             // rolled back, fulfillment or evaluation will notice the cycle.\n \n-            infcx.inner.borrow_mut().projection_cache().recur(cache_key);\n+            if use_cache {\n+                infcx.inner.borrow_mut().projection_cache().recur(cache_key);\n+            }\n             return Err(InProgress);\n         }\n         Err(ProjectionCacheEntry::Recur) => {\n@@ -963,20 +973,26 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                         .map_or(false, |res| res.must_apply_considering_regions())\n             });\n \n-            infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n+            if use_cache {\n+                infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n+            }\n             obligations.extend(result.obligations);\n             Ok(Some(result.value))\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n             debug!(?projected_ty, \"opt_normalize_projection_type: no progress\");\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n-            infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n+            if use_cache {\n+                infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n+            }\n             // No need to extend `obligations`.\n             Ok(Some(result.value))\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n             debug!(\"opt_normalize_projection_type: too many candidates\");\n-            infcx.inner.borrow_mut().projection_cache().ambiguous(cache_key);\n+            if use_cache {\n+                infcx.inner.borrow_mut().projection_cache().ambiguous(cache_key);\n+            }\n             Ok(None)\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n@@ -986,7 +1002,9 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // Trait`, which when processed will cause the error to be\n             // reported later\n \n-            infcx.inner.borrow_mut().projection_cache().error(cache_key);\n+            if use_cache {\n+                infcx.inner.borrow_mut().projection_cache().error(cache_key);\n+            }\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n             Ok(Some(result.value))"}, {"sha": "50d6f82ae18fa0a6e9654aecdcebdbf1be3da4d3", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c", "patch": "@@ -314,6 +314,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    pub fn is_intercrate(&self) -> bool {\n+        self.intercrate\n+    }\n+\n     /// Returns `true` if the trait predicate is considerd `const` to this selection context.\n     pub fn is_trait_predicate_const(&self, pred: ty::TraitPredicate<'_>) -> bool {\n         match pred.constness {\n@@ -1197,6 +1201,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>> {\n+        // Neither the global nor local cache is aware of intercrate\n+        // mode, so don't do any caching. In particular, we might\n+        // re-use the same `InferCtxt` with both an intercrate\n+        // and non-intercrate `SelectionContext`\n+        if self.intercrate {\n+            return None;\n+        }\n         let tcx = self.tcx();\n         let pred = &cache_fresh_trait_pred.skip_binder();\n         let trait_ref = pred.trait_ref;\n@@ -1233,6 +1244,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &self,\n         result: &SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n     ) -> bool {\n+        // Neither the global nor local cache is aware of intercrate\n+        // mode, so don't do any caching. In particular, we might\n+        // re-use the same `InferCtxt` with both an intercrate\n+        // and non-intercrate `SelectionContext`\n+        if self.intercrate {\n+            return false;\n+        }\n         match result {\n             Ok(Some(SelectionCandidate::ParamCandidate(trait_ref))) => !trait_ref.needs_infer(),\n             _ => true,"}, {"sha": "9efb5dc75f4f0dc65b7c8538a78863f8c40c46e0", "filename": "src/test/ui/coherence/coherence-projection-conflict-orphan.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-projection-conflict-orphan.stderr?ref=6dbb9d4eee0a2789a74bb2d4b8228626f7cd741c", "patch": "@@ -8,6 +8,7 @@ LL | impl<A:Iterator> Foo<A::Item> for A { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `i32`\n    |\n    = note: upstream crates may add a new impl of trait `std::iter::Iterator` for type `i32` in future versions\n+   = note: upstream crates may add a new impl of trait `std::iter::Iterator` for type `i32` in future versions\n \n error: aborting due to previous error\n "}]}