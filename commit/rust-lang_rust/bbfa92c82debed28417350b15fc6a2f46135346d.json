{"sha": "bbfa92c82debed28417350b15fc6a2f46135346d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiZmE5MmM4MmRlYmVkMjg0MTczNTBiMTVmYzZhMmY0NjEzNTM0NmQ=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-12T22:39:49Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-13T21:38:27Z"}, "message": "Always handle EOVERFLOW by falling back to the generic copy loop\n\nPreviously EOVERFLOW handling was only applied for io::copy specialization\nbut not for fs::copy sharing the same code.\n\nAdditionally we lower the chunk size to 1GB since we have a user report\nthat older kernels may return EINVAL when passing 0x8000_0000\nbut smaller values succeed.", "tree": {"sha": "c055bcfb0611b728298a87057f99d497919a55bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c055bcfb0611b728298a87057f99d497919a55bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbfa92c82debed28417350b15fc6a2f46135346d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbfa92c82debed28417350b15fc6a2f46135346d", "html_url": "https://github.com/rust-lang/rust/commit/bbfa92c82debed28417350b15fc6a2f46135346d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbfa92c82debed28417350b15fc6a2f46135346d/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4854d418a5245b07eca7dbec92a29d18af13a821", "url": "https://api.github.com/repos/rust-lang/rust/commits/4854d418a5245b07eca7dbec92a29d18af13a821", "html_url": "https://github.com/rust-lang/rust/commit/4854d418a5245b07eca7dbec92a29d18af13a821"}], "stats": {"total": 20, "additions": 9, "deletions": 11}, "files": [{"sha": "15054fdad8412c327a7c7ddf883d445d036262a0", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bbfa92c82debed28417350b15fc6a2f46135346d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbfa92c82debed28417350b15fc6a2f46135346d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=bbfa92c82debed28417350b15fc6a2f46135346d", "patch": "@@ -1199,12 +1199,10 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n \n     match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {\n         CopyResult::Ended(result) => result,\n-        CopyResult::Fallback(written) => {\n-            // fallback is only > 0 on EOVERFLOW, which shouldn't happen\n-            // because the copy loop starts at a file offset 0 and countns down from `len`\n-            assert_eq!(0, written);\n-            io::copy::generic_copy(&mut reader, &mut writer)\n-        }\n+        CopyResult::Fallback(written) => match io::copy::generic_copy(&mut reader, &mut writer) {\n+            Ok(bytes) => Ok(bytes + written),\n+            Err(e) => Err(e),\n+        },\n     }\n }\n "}, {"sha": "ac2fcfcb53f72342af6f25f66f3bde14aaa2aec7", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bbfa92c82debed28417350b15fc6a2f46135346d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbfa92c82debed28417350b15fc6a2f46135346d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=bbfa92c82debed28417350b15fc6a2f46135346d", "patch": "@@ -438,7 +438,6 @@ pub(super) enum CopyResult {\n /// Callers must handle fallback to a generic copy loop.\n /// `Fallback` may indicate non-zero number of bytes already written\n /// if one of the files' cursor +`max_len` would exceed u64::MAX (`EOVERFLOW`).\n-/// If the initial file offset was 0 then `Fallback` will only contain `0`.\n pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n     use crate::cmp;\n \n@@ -462,10 +461,10 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n     while written < max_len {\n         let copy_result = if has_copy_file_range {\n             let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n-            // cap to 2GB chunks in case u64::MAX is passed in as file size and the file has a non-zero offset\n-            // this allows us to copy large chunks without hitting the limit,\n-            // unless someone sets a file offset close to u64::MAX - 2GB, in which case the fallback would kick in\n-            let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x8000_0000usize);\n+            // cap to 1GB chunks in case u64::MAX is passed as max_len and the file has a non-zero seek position\n+            // this allows us to copy large chunks without hitting EOVERFLOW,\n+            // unless someone sets a file offset close to u64::MAX - 1GB, in which case a fallback would be required\n+            let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x4000_0000usize);\n             let copy_result = unsafe {\n                 // We actually don't have to adjust the offsets,\n                 // because copy_file_range adjusts the file offset automatically\n@@ -560,6 +559,7 @@ fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) ->\n \n     let mut written = 0u64;\n     while written < len {\n+        // according to its manpage that's the maximum size sendfile() will copy per invocation\n         let chunk_size = crate::cmp::min(len - written, 0x7ffff000_u64) as usize;\n \n         let result = match mode {"}]}