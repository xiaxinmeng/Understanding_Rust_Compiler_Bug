{"sha": "7176dd1c9039d7d10c0ceb694b929d094cc299e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNzZkZDFjOTAzOWQ3ZDEwYzBjZWI2OTRiOTI5ZDA5NGNjMjk5ZTM=", "commit": {"author": {"name": "Barosl Lee", "email": "vcs@barosl.com", "date": "2014-12-08T09:16:09Z"}, "committer": {"name": "Barosl Lee", "email": "vcs@barosl.com", "date": "2014-12-08T09:19:13Z"}, "message": "libserialize: Prefer into_string() to to_string() wherever possible\n\nExcept for the example code!", "tree": {"sha": "f9a53326ad939c61e99e749a7962eed3b7e3f67a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9a53326ad939c61e99e749a7962eed3b7e3f67a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7176dd1c9039d7d10c0ceb694b929d094cc299e3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7176dd1c9039d7d10c0ceb694b929d094cc299e3", "html_url": "https://github.com/rust-lang/rust/commit/7176dd1c9039d7d10c0ceb694b929d094cc299e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7176dd1c9039d7d10c0ceb694b929d094cc299e3/comments", "author": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c32286d1b1f1494cf46fb6403e329e7bb6d31942", "url": "https://api.github.com/repos/rust-lang/rust/commits/c32286d1b1f1494cf46fb6403e329e7bb6d31942", "html_url": "https://github.com/rust-lang/rust/commit/c32286d1b1f1494cf46fb6403e329e7bb6d31942"}], "stats": {"total": 170, "additions": 85, "deletions": 85}, "files": [{"sha": "74fd2bcfbd901220e53ef1abb6151c0367cef128", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/7176dd1c9039d7d10c0ceb694b929d094cc299e3/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7176dd1c9039d7d10c0ceb694b929d094cc299e3/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7176dd1c9039d7d10c0ceb694b929d094cc299e3", "patch": "@@ -1947,7 +1947,7 @@ macro_rules! expect(\n     ($e:expr, Null) => ({\n         match $e {\n             Json::Null => Ok(()),\n-            other => Err(ExpectedError(\"Null\".to_string(),\n+            other => Err(ExpectedError(\"Null\".into_string(),\n                                        format!(\"{}\", other)))\n         }\n     });\n@@ -1968,20 +1968,20 @@ macro_rules! read_primitive {\n             match self.pop() {\n                 Json::I64(f) => match num::cast(f) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    None => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", f))),\n                 },\n                 Json::U64(f) => match num::cast(f) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    None => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", f))),\n                 },\n-                Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n+                Json::F64(f) => Err(ExpectedError(\"Integer\".into_string(), format!(\"{}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 Json::String(s) => match std::str::from_str(s.as_slice()) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), s)),\n+                    None => Err(ExpectedError(\"Number\".into_string(), s)),\n                 },\n-                value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value))),\n+                value => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", value))),\n             }\n         }\n     }\n@@ -2017,11 +2017,11 @@ impl ::Decoder<DecoderError> for Decoder {\n                 // is going to have a string here, as per JSON spec.\n                 match std::str::from_str(s.as_slice()) {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), s)),\n+                    None => Err(ExpectedError(\"Number\".into_string(), s)),\n                 }\n             },\n             Json::Null => Ok(f64::NAN),\n-            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n+            value => Err(ExpectedError(\"Number\".into_string(), format!(\"{}\", value)))\n         }\n     }\n \n@@ -2040,7 +2040,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".to_string(), format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".into_string(), format!(\"{}\", s)))\n     }\n \n     fn read_str(&mut self) -> DecodeResult<string::String> {\n@@ -2063,32 +2063,32 @@ impl ::Decoder<DecoderError> for Decoder {\n         let name = match self.pop() {\n             Json::String(s) => s,\n             Json::Object(mut o) => {\n-                let n = match o.remove(&\"variant\".to_string()) {\n+                let n = match o.remove(&\"variant\".into_string()) {\n                     Some(Json::String(s)) => s,\n                     Some(val) => {\n-                        return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"String\".into_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"variant\".to_string()))\n+                        return Err(MissingFieldError(\"variant\".into_string()))\n                     }\n                 };\n-                match o.remove(&\"fields\".to_string()) {\n+                match o.remove(&\"fields\".into_string()) {\n                     Some(Json::Array(l)) => {\n                         for field in l.into_iter().rev() {\n                             self.stack.push(field);\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"Array\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"Array\".into_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"fields\".to_string()))\n+                        return Err(MissingFieldError(\"fields\".into_string()))\n                     }\n                 }\n                 n\n             }\n             json => {\n-                return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n+                return Err(ExpectedError(\"String or Object\".into_string(), format!(\"{}\", json)))\n             }\n         };\n         let idx = match names.iter()\n@@ -2437,9 +2437,9 @@ mod tests {\n     #[test]\n     fn test_decode_option_malformed() {\n         check_err::<OptionData>(\"{ \\\"opt\\\": [] }\",\n-                                ExpectedError(\"Number\".to_string(), \"[]\".to_string()));\n+                                ExpectedError(\"Number\".into_string(), \"[]\".into_string()));\n         check_err::<OptionData>(\"{ \\\"opt\\\": false }\",\n-                                ExpectedError(\"Number\".to_string(), \"false\".to_string()));\n+                                ExpectedError(\"Number\".into_string(), \"false\".into_string()));\n     }\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n@@ -2525,11 +2525,11 @@ mod tests {\n \n     #[test]\n     fn test_write_str() {\n-        assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n-        assert_eq!(String(\"\".to_string()).to_pretty_str(), \"\\\"\\\"\");\n+        assert_eq!(String(\"\".into_string()).to_string(), \"\\\"\\\"\");\n+        assert_eq!(String(\"\".into_string()).to_pretty_str(), \"\\\"\\\"\");\n \n-        assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n-        assert_eq!(String(\"madoka\".to_string()).to_pretty_str(), \"\\\"madoka\\\"\");\n+        assert_eq!(String(\"homura\".into_string()).to_string(), \"\\\"homura\\\"\");\n+        assert_eq!(String(\"madoka\".into_string()).to_pretty_str(), \"\\\"madoka\\\"\");\n     }\n \n     #[test]\n@@ -2558,7 +2558,7 @@ mod tests {\n         let long_test_array = Array(vec![\n             Boolean(false),\n             Null,\n-            Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n+            Array(vec![String(\"foo\\nbar\".into_string()), F64(3.5)])]);\n \n         assert_eq!(long_test_array.to_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n@@ -2583,22 +2583,22 @@ mod tests {\n \n         assert_eq!(\n             mk_object(&[\n-                (\"a\".to_string(), Boolean(true))\n+                (\"a\".into_string(), Boolean(true))\n             ]).to_string(),\n             \"{\\\"a\\\":true}\"\n         );\n         assert_eq!(\n-            mk_object(&[(\"a\".to_string(), Boolean(true))]).to_pretty_str(),\n+            mk_object(&[(\"a\".into_string(), Boolean(true))]).to_pretty_str(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n             }\"\n         );\n \n         let complex_obj = mk_object(&[\n-                (\"b\".to_string(), Array(vec![\n-                    mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                    mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n+                (\"b\".into_string(), Array(vec![\n+                    mk_object(&[(\"c\".into_string(), String(\"\\x0c\\r\".into_string()))]),\n+                    mk_object(&[(\"d\".into_string(), String(\"\".into_string()))])\n                 ]))\n             ]);\n \n@@ -2627,10 +2627,10 @@ mod tests {\n         );\n \n         let a = mk_object(&[\n-            (\"a\".to_string(), Boolean(true)),\n-            (\"b\".to_string(), Array(vec![\n-                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n+            (\"a\".into_string(), Boolean(true)),\n+            (\"b\".into_string(), Array(vec![\n+                mk_object(&[(\"c\".into_string(), String(\"\\x0c\\r\".into_string()))]),\n+                mk_object(&[(\"d\".into_string(), String(\"\".into_string()))])\n             ]))\n         ]);\n \n@@ -2667,7 +2667,7 @@ mod tests {\n             \"\\\"Dog\\\"\"\n         );\n \n-        let animal = Frog(\"Henry\".to_string(), 349);\n+        let animal = Frog(\"Henry\".into_string(), 349);\n         assert_eq!(\n             with_str_writer(|writer| {\n                 let mut encoder = Encoder::new(writer);\n@@ -2692,14 +2692,14 @@ mod tests {\n \n     #[test]\n     fn test_write_some() {\n-        let value = Some(\"jodhpurs\".to_string());\n+        let value = Some(\"jodhpurs\".into_string());\n         let s = with_str_writer(|writer| {\n             let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, \"\\\"jodhpurs\\\"\");\n \n-        let value = Some(\"jodhpurs\".to_string());\n+        let value = Some(\"jodhpurs\".into_string());\n         let s = with_str_writer(|writer| {\n             let mut encoder = PrettyEncoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n@@ -2834,16 +2834,16 @@ mod tests {\n         assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n         assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n \n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_string())));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_string())));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_string())));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_string())));\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".into_string())));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".into_string())));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".into_string())));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".into_string())));\n     }\n \n     #[test]\n@@ -2909,7 +2909,7 @@ mod tests {\n         assert_eq!(t, (1u, 2, 3))\n \n         let t: (uint, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n-        assert_eq!(t, (1u, \"two\".to_string()));\n+        assert_eq!(t, (1u, \"two\".into_string()));\n     }\n \n     #[test]\n@@ -2939,22 +2939,22 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object(&[(\"a\".to_string(), U64(3))]));\n+                  mk_object(&[(\"a\".into_string(), U64(3))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".to_string(), Null),\n-                      (\"b\".to_string(), Boolean(true))]));\n+                      (\"a\".into_string(), Null),\n+                      (\"b\".into_string(), Boolean(true))]));\n         assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".to_string(), Null),\n-                      (\"b\".to_string(), Boolean(true))]));\n+                      (\"a\".into_string(), Null),\n+                      (\"b\".into_string(), Boolean(true))]));\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), Array(vec![Boolean(true)]))\n+                      (\"a\".into_string(), F64(1.0)),\n+                      (\"b\".into_string(), Array(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n                       \"{\\\n@@ -2966,12 +2966,12 @@ mod tests {\n                           ]\\\n                       }\").unwrap(),\n                   mk_object(&[\n-                      (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), Array(vec![\n+                      (\"a\".into_string(), F64(1.0)),\n+                      (\"b\".into_string(), Array(vec![\n                           Boolean(true),\n-                          String(\"foo\\nbar\".to_string()),\n+                          String(\"foo\\nbar\".into_string()),\n                           mk_object(&[\n-                              (\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))\n+                              (\"c\".into_string(), mk_object(&[(\"d\".into_string(), Null)]))\n                           ])\n                       ]))\n                   ]));\n@@ -2990,7 +2990,7 @@ mod tests {\n             v,\n             Outer {\n                 inner: vec![\n-                    Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n+                    Inner { a: (), b: 2, c: vec![\"abc\".into_string(), \"xyz\".into_string()] }\n                 ]\n             }\n         );\n@@ -3016,7 +3016,7 @@ mod tests {\n         assert_eq!(value, None);\n \n         let value: Option<string::String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n-        assert_eq!(value, Some(\"jodhpurs\".to_string()));\n+        assert_eq!(value, Some(\"jodhpurs\".into_string()));\n     }\n \n     #[test]\n@@ -3026,7 +3026,7 @@ mod tests {\n \n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n         let value: Animal = super::decode(s).unwrap();\n-        assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n+        assert_eq!(value, Frog(\"Henry\".into_string(), 349));\n     }\n \n     #[test]\n@@ -3035,8 +3035,8 @@ mod tests {\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut map: TreeMap<string::String, Animal> = super::decode(s).unwrap();\n \n-        assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n-        assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n+        assert_eq!(map.remove(&\"a\".into_string()), Some(Dog));\n+        assert_eq!(map.remove(&\"b\".into_string()), Some(Frog(\"Henry\".into_string(), 349)));\n     }\n \n     #[test]\n@@ -3076,30 +3076,30 @@ mod tests {\n     }\n     #[test]\n     fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n+        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".into_string(), \"[]\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Number\".to_string(), \"true\".to_string()));\n+                                  ExpectedError(\"Number\".into_string(), \"true\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Boolean\".to_string(), \"[]\".to_string()));\n+                                  ExpectedError(\"Boolean\".into_string(), \"[]\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n+                                  ExpectedError(\"String\".into_string(), \"{}\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n+                                  ExpectedError(\"Array\".into_string(), \"null\".into_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  MissingFieldError(\"w\".to_string()));\n+                                  MissingFieldError(\"w\".into_string()));\n     }\n     #[test]\n     fn test_decode_errors_enum() {\n         check_err::<DecodeEnum>(\"{}\",\n-                                MissingFieldError(\"variant\".to_string()));\n+                                MissingFieldError(\"variant\".into_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                ExpectedError(\"String\".to_string(), \"1\".to_string()));\n+                                ExpectedError(\"String\".into_string(), \"1\".into_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                MissingFieldError(\"fields\".to_string()));\n+                                MissingFieldError(\"fields\".into_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n+                                ExpectedError(\"Array\".into_string(), \"null\".into_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                UnknownVariantError(\"C\".to_string()));\n+                                UnknownVariantError(\"C\".into_string()));\n     }\n \n     #[test]\n@@ -3384,7 +3384,7 @@ mod tests {\n         };\n         let mut decoder = Decoder::new(json_obj);\n         let result: Result<HashMap<uint, bool>, DecoderError> = Decodable::decode(&mut decoder);\n-        assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n+        assert_eq!(result, Err(ExpectedError(\"Number\".into_string(), \"a\".into_string())));\n     }\n \n     fn assert_stream_equal(src: &str,\n@@ -3411,7 +3411,7 @@ mod tests {\n             r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n             vec![\n                 (ObjectStart,             vec![]),\n-                  (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n+                  (StringValue(\"bar\".into_string()),   vec![Key(\"foo\")]),\n                   (ArrayStart,            vec![Key(\"array\")]),\n                     (U64Value(0),         vec![Key(\"array\"), Index(0)]),\n                     (U64Value(1),         vec![Key(\"array\"), Index(1)]),\n@@ -3502,7 +3502,7 @@ mod tests {\n                   (F64Value(1.0),               vec![Key(\"a\")]),\n                   (ArrayStart,                  vec![Key(\"b\")]),\n                     (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n+                    (StringValue(\"foo\\nbar\".into_string()),  vec![Key(\"b\"), Index(1)]),\n                     (ObjectStart,               vec![Key(\"b\"), Index(2)]),\n                       (ObjectStart,             vec![Key(\"b\"), Index(2), Key(\"c\")]),\n                         (NullValue,             vec![Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n@@ -3635,7 +3635,7 @@ mod tests {\n         assert!(stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n \n-        stack.push_key(\"foo\".to_string());\n+        stack.push_key(\"foo\".into_string());\n \n         assert!(stack.len() == 2);\n         assert!(stack.is_equal_to(&[Index(1), Key(\"foo\")]));\n@@ -3647,7 +3647,7 @@ mod tests {\n         assert!(stack.get(0) == Index(1));\n         assert!(stack.get(1) == Key(\"foo\"));\n \n-        stack.push_key(\"bar\".to_string());\n+        stack.push_key(\"bar\".into_string());\n \n         assert!(stack.len() == 3);\n         assert!(stack.is_equal_to(&[Index(1), Key(\"foo\"), Key(\"bar\")]));\n@@ -3684,8 +3684,8 @@ mod tests {\n         let array3 = Array(vec!(U64(1), U64(2), U64(3)));\n         let object = {\n             let mut tree_map = TreeMap::new();\n-            tree_map.insert(\"a\".to_string(), U64(1));\n-            tree_map.insert(\"b\".to_string(), U64(2));\n+            tree_map.insert(\"a\".into_string(), U64(1));\n+            tree_map.insert(\"b\".into_string(), U64(2));\n             Object(tree_map)\n         };\n \n@@ -3717,12 +3717,12 @@ mod tests {\n         assert_eq!((vec![1u, 2]).to_json(), array2);\n         assert_eq!(vec!(1u, 2, 3).to_json(), array3);\n         let mut tree_map = TreeMap::new();\n-        tree_map.insert(\"a\".to_string(), 1u);\n-        tree_map.insert(\"b\".to_string(), 2);\n+        tree_map.insert(\"a\".into_string(), 1u);\n+        tree_map.insert(\"b\".into_string(), 2);\n         assert_eq!(tree_map.to_json(), object);\n         let mut hash_map = HashMap::new();\n-        hash_map.insert(\"a\".to_string(), 1u);\n-        hash_map.insert(\"b\".to_string(), 2);\n+        hash_map.insert(\"a\".into_string(), 1u);\n+        hash_map.insert(\"b\".into_string(), 2);\n         assert_eq!(hash_map.to_json(), object);\n         assert_eq!(Some(15i).to_json(), I64(15));\n         assert_eq!(Some(15u).to_json(), U64(15));\n@@ -3765,7 +3765,7 @@ mod tests {\n     }\n \n     fn big_json() -> string::String {\n-        let mut src = \"[\\n\".to_string();\n+        let mut src = \"[\\n\".into_string();\n         for _ in range(0i, 500) {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n                             [1,2,3]},\"#);"}]}