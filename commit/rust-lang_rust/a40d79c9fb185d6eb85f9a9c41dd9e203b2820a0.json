{"sha": "a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MGQ3OWM5ZmIxODVkNmViODVmOWE5YzQxZGQ5ZTIwM2IyODIwYTA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-09-23T12:54:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-23T12:54:06Z"}, "message": "Rollup merge of #76993 - blitzerr:alloc-ref, r=Amanieu\n\nChanging the alloc() to accept &self instead of &mut self\n\nFixes: [#55](https://github.com/rust-lang/wg-allocators/issues/55)\n\nThis is the first cut. It only makes the change for `alloc` method.", "tree": {"sha": "3ed9f65f247c11f72232caf6d861ae90336ddbd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ed9f65f247c11f72232caf6d861ae90336ddbd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfa0VuCRBK7hj4Ov3rIwAAdHIIAC/fwxUKaLVWgc3Hh7kLOFD9\nkxbJx/LPWuBg0ekdmtqNTGso9Q48zLyiVWJnlu9xsUQm8Fyqnp25acTqBc0DQTZw\nFyHe0p2ZTuXYx4Dz7WjFXULLpaaHwdzccoVQ1kZnrEM2FUM0PWv2Phc1KSKPMt0O\n5aThVknb6DMIKNaDnFL//OkD2Q0MUo8ASJzoa08+dj+HR8AXhQgnwgPGU6k52xkS\nN12dlSgyKJXV1+GdN7vssIR3qyJLRTZspDZLkOH34k/CW0/NLpUuCvKtjonSLfYj\n40HBWImoqRrYe4A8WwKvN7mfDbYnNrz4Y+7bdaAlIw3E9VQB/p79El+uvaJ0jRA=\n=ADU0\n-----END PGP SIGNATURE-----\n", "payload": "tree 3ed9f65f247c11f72232caf6d861ae90336ddbd8\nparent eaaf5d7e38b1ee2306cac1ccbcbf3b18bdc6235c\nparent 2b19b14cecbcdd173e29a801baff71e31cae7331\nauthor Dylan DPC <dylan.dpc@gmail.com> 1600865646 +0200\ncommitter GitHub <noreply@github.com> 1600865646 +0200\n\nRollup merge of #76993 - blitzerr:alloc-ref, r=Amanieu\n\nChanging the alloc() to accept &self instead of &mut self\n\nFixes: [#55](https://github.com/rust-lang/wg-allocators/issues/55)\n\nThis is the first cut. It only makes the change for `alloc` method.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "html_url": "https://github.com/rust-lang/rust/commit/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaaf5d7e38b1ee2306cac1ccbcbf3b18bdc6235c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaaf5d7e38b1ee2306cac1ccbcbf3b18bdc6235c", "html_url": "https://github.com/rust-lang/rust/commit/eaaf5d7e38b1ee2306cac1ccbcbf3b18bdc6235c"}, {"sha": "2b19b14cecbcdd173e29a801baff71e31cae7331", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b19b14cecbcdd173e29a801baff71e31cae7331", "html_url": "https://github.com/rust-lang/rust/commit/2b19b14cecbcdd173e29a801baff71e31cae7331"}], "stats": {"total": 94, "additions": 48, "deletions": 46}, "files": [{"sha": "8b8cdbf252555089b8e1f0db64b367afa1d2240f", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "patch": "@@ -145,7 +145,7 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n \n impl Global {\n     #[inline]\n-    fn alloc_impl(&mut self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n         match layout.size() {\n             0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n             // SAFETY: `layout` is non-zero in size,\n@@ -160,7 +160,7 @@ impl Global {\n     // SAFETY: Same as `AllocRef::grow`\n     #[inline]\n     unsafe fn grow_impl(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -208,17 +208,17 @@ impl Global {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         self.alloc_impl(layout, true)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n             // SAFETY: `layout` is non-zero in size,\n             // other conditions must be upheld by the caller\n@@ -228,7 +228,7 @@ unsafe impl AllocRef for Global {\n \n     #[inline]\n     unsafe fn grow(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -239,7 +239,7 @@ unsafe impl AllocRef for Global {\n \n     #[inline]\n     unsafe fn grow_zeroed(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -250,7 +250,7 @@ unsafe impl AllocRef for Global {\n \n     #[inline]\n     unsafe fn shrink(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,"}, {"sha": "1844d3ae004f4dbbbbad92543d19367a8da1ad39", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "patch": "@@ -170,7 +170,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         Self::allocate_in(capacity, AllocInit::Zeroed, alloc)\n     }\n \n-    fn allocate_in(capacity: usize, init: AllocInit, mut alloc: A) -> Self {\n+    fn allocate_in(capacity: usize, init: AllocInit, alloc: A) -> Self {\n         if mem::size_of::<T>() == 0 {\n             Self::new_in(alloc)\n         } else {"}, {"sha": "e4c8b3709dfeeb9809d998747a40625579ba1038", "filename": "library/alloc/src/raw_vec/tests.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs?ref=a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use std::cell::Cell;\n \n #[test]\n fn allocator_param() {\n@@ -17,32 +18,32 @@ fn allocator_param() {\n     // A dumb allocator that consumes a fixed amount of fuel\n     // before allocation attempts start failing.\n     struct BoundedAlloc {\n-        fuel: usize,\n+        fuel: Cell<usize>,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n             let size = layout.size();\n-            if size > self.fuel {\n+            if size > self.fuel.get() {\n                 return Err(AllocErr);\n             }\n             match Global.alloc(layout) {\n                 ok @ Ok(_) => {\n-                    self.fuel -= size;\n+                    self.fuel.set(self.fuel.get() - size);\n                     ok\n                 }\n                 err @ Err(_) => err,\n             }\n         }\n-        unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n             unsafe { Global.dealloc(ptr, layout) }\n         }\n     }\n \n-    let a = BoundedAlloc { fuel: 500 };\n+    let a = BoundedAlloc { fuel: Cell::new(500) };\n     let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n-    assert_eq!(v.alloc.fuel, 450);\n+    assert_eq!(v.alloc.fuel.get(), 450);\n     v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n-    assert_eq!(v.alloc.fuel, 250);\n+    assert_eq!(v.alloc.fuel.get(), 250);\n }\n \n #[test]"}, {"sha": "a7239a4b14fae82bf92be0ae533f98ccc148bd79", "filename": "library/alloc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Falloc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Falloc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fheap.rs?ref=a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "patch": "@@ -11,7 +11,7 @@ fn std_heap_overaligned_request() {\n     check_overalign_requests(Global)\n }\n \n-fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n+fn check_overalign_requests<T: AllocRef>(allocator: T) {\n     for &align in &[4, 8, 16, 32] {\n         // less than and bigger than `MIN_ALIGN`\n         for &size in &[align / 2, align - 1] {"}, {"sha": "f9eb8981bbfc24d1a8dafeb52803d4b391edec3c", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "patch": "@@ -109,7 +109,7 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr>;\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr>;\n \n     /// Behaves like `alloc`, but also ensures that the returned memory is zero-initialized.\n     ///\n@@ -126,7 +126,7 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         let ptr = self.alloc(layout)?;\n         // SAFETY: `alloc` returns a valid memory block\n         unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }\n@@ -142,7 +142,7 @@ pub unsafe trait AllocRef {\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n+    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout);\n \n     /// Attempts to extend the memory block.\n     ///\n@@ -183,7 +183,7 @@ pub unsafe trait AllocRef {\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn grow(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -244,7 +244,7 @@ pub unsafe trait AllocRef {\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn grow_zeroed(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -308,7 +308,7 @@ pub unsafe trait AllocRef {\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn shrink(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -337,35 +337,35 @@ pub unsafe trait AllocRef {\n     ///\n     /// The returned adaptor also implements `AllocRef` and will simply borrow this.\n     #[inline(always)]\n-    fn by_ref(&mut self) -> &mut Self {\n+    fn by_ref(&mut self) -> &Self {\n         self\n     }\n }\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl<A> AllocRef for &mut A\n+unsafe impl<A> AllocRef for &A\n where\n     A: AllocRef + ?Sized,\n {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         (**self).alloc(layout)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         (**self).alloc_zeroed(layout)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n         // SAFETY: the safety contract must be upheld by the caller\n         unsafe { (**self).dealloc(ptr, layout) }\n     }\n \n     #[inline]\n     unsafe fn grow(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -376,7 +376,7 @@ where\n \n     #[inline]\n     unsafe fn grow_zeroed(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -387,7 +387,7 @@ where\n \n     #[inline]\n     unsafe fn shrink(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,"}, {"sha": "ba158511f64c085eae97538d255f77bebc398c95", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "patch": "@@ -133,7 +133,7 @@ pub struct System;\n \n impl System {\n     #[inline]\n-    fn alloc_impl(&mut self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocErr> {\n         match layout.size() {\n             0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n             // SAFETY: `layout` is non-zero in size,\n@@ -152,7 +152,7 @@ impl System {\n     // SAFETY: Same as `AllocRef::grow`\n     #[inline]\n     unsafe fn grow_impl(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -190,7 +190,7 @@ impl System {\n             old_size => unsafe {\n                 let new_ptr = self.alloc_impl(new_layout, zeroed)?;\n                 ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_size);\n-                self.dealloc(ptr, old_layout);\n+                AllocRef::dealloc(&self, ptr, old_layout);\n                 Ok(new_ptr)\n             },\n         }\n@@ -202,17 +202,17 @@ impl System {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         self.alloc_impl(layout, false)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+    fn alloc_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         self.alloc_impl(layout, true)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n             // SAFETY: `layout` is non-zero in size,\n             // other conditions must be upheld by the caller\n@@ -222,7 +222,7 @@ unsafe impl AllocRef for System {\n \n     #[inline]\n     unsafe fn grow(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -233,7 +233,7 @@ unsafe impl AllocRef for System {\n \n     #[inline]\n     unsafe fn grow_zeroed(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -244,7 +244,7 @@ unsafe impl AllocRef for System {\n \n     #[inline]\n     unsafe fn shrink(\n-        &mut self,\n+        &self,\n         ptr: NonNull<u8>,\n         old_layout: Layout,\n         new_layout: Layout,\n@@ -257,7 +257,7 @@ unsafe impl AllocRef for System {\n         match new_layout.size() {\n             // SAFETY: conditions must be upheld by the caller\n             0 => unsafe {\n-                self.dealloc(ptr, old_layout);\n+                AllocRef::dealloc(&self, ptr, old_layout);\n                 Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))\n             },\n \n@@ -277,9 +277,9 @@ unsafe impl AllocRef for System {\n             // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n             // for `dealloc` must be upheld by the caller.\n             new_size => unsafe {\n-                let new_ptr = self.alloc(new_layout)?;\n+                let new_ptr = AllocRef::alloc(&self, new_layout)?;\n                 ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);\n-                self.dealloc(ptr, old_layout);\n+                AllocRef::dealloc(&self, ptr, old_layout);\n                 Ok(new_ptr)\n             },\n         }"}, {"sha": "dfb5d3e9e38d0fb40cd49abd79cf1d32df56d6ce", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=a40d79c9fb185d6eb85f9a9c41dd9e203b2820a0", "patch": "@@ -10,6 +10,7 @@ extern crate helper;\n \n use std::alloc::{self, AllocRef, Global, Layout, System};\n use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::ptr::NonNull;\n \n static HITS: AtomicUsize = AtomicUsize::new(0);\n \n@@ -18,12 +19,12 @@ struct A;\n unsafe impl alloc::GlobalAlloc for A {\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n         HITS.fetch_add(1, Ordering::SeqCst);\n-        System.alloc(layout)\n+        alloc::GlobalAlloc::alloc(&System, layout)\n     }\n \n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         HITS.fetch_add(1, Ordering::SeqCst);\n-        System.dealloc(ptr, layout)\n+        AllocRef::dealloc(&System, NonNull::new(ptr).unwrap(), layout)\n     }\n }\n "}]}