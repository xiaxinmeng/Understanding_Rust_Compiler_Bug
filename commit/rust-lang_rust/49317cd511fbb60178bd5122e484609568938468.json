{"sha": "49317cd511fbb60178bd5122e484609568938468", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MzE3Y2Q1MTFmYmI2MDE3OGJkNTEyMmU0ODQ2MDk1Njg5Mzg0Njg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-16T16:07:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-16T16:07:10Z"}, "message": "Auto merge of #49130 - smmalis37:range, r=alexcrichton\n\nMove Range*::contains to a single default impl on RangeBounds\n\nPer the ongoing discussion in #32311.\n\nThis is my first PR to Rust (woo!), so I don't know if this requires an amendment to the original range_contains RFC, or not, or if we can just do a psuedo-RFC here. While this may no longer follow the explicit decision made in that RFC, I believe this better follows its spirit by adding the new contains method to all Ranges. It also allows users to be generic over all ranges and use this method without writing it themselves (my personal desired use case).\n\nThis also somewhat answers the unanswered question about Wrapping ranges in the above issue by instead just punting it to the question of what those types should return for start() & end(), or if they should implement RangeArgument at all. Those types could also implement their own contains method without implementing this trait, in which case the question remains the same.\n\nThis does add a new contains method to types that already implemented RangeArgument but not contains. These types are RangeFull, (Bound<T>, Bound<T>), (Bound<&'a T>, Bound<&'a T>). No tests have been added for these types yet. No inherent method has been added either.\n\nr? @alexcrichton", "tree": {"sha": "8d89911dcf8d9baed771133f3382d8f471d9b800", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d89911dcf8d9baed771133f3382d8f471d9b800"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49317cd511fbb60178bd5122e484609568938468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49317cd511fbb60178bd5122e484609568938468", "html_url": "https://github.com/rust-lang/rust/commit/49317cd511fbb60178bd5122e484609568938468", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49317cd511fbb60178bd5122e484609568938468/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ef1563518d48ad9231b3ec3ac463d34d819ed28", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef1563518d48ad9231b3ec3ac463d34d819ed28", "html_url": "https://github.com/rust-lang/rust/commit/1ef1563518d48ad9231b3ec3ac463d34d819ed28"}, {"sha": "51f24ec7f01b6a636750baff5ab5a12ec6bfe6cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/51f24ec7f01b6a636750baff5ab5a12ec6bfe6cd", "html_url": "https://github.com/rust-lang/rust/commit/51f24ec7f01b6a636750baff5ab5a12ec6bfe6cd"}], "stats": {"total": 169, "additions": 129, "deletions": 40}, "files": [{"sha": "6f3e3b508853ba7c3172824222bd86a0ba6dfcb2", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 123, "deletions": 34, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/49317cd511fbb60178bd5122e484609568938468/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49317cd511fbb60178bd5122e484609568938468/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=49317cd511fbb60178bd5122e484609568938468", "patch": "@@ -100,17 +100,28 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// ```\n     /// #![feature(range_contains)]\n     ///\n-    /// assert!(!(3..5).contains(2));\n-    /// assert!( (3..5).contains(3));\n-    /// assert!( (3..5).contains(4));\n-    /// assert!(!(3..5).contains(5));\n+    /// use std::f32;\n     ///\n-    /// assert!(!(3..3).contains(3));\n-    /// assert!(!(3..2).contains(3));\n+    /// assert!(!(3..5).contains(&2));\n+    /// assert!( (3..5).contains(&3));\n+    /// assert!( (3..5).contains(&4));\n+    /// assert!(!(3..5).contains(&5));\n+    ///\n+    /// assert!(!(3..3).contains(&3));\n+    /// assert!(!(3..2).contains(&3));\n+    ///\n+    /// assert!( (0.0..1.0).contains(&0.5));\n+    /// assert!(!(0.0..1.0).contains(&f32::NAN));\n+    /// assert!(!(0.0..f32::NAN).contains(&0.5));\n+    /// assert!(!(f32::NAN..1.0).contains(&0.5));\n     /// ```\n     #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (self.start <= item) && (item < self.end)\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n \n     /// Returns `true` if the range contains no items.\n@@ -179,7 +190,6 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -188,12 +198,23 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// ```\n     /// #![feature(range_contains)]\n     ///\n-    /// assert!(!(3..).contains(2));\n-    /// assert!( (3..).contains(3));\n-    /// assert!( (3..).contains(1_000_000_000));\n+    /// use std::f32;\n+    ///\n+    /// assert!(!(3..).contains(&2));\n+    /// assert!( (3..).contains(&3));\n+    /// assert!( (3..).contains(&1_000_000_000));\n+    ///\n+    /// assert!( (0.0..).contains(&0.5));\n+    /// assert!(!(0.0..).contains(&f32::NAN));\n+    /// assert!(!(f32::NAN..).contains(&0.5));\n     /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (self.start <= item)\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n }\n \n@@ -250,7 +271,6 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -259,12 +279,23 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// ```\n     /// #![feature(range_contains)]\n     ///\n-    /// assert!( (..5).contains(-1_000_000_000));\n-    /// assert!( (..5).contains(4));\n-    /// assert!(!(..5).contains(5));\n+    /// use std::f32;\n+    ///\n+    /// assert!( (..5).contains(&-1_000_000_000));\n+    /// assert!( (..5).contains(&4));\n+    /// assert!(!(..5).contains(&5));\n+    ///\n+    /// assert!( (..1.0).contains(&0.5));\n+    /// assert!(!(..1.0).contains(&f32::NAN));\n+    /// assert!(!(..f32::NAN).contains(&0.5));\n     /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (item < self.end)\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n }\n \n@@ -318,18 +349,29 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// ```\n     /// #![feature(range_contains)]\n     ///\n-    /// assert!(!(3..=5).contains(2));\n-    /// assert!( (3..=5).contains(3));\n-    /// assert!( (3..=5).contains(4));\n-    /// assert!( (3..=5).contains(5));\n-    /// assert!(!(3..=5).contains(6));\n+    /// use std::f32;\n+    ///\n+    /// assert!(!(3..=5).contains(&2));\n+    /// assert!( (3..=5).contains(&3));\n+    /// assert!( (3..=5).contains(&4));\n+    /// assert!( (3..=5).contains(&5));\n+    /// assert!(!(3..=5).contains(&6));\n     ///\n-    /// assert!( (3..=3).contains(3));\n-    /// assert!(!(3..=2).contains(3));\n+    /// assert!( (3..=3).contains(&3));\n+    /// assert!(!(3..=2).contains(&3));\n+    ///\n+    /// assert!( (0.0..=1.0).contains(&1.0));\n+    /// assert!(!(0.0..=1.0).contains(&f32::NAN));\n+    /// assert!(!(0.0..=f32::NAN).contains(&0.0));\n+    /// assert!(!(f32::NAN..=1.0).contains(&1.0));\n     /// ```\n     #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n-    pub fn contains(&self, item: Idx) -> bool {\n-        self.start <= item && item <= self.end\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n \n     /// Returns `true` if the range contains no items.\n@@ -431,12 +473,23 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// ```\n     /// #![feature(range_contains)]\n     ///\n-    /// assert!( (..=5).contains(-1_000_000_000));\n-    /// assert!( (..=5).contains(5));\n-    /// assert!(!(..=5).contains(6));\n+    /// use std::f32;\n+    ///\n+    /// assert!( (..=5).contains(&-1_000_000_000));\n+    /// assert!( (..=5).contains(&5));\n+    /// assert!(!(..=5).contains(&6));\n+    ///\n+    /// assert!( (..=1.0).contains(&1.0));\n+    /// assert!(!(..=1.0).contains(&f32::NAN));\n+    /// assert!(!(..=f32::NAN).contains(&0.5));\n     /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (item <= self.end)\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n }\n \n@@ -537,6 +590,42 @@ pub trait RangeBounds<T: ?Sized> {\n     /// # }\n     /// ```\n     fn end(&self) -> Bound<&T>;\n+\n+\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    ///\n+    /// use std::f32;\n+    ///\n+    /// assert!( (3..5).contains(&4));\n+    /// assert!(!(3..5).contains(&2));\n+    ///\n+    /// assert!( (0.0..1.0).contains(&0.5));\n+    /// assert!(!(0.0..1.0).contains(&f32::NAN));\n+    /// assert!(!(0.0..f32::NAN).contains(&0.5));\n+    /// assert!(!(f32::NAN..1.0).contains(&0.5));\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    fn contains<U>(&self, item: &U) -> bool\n+    where\n+        T: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<T>,\n+    {\n+        (match self.start() {\n+            Included(ref start) => *start <= item,\n+            Excluded(ref start) => *start < item,\n+            Unbounded => true,\n+        })\n+        &&\n+        (match self.end() {\n+            Included(ref end) => item <= *end,\n+            Excluded(ref end) => item < *end,\n+            Unbounded => true,\n+        })\n+    }\n }\n \n use self::Bound::{Excluded, Included, Unbounded};"}, {"sha": "91075ddcfa422ab40d532178204b806371749145", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49317cd511fbb60178bd5122e484609568938468/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49317cd511fbb60178bd5122e484609568938468/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=49317cd511fbb60178bd5122e484609568938468", "patch": "@@ -1389,8 +1389,8 @@ fn num_overlap(a_start: usize, a_end: usize, b_start: usize, b_end:usize, inclus\n     } else {\n         0\n     };\n-    (b_start..b_end + extra).contains(a_start) ||\n-    (a_start..a_end + extra).contains(b_start)\n+    (b_start..b_end + extra).contains(&a_start) ||\n+    (a_start..a_end + extra).contains(&b_start)\n }\n fn overlaps(a1: &Annotation, a2: &Annotation, padding: usize) -> bool {\n     num_overlap(a1.start_col, a1.end_col + padding, a2.start_col, a2.end_col, false)"}, {"sha": "0fe6265345de1ecfa7fd6f988dae5fb9acfa42f4", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49317cd511fbb60178bd5122e484609568938468/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49317cd511fbb60178bd5122e484609568938468/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=49317cd511fbb60178bd5122e484609568938468", "patch": "@@ -259,18 +259,18 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n     /// True if `r` is a member of this set of universal regions.\n     pub fn is_universal_region(&self, r: RegionVid) -> bool {\n-        (FIRST_GLOBAL_INDEX..self.num_universals).contains(r.index())\n+        (FIRST_GLOBAL_INDEX..self.num_universals).contains(&r.index())\n     }\n \n     /// Classifies `r` as a universal region, returning `None` if this\n     /// is not a member of this set of universal regions.\n     pub fn region_classification(&self, r: RegionVid) -> Option<RegionClassification> {\n         let index = r.index();\n-        if (FIRST_GLOBAL_INDEX..self.first_extern_index).contains(index) {\n+        if (FIRST_GLOBAL_INDEX..self.first_extern_index).contains(&index) {\n             Some(RegionClassification::Global)\n-        } else if (self.first_extern_index..self.first_local_index).contains(index) {\n+        } else if (self.first_extern_index..self.first_local_index).contains(&index) {\n             Some(RegionClassification::External)\n-        } else if (self.first_local_index..self.num_universals).contains(index) {\n+        } else if (self.first_local_index..self.num_universals).contains(&index) {\n             Some(RegionClassification::Local)\n         } else {\n             None"}]}