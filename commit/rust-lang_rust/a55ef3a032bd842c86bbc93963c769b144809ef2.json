{"sha": "a55ef3a032bd842c86bbc93963c769b144809ef2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NWVmM2EwMzJiZDg0MmM4NmJiYzkzOTYzYzc2OWIxNDQ4MDllZjI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-12-11T12:53:30Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-01-21T09:48:10Z"}, "message": "debuginfo: Make debuginfo source location assignment more stable (Pt. 1)\n\nSo far, the source location an LLVM instruction was linked to was controlled by\n`debuginfo::set_source_location()` and `debuginfo::clear_source_location()`.\nThis interface mimicked how LLVM's `IRBuilder` handles debug location\nassignment. While this interface has some theoretical performance benefits, it\nalso makes things terribly unstable: One sets some quasi-global state and then\nhopes that it is still correct when a given instruction is emitted---an\nassumption that has been proven to not hold a bit too often.\n\nThis patch requires the debug source location to be passed to the actual\ninstruction emitting function. This makes source location assignment explicit\nand will prevent future changes to `trans` from accidentally breaking things in\nthe majority of cases.\n\nThis patch does not yet implement the new principle for all instruction kinds\nbut the stepping experience should have improved significantly nonetheless\nalready.", "tree": {"sha": "2319ec5700497dc5e076244b0cbd1fedad2f0b7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2319ec5700497dc5e076244b0cbd1fedad2f0b7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a55ef3a032bd842c86bbc93963c769b144809ef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a55ef3a032bd842c86bbc93963c769b144809ef2", "html_url": "https://github.com/rust-lang/rust/commit/a55ef3a032bd842c86bbc93963c769b144809ef2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a55ef3a032bd842c86bbc93963c769b144809ef2/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51e28dd0c88030b8661f0c414eb0af3e09840b31", "url": "https://api.github.com/repos/rust-lang/rust/commits/51e28dd0c88030b8661f0c414eb0af3e09840b31", "html_url": "https://github.com/rust-lang/rust/commit/51e28dd0c88030b8661f0c414eb0af3e09840b31"}], "stats": {"total": 1294, "additions": 889, "deletions": 405}, "files": [{"sha": "fa20b99e14279651280abf363ffa6ef3c7d67f9b", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -208,10 +208,10 @@ use trans::cleanup::{self, CleanupMethods};\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n+use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::expr::{self, Dest};\n use trans::tvec;\n use trans::type_of;\n-use trans::debuginfo;\n use middle::ty::{self, Ty};\n use session::config::FullDebugInfo;\n use util::common::indenter;\n@@ -632,7 +632,7 @@ fn bind_subslice_pat(bcx: Block,\n \n     let slice_begin = InBoundsGEP(bcx, base, &[C_uint(bcx.ccx(), offset_left)]);\n     let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n-    let slice_len = Sub(bcx, len, slice_len_offset);\n+    let slice_len = Sub(bcx, len, slice_len_offset, DebugLoc::None);\n     let slice_ty = ty::mk_slice(bcx.tcx(),\n                                 bcx.tcx().mk_region(ty::ReStatic),\n                                 ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n@@ -656,7 +656,7 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     elems.extend(range(0, before).map(|i| GEPi(bcx, base, &[i])));\n     elems.extend(range(0, after).rev().map(|i| {\n         InBoundsGEP(bcx, base, &[\n-            Sub(bcx, len, C_uint(bcx.ccx(), i + 1))\n+            Sub(bcx, len, C_uint(bcx.ccx(), i + 1), DebugLoc::None)\n         ])\n     }));\n     ExtractedBlock { vals: elems, bcx: bcx }\n@@ -731,7 +731,7 @@ impl FailureHandler {\n             Infallible =>\n                 panic!(\"attempted to panic in a non-panicking panic handler!\"),\n             JumpToBasicBlock(basic_block) =>\n-                Br(bcx, basic_block),\n+                Br(bcx, basic_block, DebugLoc::None),\n             Unreachable =>\n                 build::Unreachable(bcx)\n         }\n@@ -889,7 +889,7 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    with_cond(bcx, Not(bcx, val), |bcx| {\n+    with_cond(bcx, Not(bcx, val, guard_expr.debug_loc()), |bcx| {\n         // Guard does not match: remove all bindings from the lllocals table\n         for (_, &binding_info) in data.bindings_map.iter() {\n             call_lifetime_end(bcx, binding_info.llmatch);\n@@ -966,7 +966,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n                 _ => ()\n             }\n-            Br(bcx, data.bodycx.llbb);\n+            Br(bcx, data.bodycx.llbb, DebugLoc::None);\n         }\n     }\n }\n@@ -1096,7 +1096,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         if !exhaustive || i + 1 < len {\n             opt_cx = bcx.fcx.new_temp_block(\"match_case\");\n             match kind {\n-                Single => Br(bcx, opt_cx.llbb),\n+                Single => Br(bcx, opt_cx.llbb, DebugLoc::None),\n                 Switch => {\n                     match opt.trans(bcx) {\n                         SingleResult(r) => {\n@@ -1131,7 +1131,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                     compare_scalar_types(\n                                     bcx, test_val, vend,\n                                     t, ast::BiLe);\n-                                Result::new(bcx, And(bcx, llge, llle))\n+                                Result::new(bcx, And(bcx, llge, llle, DebugLoc::None))\n                             }\n                             LowerBound(Result { bcx, val }) => {\n                                 compare_scalar_types(bcx, test_val, val, t, ast::BiGe)\n@@ -1149,12 +1149,12 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     if i + 1 < len && (guarded || multi_pats || kind == CompareSliceLength) {\n                         branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n                     }\n-                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n+                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb, DebugLoc::None);\n                 }\n                 _ => ()\n             }\n         } else if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb);\n+            Br(bcx, else_cx.llbb, DebugLoc::None);\n         }\n \n         let mut size = 0u;\n@@ -1194,7 +1194,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // Compile the fall-through case, if any\n     if !exhaustive && kind != Single {\n         if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb);\n+            Br(bcx, else_cx.llbb, DebugLoc::None);\n         }\n         match chk {\n             // If there is only one default arm left, move on to the next"}, {"sha": "c98515cff6857e38017a8466246ab32378d1fc75", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -62,6 +62,7 @@ use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum;\n+use trans::debuginfo::DebugLoc;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -979,7 +980,7 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n-                Br(variant_cx, bcx_next.llbb);\n+                Br(variant_cx, bcx_next.llbb, DebugLoc::None);\n             }\n \n             bcx_next"}, {"sha": "f8c37084788e3c699ad02ce249883f87b4ceebcf", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -57,7 +57,7 @@ use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n-use trans::common::{NodeInfo, Result};\n+use trans::common::{Result};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{tydesc_info, type_is_immediate};\n use trans::common::{type_is_zero_size, val_ty};\n@@ -66,7 +66,7 @@ use trans::consts;\n use trans::context::SharedCrateContext;\n use trans::controlflow;\n use trans::datum;\n-use trans::debuginfo;\n+use trans::debuginfo::{self, DebugLoc};\n use trans::expr;\n use trans::foreign;\n use trans::glue;\n@@ -792,7 +792,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                        &**variant,\n                                        substs,\n                                        &mut f);\n-                      Br(variant_cx, next_cx.llbb);\n+                      Br(variant_cx, next_cx.llbb, DebugLoc::None);\n                   }\n                   cx = next_cx;\n               }\n@@ -957,7 +957,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: &[ValueRef],\n                           fn_ty: Ty<'tcx>,\n-                          call_info: Option<NodeInfo>)\n+                          debug_loc: DebugLoc)\n                           -> (ValueRef, Block<'blk, 'tcx>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n@@ -983,30 +983,25 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n         let landing_pad = bcx.fcx.get_landing_pad();\n \n-        match call_info {\n-            Some(info) => debuginfo::set_source_location(bcx.fcx, info.id, info.span),\n-            None => debuginfo::clear_source_location(bcx.fcx)\n-        };\n-\n         let llresult = Invoke(bcx,\n                               llfn,\n                               &llargs[],\n                               normal_bcx.llbb,\n                               landing_pad,\n-                              Some(attributes));\n+                              Some(attributes),\n+                              debug_loc);\n         return (llresult, normal_bcx);\n     } else {\n         debug!(\"calling {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n         for &llarg in llargs.iter() {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n \n-        match call_info {\n-            Some(info) => debuginfo::set_source_location(bcx.fcx, info.id, info.span),\n-            None => debuginfo::clear_source_location(bcx.fcx)\n-        };\n-\n-        let llresult = Call(bcx, llfn, &llargs[], Some(attributes));\n+        let llresult = Call(bcx,\n+                            llfn,\n+                            &llargs[],\n+                            Some(attributes),\n+                            debug_loc);\n         return (llresult, bcx);\n     }\n }\n@@ -1094,10 +1089,10 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let next_cx = fcx.new_temp_block(\"next\");\n     let cond_cx = fcx.new_temp_block(\"cond\");\n-    CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n+    CondBr(bcx, val, cond_cx.llbb, next_cx.llbb, DebugLoc::None);\n     let after_cx = f(cond_cx);\n     if !after_cx.terminated.get() {\n-        Br(after_cx, next_cx.llbb);\n+        Br(after_cx, next_cx.llbb, DebugLoc::None);\n     }\n     next_cx\n }\n@@ -1113,7 +1108,7 @@ pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_start = ccx.get_intrinsic(&\"llvm.lifetime.start\");\n-    Call(cx, lifetime_start, &[llsize, ptr], None);\n+    Call(cx, lifetime_start, &[llsize, ptr], None, DebugLoc::None);\n }\n \n pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n@@ -1127,7 +1122,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_end = ccx.get_intrinsic(&\"llvm.lifetime.end\");\n-    Call(cx, lifetime_end, &[llsize, ptr], None);\n+    Call(cx, lifetime_end, &[llsize, ptr], None, DebugLoc::None);\n }\n \n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n@@ -1144,7 +1139,7 @@ pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     let size = IntCast(cx, n_bytes, ccx.int_type());\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n-    Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n+    Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None, DebugLoc::None);\n }\n \n pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -1697,13 +1692,14 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n // and builds the return block.\n pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n                              last_bcx: Block<'blk, 'tcx>,\n-                             retty: ty::FnOutput<'tcx>) {\n+                             retty: ty::FnOutput<'tcx>,\n+                             ret_debug_loc: DebugLoc) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     let ret_cx = match fcx.llreturn.get() {\n         Some(llreturn) => {\n             if !last_bcx.terminated.get() {\n-                Br(last_bcx, llreturn);\n+                Br(last_bcx, llreturn, DebugLoc::None);\n             }\n             raw_block(fcx, false, llreturn)\n         }\n@@ -1713,7 +1709,7 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n     // This shouldn't need to recompute the return type,\n     // as new_fn_ctxt did it already.\n     let substd_retty = fcx.monomorphize(&retty);\n-    build_return_block(fcx, ret_cx, substd_retty);\n+    build_return_block(fcx, ret_cx, substd_retty, ret_debug_loc);\n \n     debuginfo::clear_source_location(fcx);\n     fcx.cleanup();\n@@ -1722,10 +1718,11 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n // Builds the return block for a function.\n pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                                       ret_cx: Block<'blk, 'tcx>,\n-                                      retty: ty::FnOutput<'tcx>) {\n+                                      retty: ty::FnOutput<'tcx>,\n+                                      ret_debug_location: DebugLoc) {\n     if fcx.llretslotptr.get().is_none() ||\n        (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n-        return RetVoid(ret_cx);\n+        return RetVoid(ret_cx, ret_debug_location);\n     }\n \n     let retslot = if fcx.needs_ret_allocas {\n@@ -1755,26 +1752,26 @@ pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                 if let ty::FnConverging(retty) = retty {\n                     store_ty(ret_cx, retval, get_param(fcx.llfn, 0), retty);\n                 }\n-                RetVoid(ret_cx)\n+                RetVoid(ret_cx, ret_debug_location)\n             } else {\n-                Ret(ret_cx, retval)\n+                Ret(ret_cx, retval, ret_debug_location)\n             }\n         }\n         // Otherwise, copy the return value to the ret slot\n         None => match retty {\n             ty::FnConverging(retty) => {\n                 if fcx.caller_expects_out_pointer {\n                     memcpy_ty(ret_cx, get_param(fcx.llfn, 0), retslot, retty);\n-                    RetVoid(ret_cx)\n+                    RetVoid(ret_cx, ret_debug_location)\n                 } else {\n-                    Ret(ret_cx, load_ty(ret_cx, retslot, retty))\n+                    Ret(ret_cx, load_ty(ret_cx, retslot, retty), ret_debug_location)\n                 }\n             }\n             ty::FnDiverging => {\n                 if fcx.caller_expects_out_pointer {\n-                    RetVoid(ret_cx)\n+                    RetVoid(ret_cx, ret_debug_location)\n                 } else {\n-                    Ret(ret_cx, C_undef(Type::nil(fcx.ccx)))\n+                    Ret(ret_cx, C_undef(Type::nil(fcx.ccx)), ret_debug_location)\n                 }\n             }\n         }\n@@ -1905,7 +1902,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     match fcx.llreturn.get() {\n         Some(_) => {\n-            Br(bcx, fcx.return_exit_block());\n+            Br(bcx, fcx.return_exit_block(), DebugLoc::None);\n             fcx.pop_custom_cleanup_scope(arg_scope);\n         }\n         None => {\n@@ -1924,8 +1921,11 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n+    let ret_debug_loc = DebugLoc::At(fn_cleanup_debug_loc.id,\n+                                     fn_cleanup_debug_loc.span);\n+\n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(&fcx, bcx, output_type);\n+    finish_fn(&fcx, bcx, output_type, ret_debug_loc);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -1977,7 +1977,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  disr: ty::Disr,\n                                                  args: callee::CallArgs,\n                                                  dest: expr::Dest,\n-                                                 call_info: Option<NodeInfo>)\n+                                                 debug_loc: DebugLoc)\n                                                  -> Result<'blk, 'tcx> {\n \n     let ccx = bcx.fcx.ccx;\n@@ -2016,7 +2016,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       &fields[],\n                                       None,\n                                       expr::SaveIn(llresult),\n-                                      call_info);\n+                                      debug_loc);\n             }\n             _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\")\n         }\n@@ -2027,7 +2027,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let bcx = match dest {\n         expr::SaveIn(_) => bcx,\n         expr::Ignore => {\n-            glue::drop_ty(bcx, llresult, result_ty, call_info)\n+            glue::drop_ty(bcx, llresult, result_ty, debug_loc)\n         }\n     };\n \n@@ -2094,7 +2094,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         adt::trans_set_discr(bcx, &*repr, dest, disr);\n     }\n \n-    finish_fn(&fcx, bcx, result_ty);\n+    finish_fn(&fcx, bcx, result_ty, DebugLoc::None);\n }\n \n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {"}, {"sha": "7acac5a12ebd216c8e1132b477881b5512a8a17e", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 318, "deletions": 80, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -20,6 +20,7 @@ use syntax::codemap::Span;\n \n use trans::builder::Builder;\n use trans::type_::Type;\n+use trans::debuginfo::DebugLoc;\n \n use libc::{c_uint, c_char};\n \n@@ -48,41 +49,59 @@ pub fn B<'blk, 'tcx>(cx: Block<'blk, 'tcx>) -> Builder<'blk, 'tcx> {\n // for (panic/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: Block) {\n-    if cx.unreachable.get() { return; }\n+pub fn RetVoid(cx: Block, debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: Block, v: ValueRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn Ret(cx: Block, v: ValueRef, debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).ret(v);\n }\n \n-pub fn AggregateRet(cx: Block, ret_vals: &[ValueRef]) {\n-    if cx.unreachable.get() { return; }\n+pub fn AggregateRet(cx: Block,\n+                    ret_vals: &[ValueRef],\n+                    debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).aggregate_ret(ret_vals);\n }\n \n-pub fn Br(cx: Block, dest: BasicBlockRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn Br(cx: Block, dest: BasicBlockRef, debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).br(dest);\n }\n \n pub fn CondBr(cx: Block,\n               if_: ValueRef,\n               then: BasicBlockRef,\n-              else_: BasicBlockRef) {\n-    if cx.unreachable.get() { return; }\n+              else_: BasicBlockRef,\n+              debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"CondBr\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).cond_br(if_, then, else_);\n }\n \n@@ -101,10 +120,16 @@ pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: Block, addr: ValueRef, num_dests: uint) {\n-    if cx.unreachable.get() { return; }\n+pub fn IndirectBr(cx: Block,\n+                  addr: ValueRef,\n+                  num_dests: uint,\n+                  debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).indirect_br(addr, num_dests);\n }\n \n@@ -113,7 +138,8 @@ pub fn Invoke(cx: Block,\n               args: &[ValueRef],\n               then: BasicBlockRef,\n               catch: BasicBlockRef,\n-              attributes: Option<AttrBuilder>)\n+              attributes: Option<AttrBuilder>,\n+              debug_loc: DebugLoc)\n               -> ValueRef {\n     if cx.unreachable.get() {\n         return C_null(Type::i8(cx.ccx()));\n@@ -123,6 +149,7 @@ pub fn Invoke(cx: Block,\n     debug!(\"Invoke({} with arguments ({}))\",\n            cx.val_to_string(fn_),\n            args.iter().map(|a| cx.val_to_string(*a)).collect::<Vec<String>>().connect(\", \"));\n+    debug_loc.apply(cx.fcx);\n     B(cx).invoke(fn_, args, then, catch, attributes)\n }\n \n@@ -143,176 +170,378 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-pub fn Add(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Add(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).add(lhs, rhs)\n }\n \n-pub fn NSWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NSWAdd(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswadd(lhs, rhs)\n }\n \n-pub fn NUWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NUWAdd(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwadd(lhs, rhs)\n }\n \n-pub fn FAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FAdd(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fadd(lhs, rhs)\n }\n \n-pub fn Sub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Sub(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).sub(lhs, rhs)\n }\n \n-pub fn NSWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NSWSub(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswsub(lhs, rhs)\n }\n \n-pub fn NUWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NUWSub(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwsub(lhs, rhs)\n }\n \n-pub fn FSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FSub(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fsub(lhs, rhs)\n }\n \n-pub fn Mul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Mul(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).mul(lhs, rhs)\n }\n \n-pub fn NSWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NSWMul(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswmul(lhs, rhs)\n }\n \n-pub fn NUWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NUWMul(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwmul(lhs, rhs)\n }\n \n-pub fn FMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FMul(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fmul(lhs, rhs)\n }\n \n-pub fn UDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn UDiv(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).udiv(lhs, rhs)\n }\n \n-pub fn SDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn SDiv(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).sdiv(lhs, rhs)\n }\n \n-pub fn ExactSDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn ExactSDiv(cx: Block,\n+                 lhs: ValueRef,\n+                 rhs: ValueRef,\n+                 debug_loc: DebugLoc)\n+                 -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).exactsdiv(lhs, rhs)\n }\n \n-pub fn FDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FDiv(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fdiv(lhs, rhs)\n }\n \n-pub fn URem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn URem(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).urem(lhs, rhs)\n }\n \n-pub fn SRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn SRem(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).srem(lhs, rhs)\n }\n \n-pub fn FRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FRem(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).frem(lhs, rhs)\n }\n \n-pub fn Shl(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Shl(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).shl(lhs, rhs)\n }\n \n-pub fn LShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn LShr(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).lshr(lhs, rhs)\n }\n \n-pub fn AShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn AShr(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).ashr(lhs, rhs)\n }\n \n-pub fn And(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn And(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).and(lhs, rhs)\n }\n \n-pub fn Or(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Or(cx: Block,\n+          lhs: ValueRef,\n+          rhs: ValueRef,\n+          debug_loc: DebugLoc)\n+          -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).or(lhs, rhs)\n }\n \n-pub fn Xor(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Xor(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).xor(lhs, rhs)\n }\n \n-pub fn BinOp(cx: Block, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n+pub fn BinOp(cx: Block,\n+             op: Opcode,\n+             lhs: ValueRef,\n+             rhs: ValueRef,\n+             debug_loc: DebugLoc)\n           -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).binop(op, lhs, rhs)\n }\n \n-pub fn Neg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn Neg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).neg(v)\n }\n \n-pub fn NSWNeg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn NSWNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswneg(v)\n }\n \n-pub fn NUWNeg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn NUWNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwneg(v)\n }\n-pub fn FNeg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn FNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fneg(v)\n }\n \n-pub fn Not(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn Not(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).not(v)\n }\n \n /* Memory */\n-pub fn Malloc(cx: Block, ty: Type) -> ValueRef {\n+pub fn Malloc(cx: Block, ty: Type, debug_loc: DebugLoc) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).malloc(ty)\n     }\n }\n \n-pub fn ArrayMalloc(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: Block,\n+                   ty: Type,\n+                   val: ValueRef,\n+                   debug_loc: DebugLoc) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).array_malloc(ty, val)\n     }\n }\n@@ -327,6 +556,7 @@ pub fn Alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n pub fn AllocaFcx(fcx: &FunctionContext, ty: Type, name: &str) -> ValueRef {\n     let b = fcx.ccx.builder();\n     b.position_before(fcx.alloca_insert_pt.get().unwrap());\n+    DebugLoc::None.apply(fcx);\n     b.alloca(ty, name)\n }\n \n@@ -335,6 +565,7 @@ pub fn ArrayAlloca(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n         b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n+        DebugLoc::None.apply(cx.fcx);\n         b.array_alloca(ty, val)\n     }\n }\n@@ -680,9 +911,16 @@ pub fn InlineAsmCall(cx: Block, asm: *const c_char, cons: *const c_char,\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: Block, fn_: ValueRef, args: &[ValueRef],\n-            attributes: Option<AttrBuilder>) -> ValueRef {\n-    if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n+pub fn Call(cx: Block,\n+            fn_: ValueRef,\n+            args: &[ValueRef],\n+            attributes: Option<AttrBuilder>,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _UndefReturn(cx, fn_);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).call(fn_, args, attributes)\n }\n "}, {"sha": "7ed4727404e10557c960976b787ec3aacee1a240", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -40,6 +40,7 @@ use trans::common;\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n+use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::glue;\n use trans::inline;\n@@ -356,7 +357,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            ArgVals(&llargs[]),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, sig.output);\n+    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n \n@@ -646,7 +647,7 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// For non-lang items, `dest` is always Some, and hence the result is written into memory\n /// somewhere. Nonetheless we return the actual return value of the function.\n pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                           call_info: Option<NodeInfo>,\n+                                           call_info: Option<NodeIdAndSpan>,\n                                            callee_ty: Ty<'tcx>,\n                                            get_callee: F,\n                                            args: CallArgs<'a, 'tcx>,\n@@ -703,7 +704,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                                        disr,\n                                                        args,\n                                                        dest.unwrap(),\n-                                                       call_info);\n+                                                       call_info.debug_loc());\n         }\n     };\n \n@@ -781,7 +782,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                       llfn,\n                                       &llargs[],\n                                       callee_ty,\n-                                      call_info);\n+                                      call_info.debug_loc());\n         bcx = b;\n         llresult = llret;\n \n@@ -828,7 +829,10 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     match (dest, opt_llretslot, ret_ty) {\n         (Some(expr::Ignore), Some(llretslot), ty::FnConverging(ret_ty)) => {\n             // drop the value if it is not being saved.\n-            bcx = glue::drop_ty(bcx, llretslot, ret_ty, call_info);\n+            bcx = glue::drop_ty(bcx,\n+                                llretslot,\n+                                ret_ty,\n+                                call_info.debug_loc());\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}"}, {"sha": "73a71455c6ede84e2808982acadec298861bc500", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -21,8 +21,8 @@ use trans::base;\n use trans::build;\n use trans::callee;\n use trans::common;\n-use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n-use trans::debuginfo;\n+use trans::common::{Block, FunctionContext, ExprId, NodeIdAndSpan};\n+use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::glue;\n use middle::region;\n use trans::type_::Type;\n@@ -44,7 +44,7 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n \n     // The debug location any drop calls generated for this scope will be\n     // associated with.\n-    debug_loc: Option<NodeInfo>,\n+    debug_loc: DebugLoc,\n \n     cached_early_exits: Vec<CachedEarlyExit>,\n     cached_landing_pad: Option<BasicBlockRef>,\n@@ -100,7 +100,7 @@ pub trait Cleanup<'tcx> {\n     fn is_lifetime_end(&self) -> bool;\n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx>;\n }\n \n@@ -114,7 +114,7 @@ pub enum ScopeId {\n \n impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// Invoked when we start to trans the code contained within a new cleanup scope.\n-    fn push_ast_cleanup_scope(&self, debug_loc: NodeInfo) {\n+    fn push_ast_cleanup_scope(&self, debug_loc: NodeIdAndSpan) {\n         debug!(\"push_ast_cleanup_scope({})\",\n                self.ccx.tcx().map.node_to_string(debug_loc.id));\n \n@@ -139,7 +139,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n-                                          Some(debug_loc)));\n+                                          debug_loc.debug_loc()));\n     }\n \n     fn push_loop_cleanup_scope(&self,\n@@ -168,19 +168,20 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                             .borrow()\n                             .last()\n                             .map(|opt_scope| opt_scope.debug_loc)\n-                            .unwrap_or(None);\n+                            .unwrap_or(DebugLoc::None);\n \n         self.push_scope(CleanupScope::new(CustomScopeKind, debug_loc));\n         CustomScopeIndex { index: index }\n     }\n \n     fn push_custom_cleanup_scope_with_debug_loc(&self,\n-                                                debug_loc: NodeInfo)\n+                                                debug_loc: NodeIdAndSpan)\n                                                 -> CustomScopeIndex {\n         let index = self.scopes_len();\n         debug!(\"push_custom_cleanup_scope(): {}\", index);\n \n-        self.push_scope(CleanupScope::new(CustomScopeKind, Some(debug_loc)));\n+        self.push_scope(CleanupScope::new(CustomScopeKind,\n+                                          debug_loc.debug_loc()));\n         CustomScopeIndex { index: index }\n     }\n \n@@ -664,7 +665,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                                                 scope.debug_loc);\n                     }\n                 }\n-                build::Br(bcx_out, prev_llbb);\n+                build::Br(bcx_out, prev_llbb, DebugLoc::None);\n                 prev_llbb = bcx_in.llbb;\n             } else {\n                 debug!(\"no suitable cleanups in {}\",\n@@ -766,15 +767,15 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n         // Generate the cleanup block and branch to it.\n         let cleanup_llbb = self.trans_cleanups_to_exit_scope(UnwindExit);\n-        build::Br(pad_bcx, cleanup_llbb);\n+        build::Br(pad_bcx, cleanup_llbb, DebugLoc::None);\n \n         return pad_bcx.llbb;\n     }\n }\n \n impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n     fn new(kind: CleanupScopeKind<'blk, 'tcx>,\n-           debug_loc: Option<NodeInfo>)\n+           debug_loc: DebugLoc)\n         -> CleanupScope<'blk, 'tcx> {\n         CleanupScope {\n             kind: kind,\n@@ -896,7 +897,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n@@ -937,9 +938,9 @@ impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        apply_debug_loc(bcx.fcx, debug_loc);\n+        debug_loc.apply(bcx.fcx);\n \n         match self.heap {\n             HeapExchange => {\n@@ -972,9 +973,9 @@ impl<'tcx> Cleanup<'tcx> for FreeSlice {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        apply_debug_loc(bcx.fcx, debug_loc);\n+        debug_loc.apply(bcx.fcx);\n \n         match self.heap {\n             HeapExchange => {\n@@ -1004,9 +1005,9 @@ impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        apply_debug_loc(bcx.fcx, debug_loc);\n+        debug_loc.apply(bcx.fcx);\n         base::call_lifetime_end(bcx, self.ptr);\n         bcx\n     }\n@@ -1041,33 +1042,22 @@ fn cleanup_is_suitable_for(c: &Cleanup,\n     !label.is_unwind() || c.clean_on_unwind()\n }\n \n-fn apply_debug_loc(fcx: &FunctionContext, debug_loc: Option<NodeInfo>) {\n-    match debug_loc {\n-        Some(ref src_loc) => {\n-            debuginfo::set_source_location(fcx, src_loc.id, src_loc.span);\n-        }\n-        None => {\n-            debuginfo::clear_source_location(fcx);\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // These traits just exist to put the methods into this file.\n \n pub trait CleanupMethods<'blk, 'tcx> {\n-    fn push_ast_cleanup_scope(&self, id: NodeInfo);\n+    fn push_ast_cleanup_scope(&self, id: NodeIdAndSpan);\n     fn push_loop_cleanup_scope(&self,\n                                id: ast::NodeId,\n                                exits: [Block<'blk, 'tcx>; EXIT_MAX]);\n     fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;\n     fn push_custom_cleanup_scope_with_debug_loc(&self,\n-                                                debug_loc: NodeInfo)\n+                                                debug_loc: NodeIdAndSpan)\n                                                 -> CustomScopeIndex;\n     fn pop_and_trans_ast_cleanup_scope(&self,\n-                                              bcx: Block<'blk, 'tcx>,\n-                                              cleanup_scope: ast::NodeId)\n-                                              -> Block<'blk, 'tcx>;\n+                                       bcx: Block<'blk, 'tcx>,\n+                                       cleanup_scope: ast::NodeId)\n+                                       -> Block<'blk, 'tcx>;\n     fn pop_loop_cleanup_scope(&self,\n                               cleanup_scope: ast::NodeId);\n     fn pop_custom_cleanup_scope(&self,"}, {"sha": "b0bdd7f4ba48ad4b86c49074f5b0744c7196e629", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -30,7 +30,7 @@ use trans::build;\n use trans::cleanup;\n use trans::consts;\n use trans::datum;\n-use trans::debuginfo;\n+use trans::debuginfo::{self, DebugLoc};\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -317,13 +317,13 @@ pub struct tydesc_info<'tcx> {\n */\n \n #[derive(Copy)]\n-pub struct NodeInfo {\n+pub struct NodeIdAndSpan {\n     pub id: ast::NodeId,\n     pub span: Span,\n }\n \n-pub fn expr_info(expr: &ast::Expr) -> NodeInfo {\n-    NodeInfo { id: expr.id, span: expr.span }\n+pub fn expr_info(expr: &ast::Expr) -> NodeIdAndSpan {\n+    NodeIdAndSpan { id: expr.id, span: expr.span }\n }\n \n pub struct BuilderRef_res {\n@@ -517,7 +517,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let mut reachable = false;\n         for bcx in in_cxs.iter() {\n             if !bcx.unreachable.get() {\n-                build::Br(*bcx, out.llbb);\n+                build::Br(*bcx, out.llbb, DebugLoc::None);\n                 reachable = true;\n             }\n         }"}, {"sha": "bea8a75997152ba8a4932f98a5b7864ceb100e83", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -22,6 +22,7 @@ use trans::common::*;\n use trans::consts;\n use trans::datum;\n use trans::debuginfo;\n+use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::meth;\n use trans::type_::Type;\n@@ -188,20 +189,22 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n+    let cond_source_loc = cond.debug_loc();\n+\n     let next_bcx;\n     match els {\n         Some(elexpr) => {\n             let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n             let else_bcx_out = expr::trans_into(else_bcx_in, &*elexpr, dest);\n             next_bcx = bcx.fcx.join_blocks(if_id,\n                                            &[then_bcx_out, else_bcx_out]);\n-            CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n+            CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb, cond_source_loc);\n         }\n \n         None => {\n             next_bcx = bcx.fcx.new_id_block(\"next-block\", if_id);\n-            Br(then_bcx_out, next_bcx.llbb);\n-            CondBr(bcx, cond_val, then_bcx_in.llbb, next_bcx.llbb);\n+            Br(then_bcx_out, next_bcx.llbb, DebugLoc::None);\n+            CondBr(bcx, cond_val, then_bcx_in.llbb, next_bcx.llbb, cond_source_loc);\n         }\n     }\n \n@@ -213,7 +216,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               loop_id: ast::NodeId,\n+                               loop_expr: &ast::Expr,\n                                cond: &ast::Expr,\n                                body: &ast::Block)\n                                -> Block<'blk, 'tcx> {\n@@ -231,33 +234,34 @@ pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     //    |           body_bcx_out --+\n     // next_bcx_in\n \n-    let next_bcx_in = fcx.new_id_block(\"while_exit\", loop_id);\n+    let next_bcx_in = fcx.new_id_block(\"while_exit\", loop_expr.id);\n     let cond_bcx_in = fcx.new_id_block(\"while_cond\", cond.id);\n     let body_bcx_in = fcx.new_id_block(\"while_body\", body.id);\n \n-    fcx.push_loop_cleanup_scope(loop_id, [next_bcx_in, cond_bcx_in]);\n+    fcx.push_loop_cleanup_scope(loop_expr.id, [next_bcx_in, cond_bcx_in]);\n \n-    Br(bcx, cond_bcx_in.llbb);\n+    Br(bcx, cond_bcx_in.llbb, loop_expr.debug_loc());\n \n     // compile the block where we will handle loop cleanups\n-    let cleanup_llbb = fcx.normal_exit_block(loop_id, cleanup::EXIT_BREAK);\n+    let cleanup_llbb = fcx.normal_exit_block(loop_expr.id, cleanup::EXIT_BREAK);\n \n     // compile the condition\n     let Result {bcx: cond_bcx_out, val: cond_val} =\n         expr::trans(cond_bcx_in, cond).to_llbool();\n-    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, cleanup_llbb);\n+\n+    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, cleanup_llbb, cond.debug_loc());\n \n     // loop body:\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    Br(body_bcx_out, cond_bcx_in.llbb);\n+    Br(body_bcx_out, cond_bcx_in.llbb, DebugLoc::None);\n \n-    fcx.pop_loop_cleanup_scope(loop_id);\n+    fcx.pop_loop_cleanup_scope(loop_expr.id);\n     return next_bcx_in;\n }\n \n /// Translates a `for` loop.\n pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             loop_info: NodeInfo,\n+                             loop_info: NodeIdAndSpan,\n                              pat: &ast::Pat,\n                              head: &ast::Expr,\n                              body: &ast::Block)\n@@ -292,7 +296,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let body_bcx_in = bcx.fcx.new_id_block(\"for_body\", body.id);\n     bcx.fcx.push_loop_cleanup_scope(loop_info.id,\n                                     [next_bcx_in, loopback_bcx_in]);\n-    Br(bcx, loopback_bcx_in.llbb);\n+    Br(bcx, loopback_bcx_in.llbb, DebugLoc::None);\n     let cleanup_llbb = bcx.fcx.normal_exit_block(loop_info.id,\n                                                  cleanup::EXIT_BREAK);\n \n@@ -347,7 +351,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                               None);\n     let i1_type = Type::i1(loopback_bcx_out.ccx());\n     let llcondition = Trunc(loopback_bcx_out, lldiscriminant, i1_type);\n-    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb);\n+    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb, DebugLoc::None);\n \n     // Now we're in the body. Unpack the `Option` value into the programmer-\n     // supplied pattern.\n@@ -377,15 +381,15 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         body_bcx_out.fcx\n                     .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n                                                         option_cleanup_scope);\n-    Br(body_bcx_out, loopback_bcx_in.llbb);\n+    Br(body_bcx_out, loopback_bcx_in.llbb, DebugLoc::None);\n \n     // Codegen cleanups and leave.\n     next_bcx_in.fcx.pop_loop_cleanup_scope(loop_info.id);\n     next_bcx_in\n }\n \n pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              loop_id: ast::NodeId,\n+                              loop_expr: &ast::Expr,\n                               body: &ast::Block)\n                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_loop\");\n@@ -402,22 +406,22 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Links between body_bcx_in and next_bcx are created by\n     // break statements.\n \n-    let next_bcx_in = bcx.fcx.new_id_block(\"loop_exit\", loop_id);\n+    let next_bcx_in = bcx.fcx.new_id_block(\"loop_exit\", loop_expr.id);\n     let body_bcx_in = bcx.fcx.new_id_block(\"loop_body\", body.id);\n \n-    fcx.push_loop_cleanup_scope(loop_id, [next_bcx_in, body_bcx_in]);\n+    fcx.push_loop_cleanup_scope(loop_expr.id, [next_bcx_in, body_bcx_in]);\n \n-    Br(bcx, body_bcx_in.llbb);\n+    Br(bcx, body_bcx_in.llbb, loop_expr.debug_loc());\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    Br(body_bcx_out, body_bcx_in.llbb);\n+    Br(body_bcx_out, body_bcx_in.llbb, DebugLoc::None);\n \n-    fcx.pop_loop_cleanup_scope(loop_id);\n+    fcx.pop_loop_cleanup_scope(loop_expr.id);\n \n     return next_bcx_in;\n }\n \n pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    expr_id: ast::NodeId,\n+                                    expr: &ast::Expr,\n                                     opt_label: Option<Ident>,\n                                     exit: uint)\n                                     -> Block<'blk, 'tcx> {\n@@ -432,7 +436,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            match bcx.tcx().def_map.borrow().get(&expr_id) {\n+            match bcx.tcx().def_map.borrow().get(&expr.id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\",\n@@ -444,39 +448,40 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Generate appropriate cleanup code and branch\n     let cleanup_llbb = fcx.normal_exit_block(loop_id, exit);\n-    Br(bcx, cleanup_llbb);\n+    Br(bcx, cleanup_llbb, expr.debug_loc());\n     Unreachable(bcx); // anything afterwards should be ignored\n     return bcx;\n }\n \n pub fn trans_break<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               expr_id: ast::NodeId,\n+                               expr: &ast::Expr,\n                                label_opt: Option<Ident>)\n                                -> Block<'blk, 'tcx> {\n-    return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_BREAK);\n+    return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_BREAK);\n }\n \n pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              expr_id: ast::NodeId,\n+                              expr: &ast::Expr,\n                               label_opt: Option<Ident>)\n                               -> Block<'blk, 'tcx> {\n-    return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_LOOP);\n+    return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_LOOP);\n }\n \n pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             e: Option<&ast::Expr>)\n+                             return_expr: &ast::Expr,\n+                             retval_expr: Option<&ast::Expr>)\n                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n-    let dest = match (fcx.llretslotptr.get(), e) {\n-        (Some(_), Some(e)) => {\n-            let ret_ty = expr_ty(bcx, &*e);\n+    let dest = match (fcx.llretslotptr.get(), retval_expr) {\n+        (Some(_), Some(retval_expr)) => {\n+            let ret_ty = expr_ty(bcx, &*retval_expr);\n             expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(ret_ty), \"ret_slot\"))\n         }\n         _ => expr::Ignore,\n     };\n-    if let Some(x) = e {\n+    if let Some(x) = retval_expr {\n         bcx = expr::trans_into(bcx, &*x, dest);\n         match dest {\n             expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n@@ -486,7 +491,7 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n     let cleanup_llbb = fcx.return_exit_block();\n-    Br(bcx, cleanup_llbb);\n+    Br(bcx, cleanup_llbb, return_expr.debug_loc());\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "2edac5d0d154f667fe343a990056b95a51adaae1", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -188,15 +188,16 @@ use self::MemberOffset::*;\n use self::MemberDescriptionFactory::*;\n use self::RecursiveTypeDescription::*;\n use self::EnumDiscriminantInfo::*;\n-use self::DebugLocation::*;\n+use self::InternalDebugLocation::*;\n \n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::*;\n use metadata::csearch;\n use middle::subst::{self, Substs};\n use trans::{self, adt, machine, type_of};\n-use trans::common::*;\n+use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n+                    C_bytes, C_i32, C_i64, NormalizingUnboxedClosureTyper};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -650,7 +651,7 @@ macro_rules! return_if_metadata_created_in_meantime {\n pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n-    current_debug_location: Cell<DebugLocation>,\n+    current_debug_location: Cell<InternalDebugLocation>,\n     created_files: RefCell<FnvHashMap<String, DIFile>>,\n     created_enum_disr_types: RefCell<DefIdMap<DIType>>,\n \n@@ -940,13 +941,14 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    let variable_type = node_id_type(bcx, node_id);\n+    let variable_type = common::node_id_type(bcx, node_id);\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n \n     // env_pointer is the alloca containing the pointer to the environment,\n     // so it's type is **EnvironmentType. In order to find out the type of\n     // the environment we have to \"dereference\" two times.\n-    let llvm_env_data_type = val_ty(env_pointer).element_type().element_type();\n+    let llvm_env_data_type = common::val_ty(env_pointer).element_type()\n+                                                        .element_type();\n     let byte_offset_of_var_in_env = machine::llelement_offset(cx,\n                                                               llvm_env_data_type,\n                                                               env_index);\n@@ -1123,7 +1125,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,\n                                                     is_block: bool)\n-                                                 -> NodeInfo {\n+                                                 -> NodeIdAndSpan {\n     // A debug location needs two things:\n     // (1) A span (of which only the beginning will actually be used)\n     // (2) An AST node-id which will be used to look up the lexical scope\n@@ -1173,12 +1175,56 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    NodeInfo {\n+    NodeIdAndSpan {\n         id: node_id,\n         span: cleanup_span\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum DebugLoc {\n+    At(ast::NodeId, Span),\n+    None\n+}\n+\n+impl DebugLoc {\n+    pub fn apply(&self, fcx: &FunctionContext) {\n+        match *self {\n+            DebugLoc::At(node_id, span) => {\n+                set_source_location(fcx, node_id, span);\n+            }\n+            DebugLoc::None => {\n+                clear_source_location(fcx);\n+            }\n+        }\n+    }\n+}\n+\n+pub trait ToDebugLoc {\n+    fn debug_loc(&self) -> DebugLoc;\n+}\n+\n+impl ToDebugLoc for ast::Expr {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for NodeIdAndSpan {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for Option<NodeIdAndSpan> {\n+    fn debug_loc(&self) -> DebugLoc {\n+        match *self {\n+            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n+            None => DebugLoc::None\n+        }\n+    }\n+}\n+\n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n@@ -1202,9 +1248,9 @@ pub fn set_source_location(fcx: &FunctionContext,\n                 let loc = span_start(cx, span);\n                 let scope = scope_metadata(fcx, node_id, span);\n \n-                set_debug_location(cx, DebugLocation::new(scope,\n-                                                          loc.line,\n-                                                          loc.col.to_uint()));\n+                set_debug_location(cx, InternalDebugLocation::new(scope,\n+                                                                  loc.line,\n+                                                                  loc.col.to_uint()));\n             } else {\n                 set_debug_location(cx, UnknownLocation);\n             }\n@@ -1714,9 +1760,9 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         )\n     };\n \n-    set_debug_location(cx, DebugLocation::new(scope_metadata,\n-                                              loc.line,\n-                                              loc.col.to_uint()));\n+    set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n+                                                      loc.line,\n+                                                      loc.col.to_uint()));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),\n@@ -3095,13 +3141,13 @@ impl MetadataCreationResult {\n }\n \n #[derive(Copy, PartialEq)]\n-enum DebugLocation {\n+enum InternalDebugLocation {\n     KnownLocation { scope: DIScope, line: uint, col: uint },\n     UnknownLocation\n }\n \n-impl DebugLocation {\n-    fn new(scope: DIScope, line: uint, col: uint) -> DebugLocation {\n+impl InternalDebugLocation {\n+    fn new(scope: DIScope, line: uint, col: uint) -> InternalDebugLocation {\n         KnownLocation {\n             scope: scope,\n             line: line,\n@@ -3110,7 +3156,7 @@ impl DebugLocation {\n     }\n }\n \n-fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n+fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n     if debug_location == debug_context(cx).current_debug_location.get() {\n         return;\n     }"}, {"sha": "6d7c70ff035877ab95701429e6bbf8c9f8ba0671", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -46,7 +46,7 @@ use trans::build::*;\n use trans::cleanup::{self, CleanupMethods};\n use trans::common::*;\n use trans::datum::*;\n-use trans::debuginfo;\n+use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::glue;\n use trans::machine;\n use trans::meth;\n@@ -779,7 +779,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let expected = Call(bcx,\n                                 expect,\n                                 &[bounds_check, C_bool(ccx, false)],\n-                                None);\n+                                None,\n+                                index_expr.debug_loc());\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n                                                      index_expr.span,\n@@ -890,10 +891,10 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_into(bcx, &**e, Ignore)\n         }\n         ast::ExprBreak(label_opt) => {\n-            controlflow::trans_break(bcx, expr.id, label_opt)\n+            controlflow::trans_break(bcx, expr, label_opt)\n         }\n         ast::ExprAgain(label_opt) => {\n-            controlflow::trans_cont(bcx, expr.id, label_opt)\n+            controlflow::trans_cont(bcx, expr, label_opt)\n         }\n         ast::ExprRet(ref ex) => {\n             // Check to see if the return expression itself is reachable.\n@@ -905,7 +906,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             if reachable {\n-                controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n+                controlflow::trans_ret(bcx, expr, ex.as_ref().map(|e| &**e))\n             } else {\n                 // If it's not reachable, just translate the inner expression\n                 // directly. This avoids having to manage a return slot when\n@@ -921,7 +922,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::ExprWhile(ref cond, ref body, _) => {\n-            controlflow::trans_while(bcx, expr.id, &**cond, &**body)\n+            controlflow::trans_while(bcx, expr, &**cond, &**body)\n         }\n         ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n             controlflow::trans_for(bcx,\n@@ -931,7 +932,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    &**body)\n         }\n         ast::ExprLoop(ref body, _) => {\n-            controlflow::trans_loop(bcx, expr.id, &**body)\n+            controlflow::trans_loop(bcx, expr, &**body)\n         }\n         ast::ExprAssign(ref dst, ref src) => {\n             let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n@@ -960,7 +961,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = glue::drop_ty(bcx,\n                                     dst_datum.val,\n                                     dst_datum.ty,\n-                                    Some(NodeInfo { id: expr.id, span: expr.span }));\n+                                    expr.debug_loc());\n                 src_datum.store_to(bcx, dst_datum.val)\n             } else {\n                 src_datum.store_to(bcx, dst_datum.val)\n@@ -1078,7 +1079,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                       &numbered_fields[],\n                       None,\n                       dest,\n-                      Some(NodeInfo { id: expr.id, span: expr.span }))\n+                      expr.debug_loc())\n         }\n         ast::ExprLit(ref lit) => {\n             match lit.node {\n@@ -1417,7 +1418,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   numbered_fields.as_slice(),\n                   optbase,\n                   dest,\n-                  Some(NodeInfo { id: expr_id, span: expr_span }))\n+                  DebugLoc::At(expr_id, expr_span))\n     })\n }\n \n@@ -1448,18 +1449,13 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                  fields: &[(uint, &ast::Expr)],\n                                  optbase: Option<StructBaseInfo<'a, 'tcx>>,\n                                  dest: Dest,\n-                                 source_location: Option<NodeInfo>)\n+                                 debug_location: DebugLoc)\n                                  -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n     let repr = adt::represent_type(bcx.ccx(), ty);\n \n-    match source_location {\n-        Some(src_loc) => debuginfo::set_source_location(bcx.fcx,\n-                                                        src_loc.id,\n-                                                        src_loc.span),\n-        None => {}\n-    };\n+    debug_location.apply(bcx.fcx);\n \n     // If we don't care about the result, just make a\n     // temporary stack slot\n@@ -1494,12 +1490,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    match source_location {\n-        Some(src_loc) => debuginfo::set_source_location(bcx.fcx,\n-                                                        src_loc.id,\n-                                                        src_loc.span),\n-        None => {}\n-    };\n+    debug_location.apply(bcx.fcx);\n \n     if ty::type_is_simd(bcx.tcx(), ty) {\n         // This is the constructor of a SIMD type, such types are\n@@ -1540,7 +1531,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     match dest {\n         SaveIn(_) => bcx,\n         Ignore => {\n-            bcx = glue::drop_ty(bcx, addr, ty, source_location);\n+            bcx = glue::drop_ty(bcx, addr, ty, debug_location);\n             base::call_lifetime_end(bcx, addr);\n             bcx\n         }\n@@ -1579,20 +1570,22 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let un_ty = expr_ty(bcx, expr);\n \n+    let debug_loc = expr.debug_loc();\n+\n     match op {\n         ast::UnNot => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-            let llresult = Not(bcx, datum.to_llscalarish(bcx));\n+            let llresult = Not(bcx, datum.to_llscalarish(bcx), debug_loc);\n             immediate_rvalue_bcx(bcx, llresult, un_ty).to_expr_datumblock()\n         }\n         ast::UnNeg => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n             let val = datum.to_llscalarish(bcx);\n             let llneg = {\n                 if ty::type_is_fp(un_ty) {\n-                    FNeg(bcx, val)\n+                    FNeg(bcx, val, debug_loc)\n                 } else {\n-                    Neg(bcx, val)\n+                    Neg(bcx, val, debug_loc)\n                 }\n             };\n             immediate_rvalue_bcx(bcx, llneg, un_ty).to_expr_datumblock()\n@@ -1691,56 +1684,69 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let rhs = base::cast_shift_expr_rhs(bcx, op, lhs, rhs);\n \n+    let binop_debug_loc = binop_expr.debug_loc();\n+\n     let mut bcx = bcx;\n     let val = match op {\n       ast::BiAdd => {\n-        if is_float { FAdd(bcx, lhs, rhs) }\n-        else { Add(bcx, lhs, rhs) }\n+        if is_float {\n+            FAdd(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            Add(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiSub => {\n-        if is_float { FSub(bcx, lhs, rhs) }\n-        else { Sub(bcx, lhs, rhs) }\n+        if is_float {\n+            FSub(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            Sub(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiMul => {\n-        if is_float { FMul(bcx, lhs, rhs) }\n-        else { Mul(bcx, lhs, rhs) }\n+        if is_float {\n+            FMul(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            Mul(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiDiv => {\n         if is_float {\n-            FDiv(bcx, lhs, rhs)\n+            FDiv(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp /0 is NaN\n             bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n                                                   op, lhs, rhs, rhs_t);\n             if is_signed {\n-                SDiv(bcx, lhs, rhs)\n+                SDiv(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n-                UDiv(bcx, lhs, rhs)\n+                UDiv(bcx, lhs, rhs, binop_debug_loc)\n             }\n         }\n       }\n       ast::BiRem => {\n         if is_float {\n-            FRem(bcx, lhs, rhs)\n+            FRem(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp %0 is NaN\n             bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n                                                   op, lhs, rhs, rhs_t);\n             if is_signed {\n-                SRem(bcx, lhs, rhs)\n+                SRem(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n-                URem(bcx, lhs, rhs)\n+                URem(bcx, lhs, rhs, binop_debug_loc)\n             }\n         }\n       }\n-      ast::BiBitOr => Or(bcx, lhs, rhs),\n-      ast::BiBitAnd => And(bcx, lhs, rhs),\n-      ast::BiBitXor => Xor(bcx, lhs, rhs),\n-      ast::BiShl => Shl(bcx, lhs, rhs),\n+      ast::BiBitOr => Or(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiBitAnd => And(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiBitXor => Xor(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiShl => Shl(bcx, lhs, rhs, binop_debug_loc),\n       ast::BiShr => {\n         if is_signed {\n-            AShr(bcx, lhs, rhs)\n-        } else { LShr(bcx, lhs, rhs) }\n+            AShr(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            LShr(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_scalar(rhs_t) {\n@@ -1786,8 +1792,8 @@ fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let before_rhs = fcx.new_id_block(\"before_rhs\", b.id);\n \n     match op {\n-      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb),\n-      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb)\n+      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb, DebugLoc::None),\n+      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb, DebugLoc::None)\n     }\n \n     let DatumBlock {bcx: past_rhs, datum: rhs} = trans(before_rhs, b);\n@@ -1797,7 +1803,7 @@ fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return immediate_rvalue_bcx(join, lhs, binop_ty).to_expr_datumblock();\n     }\n \n-    Br(past_rhs, join.llbb);\n+    Br(past_rhs, join.llbb, DebugLoc::None);\n     let phi = Phi(join, Type::i1(bcx.ccx()), &[lhs, rhs],\n                   &[past_lhs.llbb, past_rhs.llbb]);\n "}, {"sha": "fb2ee55940d0956d94c2423705243b9d33959682", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -29,7 +29,7 @@ use trans::cleanup::CleanupMethods;\n use trans::consts;\n use trans::common::*;\n use trans::datum;\n-use trans::debuginfo;\n+use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::machine::*;\n use trans::tvec;\n@@ -106,7 +106,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n                            t: Ty<'tcx>,\n-                           source_location: Option<NodeInfo>)\n+                           debug_loc: DebugLoc)\n                            -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n@@ -121,25 +121,20 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             v\n         };\n \n-        match source_location {\n-            Some(sl) => debuginfo::set_source_location(bcx.fcx, sl.id, sl.span),\n-            None => debuginfo::clear_source_location(bcx.fcx)\n-        };\n-\n-        Call(bcx, glue, &[ptr], None);\n+        Call(bcx, glue, &[ptr], None, debug_loc);\n     }\n     bcx\n }\n \n pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      v: ValueRef,\n                                      t: Ty<'tcx>,\n-                                     source_location: Option<NodeInfo>)\n+                                     debug_loc: DebugLoc)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     store_ty(bcx, v, vp, t);\n-    drop_ty(bcx, vp, t, source_location)\n+    drop_ty(bcx, vp, t, debug_loc)\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n@@ -295,7 +290,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, DebugLoc::None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n@@ -331,7 +326,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // Return the sum of sizes and max of aligns.\n-            let size = Add(bcx, sized_size, unsized_size);\n+            let size = Add(bcx, sized_size, unsized_size, DebugLoc::None);\n             let align = Select(bcx,\n                                ICmp(bcx, llvm::IntULT, sized_align, unsized_align),\n                                sized_align,\n@@ -353,7 +348,8 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n             let unit_align = llalign_of_min(bcx.ccx(), llunit_ty);\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), unit_align))\n+            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size), DebugLoc::None),\n+             C_uint(bcx.ccx(), unit_align))\n         }\n         _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n                                     bcx.ty_to_string(t))[])\n@@ -384,7 +380,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         Call(bcx,\n                              dtor,\n                              &[PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))],\n-                             None);\n+                             None,\n+                             DebugLoc::None);\n                         bcx\n                     })\n                 }\n@@ -393,7 +390,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, v0, content_ty, None);\n+                        let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n                         let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n                         let info = Load(bcx, info);\n                         let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n@@ -406,7 +403,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, llbox, content_ty, None);\n+                        let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n                         trans_exchange_free_ty(bcx, llbox, content_ty)\n                     })\n                 }\n@@ -437,14 +434,16 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                 }\n                 ty::NoDtor => {\n                     // No dtor? Just the default case\n-                    iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))\n+                    iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n                 }\n             }\n         }\n-        ty::ty_unboxed_closure(..) => iter_structural_ty(bcx,\n-                                                         v0,\n-                                                         t,\n-                                                         |bb, vv, tt| drop_ty(bb, vv, tt, None)),\n+        ty::ty_unboxed_closure(..) => {\n+            iter_structural_ty(bcx,\n+                               v0,\n+                               t,\n+                               |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n+        }\n         ty::ty_trait(..) => {\n             // No need to do a null check here (as opposed to the Box<trait case\n             // above), because this happens for a trait field in an unsized\n@@ -456,7 +455,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n             Call(bcx,\n                  dtor,\n                  &[PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n-                 None);\n+                 None,\n+                 DebugLoc::None);\n             bcx\n         },\n         ty::ty_vec(_, None) | ty::ty_str => {\n@@ -465,9 +465,11 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         },\n         _ => {\n             assert!(type_is_sized(bcx.tcx(), t));\n-            if type_needs_drop(bcx.tcx(), t) &&\n-                ty::type_is_structural(t) {\n-                iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))\n+            if type_needs_drop(bcx.tcx(), t) && ty::type_is_structural(t) {\n+                iter_structural_ty(bcx,\n+                                   v0,\n+                                   t,\n+                                   |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n             } else {\n                 bcx\n             }\n@@ -559,7 +561,7 @@ fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n \n     let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n     let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n \n     llfn\n }"}, {"sha": "9bee2c5bbc61c69ecd3410f4c0297d645cf3e4ba", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 279, "deletions": 93, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -21,6 +21,7 @@ use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum::*;\n+use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::glue;\n use trans::type_of::*;\n@@ -149,9 +150,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             args: callee::CallArgs<'a, 'tcx>,\n                                             dest: expr::Dest,\n                                             substs: subst::Substs<'tcx>,\n-                                            call_info: NodeInfo)\n-                                            -> Result<'blk, 'tcx>\n-{\n+                                            call_info: NodeIdAndSpan)\n+                                            -> Result<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n@@ -270,10 +270,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     fcx.pop_custom_cleanup_scope(cleanup_scope);\n \n+    let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n+\n     // These are the only intrinsic functions that diverge.\n     if name.get() == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n-        Call(bcx, llfn, &[], None);\n+        Call(bcx, llfn, &[], None, call_debug_location);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n     } else if name.get() == \"unreachable\" {\n@@ -304,11 +306,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n     let llval = match (simple, name.get()) {\n         (Some(llfn), _) => {\n-            Call(bcx, llfn, llargs.as_slice(), None)\n+            Call(bcx, llfn, llargs.as_slice(), None, call_debug_location)\n         }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(bcx, llfn, &[], None)\n+            Call(bcx, llfn, &[], None, call_debug_location)\n         }\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -384,29 +386,63 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n \n         (_, \"copy_nonoverlapping_memory\") => {\n-            copy_intrinsic(bcx, false, false, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           false,\n+                           false,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"copy_memory\") => {\n-            copy_intrinsic(bcx, true, false, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           true,\n+                           false,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"set_memory\") => {\n-            memset_intrinsic(bcx, false, *substs.types.get(FnSpace, 0),\n-                             llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx,\n+                             false,\n+                             *substs.types.get(FnSpace, 0),\n+                             llargs[0],\n+                             llargs[1],\n+                             llargs[2],\n+                             call_debug_location)\n         }\n \n         (_, \"volatile_copy_nonoverlapping_memory\") => {\n-            copy_intrinsic(bcx, false, true, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           false,\n+                           true,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"volatile_copy_memory\") => {\n-            copy_intrinsic(bcx, true, true, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           true,\n+                           true,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"volatile_set_memory\") => {\n-            memset_intrinsic(bcx, true, *substs.types.get(FnSpace, 0),\n-                             llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx,\n+                             true,\n+                             *substs.types.get(FnSpace, 0),\n+                             llargs[0],\n+                             llargs[1],\n+                             llargs[2],\n+                             call_debug_location)\n         }\n         (_, \"volatile_load\") => {\n             VolatileLoad(bcx, llargs[0])\n@@ -416,93 +452,208 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         },\n \n-        (_, \"ctlz8\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\", llargs[0]),\n-        (_, \"ctlz16\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\", llargs[0]),\n-        (_, \"ctlz32\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\", llargs[0]),\n-        (_, \"ctlz64\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\", llargs[0]),\n-        (_, \"cttz8\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\", llargs[0]),\n-        (_, \"cttz16\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\", llargs[0]),\n-        (_, \"cttz32\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\", llargs[0]),\n-        (_, \"cttz64\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\", llargs[0]),\n+        (_, \"ctlz8\") => count_zeros_intrinsic(bcx,\n+                                              \"llvm.ctlz.i8\",\n+                                              llargs[0],\n+                                              call_debug_location),\n+        (_, \"ctlz16\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.ctlz.i16\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"ctlz32\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.ctlz.i32\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"ctlz64\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.ctlz.i64\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"cttz8\") => count_zeros_intrinsic(bcx,\n+                                              \"llvm.cttz.i8\",\n+                                              llargs[0],\n+                                              call_debug_location),\n+        (_, \"cttz16\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.cttz.i16\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"cttz32\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.cttz.i32\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"cttz64\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.cttz.i64\",\n+                                               llargs[0],\n+                                               call_debug_location),\n \n         (_, \"i8_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i16_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i32_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i64_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n \n         (_, \"u8_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u16_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u32_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u64_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i8_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i16_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i32_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i64_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u8_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u16_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u32_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u64_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i8_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i16_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i32_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i64_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u8_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i8\", ret_ty,\n-                                    llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u16_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i16\", ret_ty,\n-                                    llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u32_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i32\", ret_ty,\n-                                    llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u64_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i64\", ret_ty,\n-                                    llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"return_address\") => {\n             if !fcx.caller_expects_out_pointer {\n                 tcx.sess.span_err(call_info.span,\n@@ -609,7 +760,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // If we made a temporary stack slot, let's clean it up\n     match dest {\n         expr::Ignore => {\n-            bcx = glue::drop_ty(bcx, llresult, ret_ty, Some(call_info));\n+            bcx = glue::drop_ty(bcx, llresult, ret_ty, call_debug_location);\n         }\n         expr::SaveIn(_) => {}\n     }\n@@ -618,8 +769,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n }\n \n fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              allow_overlap: bool, volatile: bool, tp_ty: Ty<'tcx>,\n-                              dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n+                              allow_overlap: bool,\n+                              volatile: bool,\n+                              tp_ty: Ty<'tcx>,\n+                              dst: ValueRef,\n+                              src: ValueRef,\n+                              count: ValueRef,\n+                              call_debug_location: DebugLoc)\n+                              -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -643,12 +800,25 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let src_ptr = PointerCast(bcx, src, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n \n-    Call(bcx, llfn, &[dst_ptr, src_ptr, Mul(bcx, size, count), align,\n-                      C_bool(ccx, volatile)], None)\n+    Call(bcx,\n+         llfn,\n+         &[dst_ptr,\n+           src_ptr,\n+           Mul(bcx, size, count, DebugLoc::None),\n+           align,\n+           C_bool(ccx, volatile)],\n+         None,\n+         call_debug_location)\n }\n \n-fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, volatile: bool, tp_ty: Ty<'tcx>,\n-                                dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n+fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                volatile: bool,\n+                                tp_ty: Ty<'tcx>,\n+                                dst: ValueRef,\n+                                val: ValueRef,\n+                                count: ValueRef,\n+                                call_debug_location: DebugLoc)\n+                                -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -662,22 +832,38 @@ fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, volatile: bool, tp_ty: T\n     let dst_ptr = PointerCast(bcx, dst, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n \n-    Call(bcx, llfn, &[dst_ptr, val, Mul(bcx, size, count), align,\n-                      C_bool(ccx, volatile)], None)\n+    Call(bcx,\n+         llfn,\n+         &[dst_ptr,\n+           val,\n+           Mul(bcx, size, count, DebugLoc::None),\n+           align,\n+           C_bool(ccx, volatile)],\n+         None,\n+         call_debug_location)\n }\n \n-fn count_zeros_intrinsic(bcx: Block, name: &'static str, val: ValueRef) -> ValueRef {\n+fn count_zeros_intrinsic(bcx: Block,\n+                         name: &'static str,\n+                         val: ValueRef,\n+                         call_debug_location: DebugLoc)\n+                         -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n-    Call(bcx, llfn, &[val, y], None)\n+    Call(bcx, llfn, &[val, y], None, call_debug_location)\n }\n \n-fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, name: &'static str,\n-                                       t: Ty<'tcx>, a: ValueRef, b: ValueRef) -> ValueRef {\n+fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       name: &'static str,\n+                                       t: Ty<'tcx>,\n+                                       a: ValueRef,\n+                                       b: ValueRef,\n+                                       call_debug_location: DebugLoc)\n+                                       -> ValueRef {\n     let llfn = bcx.ccx().get_intrinsic(&name);\n \n     // Convert `i1` to a `bool`, and write it to the out parameter\n-    let val = Call(bcx, llfn, &[a, b], None);\n+    let val = Call(bcx, llfn, &[a, b], None, call_debug_location);\n     let result = ExtractValue(bcx, val, 0);\n     let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n     let ret = C_undef(type_of::type_of(bcx.ccx(), t));"}, {"sha": "d1b723d6457a20df2808b2a7fb64f80307c386e8", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -24,6 +24,7 @@ use trans::callee;\n use trans::cleanup;\n use trans::common::*;\n use trans::datum::*;\n+use trans::debuginfo::DebugLoc;\n use trans::expr::{SaveIn, Ignore};\n use trans::expr;\n use trans::glue;\n@@ -676,7 +677,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n                            ArgVals(llargs.as_slice()),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, sig.output);\n+    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n     (llfn, method_bare_fn_ty)\n }"}, {"sha": "06bc19f45a47e6bbd305ebc5cae8f10f6903d37a", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ef3a032bd842c86bbc93963c769b144809ef2/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=a55ef3a032bd842c86bbc93963c769b144809ef2", "patch": "@@ -21,6 +21,7 @@ use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n+use trans::debuginfo::DebugLoc;\n use trans::expr::{Dest, Ignore, SaveIn};\n use trans::expr;\n use trans::glue;\n@@ -58,7 +59,11 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let dataptr = get_dataptr(bcx, vptr);\n         let bcx = if type_needs_drop(tcx, unit_ty) {\n             let len = get_len(bcx, vptr);\n-            iter_vec_raw(bcx, dataptr, unit_ty, len, |bb, vv, tt| glue::drop_ty(bb, vv, tt, None))\n+            iter_vec_raw(bcx,\n+                         dataptr,\n+                         unit_ty,\n+                         len,\n+                         |bb, vv, tt| glue::drop_ty(bb, vv, tt, DebugLoc::None))\n         } else {\n             bcx\n         };\n@@ -71,7 +76,7 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0u));\n                 with_cond(bcx, not_empty, |bcx| {\n                     let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n-                    let size = Mul(bcx, C_uint(ccx, unit_size), len);\n+                    let size = Mul(bcx, C_uint(ccx, unit_size), len, DebugLoc::None);\n                     glue::trans_exchange_free_dyn(bcx, dataptr, size, llalign)\n                 })\n             } else {\n@@ -420,14 +425,14 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let cond_bcx = fcx.new_temp_block(\"expr_repeat: loop cond\");\n     let body_bcx = fcx.new_temp_block(\"expr_repeat: body: set\");\n     let inc_bcx = fcx.new_temp_block(\"expr_repeat: body: inc\");\n-    Br(bcx, loop_bcx.llbb);\n+    Br(bcx, loop_bcx.llbb, DebugLoc::None);\n \n     let loop_counter = {\n         // i = 0\n         let i = alloca(loop_bcx, bcx.ccx().int_type(), \"__i\");\n         Store(loop_bcx, C_uint(bcx.ccx(), 0u), i);\n \n-        Br(loop_bcx, cond_bcx.llbb);\n+        Br(loop_bcx, cond_bcx.llbb, DebugLoc::None);\n         i\n     };\n \n@@ -436,7 +441,7 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         let rhs = count;\n         let cond_val = ICmp(cond_bcx, llvm::IntULT, lhs, rhs);\n \n-        CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb);\n+        CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n     }\n \n     { // loop body\n@@ -448,15 +453,15 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         };\n         let body_bcx = f(body_bcx, lleltptr, vt.unit_ty);\n \n-        Br(body_bcx, inc_bcx.llbb);\n+        Br(body_bcx, inc_bcx.llbb, DebugLoc::None);\n     }\n \n     { // i += 1\n         let i = Load(inc_bcx, loop_counter);\n-        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1u));\n+        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1u), DebugLoc::None);\n         Store(inc_bcx, plusone, loop_counter);\n \n-        Br(inc_bcx, cond_bcx.llbb);\n+        Br(inc_bcx, cond_bcx.llbb, DebugLoc::None);\n     }\n \n     next_bcx\n@@ -484,19 +489,19 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         // Now perform the iteration.\n         let header_bcx = fcx.new_temp_block(\"iter_vec_loop_header\");\n-        Br(bcx, header_bcx.llbb);\n+        Br(bcx, header_bcx.llbb, DebugLoc::None);\n         let data_ptr =\n             Phi(header_bcx, val_ty(data_ptr), &[data_ptr], &[bcx.llbb]);\n         let not_yet_at_end =\n             ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr);\n         let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n         let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n-        CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n+        CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n         let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n                                                &[C_int(bcx.ccx(), 1i)]),\n                          body_bcx.llbb);\n-        Br(body_bcx, header_bcx.llbb);\n+        Br(body_bcx, header_bcx.llbb, DebugLoc::None);\n         next_bcx\n     }\n }"}]}