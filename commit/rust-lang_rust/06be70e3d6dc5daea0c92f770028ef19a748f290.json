{"sha": "06be70e3d6dc5daea0c92f770028ef19a748f290", "node_id": "C_kwDOAAsO6NoAKDA2YmU3MGUzZDZkYzVkYWVhMGM5MmY3NzAwMjhlZjE5YTc0OGYyOTA", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-12-15T12:09:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-15T12:09:37Z"}, "message": "Implement simd_gather and simd_scatter (#1309)\n\nThese are the last remaining platform intrinsics necessary for portable-simd.", "tree": {"sha": "8902f0fcc1ea649b8ba59eb2dacc8b3613787b31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8902f0fcc1ea649b8ba59eb2dacc8b3613787b31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06be70e3d6dc5daea0c92f770028ef19a748f290", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjmw6BCRBK7hj4Ov3rIwAAR1wIAHLhaifsBx4WBCxrfxWJaS8l\nfaPuJFL3ueUxDyUwpDB2MbnID40J4V82crLlxte++GvTeBZYXlW+ihXhnCpxvWC3\ncxK0wlsoVD2mAv0OUylq/5slYLbNd3xX78QFHjlUOkXtOiuuoy8VgtvZe5COb1bd\nlB+dx04+2L1bRM+wODOq4fv55vrFv/Ii6bkvECYLHCuGsBTAgefvzTfpiHRUNqCQ\nBymQvedC1aBdvb0K96aW2h5uHxgR+mWNfbMq3r4RAi9VWtRTssFPgLHIcbK5ysnZ\nxgCy55Kqaao8Awee6zz0LYvYguiPIAndUcKsjOpmBb0XEyut1AKPo7l9wF/46nA=\n=glFN\n-----END PGP SIGNATURE-----\n", "payload": "tree 8902f0fcc1ea649b8ba59eb2dacc8b3613787b31\nparent 0865e5a45295b149757da230e7e8d5d4b7b7fc9c\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1671106177 +0100\ncommitter GitHub <noreply@github.com> 1671106177 +0100\n\nImplement simd_gather and simd_scatter (#1309)\n\nThese are the last remaining platform intrinsics necessary for portable-simd."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06be70e3d6dc5daea0c92f770028ef19a748f290", "html_url": "https://github.com/rust-lang/rust/commit/06be70e3d6dc5daea0c92f770028ef19a748f290", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06be70e3d6dc5daea0c92f770028ef19a748f290/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0865e5a45295b149757da230e7e8d5d4b7b7fc9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0865e5a45295b149757da230e7e8d5d4b7b7fc9c", "html_url": "https://github.com/rust-lang/rust/commit/0865e5a45295b149757da230e7e8d5d4b7b7fc9c"}], "stats": {"total": 111, "additions": 74, "deletions": 37}, "files": [{"sha": "bdf727666bedff5a1bd149eb6466aac9dc4be716", "filename": "patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0865e5a45295b149757da230e7e8d5d4b7b7fc9c/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0865e5a45295b149757da230e7e8d5d4b7b7fc9c/patches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=0865e5a45295b149757da230e7e8d5d4b7b7fc9c", "patch": "@@ -1,35 +0,0 @@\n-From b742f03694b920cc14400727d54424e8e1b60928 Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Thu, 18 Nov 2021 19:28:40 +0100\n-Subject: [PATCH] Disable unsupported tests\n-\n----\n- crates/core_simd/src/elements/int.rs     | 8 ++++++++\n- crates/core_simd/src/elements/uint.rs    | 4 ++++\n- crates/core_simd/src/masks/full_masks.rs | 6 ++++++\n- crates/core_simd/src/vector.rs           | 2 ++\n- crates/core_simd/tests/masks.rs          | 3 ---\n- 5 files changed, 20 insertions(+), 3 deletions(-)\n-\n-diff --git a/crates/core_simd/src/vector.rs b/crates/core_simd/src/vector.rs\n-index e8e8f68..7173c24 100644\n---- a/crates/core_simd/src/vector.rs\n-+++ b/crates/core_simd/src/vector.rs\n-@@ -250,6 +250,7 @@ where\n-         unsafe { intrinsics::simd_cast(self) }\n-     }\n- \n-+    /*\n-     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-     /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n-     ///\n-@@ -473,6 +474,7 @@ where\n-         // Safety: The caller is responsible for upholding all invariants\n-         unsafe { intrinsics::simd_scatter(self, dest, enable.to_int()) }\n-     }\n-+    */\n- }\n- \n- impl<T, const LANES: usize> Copy for Simd<T, LANES>\n--- \n-2.25.1"}, {"sha": "62ea2214ab44e24e8d89a161d16e60d7f8c24a08", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 74, "deletions": 2, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/06be70e3d6dc5daea0c92f770028ef19a748f290/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06be70e3d6dc5daea0c92f770028ef19a748f290/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=06be70e3d6dc5daea0c92f770028ef19a748f290", "patch": "@@ -801,8 +801,80 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n         }\n \n-        // simd_scatter\n-        // simd_gather\n+        sym::simd_gather => {\n+            intrinsic_args!(fx, args => (val, ptr, mask); intrinsic);\n+\n+            let (val_lane_count, val_lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n+            let (ptr_lane_count, _ptr_lane_ty) = ptr.layout().ty.simd_size_and_type(fx.tcx);\n+            let (mask_lane_count, _mask_lane_ty) = mask.layout().ty.simd_size_and_type(fx.tcx);\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+            assert_eq!(val_lane_count, ptr_lane_count);\n+            assert_eq!(val_lane_count, mask_lane_count);\n+            assert_eq!(val_lane_count, ret_lane_count);\n+\n+            let lane_clif_ty = fx.clif_type(val_lane_ty).unwrap();\n+            let ret_lane_layout = fx.layout_of(ret_lane_ty);\n+\n+            for lane_idx in 0..ptr_lane_count {\n+                let val_lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n+                let ptr_lane = ptr.value_lane(fx, lane_idx).load_scalar(fx);\n+                let mask_lane = mask.value_lane(fx, lane_idx).load_scalar(fx);\n+\n+                let if_enabled = fx.bcx.create_block();\n+                let if_disabled = fx.bcx.create_block();\n+                let next = fx.bcx.create_block();\n+                let res_lane = fx.bcx.append_block_param(next, lane_clif_ty);\n+\n+                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n+                fx.bcx.ins().jump(if_disabled, &[]);\n+                fx.bcx.seal_block(if_enabled);\n+                fx.bcx.seal_block(if_disabled);\n+\n+                fx.bcx.switch_to_block(if_enabled);\n+                let res = fx.bcx.ins().load(lane_clif_ty, MemFlags::trusted(), ptr_lane, 0);\n+                fx.bcx.ins().jump(next, &[res]);\n+\n+                fx.bcx.switch_to_block(if_disabled);\n+                fx.bcx.ins().jump(next, &[val_lane]);\n+\n+                fx.bcx.seal_block(next);\n+                fx.bcx.switch_to_block(next);\n+\n+                ret.place_lane(fx, lane_idx)\n+                    .write_cvalue(fx, CValue::by_val(res_lane, ret_lane_layout));\n+            }\n+        }\n+\n+        sym::simd_scatter => {\n+            intrinsic_args!(fx, args => (val, ptr, mask); intrinsic);\n+\n+            let (val_lane_count, _val_lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n+            let (ptr_lane_count, _ptr_lane_ty) = ptr.layout().ty.simd_size_and_type(fx.tcx);\n+            let (mask_lane_count, _mask_lane_ty) = mask.layout().ty.simd_size_and_type(fx.tcx);\n+            assert_eq!(val_lane_count, ptr_lane_count);\n+            assert_eq!(val_lane_count, mask_lane_count);\n+\n+            for lane_idx in 0..ptr_lane_count {\n+                let val_lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n+                let ptr_lane = ptr.value_lane(fx, lane_idx).load_scalar(fx);\n+                let mask_lane = mask.value_lane(fx, lane_idx).load_scalar(fx);\n+\n+                let if_enabled = fx.bcx.create_block();\n+                let next = fx.bcx.create_block();\n+\n+                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n+                fx.bcx.ins().jump(next, &[]);\n+                fx.bcx.seal_block(if_enabled);\n+\n+                fx.bcx.switch_to_block(if_enabled);\n+                fx.bcx.ins().store(MemFlags::trusted(), val_lane, ptr_lane, 0);\n+                fx.bcx.ins().jump(next, &[]);\n+\n+                fx.bcx.seal_block(next);\n+                fx.bcx.switch_to_block(next);\n+            }\n+        }\n+\n         _ => {\n             fx.tcx.sess.span_fatal(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n         }"}]}