{"sha": "10befcd9a4d9f68e2dbec84c4a86450a021143fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYmVmY2Q5YTRkOWY2OGUyZGJlYzg0YzRhODY0NTBhMDIxMTQzZmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-18T00:23:31Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-18T00:23:31Z"}, "message": "Add type parameters to tag types", "tree": {"sha": "7485ae8b66f3349e3987b480d4be44b34e01af5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7485ae8b66f3349e3987b480d4be44b34e01af5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10befcd9a4d9f68e2dbec84c4a86450a021143fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10befcd9a4d9f68e2dbec84c4a86450a021143fb", "html_url": "https://github.com/rust-lang/rust/commit/10befcd9a4d9f68e2dbec84c4a86450a021143fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10befcd9a4d9f68e2dbec84c4a86450a021143fb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1", "html_url": "https://github.com/rust-lang/rust/commit/79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1"}], "stats": {"total": 133, "additions": 99, "deletions": 34}, "files": [{"sha": "9d336f221d8d5847cf1a38f72064be6833a4be18", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10befcd9a4d9f68e2dbec84c4a86450a021143fb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10befcd9a4d9f68e2dbec84c4a86450a021143fb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=10befcd9a4d9f68e2dbec84c4a86450a021143fb", "patch": "@@ -490,7 +490,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n         }\n         case (ty.ty_char) { ret T_char(); }\n         case (ty.ty_str) { ret T_ptr(T_str()); }\n-        case (ty.ty_tag(?tag_id)) {\n+        case (ty.ty_tag(?tag_id, _)) {\n             ret llvm.LLVMResolveTypeHandle(cx.tags.get(tag_id).th.llth);\n         }\n         case (ty.ty_box(?t)) {\n@@ -1445,7 +1445,9 @@ fn iter_structural_ty(@block_ctxt cx,\n                 i += 1;\n             }\n         }\n-        case (ty.ty_tag(?tid)) {\n+        case (ty.ty_tag(?tid, _)) {\n+            // TODO: type params!\n+\n             check (cx.fcx.ccx.tags.contains_key(tid));\n             auto info = cx.fcx.ccx.tags.get(tid);\n             auto n_variants = _vec.len[tup(ast.def_id,arity)](info.variants);"}, {"sha": "e8f5b04684dfb10be0beaa561bc7b556e8872128", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 66, "deletions": 21, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/10befcd9a4d9f68e2dbec84c4a86450a021143fb/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10befcd9a4d9f68e2dbec84c4a86450a021143fb/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=10befcd9a4d9f68e2dbec84c4a86450a021143fb", "patch": "@@ -32,7 +32,7 @@ tag sty {\n     ty_machine(util.common.ty_mach);\n     ty_char;\n     ty_str;\n-    ty_tag(ast.def_id);\n+    ty_tag(ast.def_id, vec[@t]);\n     ty_box(@t);\n     ty_vec(@t);\n     ty_tup(vec[@t]);\n@@ -42,7 +42,7 @@ tag sty {\n     ty_obj(vec[method]);\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var\n-    ty_param(ast.def_id);                           // fn type param\n+    ty_param(ast.def_id);                           // fn/tag type param\n     ty_type;\n     ty_native;\n     // TODO: ty_fn_arg(@t), for a possibly-aliased function argument\n@@ -235,9 +235,14 @@ fn ty_to_str(&@t typ) -> str {\n             s = \"rec(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n-        case (ty_tag(_)) {\n+        case (ty_tag(_, ?tps)) {\n             // The user should never see this if the cname is set properly!\n             s = \"<tag>\";\n+            if (_vec.len[@t](tps) > 0u) {\n+                auto f = ty_to_str;\n+                auto strs = _vec.map[@t,str](f, tps);\n+                s += \"[\" + _str.connect(strs, \",\") + \"]\";\n+            }\n         }\n \n         case (ty_fn(?inputs, ?output)) {\n@@ -291,7 +296,6 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n         case (ty_machine(_))    { ret fld.fold_simple_ty(ty); }\n         case (ty_char)          { ret fld.fold_simple_ty(ty); }\n         case (ty_str)           { ret fld.fold_simple_ty(ty); }\n-        case (ty_tag(_))        { ret fld.fold_simple_ty(ty); }\n         case (ty_type)          { ret fld.fold_simple_ty(ty); }\n         case (ty_native)        { ret fld.fold_simple_ty(ty); }\n         case (ty_box(?subty)) {\n@@ -300,6 +304,13 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n         case (ty_vec(?subty)) {\n             ret rewrap(ty, ty_vec(fold_ty(fld, subty)));\n         }\n+        case (ty_tag(?tid, ?subtys)) {\n+            let vec[@t] new_subtys = vec();\n+            for (@t subty in subtys) {\n+                new_subtys += vec(fold_ty(fld, subty));\n+            }\n+            ret rewrap(ty, ty_tag(tid, new_subtys));\n+        }\n         case (ty_tup(?subtys)) {\n             let vec[@t] new_subtys = vec();\n             for (@t subty in subtys) {\n@@ -364,23 +375,23 @@ fn type_is_nil(@t ty) -> bool {\n \n fn type_is_structural(@t ty) -> bool {\n     alt (ty.struct) {\n-        case (ty_tup(_)) { ret true; }\n-        case (ty_rec(_)) { ret true; }\n-        case (ty_tag(_)) { ret true; }\n-        case (ty_fn(_,_)) { ret true; }\n-        case (ty_obj(_)) { ret true; }\n-        case (_) { ret false; }\n+        case (ty_tup(_))    { ret true; }\n+        case (ty_rec(_))    { ret true; }\n+        case (ty_tag(_,_))  { ret true; }\n+        case (ty_fn(_,_))   { ret true; }\n+        case (ty_obj(_))    { ret true; }\n+        case (_)            { ret false; }\n     }\n     fail;\n }\n \n fn type_is_tup_like(@t ty) -> bool {\n     alt (ty.struct) {\n-        case (ty_box(_)) { ret true; }\n-        case (ty_tup(_)) { ret true; }\n-        case (ty_rec(_)) { ret true; }\n-        case (ty_tag(_)) { ret true; }\n-        case (_) { ret false; }\n+        case (ty_box(_))    { ret true; }\n+        case (ty_tup(_))    { ret true; }\n+        case (ty_rec(_))    { ret true; }\n+        case (ty_tag(_,_))  { ret true; }\n+        case (_)            { ret false; }\n     }\n     fail;\n }\n@@ -641,8 +652,13 @@ fn item_ty(@ast.item it) -> ty_params_and_ty {\n             result_ty = ann_to_type(ann);\n         }\n         case (ast.item_tag(_, _, ?tps, ?did)) {\n+            // Create a new generic polytype.\n             ty_params = tps;\n-            result_ty = plain_ty(ty_tag(did));\n+            let vec[@t] subtys = vec();\n+            for (ast.ty_param tp in tps) {\n+                subtys += vec(plain_ty(ty_param(tp.id)));\n+            }\n+            result_ty = plain_ty(ty_tag(did, subtys));\n         }\n         case (ast.item_obj(_, _, ?tps, _, ?ann)) {\n             ty_params = tps;\n@@ -1001,13 +1017,42 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n             case (ty.ty_type)       { ret struct_cmp(expected, actual); }\n             case (ty.ty_native)     { ret struct_cmp(expected, actual); }\n \n-            case (ty.ty_tag(?expected_id)) {\n+            case (ty.ty_tag(?expected_id, ?expected_tps)) {\n                 alt (actual.struct) {\n-                    case (ty.ty_tag(?actual_id)) {\n-                        if (expected_id._0 == actual_id._0 &&\n-                                expected_id._1 == actual_id._1) {\n-                            ret ures_ok(expected);\n+                    case (ty.ty_tag(?actual_id, ?actual_tps)) {\n+                        if (expected_id._0 != actual_id._0 ||\n+                                expected_id._1 != actual_id._1) {\n+                            ret ures_err(terr_mismatch, expected, actual);\n+                        }\n+\n+                        // TODO: factor this cruft out, see the TODO in the\n+                        // ty.ty_tup case\n+                        let vec[@ty.t] result_tps = vec();\n+                        auto i = 0u;\n+                        auto expected_len = _vec.len[@ty.t](expected_tps);\n+                        while (i < expected_len) {\n+                            auto expected_tp = expected_tps.(i);\n+                            auto actual_tp = actual_tps.(i);\n+\n+                            auto result = unify_step(bindings,\n+                                                     expected_tp,\n+                                                     actual_tp,\n+                                                     handler);\n+\n+                            alt (result) {\n+                                case (ures_ok(?rty)) {\n+                                    append[@ty.t](result_tps, rty);\n+                                }\n+                                case (_) {\n+                                    ret result;\n+                                }\n+                            }\n+\n+                            i += 1u;\n                         }\n+\n+                        ret ures_ok(plain_ty(ty.ty_tag(expected_id,\n+                                                       result_tps)));\n                     }\n                     case (_) { /* fall through */ }\n                 }"}, {"sha": "aa5e9fe5a7a22145c0995b10cc38a95358ec72ab", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/10befcd9a4d9f68e2dbec84c4a86450a021143fb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10befcd9a4d9f68e2dbec84c4a86450a021143fb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=10befcd9a4d9f68e2dbec84c4a86450a021143fb", "patch": "@@ -430,8 +430,13 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 ret ty_;\n             }\n \n-            case (ast.item_tag(_, _, _, ?def_id)) {\n-                auto t = plain_ty(ty.ty_tag(def_id));\n+            case (ast.item_tag(_, _, ?tps, ?def_id)) {\n+                // Create a new generic polytype.\n+                let vec[@ty.t] subtys = vec();\n+                for (ast.ty_param tp in tps) {\n+                    subtys += vec(plain_ty(ty.ty_param(tp.id)));\n+                }\n+                auto t = plain_ty(ty.ty_tag(def_id, subtys));\n                 item_to_ty.insert(def_id, t);\n                 ret t;\n             }\n@@ -468,15 +473,23 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     fn get_tag_variant_types(@ty_item_table id_to_ty_item,\n                              @ty_table item_to_ty,\n                              &ast.def_id tag_id,\n-                             &vec[ast.variant] variants) -> vec[ast.variant] {\n+                             &vec[ast.variant] variants,\n+                             &vec[ast.ty_param] ty_params)\n+            -> vec[ast.variant] {\n         let vec[ast.variant] result = vec();\n \n+        // Create a set of parameter types shared among all the variants.\n+        let vec[@ty.t] ty_param_tys = vec();\n+        for (ast.ty_param tp in ty_params) {\n+            ty_param_tys += vec(plain_ty(ty.ty_param(tp.id)));\n+        }\n+\n         for (ast.variant variant in variants) {\n-            // Nullary tag constructors get truned into constants; n-ary tag\n+            // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n             auto result_ty;\n             if (_vec.len[ast.variant_arg](variant.args) == 0u) {\n-                result_ty = plain_ty(ty.ty_tag(tag_id));\n+                result_ty = plain_ty(ty.ty_tag(tag_id, ty_param_tys));\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n@@ -487,7 +500,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                     auto arg_ty = ast_ty_to_ty(f, va.ty);\n                     args += vec(rec(mode=ast.alias, ty=arg_ty));\n                 }\n-                auto tag_t = plain_ty(ty.ty_tag(tag_id));\n+                auto tag_t = plain_ty(ty.ty_tag(tag_id, ty_param_tys));\n                 result_ty = plain_ty(ty.ty_fn(args, tag_t));\n             }\n \n@@ -674,7 +687,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                      ast.def_id id) -> @ast.item {\n         auto variants_t = get_tag_variant_types(e.id_to_ty_item,\n                                                 e.item_to_ty,\n-                                                id, variants);\n+                                                id,\n+                                                variants,\n+                                                ty_params);\n         auto item = ast.item_tag(i, variants_t, ty_params, id);\n         ret @fold.respan[ast.item_](sp, item);\n     }\n@@ -857,7 +872,7 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n \n             auto subpats_len = _vec.len[@ast.pat](subpats);\n             alt (variant_ty.struct) {\n-                case (ty.ty_tag(_)) {\n+                case (ty.ty_tag(_, _)) {\n                     // Nullary tag variant.\n                     check (subpats_len == 0u);\n                     p_1 = ast.pat_tag(id, subpats, vdef_opt, ast.ann_type(t));\n@@ -1198,7 +1213,9 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                 }\n \n                 // Nullary variants have tag types.\n-                case (ty.ty_tag(?tid)) {\n+                case (ty.ty_tag(?tid, _)) {\n+                    // TODO: ty params\n+\n                     auto subpats_len = _vec.len[@ast.pat](subpats);\n                     if (subpats_len > 0u) {\n                         // TODO: pluralize properly\n@@ -1212,7 +1229,8 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                         fail;   // TODO: recover\n                     }\n \n-                    auto ann = ast.ann_type(plain_ty(ty.ty_tag(tid)));\n+                    let vec[@ty.t] tys = vec(); // FIXME\n+                    auto ann = ast.ann_type(plain_ty(ty.ty_tag(tid, tys)));\n                     new_pat = ast.pat_tag(p, subpats, vdef_opt, ann);\n                 }\n             }"}, {"sha": "68d7c18f8d2b99ff53d44e9f89bc336926cef957", "filename": "src/test/run-pass/generic-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10befcd9a4d9f68e2dbec84c4a86450a021143fb/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10befcd9a4d9f68e2dbec84c4a86450a021143fb/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs?ref=10befcd9a4d9f68e2dbec84c4a86450a021143fb", "patch": "@@ -6,4 +6,4 @@ tag option[T] {\n fn main() {\n   let option[int] a = some[int](@10);\n   a = none[int];\n-}\n\\ No newline at end of file\n+}"}]}