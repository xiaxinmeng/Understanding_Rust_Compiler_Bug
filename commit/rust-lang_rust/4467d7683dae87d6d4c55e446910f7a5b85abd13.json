{"sha": "4467d7683dae87d6d4c55e446910f7a5b85abd13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NjdkNzY4M2RhZTg3ZDZkNGM1NWU0NDY5MTBmN2E1Yjg1YWJkMTM=", "commit": {"author": {"name": "Or Brostovski", "email": "tohava@gmail.com", "date": "2010-08-07T13:43:08Z"}, "committer": {"name": "Or Brostovski", "email": "tohava@gmail.com", "date": "2010-08-07T13:43:08Z"}, "message": "Merge branch 'master' of git://github.com/graydon/rust\n\nConflicts:\n\tsrc/boot/fe/ast.ml", "tree": {"sha": "e2578dbe8e2350eb4e82ae2941fc2efb7478253b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2578dbe8e2350eb4e82ae2941fc2efb7478253b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4467d7683dae87d6d4c55e446910f7a5b85abd13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4467d7683dae87d6d4c55e446910f7a5b85abd13", "html_url": "https://github.com/rust-lang/rust/commit/4467d7683dae87d6d4c55e446910f7a5b85abd13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4467d7683dae87d6d4c55e446910f7a5b85abd13/comments", "author": {"login": "tohava", "id": 329651, "node_id": "MDQ6VXNlcjMyOTY1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/329651?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tohava", "html_url": "https://github.com/tohava", "followers_url": "https://api.github.com/users/tohava/followers", "following_url": "https://api.github.com/users/tohava/following{/other_user}", "gists_url": "https://api.github.com/users/tohava/gists{/gist_id}", "starred_url": "https://api.github.com/users/tohava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tohava/subscriptions", "organizations_url": "https://api.github.com/users/tohava/orgs", "repos_url": "https://api.github.com/users/tohava/repos", "events_url": "https://api.github.com/users/tohava/events{/privacy}", "received_events_url": "https://api.github.com/users/tohava/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tohava", "id": 329651, "node_id": "MDQ6VXNlcjMyOTY1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/329651?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tohava", "html_url": "https://github.com/tohava", "followers_url": "https://api.github.com/users/tohava/followers", "following_url": "https://api.github.com/users/tohava/following{/other_user}", "gists_url": "https://api.github.com/users/tohava/gists{/gist_id}", "starred_url": "https://api.github.com/users/tohava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tohava/subscriptions", "organizations_url": "https://api.github.com/users/tohava/orgs", "repos_url": "https://api.github.com/users/tohava/repos", "events_url": "https://api.github.com/users/tohava/events{/privacy}", "received_events_url": "https://api.github.com/users/tohava/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1c86beea8a79e0b101596ea65f90b1b7e70bd64", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c86beea8a79e0b101596ea65f90b1b7e70bd64", "html_url": "https://github.com/rust-lang/rust/commit/b1c86beea8a79e0b101596ea65f90b1b7e70bd64"}, {"sha": "bd7835effa42a37ddf647e9cbf132d601de4700d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd7835effa42a37ddf647e9cbf132d601de4700d", "html_url": "https://github.com/rust-lang/rust/commit/bd7835effa42a37ddf647e9cbf132d601de4700d"}], "stats": {"total": 557, "additions": 410, "deletions": 147}, "files": [{"sha": "83a4fdb1b8dcf6436784ed64cd3b298be6b2a64d", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -15,6 +15,7 @@ Jeff Mulzelaar <jmuizelaar@mozilla.com>\n Jeffrey Yasskin <jyasskin@gmail.com>\n Matt Brubeck <mbrubeck@limpet.net>\n Michael Bebenita <mbebenita@mozilla.com>\n+Or Brostovski <tohava@gmail.com>\n Patrick Walton <pwalton@mozilla.com>\n Ralph Giles <giles@thaumas.net>\n Roy Frostig <rfrostig@mozilla.com>"}, {"sha": "1d79a46700a664e5bdb8059c98c96649a4c1ab54", "filename": "src/Makefile", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -389,11 +389,13 @@ TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n                     test/run-pass/child-outlives-parent.rs \\\n                     test/run-pass/clone-with-exterior.rs \\\n                     test/run-pass/constrained-type.rs \\\n+                    test/run-pass/destructor-ordering.rs \\\n                     test/run-pass/obj-as.rs \\\n                     test/run-pass/vec-slice.rs \\\n                     test/run-pass/fn-lval.rs \\\n                     test/run-pass/generic-fn-infer.rs \\\n                     test/run-pass/generic-recursive-tag.rs \\\n+                    test/run-pass/int-lib.rs \\\n                     test/run-pass/iter-ret.rs \\\n                     test/run-pass/lib-deque.rs \\\n                     test/run-pass/lib-map.rs \\\n@@ -418,7 +420,6 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       alt-tag.rs \\\n                       arithmetic-interference.rs \\\n                       argv.rs \\\n-                      auto-deref.rs \\\n                       autoderef-full-lval.rs \\\n                       autoderef-objfn.rs \\\n                       basic.rs \\\n@@ -452,7 +453,6 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       generic-drop-glue.rs \\\n                       generic-exterior-box.rs \\\n                       generic-fn-infer.rs \\\n-                      generic-fn-twice.rs \\\n                       generic-fn.rs \\\n                       generic-obj-with-derived-type.rs \\\n                       generic-obj.rs \\\n@@ -464,6 +464,8 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       i8-incr.rs \\\n                       import.rs \\\n                       inner-module.rs \\\n+                      integral-indexing.rs \\\n+                      int-lib.rs \\\n                       iter-range.rs \\\n                       iter-ret.rs \\\n                       large-records.rs \\\n@@ -481,8 +483,6 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       mutable-alias-vec.rs \\\n                       mutable-vec-drop.rs \\\n                       mutual-recursion-group.rs \\\n-                      native-mod.rc \\\n-                      native.rc \\\n                       obj-as.rs \\\n                       obj-drop.rs \\\n                       obj-dtor.rs \\\n@@ -506,6 +506,7 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       str-append.rs \\\n                       str-concat.rs \\\n                       str-idx.rs \\\n+                      str-lib.rs \\\n                       tag.rs \\\n                       tail-cps.rs \\\n                       tail-direct.rs \\"}, {"sha": "172d866143017d84dd9a99475c1a0daf0f7446e0", "filename": "src/boot/be/il.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fbe%2Fil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fbe%2Fil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fil.ml?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -695,7 +695,7 @@ type emitter = { mutable emit_pc: int;\n                  emit_target_specific: (emitter -> quad -> unit);\n                  mutable emit_quads: quads;\n                  emit_annotations: (int,string) Hashtbl.t;\n-                 emit_size_cache: ((size,operand) Hashtbl.t) Stack.t;\n+                 emit_size_cache: (size,operand) Hashtbl.t;\n                  emit_node: node_id option;\n                }\n \n@@ -722,7 +722,7 @@ let new_emitter\n     emit_target_specific = emit_target_specific;\n     emit_quads = Array.create 4 badq;\n     emit_annotations = Hashtbl.create 0;\n-    emit_size_cache = Stack.create ();\n+    emit_size_cache = Hashtbl.create 0;\n     emit_node = node;\n   }\n ;;"}, {"sha": "55b101bbd348c9063ad2d65c79d3dfa1f07d54e4", "filename": "src/boot/be/x86.ml", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fbe%2Fx86.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fbe%2Fx86.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fx86.ml?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -302,19 +302,49 @@ let emit_target_specific\n               | Il.IMOD | Il.UMOD ->\n                   let dst_eax = hr_like_cell eax dst in\n                   let lhs_eax = hr_like_op eax lhs in\n-                  let rhs_ecx = hr_like_op ecx lhs in\n-                    if lhs <> (Il.Cell lhs_eax)\n-                    then mov lhs_eax lhs;\n-                    if rhs <> (Il.Cell rhs_ecx)\n-                    then mov rhs_ecx rhs;\n+                  let rhs_ecx = hr_like_op ecx rhs in\n+                    (* Horrible: we bounce complex mul inputs off spill slots\n+                     * to ensure non-interference between the temporaries used\n+                     * during mem-base-reg reloads and the registers we're\n+                     * preparing.  *)\n+                  let next_spill_like op =\n+                    Il.Mem (Il.next_spill_slot e\n+                              (Il.ScalarTy (Il.operand_scalar_ty op)))\n+                  in\n+                  let is_mem op =\n+                    match op with\n+                        Il.Cell (Il.Mem _) -> true\n+                      | _ -> false\n+                  in\n+                  let bounce_lhs = is_mem lhs in\n+                  let bounce_rhs = is_mem rhs in\n+                  let lhs_spill = next_spill_like lhs in\n+                  let rhs_spill = next_spill_like rhs in\n+\n+                    if bounce_lhs\n+                    then mov lhs_spill lhs;\n+\n+                    if bounce_rhs\n+                    then mov rhs_spill rhs;\n+\n+                    mov lhs_eax\n+                      (if bounce_lhs\n+                       then (Il.Cell lhs_spill)\n+                       else lhs);\n+\n+                    mov rhs_ecx\n+                      (if bounce_rhs\n+                       then (Il.Cell rhs_spill)\n+                       else rhs);\n+                    \n                     put (Il.Binary\n                            { b with\n                                Il.binary_lhs = (Il.Cell lhs_eax);\n                                Il.binary_rhs = (Il.Cell rhs_ecx);\n                                Il.binary_dst = dst_eax; });\n                     if dst <> dst_eax\n                     then mov dst (Il.Cell dst_eax);\n-\n+                    \n               | _ when (Il.Cell dst) <> lhs ->\n                   mov dst lhs;\n                   put (Il.Binary\n@@ -1936,15 +1966,20 @@ let zero (dst:Il.cell) (count:Il.operand) : Asm.frag =\n ;;\n \n let mov (signed:bool) (dst:Il.cell) (src:Il.operand) : Asm.frag =\n-  if is_ty8 (Il.cell_scalar_ty dst) || is_ty8 (Il.operand_scalar_ty src)\n+  if is_ty8 (Il.cell_scalar_ty dst)\n   then\n     begin\n-      (match dst with\n-           Il.Reg (Il.Hreg r, _)\n-           -> assert (is_ok_r8 r) | _ -> ());\n-      (match src with\n-           Il.Cell (Il.Reg (Il.Hreg r, _))\n-           -> assert (is_ok_r8 r) | _ -> ());\n+      match dst with\n+          Il.Reg (Il.Hreg r, _) -> assert (is_ok_r8 r)\n+        | _ -> ()\n+    end;\n+\n+  if is_ty8 (Il.operand_scalar_ty src)\n+  then\n+    begin\n+      match src with\n+          Il.Cell (Il.Reg (Il.Hreg r, _)) -> assert (is_ok_r8 r)\n+        | _ -> ()\n     end;\n \n   match (signed, dst, src) with"}, {"sha": "82ec2fafc10d5619429e1fb6753962a45a234107", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -253,7 +253,10 @@ and parse_stmts (ps:pstate) : Ast.stmt array =\n                             let lv = name_to_lval apos bpos name in\n                               Ast.PAT_tag (lv, paren_comma_list parse_pat ps)\n \n-                      | LIT_INT _ | LIT_CHAR _ | LIT_BOOL _ ->\n+                      | LIT_INT _\n+                      | LIT_UINT _\n+                      | LIT_CHAR _\n+                      | LIT_BOOL _ ->\n                           Ast.PAT_lit (Pexp.parse_lit ps)\n \n                       | UNDERSCORE -> bump ps; Ast.PAT_wild"}, {"sha": "3e17e0e49e7f68a1eb814bb85c2cf68955f8be6e", "filename": "src/boot/fe/pexp.ml", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -817,11 +817,33 @@ and parse_or_pexp (ps:pstate) : pexp =\n     step lhs\n \n \n+and parse_as_pexp (ps:pstate) : pexp =\n+  let apos = lexpos ps in\n+  let pexp = ctxt \"as pexp\" parse_or_pexp ps in\n+  let rec step accum =\n+    match peek ps with\n+        AS ->\n+          bump ps;\n+          let tapos = lexpos ps in\n+          let t = parse_ty ps in\n+          let bpos = lexpos ps in\n+          let t = span ps tapos bpos t in\n+          let node =\n+            span ps apos bpos\n+              (PEXP_unop ((Ast.UNOP_cast t), accum))\n+          in\n+            step node\n+\n+      | _ -> accum\n+  in\n+    step pexp\n+\n+\n and parse_relational_pexp (ps:pstate) : pexp =\n   let name = \"relational pexp\" in\n   let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_or_pexp ps in\n-  let build = binop_build ps name apos parse_or_pexp in\n+  let lhs = ctxt (name ^ \" lhs\") parse_as_pexp ps in\n+  let build = binop_build ps name apos parse_as_pexp in\n   let rec step accum =\n     match peek ps with\n         LT -> build accum step Ast.BINOP_lt\n@@ -883,30 +905,8 @@ and parse_oror_pexp (ps:pstate) : pexp =\n     step lhs\n \n \n-and parse_as_pexp (ps:pstate) : pexp =\n-  let apos = lexpos ps in\n-  let pexp = ctxt \"as pexp\" parse_oror_pexp ps in\n-  let rec step accum =\n-    match peek ps with\n-        AS ->\n-          bump ps;\n-          let tapos = lexpos ps in\n-          let t = parse_ty ps in\n-          let bpos = lexpos ps in\n-          let t = span ps tapos bpos t in\n-          let node =\n-            span ps apos bpos\n-              (PEXP_unop ((Ast.UNOP_cast t), accum))\n-          in\n-            step node\n-\n-      | _ -> accum\n-  in\n-    step pexp\n-\n-\n and parse_pexp (ps:pstate) : pexp =\n-  parse_as_pexp ps\n+  parse_oror_pexp ps\n \n and parse_mutable_and_pexp (ps:pstate) : (Ast.mutability * pexp) =\n   let mutability = parse_mutability ps in"}, {"sha": "c1ef49af0bf83788659417a5c185fc2c89171293", "filename": "src/boot/llvm/lltrans.ml", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fllvm%2Flltrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fllvm%2Flltrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Flltrans.ml?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -588,7 +588,7 @@ let trans_crate\n     (* Maps a fn's or block's id to an LLVM metadata node (subprogram or\n        lexical block) representing it. *)\n   let (dbg_llscopes:(node_id, Llvm.llvalue) Hashtbl.t) = Hashtbl.create 0 in\n-  let declare_mod_item\n+  let rec declare_mod_item\n       (name:Ast.ident)\n       mod_item\n       : unit =\n@@ -616,9 +616,8 @@ let trans_crate\n         | Ast.MOD_ITEM_type _ ->\n             ()  (* Types get translated with their terms. *)\n \n-        | Ast.MOD_ITEM_mod _ ->\n-            ()  (* Modules simply contain other items that are translated\n-                   on their own. *)\n+        | Ast.MOD_ITEM_mod (_, items) ->\n+            Hashtbl.iter declare_mod_item items\n \n         | _ ->\n             Common.unimpl (Some id)\n@@ -807,6 +806,17 @@ let trans_crate\n                             Ast.sprintf_lval lval)\n       in\n \n+      let trans_callee (fn:Ast.lval) : (Llvm.llvalue * Ast.ty) =\n+        let fty = Hashtbl.find sem_cx.ctxt_all_lval_types (lval_base_id fn) in\n+          if lval_base_is_item sem_cx fn then\n+            let fn_item = lval_item sem_cx fn in\n+            let llfn = Hashtbl.find llitems (fn_item.id) in\n+              (llfn, fty)\n+          else\n+            (* indirect call to computed slot *)\n+            trans_lval fn\n+      in\n+\n       let trans_atom (atom:Ast.atom) : Llvm.llvalue =\n         iflog (fun _ -> log sem_cx \"trans_atom: %a\" Ast.sprintf_atom atom);\n         match atom with\n@@ -959,7 +969,7 @@ let trans_crate\n               | Ast.STMT_call (dest, fn, args) ->\n                   let llargs = Array.map trans_atom args in\n                   let (lldest, _) = trans_lval dest in\n-                  let (llfn, _) = trans_lval fn in\n+                  let (llfn, _) = trans_callee fn in\n                   let llallargs = Array.append [| lldest; lltask |] llargs in\n                   let llrv = build_call llfn llallargs \"\" llbuilder in\n                     Llvm.set_instruction_call_conv Llvm.CallConv.c llrv;\n@@ -1072,13 +1082,22 @@ let trans_crate\n       ignore (Llvm.build_br llbodyblock llinitbuilder)\n   in\n \n-  let trans_mod_item\n-      (_:Ast.ident)\n-      { node = { Ast.decl_item = (item:Ast.mod_item') }; id = id }\n+  let rec trans_mod_item\n+      (name:Ast.ident)\n+      mod_item\n       : unit =\n+    let { node = { Ast.decl_item = (item:Ast.mod_item') }; id = id } =\n+      mod_item in\n     match item with\n-        Ast.MOD_ITEM_fn fn -> trans_fn fn id\n-      | _ -> ()\n+        Ast.MOD_ITEM_type _ ->\n+          ()  (* Types get translated with their terms. *)\n+      | Ast.MOD_ITEM_mod (_, items) ->\n+          Hashtbl.iter trans_mod_item items\n+      | Ast.MOD_ITEM_fn fn -> trans_fn fn id\n+      | _ -> Common.unimpl (Some id)\n+          \"LLVM module declaration for: %a\"\n+            Ast.sprintf_mod_item (name, mod_item)\n+\n   in\n \n   let exit_task_glue ="}, {"sha": "b708bb268ff4e0f728485d127c04d72c6fb811e7", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -163,7 +163,6 @@ let trans_visitor\n          abi.Abi.abi_emit_target_specific\n          vregs_ok fnid\n     in\n-      Stack.push (Hashtbl.create 0) e.Il.emit_size_cache;\n       Stack.push e emitters;\n   in\n \n@@ -172,16 +171,20 @@ let trans_visitor\n \n   let pop_emitter _ = ignore (Stack.pop emitters) in\n   let emitter _ = Stack.top emitters in\n-  let emitter_size_cache _ = Stack.top (emitter()).Il.emit_size_cache in\n-  let push_emitter_size_cache _ =\n-    Stack.push\n-      (Hashtbl.copy (emitter_size_cache()))\n-      (emitter()).Il.emit_size_cache\n+  let emitter_size_cache _ = (emitter()).Il.emit_size_cache in\n+  let flush_emitter_size_cache _ =\n+    Hashtbl.clear (emitter_size_cache())\n   in\n-  let pop_emitter_size_cache _ =\n-    ignore (Stack.pop (emitter()).Il.emit_size_cache)\n+\n+  let emit q =\n+    begin\n+      match q with\n+        Il.Jmp _ -> flush_emitter_size_cache();\n+        | _ -> ()\n+    end;        \n+    Il.emit (emitter()) q\n   in\n-  let emit q = Il.emit (emitter()) q in\n+\n   let next_vreg _ = Il.next_vreg (emitter()) in\n   let next_vreg_cell t = Il.next_vreg_cell (emitter()) t in\n   let next_spill_cell t =\n@@ -190,12 +193,17 @@ let trans_visitor\n     let spill_ta = (spill_mem, Il.ScalarTy t) in\n       Il.Mem spill_ta\n   in\n-  let mark _ : quad_idx = (emitter()).Il.emit_pc in\n+  let mark _ : quad_idx =\n+    flush_emitter_size_cache ();\n+    (emitter()).Il.emit_pc\n+  in\n   let patch_existing (jmp:quad_idx) (targ:quad_idx) : unit =\n-    Il.patch_jump (emitter()) jmp targ\n+    Il.patch_jump (emitter()) jmp targ;\n+    flush_emitter_size_cache ();\n   in\n   let patch (i:quad_idx) : unit =\n     Il.patch_jump (emitter()) i (mark());\n+    flush_emitter_size_cache ();\n     (* Insert a dead quad to ensure there's an otherwise-unused\n      * jump-target here.\n      *)\n@@ -583,7 +591,13 @@ let trans_visitor\n                 (string_of_size size)));\n     let sub_sz = calculate_sz ty_params in\n     match htab_search (emitter_size_cache()) size with\n-        Some op -> op\n+        Some op ->\n+          iflog (fun _ -> annotate\n+                   (Printf.sprintf \"cached size %s is %s\"\n+                      (string_of_size size)\n+                      (oper_str op)));\n+          op\n+\n       | _ ->\n           let res =\n             match size with\n@@ -914,7 +928,8 @@ let trans_visitor\n       let atop = trans_atom at in\n       let unit_sz = ty_sz_in_current_frame ty in\n       let idx = next_vreg_cell word_sty in\n-        emit (Il.binary Il.UMUL idx atop unit_sz);\n+        mov idx atop;\n+        emit (Il.binary Il.UMUL idx (Il.Cell idx) unit_sz);\n         let elt_mem = trans_bounds_check (deref cell) (Il.Cell idx) in\n           (Il.Mem (elt_mem, referent_type abi ty), ty)\n     in\n@@ -1923,8 +1938,8 @@ let trans_visitor\n       : quad_idx list =\n     emit (Il.cmp (Il.Cell (Il.Reg (force_to_reg lhs))) rhs);\n     let jmp = mark() in\n-    emit (Il.jmp cjmp Il.CodeNone);\n-    [ jmp ]\n+      emit (Il.jmp cjmp Il.CodeNone);\n+      [ jmp ]\n \n   and trans_compare\n       ?ty_params:(ty_params=get_ty_params_of_current_frame())\n@@ -1943,7 +1958,6 @@ let trans_visitor\n       | _ -> trans_compare_simple cjmp lhs rhs\n \n   and trans_cond (invert:bool) (expr:Ast.expr) : quad_idx list =\n-\n     let anno _ =\n       iflog\n         begin\n@@ -2075,15 +2089,14 @@ let trans_visitor\n             trans_atom a\n \n   and trans_block (block:Ast.block) : unit =\n+    flush_emitter_size_cache();\n     trace_str cx.ctxt_sess.Session.sess_trace_block\n       \"entering block\";\n-    push_emitter_size_cache ();\n     emit (Il.Enter (Hashtbl.find cx.ctxt_block_fixups block.id));\n     Array.iter trans_stmt block.node;\n     trace_str cx.ctxt_sess.Session.sess_trace_block\n       \"exiting block\";\n     emit Il.Leave;\n-    pop_emitter_size_cache ();\n     trace_str cx.ctxt_sess.Session.sess_trace_block\n       \"exited block\";\n \n@@ -4395,11 +4408,11 @@ let trans_visitor\n                     let back_jmp =\n                       trans_compare_simple Il.JB (Il.Cell dptr) (Il.Cell dlim)\n                     in\n-                    List.iter\n-                      (fun j -> patch_existing j back_jmp_targ) back_jmp;\n-                    let v = next_vreg_cell word_sty in\n-                      mov v (Il.Cell src_fill);\n-                      add_to dst_fill (Il.Cell v);\n+                      List.iter\n+                        (fun j -> patch_existing j back_jmp_targ) back_jmp;\n+                      let v = next_vreg_cell word_sty in\n+                        mov v (Il.Cell src_fill);\n+                        add_to dst_fill (Il.Cell v);\n         | t ->\n             begin\n               bug () \"unsupported vector-append type %a\" Ast.sprintf_ty t"}, {"sha": "23210ea1ff8211a5177862120542c90f6164af0b", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -380,19 +380,20 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n               sprintf_itype ()\n \n         | `Type (Ast.TY_vec ty_vec), Ast.COMP_atom atom ->\n-            demand Ast.TY_int (check_atom atom);\n+            demand_integer (check_atom atom);\n             LTYPE_mono ty_vec\n \n         | `Type (Ast.TY_vec _), _ ->\n-            Common.err None \"the vector type '%a' must be indexed via an int\"\n+            Common.err None\n+              \"the vector type '%a' must be indexed by an integral type\"\n               sprintf_itype ()\n \n         | `Type Ast.TY_str, Ast.COMP_atom atom ->\n-            demand Ast.TY_int (check_atom atom);\n+            demand_integer (check_atom atom);\n             LTYPE_mono (Ast.TY_mach Common.TY_u8)\n \n         | `Type Ast.TY_str, _ ->\n-            Common.err None \"strings must be indexed via an int\"\n+            Common.err None \"strings must be indexed by an integral type\"\n \n         | `Type (Ast.TY_box ty_box), Ast.COMP_deref -> LTYPE_mono ty_box\n "}, {"sha": "beb482237beca0278c8d0884acd1a79be848e45f", "filename": "src/etc/x86.supp", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fetc%2Fx86.supp", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Fetc%2Fx86.supp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fx86.supp?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -11,4 +11,14 @@\n  Memcheck:Leak\n  fun:calloc\n  fun:_dl_allocate_tls\n-}\n\\ No newline at end of file\n+}\n+\n+{\n+   mac-dyld-oddity\n+   Memcheck:Cond\n+   fun:_ZN4dyld5_mainEPK12macho_headermiPPKcS5_S5_\n+   fun:_ZN13dyldbootstrap5startEPK12macho_headeriPPKcl\n+   fun:_dyld_start\n+   obj:*\n+}\n+"}, {"sha": "e76c2bf5062896373949eaeaac54b07be882ce09", "filename": "src/lib/_int.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2F_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2F_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_int.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -44,3 +44,47 @@ fn next_power_of_two(uint n) -> uint {\n   }\n   ret tmp + 1u;\n }\n+\n+fn uto_str(mutable uint n, uint radix) -> str\n+{\n+  check (0u < radix && radix <= 16u);\n+  fn digit(uint n) -> str {\n+    alt (n) {\n+      case (0u) { ret \"0\"; }\n+      case (1u) { ret \"1\"; }\n+      case (2u) { ret \"2\"; }\n+      case (3u) { ret \"3\"; }\n+      case (4u) { ret \"4\"; }\n+      case (5u) { ret \"5\"; }\n+      case (6u) { ret \"6\"; }\n+      case (7u) { ret \"7\"; }\n+      case (8u) { ret \"8\"; }\n+      case (9u) { ret \"9\"; }\n+      case (10u) { ret \"a\"; }\n+      case (11u) { ret \"b\"; }\n+      case (12u) { ret \"c\"; }\n+      case (13u) { ret \"d\"; }\n+      case (14u) { ret \"e\"; }\n+      case (15u) { ret \"f\"; }\n+    }\n+  }\n+\n+  if (n == 0u) { ret \"0\"; }\n+\n+  let str s = \"\";\n+  while (n > 0u) {\n+    s = digit(n % radix) + s;\n+    n /= radix;\n+  }\n+  ret s;\n+}\n+\n+fn to_str(mutable int n, uint radix) -> str\n+{\n+  check (0u < radix && radix <= 16u);\n+  if (n < 0) {\n+    ret \"-\" + uto_str((-n) as uint, radix);\n+  } else {\n+    ret uto_str(n as uint, radix);\n+  }\n+}"}, {"sha": "93d06d416fb81957a86b722d93cdfe62eb390ef8", "filename": "src/lib/_io.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2F_io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2F_io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_io.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -1,3 +1,7 @@\n+import std.os;\n+import std._str;\n+import std._vec;\n+\n type buf_reader = unsafe obj {\n   fn read() -> vec[u8];\n };\n@@ -107,3 +111,22 @@ fn new_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n   }\n   ret fd_buf_writer(fd);\n }\n+\n+type writer =\n+  unsafe obj {\n+    fn write_str(str s);\n+    fn write_int(int n);\n+    fn write_uint(uint n);\n+  };\n+\n+fn file_writer(str path,\n+               vec[fileflag] flags)\n+  -> writer\n+{\n+  unsafe obj fw(buf_writer out) {\n+    fn write_str(str s)   { out.write(_str.bytes(s)); }\n+    fn write_int(int n)   { out.write(_str.bytes(_int.to_str(n, 10u))); }\n+    fn write_uint(uint n) { out.write(_str.bytes(_int.uto_str(n, 10u))); }\n+  }\n+  ret fw(new_buf_writer(path, flags));\n+}"}, {"sha": "a607c7d5df51bbfbf8cfa583d95fc49fc27fc78a", "filename": "src/lib/_str.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -3,7 +3,7 @@ import rustrt.sbuf;\n native \"rust\" mod rustrt {\n   type sbuf;\n   fn str_buf(str s) -> sbuf;\n-  fn str_len(str s) -> uint;\n+  fn str_byte_len(str s) -> uint;\n   fn str_alloc(uint n_bytes) -> str;\n   fn refcount[T](str s) -> uint;\n }\n@@ -12,14 +12,37 @@ fn is_utf8(vec[u8] v) -> bool {\n   fail; // FIXME\n }\n \n+fn is_ascii(str s) -> bool {\n+  let uint i = byte_len(s);\n+  while (i > 0u) {\n+    i -= 1u;\n+    if ((s.(i) & 0x80u8) != 0u8) {\n+      ret false;\n+    }\n+  }\n+  ret true;\n+}\n+\n fn alloc(uint n_bytes) -> str {\n   ret rustrt.str_alloc(n_bytes);\n }\n \n-fn len(str s) -> uint {\n-  ret rustrt.str_len(s);\n+// Returns the number of bytes (a.k.a. UTF-8 code units) in s.\n+// Contrast with a function that would return the number of code\n+// points (char's), combining character sequences, words, etc.  See\n+// http://icu-project.org/apiref/icu4c/classBreakIterator.html for a\n+// way to implement those.\n+fn byte_len(str s) -> uint {\n+  ret rustrt.str_byte_len(s);\n }\n \n fn buf(str s) -> sbuf {\n   ret rustrt.str_buf(s);\n }\n+\n+fn bytes(&str s) -> vec[u8] {\n+  fn ith(str s, uint i) -> u8 {\n+    ret s.(i);\n+  }\n+  ret _vec.init_fn[u8](bind ith(s, _), _str.byte_len(s));\n+}"}, {"sha": "bf7acb533bbaa6b41ee844a788235cd6c919557a", "filename": "src/lib/deque.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -36,7 +36,7 @@ fn create[T]() -> t[T] {\n \n     fn fill[T](uint i, uint nelts, uint lo, &vec[cell[T]] old) -> cell[T] {\n       if (i < nelts) {\n-        ret old.(((lo + i) % nelts) as int);\n+        ret old.((lo + i) % nelts);\n       } else {\n         ret util.none[T]();\n       }\n@@ -47,14 +47,8 @@ fn create[T]() -> t[T] {\n     ret _vec.init_fn[cell[T]](copy_op, nalloc);\n   }\n \n-  /**\n-   * FIXME (issue #94): We're converting to int every time we index into the\n-   * vec, but we really want to index with the lo and hi uints that we have\n-   * around.\n-   */\n-\n   fn get[T](&vec[cell[T]] elts, uint i) -> T {\n-    alt (elts.(i as int)) {\n+    alt (elts.(i)) {\n       case (util.some[T](t)) { ret t; }\n       case (_) { fail; }\n     }\n@@ -82,7 +76,7 @@ fn create[T]() -> t[T] {\n         hi = nelts;\n       }\n \n-      elts.(lo as int) = util.some[T](t);\n+      elts.(lo) = util.some[T](t);\n       nelts += 1u;\n     }\n \n@@ -93,7 +87,7 @@ fn create[T]() -> t[T] {\n         hi = nelts;\n       }\n \n-      elts.(hi as int) = util.some[T](t);\n+      elts.(hi) = util.some[T](t);\n       hi = (hi + 1u) % _vec.len[cell[T]](elts);\n       nelts += 1u;\n     }\n@@ -104,7 +98,7 @@ fn create[T]() -> t[T] {\n      */\n     fn pop_front() -> T {\n       let T t = get[T](elts, lo);\n-      elts.(lo as int) = util.none[T]();\n+      elts.(lo) = util.none[T]();\n       lo = (lo + 1u) % _vec.len[cell[T]](elts);\n       ret t;\n     }\n@@ -117,7 +111,7 @@ fn create[T]() -> t[T] {\n       }\n \n       let T t = get[T](elts, hi);\n-      elts.(hi as int) = util.none[T]();\n+      elts.(hi) = util.none[T]();\n       ret t;\n     }\n "}, {"sha": "ff7b441115bf619c58eab2818a47311f42c899a1", "filename": "src/lib/map.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -75,8 +75,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n   {\n     let uint i = 0u;\n     while (i < nbkts) {\n-      // FIXME (issue #94): as in find_common()\n-      let int j = (hash[K](hasher, nbkts, key, i)) as int;\n+      let uint j = (hash[K](hasher, nbkts, key, i));\n       alt (bkts.(j)) {\n         case (some[K, V](k, _)) {\n           if (eqer(key, k)) {\n@@ -103,8 +102,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n   {\n     let uint i = 0u;\n     while (i < nbkts) {\n-      // FIXME (issue #94):  Pending bugfix, remove uint coercion.\n-      let int j = (hash[K](hasher, nbkts, key, i)) as int;\n+      let uint j = (hash[K](hasher, nbkts, key, i));\n       alt (bkts.(j)) {\n         case (some[K, V](k, v)) {\n           if (eqer(key, k)) {\n@@ -149,9 +147,6 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n       if (!util.rational_leq(load, lf)) {\n         let uint nnewbkts = _int.next_power_of_two(nbkts + 1u);\n \n-        // FIXME (issue #94):  Enforce our workaround to issue #94.\n-        check ((nnewbkts as int) > 0);\n-\n         let vec[mutable bucket[K, V]] newbkts = make_buckets[K, V](nnewbkts);\n         rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nnewbkts);\n       }\n@@ -183,8 +178,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     fn remove(&K key) -> util.option[V] {\n       let uint i = 0u;\n       while (i < nbkts) {\n-        // FIXME (issue #94): as in find_common()\n-        let int j = (hash[K](hasher, nbkts, key, i)) as int;\n+        let uint j = (hash[K](hasher, nbkts, key, i));\n         alt (bkts.(j)) {\n           case (some[K, V](_, val)) {\n             bkts.(j) = deleted[K, V]();"}, {"sha": "d8d9b8d6eb494ff54ebece6af5b7710ba7b93696", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -115,6 +115,12 @@ str_buf(rust_task *task, rust_str *s)\n     return (char const *)&s->data[0];\n }\n \n+extern \"C\" CDECL size_t\n+str_byte_len(rust_task *task, rust_str *s)\n+{\n+    return s->fill - 1;  // -1 for the '\\0' terminator.\n+}\n+\n extern \"C\" CDECL void *\n vec_buf(rust_task *task, type_desc *ty, rust_vec *v, size_t offset)\n {"}, {"sha": "f7f5b8c82c3d4f80a347f2f9074fb4eefce3b5b7", "filename": "src/test/run-pass/destructor-ordering.rs", "status": "modified", "additions": 78, "deletions": 39, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -1,76 +1,115 @@\n-// We share an instance of this type among all the destructor-order\n-// checkers.  It tracks how many destructors have run so far and\n-// 'fail's when one runs out of order.\n-// FIXME: Make it easier to collect a failure message.\n-state obj order_tracker(mutable int init) {\n-  fn assert_order(int expected, str fail_message) {\n-    if (expected != init) {\n-      log expected;\n+// This test checks that destructors run in the right order.  Because\n+// stateful objects can't have destructors, we have the destructors\n+// record their expected order into a channel when they execute (so\n+// the object becomes 'io' rather than 'state').  Then each test case\n+// asserts that the channel produces values in ascending order.\n+//\n+// FIXME: Write an int->str function and concatenate the whole failure\n+// message into a single log statement (or, even better, a print).\n+//\n+// FIXME: check_order should take only 1 line in a test, not 2+a block\n+// block. Since destructor-having objects can't refer to mutable state\n+// (like the port), we'd need a with-like construct to do the same for\n+// stateful objects within a scope.\n+//\n+// FIXME #21: Each test should execute in its own task, so it can fail\n+// independently, writing its error message to a channel that the\n+// parent task aggregates.\n+\n+type order_info = rec(int order, str msg);\n+\n+io fn check_order(port[order_info] expected_p) {\n+  chan(expected_p) <| rec(order=-1, msg=\"\");\n+  let mutable int actual = 0;\n+  auto expected <- expected_p;  // FIXME #121: Workaround for while(true) bug.\n+  auto done = -1;  // FIXME: Workaround for typechecking bug.\n+  while(expected.order != done) {\n+    if (expected.order != actual) {\n+      log expected.order;\n       log \" != \";\n-      log init;\n-      log fail_message;\n+      log actual;\n+      log expected.msg;\n       fail;\n     }\n-    init += 1;\n+    actual += 1;\n+    expected <- expected_p;\n   }\n }\n \n \n-obj dorder(@order_tracker tracker, int order, str message) {\n+obj dorder(chan[order_info] expected, int order, str message) {\n   drop {\n-    tracker.assert_order(order, message);\n+    expected <| rec(order=order, msg=message);\n   }\n }\n \n-fn test_simple() {\n-  auto tracker = @order_tracker(0);\n+io fn test_simple() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n   dorder(tracker, 1, \"Reverse decl order\");\n   dorder(tracker, 0, \"Reverse decl order\");\n+  check_order(tracker_p);\n }\n \n-fn test_block() {\n-  auto tracker = @order_tracker(0);\n-  dorder(tracker, 2, \"Before block\");\n+io fn test_block() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n   {\n-    dorder(tracker, 0, \"Inside block\");\n+    dorder(tracker, 2, \"Before block\");\n+    {\n+      dorder(tracker, 0, \"Inside block\");\n+    }\n+    dorder(tracker, 1, \"After block\");\n   }\n-  dorder(tracker, 1, \"After block\");\n+  check_order(tracker_p);\n }\n \n-fn test_decl_v_init() {\n-  auto tracker = @order_tracker(0);\n-  auto var1;\n-  auto var2;\n-  var2 = dorder(tracker, 0, \"decl, not init\");\n-  var1 = dorder(tracker, 1, \"decl, not init\");\n+io fn test_decl_v_init() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n+  {\n+    auto var1;\n+    auto var2;\n+    var2 = dorder(tracker, 0, \"decl, not init\");\n+    var1 = dorder(tracker, 1, \"decl, not init\");\n+  }\n+  check_order(tracker_p);\n }\n \n-fn test_overwritten_obj() {\n-  auto tracker = @order_tracker(0);\n-  auto var1 = dorder(tracker, 0, \"overwritten object destroyed first\");\n-  auto var2 = dorder(tracker, 2, \"destroyed at end of scope\");\n-  var1 = dorder(tracker, 3, \"overwriter deleted in rev decl order\");\n+io fn test_overwritten_obj() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n   {\n-    dorder(tracker, 1, \"overwritten object destroyed before end of scope\");\n+    auto var1 = dorder(tracker, 0, \"overwritten object destroyed first\");\n+    auto var2 = dorder(tracker, 2, \"destroyed at end of scope\");\n+    var1 = dorder(tracker, 3, \"overwriter deleted in rev decl order\");\n+    {\n+      dorder(tracker, 1, \"overwritten object destroyed before end of scope\");\n+    }\n   }\n+  check_order(tracker_p);\n }\n \n // Used to embed dorder objects into an expression.  Note that the\n // parameters don't get destroyed.\n fn combine_dorders(dorder d1, dorder d2) -> int {\n   ret 1;\n }\n-fn test_expression_destroyed_right_to_left() {\n-  auto tracker = @order_tracker(0);\n-  combine_dorders(dorder(tracker, 4, \"\"), dorder(tracker, 3, \"\"))\n-    / combine_dorders(dorder(tracker, 2, \"\"), dorder(tracker, 1, \"\"));\n+io fn test_expression_destroyed_right_to_left() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n   {\n-    dorder(tracker, 0,\n-           \"expression objects live to end of block, not statement\");\n+    combine_dorders(dorder(tracker, 4, \"\"), dorder(tracker, 3, \"\"))\n+      / combine_dorders(dorder(tracker, 2, \"\"), dorder(tracker, 1, \"\"));\n+    {\n+      dorder(tracker, 0,\n+             \"expression objects live to end of block, not statement\");\n+    }\n   }\n+  check_order(tracker_p);\n }\n \n-fn main() {\n+io fn main() {\n   test_simple();\n   test_block();\n   test_decl_v_init();"}, {"sha": "ce39de4392106a5679f8b2472e078478fd30a221", "filename": "src/test/run-pass/int-lib.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Fint-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Fint-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fint-lib.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -0,0 +1,15 @@\n+use std;\n+\n+import std._int;\n+\n+fn test_to_str() {\n+  check (_int.to_str(0, 10u) == \"0\");\n+  check (_int.to_str(1, 10u) == \"1\");\n+  check (_int.to_str(-1, 10u) == \"-1\");\n+  check (_int.to_str(255, 16u) == \"ff\");\n+  check (_int.to_str(-71, 36u) == \"-1z\");\n+}\n+\n+fn main() {\n+  test_to_str();\n+}"}, {"sha": "fe7d147c30c1d87030db86a5b919247e13b19a5d", "filename": "src/test/run-pass/integral-indexing.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -0,0 +1,22 @@\n+// This is a testcase for issue #94.\n+\n+fn main() {\n+\n+  let vec[int] v = vec(0, 1, 2, 3, 4, 5);\n+  let str s = \"abcdef\";\n+  check (v.(3u) == 3);\n+  check (v.(3u8) == 3);\n+  check (v.(3i8) == 3);\n+  check (v.(3u32) == 3);\n+  check (v.(3i32) == 3);\n+\n+  log v.(3u8);\n+\n+  check (s.(3u) == 'd' as u8);\n+  check (s.(3u8) == 'd' as u8);\n+  check (s.(3i8) == 'd' as u8);\n+  check (s.(3u32) == 'd' as u8);\n+  check (s.(3i32) == 'd' as u8);\n+\n+  log s.(3u8);\n+}\n\\ No newline at end of file"}, {"sha": "058fb2378f3f6c6a8360c9db22442616f51eaa03", "filename": "src/test/run-pass/lib-map.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -4,13 +4,17 @@ use std;\n import std.map;\n \n fn test_simple() {\n+  log \"*** starting test_simple\";\n+\n   fn eq(&uint x, &uint y) -> bool { ret x == y; }\n \n   let map.hashfn[uint] hasher = std.util.id[uint];\n   let map.eqfn[uint] eqer = eq;\n   let map.hashmap[uint, uint] hm = map.mk_hashmap[uint, uint](hasher, eqer);\n+\n+  log \"*** finished test_simple\";\n }\n \n fn main() {\n   test_simple();\n-}\n\\ No newline at end of file\n+}"}, {"sha": "585f9b8de5f2ef323152c8d310b08ed460bbdc9e", "filename": "src/test/run-pass/str-lib.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Fstr-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4467d7683dae87d6d4c55e446910f7a5b85abd13/src%2Ftest%2Frun-pass%2Fstr-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-lib.rs?ref=4467d7683dae87d6d4c55e446910f7a5b85abd13", "patch": "@@ -0,0 +1,16 @@\n+use std;\n+import std._str;\n+\n+fn test_bytes_len() {\n+  check (_str.byte_len(\"\") == 0u);\n+  check (_str.byte_len(\"hello world\") == 11u);\n+  check (_str.byte_len(\"\\x63\") == 1u);\n+  check (_str.byte_len(\"\\xa2\") == 2u);\n+  check (_str.byte_len(\"\\u03c0\") == 2u);\n+  check (_str.byte_len(\"\\u2620\") == 3u);\n+  check (_str.byte_len(\"\\U0001d11e\") == 4u);\n+}\n+\n+fn main() {\n+  test_bytes_len();\n+}"}]}