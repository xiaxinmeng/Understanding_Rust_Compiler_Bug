{"sha": "7041efcfc3f771f5fe72aede1af69180683df286", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNDFlZmNmYzNmNzcxZjVmZTcyYWVkZTFhZjY5MTgwNjgzZGYyODY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-27T00:23:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-27T00:23:53Z"}, "message": "Rollup merge of #70344 - Centril:hir-pretty, r=eddyb\n\nDecouple `rustc_hir::print` into `rustc_hir_pretty`\n\nHigh level summary:\n- The HIR pretty printer, `rustc_hir::print` is moved into a new crate `rustc_hir_pretty`.\n- `rustc_ast_pretty` and `rustc_errors` are dropped as `rustc_hir` dependencies.\n- The dependence on HIR pretty is generally reduced, leaving `rustc_save_analysis`, `rustdoc`, `rustc_metadata`, and `rustc_driver` as the remaining clients.\n\nThe main goal here is to reduce `rustc_hir`'s dependencies and its size such that it can start and finish earlier, thereby working towards https://github.com/rust-lang/rust/issues/65031.\n\nr? @Zoxc", "tree": {"sha": "ba8326824b275236cda90185b84b4463f7b9e1be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba8326824b275236cda90185b84b4463f7b9e1be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7041efcfc3f771f5fe72aede1af69180683df286", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJefUeZCRBK7hj4Ov3rIwAAdHIIABFIEyOxrMlBiH6Bgan5VWDa\nodmWfdHOPje8hHE7VqORg8VU1ZuZMZkuz35J2O7BKRRgz34MvWXCChr6yvCm37od\nqCsxkISoJTTPxYi+XheWCRiTo2IyoM8V6b+fftb0I+54JgAW/MQedrsHDz7R+gsx\nIMYWRZnatH6oELcFvJpyUT6kE6jpl7SJM7mWmfYG4xXC89pHWKGIqQZU55nQL0Xq\nEgXZw403gKc6qrAy5ZNj1wYLHqiwRSW7//FIGDkMVYT2KDZE6WoV7jhjw6aTVE3s\npqU230EoupCZE/EWoP5gClNpJkqJ/NC8LCwQPb5Sw9eTaSlKz3/B0aGA6zX8cZk=\n=c2d8\n-----END PGP SIGNATURE-----\n", "payload": "tree ba8326824b275236cda90185b84b4463f7b9e1be\nparent c0369c4523caecda8af40f4eb84509b42b673d85\nparent b2f7a9502bafebfa9ce0b61ff24a19c26e66c93b\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585268633 +0100\ncommitter GitHub <noreply@github.com> 1585268633 +0100\n\nRollup merge of #70344 - Centril:hir-pretty, r=eddyb\n\nDecouple `rustc_hir::print` into `rustc_hir_pretty`\n\nHigh level summary:\n- The HIR pretty printer, `rustc_hir::print` is moved into a new crate `rustc_hir_pretty`.\n- `rustc_ast_pretty` and `rustc_errors` are dropped as `rustc_hir` dependencies.\n- The dependence on HIR pretty is generally reduced, leaving `rustc_save_analysis`, `rustdoc`, `rustc_metadata`, and `rustc_driver` as the remaining clients.\n\nThe main goal here is to reduce `rustc_hir`'s dependencies and its size such that it can start and finish earlier, thereby working towards https://github.com/rust-lang/rust/issues/65031.\n\nr? @Zoxc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7041efcfc3f771f5fe72aede1af69180683df286", "html_url": "https://github.com/rust-lang/rust/commit/7041efcfc3f771f5fe72aede1af69180683df286", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7041efcfc3f771f5fe72aede1af69180683df286/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0369c4523caecda8af40f4eb84509b42b673d85", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0369c4523caecda8af40f4eb84509b42b673d85", "html_url": "https://github.com/rust-lang/rust/commit/c0369c4523caecda8af40f4eb84509b42b673d85"}, {"sha": "b2f7a9502bafebfa9ce0b61ff24a19c26e66c93b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f7a9502bafebfa9ce0b61ff24a19c26e66c93b", "html_url": "https://github.com/rust-lang/rust/commit/b2f7a9502bafebfa9ce0b61ff24a19c26e66c93b"}], "stats": {"total": 601, "additions": 288, "deletions": 313}, "files": [{"sha": "f1fa91362b1ac1c3b0f257dd0227dca07f8b694c", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -3668,6 +3668,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n  \"rustc_interface\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n@@ -3742,9 +3743,7 @@ dependencies = [\n  \"lazy_static 1.4.0\",\n  \"log\",\n  \"rustc_ast\",\n- \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n- \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_span\",\n@@ -3753,6 +3752,18 @@ dependencies = [\n  \"smallvec 1.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_hir_pretty\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_ast\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_data_structures\",\n+ \"rustc_hir\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+]\n+\n [[package]]\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n@@ -3903,6 +3914,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4087,6 +4099,7 @@ dependencies = [\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n  \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "bc42ac1f0d7aac39d9cd4464c584fa646c709fd8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -10,7 +10,6 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::print::Nested;\n use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::MacroKind;\n@@ -890,20 +889,18 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Get a representation of this `id` for debugging purposes.\n+    /// NOTE: Do NOT use this in diagnostics!\n     pub fn node_to_string(&self, id: HirId) -> String {\n-        hir_id_to_string(self, id, true)\n-    }\n-\n-    pub fn hir_to_user_string(&self, id: HirId) -> String {\n-        hir_id_to_string(self, id, false)\n-    }\n-\n-    pub fn hir_to_pretty_string(&self, id: HirId) -> String {\n-        print::to_string(self, |s| s.print_node(self.get(id)))\n+        hir_id_to_string(self, id)\n     }\n }\n \n impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n+    fn find(&self, hir_id: HirId) -> Option<Node<'hir>> {\n+        self.find(hir_id)\n+    }\n+\n     fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.body(id)\n     }\n@@ -982,23 +979,8 @@ pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> &'tcx Indexe\n     tcx.arena.alloc(IndexedHir { crate_hash, map })\n }\n \n-/// Identical to the `PpAnn` implementation for `hir::Crate`,\n-/// except it avoids creating a dependency on the whole crate.\n-impl<'hir> print::PpAnn for Map<'hir> {\n-    fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) {\n-        match nested {\n-            Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n-            Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n-            Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n-            Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat),\n-        }\n-    }\n-}\n-\n-fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n+fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n     let id_str = format!(\" (hir_id={})\", id);\n-    let id_str = if include_id { &id_str[..] } else { \"\" };\n \n     let path_str = || {\n         // This functionality is used for debugging, try to use `TyCtxt` to get\n@@ -1019,6 +1001,9 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         })\n     };\n \n+    let span_str = || map.tcx.sess.source_map().span_to_snippet(map.span(id)).unwrap_or_default();\n+    let node_str = |prefix| format!(\"{} {}{}\", prefix, span_str(), id_str);\n+\n     match map.find(id) {\n         Some(Node::Item(item)) => {\n             let item_str = match item.kind {\n@@ -1069,22 +1054,20 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         Some(Node::Field(ref field)) => {\n             format!(\"field {} in {}{}\", field.ident, path_str(), id_str)\n         }\n-        Some(Node::AnonConst(_)) => format!(\"const {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Expr(_)) => format!(\"expr {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Stmt(_)) => format!(\"stmt {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::PathSegment(_)) => {\n-            format!(\"path segment {}{}\", map.hir_to_pretty_string(id), id_str)\n-        }\n-        Some(Node::Ty(_)) => format!(\"type {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::TraitRef(_)) => format!(\"trait_ref {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Binding(_)) => format!(\"local {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Pat(_)) => format!(\"pat {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Param(_)) => format!(\"param {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Arm(_)) => format!(\"arm {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Block(_)) => format!(\"block {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Local(_)) => format!(\"local {}{}\", map.hir_to_pretty_string(id), id_str),\n+        Some(Node::AnonConst(_)) => node_str(\"const\"),\n+        Some(Node::Expr(_)) => node_str(\"expr\"),\n+        Some(Node::Stmt(_)) => node_str(\"stmt\"),\n+        Some(Node::PathSegment(_)) => node_str(\"path segment\"),\n+        Some(Node::Ty(_)) => node_str(\"type\"),\n+        Some(Node::TraitRef(_)) => node_str(\"trait ref\"),\n+        Some(Node::Binding(_)) => node_str(\"local\"),\n+        Some(Node::Pat(_)) => node_str(\"pat\"),\n+        Some(Node::Param(_)) => node_str(\"param\"),\n+        Some(Node::Arm(_)) => node_str(\"arm\"),\n+        Some(Node::Block(_)) => node_str(\"block\"),\n+        Some(Node::Local(_)) => node_str(\"local\"),\n         Some(Node::Ctor(..)) => format!(\"ctor {}{}\", path_str(), id_str),\n-        Some(Node::Lifetime(_)) => format!(\"lifetime {}{}\", map.hir_to_pretty_string(id), id_str),\n+        Some(Node::Lifetime(_)) => node_str(\"lifetime\"),\n         Some(Node::GenericParam(ref param)) => format!(\"generic_param {:?}{}\", param, id_str),\n         Some(Node::Visibility(ref vis)) => format!(\"visibility {:?}{}\", vis, id_str),\n         Some(Node::MacroDef(_)) => format!(\"macro {}{}\", path_str(), id_str),"}, {"sha": "3ca39b24c5276784a7eae26d7b7fdb719c0b9898", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -21,6 +21,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_parse = { path = \"../librustc_parse\" }"}, {"sha": "a57a70e6b8ca71be2871eb7b6982755fa124bd0c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::ast;\n use rustc_ast_pretty::pprust;\n use rustc_hir as hir;\n use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_hir::print as pprust_hir;\n+use rustc_hir_pretty as pprust_hir;\n use rustc_mir::util::{write_mir_graphviz, write_mir_pretty};\n use rustc_session::config::{Input, PpMode, PpSourceMode};\n use rustc_session::Session;\n@@ -155,7 +155,7 @@ impl<'hir> pprust::PpAnn for NoAnn<'hir> {}\n impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(tcx) = self.tcx {\n-            pprust_hir::PpAnn::nested(&tcx.hir(), state, nested)\n+            pprust_hir::PpAnn::nested(&(&tcx.hir() as &dyn hir::intravisit::Map<'_>), state, nested)\n         }\n     }\n }\n@@ -228,7 +228,7 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(ref tcx) = self.tcx {\n-            pprust_hir::PpAnn::nested(&tcx.hir(), state, nested)\n+            pprust_hir::PpAnn::nested(&(&tcx.hir() as &dyn hir::intravisit::Map<'_>), state, nested)\n         }\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n@@ -334,7 +334,8 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n         if let pprust_hir::Nested::Body(id) = nested {\n             self.tables.set(self.tcx.body_tables(id));\n         }\n-        pprust_hir::PpAnn::nested(&self.tcx.hir(), state, nested);\n+        let pp_ann = &(&self.tcx.hir() as &dyn hir::intravisit::Map<'_>);\n+        pprust_hir::PpAnn::nested(pp_ann, state, nested);\n         self.tables.set(old_tables);\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {"}, {"sha": "811440fdeb987f7430e715b5d0bb5b3bfbceba42", "filename": "src/librustc_hir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2FCargo.toml?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -10,13 +10,11 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_span = { path = \"../librustc_span\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n lazy_static = \"1\""}, {"sha": "2054759933f3ce6044fed0b3c1282974d8ee2a28", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 12, "deletions": 86, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -2,11 +2,6 @@ use crate::def::{DefKind, Namespace, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n use crate::itemlikevisit;\n-use crate::print;\n-\n-crate use BlockCheckMode::*;\n-crate use FnRetTy::*;\n-crate use UnsafeSource::*;\n \n use rustc_ast::ast::{self, AsmDialect, CrateSugar, Ident, Name};\n use rustc_ast::ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n@@ -16,7 +11,6 @@ use rustc_ast::node_id::NodeMap;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n-use rustc_errors::FatalError;\n use rustc_macros::HashStable_Generic;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -169,12 +163,7 @@ impl fmt::Display for Lifetime {\n \n impl fmt::Debug for Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"lifetime({}: {})\",\n-            self.hir_id,\n-            print::to_string(print::NO_ANN, |s| s.print_lifetime(self))\n-        )\n+        write!(f, \"lifetime({}: {})\", self.hir_id, self.name.ident())\n     }\n }\n \n@@ -191,7 +180,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Path<'hir> {\n     pub span: Span,\n     /// The resolution for the path.\n@@ -206,18 +195,6 @@ impl Path<'_> {\n     }\n }\n \n-impl fmt::Debug for Path<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"path({})\", self)\n-    }\n-}\n-\n-impl fmt::Display for Path<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n-    }\n-}\n-\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n@@ -388,9 +365,9 @@ pub enum GenericBound<'hir> {\n }\n \n impl GenericBound<'_> {\n-    pub fn trait_def_id(&self) -> Option<DefId> {\n+    pub fn trait_ref(&self) -> Option<&TraitRef<'_>> {\n         match self {\n-            GenericBound::Trait(data, _) => Some(data.trait_ref.trait_def_id()),\n+            GenericBound::Trait(data, _) => Some(&data.trait_ref),\n             _ => None,\n         }\n     }\n@@ -758,25 +735,14 @@ pub struct Block<'hir> {\n     pub targeted_by_break: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub kind: PatKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Pat<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"pat({}: {})\",\n-            self.hir_id,\n-            print::to_string(print::NO_ANN, |s| s.print_pat(self))\n-        )\n-    }\n-}\n-\n impl Pat<'_> {\n     // FIXME(#19596) this is a workaround, but there should be a better way\n     fn walk_short_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) -> bool {\n@@ -1118,26 +1084,15 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Stmt<'hir> {\n     pub hir_id: HirId,\n     pub kind: StmtKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Stmt<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"stmt({}: {})\",\n-            self.hir_id,\n-            print::to_string(print::NO_ANN, |s| s.print_stmt(self))\n-        )\n-    }\n-}\n-\n /// The contents of a statement.\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum StmtKind<'hir> {\n     /// A local (`let`) binding.\n     Local(&'hir Local<'hir>),\n@@ -1351,7 +1306,7 @@ pub struct AnonConst {\n }\n \n /// An expression.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct Expr<'hir> {\n     pub hir_id: HirId,\n     pub kind: ExprKind<'hir>,\n@@ -1472,17 +1427,6 @@ impl Expr<'_> {\n     }\n }\n \n-impl fmt::Debug for Expr<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"expr({}: {})\",\n-            self.hir_id,\n-            print::to_string(print::NO_ANN, |s| s.print_expr(self))\n-        )\n-    }\n-}\n-\n /// Checks if the specified expression is a built-in range literal.\n /// (See: `LoweringContext::lower_expr()`).\n ///\n@@ -1965,19 +1909,13 @@ impl TypeBinding<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct Ty<'hir> {\n     pub hir_id: HirId,\n     pub kind: TyKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Ty<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"type({})\", print::to_string(print::NO_ANN, |s| s.print_type(self)))\n-    }\n-}\n-\n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n@@ -2182,15 +2120,6 @@ pub enum FnRetTy<'hir> {\n     Return(&'hir Ty<'hir>),\n }\n \n-impl fmt::Display for FnRetTy<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::Return(ref ty) => print::to_string(print::NO_ANN, |s| s.print_type(ty)).fmt(f),\n-            Self::DefaultReturn(_) => \"()\".fmt(f),\n-        }\n-    }\n-}\n-\n impl FnRetTy<'_> {\n     pub fn span(&self) -> Span {\n         match *self {\n@@ -2274,13 +2203,10 @@ pub struct TraitRef<'hir> {\n \n impl TraitRef<'_> {\n     /// Gets the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n-    pub fn trait_def_id(&self) -> DefId {\n+    pub fn trait_def_id(&self) -> Option<DefId> {\n         match self.path.res {\n-            Res::Def(DefKind::Trait, did) => did,\n-            Res::Def(DefKind::TraitAlias, did) => did,\n-            Res::Err => {\n-                FatalError.raise();\n-            }\n+            Res::Def(DefKind::Trait | DefKind::TraitAlias, did) => Some(did),\n+            Res::Err => None,\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "08b4ef1b918e1afc81221f6301703ea7d30291f2", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -121,6 +121,8 @@ impl<'a> FnKind<'a> {\n \n /// An abstract representation of the HIR `rustc::hir::map::Map`.\n pub trait Map<'hir> {\n+    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n+    fn find(&self, hir_id: HirId) -> Option<Node<'hir>>;\n     fn body(&self, id: BodyId) -> &'hir Body<'hir>;\n     fn item(&self, id: HirId) -> &'hir Item<'hir>;\n     fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir>;\n@@ -132,6 +134,9 @@ pub trait Map<'hir> {\n pub struct ErasedMap<'hir>(&'hir dyn Map<'hir>);\n \n impl<'hir> Map<'hir> for ErasedMap<'hir> {\n+    fn find(&self, _: HirId) -> Option<Node<'hir>> {\n+        None\n+    }\n     fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.0.body(id)\n     }"}, {"sha": "49692c73fad80fb3b9fac8a3eeb71710144d56e4", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -7,6 +7,7 @@\n #![feature(const_fn)] // For the unsizing cast on `&[]`\n #![feature(const_panic)]\n #![feature(in_band_lifetimes)]\n+#![feature(or_patterns)]\n #![feature(specialization)]\n #![recursion_limit = \"256\"]\n \n@@ -23,7 +24,6 @@ pub mod intravisit;\n pub mod itemlikevisit;\n pub mod lang_items;\n pub mod pat_util;\n-pub mod print;\n mod stable_hash_impls;\n mod target;\n pub mod weak_lang_items;"}, {"sha": "6a9339b4b9cee874ce67c7e617be30b42adddc5f", "filename": "src/librustc_hir_pretty/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2FCargo.toml?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_hir_pretty\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_hir_pretty\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_target = { path = \"../librustc_target\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_span = { path = \"../librustc_span\" }\n+rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "88b1288848f4f6dddbfd2a90dbee60a53a9cb16b", "filename": "src/librustc_hir_pretty/lib.rs", "status": "renamed", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -1,21 +1,26 @@\n+#![recursion_limit = \"256\"]\n+\n use rustc_ast::ast;\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast_pretty::pp::Breaks::{Consistent, Inconsistent};\n use rustc_ast_pretty::pp::{self, Breaks};\n use rustc_ast_pretty::pprust::{Comments, PrintState};\n+use rustc_hir as hir;\n+use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node};\n+use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, IdentPrinter};\n use rustc_span::{self, BytePos, FileName};\n use rustc_target::spec::abi::Abi;\n \n-use crate::hir;\n-use crate::hir::{GenericArg, GenericParam, GenericParamKind, Node};\n-use crate::hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n-\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::vec;\n \n+pub fn id_to_string(map: &dyn rustc_hir::intravisit::Map<'_>, hir_id: hir::HirId) -> String {\n+    to_string(&map, |s| s.print_node(map.find(hir_id).unwrap()))\n+}\n+\n pub enum AnnNode<'a> {\n     Name(&'a ast::Name),\n     Block(&'a hir::Block<'a>),\n@@ -47,7 +52,7 @@ pub struct NoAnn;\n impl PpAnn for NoAnn {}\n pub const NO_ANN: &dyn PpAnn = &NoAnn;\n \n-impl PpAnn for hir::Crate<'a> {\n+impl PpAnn for hir::Crate<'_> {\n     fn try_fetch_item(&self, item: hir::HirId) -> Option<&hir::Item<'_>> {\n         Some(self.item(item))\n     }\n@@ -62,6 +67,20 @@ impl PpAnn for hir::Crate<'a> {\n     }\n }\n \n+/// Identical to the `PpAnn` implementation for `hir::Crate`,\n+/// except it avoids creating a dependency on the whole crate.\n+impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n+    fn nested(&self, state: &mut State<'_>, nested: Nested) {\n+        match nested {\n+            Nested::Item(id) => state.print_item(self.item(id.id)),\n+            Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n+            Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n+            Nested::Body(id) => state.print_expr(&self.body(id).value),\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat),\n+        }\n+    }\n+}\n+\n pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n@@ -1006,10 +1025,10 @@ impl<'a> State<'a> {\n         close_box: bool,\n     ) {\n         match blk.rules {\n-            hir::UnsafeBlock(..) => self.word_space(\"unsafe\"),\n-            hir::PushUnsafeBlock(..) => self.word_space(\"push_unsafe\"),\n-            hir::PopUnsafeBlock(..) => self.word_space(\"pop_unsafe\"),\n-            hir::DefaultBlock => (),\n+            hir::BlockCheckMode::UnsafeBlock(..) => self.word_space(\"unsafe\"),\n+            hir::BlockCheckMode::PushUnsafeBlock(..) => self.word_space(\"push_unsafe\"),\n+            hir::BlockCheckMode::PopUnsafeBlock(..) => self.word_space(\"pop_unsafe\"),\n+            hir::BlockCheckMode::DefaultBlock => (),\n         }\n         self.maybe_print_comment(blk.span.lo());\n         self.ann.pre(self, AnnNode::Block(blk));\n@@ -1092,7 +1111,7 @@ impl<'a> State<'a> {\n         &mut self,\n         qpath: &hir::QPath<'_>,\n         fields: &[hir::Field<'_>],\n-        wth: &Option<&'hir hir::Expr<'_>>,\n+        wth: &Option<&hir::Expr<'_>>,\n     ) {\n         self.print_qpath(qpath, true);\n         self.s.word(\"{\");\n@@ -1848,7 +1867,8 @@ impl<'a> State<'a> {\n                 self.print_block_unclosed(&blk);\n \n                 // If it is a user-provided unsafe block, print a comma after it\n-                if let hir::UnsafeBlock(hir::UserProvided) = blk.rules {\n+                if let hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::UserProvided) = blk.rules\n+                {\n                     self.s.word(\",\");\n                 }\n             }\n@@ -1928,18 +1948,18 @@ impl<'a> State<'a> {\n         });\n         self.s.word(\"|\");\n \n-        if let hir::DefaultReturn(..) = decl.output {\n+        if let hir::FnRetTy::DefaultReturn(..) = decl.output {\n             return;\n         }\n \n         self.space_if_not_bol();\n         self.word_space(\"->\");\n         match decl.output {\n-            hir::Return(ref ty) => {\n+            hir::FnRetTy::Return(ref ty) => {\n                 self.print_type(&ty);\n                 self.maybe_print_comment(ty.span.lo())\n             }\n-            hir::DefaultReturn(..) => unreachable!(),\n+            hir::FnRetTy::DefaultReturn(..) => unreachable!(),\n         }\n     }\n \n@@ -2112,21 +2132,21 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_output(&mut self, decl: &hir::FnDecl<'_>) {\n-        if let hir::DefaultReturn(..) = decl.output {\n+        if let hir::FnRetTy::DefaultReturn(..) = decl.output {\n             return;\n         }\n \n         self.space_if_not_bol();\n         self.ibox(INDENT_UNIT);\n         self.word_space(\"->\");\n         match decl.output {\n-            hir::DefaultReturn(..) => unreachable!(),\n-            hir::Return(ref ty) => self.print_type(&ty),\n+            hir::FnRetTy::DefaultReturn(..) => unreachable!(),\n+            hir::FnRetTy::Return(ref ty) => self.print_type(&ty),\n         }\n         self.end();\n \n         match decl.output {\n-            hir::Return(ref output) => self.maybe_print_comment(output.span.lo()),\n+            hir::FnRetTy::Return(ref output) => self.maybe_print_comment(output.span.lo()),\n             _ => {}\n         }\n     }", "previous_filename": "src/librustc_hir/print.rs"}, {"sha": "ea439b1f41d4252cfc757544e39c8418bdb3a98f", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -19,6 +19,7 @@ rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "3686b2f20487b0844d5eef190e5f60a0c94b1a67", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -824,8 +824,10 @@ impl EncodeContext<'tcx> {\n \n         record!(self.per_def.kind[def_id] <- match trait_item.kind {\n             ty::AssocKind::Const => {\n-                let rendered =\n-                    hir::print::to_string(&self.tcx.hir(), |s| s.print_trait_item(ast_item));\n+                let rendered = rustc_hir_pretty::to_string(\n+                    &(&self.tcx.hir() as &dyn intravisit::Map<'_>),\n+                    |s| s.print_trait_item(ast_item)\n+                );\n                 let rendered_const = self.lazy(RenderedConst(rendered));\n \n                 EntryKind::AssocConst(\n@@ -1044,8 +1046,11 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n-        let body = self.tcx.hir().body(body_id);\n-        let rendered = hir::print::to_string(&self.tcx.hir(), |s| s.print_expr(&body.value));\n+        let hir = self.tcx.hir();\n+        let body = hir.body(body_id);\n+        let rendered = rustc_hir_pretty::to_string(&(&hir as &dyn intravisit::Map<'_>), |s| {\n+            s.print_expr(&body.value)\n+        });\n         let rendered_const = &RenderedConst(rendered);\n         self.lazy(rendered_const)\n     }"}, {"sha": "e729c2d517feaeae4c9289e867be816fa508159f", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -903,10 +903,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn compute(&mut self, body: &hir::Expr<'_>) -> LiveNode {\n-        debug!(\n-            \"compute: using id for body, {}\",\n-            self.ir.tcx.hir().hir_to_pretty_string(body.hir_id)\n-        );\n+        debug!(\"compute: using id for body, {:?}\", body);\n \n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n@@ -979,7 +976,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn propagate_through_expr(&mut self, expr: &Expr<'_>, succ: LiveNode) -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n+        debug!(\"propagate_through_expr: {:?}\", expr);\n \n         match expr.kind {\n             // Interesting cases with control flow or which gen/kill\n@@ -990,10 +987,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::Field(ref e, _) => self.propagate_through_expr(&e, succ),\n \n             hir::ExprKind::Closure(..) => {\n-                debug!(\n-                    \"{} is an ExprKind::Closure\",\n-                    self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id)\n-                );\n+                debug!(\"{:?} is an ExprKind::Closure\", expr);\n \n                 // the construction of a closure itself is not important,\n                 // but we have to consider the closed over variables.\n@@ -1344,11 +1338,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut first_merge = true;\n         let ln = self.live_node(expr.hir_id, expr.span);\n         self.init_empty(ln, succ);\n-        debug!(\n-            \"propagate_through_loop: using id for loop body {} {}\",\n-            expr.hir_id,\n-            self.ir.tcx.hir().hir_to_pretty_string(body.hir_id)\n-        );\n+        debug!(\"propagate_through_loop: using id for loop body {} {:?}\", expr.hir_id, body);\n \n         self.break_ln.insert(expr.hir_id, succ);\n "}, {"sha": "0df1d08cbd8bdd382e9f326e5712304b308388d2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -1320,14 +1320,18 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             let is_local_static =\n                 if let DefKind::Static = kind { def_id.is_local() } else { false };\n             if !self.item_is_accessible(def_id) && !is_local_static {\n-                let name = match *qpath {\n-                    hir::QPath::Resolved(_, ref path) => path.to_string(),\n-                    hir::QPath::TypeRelative(_, ref segment) => segment.ident.to_string(),\n+                let sess = self.tcx.sess;\n+                let sm = sess.source_map();\n+                let name = match qpath {\n+                    hir::QPath::Resolved(_, path) => sm.span_to_snippet(path.span).ok(),\n+                    hir::QPath::TypeRelative(_, segment) => Some(segment.ident.to_string()),\n                 };\n                 let kind = kind.descr(def_id);\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(span, &format!(\"{} `{}` is private\", kind, name))\n+                let msg = match name {\n+                    Some(name) => format!(\"{} `{}` is private\", kind, name),\n+                    None => format!(\"{} is private\", kind),\n+                };\n+                sess.struct_span_err(span, &msg)\n                     .span_label(span, &format!(\"private {}\", kind))\n                     .emit();\n                 return;"}, {"sha": "623da1ddcb4258971df6d12bfa6f2a012e173151", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -11,13 +11,14 @@ path = \"lib.rs\"\n [dependencies]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n+rustc_ast = { path = \"../librustc_ast\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_session = { path = \"../librustc_session\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_parse = { path = \"../librustc_parse\" }\n serde_json = \"1\"\n-rustc_ast = { path = \"../librustc_ast\" }\n+rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rls-data = \"0.19\"\n rls-span = \"0.5\""}, {"sha": "21551eeddb927b3a05554f3f7a2485f87d461bdb", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -404,14 +404,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n                 Some(Node::Item(item)) => match item.kind {\n                     hir::ItemKind::Impl { ref self_ty, .. } => {\n+                        let hir = self.tcx.hir();\n+\n                         let mut qualname = String::from(\"<\");\n-                        qualname.push_str(&self.tcx.hir().hir_to_pretty_string(self_ty.hir_id));\n+                        qualname.push_str(&rustc_hir_pretty::id_to_string(&hir, self_ty.hir_id));\n \n                         let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n-                        let hir_id = self.tcx.hir().node_to_hir_id(id);\n-                        if let Some(Node::ImplItem(item)) = self.tcx.hir().find(hir_id) {\n+                        if let Some(Node::ImplItem(item)) = hir.find(hir.node_to_hir_id(id)) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }"}, {"sha": "8cbed43cac01df032112a10ae05c571cba69f30d", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -1581,7 +1581,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 for param in generics.params {\n                     if param.span == *span\n                         && !param.bounds.iter().any(|bound| {\n-                            bound.trait_def_id() == self.tcx.lang_items().sized_trait()\n+                            bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n+                                == self.tcx.lang_items().sized_trait()\n                         })\n                     {\n                         let (span, separator) = match param.bounds {"}, {"sha": "7d4ad61902a926f923f92621b0ebeb77a3b8efad", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -15,7 +15,7 @@ use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n@@ -170,6 +170,24 @@ fn object_safety_violations_for_trait(\n     violations\n }\n \n+fn sized_trait_bound_spans<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bounds: hir::GenericBounds<'tcx>,\n+) -> impl 'tcx + Iterator<Item = Span> {\n+    bounds.iter().filter_map(move |b| match b {\n+        hir::GenericBound::Trait(trait_ref, hir::TraitBoundModifier::None)\n+            if trait_has_sized_self(\n+                tcx,\n+                trait_ref.trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise()),\n+            ) =>\n+        {\n+            // Fetch spans for supertraits that are `Sized`: `trait T: Super`\n+            Some(trait_ref.span)\n+        }\n+        _ => None,\n+    })\n+}\n+\n fn get_sized_bounds(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span; 1]> {\n     tcx.hir()\n         .get_if_local(trait_def_id)\n@@ -189,33 +207,14 @@ fn get_sized_bounds(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span; 1]>\n                             {\n                                 // Fetch spans for trait bounds that are Sized:\n                                 // `trait T where Self: Pred`\n-                                Some(pred.bounds.iter().filter_map(|b| match b {\n-                                    hir::GenericBound::Trait(\n-                                        trait_ref,\n-                                        hir::TraitBoundModifier::None,\n-                                    ) if trait_has_sized_self(\n-                                        tcx,\n-                                        trait_ref.trait_ref.trait_def_id(),\n-                                    ) =>\n-                                    {\n-                                        Some(trait_ref.span)\n-                                    }\n-                                    _ => None,\n-                                }))\n+                                Some(sized_trait_bound_spans(tcx, pred.bounds))\n                             }\n                             _ => None,\n                         }\n                     })\n                     .flatten()\n-                    .chain(bounds.iter().filter_map(|b| match b {\n-                        hir::GenericBound::Trait(trait_ref, hir::TraitBoundModifier::None)\n-                            if trait_has_sized_self(tcx, trait_ref.trait_ref.trait_def_id()) =>\n-                        {\n-                            // Fetch spans for supertraits that are `Sized`: `trait T: Super`\n-                            Some(trait_ref.span)\n-                        }\n-                        _ => None,\n-                    }))\n+                    // Fetch spans for supertraits that are `Sized`: `trait T: Super`.\n+                    .chain(sized_trait_bound_spans(tcx, bounds))\n                     .collect::<SmallVec<[Span; 1]>>(),\n             ),\n             _ => None,"}, {"sha": "07630d7969e81178839b5c7efa597cc53c5b073b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -16,12 +16,11 @@ use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc_ast::ast;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{walk_generics, Visitor};\n-use rustc_hir::print;\n+use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{Constness, GenericArg, GenericArgs};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, LATE_BOUND_LIFETIME_ARGUMENTS};\n use rustc_session::parse::feature_err;\n@@ -991,7 +990,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         self.ast_path_to_mono_trait_ref(\n             trait_ref.path.span,\n-            trait_ref.trait_def_id(),\n+            trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise()),\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n         )\n@@ -1007,7 +1006,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n     ) -> Result<(), GenericArgCountMismatch> {\n-        let trait_def_id = trait_ref.trait_def_id();\n+        let trait_def_id = trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise());\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n@@ -1118,6 +1117,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if !self.tcx().features().unboxed_closures\n             && trait_segment.generic_args().parenthesized != trait_def.paren_sugar\n         {\n+            let sess = &self.tcx().sess.parse_sess;\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let (msg, sugg) = if trait_def.paren_sugar {\n                 (\n@@ -1132,7 +1132,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             .and_then(|args| args.args.get(0))\n                             .and_then(|arg| match arg {\n                                 hir::GenericArg::Type(ty) => {\n-                                    Some(print::to_string(print::NO_ANN, |s| s.print_type(ty)))\n+                                    sess.source_map().span_to_snippet(ty.span).ok()\n                                 }\n                                 _ => None,\n                             })\n@@ -1143,7 +1143,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             .iter()\n                             .filter_map(|b| match (b.ident.as_str() == \"Output\", &b.kind) {\n                                 (true, hir::TypeBindingKind::Equality { ty }) => {\n-                                    Some(print::to_string(print::NO_ANN, |s| s.print_type(ty)))\n+                                    sess.source_map().span_to_snippet(ty.span).ok()\n                                 }\n                                 _ => None,\n                             })\n@@ -1154,7 +1154,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             } else {\n                 (\"parenthetical notation is only stable when used with `Fn`-family traits\", None)\n             };\n-            let sess = &self.tcx().sess.parse_sess;\n             let mut err = feature_err(sess, sym::unboxed_closures, span, msg);\n             if let Some(sugg) = sugg {\n                 let msg = \"use parenthetical notation instead\";"}, {"sha": "b44bab2675d37562f99b9ce244ca0ccbdc31ec81", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -245,11 +245,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             {\n                 // check that the `if` expr without `else` is the fn body's expr\n                 if expr.span == span {\n-                    return self.get_fn_decl(hir_id).map(|(fn_decl, _)| {\n-                        (\n-                            fn_decl.output.span(),\n-                            format!(\"expected `{}` because of this return type\", fn_decl.output),\n-                        )\n+                    return self.get_fn_decl(hir_id).and_then(|(fn_decl, _)| {\n+                        let span = fn_decl.output.span();\n+                        let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok()?;\n+                        Some((span, format!(\"expected `{}` because of this return type\", snippet)))\n                     });\n                 }\n             }"}, {"sha": "074951684ef06c2ffc633f27463dc4293ed80841", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -265,7 +265,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let &ty::Adt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprKind::Call(ref expr, _) = call_expr.kind {\n-                            unit_variant = Some(self.tcx.hir().hir_to_pretty_string(expr.hir_id))\n+                            unit_variant =\n+                                self.tcx.sess.source_map().span_to_snippet(expr.span).ok();\n                         }\n                     }\n                 }\n@@ -335,16 +336,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_label(call_expr.span, \"call expression requires function\");\n \n                     if let Some(span) = self.tcx.hir().res_span(def) {\n+                        let callee_ty = callee_ty.to_string();\n                         let label = match (unit_variant, inner_callee_path) {\n-                            (Some(path), _) => format!(\"`{}` defined here\", path),\n-                            (_, Some(hir::QPath::Resolved(_, path))) => format!(\n-                                \"`{}` defined here returns `{}`\",\n-                                path,\n-                                callee_ty.to_string()\n-                            ),\n-                            _ => format!(\"`{}` defined here\", callee_ty.to_string()),\n+                            (Some(path), _) => Some(format!(\"`{}` defined here\", path)),\n+                            (_, Some(hir::QPath::Resolved(_, path))) => {\n+                                self.tcx.sess.source_map().span_to_snippet(path.span).ok().map(\n+                                    |p| format!(\"`{}` defined here returns `{}`\", p, callee_ty),\n+                                )\n+                            }\n+                            _ => Some(format!(\"`{}` defined here\", callee_ty)),\n                         };\n-                        err.span_label(span, label);\n+                        if let Some(label) = label {\n+                            err.span_label(span, label);\n+                        }\n                     }\n                     err.emit();\n                 } else {"}, {"sha": "2dc2a48ecbce82f2fdfae9d657ad761d5fe2503b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -1402,9 +1402,12 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     {\n                         // Are of this `impl Trait`'s traits object safe?\n                         is_object_safe = bounds.iter().all(|bound| {\n-                            bound.trait_def_id().map_or(false, |def_id| {\n-                                fcx.tcx.object_safety_violations(def_id).is_empty()\n-                            })\n+                            bound\n+                                .trait_ref()\n+                                .and_then(|t| t.trait_def_id())\n+                                .map_or(false, |def_id| {\n+                                    fcx.tcx.object_safety_violations(def_id).is_empty()\n+                                })\n                         })\n                     }\n                 }"}, {"sha": "f7ffb5a2218baa75d36c2fe533b0c1f14e3c8ee0", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -9,7 +9,7 @@ use rustc::ty::{self, AssocItem, Ty};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::{is_range_literal, print, Node};\n+use rustc_hir::{is_range_literal, Node};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -198,13 +198,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .peekable();\n \n             if compatible_variants.peek().is_some() {\n-                let expr_text =\n-                    self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap_or_else(|_| {\n-                        print::to_string(print::NO_ANN, |s| s.print_expr(expr))\n-                    });\n-                let suggestions = compatible_variants.map(|v| format!(\"{}({})\", v, expr_text));\n-                let msg = \"try using a variant of the expected enum\";\n-                err.span_suggestions(expr.span, msg, suggestions, Applicability::MaybeIncorrect);\n+                if let Ok(expr_text) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+                    let suggestions = compatible_variants.map(|v| format!(\"{}({})\", v, expr_text));\n+                    let msg = \"try using a variant of the expected enum\";\n+                    err.span_suggestions(\n+                        expr.span,\n+                        msg,\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "53a20d9e867888fe63ec3d556e5f0059b393ba15", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -475,7 +475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tcx.types.err\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n-                report_unexpected_variant_res(tcx, res, expr.span, qpath);\n+                report_unexpected_variant_res(tcx, res, expr.span);\n                 tcx.types.err\n             }\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n@@ -696,10 +696,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self,\n                     &cause,\n                     &mut |db| {\n-                        db.span_label(\n-                            fn_decl.output.span(),\n-                            format!(\"expected `{}` because of this return type\", fn_decl.output,),\n-                        );\n+                        let span = fn_decl.output.span();\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                            db.span_label(\n+                                span,\n+                                format!(\"expected `{}` because of this return type\", snippet),\n+                            );\n+                        }\n                     },\n                     true,\n                 );\n@@ -1668,20 +1671,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let (Some(len), Ok(user_index)) =\n             (len.try_eval_usize(self.tcx, self.param_env), field.as_str().parse::<u64>())\n         {\n-            let base = self\n-                .tcx\n-                .sess\n-                .source_map()\n-                .span_to_snippet(base.span)\n-                .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-            let help = \"instead of using tuple indexing, use array indexing\";\n-            let suggestion = format!(\"{}[{}]\", base, field);\n-            let applicability = if len < user_index {\n-                Applicability::MachineApplicable\n-            } else {\n-                Applicability::MaybeIncorrect\n-            };\n-            err.span_suggestion(expr.span, help, suggestion, applicability);\n+            if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n+                let help = \"instead of using tuple indexing, use array indexing\";\n+                let suggestion = format!(\"{}[{}]\", base, field);\n+                let applicability = if len < user_index {\n+                    Applicability::MachineApplicable\n+                } else {\n+                    Applicability::MaybeIncorrect\n+                };\n+                err.span_suggestion(expr.span, help, suggestion, applicability);\n+            }\n         }\n     }\n \n@@ -1692,15 +1691,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &hir::Expr<'_>,\n         field: ast::Ident,\n     ) {\n-        let base = self\n-            .tcx\n-            .sess\n-            .source_map()\n-            .span_to_snippet(base.span)\n-            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n-        let suggestion = format!(\"(*{}).{}\", base, field);\n-        err.span_suggestion(expr.span, &msg, suggestion, Applicability::MaybeIncorrect);\n+        if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n+            let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n+            let suggestion = format!(\"(*{}).{}\", base, field);\n+            err.span_suggestion(expr.span, &msg, suggestion, Applicability::MaybeIncorrect);\n+        }\n     }\n \n     fn no_such_field_err<T: Display>("}, {"sha": "688820029febc95a49e3496ba1bbf6aad898d05a", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -1061,7 +1061,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let trait_def_ids: FxHashSet<DefId> = param\n                                     .bounds\n                                     .iter()\n-                                    .filter_map(|bound| bound.trait_def_id())\n+                                    .filter_map(|bound| Some(bound.trait_ref()?.trait_def_id()?))\n                                     .collect();\n                                 if !candidates.iter().any(|t| trait_def_ids.contains(&t.def_id)) {\n                                     err.span_suggestions("}, {"sha": "f188ee0a13c3d2197551d9d02f316fb142219f0c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -2677,14 +2677,14 @@ pub fn check_enum<'tcx>(\n     check_transparent(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &QPath<'_>) {\n+fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span) {\n     struct_span_err!(\n         tcx.sess,\n         span,\n         E0533,\n-        \"expected unit struct, unit variant or constant, found {} `{}`\",\n+        \"expected unit struct, unit variant or constant, found {}{}\",\n         res.descr(),\n-        hir::print::to_string(&tcx.hir(), |s| s.print_qpath(qpath, false))\n+        tcx.sess.source_map().span_to_snippet(span).map_or(String::new(), |s| format!(\" `{}`\", s)),\n     )\n     .emit();\n }"}, {"sha": "ec703d5ec9e9a2e8ffc9e9e5431d96dae1a35924", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -171,9 +171,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             PatKind::TupleStruct(ref qpath, subpats, ddpos) => {\n                 self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n             }\n-            PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_res.unwrap(), qpath, expected, ti)\n-            }\n+            PatKind::Path(_) => self.check_pat_path(pat, path_res.unwrap(), expected, ti),\n             PatKind::Struct(ref qpath, fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n             }\n@@ -694,7 +692,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat: &Pat<'_>,\n         path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]),\n-        qpath: &hir::QPath<'_>,\n         expected: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -707,17 +704,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.set_tainted_by_errors();\n                 return tcx.types.err;\n             }\n-            Res::Def(DefKind::AssocFn, _)\n-            | Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _)\n-            | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n-                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n+            Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fictive | CtorKind::Fn), _) => {\n+                report_unexpected_variant_res(tcx, res, pat.span);\n                 return tcx.types.err;\n             }\n-            Res::Def(DefKind::Ctor(_, CtorKind::Const), _)\n-            | Res::SelfCtor(..)\n-            | Res::Def(DefKind::Const, _)\n-            | Res::Def(DefKind::AssocConst, _)\n-            | Res::Def(DefKind::ConstParam, _) => {} // OK\n+            Res::SelfCtor(..)\n+            | Res::Def(\n+                DefKind::Ctor(_, CtorKind::Const)\n+                | DefKind::Const\n+                | DefKind::AssocConst\n+                | DefKind::ConstParam,\n+                _,\n+            ) => {} // OK\n             _ => bug!(\"unexpected pattern resolution: {:?}\", res),\n         }\n \n@@ -791,14 +789,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n+            let sm = tcx.sess.source_map();\n+            let path_str = sm\n+                .span_to_snippet(sm.span_until_char(pat.span, '('))\n+                .map_or(String::new(), |s| format!(\" `{}`\", s.trim_end()));\n             let msg = format!(\n-                \"expected tuple struct or tuple variant, found {} `{}`\",\n+                \"expected tuple struct or tuple variant, found {}{}\",\n                 res.descr(),\n-                hir::print::to_string(&tcx.hir(), |s| s.print_qpath(qpath, false)),\n+                path_str\n             );\n+\n             let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n-            match (res, &pat.kind) {\n-                (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::AssocFn, _), _) => {\n+            match res {\n+                Res::Def(DefKind::Fn | DefKind::AssocFn, _) => {\n                     err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n                     err.help(\n                         \"for more information, visit \\"}, {"sha": "9d8113e7b3fff4942f9665b69bf825e8d772ba5c", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -5,7 +5,6 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::print::visibility_qualified;\n use rustc_session::lint;\n use rustc_span::Span;\n \n@@ -176,16 +175,13 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n                 Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n                 None => format!(\"use {};\", item.ident.name),\n             };\n-\n-            let replacement = visibility_qualified(&item.vis, base_replacement);\n-            let msg = \"`extern crate` is not idiomatic in the new edition\";\n-            let help = format!(\"convert it to a `{}`\", visibility_qualified(&item.vis, \"use\"));\n-\n-            lint.build(msg)\n+            let vis = tcx.sess.source_map().span_to_snippet(item.vis.span).unwrap_or_default();\n+            let add_vis = |to| if vis.is_empty() { to } else { format!(\"{} {}\", vis, to) };\n+            lint.build(\"`extern crate` is not idiomatic in the new edition\")\n                 .span_suggestion_short(\n                     extern_crate.span,\n-                    &help,\n-                    replacement,\n+                    &format!(\"convert it to a `{}`\", add_vis(\"use\".to_string())),\n+                    add_vis(base_replacement),\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();"}, {"sha": "31123c5cf028c410862f87e02c36b95a673017fd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -2146,13 +2146,18 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     {\n         let check = |ast_ty: &hir::Ty<'_>, ty: Ty<'_>| {\n             if ty.is_simd() {\n+                let snip = tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(ast_ty.span)\n+                    .map_or(String::new(), |s| format!(\" `{}`\", s));\n                 tcx.sess\n                     .struct_span_err(\n                         ast_ty.span,\n                         &format!(\n-                            \"use of SIMD type `{}` in FFI is highly experimental and \\\n+                            \"use of SIMD type{} in FFI is highly experimental and \\\n                              may result in invalid code\",\n-                            tcx.hir().hir_to_pretty_string(ast_ty.hir_id)\n+                            snip\n                         ),\n                     )\n                     .help(\"add `#![feature(simd_ffi)]` to the crate attributes to enable\")"}, {"sha": "510eae82834c873d4557bcd8021066985282ada7", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -482,8 +482,8 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n }\n \n pub fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {\n-    if let Some(node_id) = cx.tcx.hir().as_local_hir_id(did) {\n-        cx.tcx.hir().hir_to_pretty_string(node_id)\n+    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n+        rustc_hir_pretty::id_to_string(&cx.tcx.hir(), hir_id)\n     } else {\n         cx.tcx.rendered_const(did)\n     }"}, {"sha": "b3bfb559749cb4143b9423c8c62adb9b3acbfcb0", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -578,7 +578,7 @@ pub fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n         None\n     };\n \n-    snippet.unwrap_or_else(|| cx.tcx.hir().hir_to_pretty_string(body.hir_id))\n+    snippet.unwrap_or_else(|| rustc_hir_pretty::id_to_string(&cx.tcx.hir(), body.hir_id))\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}, {"sha": "3c5df0247c1e8f382d18fb3b52ae1e616eec2a3d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -26,6 +26,7 @@ extern crate rustc_errors;\n extern crate rustc_expand;\n extern crate rustc_feature;\n extern crate rustc_hir;\n+extern crate rustc_hir_pretty;\n extern crate rustc_index;\n extern crate rustc_infer;\n extern crate rustc_interface;"}, {"sha": "93305a1f87a16e7e079d705720932e087a85c610", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -910,7 +910,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n         let name = if let hir::ItemKind::Impl { ref self_ty, .. } = item.kind {\n-            self.map.hir_to_pretty_string(self_ty.hir_id)\n+            rustc_hir_pretty::id_to_string(&self.map, self_ty.hir_id)\n         } else {\n             item.ident.to_string()\n         };"}, {"sha": "ed3c0222c7542bdd71fbc961774c7e065df9550c", "filename": "src/test/ui/methods/method-path-in-pattern.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Ftest%2Fui%2Fmethods%2Fmethod-path-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Ftest%2Fui%2Fmethods%2Fmethod-path-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-path-in-pattern.stderr?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -4,13 +4,13 @@ error[E0533]: expected unit struct, unit variant or constant, found associated f\n LL |         Foo::bar => {}\n    |         ^^^^^^^^\n \n-error[E0533]: expected unit struct, unit variant or constant, found associated function `Foo::bar`\n+error[E0533]: expected unit struct, unit variant or constant, found associated function `<Foo>::bar`\n   --> $DIR/method-path-in-pattern.rs:19:9\n    |\n LL |         <Foo>::bar => {}\n    |         ^^^^^^^^^^\n \n-error[E0533]: expected unit struct, unit variant or constant, found associated function `Foo::trait_bar`\n+error[E0533]: expected unit struct, unit variant or constant, found associated function `<Foo>::trait_bar`\n   --> $DIR/method-path-in-pattern.rs:23:9\n    |\n LL |         <Foo>::trait_bar => {}\n@@ -22,7 +22,7 @@ error[E0533]: expected unit struct, unit variant or constant, found associated f\n LL |     if let Foo::bar = 0u32 {}\n    |            ^^^^^^^^\n \n-error[E0533]: expected unit struct, unit variant or constant, found associated function `Foo::bar`\n+error[E0533]: expected unit struct, unit variant or constant, found associated function `<Foo>::bar`\n   --> $DIR/method-path-in-pattern.rs:28:12\n    |\n LL |     if let <Foo>::bar = 0u32 {}"}, {"sha": "b1482bc040f5332b2bc273af26be316fa9f1303b", "filename": "src/test/ui/privacy/associated-item-privacy-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.rs?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -21,9 +21,9 @@ mod priv_trait {\n         Pub.method();\n         //~^ ERROR type `for<'r> fn(&'r Self) {<Self as priv_trait::PrivTr>::method}` is private\n         <Pub as PrivTr>::CONST;\n-        //~^ ERROR associated constant `PrivTr::CONST` is private\n+        //~^ ERROR associated constant `<Pub as PrivTr>::CONST` is private\n         let _: <Pub as PrivTr>::AssocTy;\n-        //~^ ERROR associated type `PrivTr::AssocTy` is private\n+        //~^ ERROR associated type `<Pub as PrivTr>::AssocTy` is private\n         pub type InSignatureTy = <Pub as PrivTr>::AssocTy;\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n         pub trait InSignatureTr: PrivTr {}\n@@ -115,7 +115,7 @@ mod priv_parent_substs {\n         <Priv as PubTr<_>>::CONST;\n         //~^ ERROR type `priv_parent_substs::Priv` is private\n \n-        let _: <Pub as PubTr>::AssocTy;  // FIXME no longer an error?!\n+        let _: <Pub as PubTr>::AssocTy; // FIXME no longer an error?!\n         let _: <Pub as PubTr<_>>::AssocTy;\n         //~^ ERROR type `priv_parent_substs::Priv` is private\n         let _: <Priv as PubTr<_>>::AssocTy;"}, {"sha": "b9f3e35d72261813e846413f40ab73bc4985b6e2", "filename": "src/test/ui/privacy/associated-item-privacy-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.stderr?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -31,7 +31,7 @@ LL |     priv_trait::mac!();\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: associated constant `PrivTr::CONST` is private\n+error: associated constant `<Pub as PrivTr>::CONST` is private\n   --> $DIR/associated-item-privacy-trait.rs:23:9\n    |\n LL |         <Pub as PrivTr>::CONST;\n@@ -42,7 +42,7 @@ LL |     priv_trait::mac!();\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: associated type `PrivTr::AssocTy` is private\n+error: associated type `<Pub as PrivTr>::AssocTy` is private\n   --> $DIR/associated-item-privacy-trait.rs:25:16\n    |\n LL |         let _: <Pub as PrivTr>::AssocTy;"}, {"sha": "4214e2503c345cad36a3a4e12df95e88e21fcbd5", "filename": "src/test/ui/qualified/qualified-path-params.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7041efcfc3f771f5fe72aede1af69180683df286/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7041efcfc3f771f5fe72aede1af69180683df286/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr?ref=7041efcfc3f771f5fe72aede1af69180683df286", "patch": "@@ -1,4 +1,4 @@\n-error[E0533]: expected unit struct, unit variant or constant, found associated function `<<S as Tr>::A>::f<u8>`\n+error[E0533]: expected unit struct, unit variant or constant, found associated function `<S as Tr>::A::f::<u8>`\n   --> $DIR/qualified-path-params.rs:20:9\n    |\n LL |         <S as Tr>::A::f::<u8> => {}"}]}