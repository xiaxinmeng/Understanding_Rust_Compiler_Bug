{"sha": "ece3543c9f292c77b6a388eff6d3d5b857092f9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZTM1NDNjOWYyOTJjNzdiNmEzODhlZmY2ZDNkNWI4NTcwOTJmOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-02T15:36:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-02T15:36:00Z"}, "message": "Auto merge of #6801 - Jarcho:manual_match_fix, r=phansch\n\nFix `manual_map` false positives\n\nfixes: #6795\nfixes: #6797\nfixes: #6811\nfixes: #6819\n\nchangelog: Fix false positives for `manual_map` when `return`, `break`, `continue`, `yield`, `await`, and partially moved values are used.\nchangelog: Don't expand macros in suggestions  for `manual_map`", "tree": {"sha": "0afb3a0bf7fc5a73a8da3693aafcf9f2017fc651", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0afb3a0bf7fc5a73a8da3693aafcf9f2017fc651"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ece3543c9f292c77b6a388eff6d3d5b857092f9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ece3543c9f292c77b6a388eff6d3d5b857092f9b", "html_url": "https://github.com/rust-lang/rust/commit/ece3543c9f292c77b6a388eff6d3d5b857092f9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ece3543c9f292c77b6a388eff6d3d5b857092f9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb04beb00558fd25499541e7caa49f95a9beb243", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb04beb00558fd25499541e7caa49f95a9beb243", "html_url": "https://github.com/rust-lang/rust/commit/eb04beb00558fd25499541e7caa49f95a9beb243"}, {"sha": "2c485e36cdd76bc887278820822ffc053c5b3b83", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c485e36cdd76bc887278820822ffc053c5b3b83", "html_url": "https://github.com/rust-lang/rust/commit/2c485e36cdd76bc887278820822ffc053c5b3b83"}], "stats": {"total": 444, "additions": 348, "deletions": 96}, "files": [{"sha": "183778cb55eba265ac398db224f6045f75fdd434", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ece3543c9f292c77b6a388eff6d3d5b857092f9b/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece3543c9f292c77b6a388eff6d3d5b857092f9b/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ece3543c9f292c77b6a388eff6d3d5b857092f9b", "patch": "@@ -1543,6 +1543,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n+        LintId::of(&manual_map::MANUAL_MAP),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&manual_strip::MANUAL_STRIP),\n         LintId::of(&manual_unwrap_or::MANUAL_UNWRAP_OR),\n@@ -1774,6 +1775,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n+        LintId::of(&manual_map::MANUAL_MAP),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n@@ -2050,7 +2052,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n         LintId::of(&future_not_send::FUTURE_NOT_SEND),\n         LintId::of(&let_if_seq::USELESS_LET_IF_SEQ),\n-        LintId::of(&manual_map::MANUAL_MAP),\n         LintId::of(&missing_const_for_fn::MISSING_CONST_FOR_FN),\n         LintId::of(&mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n         LintId::of(&mutex_atomic::MUTEX_INTEGER),"}, {"sha": "ac1d51e1993b481581627a5c5b576954b55a6c81", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 137, "deletions": 73, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/ece3543c9f292c77b6a388eff6d3d5b857092f9b/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece3543c9f292c77b6a388eff6d3d5b857092f9b/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=ece3543c9f292c77b6a388eff6d3d5b857092f9b", "patch": "@@ -2,24 +2,32 @@ use crate::{\n     map_unit_fn::OPTION_MAP_UNIT_FN,\n     matches::MATCH_AS_REF,\n     utils::{\n-        is_allowed, is_type_diagnostic_item, match_def_path, match_var, paths, peel_hir_expr_refs,\n-        peel_mid_ty_refs_is_mutable, snippet_with_applicability, span_lint_and_sugg,\n+        can_partially_move_ty, is_allowed, is_type_diagnostic_item, match_def_path, match_var, paths,\n+        peel_hir_expr_refs, peel_mid_ty_refs_is_mutable, snippet_with_applicability, snippet_with_context,\n+        span_lint_and_sugg,\n     },\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Mutability, Pat, PatKind, QPath};\n+use rustc_hir::{\n+    def::Res,\n+    intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n+    Arm, BindingAnnotation, Block, Expr, ExprKind, Mutability, Pat, PatKind, Path, QPath,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{\n+    symbol::{sym, Ident},\n+    SyntaxContext,\n+};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usages of `match` which could be implemented using `map`\n     ///\n     /// **Why is this bad?** Using the `map` method is clearer and more concise.\n     ///\n-    /// **Known problems:** `map` is not capable of representing some control flow which works fine in `match`.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     ///\n@@ -34,7 +42,7 @@ declare_clippy_lint! {\n     /// Some(0).map(|x| x + 1);\n     /// ```\n     pub MANUAL_MAP,\n-    nursery,\n+    style,\n     \"reimplementation of `map`\"\n }\n \n@@ -52,43 +60,46 @@ impl LateLintPass<'_> for ManualMap {\n         {\n             let (scrutinee_ty, ty_ref_count, ty_mutability) =\n                 peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-            if !is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n-                || !is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type)\n+            if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+                && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n             {\n                 return;\n             }\n \n-            let (some_expr, some_pat, pat_ref_count, is_wild_none) =\n-                match (try_parse_pattern(cx, arm1.pat), try_parse_pattern(cx, arm2.pat)) {\n-                    (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n-                        if is_none_expr(cx, arm1.body) =>\n-                    {\n-                        (arm2.body, pattern, ref_count, true)\n-                    },\n-                    (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n-                        if is_none_expr(cx, arm1.body) =>\n-                    {\n-                        (arm2.body, pattern, ref_count, false)\n-                    },\n-                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n-                        if is_none_expr(cx, arm2.body) =>\n-                    {\n-                        (arm1.body, pattern, ref_count, true)\n-                    },\n-                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n-                        if is_none_expr(cx, arm2.body) =>\n-                    {\n-                        (arm1.body, pattern, ref_count, false)\n-                    },\n-                    _ => return,\n-                };\n+            let expr_ctxt = expr.span.ctxt();\n+            let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+                try_parse_pattern(cx, arm1.pat, expr_ctxt),\n+                try_parse_pattern(cx, arm2.pat, expr_ctxt),\n+            ) {\n+                (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n+                    if is_none_expr(cx, arm1.body) =>\n+                {\n+                    (arm2.body, pattern, ref_count, true)\n+                },\n+                (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n+                    if is_none_expr(cx, arm1.body) =>\n+                {\n+                    (arm2.body, pattern, ref_count, false)\n+                },\n+                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n+                    if is_none_expr(cx, arm2.body) =>\n+                {\n+                    (arm1.body, pattern, ref_count, true)\n+                },\n+                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n+                    if is_none_expr(cx, arm2.body) =>\n+                {\n+                    (arm1.body, pattern, ref_count, false)\n+                },\n+                _ => return,\n+            };\n \n             // Top level or patterns aren't allowed in closures.\n             if matches!(some_pat.kind, PatKind::Or(_)) {\n                 return;\n             }\n \n-            let some_expr = match get_some_expr(cx, some_expr) {\n+            let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n                 Some(expr) => expr,\n                 None => return,\n             };\n@@ -99,6 +110,10 @@ impl LateLintPass<'_> for ManualMap {\n                 return;\n             }\n \n+            if !can_move_expr_to_closure(cx, some_expr) {\n+                return;\n+            }\n+\n             // Determine which binding mode to use.\n             let explicit_ref = some_pat.contains_explicit_ref_binding();\n             let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n@@ -111,47 +126,50 @@ impl LateLintPass<'_> for ManualMap {\n \n             let mut app = Applicability::MachineApplicable;\n \n-            // Remove address-of expressions from the scrutinee. `as_ref` will be called,\n-            // the type is copyable, or the option is being passed by value.\n+            // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+            // it's being passed by value.\n             let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-            let scrutinee_str = snippet_with_applicability(cx, scrutinee.span, \"_\", &mut app);\n-            let scrutinee_str = if expr.precedence().order() < PREC_POSTFIX {\n-                // Parens are needed to chain method calls.\n-                format!(\"({})\", scrutinee_str)\n-            } else {\n-                scrutinee_str.into()\n-            };\n+            let scrutinee_str = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+            let scrutinee_str =\n+                if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+                    format!(\"({})\", scrutinee_str)\n+                } else {\n+                    scrutinee_str.into()\n+                };\n \n             let body_str = if let PatKind::Binding(annotation, _, some_binding, None) = some_pat.kind {\n-                if let Some(func) = can_pass_as_func(cx, some_binding, some_expr) {\n-                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                } else {\n-                    if match_var(some_expr, some_binding.name)\n-                        && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                        && binding_ref.is_some()\n-                    {\n-                        return;\n-                    }\n+                match can_pass_as_func(cx, some_binding, some_expr) {\n+                    Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+                        snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+                    },\n+                    _ => {\n+                        if match_var(some_expr, some_binding.name)\n+                            && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                            && binding_ref.is_some()\n+                        {\n+                            return;\n+                        }\n \n-                    // `ref` and `ref mut` annotations were handled earlier.\n-                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                        \"mut \"\n-                    } else {\n-                        \"\"\n-                    };\n-                    format!(\n-                        \"|{}{}| {}\",\n-                        annotation,\n-                        some_binding,\n-                        snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n-                    )\n+                        // `ref` and `ref mut` annotations were handled earlier.\n+                        let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                            \"mut \"\n+                        } else {\n+                            \"\"\n+                        };\n+                        format!(\n+                            \"|{}{}| {}\",\n+                            annotation,\n+                            some_binding,\n+                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n+                        )\n+                    },\n                 }\n             } else if !is_wild_none && explicit_ref.is_none() {\n                 // TODO: handle explicit reference annotations.\n                 format!(\n                     \"|{}| {}\",\n-                    snippet_with_applicability(cx, some_pat.span, \"..\", &mut app),\n-                    snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n+                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app),\n+                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n                 )\n             } else {\n                 // Refutable bindings and mixed reference annotations can't be handled by `map`.\n@@ -171,6 +189,51 @@ impl LateLintPass<'_> for ManualMap {\n     }\n }\n \n+// Checks if the expression can be moved into a closure as is.\n+fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        make_closure: bool,\n+    }\n+    impl Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            match e.kind {\n+                ExprKind::Break(..)\n+                | ExprKind::Continue(_)\n+                | ExprKind::Ret(_)\n+                | ExprKind::Yield(..)\n+                | ExprKind::InlineAsm(_)\n+                | ExprKind::LlvmInlineAsm(_) => {\n+                    self.make_closure = false;\n+                },\n+                // Accessing a field of a local value can only be done if the type isn't\n+                // partially moved.\n+                ExprKind::Field(base_expr, _)\n+                    if matches!(\n+                        base_expr.kind,\n+                        ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n+                    ) && can_partially_move_ty(self.cx, self.cx.typeck_results().expr_ty(base_expr)) =>\n+                {\n+                    // TODO: check if the local has been partially moved. Assume it has for now.\n+                    self.make_closure = false;\n+                    return;\n+                }\n+                _ => (),\n+            };\n+            walk_expr(self, e);\n+        }\n+    }\n+\n+    let mut v = V { cx, make_closure: true };\n+    v.visit_expr(expr);\n+    v.make_closure\n+}\n+\n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n@@ -198,11 +261,11 @@ enum OptionPat<'a> {\n \n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) -> Option<OptionPat<'tcx>> {\n-    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize) -> Option<OptionPat<'tcx>> {\n+fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n             PatKind::Path(QPath::Resolved(None, path))\n                 if path\n                     .res\n@@ -215,18 +278,19 @@ fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) -> Option<Optio\n                 if path\n                     .res\n                     .opt_def_id()\n-                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME)) =>\n+                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME))\n+                    && pat.span.ctxt() == ctxt =>\n             {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n             _ => None,\n         }\n     }\n-    f(cx, pat, 0)\n+    f(cx, pat, 0, ctxt)\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n-fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxContext) -> Option<&'tcx Expr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n         ExprKind::Call(\n@@ -235,7 +299,7 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx E\n                 ..\n             },\n             [arg],\n-        ) => {\n+        ) if ctxt == expr.span.ctxt() => {\n             if match_def_path(cx, path.res.opt_def_id()?, &paths::OPTION_SOME) {\n                 Some(arg)\n             } else {\n@@ -249,7 +313,7 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx E\n                 ..\n             },\n             _,\n-        ) => get_some_expr(cx, expr),\n+        ) => get_some_expr(cx, expr, ctxt),\n         _ => None,\n     }\n }"}, {"sha": "00455d4102f986d850a874da7952960c83bd5ea6", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ece3543c9f292c77b6a388eff6d3d5b857092f9b/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece3543c9f292c77b6a388eff6d3d5b857092f9b/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=ece3543c9f292c77b6a388eff6d3d5b857092f9b", "patch": "@@ -73,11 +73,11 @@ use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n-use rustc_span::hygiene::{ExpnKind, MacroKind};\n+use rustc_span::hygiene::{self, ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::sym;\n use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n+use rustc_span::{BytePos, Pos, Span, SyntaxContext, DUMMY_SP};\n use rustc_target::abi::Integer;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use smallvec::SmallVec;\n@@ -472,6 +472,18 @@ pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n+/// Checks whether a type can be partially moved.\n+pub fn can_partially_move_ty(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    if has_drop(cx, ty) || is_copy(cx, ty) {\n+        return false;\n+    }\n+    match ty.kind() {\n+        ty::Param(_) => false,\n+        ty::Adt(def, subs) => def.all_fields().any(|f| !is_copy(cx, f.ty(cx.tcx, subs))),\n+        _ => true,\n+    }\n+}\n+\n /// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`. method/span lists are sorted with the most recent call first.\n pub fn method_calls<'tcx>(\n@@ -762,6 +774,35 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n     reindent_multiline(snip, true, indent)\n }\n \n+/// Same as `snippet_with_applicability`, but first walks the span up to the given context. This\n+/// will result in the macro call, rather then the expansion, if the span is from a child context.\n+/// If the span is not from a child context, it will be used directly instead.\n+///\n+/// e.g. Given the expression `&vec![]`, getting a snippet from the span for `vec![]` as a HIR node\n+/// would result in `box []`. If given the context of the address of expression, this function will\n+/// correctly get a snippet of `vec![]`.\n+pub fn snippet_with_context(\n+    cx: &LateContext<'_>,\n+    span: Span,\n+    outer: SyntaxContext,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    let outer_span = hygiene::walk_chain(span, outer);\n+    let span = if outer_span.ctxt() == outer {\n+        outer_span\n+    } else {\n+        // The span is from a macro argument, and the outer context is the macro using the argument\n+        if *applicability != Applicability::Unspecified {\n+            *applicability = Applicability::MaybeIncorrect;\n+        }\n+        // TODO: get the argument span.\n+        span\n+    };\n+\n+    snippet_with_applicability(cx, span, default, applicability)\n+}\n+\n /// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n /// line.\n ///"}, {"sha": "9222aaf6c789c20b96f3c3effc69655187c21c26", "filename": "tests/ui/manual_map_option.fixed", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ece3543c9f292c77b6a388eff6d3d5b857092f9b/tests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ece3543c9f292c77b6a388eff6d3d5b857092f9b/tests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.fixed?ref=ece3543c9f292c77b6a388eff6d3d5b857092f9b", "patch": "@@ -1,7 +1,14 @@\n+// edition:2018\n // run-rustfix\n \n #![warn(clippy::manual_map)]\n-#![allow(clippy::no_effect, clippy::map_identity, clippy::unit_arg, clippy::match_ref_pats)]\n+#![allow(\n+    clippy::no_effect,\n+    clippy::map_identity,\n+    clippy::unit_arg,\n+    clippy::match_ref_pats,\n+    dead_code\n+)]\n \n fn main() {\n     Some(0).map(|_| 2);\n@@ -67,4 +74,58 @@ fn main() {\n         Some(Some((x, 1))) => Some(x),\n         _ => None,\n     };\n+\n+    // #6795\n+    fn f1() -> Result<(), ()> {\n+        let _ = match Some(Ok(())) {\n+            Some(x) => Some(x?),\n+            None => None,\n+        };\n+        Ok(())\n+    }\n+\n+    for &x in Some(Some(true)).iter() {\n+        let _ = match x {\n+            Some(x) => Some(if x { continue } else { x }),\n+            None => None,\n+        };\n+    }\n+\n+    // #6797\n+    let x1 = (Some(String::new()), 0);\n+    let x2 = x1.0;\n+    match x2 {\n+        Some(x) => Some((x, x1.1)),\n+        None => None,\n+    };\n+\n+    struct S1 {\n+        x: Option<String>,\n+        y: u32,\n+    }\n+    impl S1 {\n+        fn f(self) -> Option<(String, u32)> {\n+            match self.x {\n+                Some(x) => Some((x, self.y)),\n+                None => None,\n+            }\n+        }\n+    }\n+\n+    // #6811\n+    Some(0).map(|x| vec![x]);\n+\n+    option_env!(\"\").map(String::from);\n+\n+    // #6819\n+    async fn f2(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn f3() {\n+        match Some(0) {\n+            Some(x) => Some(f2(x).await),\n+            None => None,\n+        };\n+    }\n }"}, {"sha": "1ccb450619c69127897206289409c6fd2b32d5b4", "filename": "tests/ui/manual_map_option.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ece3543c9f292c77b6a388eff6d3d5b857092f9b/tests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece3543c9f292c77b6a388eff6d3d5b857092f9b/tests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.rs?ref=ece3543c9f292c77b6a388eff6d3d5b857092f9b", "patch": "@@ -1,7 +1,14 @@\n+// edition:2018\n // run-rustfix\n \n #![warn(clippy::manual_map)]\n-#![allow(clippy::no_effect, clippy::map_identity, clippy::unit_arg, clippy::match_ref_pats)]\n+#![allow(\n+    clippy::no_effect,\n+    clippy::map_identity,\n+    clippy::unit_arg,\n+    clippy::match_ref_pats,\n+    dead_code\n+)]\n \n fn main() {\n     match Some(0) {\n@@ -119,4 +126,64 @@ fn main() {\n         Some(Some((x, 1))) => Some(x),\n         _ => None,\n     };\n+\n+    // #6795\n+    fn f1() -> Result<(), ()> {\n+        let _ = match Some(Ok(())) {\n+            Some(x) => Some(x?),\n+            None => None,\n+        };\n+        Ok(())\n+    }\n+\n+    for &x in Some(Some(true)).iter() {\n+        let _ = match x {\n+            Some(x) => Some(if x { continue } else { x }),\n+            None => None,\n+        };\n+    }\n+\n+    // #6797\n+    let x1 = (Some(String::new()), 0);\n+    let x2 = x1.0;\n+    match x2 {\n+        Some(x) => Some((x, x1.1)),\n+        None => None,\n+    };\n+\n+    struct S1 {\n+        x: Option<String>,\n+        y: u32,\n+    }\n+    impl S1 {\n+        fn f(self) -> Option<(String, u32)> {\n+            match self.x {\n+                Some(x) => Some((x, self.y)),\n+                None => None,\n+            }\n+        }\n+    }\n+\n+    // #6811\n+    match Some(0) {\n+        Some(x) => Some(vec![x]),\n+        None => None,\n+    };\n+\n+    match option_env!(\"\") {\n+        Some(x) => Some(String::from(x)),\n+        None => None,\n+    };\n+\n+    // #6819\n+    async fn f2(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn f3() {\n+        match Some(0) {\n+            Some(x) => Some(f2(x).await),\n+            None => None,\n+        };\n+    }\n }"}, {"sha": "d9f86eecd93f6cb357711f6a1c8da23777233949", "filename": "tests/ui/manual_map_option.stderr", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ece3543c9f292c77b6a388eff6d3d5b857092f9b/tests%2Fui%2Fmanual_map_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ece3543c9f292c77b6a388eff6d3d5b857092f9b/tests%2Fui%2Fmanual_map_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.stderr?ref=ece3543c9f292c77b6a388eff6d3d5b857092f9b", "patch": "@@ -1,5 +1,5 @@\n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:7:5\n+  --> $DIR/manual_map_option.rs:14:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(_) => Some(2),\n@@ -10,7 +10,7 @@ LL | |     };\n    = note: `-D clippy::manual-map` implied by `-D warnings`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:12:5\n+  --> $DIR/manual_map_option.rs:19:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(x) => Some(x + 1),\n@@ -19,7 +19,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| x + 1)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:17:5\n+  --> $DIR/manual_map_option.rs:24:5\n    |\n LL | /     match Some(\"\") {\n LL | |         Some(x) => Some(x.is_empty()),\n@@ -28,7 +28,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(\"\").map(|x| x.is_empty())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:22:5\n+  --> $DIR/manual_map_option.rs:29:5\n    |\n LL | /     if let Some(x) = Some(0) {\n LL | |         Some(!x)\n@@ -38,7 +38,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| !x)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:29:5\n+  --> $DIR/manual_map_option.rs:36:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(x) => { Some(std::convert::identity(x)) }\n@@ -47,7 +47,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(std::convert::identity)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:34:5\n+  --> $DIR/manual_map_option.rs:41:5\n    |\n LL | /     match Some(&String::new()) {\n LL | |         Some(x) => Some(str::len(x)),\n@@ -56,7 +56,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(&String::new()).map(|x| str::len(x))`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:44:5\n+  --> $DIR/manual_map_option.rs:51:5\n    |\n LL | /     match &Some([0, 1]) {\n LL | |         Some(x) => Some(x[0]),\n@@ -65,7 +65,7 @@ LL | |     };\n    | |_____^ help: try this: `Some([0, 1]).as_ref().map(|x| x[0])`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:49:5\n+  --> $DIR/manual_map_option.rs:56:5\n    |\n LL | /     match &Some(0) {\n LL | |         &Some(x) => Some(x * 2),\n@@ -74,7 +74,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| x * 2)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:54:5\n+  --> $DIR/manual_map_option.rs:61:5\n    |\n LL | /     match Some(String::new()) {\n LL | |         Some(ref x) => Some(x.is_empty()),\n@@ -83,7 +83,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:59:5\n+  --> $DIR/manual_map_option.rs:66:5\n    |\n LL | /     match &&Some(String::new()) {\n LL | |         Some(x) => Some(x.len()),\n@@ -92,7 +92,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:64:5\n+  --> $DIR/manual_map_option.rs:71:5\n    |\n LL | /     match &&Some(0) {\n LL | |         &&Some(x) => Some(x + x),\n@@ -101,7 +101,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| x + x)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:77:9\n+  --> $DIR/manual_map_option.rs:84:9\n    |\n LL | /         match &mut Some(String::new()) {\n LL | |             Some(x) => Some(x.push_str(\"\")),\n@@ -110,7 +110,7 @@ LL | |         };\n    | |_________^ help: try this: `Some(String::new()).as_mut().map(|x| x.push_str(\"\"))`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:83:5\n+  --> $DIR/manual_map_option.rs:90:5\n    |\n LL | /     match &mut Some(String::new()) {\n LL | |         Some(ref x) => Some(x.len()),\n@@ -119,7 +119,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:88:5\n+  --> $DIR/manual_map_option.rs:95:5\n    |\n LL | /     match &mut &Some(String::new()) {\n LL | |         Some(x) => Some(x.is_empty()),\n@@ -128,7 +128,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:93:5\n+  --> $DIR/manual_map_option.rs:100:5\n    |\n LL | /     match Some((0, 1, 2)) {\n LL | |         Some((x, y, z)) => Some(x + y + z),\n@@ -137,7 +137,7 @@ LL | |     };\n    | |_____^ help: try this: `Some((0, 1, 2)).map(|(x, y, z)| x + y + z)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:98:5\n+  --> $DIR/manual_map_option.rs:105:5\n    |\n LL | /     match Some([1, 2, 3]) {\n LL | |         Some([first, ..]) => Some(first),\n@@ -146,13 +146,31 @@ LL | |     };\n    | |_____^ help: try this: `Some([1, 2, 3]).map(|[first, ..]| first)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:103:5\n+  --> $DIR/manual_map_option.rs:110:5\n    |\n LL | /     match &Some((String::new(), \"test\")) {\n LL | |         Some((x, y)) => Some((y, x)),\n LL | |         None => None,\n LL | |     };\n    | |_____^ help: try this: `Some((String::new(), \"test\")).as_ref().map(|(x, y)| (y, x))`\n \n-error: aborting due to 17 previous errors\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:168:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         Some(x) => Some(vec![x]),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| vec![x])`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:173:5\n+   |\n+LL | /     match option_env!(\"\") {\n+LL | |         Some(x) => Some(String::from(x)),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `option_env!(\"\").map(String::from)`\n+\n+error: aborting due to 19 previous errors\n "}]}