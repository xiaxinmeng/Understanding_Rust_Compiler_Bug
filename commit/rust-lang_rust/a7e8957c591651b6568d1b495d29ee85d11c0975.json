{"sha": "a7e8957c591651b6568d1b495d29ee85d11c0975", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZTg5NTdjNTkxNjUxYjY1NjhkMWI0OTVkMjllZTg1ZDExYzA5NzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-14T22:06:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-14T22:06:36Z"}, "message": "auto merge of #9823 : pnkfelix/rust/issue7655-bench-papercuts, r=alexcrichton\n\nr? anyone.\r\n\r\nYou can see a bit more discussion on #7655.\r\n\r\nThis does not close any ticket; I am just scratching an itch.  Note in particular that I picked the value `{:>9} ns/iter` pretty much out of a hat.  :)", "tree": {"sha": "21e804cf80bd761d7c939a351254b2c3a8c0e81d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21e804cf80bd761d7c939a351254b2c3a8c0e81d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7e8957c591651b6568d1b495d29ee85d11c0975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e8957c591651b6568d1b495d29ee85d11c0975", "html_url": "https://github.com/rust-lang/rust/commit/a7e8957c591651b6568d1b495d29ee85d11c0975", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7e8957c591651b6568d1b495d29ee85d11c0975/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e77d5586aed50821e0b9361b2e24c96ade816c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e77d5586aed50821e0b9361b2e24c96ade816c", "html_url": "https://github.com/rust-lang/rust/commit/c8e77d5586aed50821e0b9361b2e24c96ade816c"}, {"sha": "602b3cd56cb57782ef5772b3b737def4d9f3fd05", "url": "https://api.github.com/repos/rust-lang/rust/commits/602b3cd56cb57782ef5772b3b737def4d9f3fd05", "html_url": "https://github.com/rust-lang/rust/commit/602b3cd56cb57782ef5772b3b737def4d9f3fd05"}], "stats": {"total": 72, "additions": 60, "deletions": 12}, "files": [{"sha": "a352a2e467808d9497d7a15bed0ed6dff3a705ac", "filename": "src/libextra/test.rs", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a7e8957c591651b6568d1b495d29ee85d11c0975/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e8957c591651b6568d1b495d29ee85d11c0975/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=a7e8957c591651b6568d1b495d29ee85d11c0975", "patch": "@@ -57,6 +57,23 @@ impl ToStr for TestName {\n     }\n }\n \n+#[deriving(Clone)]\n+enum NamePadding { PadNone, PadOnLeft, PadOnRight }\n+\n+impl TestDesc {\n+    fn padded_name(&self, column_count: uint, align: NamePadding) -> ~str {\n+        use std::num::Saturating;\n+        let name = self.name.to_str();\n+        let fill = column_count.saturating_sub(name.len());\n+        let pad = \" \".repeat(fill);\n+        match align {\n+            PadNone => name,\n+            PadOnLeft => pad.append(name),\n+            PadOnRight => name.append(pad),\n+        }\n+    }\n+}\n+\n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n@@ -70,6 +87,19 @@ pub enum TestFn {\n     DynBenchFn(~fn(&mut BenchHarness))\n }\n \n+impl TestFn {\n+    fn padding(&self) -> NamePadding {\n+        match self {\n+            &StaticTestFn(*)   => PadNone,\n+            &StaticBenchFn(*)  => PadOnRight,\n+            &StaticMetricFn(*) => PadOnRight,\n+            &DynTestFn(*)      => PadNone,\n+            &DynMetricFn(*)    => PadOnRight,\n+            &DynBenchFn(*)     => PadOnRight,\n+        }\n+    }\n+}\n+\n // Structure passed to BenchFns\n pub struct BenchHarness {\n     iterations: u64,\n@@ -316,7 +346,8 @@ struct ConsoleTestState {\n     ignored: uint,\n     measured: uint,\n     metrics: MetricMap,\n-    failures: ~[TestDesc]\n+    failures: ~[TestDesc],\n+    max_name_len: uint, // number of columns to fill when aligning names\n }\n \n impl ConsoleTestState {\n@@ -348,7 +379,8 @@ impl ConsoleTestState {\n             ignored: 0u,\n             measured: 0u,\n             metrics: MetricMap::new(),\n-            failures: ~[]\n+            failures: ~[],\n+            max_name_len: 0u,\n         }\n     }\n \n@@ -411,8 +443,9 @@ impl ConsoleTestState {\n         self.out.write_line(format!(\"\\nrunning {} {}\", len, noun));\n     }\n \n-    pub fn write_test_start(&self, test: &TestDesc) {\n-        self.out.write_str(format!(\"test {} ... \", test.name.to_str()));\n+    pub fn write_test_start(&self, test: &TestDesc, align: NamePadding) {\n+        let name = test.padded_name(self.max_name_len, align);\n+        self.out.write_str(format!(\"test {} ... \", name));\n     }\n \n     pub fn write_result(&self, result: &TestResult) {\n@@ -559,12 +592,12 @@ pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n \n pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n     if bs.mb_s != 0 {\n-        format!(\"{} ns/iter (+/- {}) = {} MB/s\",\n+        format!(\"{:>9} ns/iter (+/- {}) = {} MB/s\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n              bs.mb_s)\n     } else {\n-        format!(\"{} ns/iter (+/- {})\",\n+        format!(\"{:>9} ns/iter (+/- {})\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n     }\n@@ -577,7 +610,7 @@ pub fn run_tests_console(opts: &TestOpts,\n         debug2!(\"callback(event={:?})\", event);\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n-            TeWait(ref test) => st.write_test_start(test),\n+            TeWait(ref test, padding) => st.write_test_start(test, padding),\n             TeResult(test, result) => {\n                 st.write_log(&test, &result);\n                 st.write_result(&result);\n@@ -607,6 +640,20 @@ pub fn run_tests_console(opts: &TestOpts,\n         }\n     }\n     let st = @mut ConsoleTestState::new(opts);\n+    fn len_if_padded(t: &TestDescAndFn) -> uint {\n+        match t.testfn.padding() {\n+            PadNone => 0u,\n+            PadOnLeft | PadOnRight => t.desc.name.to_str().len(),\n+        }\n+    }\n+    match tests.iter().max_by(|t|len_if_padded(*t)) {\n+        Some(t) => {\n+            let n = t.desc.name.to_str();\n+            debug2!(\"Setting max_name_len from: {}\", n);\n+            st.max_name_len = n.len();\n+        },\n+        None => {}\n+    }\n     run_tests(opts, tests, |x| callback(&x, st));\n     match opts.save_metrics {\n         None => (),\n@@ -646,7 +693,8 @@ fn should_sort_failures_before_printing_them() {\n             ignored: 0u,\n             measured: 0u,\n             metrics: MetricMap::new(),\n-            failures: ~[test_b, test_a]\n+            failures: ~[test_b, test_a],\n+            max_name_len: 0u,\n         };\n \n         st.write_failures();\n@@ -662,7 +710,7 @@ fn use_color() -> bool { return get_concurrency() == 1; }\n #[deriving(Clone)]\n enum TestEvent {\n     TeFiltered(~[TestDesc]),\n-    TeWait(TestDesc),\n+    TeWait(TestDesc, NamePadding),\n     TeResult(TestDesc, TestResult),\n }\n \n@@ -704,15 +752,15 @@ fn run_tests(opts: &TestOpts,\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(TeWait(test.desc.clone()));\n+                callback(TeWait(test.desc.clone(), test.testfn.padding()));\n             }\n             run_test(!opts.run_tests, test, ch.clone());\n             pending += 1;\n         }\n \n         let (desc, result) = p.recv();\n         if concurrency != 1 {\n-            callback(TeWait(desc.clone()));\n+            callback(TeWait(desc.clone(), PadNone));\n         }\n         callback(TeResult(desc, result));\n         pending -= 1;\n@@ -721,7 +769,7 @@ fn run_tests(opts: &TestOpts,\n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n     for b in filtered_benchs_and_metrics.move_iter() {\n-        callback(TeWait(b.desc.clone()));\n+        callback(TeWait(b.desc.clone(), b.testfn.padding()));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n         callback(TeResult(test, result));"}]}