{"sha": "9c9f4635b4eb7d987717b4064a7de789f7983e2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljOWY0NjM1YjRlYjdkOTg3NzE3YjQwNjRhN2RlNzg5Zjc5ODNlMmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-13T19:49:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-13T19:49:01Z"}, "message": "Merge #2550\n\n2550: Infer - and ! using std::ops::{Neg, Not} r=flodiebold a=kiljacken\n\nFound some low hanging fruit while taking a cursory look at index inferring.\n\nCo-authored-by: Emil Lauridsen <mine809@gmail.com>", "tree": {"sha": "a90ec3dd748d8e4f9fcd6e808bf39c234a25c6d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a90ec3dd748d8e4f9fcd6e808bf39c234a25c6d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c9f4635b4eb7d987717b4064a7de789f7983e2a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd8+stCRBK7hj4Ov3rIwAAdHIIAEDozk3SBRLe8IfpKJk9ag4h\nnn2XBnljlPCxWH0v9wLTamyhH838zv5EyXCbmv5+JhpjFxolO12QdwPp3hh4+Gyg\nmuvsPI+x2Ym1V/0qu+j/GiMW29IPPdGSvTZyvtm0ky7NgZjR4E2Pp9oItHGXwEds\nEpNH/7U1ZS6UbNTnaIQpNPHs1CzqBPzmd7Mo8YQL5swN9zr06QMB8cD3xOtpjhz6\n07r+LxmX3uaaxx8+CizVc+zOLEEQkHZNCRMIN4fIq8vfuoXhkmFuOwq3p48rR/fT\nEHx2cS2QhfwBLvxTLxF6IlmsoId12iqNhJ9FNVkPx3YRWbunIUYxuvE7is4L0rU=\n=N3of\n-----END PGP SIGNATURE-----\n", "payload": "tree a90ec3dd748d8e4f9fcd6e808bf39c234a25c6d7\nparent ebc95af2b5b91239fc1d8a5fc8344ded6f6ef3e4\nparent 77052090515c1bb2a00236b3a57cdd778e581c8c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1576266541 +0000\ncommitter GitHub <noreply@github.com> 1576266541 +0000\n\nMerge #2550\n\n2550: Infer - and ! using std::ops::{Neg, Not} r=flodiebold a=kiljacken\n\nFound some low hanging fruit while taking a cursory look at index inferring.\n\nCo-authored-by: Emil Lauridsen <mine809@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c9f4635b4eb7d987717b4064a7de789f7983e2a", "html_url": "https://github.com/rust-lang/rust/commit/9c9f4635b4eb7d987717b4064a7de789f7983e2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c9f4635b4eb7d987717b4064a7de789f7983e2a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebc95af2b5b91239fc1d8a5fc8344ded6f6ef3e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebc95af2b5b91239fc1d8a5fc8344ded6f6ef3e4", "html_url": "https://github.com/rust-lang/rust/commit/ebc95af2b5b91239fc1d8a5fc8344ded6f6ef3e4"}, {"sha": "77052090515c1bb2a00236b3a57cdd778e581c8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/77052090515c1bb2a00236b3a57cdd778e581c8c", "html_url": "https://github.com/rust-lang/rust/commit/77052090515c1bb2a00236b3a57cdd778e581c8c"}], "stats": {"total": 209, "additions": 139, "deletions": 70}, "files": [{"sha": "50f0cad94f2d3eb5e5abb63456d09a0d580cd917", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=9c9f4635b4eb7d987717b4064a7de789f7983e2a", "patch": "@@ -342,6 +342,14 @@ pub mod known {\n         )\n     }\n \n+    pub fn std_ops_neg() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::NEG_TYPE])\n+    }\n+\n+    pub fn std_ops_not() -> Path {\n+        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::NOT_TYPE])\n+    }\n+\n     pub fn std_result_result() -> Path {\n         Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::RESULT, name::RESULT_TYPE])\n     }"}, {"sha": "9e68dd98d702a866e6c650d28a17b743649d111b", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=9c9f4635b4eb7d987717b4064a7de789f7983e2a", "patch": "@@ -152,6 +152,8 @@ pub const RANGE_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(b\"RangeInclusive\")\n pub const RANGE_TO_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(b\"RangeToInclusive\");\n pub const RANGE_TO_TYPE: Name = Name::new_inline_ascii(b\"RangeTo\");\n pub const RANGE_TYPE: Name = Name::new_inline_ascii(b\"Range\");\n+pub const NEG_TYPE: Name = Name::new_inline_ascii(b\"Neg\");\n+pub const NOT_TYPE: Name = Name::new_inline_ascii(b\"Not\");\n \n // Builtin Macros\n pub const FILE_MACRO: Name = Name::new_inline_ascii(b\"file\");"}, {"sha": "a1201b3e4797cda91035db57ccb2302fc9446018", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=9c9f4635b4eb7d987717b4064a7de789f7983e2a", "patch": "@@ -36,8 +36,8 @@ use ra_prof::profile;\n use super::{\n     primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n-    Uncertain,\n+    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    TypeWalk, Uncertain,\n };\n use crate::{db::HirDatabase, infer::diagnostics::InferenceDiagnostic};\n \n@@ -338,6 +338,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.table.resolve_ty_shallow(ty)\n     }\n \n+    fn resolve_associated_type(&mut self, inner_ty: Ty, assoc_ty: Option<TypeAliasId>) -> Ty {\n+        match assoc_ty {\n+            Some(res_assoc_ty) => {\n+                let ty = self.table.new_type_var();\n+                let projection = ProjectionPredicate {\n+                    ty: ty.clone(),\n+                    projection_ty: ProjectionTy {\n+                        associated_ty: res_assoc_ty,\n+                        parameters: Substs::single(inner_ty),\n+                    },\n+                };\n+                self.obligations.push(Obligation::Projection(projection));\n+                self.resolve_ty_as_possible(ty)\n+            }\n+            None => Ty::Unknown,\n+        }\n+    }\n+\n     /// Recurses through the given type, normalizing associated types mentioned\n     /// in it by replacing them by type variables and registering obligations to\n     /// resolve later. This should be done once for every type we get from some\n@@ -415,6 +433,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE)\n     }\n \n+    fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n+        let path = known::std_ops_neg();\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n+    }\n+\n+    fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n+        let path = known::std_ops_not();\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n+    }\n+\n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n         let path = known::std_future_future();\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;"}, {"sha": "f8c00a7b4a391b7261f5e29259f52e744054c0f6", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 33, "deletions": 68, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=9c9f4635b4eb7d987717b4064a7de789f7983e2a", "patch": "@@ -19,8 +19,8 @@ use crate::{\n     method_resolution, op,\n     traits::InEnvironment,\n     utils::{generics, variant_data, Generics},\n-    CallableDef, InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n-    TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n+    ApplicationTy, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef, Ty,\n+    TypeCtor, TypeWalk, Uncertain,\n };\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n@@ -95,21 +95,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                let pat_ty = match self.resolve_into_iter_item() {\n-                    Some(into_iter_item_alias) => {\n-                        let pat_ty = self.table.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: pat_ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: into_iter_item_alias,\n-                                parameters: Substs::single(iterable_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(pat_ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let pat_ty =\n+                    self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(*pat, &pat_ty, BindingMode::default());\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n@@ -284,40 +271,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Await { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                let ty = match self.resolve_future_future_output() {\n-                    Some(future_future_output_alias) => {\n-                        let ty = self.table.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: future_future_output_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let ty =\n+                    self.resolve_associated_type(inner_ty, self.resolve_future_future_output());\n                 ty\n             }\n             Expr::Try { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                let ty = match self.resolve_ops_try_ok() {\n-                    Some(ops_try_ok_alias) => {\n-                        let ty = self.table.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: ops_try_ok_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let ty = self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok());\n                 ty\n             }\n             Expr::Cast { expr, type_ref } => {\n@@ -372,31 +332,36 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     },\n                     UnaryOp::Neg => {\n                         match &inner_ty {\n-                            Ty::Apply(a_ty) => match a_ty.ctor {\n-                                TypeCtor::Int(Uncertain::Unknown)\n-                                | TypeCtor::Int(Uncertain::Known(IntTy {\n-                                    signedness: Signedness::Signed,\n-                                    ..\n-                                }))\n-                                | TypeCtor::Float(..) => inner_ty,\n-                                _ => Ty::Unknown,\n-                            },\n-                            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => {\n-                                inner_ty\n-                            }\n-                            // FIXME: resolve ops::Neg trait\n-                            _ => Ty::Unknown,\n+                            // Fast path for builtins\n+                            Ty::Apply(ApplicationTy {\n+                                ctor:\n+                                    TypeCtor::Int(Uncertain::Known(IntTy {\n+                                        signedness: Signedness::Signed,\n+                                        ..\n+                                    })),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Int(Uncertain::Unknown),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(_), .. })\n+                            | Ty::Infer(InferTy::IntVar(..))\n+                            | Ty::Infer(InferTy::FloatVar(..)) => inner_ty,\n+                            // Otherwise we resolve via the std::ops::Neg trait\n+                            _ => self\n+                                .resolve_associated_type(inner_ty, self.resolve_ops_neg_output()),\n                         }\n                     }\n                     UnaryOp::Not => {\n                         match &inner_ty {\n-                            Ty::Apply(a_ty) => match a_ty.ctor {\n-                                TypeCtor::Bool | TypeCtor::Int(_) => inner_ty,\n-                                _ => Ty::Unknown,\n-                            },\n-                            Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n-                            // FIXME: resolve ops::Not trait for inner_ty\n-                            _ => Ty::Unknown,\n+                            // Fast path for builtins\n+                            Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. })\n+                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(_), .. })\n+                            | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n+                            // Otherwise we resolve via the std::ops::Not trait\n+                            _ => self\n+                                .resolve_associated_type(inner_ty, self.resolve_ops_not_output()),\n                         }\n                     }\n                 }"}, {"sha": "6139adb72e501b5b64d49aa159d501c224f32c8e", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9f4635b4eb7d987717b4064a7de789f7983e2a/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=9c9f4635b4eb7d987717b4064a7de789f7983e2a", "patch": "@@ -115,6 +115,70 @@ mod collections {\n     assert_eq!(\"&str\", type_at_pos(&db, pos));\n }\n \n+#[test]\n+fn infer_ops_neg() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+struct Bar;\n+struct Foo;\n+\n+impl std::ops::Neg for Bar {\n+    type Output = Foo;\n+}\n+\n+fn test() {\n+    let a = Bar;\n+    let b = -a;\n+    b<|>;\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    pub trait Neg {\n+        type Output;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_ops_not() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+struct Bar;\n+struct Foo;\n+\n+impl std::ops::Not for Bar {\n+    type Output = Foo;\n+}\n+\n+fn test() {\n+    let a = Bar;\n+    let b = !a;\n+    b<|>;\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    pub trait Not {\n+        type Output;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn infer_from_bound_1() {\n     assert_snapshot!("}]}