{"sha": "c5142056f7f57387dc37361889d13409667b920d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MTQyMDU2ZjdmNTczODdkYzM3MzYxODg5ZDEzNDA5NjY3YjkyMGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-02T07:10:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-02T07:10:14Z"}, "message": "Auto merge of #22797 - alexcrichton:io-stdio, r=aturon\n\nThis is an implementation of RFC 899 and adds stdio functionality to the new\r\n`std::io` module. Details of the API can be found on the RFC, but from a high\r\nlevel:\r\n\r\n* `io::{stdin, stdout, stderr}` constructors are now available. There are also\r\n  `*_raw` variants for unbuffered and unlocked access.\r\n* All handles are globally shared (excluding raw variants).\r\n* The stderr handle is no longer buffered.\r\n* All handles can be explicitly locked (excluding the raw variants).\r\n\r\nThe `print!` and `println!` machinery has not yet been hooked up to these\r\nstreams just yet. The `std::fmt::output` module has also not yet been\r\nimplemented as part of this commit.", "tree": {"sha": "6e62f6151e03cdf5eaf04102bdd42abb3023dc8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e62f6151e03cdf5eaf04102bdd42abb3023dc8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5142056f7f57387dc37361889d13409667b920d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5142056f7f57387dc37361889d13409667b920d", "html_url": "https://github.com/rust-lang/rust/commit/c5142056f7f57387dc37361889d13409667b920d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5142056f7f57387dc37361889d13409667b920d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b3b02f8f4f57046956d42c4c19d00c7bb260189", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3b02f8f4f57046956d42c4c19d00c7bb260189", "html_url": "https://github.com/rust-lang/rust/commit/4b3b02f8f4f57046956d42c4c19d00c7bb260189"}, {"sha": "94d71f8836b3bfac3370e4d324ca1987d843552f", "url": "https://api.github.com/repos/rust-lang/rust/commits/94d71f8836b3bfac3370e4d324ca1987d843552f", "html_url": "https://github.com/rust-lang/rust/commit/94d71f8836b3bfac3370e4d324ca1987d843552f"}], "stats": {"total": 840, "additions": 732, "deletions": 108}, "files": [{"sha": "c95b413b397edb1fd489298ddde673707e4fce7a", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -201,10 +201,11 @@ impl<T> Arc<T> {\n impl<T> Arc<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n-        // This unsafety is ok because while this arc is alive we're guaranteed that the inner\n-        // pointer is valid. Furthermore, we know that the `ArcInner` structure itself is `Sync`\n-        // because the inner data is `Sync` as well, so we're ok loaning out an immutable pointer\n-        // to these contents.\n+        // This unsafety is ok because while this arc is alive we're guaranteed\n+        // that the inner pointer is valid. Furthermore, we know that the\n+        // `ArcInner` structure itself is `Sync` because the inner data is\n+        // `Sync` as well, so we're ok loaning out an immutable pointer to these\n+        // contents.\n         unsafe { &**self._ptr }\n     }\n }\n@@ -236,13 +237,15 @@ impl<T> Clone for Arc<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Arc<T> {\n-        // Using a relaxed ordering is alright here, as knowledge of the original reference\n-        // prevents other threads from erroneously deleting the object.\n+        // Using a relaxed ordering is alright here, as knowledge of the\n+        // original reference prevents other threads from erroneously deleting\n+        // the object.\n         //\n-        // As explained in the [Boost documentation][1], Increasing the reference counter can\n-        // always be done with memory_order_relaxed: New references to an object can only be formed\n-        // from an existing reference, and passing an existing reference from one thread to another\n-        // must already provide any required synchronization.\n+        // As explained in the [Boost documentation][1], Increasing the\n+        // reference counter can always be done with memory_order_relaxed: New\n+        // references to an object can only be formed from an existing\n+        // reference, and passing an existing reference from one thread to\n+        // another must already provide any required synchronization.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         self.inner().strong.fetch_add(1, Relaxed);"}, {"sha": "c9b105f72a53943ab0d8e9ff6dbab3071b1ab993", "filename": "src/libstd/io/lazy.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use boxed;\n+use cell::UnsafeCell;\n+use rt;\n+use sync::{StaticMutex, Arc};\n+\n+pub struct Lazy<T> {\n+    pub lock: StaticMutex,\n+    pub ptr: UnsafeCell<*mut Arc<T>>,\n+    pub init: fn() -> Arc<T>,\n+}\n+\n+unsafe impl<T> Sync for Lazy<T> {}\n+\n+macro_rules! lazy_init {\n+    ($init:expr) => (::io::lazy::Lazy {\n+        lock: ::sync::MUTEX_INIT,\n+        ptr: ::cell::UnsafeCell { value: 0 as *mut _ },\n+        init: $init,\n+    })\n+}\n+\n+impl<T: Send + Sync + 'static> Lazy<T> {\n+    pub fn get(&'static self) -> Option<Arc<T>> {\n+        let _g = self.lock.lock();\n+        unsafe {\n+            let mut ptr = *self.ptr.get();\n+            if ptr.is_null() {\n+                ptr = boxed::into_raw(self.init());\n+                *self.ptr.get() = ptr;\n+            } else if ptr as usize == 1 {\n+                return None\n+            }\n+            Some((*ptr).clone())\n+        }\n+    }\n+\n+    fn init(&'static self) -> Box<Arc<T>> {\n+        rt::at_exit(move || unsafe {\n+            let g = self.lock.lock();\n+            let ptr = *self.ptr.get();\n+            *self.ptr.get() = 1 as *mut _;\n+            drop(g);\n+            drop(Box::from_raw(ptr))\n+        });\n+        Box::new((self.init)())\n+    }\n+}"}, {"sha": "5510c0203e6cff3c3af5e7c487cf2ad2112ba909", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -39,13 +39,18 @@ pub use self::buffered::IntoInnerError;\n pub use self::cursor::Cursor;\n pub use self::error::{Result, Error, ErrorKind};\n pub use self::util::{copy, sink, Sink, empty, Empty, repeat, Repeat};\n+pub use self::stdio::{stdin, stdout, stderr, Stdin, Stdout, Stderr};\n+pub use self::stdio::{StdoutLock, StderrLock, StdinLock};\n+\n+#[macro_use] mod lazy;\n \n pub mod prelude;\n mod buffered;\n mod cursor;\n mod error;\n mod impls;\n mod util;\n+mod stdio;\n \n const DEFAULT_BUF_SIZE: usize = 64 * 1024;\n "}, {"sha": "61ad9905771a406b328d8de4161f2157a038b4b4", "filename": "src/libstd/io/stdio.rs", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -0,0 +1,325 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n+\n+use cmp;\n+use fmt;\n+use io::lazy::Lazy;\n+use io::{self, BufReader, LineWriter};\n+use sync::{Arc, Mutex, MutexGuard};\n+use sys::stdio;\n+\n+/// A handle to a raw instance of the standard input stream of this process.\n+///\n+/// This handle is not synchronized or buffered in any fashion. Constructed via\n+/// the `std::io::stdin_raw` function.\n+pub struct StdinRaw(stdio::Stdin);\n+\n+/// A handle to a raw instance of the standard output stream of this process.\n+///\n+/// This handle is not synchronized or buffered in any fashion. Constructed via\n+/// the `std::io::stdout_raw` function.\n+pub struct StdoutRaw(stdio::Stdout);\n+\n+/// A handle to a raw instance of the standard output stream of this process.\n+///\n+/// This handle is not synchronized or buffered in any fashion. Constructed via\n+/// the `std::io::stderr_raw` function.\n+pub struct StderrRaw(stdio::Stderr);\n+\n+/// Construct a new raw handle to the standard input of this process.\n+///\n+/// The returned handle does not interact with any other handles created nor\n+/// handles returned by `std::io::stdin`. Data buffered by the `std::io::stdin`\n+/// handles is **not** available to raw handles returned from this function.\n+///\n+/// The returned handle has no external synchronization or buffering.\n+pub fn stdin_raw() -> StdinRaw { StdinRaw(stdio::Stdin::new()) }\n+\n+/// Construct a new raw handle to the standard input stream of this process.\n+///\n+/// The returned handle does not interact with any other handles created nor\n+/// handles returned by `std::io::stdout`. Note that data is buffered by the\n+/// `std::io::stdin` handles so writes which happen via this raw handle may\n+/// appear before previous writes.\n+///\n+/// The returned handle has no external synchronization or buffering layered on\n+/// top.\n+pub fn stdout_raw() -> StdoutRaw { StdoutRaw(stdio::Stdout::new()) }\n+\n+/// Construct a new raw handle to the standard input stream of this process.\n+///\n+/// The returned handle does not interact with any other handles created nor\n+/// handles returned by `std::io::stdout`.\n+///\n+/// The returned handle has no external synchronization or buffering layered on\n+/// top.\n+pub fn stderr_raw() -> StderrRaw { StderrRaw(stdio::Stderr::new()) }\n+\n+impl Read for StdinRaw {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+}\n+impl Write for StdoutRaw {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+impl Write for StderrRaw {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+/// A handle to the standard input stream of a process.\n+///\n+/// Each handle is a shared reference to a global buffer of input data to this\n+/// process. A handle can be `lock`'d to gain full access to `BufRead` methods\n+/// (e.g. `.lines()`). Writes to this handle are otherwise locked with respect\n+/// to other writes.\n+///\n+/// This handle implements the `Read` trait, but beware that concurrent reads\n+/// of `Stdin` must be executed with care.\n+pub struct Stdin {\n+    inner: Arc<Mutex<BufReader<StdinRaw>>>,\n+}\n+\n+/// A locked reference to the a `Stdin` handle.\n+///\n+/// This handle implements both the `Read` and `BufRead` traits and is\n+/// constructed via the `lock` method on `Stdin`.\n+pub struct StdinLock<'a> {\n+    inner: MutexGuard<'a, BufReader<StdinRaw>>,\n+}\n+\n+/// Create a new handle to the global standard input stream of this process.\n+///\n+/// The handle returned refers to a globally shared buffer between all threads.\n+/// Access is synchronized and can be explicitly controlled with the `lock()`\n+/// method.\n+///\n+/// The `Read` trait is implemented for the returned value but the `BufRead`\n+/// trait is not due to the global nature of the standard input stream. The\n+/// locked version, `StdinLock`, implements both `Read` and `BufRead`, however.\n+///\n+/// To avoid locking and buffering altogether, it is recommended to use the\n+/// `stdin_raw` constructor.\n+pub fn stdin() -> Stdin {\n+    static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = lazy_init!(stdin_init);\n+    return Stdin {\n+        inner: INSTANCE.get().expect(\"cannot access stdin during shutdown\"),\n+    };\n+\n+    fn stdin_init() -> Arc<Mutex<BufReader<StdinRaw>>> {\n+        // The default buffer capacity is 64k, but apparently windows\n+        // doesn't like 64k reads on stdin. See #13304 for details, but the\n+        // idea is that on windows we use a slightly smaller buffer that's\n+        // been seen to be acceptable.\n+        Arc::new(Mutex::new(if cfg!(windows) {\n+            BufReader::with_capacity(8 * 1024, stdin_raw())\n+        } else {\n+            BufReader::new(stdin_raw())\n+        }))\n+    }\n+}\n+\n+impl Stdin {\n+    /// Lock this handle to the standard input stream, returning a readable\n+    /// guard.\n+    ///\n+    /// The lock is released when the returned lock goes out of scope. The\n+    /// returned guard also implements the `Read` and `BufRead` traits for\n+    /// accessing the underlying data.\n+    pub fn lock(&self) -> StdinLock {\n+        StdinLock { inner: self.inner.lock().unwrap() }\n+    }\n+}\n+\n+impl Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.lock().read(buf)\n+    }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<()> {\n+        self.lock().read_to_end(buf)\n+    }\n+\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<()> {\n+        self.lock().read_to_string(buf)\n+    }\n+}\n+\n+impl<'a> Read for StdinLock<'a> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        // Flush stdout so that weird issues like a print!'d prompt not being\n+        // shown until after the user hits enter.\n+        drop(stdout().flush());\n+        self.inner.read(buf)\n+    }\n+}\n+impl<'a> BufRead for StdinLock<'a> {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n+    fn consume(&mut self, n: usize) { self.inner.consume(n) }\n+}\n+\n+// As with stdin on windows, stdout often can't handle writes of large\n+// sizes. For an example, see #14940. For this reason, don't try to\n+// write the entire output buffer on windows. On unix we can just\n+// write the whole buffer all at once.\n+//\n+// For some other references, it appears that this problem has been\n+// encountered by others [1] [2]. We choose the number 8KB just because\n+// libuv does the same.\n+//\n+// [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n+// [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n+#[cfg(windows)]\n+const OUT_MAX: usize = 8192;\n+#[cfg(unix)]\n+const OUT_MAX: usize = ::usize::MAX;\n+\n+/// A handle to the global standard output stream of the current process.\n+///\n+/// Each handle shares a global buffer of data to be written to the standard\n+/// output stream. Access is also synchronized via a lock and explicit control\n+/// over locking is available via the `lock` method.\n+pub struct Stdout {\n+    // FIXME: this should be LineWriter or BufWriter depending on the state of\n+    //        stdout (tty or not). Note that if this is not line buffered it\n+    //        should also flush-on-panic or some form of flush-on-abort.\n+    inner: Arc<Mutex<LineWriter<StdoutRaw>>>,\n+}\n+\n+/// A locked reference to the a `Stdout` handle.\n+///\n+/// This handle implements the `Write` trait and is constructed via the `lock`\n+/// method on `Stdout`.\n+pub struct StdoutLock<'a> {\n+    inner: MutexGuard<'a, LineWriter<StdoutRaw>>,\n+}\n+\n+/// Constructs a new reference to the standard output of the current process.\n+///\n+/// Each handle returned is a reference to a shared global buffer whose access\n+/// is synchronized via a mutex. Explicit control over synchronization is\n+/// provided via the `lock` method.\n+///\n+/// The returned handle implements the `Write` trait.\n+///\n+/// To avoid locking and buffering altogether, it is recommended to use the\n+/// `stdout_raw` constructor.\n+pub fn stdout() -> Stdout {\n+    static INSTANCE: Lazy<Mutex<LineWriter<StdoutRaw>>> = lazy_init!(stdout_init);\n+    return Stdout {\n+        inner: INSTANCE.get().expect(\"cannot access stdout during shutdown\"),\n+    };\n+\n+    fn stdout_init() -> Arc<Mutex<LineWriter<StdoutRaw>>> {\n+        Arc::new(Mutex::new(LineWriter::new(stdout_raw())))\n+    }\n+}\n+\n+impl Stdout {\n+    /// Lock this handle to the standard output stream, returning a writable\n+    /// guard.\n+    ///\n+    /// The lock is released when the returned lock goes out of scope. The\n+    /// returned guard also implements the `Write` trait for writing data.\n+    pub fn lock(&self) -> StdoutLock {\n+        StdoutLock { inner: self.inner.lock().unwrap() }\n+    }\n+}\n+\n+impl Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.lock().write(buf)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.lock().flush()\n+    }\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        self.lock().write_all(buf)\n+    }\n+    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n+        self.lock().write_fmt(fmt)\n+    }\n+}\n+impl<'a> Write for StdoutLock<'a> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.inner.write(&buf[..cmp::min(buf.len(), OUT_MAX)])\n+    }\n+    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+}\n+\n+/// A handle to the standard error stream of a process.\n+///\n+/// For more information, see `stderr`\n+pub struct Stderr {\n+    inner: Arc<Mutex<StderrRaw>>,\n+}\n+\n+/// A locked reference to the a `Stderr` handle.\n+///\n+/// This handle implements the `Write` trait and is constructed via the `lock`\n+/// method on `Stderr`.\n+pub struct StderrLock<'a> {\n+    inner: MutexGuard<'a, StderrRaw>,\n+}\n+\n+/// Constructs a new reference to the standard error stream of a process.\n+///\n+/// Each returned handle is synchronized amongst all other handles created from\n+/// this function. No handles are buffered, however.\n+///\n+/// The returned handle implements the `Write` trait.\n+///\n+/// To avoid locking altogether, it is recommended to use the `stderr_raw`\n+/// constructor.\n+pub fn stderr() -> Stderr {\n+    static INSTANCE: Lazy<Mutex<StderrRaw>> = lazy_init!(stderr_init);\n+    return Stderr {\n+        inner: INSTANCE.get().expect(\"cannot access stderr during shutdown\"),\n+    };\n+\n+    fn stderr_init() -> Arc<Mutex<StderrRaw>> {\n+        Arc::new(Mutex::new(stderr_raw()))\n+    }\n+}\n+\n+impl Stderr {\n+    /// Lock this handle to the standard error stream, returning a writable\n+    /// guard.\n+    ///\n+    /// The lock is released when the returned lock goes out of scope. The\n+    /// returned guard also implements the `Write` trait for writing data.\n+    pub fn lock(&self) -> StderrLock {\n+        StderrLock { inner: self.inner.lock().unwrap() }\n+    }\n+}\n+\n+impl Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.lock().write(buf)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.lock().flush()\n+    }\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        self.lock().write_all(buf)\n+    }\n+    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n+        self.lock().write_fmt(fmt)\n+    }\n+}\n+impl<'a> Write for StderrLock<'a> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.inner.write(&buf[..cmp::min(buf.len(), OUT_MAX)])\n+    }\n+    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+}"}, {"sha": "a5df21749e22e3023580e1ae8ef4b6a48a130c67", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -224,10 +224,10 @@ pub fn stdin() -> StdinReader {\n \n     unsafe {\n         ONCE.call_once(|| {\n-            // The default buffer capacity is 64k, but apparently windows doesn't like\n-            // 64k reads on stdin. See #13304 for details, but the idea is that on\n-            // windows we use a slightly smaller buffer that's been seen to be\n-            // acceptable.\n+            // The default buffer capacity is 64k, but apparently windows\n+            // doesn't like 64k reads on stdin. See #13304 for details, but the\n+            // idea is that on windows we use a slightly smaller buffer that's\n+            // been seen to be acceptable.\n             let stdin = if cfg!(windows) {\n                 BufferedReader::with_capacity(8 * 1024, stdin_raw())\n             } else {"}, {"sha": "80bfd57e933c42af7cb23da3a33006a8f553c59f", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -63,6 +63,7 @@ pub mod time;\n pub mod timer;\n pub mod tty;\n pub mod udp;\n+pub mod stdio;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;"}, {"sha": "2f9610fa5b5a8a9702c98374cdd536bd7e6f774f", "filename": "src/libstd/sys/unix/stdio.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use io;\n+use libc;\n+use sys::fd::FileDesc;\n+\n+pub struct Stdin(());\n+pub struct Stdout(());\n+pub struct Stderr(());\n+\n+impl Stdin {\n+    pub fn new() -> Stdin { Stdin(()) }\n+\n+    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDIN_FILENO);\n+        let ret = fd.read(data);\n+        fd.into_raw();\n+        return ret;\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> Stdout { Stdout(()) }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDOUT_FILENO);\n+        let ret = fd.write(data);\n+        fd.into_raw();\n+        return ret;\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> Stderr { Stderr(()) }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDERR_FILENO);\n+        let ret = fd.write(data);\n+        fd.into_raw();\n+        return ret;\n+    }\n+}"}, {"sha": "8ed7302b6653f74327da76665a0455137a8abae2", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -48,6 +48,11 @@ pub const WSAESHUTDOWN: libc::c_int = 10058;\n pub const ERROR_NO_MORE_FILES: libc::DWORD = 18;\n pub const TOKEN_READ: libc::DWORD = 0x20008;\n \n+// Note that these are not actually HANDLEs, just values to pass to GetStdHandle\n+pub const STD_INPUT_HANDLE: libc::DWORD = -10;\n+pub const STD_OUTPUT_HANDLE: libc::DWORD = -11;\n+pub const STD_ERROR_HANDLE: libc::DWORD = -12;\n+\n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n pub struct WSADATA {\n@@ -427,6 +432,7 @@ extern \"system\" {\n                             DesiredAccess: libc::DWORD,\n                             TokenHandle: *mut libc::HANDLE) -> libc::BOOL;\n     pub fn GetCurrentProcess() -> libc::HANDLE;\n+    pub fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n }\n \n #[link(name = \"userenv\")]"}, {"sha": "0089dcad455df2f731608871524b6edf803f329a", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -10,9 +10,10 @@\n \n use prelude::v1::*;\n \n-use libc::{self, HANDLE};\n-use io;\n use io::ErrorKind;\n+use io;\n+use libc::{self, HANDLE};\n+use mem;\n use ptr;\n use sys::cvt;\n \n@@ -28,6 +29,12 @@ impl Handle {\n \n     pub fn raw(&self) -> HANDLE { self.0 }\n \n+    pub fn into_raw(self) -> HANDLE {\n+        let ret = self.0;\n+        unsafe { mem::forget(self) }\n+        return ret;\n+    }\n+\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         read(self.0, buf)\n     }"}, {"sha": "3bdadbb9012e04da91a39f5635bfb779614b5e42", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -61,6 +61,7 @@ pub mod time;\n pub mod timer;\n pub mod tty;\n pub mod udp;\n+pub mod stdio;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;"}, {"sha": "72ce8b7c6e30c5fb1d12c732c48a2ff97f20521a", "filename": "src/libstd/sys/windows/stdio.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -0,0 +1,155 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n+\n+use io::{self, Cursor};\n+use iter::repeat;\n+use libc;\n+use ptr;\n+use str;\n+use sync::Mutex;\n+use sys::c;\n+use sys::cvt;\n+use sys::handle::Handle;\n+\n+struct NoClose(Option<Handle>);\n+\n+enum Output {\n+    Console(NoClose),\n+    Pipe(NoClose),\n+}\n+\n+pub struct Stdin {\n+    handle: Output,\n+    utf8: Mutex<io::Cursor<Vec<u8>>>,\n+}\n+pub struct Stdout(Output);\n+pub struct Stderr(Output);\n+\n+fn get(handle: libc::DWORD) -> io::Result<Output> {\n+    let handle = unsafe { c::GetStdHandle(handle) };\n+    if handle == libc::INVALID_HANDLE_VALUE {\n+        Err(io::Error::last_os_error())\n+    } else if handle.is_null() {\n+        Err(io::Error::new(io::ErrorKind::Other,\n+                           \"no stdio handle available for this process\", None))\n+    } else {\n+        let ret = NoClose::new(handle);\n+        let mut out = 0;\n+        match unsafe { c::GetConsoleMode(handle, &mut out) } {\n+            0 => Ok(Output::Pipe(ret)),\n+            _ => Ok(Output::Console(ret)),\n+        }\n+    }\n+}\n+\n+fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n+    let handle = match *out {\n+        Output::Console(ref c) => c.get().raw(),\n+        Output::Pipe(ref p) => return p.get().write(data),\n+    };\n+    let utf16 = match str::from_utf8(data).ok() {\n+        Some(utf8) => utf8.utf16_units().collect::<Vec<u16>>(),\n+        None => return Err(invalid_encoding()),\n+    };\n+    let mut written = 0;\n+    try!(cvt(unsafe {\n+        c::WriteConsoleW(handle,\n+                         utf16.as_ptr() as libc::LPCVOID,\n+                         utf16.len() as u32,\n+                         &mut written,\n+                         ptr::null_mut())\n+    }));\n+\n+    // FIXME if this only partially writes the utf16 buffer then we need to\n+    //       figure out how many bytes of `data` were actually written\n+    assert_eq!(written as usize, utf16.len());\n+    Ok(data.len())\n+}\n+\n+impl Stdin {\n+    pub fn new() -> Stdin {\n+        Stdin {\n+            handle: get(c::STD_INPUT_HANDLE).unwrap(),\n+            utf8: Mutex::new(Cursor::new(Vec::new())),\n+        }\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let handle = match self.handle {\n+            Output::Console(ref c) => c.get().raw(),\n+            Output::Pipe(ref p) => return p.get().read(buf),\n+        };\n+        let mut utf8 = self.utf8.lock().unwrap();\n+        // Read more if the buffer is empty\n+        if utf8.position() as usize == utf8.get_ref().len() {\n+            let mut utf16: Vec<u16> = repeat(0u16).take(0x1000).collect();\n+            let mut num = 0;\n+            try!(cvt(unsafe {\n+                c::ReadConsoleW(handle,\n+                                utf16.as_mut_ptr() as libc::LPVOID,\n+                                utf16.len() as u32,\n+                                &mut num,\n+                                ptr::null_mut())\n+            }));\n+            utf16.truncate(num as usize);\n+            // FIXME: what to do about this data that has already been read?\n+            let data = match String::from_utf16(&utf16) {\n+                Ok(utf8) => utf8.into_bytes(),\n+                Err(..) => return Err(invalid_encoding()),\n+            };\n+            *utf8 = Cursor::new(data);\n+        }\n+\n+        // MemReader shouldn't error here since we just filled it\n+        utf8.read(buf)\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> Stdout {\n+        Stdout(get(c::STD_OUTPUT_HANDLE).unwrap())\n+    }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        write(&self.0, data)\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> Stderr {\n+        Stderr(get(c::STD_ERROR_HANDLE).unwrap())\n+    }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        write(&self.0, data)\n+    }\n+}\n+\n+impl NoClose {\n+    fn new(handle: libc::HANDLE) -> NoClose {\n+        NoClose(Some(Handle::new(handle)))\n+    }\n+\n+    fn get(&self) -> &Handle { self.0.as_ref().unwrap() }\n+}\n+\n+impl Drop for NoClose {\n+    fn drop(&mut self) {\n+        self.0.take().unwrap().into_raw();\n+    }\n+}\n+\n+fn invalid_encoding() -> io::Error {\n+    io::Error::new(io::ErrorKind::InvalidInput, \"text was not valid unicode\",\n+                   None)\n+}"}, {"sha": "f239a0d78d1ddd9875bb6c873d5f5f07e0aeb6b4", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -43,12 +43,16 @@\n #![feature(box_syntax)]\n \n use std::ascii::OwnedAsciiExt;\n+use std::env;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::io;\n use std::slice;\n use std::sync::Arc;\n use std::thread;\n \n static TABLE: [u8;4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n-static TABLE_SIZE: uint = 2 << 16;\n+static TABLE_SIZE: usize = 2 << 16;\n \n static OCCURRENCES: [&'static str;5] = [\n     \"GGT\",\n@@ -73,15 +77,15 @@ impl Code {\n         Code((self.hash() << 2) + (pack_symbol(c) as u64))\n     }\n \n-    fn rotate(&self, c: u8, frame: uint) -> Code {\n+    fn rotate(&self, c: u8, frame: usize) -> Code {\n         Code(self.push_char(c).hash() & ((1u64 << (2 * frame)) - 1))\n     }\n \n     fn pack(string: &str) -> Code {\n         string.bytes().fold(Code(0u64), |a, b| a.push_char(b))\n     }\n \n-    fn unpack(&self, frame: uint) -> String {\n+    fn unpack(&self, frame: usize) -> String {\n         let mut key = self.hash();\n         let mut result = Vec::new();\n         for _ in 0..frame {\n@@ -113,13 +117,13 @@ struct PrintCallback(&'static str);\n impl TableCallback for PrintCallback {\n     fn f(&self, entry: &mut Entry) {\n         let PrintCallback(s) = *self;\n-        println!(\"{}\\t{}\", entry.count as int, s);\n+        println!(\"{}\\t{}\", entry.count, s);\n     }\n }\n \n struct Entry {\n     code: Code,\n-    count: uint,\n+    count: usize,\n     next: Option<Box<Entry>>,\n }\n \n@@ -165,20 +169,20 @@ impl Table {\n         let index = key.hash() % (TABLE_SIZE as u64);\n \n         {\n-            if self.items[index as uint].is_none() {\n+            if self.items[index as usize].is_none() {\n                 let mut entry = box Entry {\n                     code: key,\n                     count: 0,\n                     next: None,\n                 };\n                 c.f(&mut *entry);\n-                self.items[index as uint] = Some(entry);\n+                self.items[index as usize] = Some(entry);\n                 return;\n             }\n         }\n \n         {\n-            let entry = self.items[index as uint].as_mut().unwrap();\n+            let entry = self.items[index as usize].as_mut().unwrap();\n             if entry.code == key {\n                 c.f(&mut **entry);\n                 return;\n@@ -233,10 +237,10 @@ fn pack_symbol(c: u8) -> u8 {\n }\n \n fn unpack_symbol(c: u8) -> u8 {\n-    TABLE[c as uint]\n+    TABLE[c as usize]\n }\n \n-fn generate_frequencies(mut input: &[u8], frame: uint) -> Table {\n+fn generate_frequencies(mut input: &[u8], frame: usize) -> Table {\n     let mut frequencies = Table::new();\n     if input.len() < frame { return frequencies; }\n     let mut code = Code(0);\n@@ -256,7 +260,7 @@ fn generate_frequencies(mut input: &[u8], frame: uint) -> Table {\n     frequencies\n }\n \n-fn print_frequencies(frequencies: &Table, frame: uint) {\n+fn print_frequencies(frequencies: &Table, frame: usize) {\n     let mut vector = Vec::new();\n     for entry in frequencies.iter() {\n         vector.push((entry.count, entry.code));\n@@ -280,9 +284,9 @@ fn print_occurrences(frequencies: &mut Table, occurrence: &'static str) {\n     frequencies.lookup(Code::pack(occurrence), PrintCallback(occurrence))\n }\n \n-fn get_sequence<R: Buffer>(r: &mut R, key: &str) -> Vec<u8> {\n+fn get_sequence<R: BufRead>(r: &mut R, key: &str) -> Vec<u8> {\n     let mut res = Vec::new();\n-    for l in r.lines().map(|l| l.ok().unwrap())\n+    for l in r.lines().map(|l| l.unwrap())\n         .skip_while(|l| key != &l[..key.len()]).skip(1)\n     {\n         res.push_all(l.trim().as_bytes());\n@@ -291,13 +295,13 @@ fn get_sequence<R: Buffer>(r: &mut R, key: &str) -> Vec<u8> {\n }\n \n fn main() {\n-    let input = if std::env::var_os(\"RUST_BENCH\").is_some() {\n-        let fd = std::old_io::File::open(&Path::new(\"shootout-k-nucleotide.data\"));\n-        get_sequence(&mut std::old_io::BufferedReader::new(fd), \">THREE\")\n+    let input = if env::var_os(\"RUST_BENCH\").is_some() {\n+        let f = File::open(\"shootout-k-nucleotide.data\").unwrap();\n+        get_sequence(&mut io::BufReader::new(f), \">THREE\")\n     } else {\n-        let mut stdin = std::old_io::stdin();\n+        let stdin = io::stdin();\n         let mut stdin = stdin.lock();\n-        get_sequence(&mut *stdin, \">THREE\")\n+        get_sequence(&mut stdin, \">THREE\")\n     };\n     let input = Arc::new(input);\n "}, {"sha": "40e1e7d2b76b02614a211db532013b8a9a0b1452", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -13,9 +13,8 @@\n #![feature(box_syntax)]\n #![allow(non_snake_case)]\n \n-use std::old_io::BufferedReader;\n-use std::old_io::stdio::StdReader;\n-use std::old_io;\n+use std::io::prelude::*;\n+use std::io;\n use std::iter::repeat;\n use std::num::Int;\n use std::env;\n@@ -37,7 +36,7 @@ use std::env;\n //\n \n // internal type of sudoku grids\n-type grid = Vec<Vec<u8> > ;\n+type grid = Vec<Vec<u8>>;\n \n struct Sudoku {\n     grid: grid\n@@ -55,9 +54,11 @@ impl Sudoku {\n         return Sudoku::new(g)\n     }\n \n-    pub fn read(mut reader: &mut BufferedReader<StdReader>) -> Sudoku {\n+    pub fn read(reader: &mut BufRead) -> Sudoku {\n         /* assert first line is exactly \"9,9\" */\n-        assert!(reader.read_line().unwrap() == \"9,9\".to_string());\n+        let mut s = String::new();\n+        reader.read_line(&mut s).unwrap();\n+        assert_eq!(s, \"9,9\\n\");\n \n         let mut g = repeat(vec![0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8])\n                           .take(10).collect::<Vec<_>>();\n@@ -71,7 +72,7 @@ impl Sudoku {\n             if comps.len() == 3 {\n                 let row = comps[0].parse::<u8>().unwrap();\n                 let col = comps[1].parse::<u8>().unwrap();\n-                g[row as uint][col as uint] = comps[2].parse().unwrap();\n+                g[row as usize][col as usize] = comps[2].parse().unwrap();\n             }\n             else {\n                 panic!(\"Invalid sudoku file\");\n@@ -80,11 +81,11 @@ impl Sudoku {\n         return Sudoku::new(g)\n     }\n \n-    pub fn write(&self, writer: &mut old_io::Writer) {\n+    pub fn write(&self, writer: &mut Write) {\n         for row in 0u8..9u8 {\n-            write!(writer, \"{}\", self.grid[row as uint][0]);\n+            write!(writer, \"{}\", self.grid[row as usize][0]);\n             for col in 1u8..9u8 {\n-                write!(writer, \" {}\", self.grid[row as uint][col as uint]);\n+                write!(writer, \" {}\", self.grid[row as usize][col as usize]);\n             }\n             write!(writer, \"\\n\");\n          }\n@@ -95,7 +96,7 @@ impl Sudoku {\n         let mut work: Vec<(u8, u8)> = Vec::new(); /* queue of uncolored fields */\n         for row in 0u8..9u8 {\n             for col in 0u8..9u8 {\n-                let color = self.grid[row as uint][col as uint];\n+                let color = self.grid[row as usize][col as usize];\n                 if color == 0u8 {\n                     work.push((row, col));\n                 }\n@@ -107,7 +108,7 @@ impl Sudoku {\n         while ptr < end {\n             let (row, col) = work[ptr];\n             // is there another color to try?\n-            let the_color = self.grid[row as uint][col as uint] +\n+            let the_color = self.grid[row as usize][col as usize] +\n                                 (1 as u8);\n             if self.next_color(row, col, the_color) {\n                 //  yes: advance work list\n@@ -130,28 +131,28 @@ impl Sudoku {\n \n             // find first remaining color that is available\n             let next = avail.next();\n-            self.grid[row as uint][col as uint] = next;\n+            self.grid[row as usize][col as usize] = next;\n             return 0u8 != next;\n         }\n-        self.grid[row as uint][col as uint] = 0u8;\n+        self.grid[row as usize][col as usize] = 0u8;\n         return false;\n     }\n \n     // find colors available in neighbourhood of (row, col)\n     fn drop_colors(&mut self, avail: &mut Colors, row: u8, col: u8) {\n         for idx in 0u8..9u8 {\n             /* check same column fields */\n-            avail.remove(self.grid[idx as uint][col as uint]);\n+            avail.remove(self.grid[idx as usize][col as usize]);\n             /* check same row fields */\n-            avail.remove(self.grid[row as uint][idx as uint]);\n+            avail.remove(self.grid[row as usize][idx as usize]);\n         }\n \n         // check same block fields\n         let row0 = (row / 3u8) * 3u8;\n         let col0 = (col / 3u8) * 3u8;\n         for alt_row in row0..row0 + 3u8 {\n             for alt_col in col0..col0 + 3u8 {\n-                avail.remove(self.grid[alt_row as uint][alt_col as uint]);\n+                avail.remove(self.grid[alt_row as usize][alt_col as usize]);\n             }\n         }\n     }\n@@ -165,7 +166,7 @@ static HEADS: u16 = (1u16 << 10) - 1; /* bits 9..0 */\n impl Colors {\n     fn new(start_color: u8) -> Colors {\n         // Sets bits 9..start_color\n-        let tails = !0u16 << start_color as uint;\n+        let tails = !0u16 << start_color as usize;\n         return Colors(HEADS & tails);\n     }\n \n@@ -182,7 +183,7 @@ impl Colors {\n     fn remove(&mut self, color: u8) {\n         if color != 0u8 {\n             let Colors(val) = *self;\n-            let mask = !(1u16 << color as uint);\n+            let mask = !(1u16 << color as usize);\n             *self    = Colors(val & mask);\n         }\n     }\n@@ -269,15 +270,16 @@ fn check_DEFAULT_SUDOKU_solution() {\n }\n \n fn main() {\n-    let args        = env::args();\n+    let args = env::args();\n     let use_default = args.len() == 1;\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&DEFAULT_SUDOKU)\n     } else {\n-        let mut stdin = old_io::stdin();\n-        let mut stdin = stdin.lock();\n-        Sudoku::read(&mut *stdin)\n+        let stdin = io::stdin();\n+        let mut locked = stdin.lock();\n+        Sudoku::read(&mut locked)\n     };\n     sudoku.solve();\n-    sudoku.write(&mut old_io::stdout());\n+    let out = io::stdout();\n+    sudoku.write(&mut out.lock());\n }"}, {"sha": "127be1f90d5ff08fc5ed5a5ffa7d625fd0dca84f", "filename": "src/test/run-pass-valgrind/cleanup-stdin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let _ = std::old_io::stdin();\n+    let _ = std::io::stdin();\n }"}, {"sha": "f1c747eca68406c82bcb7b97738feeabf9c9dde8", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-fast\n-\n use std::env;\n-use std::old_io;\n+use std::io::prelude::*;\n+use std::io;\n+use std::process::{Command, Stdio};\n use std::str;\n \n fn main() {\n@@ -25,17 +25,19 @@ fn main() {\n \n fn parent() {\n     let args: Vec<String> = env::args().collect();\n-    let mut p = old_io::process::Command::new(&args[0])\n-                                     .arg(\"child\").spawn().unwrap();\n-    p.stdin.as_mut().unwrap().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n+    let mut p = Command::new(&args[0]).arg(\"child\")\n+                        .stdout(Stdio::capture())\n+                        .stdin(Stdio::capture())\n+                        .spawn().unwrap();\n+    p.stdin.as_mut().unwrap().write_all(b\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output().unwrap();\n     assert!(out.status.success());\n-    let s = str::from_utf8(&out.output).unwrap();\n-    assert_eq!(s, \"test1\\n\\ntest2\\n\\ntest3\\n\");\n+    let s = str::from_utf8(&out.stdout).unwrap();\n+    assert_eq!(s, \"test1\\ntest2\\ntest3\\n\");\n }\n \n fn child() {\n-    let mut stdin = old_io::stdin();\n+    let mut stdin = io::stdin();\n     for line in stdin.lock().lines() {\n         println!(\"{}\", line.unwrap());\n     }"}, {"sha": "7e4c464d9aaba7f37c5b650fe07725be6ca85505", "filename": "src/test/run-pass/issue-14456.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14456.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use std::old_io::process;\n-use std::old_io::Command;\n-use std::old_io;\n use std::env;\n+use std::io::prelude::*;\n+use std::io;\n+use std::process::{Command, Stdio};\n \n fn main() {\n     let args: Vec<String> = env::args().collect();\n@@ -21,22 +20,23 @@ fn main() {\n     }\n \n     test();\n-\n }\n \n fn child() {\n-    old_io::stdout().write_line(\"foo\").unwrap();\n-    old_io::stderr().write_line(\"bar\").unwrap();\n-    let mut stdin = old_io::stdin();\n-    assert_eq!(stdin.lock().read_line().err().unwrap().kind, old_io::EndOfFile);\n+    writeln!(&mut io::stdout(), \"foo\").unwrap();\n+    writeln!(&mut io::stderr(), \"bar\").unwrap();\n+    let mut stdin = io::stdin();\n+    let mut s = String::new();\n+    stdin.lock().read_line(&mut s).unwrap();\n+    assert_eq!(s.len(), 0);\n }\n \n fn test() {\n     let args: Vec<String> = env::args().collect();\n     let mut p = Command::new(&args[0]).arg(\"child\")\n-                                     .stdin(process::Ignored)\n-                                     .stdout(process::Ignored)\n-                                     .stderr(process::Ignored)\n+                                     .stdin(Stdio::capture())\n+                                     .stdout(Stdio::capture())\n+                                     .stderr(Stdio::capture())\n                                      .spawn().unwrap();\n     assert!(p.wait().unwrap().success());\n }"}, {"sha": "1ebe3a7f068acc7184c3e334e70876dc919dcaf8", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -19,11 +19,13 @@\n // A var moved into a proc, that has a mutable loan path should\n // not trigger a misleading unused_mut warning.\n \n+use std::io::prelude::*;\n use std::thread;\n \n pub fn main() {\n-    let mut stdin = std::old_io::stdin();\n+    let mut stdin = std::io::stdin();\n     thread::spawn(move|| {\n-        let _ = stdin.read_to_end();\n-    });\n+        let mut v = Vec::new();\n+        let _ = stdin.read_to_end(&mut v);\n+    }).join().ok().unwrap();\n }"}, {"sha": "d4c32f42188bb0b4934f073c2c21955d3ecb4c7a", "filename": "src/test/run-pass/issue-17322.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-17322.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-17322.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17322.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -11,13 +11,13 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-use std::old_io;\n+use std::io::{self, Write};\n \n-fn f(wr: &mut Writer) {\n-    wr.write_str(\"hello\").ok().expect(\"failed\");\n+fn f(wr: &mut Write) {\n+    wr.write_all(b\"hello\").ok().expect(\"failed\");\n }\n \n fn main() {\n-    let mut wr = box old_io::stdout() as Box<Writer + 'static>;\n+    let mut wr = box io::stdout() as Box<Write>;\n     f(&mut wr);\n }"}, {"sha": "074bbf270fd7e26f87342ceca320fd7ae71ed3e7", "filename": "src/test/run-pass/issue-4333.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4333.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::old_io;\n+use std::io;\n \n pub fn main() {\n-    let stdout = &mut old_io::stdout() as &mut old_io::Writer;\n+    let stdout = &mut io::stdout() as &mut io::Write;\n     stdout.write(b\"Hello!\");\n }"}, {"sha": "3e5f84fa26fe075769334e213e478b5acf3234e5", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5142056f7f57387dc37361889d13409667b920d/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=c5142056f7f57387dc37361889d13409667b920d", "patch": "@@ -16,63 +16,62 @@\n // non-ASCII characters.  The child process ensures all the strings are\n // intact.\n \n-use std::old_io;\n-use std::old_io::fs;\n-use std::old_io::Command;\n+use std::io::prelude::*;\n+use std::io;\n+use std::fs;\n+use std::process::Command;\n use std::os;\n use std::env;\n-use std::old_path::Path;\n+use std::path::{Path, PathBuf};\n \n fn main() {\n     let my_args = env::args().collect::<Vec<_>>();\n-    let my_cwd  = os::getcwd().unwrap();\n+    let my_cwd  = PathBuf::new(os::getcwd().unwrap().as_str().unwrap());\n     let my_env  = env::vars().collect::<Vec<_>>();\n-    let my_path = Path::new(os::self_exe_name().unwrap());\n-    let my_dir  = my_path.dir_path();\n-    let my_ext  = my_path.extension_str().unwrap_or(\"\");\n+    let my_path = PathBuf::new(os::self_exe_name().unwrap().as_str().unwrap());\n+    let my_dir  = my_path.parent().unwrap();\n+    let my_ext  = my_path.extension().and_then(|s| s.to_str()).unwrap_or(\"\");\n \n     // some non-ASCII characters\n-    let blah       = \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\";\n+    let blah       = \"\\u{3c0}\\u{42f}\\u{97f3}\\u{e6}\\u{221e}\";\n \n     let child_name = \"child\";\n     let child_dir  = format!(\"process-spawn-with-unicode-params-{}\", blah);\n \n     // parameters sent to child / expected to be received from parent\n     let arg = blah;\n-    let cwd = my_dir.join(Path::new(child_dir.clone()));\n+    let cwd = my_dir.join(&child_dir);\n     let env = (\"RUST_TEST_PROC_SPAWN_UNICODE\".to_string(), blah.to_string());\n \n     // am I the parent or the child?\n     if my_args.len() == 1 {             // parent\n \n         let child_filestem = Path::new(child_name);\n         let child_filename = child_filestem.with_extension(my_ext);\n-        let child_path     = cwd.join(child_filename);\n+        let child_path     = cwd.join(&child_filename);\n \n         // make a separate directory for the child\n-        drop(fs::mkdir(&cwd, old_io::USER_RWX).is_ok());\n-        assert!(fs::copy(&my_path, &child_path).is_ok());\n-        let mut my_env = my_env;\n-        my_env.push(env);\n+        let _ = fs::create_dir(&cwd);\n+        fs::copy(&my_path, &child_path).unwrap();\n \n         // run child\n         let p = Command::new(&child_path)\n                         .arg(arg)\n-                        .cwd(&cwd)\n-                        .env_set_all(&my_env)\n+                        .current_dir(&cwd)\n+                        .env(&env.0, &env.1)\n                         .spawn().unwrap().wait_with_output().unwrap();\n \n         // display the output\n-        assert!(old_io::stdout().write(&p.output).is_ok());\n-        assert!(old_io::stderr().write(&p.error).is_ok());\n+        io::stdout().write_all(&p.stdout).unwrap();\n+        io::stderr().write_all(&p.stderr).unwrap();\n \n         // make sure the child succeeded\n         assert!(p.status.success());\n \n     } else {                            // child\n \n         // check working directory (don't try to compare with `cwd` here!)\n-        assert!(my_cwd.ends_with_path(&Path::new(child_dir)));\n+        assert!(my_cwd.ends_with(&child_dir));\n \n         // check arguments\n         assert_eq!(&*my_args[1], arg);"}]}