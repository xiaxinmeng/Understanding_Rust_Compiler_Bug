{"sha": "11613fc1c048f5bec4cf792397a15bdd17dfd797", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNjEzZmMxYzA0OGY1YmVjNGNmNzkyMzk3YTE1YmRkMTdkZmQ3OTc=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-04T05:02:59Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-08T19:06:21Z"}, "message": "Handle fallout in std::ascii and std::strconv\n\nAPI changes:\n\n- OwnedAsciiCast returns Vec<Ascii> instead of ~[Ascii]\n- OwnedAsciiCast is implemented on Vec<u8>\n- AsciiStr.to_lower/upper() returns Vec<Ascii>\n- IntoBytes::into_bytes() returns Vec<u8>\n- float_to_str_bytes_common() returns (Vec<u8>, bool)", "tree": {"sha": "648ac5aafa8fabf5d3e74d67e705210039fd245e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/648ac5aafa8fabf5d3e74d67e705210039fd245e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11613fc1c048f5bec4cf792397a15bdd17dfd797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11613fc1c048f5bec4cf792397a15bdd17dfd797", "html_url": "https://github.com/rust-lang/rust/commit/11613fc1c048f5bec4cf792397a15bdd17dfd797", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11613fc1c048f5bec4cf792397a15bdd17dfd797/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbc35eada991b3256812598a555b1ef442d29c15", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc35eada991b3256812598a555b1ef442d29c15", "html_url": "https://github.com/rust-lang/rust/commit/bbc35eada991b3256812598a555b1ef442d29c15"}], "stats": {"total": 105, "additions": 59, "deletions": 46}, "files": [{"sha": "32f78c23aa731541fb6b0171b3094ed24d9dcf6c", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 49, "deletions": 36, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/11613fc1c048f5bec4cf792397a15bdd17dfd797/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11613fc1c048f5bec4cf792397a15bdd17dfd797/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=11613fc1c048f5bec4cf792397a15bdd17dfd797", "patch": "@@ -217,14 +217,14 @@ pub trait OwnedAsciiCast {\n \n     /// Take ownership and cast to an ascii vector. Fail on non-ASCII input.\n     #[inline]\n-    fn into_ascii(self) -> ~[Ascii] {\n+    fn into_ascii(self) -> Vec<Ascii> {\n         assert!(self.is_ascii());\n         unsafe {self.into_ascii_nocheck()}\n     }\n \n     /// Take ownership and cast to an ascii vector. Return None on non-ASCII input.\n     #[inline]\n-    fn into_ascii_opt(self) -> Option<~[Ascii]> {\n+    fn into_ascii_opt(self) -> Option<Vec<Ascii>> {\n         if self.is_ascii() {\n             Some(unsafe { self.into_ascii_nocheck() })\n         } else {\n@@ -234,7 +234,7 @@ pub trait OwnedAsciiCast {\n \n     /// Take ownership and cast to an ascii vector.\n     /// Does not perform validation checks.\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii];\n+    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii>;\n }\n \n impl OwnedAsciiCast for ~[u8] {\n@@ -244,8 +244,8 @@ impl OwnedAsciiCast for ~[u8] {\n     }\n \n     #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n-        cast::transmute(self)\n+    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n+        cast::transmute(Vec::from_slice(self.as_slice()))\n     }\n }\n \n@@ -256,7 +256,20 @@ impl OwnedAsciiCast for ~str {\n     }\n \n     #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n+    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n+        let v: ~[u8] = cast::transmute(self);\n+        v.into_ascii_nocheck()\n+    }\n+}\n+\n+impl OwnedAsciiCast for Vec<u8> {\n+    #[inline]\n+    fn is_ascii(&self) -> bool {\n+        self.as_slice().is_ascii()\n+    }\n+\n+    #[inline]\n+    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n         cast::transmute(self)\n     }\n }\n@@ -268,10 +281,10 @@ pub trait AsciiStr {\n     fn as_str_ascii<'a>(&'a self) -> &'a str;\n \n     /// Convert to vector representing a lower cased ascii string.\n-    fn to_lower(&self) -> ~[Ascii];\n+    fn to_lower(&self) -> Vec<Ascii>;\n \n     /// Convert to vector representing a upper cased ascii string.\n-    fn to_upper(&self) -> ~[Ascii];\n+    fn to_upper(&self) -> Vec<Ascii>;\n \n     /// Compares two Ascii strings ignoring case.\n     fn eq_ignore_case(self, other: &[Ascii]) -> bool;\n@@ -284,12 +297,12 @@ impl<'a> AsciiStr for &'a [Ascii] {\n     }\n \n     #[inline]\n-    fn to_lower(&self) -> ~[Ascii] {\n+    fn to_lower(&self) -> Vec<Ascii> {\n         self.iter().map(|a| a.to_lower()).collect()\n     }\n \n     #[inline]\n-    fn to_upper(&self) -> ~[Ascii] {\n+    fn to_upper(&self) -> Vec<Ascii> {\n         self.iter().map(|a| a.to_upper()).collect()\n     }\n \n@@ -309,19 +322,21 @@ impl IntoStr for ~[Ascii] {\n impl IntoStr for Vec<Ascii> {\n     #[inline]\n     fn into_str(self) -> ~str {\n-        let v: ~[Ascii] = self.move_iter().collect();\n-        unsafe { cast::transmute(v) }\n+        unsafe {\n+            let s: &str = cast::transmute(self.as_slice());\n+            s.to_owned()\n+        }\n     }\n }\n \n-/// Trait to convert to an owned byte array by consuming self\n+/// Trait to convert to an owned byte vector by consuming self\n pub trait IntoBytes {\n-    /// Converts to an owned byte array by consuming self\n-    fn into_bytes(self) -> ~[u8];\n+    /// Converts to an owned byte vector by consuming self\n+    fn into_bytes(self) -> Vec<u8>;\n }\n \n-impl IntoBytes for ~[Ascii] {\n-    fn into_bytes(self) -> ~[u8] {\n+impl IntoBytes for Vec<Ascii> {\n+    fn into_bytes(self) -> Vec<u8> {\n         unsafe { cast::transmute(self) }\n     }\n }\n@@ -404,9 +419,11 @@ unsafe fn str_map_bytes(string: ~str, map: &'static [u8]) -> ~str {\n \n #[inline]\n unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> ~str {\n-    let bytes = string.bytes().map(|b| map[b as uint]).collect::<~[_]>();\n-\n-    str::raw::from_utf8_owned(bytes)\n+    let mut s = string.to_owned();\n+    for b in str::raw::as_owned_vec(&mut s).mut_iter() {\n+        *b = map[*b as uint];\n+    }\n+    s\n }\n \n static ASCII_LOWER_MAP: &'static [u8] = &[\n@@ -492,7 +509,6 @@ mod tests {\n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n         (&[$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n-        (~[$($e:expr),*]) => (box [$(Ascii{chr:$e}),*]);\n     )\n \n     macro_rules! vec2ascii (\n@@ -556,20 +572,17 @@ mod tests {\n \n     #[test]\n     fn test_ascii_vec_ng() {\n-        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_lower()).into_str(),\n-                   \"abcdef&?#\".to_owned());\n-        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_upper()).into_str(),\n-                   \"ABCDEF&?#\".to_owned());\n-        assert_eq!(Vec::from_slice(\"\".to_ascii().to_lower()).into_str(), \"\".to_owned());\n-        assert_eq!(Vec::from_slice(\"YMCA\".to_ascii().to_lower()).into_str(), \"ymca\".to_owned());\n-        assert_eq!(Vec::from_slice(\"abcDEFxyz:.;\".to_ascii().to_upper()).into_str(),\n-                   \"ABCDEFXYZ:.;\".to_owned());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_owned());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_owned());\n+        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_owned());\n+        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_owned());\n+        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_owned());\n     }\n \n     #[test]\n     fn test_owned_ascii_vec() {\n-        assert_eq!((\"( ;\".to_owned()).into_ascii(), v2ascii!(~[40, 32, 59]));\n-        assert_eq!((box [40u8, 32u8, 59u8]).into_ascii(), v2ascii!(~[40, 32, 59]));\n+        assert_eq!((\"( ;\".to_owned()).into_ascii(), vec2ascii![40, 32, 59]);\n+        assert_eq!((box [40u8, 32u8, 59u8]).into_ascii(), vec2ascii![40, 32, 59]);\n     }\n \n     #[test]\n@@ -580,13 +593,13 @@ mod tests {\n \n     #[test]\n     fn test_ascii_into_str() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).into_str(), \"( ;\".to_owned());\n+        assert_eq!(vec2ascii![40, 32, 59].into_str(), \"( ;\".to_owned());\n         assert_eq!(vec2ascii!(40, 32, 59).into_str(), \"( ;\".to_owned());\n     }\n \n     #[test]\n     fn test_ascii_to_bytes() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).into_bytes(), box [40u8, 32u8, 59u8]);\n+        assert_eq!(vec2ascii![40, 32, 59].into_bytes(), vec![40u8, 32u8, 59u8]);\n     }\n \n     #[test] #[should_fail]\n@@ -625,10 +638,10 @@ mod tests {\n         assert_eq!(v.to_ascii_opt(), Some(v2));\n         assert_eq!(\"zo\u00e4\u534e\".to_ascii_opt(), None);\n \n-        assert_eq!((box [40u8, 32u8, 59u8]).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n-        assert_eq!((box [127u8, 128u8, 255u8]).into_ascii_opt(), None);\n+        assert_eq!((vec![40u8, 32u8, 59u8]).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n+        assert_eq!((vec![127u8, 128u8, 255u8]).into_ascii_opt(), None);\n \n-        assert_eq!((\"( ;\".to_owned()).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n+        assert_eq!((\"( ;\".to_owned()).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n         assert_eq!((\"zo\u00e4\u534e\".to_owned()).into_ascii_opt(), None);\n     }\n "}, {"sha": "618449939ce266f8f5e6a027a4dadcb040dc3906", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/11613fc1c048f5bec4cf792397a15bdd17dfd797/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11613fc1c048f5bec4cf792397a15bdd17dfd797/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=11613fc1c048f5bec4cf792397a15bdd17dfd797", "patch": "@@ -22,8 +22,8 @@ use option::{None, Option, Some};\n use slice::OwnedVector;\n use slice::{CloneableVector, ImmutableVector, MutableVector};\n use std::cmp::{Ord, Eq};\n-use str::{StrSlice};\n-use str;\n+use str::{Str, StrSlice};\n+use strbuf::StrBuf;\n use vec::Vec;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n@@ -262,7 +262,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n-        ) -> (~[u8], bool) {\n+        ) -> (Vec<u8>, bool) {\n     assert!(2 <= radix && radix <= 36);\n     match exp_format {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n@@ -278,17 +278,17 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n     let _1: T = One::one();\n \n     match num.classify() {\n-        FPNaN => { return (\"NaN\".as_bytes().to_owned(), true); }\n+        FPNaN => { return (Vec::from_slice(\"NaN\".as_bytes()), true); }\n         FPInfinite if num > _0 => {\n             return match sign {\n-                SignAll => (\"+inf\".as_bytes().to_owned(), true),\n-                _       => (\"inf\".as_bytes().to_owned(), true)\n+                SignAll => (Vec::from_slice(\"+inf\".as_bytes()), true),\n+                _       => (Vec::from_slice(\"inf\".as_bytes()), true)\n             };\n         }\n         FPInfinite if num < _0 => {\n             return match sign {\n-                SignNone => (\"inf\".as_bytes().to_owned(), true),\n-                _        => (\"-inf\".as_bytes().to_owned(), true),\n+                SignNone => (Vec::from_slice(\"inf\".as_bytes()), true),\n+                _        => (Vec::from_slice(\"-inf\".as_bytes()), true),\n             };\n         }\n         _ => {}\n@@ -483,7 +483,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n         }\n     }\n \n-    (buf.move_iter().collect(), false)\n+    (buf, false)\n }\n \n /**\n@@ -498,7 +498,7 @@ pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+\n         ) -> (~str, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n                                negative_zero, sign, digits, exp_format, exp_capital);\n-    (str::from_utf8_owned(bytes).unwrap(), special)\n+    (StrBuf::from_utf8(bytes).unwrap().into_owned(), special)\n }\n \n // Some constants for from_str_bytes_common's input validation,"}]}