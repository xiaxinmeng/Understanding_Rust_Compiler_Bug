{"sha": "fe90c189f488d336fc34979d6b928555d984a4d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOTBjMTg5ZjQ4OGQzMzZmYzM0OTc5ZDZiOTI4NTU1ZDk4NGE0ZDc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-08T22:37:45Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T08:32:53Z"}, "message": "Only write metadata for items that actually appear in the root AST\n\nNot for imported ASTs from inlined items.", "tree": {"sha": "b18188f1fc965b1e8ba28217d9f5f75f8aaec0c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b18188f1fc965b1e8ba28217d9f5f75f8aaec0c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe90c189f488d336fc34979d6b928555d984a4d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe90c189f488d336fc34979d6b928555d984a4d7", "html_url": "https://github.com/rust-lang/rust/commit/fe90c189f488d336fc34979d6b928555d984a4d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe90c189f488d336fc34979d6b928555d984a4d7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c8c50d6cb1d7cce0f597dd60daf2a5109b9c0de", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c8c50d6cb1d7cce0f597dd60daf2a5109b9c0de", "html_url": "https://github.com/rust-lang/rust/commit/2c8c50d6cb1d7cce0f597dd60daf2a5109b9c0de"}], "stats": {"total": 76, "additions": 42, "deletions": 34}, "files": [{"sha": "57813f1791b589812a03a5838edd38cb2127434e", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fe90c189f488d336fc34979d6b928555d984a4d7/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe90c189f488d336fc34979d6b928555d984a4d7/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=fe90c189f488d336fc34979d6b928555d984a4d7", "patch": "@@ -6,7 +6,7 @@ import io::writer_util;\n import ebml::writer;\n import syntax::ast::*;\n import syntax::print::pprust;\n-import syntax::ast_util;\n+import syntax::{ast_util, visit};\n import syntax::ast_util::local_def;\n import common::*;\n import middle::trans::common::crate_ctxt;\n@@ -249,13 +249,13 @@ fn encode_parent_item(ebml_w: ebml::writer, id: def_id) {\n \n fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                             id: node_id, variants: [variant],\n-                            path: ast_map::path, &index: [entry<int>],\n+                            path: ast_map::path, index: @mutable [entry<int>],\n                             ty_params: [ty_param]) {\n     let disr_val = 0;\n     let i = 0;\n     let vi = ty::enum_variants(ecx.ccx.tcx, {crate: local_crate, node: id});\n     for variant: variant in variants {\n-        index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n+        *index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v');\n@@ -329,7 +329,7 @@ fn purity_fn_family(p: purity) -> char {\n }\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n-                        &index: [entry<int>], path: ast_map::path) -> bool {\n+                        index: @mutable [entry<int>], path: ast_map::path) {\n \n     fn should_inline(attrs: [attribute]) -> bool {\n         alt attr::find_inline_attr(attrs) {\n@@ -340,7 +340,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n     let tcx = ecx.ccx.tcx;\n     let must_write = alt item.node { item_enum(_, _) { true } _ { false } };\n-    if !must_write && !ecx.reachable.contains_key(item.id) { ret false; }\n+    if !must_write && !ecx.reachable.contains_key(item.id) { ret; }\n+    *index += [{val: item.id, pos: ebml_w.writer.tell()}];\n \n     alt item.node {\n       item_const(_, _) {\n@@ -419,7 +420,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n \n-        index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n+        *index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'f');\n@@ -457,7 +458,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n         let impl_path = path + [ast_map::path_name(item.ident)];\n         for m in methods {\n-            index += [{val: m.id, pos: ebml_w.writer.tell()}];\n+            *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n             ebml_w.start_tag(tag_items_data_item);\n             encode_def_id(ebml_w, local_def(m.id));\n             encode_family(ebml_w, purity_fn_family(m.decl.purity));\n@@ -496,13 +497,15 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.end_tag();\n       }\n     }\n-    ret true;\n }\n \n fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n-                               nitem: @native_item, path: ast_map::path)\n-    -> bool {\n-    if !ecx.reachable.contains_key(nitem.id) { ret false; }\n+                               nitem: @native_item,\n+                               index: @mutable [entry<int>],\n+                               path: ast_map::path) {\n+    if !ecx.reachable.contains_key(nitem.id) { ret; }\n+    *index += [{val: nitem.id, pos: ebml_w.writer.tell()}];\n+\n     ebml_w.start_tag(tag_items_data_item);\n     alt nitem.node {\n       native_item_fn(fn_decl, tps) {\n@@ -515,30 +518,35 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n       }\n     }\n     ebml_w.end_tag();\n-    ret true;\n }\n \n fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n-                         crate_mod: _mod) -> [entry<int>] {\n-    let index: [entry<int>] = [];\n+                         crate: @crate) -> [entry<int>] {\n+    let index = @mutable [];\n     ebml_w.start_tag(tag_items_data);\n-    index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n-    encode_info_for_mod(ecx, ebml_w, crate_mod, crate_node_id, [], \"\");\n-    ecx.ccx.tcx.items.items {|key, val|\n-        let where = ebml_w.writer.tell();\n-        let written = alt val {\n-          middle::ast_map::node_item(i, path) if i.id == key {\n-            encode_info_for_item(ecx, ebml_w, i, index, *path)\n-          }\n-          middle::ast_map::node_native_item(i, _, path) {\n-            encode_info_for_native_item(ecx, ebml_w, i, *path)\n-          }\n-          _ { false }\n-        };\n-        if written { index += [{val: key, pos: where}]; }\n-    };\n+    *index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n+    encode_info_for_mod(ecx, ebml_w, crate.node.module,\n+                        crate_node_id, [], \"\");\n+    visit::visit_crate(*crate, (), visit::mk_vt(@{\n+        visit_expr: {|_e, _cx, _v|},\n+        visit_item: {|i, cx, v|\n+            visit::visit_item(i, cx, v);\n+            let path = alt check ecx.ccx.tcx.items.get(i.id) {\n+              ast_map::node_item(_, pt) { pt }\n+            };\n+            encode_info_for_item(ecx, ebml_w, i, index, *path);\n+        },\n+        visit_native_item: {|ni, cx, v|\n+            visit::visit_native_item(ni, cx, v);\n+            let path = alt check ecx.ccx.tcx.items.get(ni.id) {\n+              ast_map::node_native_item(_, _, pt) { pt }\n+            };\n+            encode_info_for_native_item(ecx, ebml_w, ni, index, *path);\n+        }\n+        with *visit::default_visitor()\n+    }));\n     ebml_w.end_tag();\n-    ret index;\n+    ret *index;\n }\n \n \n@@ -765,7 +773,7 @@ fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> [u8] {\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n-    let items_index = encode_info_for_items(ecx, ebml_w, crate.node.module);\n+    let items_index = encode_info_for_items(ecx, ebml_w, crate);\n     let items_buckets = create_index(items_index, hash_node_id);\n     encode_index(ebml_w, items_buckets, write_int);\n     ebml_w.end_tag();"}, {"sha": "6a287ee126e16b1b26ce74faf275599afeb530f4", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe90c189f488d336fc34979d6b928555d984a4d7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe90c189f488d336fc34979d6b928555d984a4d7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fe90c189f488d336fc34979d6b928555d984a4d7", "patch": "@@ -527,9 +527,9 @@ fn set_struct_body(t: TypeRef, elts: [TypeRef]) unsafe {\n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n \n // A vtable is, in reality, a vtable pointer followed by zero or more pointers\n-// to tydescs and other vtables that it closes over. But the types and number of\n-// those are rarely known to the code that needs to manipulate them, so they\n-// are described by this opaque type.\n+// to tydescs and other vtables that it closes over. But the types and number\n+// of those are rarely known to the code that needs to manipulate them, so\n+// they are described by this opaque type.\n fn T_vtable() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n \n fn T_task(targ_cfg: @session::config) -> TypeRef {"}]}