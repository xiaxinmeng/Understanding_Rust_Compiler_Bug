{"sha": "dc0aab47a77fbd47354dc6cf64cdb300cb6fd4b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMGFhYjQ3YTc3ZmJkNDczNTRkYzZjZjY0Y2RiMzAwY2I2ZmQ0YjM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-11T04:58:46Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-11T05:11:59Z"}, "message": "More alias-ification of trans.", "tree": {"sha": "6dd545fcb10445947daf135c4075ce0d17fd67d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dd545fcb10445947daf135c4075ce0d17fd67d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc0aab47a77fbd47354dc6cf64cdb300cb6fd4b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc0aab47a77fbd47354dc6cf64cdb300cb6fd4b3", "html_url": "https://github.com/rust-lang/rust/commit/dc0aab47a77fbd47354dc6cf64cdb300cb6fd4b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc0aab47a77fbd47354dc6cf64cdb300cb6fd4b3/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65547a314fc37c1014a9f93523b37fe9fe692998", "url": "https://api.github.com/repos/rust-lang/rust/commits/65547a314fc37c1014a9f93523b37fe9fe692998", "html_url": "https://github.com/rust-lang/rust/commit/65547a314fc37c1014a9f93523b37fe9fe692998"}], "stats": {"total": 564, "additions": 285, "deletions": 279}, "files": [{"sha": "8ff1f366a17c65dc0a61d012a181a71a8eb008c1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 285, "deletions": 279, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/dc0aab47a77fbd47354dc6cf64cdb300cb6fd4b3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc0aab47a77fbd47354dc6cf64cdb300cb6fd4b3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=dc0aab47a77fbd47354dc6cf64cdb300cb6fd4b3", "patch": "@@ -141,7 +141,7 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          @local_ctxt lcx);\n \n tag cleanup {\n-    clean(fn(@block_ctxt cx) -> result);\n+    clean(fn(&@block_ctxt cx) -> result);\n }\n \n \n@@ -174,16 +174,16 @@ fn sep() -> str {\n     ret \"_\";\n }\n \n-fn extend_path(@local_ctxt cx, str name) -> @local_ctxt {\n+fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n   ret @rec(path = cx.path + vec(name) with *cx);\n }\n \n-fn path_name(vec[str] path) -> str {\n+fn path_name(&vec[str] path) -> str {\n     ret Str.connect(path, sep());\n }\n \n \n-fn get_type_sha1(@crate_ctxt ccx, ty.t t) -> str {\n+fn get_type_sha1(&@crate_ctxt ccx, &ty.t t) -> str {\n     auto hash = \"\";\n     alt (ccx.type_sha1s.find(t)) {\n         case (some[str](?h)) { hash = h; }\n@@ -202,12 +202,12 @@ fn get_type_sha1(@crate_ctxt ccx, ty.t t) -> str {\n     ret hash;\n }\n \n-fn mangle_name_by_type(@crate_ctxt ccx, vec[str] path, ty.t t) -> str {\n+fn mangle_name_by_type(&@crate_ctxt ccx, &vec[str] path, &ty.t t) -> str {\n     auto hash = get_type_sha1(ccx, t);\n     ret sep() + \"rust\" + sep() + hash + sep() + path_name(path);\n }\n \n-fn mangle_name_by_type_only(@crate_ctxt ccx, ty.t t, str name) -> str {\n+fn mangle_name_by_type_only(&@crate_ctxt ccx, &ty.t t, &str name) -> str {\n     auto f = metadata.def_to_str;\n     auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata.ac_no_abbrevs);\n     auto s = ty.ty_to_short_str(ccx.tcx, t);\n@@ -216,7 +216,8 @@ fn mangle_name_by_type_only(@crate_ctxt ccx, ty.t t, str name) -> str {\n     ret sep() + \"rust\" + sep() + hash + sep() + name + \"_\" + s;\n }\n \n-fn mangle_name_by_seq(@crate_ctxt ccx, vec[str] path, str flav) -> str {\n+fn mangle_name_by_seq(&@crate_ctxt ccx, &vec[str] path,\n+                      &str flav) -> str {\n     ret sep() + \"rust\" + sep()\n         + ccx.names.next(flav) + sep()\n         + path_name(path);\n@@ -319,7 +320,7 @@ fn T_fn(vec[TypeRef] inputs, TypeRef output) -> TypeRef {\n                               False);\n }\n \n-fn T_fn_pair(type_names tn, TypeRef tfn) -> TypeRef {\n+fn T_fn_pair(&type_names tn, TypeRef tfn) -> TypeRef {\n     ret T_struct(vec(T_ptr(tfn),\n                      T_opaque_closure_ptr(tn)));\n }\n@@ -328,7 +329,7 @@ fn T_ptr(TypeRef t) -> TypeRef {\n     ret llvm.LLVMPointerType(t, 0u);\n }\n \n-fn T_struct(vec[TypeRef] elts) -> TypeRef {\n+fn T_struct(&vec[TypeRef] elts) -> TypeRef {\n     ret llvm.LLVMStructType(Vec.buf[TypeRef](elts),\n                             Vec.len[TypeRef](elts),\n                             False);\n@@ -338,7 +339,7 @@ fn T_opaque() -> TypeRef {\n     ret llvm.LLVMOpaqueType();\n }\n \n-fn T_task(type_names tn) -> TypeRef {\n+fn T_task(&type_names tn) -> TypeRef {\n     auto s = \"task\";\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n@@ -357,7 +358,7 @@ fn T_task(type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc_field(type_names tn, int field) -> TypeRef {\n+fn T_tydesc_field(&type_names tn, int field) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n     let vec[TypeRef] tydesc_elts =\n         Vec.init_elt[TypeRef](T_nil(), abi.n_tydesc_fields as uint);\n@@ -367,7 +368,7 @@ fn T_tydesc_field(type_names tn, int field) -> TypeRef {\n     ret t;\n }\n \n-fn T_glue_fn(type_names tn) -> TypeRef {\n+fn T_glue_fn(&type_names tn) -> TypeRef {\n     auto s = \"glue_fn\";\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n@@ -378,12 +379,12 @@ fn T_glue_fn(type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_dtor(@crate_ctxt ccx, TypeRef llself_ty) -> TypeRef {\n+fn T_dtor(&@crate_ctxt ccx, TypeRef llself_ty) -> TypeRef {\n     ret type_of_fn_full(ccx, ast.proto_fn, some[TypeRef](llself_ty),\n                         Vec.empty[ty.arg](), ty.mk_nil(ccx.tcx), 0u);\n }\n \n-fn T_cmp_glue_fn(type_names tn) -> TypeRef {\n+fn T_cmp_glue_fn(&type_names tn) -> TypeRef {\n     auto s = \"cmp_glue_fn\";\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n@@ -394,7 +395,7 @@ fn T_cmp_glue_fn(type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc(type_names tn) -> TypeRef {\n+fn T_tydesc(&type_names tn) -> TypeRef {\n \n     auto s = \"tydesc\";\n     if (tn.name_has_type(s)) {\n@@ -469,7 +470,7 @@ fn T_chan(TypeRef t) -> TypeRef {\n     ret T_struct(vec(T_int())); // Refcount\n }\n \n-fn T_crate(type_names tn) -> TypeRef {\n+fn T_crate(&type_names tn) -> TypeRef {\n     auto s = \"crate\";\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n@@ -495,12 +496,12 @@ fn T_crate(type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_taskptr(type_names tn) -> TypeRef {\n+fn T_taskptr(&type_names tn) -> TypeRef {\n     ret T_ptr(T_task(tn));\n }\n \n // This type must never be used directly; it must always be cast away.\n-fn T_typaram(type_names tn) -> TypeRef {\n+fn T_typaram(&type_names tn) -> TypeRef {\n     auto s = \"typaram\";\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n@@ -511,11 +512,11 @@ fn T_typaram(type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_typaram_ptr(type_names tn) -> TypeRef {\n+fn T_typaram_ptr(&type_names tn) -> TypeRef {\n     ret T_ptr(T_typaram(tn));\n }\n \n-fn T_closure_ptr(type_names tn,\n+fn T_closure_ptr(&type_names tn,\n                  TypeRef lltarget_ty,\n                  TypeRef llbindings_ty,\n                  uint n_ty_params) -> TypeRef {\n@@ -530,7 +531,7 @@ fn T_closure_ptr(type_names tn,\n                              )));\n }\n \n-fn T_opaque_closure_ptr(type_names tn) -> TypeRef {\n+fn T_opaque_closure_ptr(&type_names tn) -> TypeRef {\n     auto s = \"*closure\";\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n@@ -543,7 +544,7 @@ fn T_opaque_closure_ptr(type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_tag(type_names tn, uint size) -> TypeRef {\n+fn T_tag(&type_names tn, uint size) -> TypeRef {\n     auto s = \"tag_\" + UInt.to_str(size, 10u);\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n@@ -560,7 +561,7 @@ fn T_tag(type_names tn, uint size) -> TypeRef {\n     ret t;\n }\n \n-fn T_opaque_tag(type_names tn) -> TypeRef {\n+fn T_opaque_tag(&type_names tn) -> TypeRef {\n     auto s = \"opaque_tag\";\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n@@ -570,15 +571,15 @@ fn T_opaque_tag(type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_opaque_tag_ptr(type_names tn) -> TypeRef {\n+fn T_opaque_tag_ptr(&type_names tn) -> TypeRef {\n     ret T_ptr(T_opaque_tag(tn));\n }\n \n-fn T_captured_tydescs(type_names tn, uint n) -> TypeRef {\n+fn T_captured_tydescs(&type_names tn, uint n) -> TypeRef {\n     ret T_struct(Vec.init_elt[TypeRef](T_ptr(T_tydesc(tn)), n));\n }\n \n-fn T_obj_ptr(type_names tn, uint n_captured_tydescs) -> TypeRef {\n+fn T_obj_ptr(&type_names tn, uint n_captured_tydescs) -> TypeRef {\n     // This function is not publicly exposed because it returns an incomplete\n     // type. The dynamically-sized fields follow the captured tydescs.\n     fn T_obj(type_names tn, uint n_captured_tydescs) -> TypeRef {\n@@ -589,7 +590,7 @@ fn T_obj_ptr(type_names tn, uint n_captured_tydescs) -> TypeRef {\n     ret T_ptr(T_box(T_obj(tn, n_captured_tydescs)));\n }\n \n-fn T_opaque_obj_ptr(type_names tn) -> TypeRef {\n+fn T_opaque_obj_ptr(&type_names tn) -> TypeRef {\n     ret T_obj_ptr(tn, 0u);\n }\n \n@@ -602,7 +603,7 @@ fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n // return value was always meaningless in that case anyhow). Beware!\n //\n // TODO: Enforce via a predicate.\n-fn type_of(@crate_ctxt cx, ty.t t) -> TypeRef {\n+fn type_of(&@crate_ctxt cx, &ty.t t) -> TypeRef {\n     if (ty.type_has_dynamic_size(cx.tcx, t)) {\n         log_err \"type_of() called on a type with dynamic size: \" +\n             ty.ty_to_str(cx.tcx, t);\n@@ -612,7 +613,8 @@ fn type_of(@crate_ctxt cx, ty.t t) -> TypeRef {\n     ret type_of_inner(cx, t);\n }\n \n-fn type_of_explicit_args(@crate_ctxt cx, vec[ty.arg] inputs) -> vec[TypeRef] {\n+fn type_of_explicit_args(&@crate_ctxt cx,\n+                         &vec[ty.arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = vec();\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(cx.tcx, arg.ty)) {\n@@ -641,11 +643,11 @@ fn type_of_explicit_args(@crate_ctxt cx, vec[ty.arg] inputs) -> vec[TypeRef] {\n //  - new_fn_ctxt\n //  - trans_args\n \n-fn type_of_fn_full(@crate_ctxt cx,\n+fn type_of_fn_full(&@crate_ctxt cx,\n                    ast.proto proto,\n-                   Option.t[TypeRef] obj_self,\n-                   vec[ty.arg] inputs,\n-                   ty.t output,\n+                   &Option.t[TypeRef] obj_self,\n+                   &vec[ty.arg] inputs,\n+                   &ty.t output,\n                    uint ty_param_count) -> TypeRef {\n     let vec[TypeRef] atys = vec();\n \n@@ -697,18 +699,18 @@ fn type_of_fn_full(@crate_ctxt cx,\n     ret T_fn(atys, llvm.LLVMVoidType());\n }\n \n-fn type_of_fn(@crate_ctxt cx,\n+fn type_of_fn(&@crate_ctxt cx,\n               ast.proto proto,\n-              vec[ty.arg] inputs,\n-              ty.t output,\n+              &vec[ty.arg] inputs,\n+              &ty.t output,\n               uint ty_param_count) -> TypeRef {\n     ret type_of_fn_full(cx, proto, none[TypeRef], inputs, output,\n                         ty_param_count);\n }\n \n-fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n-                     vec[ty.arg] inputs,\n-                     ty.t output,\n+fn type_of_native_fn(&@crate_ctxt cx, ast.native_abi abi,\n+                     &vec[ty.arg] inputs,\n+                     &ty.t output,\n                      uint ty_param_count) -> TypeRef {\n     let vec[TypeRef] atys = vec();\n     if (abi == ast.native_abi_rust) {\n@@ -724,7 +726,7 @@ fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n     ret T_fn(atys, type_of_inner(cx, output));\n }\n \n-fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n+fn type_of_inner(&@crate_ctxt cx, &ty.t t) -> TypeRef {\n     // Check the cache.\n     if (cx.lltypes.contains_key(t)) {\n         ret cx.lltypes.get(t);\n@@ -863,7 +865,7 @@ fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n }\n \n fn type_of_ty_param_count_and_ty(@local_ctxt lcx,\n-                                 ty.ty_param_count_and_ty tpt) -> TypeRef {\n+                                 &ty.ty_param_count_and_ty tpt) -> TypeRef {\n     alt (ty.struct(lcx.ccx.tcx, tpt._1)) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             auto llfnty = type_of_fn(lcx.ccx, proto, inputs, output, tpt._0);\n@@ -880,7 +882,7 @@ fn type_of_ty_param_count_and_ty(@local_ctxt lcx,\n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n \n-fn sanitize(str s) -> str {\n+fn sanitize(&str s) -> str {\n     auto result = \"\";\n     for (u8 c in s) {\n         if (c == ('@' as u8)) {\n@@ -920,11 +922,11 @@ fn C_integral(TypeRef t, uint u, Bool sign_extend) -> ValueRef {\n     ret llvm.LLVMRustConstSmallInt(t, u, sign_extend);\n }\n \n-fn C_float(str s) -> ValueRef {\n+fn C_float(&str s) -> ValueRef {\n     ret llvm.LLVMConstRealOfString(T_float(), Str.buf(s));\n }\n \n-fn C_floating(str s, TypeRef t) -> ValueRef {\n+fn C_floating(&str s, TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstRealOfString(t, Str.buf(s));\n }\n \n@@ -951,7 +953,7 @@ fn C_u8(uint i) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-fn C_cstr(@crate_ctxt cx, str s) -> ValueRef {\n+fn C_cstr(&@crate_ctxt cx, &str s) -> ValueRef {\n     auto sc = llvm.LLVMConstString(Str.buf(s), Str.byte_len(s), False);\n     auto g = llvm.LLVMAddGlobal(cx.llmod, val_ty(sc),\n                                 Str.buf(cx.names.next(\"str\")));\n@@ -963,7 +965,7 @@ fn C_cstr(@crate_ctxt cx, str s) -> ValueRef {\n }\n \n // A rust boxed-and-length-annotated string.\n-fn C_str(@crate_ctxt cx, str s) -> ValueRef {\n+fn C_str(&@crate_ctxt cx, &str s) -> ValueRef {\n     auto len = Str.byte_len(s);\n     auto box = C_struct(vec(C_int(abi.const_refcount as int),\n                             C_int(len + 1u as int), // 'alloc'\n@@ -991,44 +993,44 @@ fn C_zero_byte_arr(uint size) -> ValueRef {\n                             Vec.len[ValueRef](elts));\n }\n \n-fn C_struct(vec[ValueRef] elts) -> ValueRef {\n+fn C_struct(&vec[ValueRef] elts) -> ValueRef {\n     ret llvm.LLVMConstStruct(Vec.buf[ValueRef](elts),\n                              Vec.len[ValueRef](elts),\n                              False);\n }\n \n-fn C_array(TypeRef ty, vec[ValueRef] elts) -> ValueRef {\n+fn C_array(TypeRef ty, &vec[ValueRef] elts) -> ValueRef {\n     ret llvm.LLVMConstArray(ty, Vec.buf[ValueRef](elts),\n                             Vec.len[ValueRef](elts));\n }\n \n-fn decl_fn(ModuleRef llmod, str name, uint cc, TypeRef llty) -> ValueRef {\n+fn decl_fn(ModuleRef llmod, &str name, uint cc, TypeRef llty) -> ValueRef {\n     let ValueRef llfn =\n         llvm.LLVMAddFunction(llmod, Str.buf(name), llty);\n     llvm.LLVMSetFunctionCallConv(llfn, cc);\n     ret llfn;\n }\n \n-fn decl_cdecl_fn(ModuleRef llmod, str name, TypeRef llty) -> ValueRef {\n+fn decl_cdecl_fn(ModuleRef llmod, &str name, TypeRef llty) -> ValueRef {\n     ret decl_fn(llmod, name, lib.llvm.LLVMCCallConv, llty);\n }\n \n-fn decl_fastcall_fn(ModuleRef llmod, str name, TypeRef llty) -> ValueRef {\n+fn decl_fastcall_fn(ModuleRef llmod, &str name, TypeRef llty) -> ValueRef {\n     ret decl_fn(llmod, name, lib.llvm.LLVMFastCallConv, llty);\n }\n \n fn decl_internal_fastcall_fn(ModuleRef llmod,\n-                            str name, TypeRef llty) -> ValueRef {\n+                            &str name, TypeRef llty) -> ValueRef {\n     auto llfn = decl_fn(llmod, name, lib.llvm.LLVMFastCallConv, llty);\n     llvm.LLVMSetLinkage(llfn, lib.llvm.LLVMInternalLinkage as llvm.Linkage);\n     ret llfn;\n }\n \n-fn decl_glue(ModuleRef llmod, type_names tn, str s) -> ValueRef {\n+fn decl_glue(ModuleRef llmod, type_names tn, &str s) -> ValueRef {\n     ret decl_cdecl_fn(llmod, s, T_fn(vec(T_taskptr(tn)), T_void()));\n }\n \n-fn decl_native_glue(ModuleRef llmod, type_names tn,\n+fn decl_native_glue(ModuleRef llmod, &type_names tn,\n                     abi.native_glue_type ngt, uint _n) -> ValueRef {\n     let bool pass_task;\n     alt (ngt) {\n@@ -1055,7 +1057,7 @@ fn decl_native_glue(ModuleRef llmod, type_names tn,\n }\n \n fn get_extern_fn(&hashmap[str, ValueRef] externs,\n-                 ModuleRef llmod, str name,\n+                 ModuleRef llmod, &str name,\n                  uint cc, TypeRef ty) -> ValueRef {\n     if (externs.contains_key(name)) {\n         ret externs.get(name);\n@@ -1066,7 +1068,7 @@ fn get_extern_fn(&hashmap[str, ValueRef] externs,\n }\n \n fn get_extern_const(&hashmap[str, ValueRef] externs,\n-                    ModuleRef llmod, str name, TypeRef ty) -> ValueRef {\n+                    ModuleRef llmod, &str name, TypeRef ty) -> ValueRef {\n     if (externs.contains_key(name)) {\n         ret externs.get(name);\n     }\n@@ -1076,17 +1078,18 @@ fn get_extern_const(&hashmap[str, ValueRef] externs,\n }\n \n fn get_simple_extern_fn(&hashmap[str, ValueRef] externs,\n-                     ModuleRef llmod, str name, int n_args) -> ValueRef {\n+                        ModuleRef llmod, &str name,\n+                        int n_args) -> ValueRef {\n     auto inputs = Vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n     auto t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib.llvm.LLVMCCallConv, t);\n }\n \n-fn trans_native_call(builder b, @glue_fns glues, ValueRef lltaskptr,\n+fn trans_native_call(&builder b, @glue_fns glues, ValueRef lltaskptr,\n                      &hashmap[str, ValueRef] externs,\n-                     type_names tn, ModuleRef llmod, str name,\n-                     bool pass_task, vec[ValueRef] args) -> ValueRef {\n+                     &type_names tn, ModuleRef llmod, &str name,\n+                     bool pass_task, &vec[ValueRef] args) -> ValueRef {\n     let int n = (Vec.len[ValueRef](args) as int);\n     let ValueRef llnative = get_simple_extern_fn(externs, llmod, name, n);\n     llnative = llvm.LLVMConstPointerCast(llnative, T_int());\n@@ -1110,14 +1113,14 @@ fn trans_native_call(builder b, @glue_fns glues, ValueRef lltaskptr,\n     ret b.FastCall(llglue, call_args);\n }\n \n-fn trans_non_gc_free(@block_ctxt cx, ValueRef v) -> result {\n+fn trans_non_gc_free(&@block_ctxt cx, ValueRef v) -> result {\n     cx.build.Call(cx.fcx.lcx.ccx.upcalls.free,\n                   vec(cx.fcx.lltaskptr,\n                       cx.build.PointerCast(v, T_ptr(T_i8())), C_int(0)));\n     ret res(cx, C_int(0));\n }\n \n-fn find_scope_cx(@block_ctxt cx) -> @block_ctxt {\n+fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n     if (cx.kind != NON_SCOPE_BLOCK) {\n         ret cx;\n     }\n@@ -1131,7 +1134,7 @@ fn find_scope_cx(@block_ctxt cx) -> @block_ctxt {\n     }\n }\n \n-fn find_outer_scope_cx(@block_ctxt cx) -> @block_ctxt {\n+fn find_outer_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n     auto scope_cx = find_scope_cx(cx);\n     alt (cx.parent) {\n         case (parent_some(?b)) {\n@@ -1143,24 +1146,24 @@ fn find_outer_scope_cx(@block_ctxt cx) -> @block_ctxt {\n     }\n }\n \n-fn umax(@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n+fn umax(&@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n     auto cond = cx.build.ICmp(lib.llvm.LLVMIntULT, a, b);\n     ret cx.build.Select(cond, b, a);\n }\n \n-fn umin(@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n+fn umin(&@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n     auto cond = cx.build.ICmp(lib.llvm.LLVMIntULT, a, b);\n     ret cx.build.Select(cond, a, b);\n }\n \n-fn align_to(@block_ctxt cx, ValueRef off, ValueRef align) -> ValueRef {\n+fn align_to(&@block_ctxt cx, ValueRef off, ValueRef align) -> ValueRef {\n     auto mask = cx.build.Sub(align, C_int(1));\n     auto bumped = cx.build.Add(off, mask);\n     ret cx.build.And(bumped, cx.build.Not(mask));\n }\n \n // Returns the real size of the given type for the current target.\n-fn llsize_of_real(@crate_ctxt cx, TypeRef t) -> uint {\n+fn llsize_of_real(&@crate_ctxt cx, TypeRef t) -> uint {\n     ret llvm.LLVMStoreSizeOfType(cx.td.lltd, t);\n }\n \n@@ -1172,25 +1175,25 @@ fn llalign_of(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntCast(lib.llvm.llvm.LLVMAlignOf(t), T_int(), False);\n }\n \n-fn size_of(@block_ctxt cx, ty.t t) -> result {\n+fn size_of(&@block_ctxt cx, &ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, llsize_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n-fn align_of(@block_ctxt cx, ty.t t) -> result {\n+fn align_of(&@block_ctxt cx, &ty.t t) -> result {\n     if (!ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, llalign_of(type_of(cx.fcx.lcx.ccx, t)));\n     }\n     ret dynamic_align_of(cx, t);\n }\n \n-fn alloca(@block_ctxt cx, TypeRef t) -> ValueRef {\n+fn alloca(&@block_ctxt cx, TypeRef t) -> ValueRef {\n     ret new_builder(cx.fcx.llallocas).Alloca(t);\n }\n \n-fn array_alloca(@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n+fn array_alloca(&@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n     ret new_builder(cx.fcx.llallocas).ArrayAlloca(t, n);\n }\n \n@@ -1199,7 +1202,7 @@ fn array_alloca(@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n // to have (a) the same size as the type that was passed in; (b) to be non-\n // recursive. This is done by replacing all boxes in a type with boxed unit\n // types.\n-fn simplify_type(@crate_ctxt ccx, ty.t typ) -> ty.t {\n+fn simplify_type(&@crate_ctxt ccx, &ty.t typ) -> ty.t {\n     fn simplifier(@crate_ctxt ccx, ty.t typ) -> ty.t {\n         alt (ty.struct(ccx.tcx, typ)) {\n             case (ty.ty_box(_)) {\n@@ -1213,7 +1216,7 @@ fn simplify_type(@crate_ctxt ccx, ty.t typ) -> ty.t {\n }\n \n // Computes the size of the data part of a non-dynamically-sized tag.\n-fn static_size_of_tag(@crate_ctxt cx, ty.t t) -> uint {\n+fn static_size_of_tag(&@crate_ctxt cx, &ty.t t) -> uint {\n     if (ty.type_has_dynamic_size(cx.tcx, t)) {\n         log_err \"dynamically sized type passed to static_size_of_tag()\";\n         fail;\n@@ -1258,8 +1261,8 @@ fn static_size_of_tag(@crate_ctxt cx, ty.t t) -> uint {\n     ret max_size;\n }\n \n-fn dynamic_size_of(@block_ctxt cx, ty.t t) -> result {\n-    fn align_elements(@block_ctxt cx, vec[ty.t] elts) -> result {\n+fn dynamic_size_of(&@block_ctxt cx, ty.t t) -> result {\n+    fn align_elements(&@block_ctxt cx, &vec[ty.t] elts) -> result {\n         //\n         // C padding rules:\n         //\n@@ -1337,7 +1340,7 @@ fn dynamic_size_of(@block_ctxt cx, ty.t t) -> result {\n     }\n }\n \n-fn dynamic_align_of(@block_ctxt cx, ty.t t) -> result {\n+fn dynamic_align_of(&@block_ctxt cx, &ty.t t) -> result {\n     alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty.ty_param(?p)) {\n             auto aptr = field_of_tydesc(cx, t, false, abi.tydesc_field_align);\n@@ -1375,8 +1378,8 @@ fn dynamic_align_of(@block_ctxt cx, ty.t t) -> result {\n // middle of the thing it's GEP'ing into. Much like size_of and align_of,\n // above.\n \n-fn GEP_tup_like(@block_ctxt cx, ty.t t,\n-                ValueRef base, vec[int] ixs) -> result {\n+fn GEP_tup_like(&@block_ctxt cx, &ty.t t,\n+                ValueRef base, &vec[int] ixs) -> result {\n \n     assert (ty.type_is_tup_like(cx.fcx.lcx.ccx.tcx, t));\n \n@@ -1407,7 +1410,7 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n     // elements of the type and splitting the Xth off. Return the prefix as\n     // well as the innermost Xth type.\n \n-    fn split_type(@crate_ctxt ccx, ty.t t, vec[int] ixs, uint n)\n+    fn split_type(&@crate_ctxt ccx, &ty.t t, &vec[int] ixs, uint n)\n         -> rec(vec[ty.t] prefix, ty.t target) {\n \n         let uint len = Vec.len[int](ixs);\n@@ -1481,7 +1484,7 @@ fn GEP_tag(@block_ctxt cx,\n            ValueRef llblobptr,\n            &ast.def_id tag_id,\n            &ast.def_id variant_id,\n-           vec[ty.t] ty_substs,\n+           &vec[ty.t] ty_substs,\n            int ix)\n         -> result {\n     auto variant = tag_variant_with_id(cx.fcx.lcx.ccx, tag_id, variant_id);\n@@ -1532,7 +1535,7 @@ fn GEP_tag(@block_ctxt cx,\n }\n \n \n-fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n+fn trans_raw_malloc(&@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n         -> result {\n     // FIXME: need a table to collect tydesc globals.\n     auto tydesc = C_null(T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn)));\n@@ -1541,7 +1544,7 @@ fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n     ret res(cx, cx.build.PointerCast(rval, llptr_ty));\n }\n \n-fn trans_malloc_boxed(@block_ctxt cx, ty.t t) -> result {\n+fn trans_malloc_boxed(&@block_ctxt cx, ty.t t) -> result {\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n     auto boxed_body = ty.mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n@@ -1558,7 +1561,7 @@ fn trans_malloc_boxed(@block_ctxt cx, ty.t t) -> result {\n // Given a type and a field index into its corresponding type descriptor,\n // returns an LLVM ValueRef of that field from the tydesc, generating the\n // tydesc if necessary.\n-fn field_of_tydesc(@block_ctxt cx, ty.t t, bool escapes, int field)\n+fn field_of_tydesc(&@block_ctxt cx, &ty.t t, bool escapes, int field)\n         -> result {\n     auto tydesc = get_tydesc(cx, t, escapes);\n     ret res(tydesc.bcx,\n@@ -1569,7 +1572,7 @@ fn field_of_tydesc(@block_ctxt cx, ty.t t, bool escapes, int field)\n // each of the ty params it uses (from the current frame) and a vector of the\n // indices of the ty params present in the type. This is used solely for\n // constructing derived tydescs.\n-fn linearize_ty_params(@block_ctxt cx, ty.t t) ->\n+fn linearize_ty_params(&@block_ctxt cx, &ty.t t) ->\n         tup(vec[uint], vec[ValueRef]) {\n     let vec[ValueRef] param_vals = vec();\n     let vec[uint] param_defs = vec();\n@@ -1606,9 +1609,11 @@ fn linearize_ty_params(@block_ctxt cx, ty.t t) ->\n     ret tup(x.defs, x.vals);\n }\n \n-fn trans_stack_local_derived_tydesc(@block_ctxt cx, ValueRef llsz,\n-        ValueRef llalign, ValueRef llroottydesc,\n-        Option.t[ValueRef] llparamtydescs) -> result {\n+fn trans_stack_local_derived_tydesc(&@block_ctxt cx, ValueRef llsz,\n+                                    ValueRef llalign,\n+                                    ValueRef llroottydesc,\n+                                    &Option.t[ValueRef] llparamtydescs)\n+    -> result {\n     auto llmyroottydesc = alloca(cx, T_tydesc(cx.fcx.lcx.ccx.tn));\n \n     // By convention, desc 0 is the root descriptor.\n@@ -1640,7 +1645,7 @@ fn trans_stack_local_derived_tydesc(@block_ctxt cx, ValueRef llsz,\n     ret res(cx, llmyroottydesc);\n }\n \n-fn mk_derived_tydesc(@block_ctxt cx, ty.t t, bool escapes) -> result {\n+fn mk_derived_tydesc(&@block_ctxt cx, &ty.t t, bool escapes) -> result {\n     let uint n_params = ty.count_ty_params(cx.fcx.lcx.ccx.tcx, t);\n     auto tys = linearize_ty_params(cx, t);\n \n@@ -1706,7 +1711,7 @@ fn mk_derived_tydesc(@block_ctxt cx, ty.t t, bool escapes) -> result {\n     ret v;\n }\n \n-fn get_tydesc(&@block_ctxt cx, ty.t t, bool escapes) -> result {\n+fn get_tydesc(&@block_ctxt cx, &ty.t t, bool escapes) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt (ty.type_param(cx.fcx.lcx.ccx.tcx, t)) {\n         case (some[uint](?id)) { ret res(cx, cx.fcx.lltydescs.(id)); }\n@@ -1726,7 +1731,7 @@ fn get_tydesc(&@block_ctxt cx, ty.t t, bool escapes) -> result {\n }\n \n fn get_static_tydesc(&@block_ctxt cx,\n-                     ty.t t, vec[uint] ty_params) -> @tydesc_info {\n+                     &ty.t t, &vec[uint] ty_params) -> @tydesc_info {\n     alt (cx.fcx.lcx.ccx.tydescs.find(t)) {\n         case (some[@tydesc_info](?info)) {\n             ret info;\n@@ -1759,7 +1764,7 @@ fn get_static_tydesc(&@block_ctxt cx,\n // Generates the declaration for (but doesn't fill in) a type descriptor. This\n // needs to be separate from make_tydesc() below, because sometimes type glue\n // functions needs to refer to their own type descriptors.\n-fn declare_tydesc(@local_ctxt cx, ty.t t) -> @tydesc_info {\n+fn declare_tydesc(&@local_ctxt cx, &ty.t t) -> @tydesc_info {\n     auto take_glue = declare_generic_glue(cx, t, T_glue_fn(cx.ccx.tn),\n                                           \"take\");\n     auto drop_glue = declare_generic_glue(cx, t, T_glue_fn(cx.ccx.tn),\n@@ -1821,12 +1826,12 @@ fn declare_tydesc(@local_ctxt cx, ty.t t) -> @tydesc_info {\n }\n \n tag make_generic_glue_helper_fn {\n-    mgghf_single(fn(@block_ctxt cx, ValueRef v, ty.t t));\n+    mgghf_single(fn(&@block_ctxt cx, ValueRef v, &ty.t t));\n     mgghf_cmp;\n }\n \n // declare_tydesc() above must have been called first.\n-fn define_tydesc(@local_ctxt cx, ty.t t, vec[uint] ty_params) {\n+fn define_tydesc(&@local_ctxt cx, &ty.t t, &vec[uint] ty_params) {\n     auto info = cx.ccx.tydescs.get(t);\n     auto gvar = info.tydesc;\n \n@@ -1837,10 +1842,10 @@ fn define_tydesc(@local_ctxt cx, ty.t t, vec[uint] ty_params) {\n     make_generic_glue(cx, t, info.cmp_glue, mgghf_cmp, ty_params);\n }\n \n-fn declare_generic_glue(@local_ctxt cx,\n-                        ty.t t,\n+fn declare_generic_glue(&@local_ctxt cx,\n+                        &ty.t t,\n                         TypeRef llfnty,\n-                        str name) -> ValueRef {\n+                        &str name) -> ValueRef {\n     auto fn_nm;\n     if (cx.ccx.sess.get_opts().debuginfo) {\n         fn_nm = mangle_name_by_type_only(cx.ccx, t, \"glue_\" + name);\n@@ -1852,11 +1857,11 @@ fn declare_generic_glue(@local_ctxt cx,\n     ret llfn;\n }\n \n-fn make_generic_glue(@local_ctxt cx,\n-                     ty.t t,\n+fn make_generic_glue(&@local_ctxt cx,\n+                     &ty.t t,\n                      ValueRef llfn,\n-                     make_generic_glue_helper_fn helper,\n-                     vec[uint] ty_params) -> ValueRef {\n+                     &make_generic_glue_helper_fn helper,\n+                     &vec[uint] ty_params) -> ValueRef {\n     auto fcx = new_fn_ctxt(cx, llfn);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n@@ -1911,7 +1916,7 @@ fn make_generic_glue(@local_ctxt cx,\n     ret llfn;\n }\n \n-fn make_take_glue(@block_ctxt cx, ValueRef v, ty.t t) {\n+fn make_take_glue(&@block_ctxt cx, ValueRef v, &ty.t t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     auto bcx;\n     if (ty.type_is_boxed(cx.fcx.lcx.ccx.tcx, t)) {\n@@ -1926,7 +1931,7 @@ fn make_take_glue(@block_ctxt cx, ValueRef v, ty.t t) {\n     bcx.build.RetVoid();\n }\n \n-fn incr_refcnt_of_boxed(@block_ctxt cx, ValueRef box_ptr) -> result {\n+fn incr_refcnt_of_boxed(&@block_ctxt cx, ValueRef box_ptr) -> result {\n     auto rc_ptr = cx.build.GEP(box_ptr, vec(C_int(0),\n                                             C_int(abi.box_rc_field_refcnt)));\n     auto rc = cx.build.Load(rc_ptr);\n@@ -1945,7 +1950,7 @@ fn incr_refcnt_of_boxed(@block_ctxt cx, ValueRef box_ptr) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n+fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty.t t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     auto rslt;\n     alt (ty.struct(cx.fcx.lcx.ccx.tcx, t)) {\n@@ -1958,7 +1963,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         }\n \n         case (ty.ty_vec(_)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v,\n+            fn hit_zero(&@block_ctxt cx, ValueRef v,\n                         ty.t t) -> result {\n                 auto res = iter_sequence(cx, v, t,\n                                          bind drop_ty(_,_,_));\n@@ -1973,7 +1978,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         }\n \n         case (ty.ty_box(?body_mt)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v,\n+            fn hit_zero(&@block_ctxt cx, ValueRef v,\n                         ty.t body_ty) -> result {\n                 auto body = cx.build.GEP(v,\n                                          vec(C_int(0),\n@@ -1992,7 +1997,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         }\n \n         case (ty.ty_port(_)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n+            fn hit_zero(&@block_ctxt cx, ValueRef v) -> result {\n                 cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_port,\n                     vec(cx.fcx.lltaskptr,\n                         cx.build.PointerCast(v, T_opaque_port_ptr())));\n@@ -2006,7 +2011,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         }\n \n         case (ty.ty_chan(_)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n+            fn hit_zero(&@block_ctxt cx, ValueRef v) -> result {\n                 cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_chan,\n                     vec(cx.fcx.lltaskptr,\n                         cx.build.PointerCast(v, T_opaque_chan_ptr())));\n@@ -2020,7 +2025,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         }\n \n         case (ty.ty_obj(_)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef b, ValueRef o) -> result {\n+            fn hit_zero(&@block_ctxt cx, ValueRef b, ValueRef o) -> result {\n                 auto body =\n                     cx.build.GEP(b,\n                                  vec(C_int(0),\n@@ -2055,7 +2060,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         }\n \n         case (ty.ty_fn(_,_,_)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n+            fn hit_zero(&@block_ctxt cx, ValueRef v) -> result {\n \n                 // Call through the closure's own fields-drop glue first.\n                 auto body =\n@@ -2111,10 +2116,10 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n     rslt.bcx.build.RetVoid();\n }\n \n-fn decr_refcnt_and_if_zero(@block_ctxt cx,\n+fn decr_refcnt_and_if_zero(&@block_ctxt cx,\n                            ValueRef box_ptr,\n-                           fn(@block_ctxt cx) -> result inner,\n-                           str inner_name,\n+                           &fn(&@block_ctxt cx) -> result inner,\n+                           &str inner_name,\n                            TypeRef t_else, ValueRef v_else) -> result {\n \n     auto load_rc_cx = new_sub_block_ctxt(cx, \"load rc\");\n@@ -2156,16 +2161,16 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n \n // Structural comparison: a rather involved form of glue.\n \n-fn maybe_name_value(&@crate_ctxt cx, ValueRef v, str s) {\n+fn maybe_name_value(&@crate_ctxt cx, ValueRef v, &str s) {\n     if (cx.sess.get_opts().save_temps) {\n         llvm.LLVMSetValueName(v, Str.buf(s));\n     }\n }\n \n-fn make_cmp_glue(@block_ctxt cx,\n+fn make_cmp_glue(&@block_ctxt cx,\n                  ValueRef lhs0,\n                  ValueRef rhs0,\n-                 ty.t t,\n+                 &ty.t t,\n                  ValueRef llop) {\n     auto lhs = load_if_immediate(cx, lhs0, t);\n     auto rhs = load_if_immediate(cx, rhs0, t);\n@@ -2240,7 +2245,7 @@ fn make_cmp_glue(@block_ctxt cx,\n                  bool load_inner,\n                  ValueRef flag,\n                  ValueRef llop,\n-                 @block_ctxt cx,\n+                 &@block_ctxt cx,\n                  ValueRef av0,\n                  ValueRef bv0,\n                  ty.t t) -> result {\n@@ -2310,8 +2315,8 @@ fn make_cmp_glue(@block_ctxt cx,\n }\n \n // A helper function to create scalar comparison glue.\n-fn make_scalar_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n-                        ValueRef llop) {\n+fn make_scalar_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n+                        &ty.t t, ValueRef llop) {\n     if (ty.type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n         make_fp_cmp_glue(cx, lhs, rhs, t, llop);\n         ret;\n@@ -2335,8 +2340,8 @@ fn make_scalar_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t t,\n }\n \n // A helper function to create floating point comparison glue.\n-fn make_fp_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t fptype,\n-                    ValueRef llop) {\n+fn make_fp_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n+                    &ty.t fptype, ValueRef llop) {\n     auto last_cx = new_sub_block_ctxt(cx, \"last\");\n \n     auto eq_cx = new_sub_block_ctxt(cx, \"eq\");\n@@ -2368,7 +2373,7 @@ fn make_fp_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, ty.t fptype,\n \n // A helper function to compare integral values. This is used by both\n // `make_integral_cmp_glue` and `make_cmp_glue`.\n-fn compare_integral_values(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n+fn compare_integral_values(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n                            bool signed, ValueRef llop) -> result {\n     auto lt_cmp; auto le_cmp;\n     if (signed) {\n@@ -2408,8 +2413,8 @@ fn compare_integral_values(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n }\n \n // A helper function to create integral comparison glue.\n-fn make_integral_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n-                          ty.t intype, ValueRef llop) {\n+fn make_integral_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n+                          &ty.t intype, ValueRef llop) {\n     auto r = compare_integral_values(cx, lhs, rhs,\n         ty.type_is_signed(cx.fcx.lcx.ccx.tcx, intype), llop);\n     r.bcx.build.Store(r.val, r.bcx.fcx.llretptr);\n@@ -2422,7 +2427,7 @@ fn make_integral_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n type variant_info = rec(vec[ty.t] args, ty.t ctor_ty, ast.def_id id);\n \n // Returns information about the variants in a tag.\n-fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n+fn tag_variants(&@crate_ctxt cx, &ast.def_id id) -> vec[variant_info] {\n     if (cx.sess.get_targ_crate_num() != id._0) {\n         ret creader.get_tag_variants(cx.sess, cx.tcx, id);\n     }\n@@ -2449,7 +2454,7 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n }\n \n // Returns information about the tag variant with the given ID.\n-fn tag_variant_with_id(@crate_ctxt cx,\n+fn tag_variant_with_id(&@crate_ctxt cx,\n                        &ast.def_id tag_id,\n                        &ast.def_id variant_id) -> variant_info {\n     auto variants = tag_variants(cx, tag_id);\n@@ -2468,21 +2473,21 @@ fn tag_variant_with_id(@crate_ctxt cx,\n }\n \n \n-type val_pair_fn = fn(@block_ctxt cx, ValueRef dst, ValueRef src) -> result;\n+type val_pair_fn = fn(&@block_ctxt cx, ValueRef dst, ValueRef src) -> result;\n \n-type val_and_ty_fn = fn(@block_ctxt cx, ValueRef v, ty.t t) -> result;\n+type val_and_ty_fn = fn(&@block_ctxt cx, ValueRef v, ty.t t) -> result;\n \n type val_pair_and_ty_fn =\n-    fn(@block_ctxt cx, ValueRef av, ValueRef bv, ty.t t) -> result;\n+    fn(&@block_ctxt cx, ValueRef av, ValueRef bv, ty.t t) -> result;\n \n // Iterates through the elements of a structural type.\n-fn iter_structural_ty(@block_ctxt cx,\n+fn iter_structural_ty(&@block_ctxt cx,\n                       ValueRef v,\n-                      ty.t t,\n+                      &ty.t t,\n                       val_and_ty_fn f)\n     -> result {\n     fn adaptor_fn(val_and_ty_fn f,\n-                  @block_ctxt cx,\n+                  &@block_ctxt cx,\n                   ValueRef av,\n                   ValueRef bv,\n                   ty.t t) -> result {\n@@ -2493,18 +2498,18 @@ fn iter_structural_ty(@block_ctxt cx,\n }\n \n \n-fn iter_structural_ty_full(@block_ctxt cx,\n+fn iter_structural_ty_full(&@block_ctxt cx,\n                            ValueRef av,\n                            ValueRef bv,\n-                           ty.t t,\n-                           val_pair_and_ty_fn f)\n+                           &ty.t t,\n+                           &val_pair_and_ty_fn f)\n     -> result {\n     let result r = res(cx, C_nil());\n \n     fn iter_boxpp(@block_ctxt cx,\n                   ValueRef box_a_cell,\n                   ValueRef box_b_cell,\n-                  val_pair_and_ty_fn f) -> result {\n+                  &val_pair_and_ty_fn f) -> result {\n         auto box_a_ptr = cx.build.Load(box_a_cell);\n         auto box_b_ptr = cx.build.Load(box_b_cell);\n         auto tnil = ty.mk_nil(cx.fcx.lcx.ccx.tcx);\n@@ -2680,7 +2685,7 @@ fn iter_sequence_raw(@block_ctxt cx,\n                      ValueRef src,     // elt*\n                      ValueRef src_lim, // elt*\n                      ValueRef elt_sz,\n-                     val_pair_fn f) -> result {\n+                     &val_pair_fn f) -> result {\n \n     auto bcx = cx;\n \n@@ -2723,14 +2728,14 @@ fn iter_sequence_raw(@block_ctxt cx,\n }\n \n \n-fn iter_sequence_inner(@block_ctxt cx,\n+fn iter_sequence_inner(&@block_ctxt cx,\n                        ValueRef src,     // elt*\n                        ValueRef src_lim, // elt*\n-                       ty.t elt_ty,\n-                       val_and_ty_fn f) -> result {\n+                       &ty.t elt_ty,\n+                       &val_and_ty_fn f) -> result {\n     fn adaptor_fn(val_and_ty_fn f,\n                   ty.t elt_ty,\n-                  @block_ctxt cx,\n+                  &@block_ctxt cx,\n                   ValueRef dst,\n                   ValueRef src) -> result {\n         auto llptrty;\n@@ -2754,13 +2759,13 @@ fn iter_sequence_inner(@block_ctxt cx,\n // Iterates through the elements of a vec or str.\n fn iter_sequence(@block_ctxt cx,\n                  ValueRef v,\n-                 ty.t t,\n-                 val_and_ty_fn f) -> result {\n+                 &ty.t t,\n+                 &val_and_ty_fn f) -> result {\n \n     fn iter_sequence_body(@block_ctxt cx,\n                           ValueRef v,\n-                          ty.t elt_ty,\n-                          val_and_ty_fn f,\n+                          &ty.t elt_ty,\n+                          &val_and_ty_fn f,\n                           bool trailing_null) -> result {\n \n         auto p0 = cx.build.GEP(v, vec(C_int(0),\n@@ -2804,7 +2809,7 @@ fn iter_sequence(@block_ctxt cx,\n     fail;\n }\n \n-fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n+fn call_tydesc_glue_full(&@block_ctxt cx, ValueRef v,\n                          ValueRef tydesc, int field) {\n     auto llrawptr = cx.build.BitCast(v, T_ptr(T_i8()));\n     auto lltydescs = cx.build.GEP(tydesc,\n@@ -2821,16 +2826,16 @@ fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n                                 llrawptr));\n }\n \n-fn call_tydesc_glue(@block_ctxt cx, ValueRef v,\n-                    ty.t t, bool escapes, int field) -> result {\n+fn call_tydesc_glue(&@block_ctxt cx, ValueRef v,\n+                    &ty.t t, bool escapes, int field) -> result {\n     auto td = get_tydesc(cx, t, escapes);\n     call_tydesc_glue_full(td.bcx,\n                           spill_if_immediate(td.bcx, v, t),\n                           td.val, field);\n     ret res(td.bcx, C_nil());\n }\n \n-fn maybe_call_dtor(@block_ctxt cx, ValueRef v) -> @block_ctxt {\n+fn maybe_call_dtor(&@block_ctxt cx, ValueRef v) -> @block_ctxt {\n     auto vtbl = cx.build.GEP(v, vec(C_int(0), C_int(abi.obj_field_vtbl)));\n     vtbl = cx.build.Load(vtbl);\n     auto dtor_ptr = cx.build.GEP(vtbl, vec(C_int(0), C_int(0)));\n@@ -2852,10 +2857,10 @@ fn maybe_call_dtor(@block_ctxt cx, ValueRef v) -> @block_ctxt {\n     ret after_cx;\n }\n \n-fn call_cmp_glue(@block_ctxt cx,\n+fn call_cmp_glue(&@block_ctxt cx,\n                  ValueRef lhs,\n                  ValueRef rhs,\n-                 ty.t t,\n+                 &ty.t t,\n                  ValueRef llop) -> result {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n     // glue has a special signature.\n@@ -2891,16 +2896,16 @@ fn call_cmp_glue(@block_ctxt cx,\n     ret res(r.bcx, r.bcx.build.Load(llcmpresultptr));\n }\n \n-fn take_ty(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n+fn take_ty(&@block_ctxt cx, ValueRef v, ty.t t) -> result {\n     if (!ty.type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n         ret call_tydesc_glue(cx, v, t, false, abi.tydesc_field_take_glue);\n     }\n     ret res(cx, C_nil());\n }\n \n-fn drop_slot(@block_ctxt cx,\n+fn drop_slot(&@block_ctxt cx,\n              ValueRef slot,\n-             ty.t t) -> result {\n+             &ty.t t) -> result {\n     auto llptr = load_if_immediate(cx, slot, t);\n     auto re = drop_ty(cx, llptr, t);\n \n@@ -2910,7 +2915,7 @@ fn drop_slot(@block_ctxt cx,\n     ret re;\n }\n \n-fn drop_ty(@block_ctxt cx,\n+fn drop_ty(&@block_ctxt cx,\n            ValueRef v,\n            ty.t t) -> result {\n \n@@ -2920,11 +2925,11 @@ fn drop_ty(@block_ctxt cx,\n     ret res(cx, C_nil());\n }\n \n-fn call_memmove(@block_ctxt cx,\n-               ValueRef dst,\n-               ValueRef src,\n-               ValueRef n_bytes,\n-               ValueRef align_bytes) -> result {\n+fn call_memmove(&@block_ctxt cx,\n+                ValueRef dst,\n+                ValueRef src,\n+                ValueRef n_bytes,\n+                ValueRef align_bytes) -> result {\n     // FIXME: switch to the 64-bit variant when on such a platform.\n     auto i = cx.fcx.lcx.ccx.intrinsics;\n     assert (i.contains_key(\"llvm.memmove.p0i8.p0i8.i32\"));\n@@ -2944,7 +2949,7 @@ fn call_memmove(@block_ctxt cx,\n                                   size, align, volatile)));\n }\n \n-fn call_bzero(@block_ctxt cx,\n+fn call_bzero(&@block_ctxt cx,\n               ValueRef dst,\n               ValueRef n_bytes,\n               ValueRef align_bytes) -> result {\n@@ -2967,10 +2972,10 @@ fn call_bzero(@block_ctxt cx,\n                                   size, align, volatile)));\n }\n \n-fn memmove_ty(@block_ctxt cx,\n-             ValueRef dst,\n-             ValueRef src,\n-             ty.t t) -> result {\n+fn memmove_ty(&@block_ctxt cx,\n+              ValueRef dst,\n+              ValueRef src,\n+              &ty.t t) -> result {\n     if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         auto llsz = size_of(cx, t);\n         auto llalign = align_of(llsz.bcx, t);\n@@ -2986,11 +2991,11 @@ tag copy_action {\n     DROP_EXISTING;\n }\n \n-fn copy_ty(@block_ctxt cx,\n+fn copy_ty(&@block_ctxt cx,\n            copy_action action,\n            ValueRef dst,\n            ValueRef src,\n-           ty.t t) -> result {\n+           &ty.t t) -> result {\n     if (ty.type_is_scalar(cx.fcx.lcx.ccx.tcx, t) ||\n             ty.type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, cx.build.Store(src, dst));\n@@ -3019,7 +3024,7 @@ fn copy_ty(@block_ctxt cx,\n     fail;\n }\n \n-fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n+fn trans_lit(&@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n     alt (lit.node) {\n         case (ast.lit_int(?i)) {\n             ret C_int(i);\n@@ -3072,7 +3077,7 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n     }\n }\n \n-fn target_type(@crate_ctxt cx, ty.t t) -> ty.t {\n+fn target_type(&@crate_ctxt cx, &ty.t t) -> ty.t {\n     alt (ty.struct(cx.tcx, t)) {\n         case (ty.ty_int) {\n             auto struct_ty = ty.mk_mach(cx.tcx,\n@@ -3091,7 +3096,7 @@ fn target_type(@crate_ctxt cx, ty.t t) -> ty.t {\n \n \n // Converts an annotation to a type\n-fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> ty.t {\n+fn node_ann_type(&@crate_ctxt cx, &ast.ann a) -> ty.t {\n     ret target_type(cx, ty.ann_to_monotype(cx.tcx, a));\n }\n \n@@ -3113,12 +3118,12 @@ fn node_ann_ty_params(&ast.ann a) -> vec[ty.t] {\n     }\n }\n \n-fn node_type(@crate_ctxt cx, &ast.ann a) -> TypeRef {\n+fn node_type(&@crate_ctxt cx, &ast.ann a) -> TypeRef {\n     ret type_of(cx, node_ann_type(cx, a));\n }\n \n fn trans_unary(&@block_ctxt cx, ast.unop op,\n-               @ast.expr e, &ast.ann a) -> result {\n+               &@ast.expr e, &ast.ann a) -> result {\n \n     auto sub = trans_expr(cx, e);\n     auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, e);\n@@ -3181,7 +3186,7 @@ fn trans_unary(&@block_ctxt cx, ast.unop op,\n     fail;\n }\n \n-fn trans_compare(&@block_ctxt cx0, ast.binop op, ty.t t0,\n+fn trans_compare(&@block_ctxt cx0, ast.binop op, &ty.t t0,\n                  ValueRef lhs0, ValueRef rhs0) -> result {\n     // Autoderef both sides.\n     auto cx = cx0;\n@@ -3222,7 +3227,7 @@ fn trans_compare(&@block_ctxt cx0, ast.binop op, ty.t t0,\n     }\n }\n \n-fn trans_vec_append(&@block_ctxt cx, ty.t t,\n+fn trans_vec_append(&@block_ctxt cx, &ty.t t,\n                     ValueRef lhs, ValueRef rhs) -> result {\n \n     auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n@@ -3251,7 +3256,7 @@ fn trans_vec_append(&@block_ctxt cx, ty.t t,\n                                         dst, src, skip_null)));\n }\n \n-fn trans_vec_add(&@block_ctxt cx, ty.t t,\n+fn trans_vec_add(&@block_ctxt cx, &ty.t t,\n                  ValueRef lhs, ValueRef rhs) -> result {\n     auto r = alloc_ty(cx, t);\n     auto tmp = r.val;\n@@ -3264,7 +3269,7 @@ fn trans_vec_add(&@block_ctxt cx, ty.t t,\n }\n \n \n-fn trans_eager_binop(&@block_ctxt cx, ast.binop op, ty.t intype,\n+fn trans_eager_binop(&@block_ctxt cx, ast.binop op, &ty.t intype,\n                      ValueRef lhs, ValueRef rhs) -> result {\n \n     auto is_float = false;\n@@ -3341,7 +3346,7 @@ fn trans_eager_binop(&@block_ctxt cx, ast.binop op, ty.t intype,\n     fail;\n }\n \n-fn autoderef(&@block_ctxt cx, ValueRef v, ty.t t) -> result {\n+fn autoderef(&@block_ctxt cx, ValueRef v, &ty.t t) -> result {\n     let ValueRef v1 = v;\n     let ty.t t1 = t;\n \n@@ -3373,7 +3378,7 @@ fn autoderef(&@block_ctxt cx, ValueRef v, ty.t t) -> result {\n     }\n }\n \n-fn autoderefed_ty(@crate_ctxt ccx, ty.t t) -> ty.t {\n+fn autoderefed_ty(&@crate_ctxt ccx, &ty.t t) -> ty.t {\n     let ty.t t1 = t;\n \n     while (true) {\n@@ -3389,7 +3394,7 @@ fn autoderefed_ty(@crate_ctxt ccx, ty.t t) -> ty.t {\n }\n \n fn trans_binary(&@block_ctxt cx, ast.binop op,\n-                @ast.expr a, @ast.expr b) -> result {\n+                &@ast.expr a, &@ast.expr b) -> result {\n \n     // First couple cases are lazy:\n \n@@ -3455,7 +3460,7 @@ fn trans_binary(&@block_ctxt cx, ast.binop op,\n \n fn join_results(&@block_ctxt parent_cx,\n                 TypeRef t,\n-                vec[result] ins)\n+                &vec[result] ins)\n     -> result {\n \n     let vec[result] live = vec();\n@@ -3491,7 +3496,7 @@ fn join_results(&@block_ctxt parent_cx,\n     ret res(join_cx, phi);\n }\n \n-fn trans_if(&@block_ctxt cx, @ast.expr cond,\n+fn trans_if(&@block_ctxt cx, &@ast.expr cond,\n             &ast.block thn, &Option.t[@ast.expr] els) -> result {\n \n     auto cond_res = trans_expr(cx, cond);\n@@ -3546,10 +3551,10 @@ fn trans_if(&@block_ctxt cx, @ast.expr cond,\n }\n \n fn trans_for(&@block_ctxt cx,\n-             @ast.decl decl,\n-             @ast.expr seq,\n+             &@ast.decl decl,\n+             &@ast.expr seq,\n              &ast.block body) -> result {\n-    fn inner(@block_ctxt cx,\n+    fn inner(&@block_ctxt cx,\n              @ast.local local, ValueRef curr,\n              ty.t t, ast.block body,\n              @block_ctxt outer_next_cx) -> result {\n@@ -3649,8 +3654,8 @@ fn collect_upvars(&@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n }\n \n fn trans_for_each(&@block_ctxt cx,\n-                  @ast.decl decl,\n-                  @ast.expr seq,\n+                  &@ast.decl decl,\n+                  &@ast.expr seq,\n                   &ast.block body) -> result {\n     /*\n      * The translation is a little .. complex here. Code like:\n@@ -3855,7 +3860,7 @@ fn trans_for_each(&@block_ctxt cx,\n }\n \n \n-fn trans_while(&@block_ctxt cx, @ast.expr cond,\n+fn trans_while(&@block_ctxt cx, &@ast.expr cond,\n                &ast.block body) -> result {\n \n     auto cond_cx = new_scope_block_ctxt(cx, \"while cond\");\n@@ -3876,7 +3881,7 @@ fn trans_while(&@block_ctxt cx, @ast.expr cond,\n }\n \n fn trans_do_while(&@block_ctxt cx, &ast.block body,\n-                  @ast.expr cond) -> result {\n+                  &@ast.expr cond) -> result {\n \n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n     auto body_cx = new_loop_scope_block_ctxt(cx, Option.none[@block_ctxt],\n@@ -3894,7 +3899,7 @@ fn trans_do_while(&@block_ctxt cx, &ast.block body,\n \n // Pattern matching translation\n \n-fn trans_pat_match(&@block_ctxt cx, @ast.pat pat, ValueRef llval,\n+fn trans_pat_match(&@block_ctxt cx, &@ast.pat pat, ValueRef llval,\n                    &@block_ctxt next_cx) -> result {\n     alt (pat.node) {\n         case (ast.pat_wild(_)) { ret res(cx, llval); }\n@@ -3968,7 +3973,7 @@ fn trans_pat_match(&@block_ctxt cx, @ast.pat pat, ValueRef llval,\n     fail;\n }\n \n-fn trans_pat_binding(&@block_ctxt cx, @ast.pat pat,\n+fn trans_pat_binding(&@block_ctxt cx, &@ast.pat pat,\n                      ValueRef llval, bool bind_alias)\n     -> result {\n     alt (pat.node) {\n@@ -4019,8 +4024,8 @@ fn trans_pat_binding(&@block_ctxt cx, @ast.pat pat,\n     }\n }\n \n-fn trans_alt(&@block_ctxt cx, @ast.expr expr,\n-             vec[ast.arm] arms, ast.ann ann) -> result {\n+fn trans_alt(&@block_ctxt cx, &@ast.expr expr,\n+             &vec[ast.arm] arms, &ast.ann ann) -> result {\n     auto expr_res = trans_expr(cx, expr);\n \n     auto this_cx = expr_res.bcx;\n@@ -4086,8 +4091,8 @@ fn lval_val(&@block_ctxt cx, ValueRef val) -> lval_result {\n             method_ty=none[ty.t]);\n }\n \n-fn trans_external_path(&@block_ctxt cx, ast.def_id did,\n-                       ty.ty_param_count_and_ty tpt) -> lval_result {\n+fn trans_external_path(&@block_ctxt cx, &ast.def_id did,\n+                       &ty.ty_param_count_and_ty tpt) -> lval_result {\n     auto lcx = cx.fcx.lcx;\n     auto name = creader.get_symbol(lcx.ccx.sess, did);\n     auto v = get_extern_const(lcx.ccx.externs, lcx.ccx.llmod,\n@@ -4096,8 +4101,8 @@ fn trans_external_path(&@block_ctxt cx, ast.def_id did,\n }\n \n fn lval_generic_fn(&@block_ctxt cx,\n-                   ty.ty_param_count_and_ty tpt,\n-                   ast.def_id fn_id,\n+                   &ty.ty_param_count_and_ty tpt,\n+                   &ast.def_id fn_id,\n                    &ast.ann ann)\n         -> lval_result {\n     auto lv;\n@@ -4141,7 +4146,7 @@ fn lval_generic_fn(&@block_ctxt cx,\n     ret lv;\n }\n \n-fn lookup_discriminant(@local_ctxt lcx, ast.def_id tid, ast.def_id vid)\n+fn lookup_discriminant(&@local_ctxt lcx, &ast.def_id tid, &ast.def_id vid)\n         -> ValueRef {\n     alt (lcx.ccx.discrims.find(vid)) {\n         case (none[ValueRef]) {\n@@ -4265,7 +4270,7 @@ fn trans_path(&@block_ctxt cx, &ast.path p, &Option.t[ast.def] dopt,\n     fail;\n }\n \n-fn trans_field(&@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n+fn trans_field(&@block_ctxt cx, &ast.span sp, ValueRef v, &ty.t t0,\n                &ast.ident field, &ast.ann ann) -> lval_result {\n \n     auto r = autoderef(cx, v, t0);\n@@ -4306,8 +4311,8 @@ fn trans_field(&@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n     fail;\n }\n \n-fn trans_index(&@block_ctxt cx, &ast.span sp, @ast.expr base,\n-               @ast.expr idx, &ast.ann ann) -> lval_result {\n+fn trans_index(&@block_ctxt cx, &ast.span sp, &@ast.expr base,\n+               &@ast.expr idx, &ast.ann ann) -> lval_result {\n \n     auto lv = trans_expr(cx, base);\n     lv = autoderef(lv.bcx, lv.val, ty.expr_ty(cx.fcx.lcx.ccx.tcx, base));\n@@ -4369,7 +4374,7 @@ fn trans_index(&@block_ctxt cx, &ast.span sp, @ast.expr base,\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n \n-fn trans_lval(&@block_ctxt cx, @ast.expr e) -> lval_result {\n+fn trans_lval(&@block_ctxt cx, &@ast.expr e) -> lval_result {\n     alt (e.node) {\n         case (ast.expr_path(?p, ?dopt, ?ann)) {\n             ret trans_path(cx, p, dopt, ann);\n@@ -4429,7 +4434,7 @@ fn int_cast(&@block_ctxt bcx, TypeRef lldsttype, TypeRef llsrctype,\n     ret bcx.build.TruncOrBitCast(llsrc, lldsttype);\n }\n \n-fn trans_cast(&@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n+fn trans_cast(&@block_ctxt cx, &@ast.expr e, &ast.ann ann) -> result {\n     auto e_res = trans_expr(cx, e);\n     auto llsrctype = val_ty(e_res.val);\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n@@ -4451,12 +4456,12 @@ fn trans_cast(&@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     ret e_res;\n }\n \n-fn trans_bind_thunk(@local_ctxt cx,\n-                    ty.t incoming_fty,\n-                    ty.t outgoing_fty,\n-                    vec[Option.t[@ast.expr]] args,\n-                    ty.t closure_ty,\n-                    vec[ty.t] bound_tys,\n+fn trans_bind_thunk(&@local_ctxt cx,\n+                    &ty.t incoming_fty,\n+                    &ty.t outgoing_fty,\n+                    &vec[Option.t[@ast.expr]] args,\n+                    &ty.t closure_ty,\n+                    &vec[ty.t] bound_tys,\n                     uint ty_param_count) -> ValueRef {\n     // Construct a thunk-call with signature incoming_fty, and that copies\n     // args forward into a call to outgoing_fty.\n@@ -4600,8 +4605,8 @@ fn trans_bind_thunk(@local_ctxt cx,\n     ret llthunk;\n }\n \n-fn trans_bind(&@block_ctxt cx, @ast.expr f,\n-              vec[Option.t[@ast.expr]] args,\n+fn trans_bind(&@block_ctxt cx, &@ast.expr f,\n+              &vec[Option.t[@ast.expr]] args,\n               &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     if (f_res.is_mem) {\n@@ -4789,9 +4794,9 @@ fn trans_bind(&@block_ctxt cx, @ast.expr f,\n }\n \n fn trans_arg_expr(&@block_ctxt cx,\n-                  ty.arg arg,\n+                  &ty.arg arg,\n                   TypeRef lldestty0,\n-                  @ast.expr e) -> result {\n+                  &@ast.expr e) -> result {\n \n     auto val;\n     auto bcx = cx;\n@@ -4863,11 +4868,11 @@ fn trans_arg_expr(&@block_ctxt cx,\n \n fn trans_args(&@block_ctxt cx,\n               ValueRef llenv,\n-              Option.t[ValueRef] llobj,\n-              Option.t[generic_info] gen,\n-              Option.t[ValueRef] lliterbody,\n+              &Option.t[ValueRef] llobj,\n+              &Option.t[generic_info] gen,\n+              &Option.t[ValueRef] lliterbody,\n               &vec[@ast.expr] es,\n-              ty.t fn_ty)\n+              &ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef], ValueRef) {\n \n     let vec[ty.arg] args = ty.ty_fn_args(cx.fcx.lcx.ccx.tcx, fn_ty);\n@@ -4953,9 +4958,9 @@ fn trans_args(&@block_ctxt cx,\n     ret tup(bcx, llargs, llretslot);\n }\n \n-fn trans_call(&@block_ctxt cx, @ast.expr f,\n-              Option.t[ValueRef] lliterbody,\n-              vec[@ast.expr] args,\n+fn trans_call(&@block_ctxt cx, &@ast.expr f,\n+              &Option.t[ValueRef] lliterbody,\n+              &vec[@ast.expr] args,\n               &ast.ann ann) -> result {\n \n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n@@ -5042,7 +5047,7 @@ fn trans_call(&@block_ctxt cx, @ast.expr f,\n     ret res(bcx, retval);\n }\n \n-fn trans_tup(&@block_ctxt cx, vec[ast.elt] elts,\n+fn trans_tup(&@block_ctxt cx, &vec[ast.elt] elts,\n              &ast.ann ann) -> result {\n     auto bcx = cx;\n     auto t = node_ann_type(bcx.fcx.lcx.ccx, ann);\n@@ -5066,7 +5071,7 @@ fn trans_tup(&@block_ctxt cx, vec[ast.elt] elts,\n     ret res(bcx, tup_val);\n }\n \n-fn trans_vec(&@block_ctxt cx, vec[@ast.expr] args,\n+fn trans_vec(&@block_ctxt cx, &vec[@ast.expr] args,\n              &ast.ann ann) -> result {\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty = t;\n@@ -5140,8 +5145,8 @@ fn trans_vec(&@block_ctxt cx, vec[@ast.expr] args,\n     ret res(bcx, vec_val);\n }\n \n-fn trans_rec(&@block_ctxt cx, vec[ast.field] fields,\n-             Option.t[@ast.expr] base, &ast.ann ann) -> result {\n+fn trans_rec(&@block_ctxt cx, &vec[ast.field] fields,\n+             &Option.t[@ast.expr] base, &ast.ann ann) -> result {\n \n     auto bcx = cx;\n     auto t = node_ann_type(bcx.fcx.lcx.ccx, ann);\n@@ -5198,7 +5203,7 @@ fn trans_rec(&@block_ctxt cx, vec[ast.field] fields,\n \n \n \n-fn trans_expr(&@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_expr(&@block_ctxt cx, &@ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, ?ann)) {\n             ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, ann));\n@@ -5382,7 +5387,7 @@ fn trans_expr(&@block_ctxt cx, @ast.expr e) -> result {\n // pointer (or need one), perform load/store operations based on the\n // immediate-ness of the type.\n \n-fn type_is_immediate(@crate_ctxt ccx, ty.t t) -> bool {\n+fn type_is_immediate(&@crate_ctxt ccx, &ty.t t) -> bool {\n     ret ty.type_is_scalar(ccx.tcx, t) ||\n         ty.type_is_boxed(ccx.tcx, t) ||\n         ty.type_is_native(ccx.tcx, t);\n@@ -5395,21 +5400,21 @@ fn do_spill(&@block_ctxt cx, ValueRef v) -> ValueRef {\n     ret llptr;\n }\n \n-fn spill_if_immediate(&@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n+fn spill_if_immediate(&@block_ctxt cx, ValueRef v, &ty.t t) -> ValueRef {\n     if (type_is_immediate(cx.fcx.lcx.ccx, t)) {\n         ret do_spill(cx, v);\n     }\n     ret v;\n }\n \n-fn load_if_immediate(&@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n+fn load_if_immediate(&@block_ctxt cx, ValueRef v, &ty.t t) -> ValueRef {\n     if (type_is_immediate(cx.fcx.lcx.ccx, t)) {\n         ret cx.build.Load(v);\n     }\n     ret v;\n }\n \n-fn trans_log(int lvl, &@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_log(int lvl, &@block_ctxt cx, &@ast.expr e) -> result {\n     auto lcx = cx.fcx.lcx;\n     auto modname = Str.connect(lcx.module_path, \".\");\n     auto global;\n@@ -5485,7 +5490,7 @@ fn trans_log(int lvl, &@block_ctxt cx, @ast.expr e) -> result {\n     ret res(after_cx, C_nil());\n }\n \n-fn trans_check_expr(&@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_check_expr(&@block_ctxt cx, &@ast.expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n     auto expr_str = util.common.expr_to_str(e);\n@@ -5499,7 +5504,7 @@ fn trans_check_expr(&@block_ctxt cx, @ast.expr e) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn trans_fail(&@block_ctxt cx, Option.t[common.span] sp_opt, str fail_str)\n+fn trans_fail(&@block_ctxt cx, &Option.t[common.span] sp_opt, &str fail_str)\n         -> result {\n     auto V_fail_str = C_cstr(cx.fcx.lcx.ccx, fail_str);\n \n@@ -5642,15 +5647,15 @@ fn trans_ret(&@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n     ret res(new_sub_block_ctxt(bcx, \"ret.unreachable\"), C_nil());\n }\n \n-fn trans_be(&@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_be(&@block_ctxt cx, &@ast.expr e) -> result {\n     // FIXME: This should be a typestate precondition\n     assert (ast.is_call_expr(e));\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n     ret trans_ret(cx, some(e));\n }\n \n-fn trans_port(&@block_ctxt cx, ast.ann ann) -> result {\n+fn trans_port(&@block_ctxt cx, &ast.ann ann) -> result {\n \n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n@@ -5679,7 +5684,7 @@ fn trans_port(&@block_ctxt cx, ast.ann ann) -> result {\n     ret res(bcx, port_val);\n }\n \n-fn trans_chan(&@block_ctxt cx, @ast.expr e, ast.ann ann) -> result {\n+fn trans_chan(&@block_ctxt cx, &@ast.expr e, &ast.ann ann) -> result {\n \n     auto bcx = cx;\n     auto prt = trans_expr(bcx, e);\n@@ -5698,8 +5703,8 @@ fn trans_chan(&@block_ctxt cx, @ast.expr e, ast.ann ann) -> result {\n     ret res(bcx, chan_val);\n }\n \n-fn trans_send(&@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n-              ast.ann ann) -> result {\n+fn trans_send(&@block_ctxt cx, &@ast.expr lhs, &@ast.expr rhs,\n+              &ast.ann ann) -> result {\n \n     auto bcx = cx;\n     auto chn = trans_expr(bcx, lhs);\n@@ -5735,8 +5740,8 @@ fn trans_send(&@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n     ret res(bcx, chn.val);\n }\n \n-fn trans_recv(&@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n-              ast.ann ann) -> result {\n+fn trans_recv(&@block_ctxt cx, &@ast.expr lhs, &@ast.expr rhs,\n+              &ast.ann ann) -> result {\n \n     auto bcx = cx;\n     auto data = trans_lval(bcx, lhs);\n@@ -5748,8 +5753,8 @@ fn trans_recv(&@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n     ret recv_val(bcx, data.res.val, rhs, unit_ty, DROP_EXISTING);\n  }\n \n-fn recv_val(&@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n-            ty.t unit_ty, copy_action action) -> result {\n+fn recv_val(&@block_ctxt cx, ValueRef lhs, &@ast.expr rhs,\n+            &ty.t unit_ty, copy_action action) -> result {\n \n     auto bcx = cx;\n     auto prt = trans_expr(bcx, rhs);\n@@ -5769,7 +5774,7 @@ fn recv_val(&@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n     ret res(bcx, lhs);\n }\n \n-fn init_local(&@block_ctxt cx, @ast.local local) -> result {\n+fn init_local(&@block_ctxt cx, &@ast.local local) -> result {\n \n     // Make a note to drop this slot on the way out.\n     assert (cx.fcx.lllocals.contains_key(local.id));\n@@ -5846,9 +5851,9 @@ fn new_builder(BasicBlockRef llbb) -> builder {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-fn new_block_ctxt(@fn_ctxt cx, block_parent parent,\n+fn new_block_ctxt(&@fn_ctxt cx, &block_parent parent,\n                   block_kind kind,\n-                  str name) -> @block_ctxt {\n+                  &str name) -> @block_ctxt {\n     let vec[cleanup] cleanups = vec();\n     auto s = Str.buf(\"\");\n     if (cx.lcx.ccx.sess.get_opts().save_temps) {\n@@ -5864,24 +5869,24 @@ fn new_block_ctxt(@fn_ctxt cx, block_parent parent,\n }\n \n // Use this when you're at the top block of a function or the like.\n-fn new_top_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n+fn new_top_block_ctxt(&@fn_ctxt fcx) -> @block_ctxt {\n     ret new_block_ctxt(fcx, parent_none, SCOPE_BLOCK,\n                        \"function top level\");\n }\n \n // Use this when you're at a curly-brace or similar lexical scope.\n-fn new_scope_block_ctxt(&@block_ctxt bcx, str n) -> @block_ctxt {\n+fn new_scope_block_ctxt(&@block_ctxt bcx, &str n) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n);\n }\n \n-fn new_loop_scope_block_ctxt(&@block_ctxt bcx, Option.t[@block_ctxt] _cont,\n-                             &@block_ctxt _break, str n) -> @block_ctxt {\n+fn new_loop_scope_block_ctxt(&@block_ctxt bcx, &Option.t[@block_ctxt] _cont,\n+                             &@block_ctxt _break, &str n) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx),\n                        LOOP_SCOPE_BLOCK(_cont, _break), n);\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-fn new_sub_block_ctxt(&@block_ctxt bcx, str n) -> @block_ctxt {\n+fn new_sub_block_ctxt(&@block_ctxt bcx, &str n) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx), NON_SCOPE_BLOCK, n);\n }\n \n@@ -5925,7 +5930,7 @@ iter block_locals(&ast.block b) -> @ast.local {\n     }\n }\n \n-fn llallocas_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n+fn llallocas_block_ctxt(&@fn_ctxt fcx) -> @block_ctxt {\n     let vec[cleanup] cleanups = vec();\n     ret @rec(llbb=fcx.llallocas,\n              build=new_builder(fcx.llallocas),\n@@ -5935,7 +5940,7 @@ fn llallocas_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n              fcx=fcx);\n }\n \n-fn alloc_ty(&@block_ctxt cx, ty.t t) -> result {\n+fn alloc_ty(&@block_ctxt cx, &ty.t t) -> result {\n     auto val = C_int(0);\n     if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n \n@@ -5959,7 +5964,7 @@ fn alloc_ty(&@block_ctxt cx, ty.t t) -> result {\n     ret res(cx, val);\n }\n \n-fn alloc_local(&@block_ctxt cx, @ast.local local) -> result {\n+fn alloc_local(&@block_ctxt cx, &@ast.local local) -> result {\n     auto t = node_ann_type(cx.fcx.lcx.ccx, local.ann);\n     auto r = alloc_ty(cx, t);\n     r.bcx.fcx.lllocals.insert(local.id, r.val);\n@@ -6017,7 +6022,7 @@ fn trans_block(&@block_ctxt cx, &ast.block b) -> result {\n                                             res_alloca.val, r.val, r_ty);\n                     bcx = res_copy.bcx;\n \n-                    fn drop_hoisted_ty(@block_ctxt cx,\n+                    fn drop_hoisted_ty(&@block_ctxt cx,\n                                        ValueRef alloca_val,\n                                        ty.t t) -> result {\n                         auto reg_val = load_if_immediate(cx,\n@@ -6040,7 +6045,7 @@ fn trans_block(&@block_ctxt cx, &ast.block b) -> result {\n     ret res(bcx, r.val);\n }\n \n-fn new_local_ctxt(@crate_ctxt ccx) -> @local_ctxt {\n+fn new_local_ctxt(&@crate_ctxt ccx) -> @local_ctxt {\n     let vec[str] pth = vec();\n     let vec[ast.ty_param] obj_typarams = vec();\n     let vec[ast.obj_field] obj_fields = vec();\n@@ -6200,7 +6205,7 @@ fn is_terminated(&@block_ctxt cx) -> bool {\n     ret llvm.LLVMIsATerminatorInst(inst) as int != 0;\n }\n \n-fn arg_tys_of_fn(@crate_ctxt ccx, ast.ann ann) -> vec[ty.arg] {\n+fn arg_tys_of_fn(&@crate_ctxt ccx, ast.ann ann) -> vec[ty.arg] {\n     alt (ty.struct(ccx.tcx, ty.ann_to_type(ann))) {\n         case (ty.ty_fn(_, ?arg_tys, _)) {\n             ret arg_tys;\n@@ -6209,7 +6214,7 @@ fn arg_tys_of_fn(@crate_ctxt ccx, ast.ann ann) -> vec[ty.arg] {\n     fail;\n }\n \n-fn ret_ty_of_fn_ty(@crate_ctxt ccx, ty.t t) -> ty.t {\n+fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty.t t) -> ty.t {\n     alt (ty.struct(ccx.tcx, t)) {\n         case (ty.ty_fn(_, _, ?ret_ty)) {\n             ret ret_ty;\n@@ -6219,7 +6224,7 @@ fn ret_ty_of_fn_ty(@crate_ctxt ccx, ty.t t) -> ty.t {\n }\n \n \n-fn ret_ty_of_fn(@crate_ctxt ccx, ast.ann ann) -> ty.t {\n+fn ret_ty_of_fn(&@crate_ctxt ccx, ast.ann ann) -> ty.t {\n     ret ret_ty_of_fn_ty(ccx, ty.ann_to_type(ann));\n }\n \n@@ -6635,15 +6640,15 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n // duplicate constants. I think. Maybe LLVM has a magical mode\n // that does so later on?\n \n-fn trans_const_expr(@crate_ctxt cx, @ast.expr e) -> ValueRef {\n+fn trans_const_expr(&@crate_ctxt cx, @ast.expr e) -> ValueRef {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, ?ann)) {\n             ret trans_lit(cx, *lit, ann);\n         }\n     }\n }\n \n-fn trans_const(@crate_ctxt cx, @ast.expr e,\n+fn trans_const(&@crate_ctxt cx, @ast.expr e,\n                &ast.def_id cid, &ast.ann ann) {\n     auto t = node_ann_type(cx, ann);\n     auto v = trans_const_expr(cx, e);\n@@ -6702,7 +6707,7 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n     ret llvm.LLVMGetElementType(pair_tys.(0));\n }\n \n-fn decl_fn_and_pair(@crate_ctxt ccx,\n+fn decl_fn_and_pair(&@crate_ctxt ccx,\n                     vec[str] path,\n                     str flav,\n                     vec[ast.ty_param] ty_params,\n@@ -6733,7 +6738,7 @@ fn decl_fn_and_pair(@crate_ctxt ccx,\n     register_fn_pair(ccx, ps, llpairty, llfn, id);\n }\n \n-fn register_fn_pair(@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n+fn register_fn_pair(&@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n                     ast.def_id id) {\n     let ValueRef gvar = llvm.LLVMAddGlobal(cx.llmod, llpairty,\n                                            Str.buf(ps));\n@@ -6752,7 +6757,7 @@ fn register_fn_pair(@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n }\n \n // Returns the number of type parameters that the given native function has.\n-fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n+fn native_fn_ty_param_count(&@crate_ctxt cx, &ast.def_id id) -> uint {\n     auto count;\n     auto native_item = cx.native_items.get(id);\n     alt (native_item.node) {\n@@ -6768,7 +6773,7 @@ fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n     ret count;\n }\n \n-fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, ty.t x)\n+fn native_fn_wrapper_type(&@crate_ctxt cx, uint ty_param_count, ty.t x)\n         -> TypeRef {\n     alt (ty.struct(cx.tcx, x)) {\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n@@ -6778,7 +6783,7 @@ fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, ty.t x)\n     fail;\n }\n \n-fn decl_native_fn_and_pair(@crate_ctxt ccx,\n+fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n                            vec[str] path,\n                            str name,\n                            &ast.ann ann,\n@@ -7008,7 +7013,8 @@ fn leave_item(@walk_ctxt cx, &@ast.item item) {\n     }\n }\n \n-fn collect_native_item(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.native_item i) {\n+fn collect_native_item(&@crate_ctxt ccx, @walk_ctxt wcx,\n+                       &@ast.native_item i) {\n     alt (i.node) {\n         case (ast.native_item_fn(?name, _, _, _, ?fid, ?ann)) {\n             ccx.native_items.insert(fid, i);\n@@ -7022,7 +7028,7 @@ fn collect_native_item(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.native_item i) {\n     }\n }\n \n-fn collect_item_1(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n+fn collect_item_1(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n     enter_item(wcx, i);\n \n     alt (i.node) {\n@@ -7048,7 +7054,7 @@ fn collect_item_1(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n     }\n }\n \n-fn collect_item_2(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n+fn collect_item_2(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n     enter_item(wcx, i);\n \n     alt (i.node) {\n@@ -7069,7 +7075,7 @@ fn collect_item_2(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n     }\n }\n \n-fn collect_items(@crate_ctxt ccx, @ast.crate crate) {\n+fn collect_items(&@crate_ctxt ccx, @ast.crate crate) {\n     auto wcx = new_walk_ctxt();\n     auto visitor0 = walk.default_visitor();\n     auto visitor1 = rec(visit_native_item_pre =\n@@ -7084,7 +7090,7 @@ fn collect_items(@crate_ctxt ccx, @ast.crate crate) {\n     walk.walk_crate(visitor2, *crate);\n }\n \n-fn collect_tag_ctor(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n+fn collect_tag_ctor(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n     enter_item(wcx, i);\n \n     alt (i.node) {\n@@ -7102,7 +7108,7 @@ fn collect_tag_ctor(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item i) {\n     }\n }\n \n-fn collect_tag_ctors(@crate_ctxt ccx, @ast.crate crate) {\n+fn collect_tag_ctors(&@crate_ctxt ccx, @ast.crate crate) {\n     auto wcx = new_walk_ctxt();\n     auto visitor = rec(visit_item_pre = bind collect_tag_ctor(ccx, wcx, _),\n                        visit_item_post = bind leave_item(wcx, _)\n@@ -7112,7 +7118,7 @@ fn collect_tag_ctors(@crate_ctxt ccx, @ast.crate crate) {\n \n // The constant translation pass.\n \n-fn trans_constant(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item it) {\n+fn trans_constant(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item it) {\n     enter_item(wcx, it);\n \n     alt (it.node) {\n@@ -7154,7 +7160,7 @@ fn trans_constant(@crate_ctxt ccx, @walk_ctxt wcx, &@ast.item it) {\n     }\n }\n \n-fn trans_constants(@crate_ctxt ccx, @ast.crate crate) {\n+fn trans_constants(&@crate_ctxt ccx, @ast.crate crate) {\n     auto wcx = new_walk_ctxt();\n     auto visitor = rec(visit_item_pre = bind trans_constant(ccx, wcx, _),\n                        visit_item_post = bind leave_item(wcx, _)\n@@ -7209,7 +7215,7 @@ fn trans_exit_task_glue(@glue_fns glues,\n     build.RetVoid();\n }\n \n-fn create_typedefs(@crate_ctxt cx) {\n+fn create_typedefs(&@crate_ctxt cx) {\n     llvm.LLVMAddTypeName(cx.llmod, Str.buf(\"crate\"), T_crate(cx.tn));\n     llvm.LLVMAddTypeName(cx.llmod, Str.buf(\"task\"), T_task(cx.tn));\n     llvm.LLVMAddTypeName(cx.llmod, Str.buf(\"tydesc\"), T_tydesc(cx.tn));\n@@ -7249,7 +7255,7 @@ fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n     llvm.LLVMSetInitializer(crate_ptr, crate_val);\n }\n \n-fn find_main_fn(@crate_ctxt cx) -> ValueRef {\n+fn find_main_fn(&@crate_ctxt cx) -> ValueRef {\n     auto e = sep() + \"main\";\n     let ValueRef v = C_nil();\n     let uint n = 0u;\n@@ -7530,7 +7536,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n \n \n         fn take_one(ValueRef elt_tydesc,\n-                    @block_ctxt cx,\n+                    &@block_ctxt cx,\n                     ValueRef dst, ValueRef src) -> result {\n             call_tydesc_glue_full(cx, src,\n                                   elt_tydesc,\n@@ -7586,7 +7592,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n }\n \n \n-fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n+fn make_glues(ModuleRef llmod, &type_names tn) -> @glue_fns {\n     ret @rec(activate_glue = decl_glue(llmod, tn, abi.activate_glue_name()),\n              yield_glue = decl_glue(llmod, tn, abi.yield_glue_name()),\n              exit_task_glue = decl_cdecl_fn(llmod, abi.exit_task_glue_name(),\n@@ -7610,7 +7616,7 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n              vec_append_glue = make_vec_append_glue(llmod, tn));\n }\n \n-fn make_common_glue(session.session sess, str output) {\n+fn make_common_glue(&session.session sess, &str output) {\n     // FIXME: part of this is repetitive and is probably a good idea\n     // to autogen it.\n     auto llmod =\n@@ -7637,7 +7643,7 @@ fn make_common_glue(session.session sess, str output) {\n     Link.Write.run_passes(sess, llmod, output);\n }\n \n-fn create_module_map(@crate_ctxt ccx) -> ValueRef {\n+fn create_module_map(&@crate_ctxt ccx) -> ValueRef {\n     auto elttype = T_struct(vec(T_int(), T_int()));\n     auto maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     auto map = llvm.LLVMAddGlobal(ccx.llmod, maptype,\n@@ -7654,7 +7660,7 @@ fn create_module_map(@crate_ctxt ccx) -> ValueRef {\n     ret map;\n }\n \n-fn crate_name(@crate_ctxt ccx, str deflt) -> str {\n+fn crate_name(&@crate_ctxt ccx, &str deflt) -> str {\n     for (@ast.meta_item item in ccx.sess.get_metadata()) {\n         if (Str.eq(item.node.name, \"name\")) {\n             ret item.node.value;\n@@ -7664,7 +7670,7 @@ fn crate_name(@crate_ctxt ccx, str deflt) -> str {\n }\n \n // FIXME use hashed metadata instead of crate names once we have that\n-fn create_crate_map(@crate_ctxt ccx) -> ValueRef {\n+fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n     let vec[ValueRef] subcrates = vec();\n     auto i = 1;\n     while (ccx.sess.has_external_crate(i)) {\n@@ -7685,8 +7691,8 @@ fn create_crate_map(@crate_ctxt ccx) -> ValueRef {\n     ret map;\n }\n \n-fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n-               ty.type_cache type_cache, str output)\n+fn trans_crate(&session.session sess, &@ast.crate crate, &ty.ctxt tcx,\n+               &ty.type_cache type_cache, &str output)\n         -> ModuleRef {\n     auto llmod =\n         llvm.LLVMModuleCreateWithNameInContext(Str.buf(\"rust_out\"),"}]}