{"sha": "d425218395b4a4dd7c6e4f3d680447efd2a3abc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MjUyMTgzOTViNGE0ZGQ3YzZlNGYzZDY4MDQ0N2VmZDJhM2FiYzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-22T15:51:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:22:35Z"}, "message": "Bring io::signal up to date with changes to rt::rtio", "tree": {"sha": "2fe3e4bd7ea85a77fa5213e2e1d7377df5fc1183", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fe3e4bd7ea85a77fa5213e2e1d7377df5fc1183"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d425218395b4a4dd7c6e4f3d680447efd2a3abc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d425218395b4a4dd7c6e4f3d680447efd2a3abc6", "html_url": "https://github.com/rust-lang/rust/commit/d425218395b4a4dd7c6e4f3d680447efd2a3abc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d425218395b4a4dd7c6e4f3d680447efd2a3abc6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a02e07845b9fb4bc9b09909bd996c874fa3eed", "html_url": "https://github.com/rust-lang/rust/commit/b5a02e07845b9fb4bc9b09909bd996c874fa3eed"}], "stats": {"total": 154, "additions": 75, "deletions": 79}, "files": [{"sha": "07fe91f57a0d90720755ada25fe9567c130f39b8", "filename": "src/libstd/rt/io/signal.rs", "status": "modified", "additions": 58, "deletions": 35, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d425218395b4a4dd7c6e4f3d680447efd2a3abc6/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d425218395b4a4dd7c6e4f3d680447efd2a3abc6/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=d425218395b4a4dd7c6e4f3d680447efd2a3abc6", "patch": "@@ -8,14 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+Signal handling\n+\n+This modules provides bindings to receive signals safely, built on top of the\n+local I/O factory. There are a number of defined signals which can be caught,\n+but not all signals will work across all platforms (windows doesn't have\n+definitions for a number of signals.\n+\n+*/\n+\n use comm::{Port, SharedChan, stream};\n use hashmap;\n use option::{Some, None};\n use result::{Err, Ok};\n use rt::io::io_error;\n-use rt::local::Local;\n-use rt::rtio::{EventLoop, RtioSignalObject};\n-use rt::sched::Scheduler;\n+use rt::rtio::{IoFactory, RtioSignal, with_local_io};\n \n #[deriving(Eq, IterBytes)]\n pub enum Signum {\n@@ -47,19 +56,18 @@ pub enum Signum {\n /// Listener automatically unregisters its handles once it is out of scope.\n /// However, clients can still unregister signums manually.\n ///\n-/// Example usage:\n+/// # Example\n ///\n /// ```rust\n-/// use std::rt::io::signal;\n-/// use std::task;\n+/// use std::rt::io::signal::{Listener, Interrupt};\n ///\n-/// let mut listener = signal::Listener();\n+/// let mut listener = Listener::new();\n /// listener.register(signal::Interrupt);\n ///\n-/// do task::spawn {\n+/// do spawn {\n ///     loop {\n-///         match listener.recv() {\n-///             signal::Interrupt => println(\"Got Interrupt'ed\"),\n+///         match listener.port.recv() {\n+///             Interrupt => println(\"Got Interrupt'ed\"),\n ///             _ => (),\n ///         }\n ///     }\n@@ -68,15 +76,20 @@ pub enum Signum {\n /// ```\n pub struct Listener {\n     /// A map from signums to handles to keep the handles in memory\n-    priv handles: hashmap::HashMap<Signum, ~RtioSignalObject>,\n+    priv handles: hashmap::HashMap<Signum, ~RtioSignal>,\n     /// chan is where all the handles send signums, which are received by\n     /// the clients from port.\n     priv chan: SharedChan<Signum>,\n-    /// Clients of Listener can `recv()` from this port\n+\n+    /// Clients of Listener can `recv()` from this port. This is exposed to\n+    /// allow selection over this port as well as manipulation of the port\n+    /// directly.\n     port: Port<Signum>,\n }\n \n impl Listener {\n+    /// Creates a new listener for signals. Once created, signals are bound via\n+    /// the `register` method (otherwise nothing will ever be received)\n     pub fn new() -> Listener {\n         let (port, chan) = stream();\n         Listener {\n@@ -88,33 +101,43 @@ impl Listener {\n \n     /// Listen for a signal, returning true when successfully registered for\n     /// signum. Signals can be received using `recv()`.\n+    ///\n+    /// Once a signal is registered, this listener will continue to receive\n+    /// notifications of signals until it is unregistered. This occurs\n+    /// regardless of the number of other listeners registered in other tasks\n+    /// (or on this task).\n+    ///\n+    /// Signals are still received if there is no task actively waiting for\n+    /// a signal, and a later call to `recv` will return the signal that was\n+    /// received while no task was waiting on it.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If this function fails to register a signal handler, then an error will\n+    /// be raised on the `io_error` condition and the function will return\n+    /// false.\n     pub fn register(&mut self, signum: Signum) -> bool {\n-        match self.handles.find(&signum) {\n-            Some(_) => true, // self is already listening to signum, so succeed\n-            None => {\n-                let chan = self.chan.clone();\n-                let handle = unsafe {\n-                    rtdebug!(\"Listener::register: borrowing io to init UvSignal\");\n-                    let sched: *mut Scheduler = Local::unsafe_borrow();\n-                    rtdebug!(\"about to init handle\");\n-                    (*sched).event_loop.signal(signum, chan)\n-                };\n-                match handle {\n-                    Ok(w) => {\n-                        self.handles.insert(signum, w);\n-                        true\n-                    },\n-                    Err(ioerr) => {\n-                        rtdebug!(\"Listener::register: failed to init: {:?}\", ioerr);\n-                        io_error::cond.raise(ioerr);\n-                        false\n-                    },\n-                }\n-            },\n+        if self.handles.contains_key(&signum) {\n+            return true; // self is already listening to signum, so succeed\n         }\n+        do with_local_io |io| {\n+            match io.signal(signum, self.chan.clone()) {\n+                Ok(w) => {\n+                    self.handles.insert(signum, w);\n+                    Some(())\n+                },\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n+            }\n+        }.is_some()\n     }\n \n-    /// Unregister a signal.\n+    /// Unregisters a signal. If this listener currently had a handler\n+    /// registered for the signal, then it will stop receiving any more\n+    /// notification about the signal. If the signal has already been received,\n+    /// it may still be returned by `recv`.\n     pub fn unregister(&mut self, signum: Signum) {\n         self.handles.pop(&signum);\n     }"}, {"sha": "e51b7d90d95507e3205237a1f83ae7bf4635a6e9", "filename": "src/libstd/rt/uv/signal.rs", "status": "modified", "additions": 15, "deletions": 42, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d425218395b4a4dd7c6e4f3d680447efd2a3abc6/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d425218395b4a4dd7c6e4f3d680447efd2a3abc6/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs?ref=d425218395b4a4dd7c6e4f3d680447efd2a3abc6", "patch": "@@ -10,12 +10,10 @@\n \n use cast;\n use option::Some;\n-use libc::{c_int, c_void};\n+use libc::c_int;\n use result::{Err, Ok, Result};\n-use rt::io::IoError;\n use rt::io::signal::Signum;\n-use rt::uv::{Loop, NativeHandle, NullCallback, SignalCallback, UvError, Watcher};\n-use rt::uv::uv_error_to_io_error;\n+use rt::uv::{Loop, NativeHandle, SignalCallback, UvError, Watcher};\n use rt::uv::uvll;\n \n pub struct SignalWatcher(*uvll::uv_signal_t);\n@@ -34,19 +32,19 @@ impl SignalWatcher {\n         }\n     }\n \n-    pub fn start(&mut self, signum: Signum, callback: SignalCallback) -> Result<(), IoError> {\n-        {\n-            let data = self.get_watcher_data();\n-            data.signal_cb = Some(callback);\n-        }\n-\n-        let ret = unsafe {\n-            uvll::signal_start(self.native_handle(), signal_cb, signum as c_int)\n-        };\n-\n-        return match ret {\n-            0 => Ok(()),\n-            _ => Err(uv_error_to_io_error(UvError(ret))),\n+    pub fn start(&mut self, signum: Signum, callback: SignalCallback)\n+            -> Result<(), UvError>\n+    {\n+        return unsafe {\n+            match uvll::signal_start(self.native_handle(), signal_cb,\n+                                     signum as c_int) {\n+                0 => {\n+                    let data = self.get_watcher_data();\n+                    data.signal_cb = Some(callback);\n+                    Ok(())\n+                }\n+                n => Err(UvError(n)),\n+            }\n         };\n \n         extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n@@ -62,31 +60,6 @@ impl SignalWatcher {\n             uvll::signal_stop(self.native_handle());\n         }\n     }\n-\n-    pub fn close(self, cb: NullCallback) {\n-        let mut watcher = self;\n-        {\n-            let data = watcher.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe {\n-            uvll::close(watcher.native_handle(), close_cb);\n-        }\n-\n-        extern fn close_cb(handle: *uvll::uv_signal_t) {\n-            let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n-            {\n-                let data = watcher.get_watcher_data();\n-                data.close_cb.take_unwrap()();\n-            }\n-            watcher.drop_watcher_data();\n-            unsafe {\n-                uvll::free_handle(handle as *c_void);\n-            }\n-        }\n-    }\n }\n \n impl NativeHandle<*uvll::uv_signal_t> for SignalWatcher {"}, {"sha": "473eec32c67eb4e28147b93d93336ad2c3e54f1d", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d425218395b4a4dd7c6e4f3d680447efd2a3abc6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d425218395b4a4dd7c6e4f3d680447efd2a3abc6/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=d425218395b4a4dd7c6e4f3d680447efd2a3abc6", "patch": "@@ -865,12 +865,12 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn signal(&mut self, signum: Signum, channel: SharedChan<Signum>)\n-        -> Result<~RtioSignalObject, IoError> {\n+        -> Result<~RtioSignal, IoError> {\n         let watcher = SignalWatcher::new(self.uv_loop());\n         let home = get_handle_to_current_scheduler!();\n         let mut signal = ~UvSignal::new(watcher, home);\n         match signal.watcher.start(signum, |_, _| channel.send_deferred(signum)) {\n-            Ok(()) => Ok(signal),\n+            Ok(()) => Ok(signal as ~RtioSignal),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }"}]}