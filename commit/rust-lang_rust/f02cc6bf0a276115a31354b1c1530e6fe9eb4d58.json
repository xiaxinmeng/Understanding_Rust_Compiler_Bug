{"sha": "f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMmNjNmJmMGEyNzYxMTVhMzEzNTRiMWMxNTMwZTZmZTllYjRkNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-13T11:59:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-13T11:59:20Z"}, "message": "auto merge of #8411 : bblum/rust/assorted-fixes, r=brson\n\nEach commit is pretty much what it says on the tin. r anybody.", "tree": {"sha": "f5b4895221d2354eae0a71cdf1cb99eb50bac693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5b4895221d2354eae0a71cdf1cb99eb50bac693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "html_url": "https://github.com/rust-lang/rust/commit/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c99b2b932f1da9b1746387d8968476240dadf204", "url": "https://api.github.com/repos/rust-lang/rust/commits/c99b2b932f1da9b1746387d8968476240dadf204", "html_url": "https://github.com/rust-lang/rust/commit/c99b2b932f1da9b1746387d8968476240dadf204"}, {"sha": "5ac8c57bd420d61ed80a07746ab1a75e4062383f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac8c57bd420d61ed80a07746ab1a75e4062383f", "html_url": "https://github.com/rust-lang/rust/commit/5ac8c57bd420d61ed80a07746ab1a75e4062383f"}], "stats": {"total": 948, "additions": 469, "deletions": 479}, "files": [{"sha": "372effad61d3c99713e2734f81a0651f95fecef9", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -13,6 +13,7 @@\n #[missing_doc];\n \n use cast::transmute_mut;\n+use unstable::finally::Finally;\n use prelude::*;\n \n /*\n@@ -65,18 +66,17 @@ impl<T> Cell<T> {\n \n     /// Calls a closure with a reference to the value.\n     pub fn with_ref<R>(&self, op: &fn(v: &T) -> R) -> R {\n-        let v = self.take();\n-        let r = op(&v);\n-        self.put_back(v);\n-        r\n+        do self.with_mut_ref |ptr| { op(ptr) }\n     }\n \n     /// Calls a closure with a mutable reference to the value.\n     pub fn with_mut_ref<R>(&self, op: &fn(v: &mut T) -> R) -> R {\n-        let mut v = self.take();\n-        let r = op(&mut v);\n-        self.put_back(v);\n-        r\n+        let mut v = Some(self.take());\n+        do (|| {\n+            op(v.get_mut_ref())\n+        }).finally {\n+            self.put_back(v.take_unwrap());\n+        }\n     }\n }\n "}, {"sha": "42d59ccdf958eb8eff28ddabdc014202c5e1547b", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -18,7 +18,8 @@ use kinds::Send;\n use rt;\n use rt::sched::Scheduler;\n use rt::local::Local;\n-use rt::select::{Select, SelectPort};\n+use rt::select::{SelectInner, SelectPortInner};\n+use select::{Select, SelectPort};\n use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Relaxed, SeqCst};\n use unstable::sync::UnsafeAtomicRcBox;\n use util::Void;\n@@ -113,7 +114,9 @@ impl<T> ChanOne<T> {\n     // 'do_resched' configures whether the scheduler immediately switches to\n     // the receiving task, or leaves the sending task still running.\n     fn try_send_inner(self, val: T, do_resched: bool) -> bool {\n-        rtassert!(!rt::in_sched_context());\n+        if do_resched {\n+            rtassert!(!rt::in_sched_context());\n+        }\n \n         let mut this = self;\n         let mut recvr_active = true;\n@@ -215,7 +218,7 @@ impl<T> PortOne<T> {\n     }\n }\n \n-impl<T> Select for PortOne<T> {\n+impl<T> SelectInner for PortOne<T> {\n     #[inline] #[cfg(not(test))]\n     fn optimistic_check(&mut self) -> bool {\n         unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n@@ -318,7 +321,9 @@ impl<T> Select for PortOne<T> {\n     }\n }\n \n-impl<T> SelectPort<T> for PortOne<T> {\n+impl<T> Select for PortOne<T> { }\n+\n+impl<T> SelectPortInner<T> for PortOne<T> {\n     fn recv_ready(self) -> Option<T> {\n         let mut this = self;\n         let packet = this.packet();\n@@ -349,6 +354,8 @@ impl<T> SelectPort<T> for PortOne<T> {\n     }\n }\n \n+impl<T> SelectPort<T> for PortOne<T> { }\n+\n impl<T> Peekable<T> for PortOne<T> {\n     fn peek(&self) -> bool {\n         unsafe {\n@@ -513,7 +520,7 @@ impl<T> Peekable<T> for Port<T> {\n // of them, but a &Port<T> should also be selectable so you can select2 on it\n // alongside a PortOne<U> without passing the port by value in recv_ready.\n \n-impl<'self, T> Select for &'self Port<T> {\n+impl<'self, T> SelectInner for &'self Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n         do self.next.with_mut_ref |pone| { pone.optimistic_check() }\n@@ -531,7 +538,9 @@ impl<'self, T> Select for &'self Port<T> {\n     }\n }\n \n-impl<T> Select for Port<T> {\n+impl<'self, T> Select for &'self Port<T> { }\n+\n+impl<T> SelectInner for Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n         (&*self).optimistic_check()\n@@ -548,7 +557,9 @@ impl<T> Select for Port<T> {\n     }\n }\n \n-impl<'self, T> SelectPort<T> for &'self Port<T> {\n+impl<T> Select for Port<T> { }\n+\n+impl<'self, T> SelectPortInner<T> for &'self Port<T> {\n     fn recv_ready(self) -> Option<T> {\n         match self.next.take().recv_ready() {\n             Some(StreamPayload { val, next }) => {\n@@ -560,6 +571,8 @@ impl<'self, T> SelectPort<T> for &'self Port<T> {\n     }\n }\n \n+impl<'self, T> SelectPort<T> for &'self Port<T> { }\n+\n pub struct SharedChan<T> {\n     // Just like Chan, but a shared AtomicOption instead of Cell\n     priv next: UnsafeAtomicRcBox<AtomicOption<StreamChanOne<T>>>"}, {"sha": "83bf34941dc705688f39f5ddaa3629fcf21107cd", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -488,8 +488,8 @@ impl Death {\n         rtassert!(self.unkillable == 0);\n         self.unkillable = 1;\n \n-        // FIXME(#7544): See corresponding fixme at the callsite in task.rs.\n-        // NB(#8192): Doesn't work with \"let _ = ...\"\n+        // NB. See corresponding comment at the callsite in task.rs.\n+        // FIXME(#8192): Doesn't work with \"let _ = ...\"\n         { use util; util::ignore(group); }\n \n         // Step 1. Decide if we need to collect child failures synchronously."}, {"sha": "3a991e92b0b5f1c421dd48772e01c07e6d74ed5f", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -142,8 +142,7 @@ pub mod tube;\n /// Simple reimplementation of core::comm\n pub mod comm;\n \n-/// Routines for select()ing on pipes.\n-pub mod select;\n+mod select;\n \n // FIXME #5248 shouldn't be pub\n /// The runtime needs to be able to put a pointer into thread-local storage."}, {"sha": "19a4948af3c5ae8e8582536b9776ef999127b982", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 5, "deletions": 305, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::*;\n-// use either::{Either, Left, Right};\n+//! Module for private, abstraction-leaking select traits. Wrapped in std::select.\n+\n use rt::kill::BlockedTask;\n use rt::sched::Scheduler;\n-use rt::local::Local;\n+use option::Option;\n \n-/// Trait for message-passing primitives that can be select()ed on.\n-pub trait Select {\n+pub trait SelectInner {\n     // Returns true if data was available.\n     fn optimistic_check(&mut self) -> bool;\n     // Returns true if data was available. If so, shall also wake() the task.\n@@ -24,305 +23,6 @@ pub trait Select {\n     fn unblock_from(&mut self) -> bool;\n }\n \n-/// Trait for message-passing primitives that can use the select2() convenience wrapper.\n-// (This is separate from the above trait to enable heterogeneous lists of ports\n-// that implement Select on different types to use select().)\n-pub trait SelectPort<T> : Select {\n+pub trait SelectPortInner<T> {\n     fn recv_ready(self) -> Option<T>;\n }\n-\n-/// Receive a message from any one of many ports at once.\n-pub fn select<A: Select>(ports: &mut [A]) -> uint {\n-    if ports.is_empty() {\n-        fail!(\"can't select on an empty list\");\n-    }\n-\n-    for (index, port) in ports.mut_iter().enumerate() {\n-        if port.optimistic_check() {\n-            return index;\n-        }\n-    }\n-\n-    // If one of the ports already contains data when we go to block on it, we\n-    // don't bother enqueueing on the rest of them, so we shouldn't bother\n-    // unblocking from it either. This is just for efficiency, not correctness.\n-    // (If not, we need to unblock from all of them. Length is a placeholder.)\n-    let mut ready_index = ports.len();\n-\n-    let sched = Local::take::<Scheduler>();\n-    do sched.deschedule_running_task_and_then |sched, task| {\n-        let task_handles = task.make_selectable(ports.len());\n-\n-        for (index, (port, task_handle)) in\n-                ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n-            // If one of the ports has data by now, it will wake the handle.\n-            if port.block_on(sched, task_handle) {\n-                ready_index = index;\n-                break;\n-            }\n-        }\n-    }\n-\n-    // Task resumes. Now unblock ourselves from all the ports we blocked on.\n-    // If the success index wasn't reset, 'take' will just take all of them.\n-    // Iterate in reverse so the 'earliest' index that's ready gets returned.\n-    for (index, port) in ports.mut_slice(0, ready_index).mut_rev_iter().enumerate() {\n-        if port.unblock_from() {\n-            ready_index = index;\n-        }\n-    }\n-\n-    assert!(ready_index < ports.len());\n-    return ready_index;\n-}\n-\n-/* FIXME(#5121, #7914) This all should be legal, but rust is not clever enough yet.\n-\n-impl <'self> Select for &'self mut Select {\n-    fn optimistic_check(&mut self) -> bool { self.optimistic_check() }\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        self.block_on(sched, task)\n-    }\n-    fn unblock_from(&mut self) -> bool { self.unblock_from() }\n-}\n-\n-pub fn select2<TA, A: SelectPort<TA>, TB, B: SelectPort<TB>>(mut a: A, mut b: B)\n-        -> Either<(Option<TA>, B), (A, Option<TB>)> {\n-    let result = {\n-        let mut ports = [&mut a as &mut Select, &mut b as &mut Select];\n-        select(ports)\n-    };\n-    match result {\n-        0 => Left ((a.recv_ready(), b)),\n-        1 => Right((a, b.recv_ready())),\n-        x => fail!(\"impossible case in select2: %?\", x)\n-    }\n-}\n-\n-*/\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use option::*;\n-    use rt::comm::*;\n-    use rt::test::*;\n-    use vec::*;\n-    use comm::GenericChan;\n-    use task;\n-    use cell::Cell;\n-    use iterator::{Iterator, range};\n-\n-    #[test] #[ignore(cfg(windows))] #[should_fail]\n-    fn select_doesnt_get_trolled() {\n-        select::<PortOne<()>>([]);\n-    }\n-\n-    /* non-blocking select tests */\n-\n-    #[cfg(test)]\n-    fn select_helper(num_ports: uint, send_on_chans: &[uint]) {\n-        // Unfortunately this does not actually test the block_on early-break\n-        // codepath in select -- racing between the sender and the receiver in\n-        // separate tasks is necessary to get around the optimistic check.\n-        let (ports, chans) = unzip(from_fn(num_ports, |_| oneshot::<()>()));\n-        let mut dead_chans = ~[];\n-        let mut ports = ports;\n-        for (i, chan) in chans.move_iter().enumerate() {\n-            if send_on_chans.contains(&i) {\n-                chan.send(());\n-            } else {\n-                dead_chans.push(chan);\n-            }\n-        }\n-        let ready_index = select(ports);\n-        assert!(send_on_chans.contains(&ready_index));\n-        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n-        let _ = dead_chans;\n-\n-        // Same thing with streams instead.\n-        // FIXME(#7971): This should be in a macro but borrowck isn't smart enough.\n-        let (ports, chans) = unzip(from_fn(num_ports, |_| stream::<()>()));\n-        let mut dead_chans = ~[];\n-        let mut ports = ports;\n-        for (i, chan) in chans.move_iter().enumerate() {\n-            if send_on_chans.contains(&i) {\n-                chan.send(());\n-            } else {\n-                dead_chans.push(chan);\n-            }\n-        }\n-        let ready_index = select(ports);\n-        assert!(send_on_chans.contains(&ready_index));\n-        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n-        let _ = dead_chans;\n-    }\n-\n-    #[test]\n-    fn select_one() {\n-        do run_in_newsched_task { select_helper(1, [0]) }\n-    }\n-\n-    #[test]\n-    fn select_two() {\n-        // NB. I would like to have a test that tests the first one that is\n-        // ready is the one that's returned, but that can't be reliably tested\n-        // with the randomized behaviour of optimistic_check.\n-        do run_in_newsched_task { select_helper(2, [1]) }\n-        do run_in_newsched_task { select_helper(2, [0]) }\n-        do run_in_newsched_task { select_helper(2, [1,0]) }\n-    }\n-\n-    #[test]\n-    fn select_a_lot() {\n-        do run_in_newsched_task { select_helper(12, [7,8,9]) }\n-    }\n-\n-    #[test]\n-    fn select_stream() {\n-        use util;\n-        use comm::GenericChan;\n-        use iter::Times;\n-\n-        // Sends 10 buffered packets, and uses select to retrieve them all.\n-        // Puts the port in a different spot in the vector each time.\n-        do run_in_newsched_task {\n-            let (ports, _) = unzip(from_fn(10, |_| stream()));\n-            let (port, chan) = stream();\n-            do 10.times { chan.send(31337); }\n-            let mut ports = ports;\n-            let mut port = Some(port);\n-            let order = [5u,0,4,3,2,6,9,8,7,1];\n-            for &index in order.iter() {\n-                // put the port in the vector at any index\n-                util::swap(port.get_mut_ref(), &mut ports[index]);\n-                assert!(select(ports) == index);\n-                // get it back out\n-                util::swap(port.get_mut_ref(), &mut ports[index]);\n-                // NB. Not recv(), because optimistic_check randomly fails.\n-                assert!(port.get_ref().recv_ready().unwrap() == 31337);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn select_unkillable() {\n-        do run_in_newsched_task {\n-            do task::unkillable { select_helper(2, [1]) }\n-        }\n-    }\n-\n-    /* blocking select tests */\n-\n-    #[test]\n-    fn select_blocking() {\n-        select_blocking_helper(true);\n-        select_blocking_helper(false);\n-\n-        fn select_blocking_helper(killable: bool) {\n-            do run_in_newsched_task {\n-                let (p1,_c) = oneshot();\n-                let (p2,c2) = oneshot();\n-                let mut ports = [p1,p2];\n-\n-                let (p3,c3) = oneshot();\n-                let (p4,c4) = oneshot();\n-\n-                let x = Cell::new((c2, p3, c4));\n-                do task::spawn {\n-                    let (c2, p3, c4) = x.take();\n-                    p3.recv();   // handshake parent\n-                    c4.send(()); // normal receive\n-                    task::yield();\n-                    c2.send(()); // select receive\n-                }\n-\n-                // Try to block before child sends on c2.\n-                c3.send(());\n-                p4.recv();\n-                if killable {\n-                    assert!(select(ports) == 1);\n-                } else {\n-                    do task::unkillable { assert!(select(ports) == 1); }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn select_racing_senders() {\n-        static NUM_CHANS: uint = 10;\n-\n-        select_racing_senders_helper(true,  ~[0,1,2,3,4,5,6,7,8,9]);\n-        select_racing_senders_helper(false, ~[0,1,2,3,4,5,6,7,8,9]);\n-        select_racing_senders_helper(true,  ~[0,1,2]);\n-        select_racing_senders_helper(false, ~[0,1,2]);\n-        select_racing_senders_helper(true,  ~[3,4,5,6]);\n-        select_racing_senders_helper(false, ~[3,4,5,6]);\n-        select_racing_senders_helper(true,  ~[7,8,9]);\n-        select_racing_senders_helper(false, ~[7,8,9]);\n-\n-        fn select_racing_senders_helper(killable: bool, send_on_chans: ~[uint]) {\n-            use rt::test::spawntask_random;\n-            use iter::Times;\n-\n-            do run_in_newsched_task {\n-                // A bit of stress, since ordinarily this is just smoke and mirrors.\n-                do 4.times {\n-                    let send_on_chans = send_on_chans.clone();\n-                    do task::spawn {\n-                        let mut ports = ~[];\n-                        for i in range(0u, NUM_CHANS) {\n-                            let (p,c) = oneshot();\n-                            ports.push(p);\n-                            if send_on_chans.contains(&i) {\n-                                let c = Cell::new(c);\n-                                do spawntask_random {\n-                                    task::yield();\n-                                    c.take().send(());\n-                                }\n-                            }\n-                        }\n-                        // nondeterministic result, but should succeed\n-                        if killable {\n-                            select(ports);\n-                        } else {\n-                            do task::unkillable { select(ports); }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test] #[ignore(cfg(windows))]\n-    fn select_killed() {\n-        do run_in_newsched_task {\n-            let (success_p, success_c) = oneshot::<bool>();\n-            let success_c = Cell::new(success_c);\n-            do task::try {\n-                let success_c = Cell::new(success_c.take());\n-                do task::unkillable {\n-                    let (p,c) = oneshot();\n-                    let c = Cell::new(c);\n-                    do task::spawn {\n-                        let (dead_ps, dead_cs) = unzip(from_fn(5, |_| oneshot::<()>()));\n-                        let mut ports = dead_ps;\n-                        select(ports); // should get killed; nothing should leak\n-                        c.take().send(()); // must not happen\n-                        // Make sure dead_cs doesn't get closed until after select.\n-                        let _ = dead_cs;\n-                    }\n-                    do task::spawn {\n-                        fail!(); // should kill sibling awake\n-                    }\n-\n-                    // wait for killed selector to close (NOT send on) its c.\n-                    // hope to send 'true'.\n-                    success_c.take().send(p.try_recv().is_none());\n-                }\n-            };\n-            assert!(success_p.recv());\n-        }\n-    }\n-}"}, {"sha": "c669f25d8b738033b78c7ab4188cd1be0579bcaa", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -253,12 +253,10 @@ impl Task {\n             }\n         }\n \n-        // FIXME(#7544): We pass the taskgroup into death so that it can be\n-        // dropped while the unkillable counter is set. This should not be\n-        // necessary except for an extraneous clone() in task/spawn.rs that\n-        // causes a killhandle to get dropped, which mustn't receive a kill\n-        // signal since we're outside of the unwinder's try() scope.\n-        // { let _ = self.taskgroup.take(); }\n+        // NB. We pass the taskgroup into death so that it can be dropped while\n+        // the unkillable counter is set. This is necessary for when the\n+        // taskgroup destruction code drops references on KillHandles, which\n+        // might require using unkillable (to synchronize with an unwrapper).\n         self.death.collect_failure(!self.unwinder.unwinding, self.taskgroup.take());\n         self.destroyed = true;\n     }"}, {"sha": "a92339e2562443a325c50623203e4a3c31ac0759", "filename": "src/libstd/select.rs", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -0,0 +1,344 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::Cell;\n+use comm;\n+use container::Container;\n+use iterator::Iterator;\n+use option::*;\n+// use either::{Either, Left, Right};\n+// use rt::kill::BlockedTask;\n+use rt::sched::Scheduler;\n+use rt::select::{SelectInner, SelectPortInner};\n+use rt::local::Local;\n+use rt::rtio::EventLoop;\n+use task;\n+use vec::{OwnedVector, MutableVector};\n+\n+/// Trait for message-passing primitives that can be select()ed on.\n+pub trait Select : SelectInner { }\n+\n+/// Trait for message-passing primitives that can use the select2() convenience wrapper.\n+// (This is separate from the above trait to enable heterogeneous lists of ports\n+// that implement Select on different types to use select().)\n+pub trait SelectPort<T> : SelectPortInner<T> { }\n+\n+/// Receive a message from any one of many ports at once. Returns the index of the\n+/// port whose data is ready. (If multiple are ready, returns the lowest index.)\n+pub fn select<A: Select>(ports: &mut [A]) -> uint {\n+    if ports.is_empty() {\n+        fail!(\"can't select on an empty list\");\n+    }\n+\n+    for (index, port) in ports.mut_iter().enumerate() {\n+        if port.optimistic_check() {\n+            return index;\n+        }\n+    }\n+\n+    // If one of the ports already contains data when we go to block on it, we\n+    // don't bother enqueueing on the rest of them, so we shouldn't bother\n+    // unblocking from it either. This is just for efficiency, not correctness.\n+    // (If not, we need to unblock from all of them. Length is a placeholder.)\n+    let mut ready_index = ports.len();\n+\n+    // XXX: We're using deschedule...and_then in an unsafe way here (see #8132),\n+    // in that we need to continue mutating the ready_index in the environment\n+    // after letting the task get woken up. The and_then closure needs to delay\n+    // the task from resuming until all ports have become blocked_on.\n+    let (p,c) = comm::oneshot();\n+    let p = Cell::new(p);\n+    let c = Cell::new(c);\n+\n+    let sched = Local::take::<Scheduler>();\n+    do sched.deschedule_running_task_and_then |sched, task| {\n+        let task_handles = task.make_selectable(ports.len());\n+\n+        for (index, (port, task_handle)) in\n+                ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n+            // If one of the ports has data by now, it will wake the handle.\n+            if port.block_on(sched, task_handle) {\n+                ready_index = index;\n+                break;\n+            }\n+        }\n+\n+        let c = Cell::new(c.take());\n+        do sched.event_loop.callback { c.take().send_deferred(()) }\n+    }\n+\n+    // Unkillable is necessary not because getting killed is dangerous here,\n+    // but to force the recv not to use the same kill-flag that we used for\n+    // selecting. Otherwise a user-sender could spuriously wakeup us here.\n+    do task::unkillable { p.take().recv(); }\n+\n+    // Task resumes. Now unblock ourselves from all the ports we blocked on.\n+    // If the success index wasn't reset, 'take' will just take all of them.\n+    // Iterate in reverse so the 'earliest' index that's ready gets returned.\n+    for (index, port) in ports.mut_slice(0, ready_index).mut_rev_iter().enumerate() {\n+        if port.unblock_from() {\n+            ready_index = index;\n+        }\n+    }\n+\n+    assert!(ready_index < ports.len());\n+    return ready_index;\n+}\n+\n+/* FIXME(#5121, #7914) This all should be legal, but rust is not clever enough yet.\n+\n+impl <'self> Select for &'self mut Select {\n+    fn optimistic_check(&mut self) -> bool { self.optimistic_check() }\n+    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n+        self.block_on(sched, task)\n+    }\n+    fn unblock_from(&mut self) -> bool { self.unblock_from() }\n+}\n+\n+pub fn select2<TA, A: SelectPort<TA>, TB, B: SelectPort<TB>>(mut a: A, mut b: B)\n+        -> Either<(Option<TA>, B), (A, Option<TB>)> {\n+    let result = {\n+        let mut ports = [&mut a as &mut Select, &mut b as &mut Select];\n+        select(ports)\n+    };\n+    match result {\n+        0 => Left ((a.recv_ready(), b)),\n+        1 => Right((a, b.recv_ready())),\n+        x => fail!(\"impossible case in select2: %?\", x)\n+    }\n+}\n+\n+*/\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use clone::Clone;\n+    use iter::Times;\n+    use option::*;\n+    use rt::comm::*;\n+    use rt::test::*;\n+    use vec::*;\n+    use comm::GenericChan;\n+    use task;\n+    use cell::Cell;\n+    use iterator::{Iterator, range};\n+\n+    #[test] #[ignore(cfg(windows))] #[should_fail]\n+    fn select_doesnt_get_trolled() {\n+        select::<PortOne<()>>([]);\n+    }\n+\n+    /* non-blocking select tests */\n+\n+    #[cfg(test)]\n+    fn select_helper(num_ports: uint, send_on_chans: &[uint]) {\n+        // Unfortunately this does not actually test the block_on early-break\n+        // codepath in select -- racing between the sender and the receiver in\n+        // separate tasks is necessary to get around the optimistic check.\n+        let (ports, chans) = unzip(from_fn(num_ports, |_| oneshot::<()>()));\n+        let mut dead_chans = ~[];\n+        let mut ports = ports;\n+        for (i, chan) in chans.move_iter().enumerate() {\n+            if send_on_chans.contains(&i) {\n+                chan.send(());\n+            } else {\n+                dead_chans.push(chan);\n+            }\n+        }\n+        let ready_index = select(ports);\n+        assert!(send_on_chans.contains(&ready_index));\n+        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n+        let _ = dead_chans;\n+\n+        // Same thing with streams instead.\n+        // FIXME(#7971): This should be in a macro but borrowck isn't smart enough.\n+        let (ports, chans) = unzip(from_fn(num_ports, |_| stream::<()>()));\n+        let mut dead_chans = ~[];\n+        let mut ports = ports;\n+        for (i, chan) in chans.move_iter().enumerate() {\n+            if send_on_chans.contains(&i) {\n+                chan.send(());\n+            } else {\n+                dead_chans.push(chan);\n+            }\n+        }\n+        let ready_index = select(ports);\n+        assert!(send_on_chans.contains(&ready_index));\n+        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n+        let _ = dead_chans;\n+    }\n+\n+    #[test]\n+    fn select_one() {\n+        do run_in_newsched_task { select_helper(1, [0]) }\n+    }\n+\n+    #[test]\n+    fn select_two() {\n+        // NB. I would like to have a test that tests the first one that is\n+        // ready is the one that's returned, but that can't be reliably tested\n+        // with the randomized behaviour of optimistic_check.\n+        do run_in_newsched_task { select_helper(2, [1]) }\n+        do run_in_newsched_task { select_helper(2, [0]) }\n+        do run_in_newsched_task { select_helper(2, [1,0]) }\n+    }\n+\n+    #[test]\n+    fn select_a_lot() {\n+        do run_in_newsched_task { select_helper(12, [7,8,9]) }\n+    }\n+\n+    #[test]\n+    fn select_stream() {\n+        use util;\n+        use comm::GenericChan;\n+\n+        // Sends 10 buffered packets, and uses select to retrieve them all.\n+        // Puts the port in a different spot in the vector each time.\n+        do run_in_newsched_task {\n+            let (ports, _) = unzip(from_fn(10, |_| stream()));\n+            let (port, chan) = stream();\n+            do 10.times { chan.send(31337); }\n+            let mut ports = ports;\n+            let mut port = Some(port);\n+            let order = [5u,0,4,3,2,6,9,8,7,1];\n+            for &index in order.iter() {\n+                // put the port in the vector at any index\n+                util::swap(port.get_mut_ref(), &mut ports[index]);\n+                assert!(select(ports) == index);\n+                // get it back out\n+                util::swap(port.get_mut_ref(), &mut ports[index]);\n+                // NB. Not recv(), because optimistic_check randomly fails.\n+                assert!(port.get_ref().recv_ready().unwrap() == 31337);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn select_unkillable() {\n+        do run_in_newsched_task {\n+            do task::unkillable { select_helper(2, [1]) }\n+        }\n+    }\n+\n+    /* blocking select tests */\n+\n+    #[test]\n+    fn select_blocking() {\n+        select_blocking_helper(true);\n+        select_blocking_helper(false);\n+\n+        fn select_blocking_helper(killable: bool) {\n+            do run_in_newsched_task {\n+                let (p1,_c) = oneshot();\n+                let (p2,c2) = oneshot();\n+                let mut ports = [p1,p2];\n+\n+                let (p3,c3) = oneshot();\n+                let (p4,c4) = oneshot();\n+\n+                let x = Cell::new((c2, p3, c4));\n+                do task::spawn {\n+                    let (c2, p3, c4) = x.take();\n+                    p3.recv();   // handshake parent\n+                    c4.send(()); // normal receive\n+                    task::yield();\n+                    c2.send(()); // select receive\n+                }\n+\n+                // Try to block before child sends on c2.\n+                c3.send(());\n+                p4.recv();\n+                if killable {\n+                    assert!(select(ports) == 1);\n+                } else {\n+                    do task::unkillable { assert!(select(ports) == 1); }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn select_racing_senders() {\n+        static NUM_CHANS: uint = 10;\n+\n+        select_racing_senders_helper(true,  ~[0,1,2,3,4,5,6,7,8,9]);\n+        select_racing_senders_helper(false, ~[0,1,2,3,4,5,6,7,8,9]);\n+        select_racing_senders_helper(true,  ~[0,1,2]);\n+        select_racing_senders_helper(false, ~[0,1,2]);\n+        select_racing_senders_helper(true,  ~[3,4,5,6]);\n+        select_racing_senders_helper(false, ~[3,4,5,6]);\n+        select_racing_senders_helper(true,  ~[7,8,9]);\n+        select_racing_senders_helper(false, ~[7,8,9]);\n+\n+        fn select_racing_senders_helper(killable: bool, send_on_chans: ~[uint]) {\n+            use rt::test::spawntask_random;\n+\n+            do run_in_newsched_task {\n+                // A bit of stress, since ordinarily this is just smoke and mirrors.\n+                do 4.times {\n+                    let send_on_chans = send_on_chans.clone();\n+                    do task::spawn {\n+                        let mut ports = ~[];\n+                        for i in range(0u, NUM_CHANS) {\n+                            let (p,c) = oneshot();\n+                            ports.push(p);\n+                            if send_on_chans.contains(&i) {\n+                                let c = Cell::new(c);\n+                                do spawntask_random {\n+                                    task::yield();\n+                                    c.take().send(());\n+                                }\n+                            }\n+                        }\n+                        // nondeterministic result, but should succeed\n+                        if killable {\n+                            select(ports);\n+                        } else {\n+                            do task::unkillable { select(ports); }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test] #[ignore(cfg(windows))]\n+    fn select_killed() {\n+        do run_in_newsched_task {\n+            let (success_p, success_c) = oneshot::<bool>();\n+            let success_c = Cell::new(success_c);\n+            do task::try {\n+                let success_c = Cell::new(success_c.take());\n+                do task::unkillable {\n+                    let (p,c) = oneshot();\n+                    let c = Cell::new(c);\n+                    do task::spawn {\n+                        let (dead_ps, dead_cs) = unzip(from_fn(5, |_| oneshot::<()>()));\n+                        let mut ports = dead_ps;\n+                        select(ports); // should get killed; nothing should leak\n+                        c.take().send(()); // must not happen\n+                        // Make sure dead_cs doesn't get closed until after select.\n+                        let _ = dead_cs;\n+                    }\n+                    do task::spawn {\n+                        fail!(); // should kill sibling awake\n+                    }\n+\n+                    // wait for killed selector to close (NOT send on) its c.\n+                    // hope to send 'true'.\n+                    success_c.take().send(p.try_recv().is_none());\n+                }\n+            };\n+            assert!(success_p.recv());\n+        }\n+    }\n+}"}, {"sha": "c4bd0a6d043544c8807002675b6e93fb1ae5f369", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -164,6 +164,7 @@ pub mod trie;\n \n pub mod task;\n pub mod comm;\n+pub mod select;\n pub mod local_data;\n \n "}, {"sha": "c38e6f233130b57cd6f0cfd9a28a28520c8b459a", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -38,7 +38,6 @@\n use prelude::*;\n \n use cell::Cell;\n-use cmp::Eq;\n use comm::{stream, Chan, GenericChan, GenericPort, Port};\n use result::Result;\n use result;"}, {"sha": "e0efc14a8871fbe5970127b985119fdb42b1401f", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 63, "deletions": 129, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -22,10 +22,9 @@\n  *\n  *     A new one of these is created each spawn_linked or spawn_supervised.\n  *\n- * (2) The \"tcb\" is a per-task control structure that tracks a task's spawn\n- *     configuration. It contains a reference to its taskgroup_arc, a\n- *     reference to its node in the ancestor list (below), a flag for\n- *     whether it's part of the 'main'/'root' taskgroup, and an optionally\n+ * (2) The \"taskgroup\" is a per-task control structure that tracks a task's\n+ *     spawn configuration. It contains a reference to its taskgroup_arc, a\n+ *     reference to its node in the ancestor list (below), and an optionally\n  *     configured notification port. These are stored in TLS.\n  *\n  * (3) The \"ancestor_list\" is a cons-style list of unsafe::exclusives which\n@@ -84,7 +83,6 @@ use local_data;\n use task::{Failure, SingleThreaded};\n use task::{Success, TaskOpts, TaskResult};\n use task::unkillable;\n-use to_bytes::IterBytes;\n use uint;\n use util;\n use unstable::sync::Exclusive;\n@@ -101,47 +99,25 @@ use rt::work_queue::WorkQueue;\n #[cfg(test)] use comm;\n #[cfg(test)] use task;\n \n-// Transitionary.\n-#[deriving(Eq)]\n-enum TaskHandle {\n-    NewTask(KillHandle),\n-}\n-\n-impl Clone for TaskHandle {\n-    fn clone(&self) -> TaskHandle {\n-        match *self {\n-            NewTask(ref x) => NewTask(x.clone()),\n-        }\n-    }\n-}\n-\n-impl IterBytes for TaskHandle {\n-    fn iter_bytes(&self, lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n-        match *self {\n-            NewTask(ref x) => x.iter_bytes(lsb0, f),\n-        }\n-    }\n-}\n-\n-struct TaskSet(HashSet<TaskHandle>);\n+struct TaskSet(HashSet<KillHandle>);\n \n impl TaskSet {\n     #[inline]\n     fn new() -> TaskSet {\n         TaskSet(HashSet::new())\n     }\n     #[inline]\n-    fn insert(&mut self, task: TaskHandle) {\n+    fn insert(&mut self, task: KillHandle) {\n         let didnt_overwrite = (**self).insert(task);\n         assert!(didnt_overwrite);\n     }\n     #[inline]\n-    fn remove(&mut self, task: &TaskHandle) {\n+    fn remove(&mut self, task: &KillHandle) {\n         let was_present = (**self).remove(task);\n         assert!(was_present);\n     }\n     #[inline]\n-    fn move_iter(self) -> HashSetMoveIterator<TaskHandle> {\n+    fn move_iter(self) -> HashSetMoveIterator<KillHandle> {\n         (*self).move_iter()\n     }\n }\n@@ -291,7 +267,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                             None => nobe_is_dead\n                         };\n                         // Call iterator block. (If the group is dead, it's\n-                        // safe to skip it. This will leave our TaskHandle\n+                        // safe to skip it. This will leave our KillHandle\n                         // hanging around in the group even after it's freed,\n                         // but that's ok because, by virtue of the group being\n                         // dead, nobody will ever kill-all (for) over it.)\n@@ -338,7 +314,6 @@ pub struct Taskgroup {\n     tasks:      TaskGroupArc, // 'none' means the group has failed.\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n     ancestors:  AncestorList,\n-    is_main:    bool,\n     notifier:   Option<AutoNotify>,\n }\n \n@@ -355,22 +330,26 @@ impl Drop for Taskgroup {\n                     for x in this.notifier.mut_iter() {\n                         x.failed = true;\n                     }\n-                    // Take everybody down with us.\n-                    do access_group(&self.tasks) |tg| {\n-                        kill_taskgroup(tg, &me, self.is_main);\n-                    }\n+                    // Take everybody down with us. After this point, every\n+                    // other task in the group will see 'tg' as none, which\n+                    // indicates the whole taskgroup is failing (and forbids\n+                    // new spawns from succeeding).\n+                    let tg = do access_group(&self.tasks) |tg| { tg.take() };\n+                    // It's safe to send kill signals outside the lock, because\n+                    // we have a refcount on all kill-handles in the group.\n+                    kill_taskgroup(tg, me);\n                 } else {\n                     // Remove ourselves from the group(s).\n                     do access_group(&self.tasks) |tg| {\n-                        leave_taskgroup(tg, &me, true);\n+                        leave_taskgroup(tg, me, true);\n                     }\n                 }\n                 // It doesn't matter whether this happens before or after dealing\n                 // with our own taskgroup, so long as both happen before we die.\n                 // We remove ourself from every ancestor we can, so no cleanup; no\n                 // break.\n                 do each_ancestor(&mut this.ancestors, |_| {}) |ancestor_group| {\n-                    leave_taskgroup(ancestor_group, &me, false);\n+                    leave_taskgroup(ancestor_group, me, false);\n                     true\n                 };\n             }\n@@ -380,7 +359,6 @@ impl Drop for Taskgroup {\n \n pub fn Taskgroup(tasks: TaskGroupArc,\n        ancestors: AncestorList,\n-       is_main: bool,\n        mut notifier: Option<AutoNotify>) -> Taskgroup {\n     for x in notifier.mut_iter() {\n         x.failed = false;\n@@ -389,7 +367,6 @@ pub fn Taskgroup(tasks: TaskGroupArc,\n     Taskgroup {\n         tasks: tasks,\n         ancestors: ancestors,\n-        is_main: is_main,\n         notifier: notifier\n     }\n }\n@@ -413,7 +390,7 @@ fn AutoNotify(chan: Chan<TaskResult>) -> AutoNotify {\n     }\n }\n \n-fn enlist_in_taskgroup(state: TaskGroupInner, me: TaskHandle,\n+fn enlist_in_taskgroup(state: TaskGroupInner, me: KillHandle,\n                            is_member: bool) -> bool {\n     let me = Cell::new(me); // :(\n     // If 'None', the group was failing. Can't enlist.\n@@ -428,8 +405,7 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: TaskHandle,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn leave_taskgroup(state: TaskGroupInner, me: &TaskHandle,\n-                       is_member: bool) {\n+fn leave_taskgroup(state: TaskGroupInner, me: &KillHandle, is_member: bool) {\n     let me = Cell::new(me); // :(\n     // If 'None', already failing and we've already gotten a kill signal.\n     do state.map_mut |group| {\n@@ -442,43 +418,23 @@ fn leave_taskgroup(state: TaskGroupInner, me: &TaskHandle,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn kill_taskgroup(state: TaskGroupInner, me: &TaskHandle, is_main: bool) {\n-    unsafe {\n-        // NB: We could do the killing iteration outside of the group arc, by\n-        // having \"let mut newstate\" here, swapping inside, and iterating\n-        // after. But that would let other exiting tasks fall-through and exit\n-        // while we were trying to kill them, causing potential\n-        // use-after-free. A task's presence in the arc guarantees it's alive\n-        // only while we hold the lock, so if we're failing, all concurrently\n-        // exiting tasks must wait for us. To do it differently, we'd have to\n-        // use the runtime's task refcounting, but that could leave task\n-        // structs around long after their task exited.\n-        let newstate = util::replace(state, None);\n-        // Might already be None, if Somebody is failing simultaneously.\n-        // That's ok; only one task needs to do the dirty work. (Might also\n-        // see 'None' if Somebody already failed and we got a kill signal.)\n-        if newstate.is_some() {\n-            let TaskGroupData { members: members, descendants: descendants } =\n-                newstate.unwrap();\n-            for sibling in members.move_iter() {\n-                // Skip self - killing ourself won't do much good.\n-                if &sibling != me {\n-                    RuntimeGlue::kill_task(sibling);\n-                }\n-            }\n-            for child in descendants.move_iter() {\n-                assert!(&child != me);\n-                RuntimeGlue::kill_task(child);\n+fn kill_taskgroup(state: Option<TaskGroupData>, me: &KillHandle) {\n+    // Might already be None, if somebody is failing simultaneously.\n+    // That's ok; only one task needs to do the dirty work. (Might also\n+    // see 'None' if somebody already failed and we got a kill signal.)\n+    do state.map_move |TaskGroupData { members: members, descendants: descendants }| {\n+        for sibling in members.move_iter() {\n+            // Skip self - killing ourself won't do much good.\n+            if &sibling != me {\n+                RuntimeGlue::kill_task(sibling);\n             }\n-            // Only one task should ever do this.\n-            if is_main {\n-                RuntimeGlue::kill_all_tasks(me);\n-            }\n-            // Do NOT restore state to Some(..)! It stays None to indicate\n-            // that the whole taskgroup is failing, to forbid new spawns.\n         }\n-        // (note: multiple tasks may reach this point)\n-    }\n+        for child in descendants.move_iter() {\n+            assert!(&child != me);\n+            RuntimeGlue::kill_task(child);\n+        }\n+    };\n+    // (note: multiple tasks may reach this point)\n }\n \n // FIXME (#2912): Work around core-vs-coretest function duplication. Can't use\n@@ -490,38 +446,23 @@ fn taskgroup_key() -> local_data::Key<@@mut Taskgroup> {\n // Transitionary.\n struct RuntimeGlue;\n impl RuntimeGlue {\n-    unsafe fn kill_task(task: TaskHandle) {\n-        match task {\n-            NewTask(handle) => {\n-                let mut handle = handle;\n-                do handle.kill().map_move |killed_task| {\n-                    let killed_task = Cell::new(killed_task);\n-                    do Local::borrow::<Scheduler, ()> |sched| {\n-                        sched.enqueue_task(killed_task.take());\n-                    }\n-                };\n+    fn kill_task(handle: KillHandle) {\n+        let mut handle = handle;\n+        do handle.kill().map_move |killed_task| {\n+            let killed_task = Cell::new(killed_task);\n+            do Local::borrow::<Scheduler, ()> |sched| {\n+                sched.enqueue_task(killed_task.take());\n             }\n-        }\n-    }\n-\n-    unsafe fn kill_all_tasks(task: &TaskHandle) {\n-        match *task {\n-            // FIXME(#7544): Remove the kill_all feature entirely once the\n-            // oldsched goes away.\n-            NewTask(ref _handle) => rtabort!(\"can't kill_all in newsched\"),\n-        }\n+        };\n     }\n \n-    fn with_task_handle_and_failing(blk: &fn(TaskHandle, bool)) {\n+    fn with_task_handle_and_failing(blk: &fn(&KillHandle, bool)) {\n         if in_green_task_context() {\n             unsafe {\n                 // Can't use safe borrow, because the taskgroup destructor needs to\n                 // access the scheduler again to send kill signals to other tasks.\n                 let me = Local::unsafe_borrow::<Task>();\n-                // FIXME(#7544): Get rid of this clone by passing by-ref.\n-                // Will probably have to wait until the old rt is gone.\n-                blk(NewTask((*me).death.kill_handle.get_ref().clone()),\n-                    (*me).unwinder.unwinding)\n+                blk((*me).death.kill_handle.get_ref(), (*me).unwinder.unwinding)\n             }\n         } else {\n             rtabort!(\"task dying in bad context\")\n@@ -540,15 +481,12 @@ impl RuntimeGlue {\n                         // Lazily initialize.\n                         let mut members = TaskSet::new();\n                         let my_handle = (*me).death.kill_handle.get_ref().clone();\n-                        members.insert(NewTask(my_handle));\n+                        members.insert(my_handle);\n                         let tasks = Exclusive::new(Some(TaskGroupData {\n                             members: members,\n                             descendants: TaskSet::new(),\n                         }));\n-                        // FIXME(#7544): Remove the is_main flag entirely once\n-                        // the newsched goes away. The main taskgroup has no special\n-                        // behaviour.\n-                        let group = Taskgroup(tasks, AncestorList(None), false, None);\n+                        let group = Taskgroup(tasks, AncestorList(None), None);\n                         (*me).taskgroup = Some(group);\n                         (*me).taskgroup.get_ref()\n                     }\n@@ -563,9 +501,7 @@ impl RuntimeGlue {\n \n // Returns 'None' in the case where the child's TG should be lazily initialized.\n fn gen_child_taskgroup(linked: bool, supervised: bool)\n-    -> Option<(TaskGroupArc, AncestorList, bool)> {\n-    // FIXME(#7544): Not safe to lazily initialize in the old runtime. Remove\n-    // this context check once 'spawn_raw_oldsched' is gone.\n+    -> Option<(TaskGroupArc, AncestorList)> {\n     if linked || supervised {\n         // with_my_taskgroup will lazily initialize the parent's taskgroup if\n         // it doesn't yet exist. We don't want to call it in the unlinked case.\n@@ -574,8 +510,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             if linked {\n                 // Child is in the same group as spawner.\n                 // Child's ancestors are spawner's ancestors.\n-                // Propagate main-ness.\n-                Some((spawner_group.tasks.clone(), ancestors, spawner_group.is_main))\n+                Some((spawner_group.tasks.clone(), ancestors))\n             } else {\n                 // Child is in a separate group from spawner.\n                 let g = Exclusive::new(Some(TaskGroupData {\n@@ -596,7 +531,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                     // Child has no ancestors.\n                     AncestorList(None)\n                 };\n-                Some((g, a, false))\n+                Some((g, a))\n             }\n         }\n     } else {\n@@ -607,15 +542,15 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n // Set up membership in taskgroup and descendantship in all ancestor\n // groups. If any enlistment fails, Some task was already failing, so\n // don't let the child task run, and undo every successful enlistment.\n-fn enlist_many(child: TaskHandle, child_arc: &TaskGroupArc,\n+fn enlist_many(child: &KillHandle, child_arc: &TaskGroupArc,\n                ancestors: &mut AncestorList) -> bool {\n     // Join this taskgroup.\n     let mut result = do access_group(child_arc) |child_tg| {\n         enlist_in_taskgroup(child_tg, child.clone(), true) // member\n     };\n     if result {\n         // Unwinding function in case any ancestral enlisting fails\n-        let bail: &fn(TaskGroupInner) = |tg| { leave_taskgroup(tg, &child, false) };\n+        let bail: &fn(TaskGroupInner) = |tg| { leave_taskgroup(tg, child, false) };\n         // Attempt to join every ancestor group.\n         result = do each_ancestor(ancestors, bail) |ancestor_tg| {\n             // Enlist as a descendant, not as an actual member.\n@@ -625,7 +560,7 @@ fn enlist_many(child: TaskHandle, child_arc: &TaskGroupArc,\n         // If any ancestor group fails, need to exit this group too.\n         if !result {\n             do access_group(child_arc) |child_tg| {\n-                leave_taskgroup(child_tg, &child, true); // member\n+                leave_taskgroup(child_tg, child, true); // member\n             }\n         }\n     }\n@@ -653,15 +588,14 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n         let enlist_success = do child_data.take().map_move_default(true) |child_data| {\n             let child_data = Cell::new(child_data); // :(\n             do Local::borrow::<Task, bool> |me| {\n-                let (child_tg, ancestors, is_main) = child_data.take();\n+                let (child_tg, ancestors) = child_data.take();\n                 let mut ancestors = ancestors;\n-                // FIXME(#7544): Optimize out the xadd in this clone, somehow.\n-                let handle = me.death.kill_handle.get_ref().clone();\n+                let handle = me.death.kill_handle.get_ref();\n                 // Atomically try to get into all of our taskgroups.\n-                if enlist_many(NewTask(handle), &child_tg, &mut ancestors) {\n+                if enlist_many(handle, &child_tg, &mut ancestors) {\n                     // Got in. We can run the provided child body, and can also run\n                     // the taskgroup's exit-time-destructor afterward.\n-                    me.taskgroup = Some(Taskgroup(child_tg, ancestors, is_main, None));\n+                    me.taskgroup = Some(Taskgroup(child_tg, ancestors, None));\n                     true\n                 } else {\n                     false\n@@ -678,14 +612,14 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n         }\n     };\n \n-    let mut task = unsafe {\n-        if opts.sched.mode != SingleThreaded {\n-            if opts.watched {\n-                Task::build_child(opts.stack_size, child_wrapper)\n-            } else {\n-                Task::build_root(opts.stack_size, child_wrapper)\n-            }\n+    let mut task = if opts.sched.mode != SingleThreaded {\n+        if opts.watched {\n+            Task::build_child(opts.stack_size, child_wrapper)\n         } else {\n+            Task::build_root(opts.stack_size, child_wrapper)\n+        }\n+    } else {\n+        unsafe {\n             // Creating a 1:1 task:thread ...\n             let sched = Local::unsafe_borrow::<Scheduler>();\n             let sched_handle = (*sched).make_handle();"}, {"sha": "adbf9fc757819092ca22f21091e4a7a273d8ba87", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02cc6bf0a276115a31354b1c1530e6fe9eb4d58/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=f02cc6bf0a276115a31354b1c1530e6fe9eb4d58", "patch": "@@ -229,20 +229,22 @@ impl<T> Drop for UnsafeAtomicRcBox<T>{\n             if self.data.is_null() {\n                 return; // Happens when destructing an unwrapper's handle.\n             }\n-            do task::unkillable {\n-                let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-                // Must be acquire+release, not just release, to make sure this\n-                // doesn't get reordered to after the unwrapper pointer load.\n-                let old_count = data.count.fetch_sub(1, SeqCst);\n-                assert!(old_count >= 1);\n-                if old_count == 1 {\n-                    // Were we really last, or should we hand off to an\n-                    // unwrapper? It's safe to not xchg because the unwrapper\n-                    // will set the unwrap lock *before* dropping his/her\n-                    // reference. In effect, being here means we're the only\n-                    // *awake* task with the data.\n-                    match data.unwrapper.take(Acquire) {\n-                        Some(~(message,response)) => {\n+            let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+            // Must be acquire+release, not just release, to make sure this\n+            // doesn't get reordered to after the unwrapper pointer load.\n+            let old_count = data.count.fetch_sub(1, SeqCst);\n+            assert!(old_count >= 1);\n+            if old_count == 1 {\n+                // Were we really last, or should we hand off to an\n+                // unwrapper? It's safe to not xchg because the unwrapper\n+                // will set the unwrap lock *before* dropping his/her\n+                // reference. In effect, being here means we're the only\n+                // *awake* task with the data.\n+                match data.unwrapper.take(Acquire) {\n+                    Some(~(message,response)) => {\n+                        let cell = Cell::new((message, response, data));\n+                        do task::unkillable {\n+                            let (message, response, data) = cell.take();\n                             // Send 'ready' and wait for a response.\n                             message.send(());\n                             // Unkillable wait. Message guaranteed to come.\n@@ -253,13 +255,13 @@ impl<T> Drop for UnsafeAtomicRcBox<T>{\n                                 // Other task was killed. drop glue takes over.\n                             }\n                         }\n-                        None => {\n-                            // drop glue takes over.\n-                        }\n                     }\n-                } else {\n-                    cast::forget(data);\n+                    None => {\n+                        // drop glue takes over.\n+                    }\n                 }\n+            } else {\n+                cast::forget(data);\n             }\n         }\n     }"}]}