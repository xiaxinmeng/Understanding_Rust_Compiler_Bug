{"sha": "b8a52e3a4ba9549edb71836561be13e73a8a50a7", "node_id": "C_kwDOAAsO6NoAKGI4YTUyZTNhNGJhOTU0OWVkYjcxODM2NTYxYmUxM2U3M2E4YTUwYTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-03T21:25:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-03T21:25:45Z"}, "message": "Auto merge of #105218 - matthiaskrgr:rollup-8d3k08n, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #104199 (Keep track of the start of the argument block of a closure)\n - #105050 (Remove useless borrows and derefs)\n - #105153 (Create a hacky fail-fast mode that stops tests at the first failure)\n - #105164 (Restore `use` suggestion for `dyn` method call requiring `Sized`)\n - #105193 (Disable coverage instrumentation for naked functions)\n - #105200 (Remove useless filter in unused extern crate check.)\n - #105201 (Do not call fn_sig on non-functions.)\n - #105208 (Add AmbiguityError for inconsistent resolution for an import)\n - #105214 (update Miri)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "acf5fbcc8f5f80901a68b404f43c38b4ab923130", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acf5fbcc8f5f80901a68b404f43c38b4ab923130"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8a52e3a4ba9549edb71836561be13e73a8a50a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8a52e3a4ba9549edb71836561be13e73a8a50a7", "html_url": "https://github.com/rust-lang/rust/commit/b8a52e3a4ba9549edb71836561be13e73a8a50a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8a52e3a4ba9549edb71836561be13e73a8a50a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23415176968e81e0aac92d0218612a89c4e68a82", "url": "https://api.github.com/repos/rust-lang/rust/commits/23415176968e81e0aac92d0218612a89c4e68a82", "html_url": "https://github.com/rust-lang/rust/commit/23415176968e81e0aac92d0218612a89c4e68a82"}, {"sha": "8be329de01bddbb6080a8f5c5234bf77a637a817", "url": "https://api.github.com/repos/rust-lang/rust/commits/8be329de01bddbb6080a8f5c5234bf77a637a817", "html_url": "https://github.com/rust-lang/rust/commit/8be329de01bddbb6080a8f5c5234bf77a637a817"}], "stats": {"total": 2611, "additions": 1470, "deletions": 1141}, "files": [{"sha": "940a4f82ddca7bc2d7fb6eaba14d96b7e72f43c4", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -5356,9 +5356,9 @@ checksum = \"56dee185309b50d1f11bfedef0fe6d036842e3fb77413abef29f8f8d1c5d4c1c\"\n \n [[package]]\n name = \"ui_test\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf4559da3fe6b481f8674a29379677cb9606cd6f75fc254a2c9834c55638503d\"\n+checksum = \"54ddb6f31025943e2f9d59237f433711c461a43d9415974c3eb3a4902edc1c1f\"\n dependencies = [\n  \"bstr 1.0.1\",\n  \"cargo_metadata 0.15.0\","}, {"sha": "9c2cf58efed4a30ef37d0f522a1b6d6ba96c6e03", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -354,7 +354,7 @@ pub trait LayoutCalculator {\n                 if !always_sized { StructKind::MaybeUnsized } else { StructKind::AlwaysSized }\n             };\n \n-            let mut st = self.univariant(dl, &variants[v], &repr, kind)?;\n+            let mut st = self.univariant(dl, &variants[v], repr, kind)?;\n             st.variants = Variants::Single { index: v };\n \n             if is_unsafe_cell {\n@@ -457,7 +457,7 @@ pub trait LayoutCalculator {\n             let mut variant_layouts = variants\n                 .iter_enumerated()\n                 .map(|(j, v)| {\n-                    let mut st = self.univariant(dl, v, &repr, StructKind::AlwaysSized)?;\n+                    let mut st = self.univariant(dl, v, repr, StructKind::AlwaysSized)?;\n                     st.variants = Variants::Single { index: j };\n \n                     align = align.max(st.align);\n@@ -647,8 +647,8 @@ pub trait LayoutCalculator {\n             .map(|(i, field_layouts)| {\n                 let mut st = self.univariant(\n                     dl,\n-                    &field_layouts,\n-                    &repr,\n+                    field_layouts,\n+                    repr,\n                     StructKind::Prefixed(min_ity.size(), prefix_align),\n                 )?;\n                 st.variants = Variants::Single { index: i };\n@@ -755,7 +755,7 @@ pub trait LayoutCalculator {\n             // Try to use a ScalarPair for all tagged enums.\n             let mut common_prim = None;\n             let mut common_prim_initialized_in_all_variants = true;\n-            for (field_layouts, layout_variant) in iter::zip(&*variants, &layout_variants) {\n+            for (field_layouts, layout_variant) in iter::zip(variants, &layout_variants) {\n                 let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n                     panic!();\n                 };"}, {"sha": "4d80f904ac461beafd03f212c83931e981fa1cff", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1179,7 +1179,7 @@ impl Expr {\n     pub fn peel_parens(&self) -> &Expr {\n         let mut expr = self;\n         while let ExprKind::Paren(inner) = &expr.kind {\n-            expr = &inner;\n+            expr = inner;\n         }\n         expr\n     }\n@@ -1312,8 +1312,10 @@ pub struct Closure {\n     pub movability: Movability,\n     pub fn_decl: P<FnDecl>,\n     pub body: P<Expr>,\n-    /// The span of the argument block `|...|`.\n+    /// The span of the declaration block: 'move |...| -> ...'\n     pub fn_decl_span: Span,\n+    /// The span of the argument block `|...|`\n+    pub fn_arg_span: Span,\n }\n \n /// Limit types of a range (inclusive or exclusive)\n@@ -2027,7 +2029,7 @@ impl Ty {\n     pub fn peel_refs(&self) -> &Self {\n         let mut final_ty = self;\n         while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n-            final_ty = &ty;\n+            final_ty = ty;\n         }\n         final_ty\n     }"}, {"sha": "a45ee6067bbaedb5c541d91dd2ccff91f23228e1", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -736,8 +736,7 @@ pub fn visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n             return; // Avoid visiting the span for the second time.\n         }\n         token::Interpolated(nt) => {\n-            let mut nt = Lrc::make_mut(nt);\n-            visit_nonterminal(&mut nt, vis);\n+            visit_nonterminal(Lrc::make_mut(nt), vis);\n         }\n         _ => {}\n     }\n@@ -1368,6 +1367,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             fn_decl,\n             body,\n             fn_decl_span,\n+            fn_arg_span: _,\n         }) => {\n             vis.visit_closure_binder(binder);\n             vis.visit_asyncness(asyncness);"}, {"sha": "482c302950f01ae7e20b16002afb4b4e114e97f1", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -64,7 +64,7 @@ impl TokenTree {\n         match (self, other) {\n             (TokenTree::Token(token, _), TokenTree::Token(token2, _)) => token.kind == token2.kind,\n             (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n-                delim == delim2 && tts.eq_unspanned(&tts2)\n+                delim == delim2 && tts.eq_unspanned(tts2)\n             }\n             _ => false,\n         }\n@@ -402,7 +402,7 @@ impl TokenStream {\n         let mut t1 = self.trees();\n         let mut t2 = other.trees();\n         for (t1, t2) in iter::zip(&mut t1, &mut t2) {\n-            if !t1.eq_unspanned(&t2) {\n+            if !t1.eq_unspanned(t2) {\n                 return false;\n             }\n         }\n@@ -475,7 +475,7 @@ impl TokenStream {\n             token::Interpolated(nt) => TokenTree::Delimited(\n                 DelimSpan::from_single(token.span),\n                 Delimiter::Invisible,\n-                TokenStream::from_nonterminal_ast(&nt).flattened(),\n+                TokenStream::from_nonterminal_ast(nt).flattened(),\n             ),\n             _ => TokenTree::Token(token.clone(), spacing),\n         }\n@@ -511,7 +511,7 @@ impl TokenStream {\n     fn try_glue_to_last(vec: &mut Vec<TokenTree>, tt: &TokenTree) -> bool {\n         if let Some(TokenTree::Token(last_tok, Spacing::Joint)) = vec.last()\n             && let TokenTree::Token(tok, spacing) = tt\n-            && let Some(glued_tok) = last_tok.glue(&tok)\n+            && let Some(glued_tok) = last_tok.glue(tok)\n         {\n             // ...then overwrite the last token tree in `vec` with the\n             // glued token, and skip the first token tree from `stream`."}, {"sha": "35454c3a6709224ce20ca3a20d2d915824047895", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -110,7 +110,7 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         } else {\n             &mut lines\n         };\n-        if let Some(horizontal) = get_horizontal_trim(&lines, kind) {\n+        if let Some(horizontal) = get_horizontal_trim(lines, kind) {\n             changes = true;\n             // remove a \"[ \\t]*\\*\" block from each line, if possible\n             for line in lines.iter_mut() {\n@@ -147,7 +147,7 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n \n fn trim_whitespace_prefix(s: &str, col: CharPos) -> &str {\n     let len = s.len();\n-    match all_whitespace(&s, col) {\n+    match all_whitespace(s, col) {\n         Some(col) => {\n             if col < len {\n                 &s[col..]"}, {"sha": "f6f186b51073b788d46438e87583c6afbcb755bc", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -52,14 +52,14 @@ impl LitKind {\n                 // new symbol because the string in the LitKind is different to the\n                 // string in the token.\n                 let s = symbol.as_str();\n-                let symbol = if s.contains(&['\\\\', '\\r']) {\n+                let symbol = if s.contains(['\\\\', '\\r']) {\n                     let mut buf = String::with_capacity(s.len());\n                     let mut error = Ok(());\n                     // Force-inlining here is aggressive but the closure is\n                     // called on every char in the string, so it can be\n                     // hot in programs with many long strings.\n                     unescape_literal(\n-                        &s,\n+                        s,\n                         Mode::Str,\n                         &mut #[inline(always)]\n                         |_, unescaped_char| match unescaped_char {\n@@ -85,7 +85,7 @@ impl LitKind {\n                     if s.contains('\\r') {\n                         let mut buf = String::with_capacity(s.len());\n                         let mut error = Ok(());\n-                        unescape_literal(&s, Mode::RawStr, &mut |_, unescaped_char| {\n+                        unescape_literal(s, Mode::RawStr, &mut |_, unescaped_char| {\n                             match unescaped_char {\n                                 Ok(c) => buf.push(c),\n                                 Err(err) => {\n@@ -106,7 +106,7 @@ impl LitKind {\n                 let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n                 let mut error = Ok(());\n-                unescape_literal(&s, Mode::ByteStr, &mut |_, c| match c {\n+                unescape_literal(s, Mode::ByteStr, &mut |_, c| match c {\n                     Ok(c) => buf.push(byte_from_char(c)),\n                     Err(err) => {\n                         if err.is_fatal() {\n@@ -122,7 +122,7 @@ impl LitKind {\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n                     let mut error = Ok(());\n-                    unescape_literal(&s, Mode::RawByteStr, &mut |_, c| match c {\n+                    unescape_literal(s, Mode::RawByteStr, &mut |_, c| match c {\n                         Ok(c) => buf.push(byte_from_char(c)),\n                         Err(err) => {\n                             if err.is_fatal() {"}, {"sha": "819f1884a06922ca5861679de032dde2b2db47a7", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -384,7 +384,7 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n         | ast::ExprKind::AssignOp(_, lhs, rhs)\n         | ast::ExprKind::Binary(_, lhs, rhs) => {\n             // X { y: 1 } + X { y: 2 }\n-            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+            contains_exterior_struct_lit(lhs) || contains_exterior_struct_lit(rhs)\n         }\n         ast::ExprKind::Await(x)\n         | ast::ExprKind::Unary(_, x)\n@@ -393,12 +393,12 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n         | ast::ExprKind::Field(x, _)\n         | ast::ExprKind::Index(x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n-            contains_exterior_struct_lit(&x)\n+            contains_exterior_struct_lit(x)\n         }\n \n         ast::ExprKind::MethodCall(box ast::MethodCall { receiver, .. }) => {\n             // X { y: 1 }.bar(...)\n-            contains_exterior_struct_lit(&receiver)\n+            contains_exterior_struct_lit(receiver)\n         }\n \n         _ => false,"}, {"sha": "0eae791b25e1c66e8da0b93bdfefa0ce7c5585bb", "filename": "compiler/rustc_ast/src/util/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -17,7 +17,7 @@ pub fn contains_text_flow_control_chars(s: &str) -> bool {\n     // U+2069 - E2 81 A9\n     let mut bytes = s.as_bytes();\n     loop {\n-        match core::slice::memchr::memchr(0xE2, &bytes) {\n+        match core::slice::memchr::memchr(0xE2, bytes) {\n             Some(idx) => {\n                 // bytes are valid UTF-8 -> E2 must be followed by two bytes\n                 let ch = &bytes[idx..idx + 3];"}, {"sha": "991eb489f6ba3ee115fbf7f8b8dcf691226adf48", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -840,6 +840,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             fn_decl,\n             body,\n             fn_decl_span: _,\n+            fn_arg_span: _,\n         }) => {\n             visitor.visit_fn(FnKind::Closure(binder, fn_decl, body), expression.span, expression.id)\n         }"}, {"sha": "4260805f1dd1fdfed90cdc8cce97aa605b2f8965", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -176,6 +176,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     fn_decl,\n                     body,\n                     fn_decl_span,\n+                    fn_arg_span,\n                 }) => {\n                     if let Async::Yes { closure_id, .. } = asyncness {\n                         self.lower_expr_async_closure(\n@@ -186,6 +187,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             fn_decl,\n                             body,\n                             *fn_decl_span,\n+                            *fn_arg_span,\n                         )\n                     } else {\n                         self.lower_expr_closure(\n@@ -196,6 +198,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             fn_decl,\n                             body,\n                             *fn_decl_span,\n+                            *fn_arg_span,\n                         )\n                     }\n                 }\n@@ -642,6 +645,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: self.lower_span(span),\n+                fn_arg_span: None,\n                 movability: Some(hir::Movability::Static),\n             });\n \n@@ -898,6 +902,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n+        fn_arg_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         let (binder_clause, generic_params) = self.lower_closure_binder(binder);\n \n@@ -928,6 +933,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             fn_decl,\n             body: body_id,\n             fn_decl_span: self.lower_span(fn_decl_span),\n+            fn_arg_span: Some(self.lower_span(fn_arg_span)),\n             movability: generator_option,\n         });\n \n@@ -984,6 +990,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n+        fn_arg_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         if let &ClosureBinder::For { span, .. } = binder {\n             self.tcx.sess.emit_err(NotSupportedForLifetimeBinderAsyncClosure { span });\n@@ -1038,6 +1045,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             fn_decl,\n             body,\n             fn_decl_span: self.lower_span(fn_decl_span),\n+            fn_arg_span: Some(self.lower_span(fn_arg_span)),\n             movability: None,\n         });\n         hir::ExprKind::Closure(c)"}, {"sha": "d3d8431c163c728efa42dd52a248c6f692271a84", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -519,7 +519,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             ast::MetaItemKind::List(items) => {\n                 self.print_path(&item.path, false, 0);\n                 self.popen();\n-                self.commasep(Consistent, &items, |s, i| s.print_meta_list_item(i));\n+                self.commasep(Consistent, items, |s, i| s.print_meta_list_item(i));\n                 self.pclose();\n             }\n         }\n@@ -536,7 +536,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_tt(&mut self, tt: &TokenTree, convert_dollar_crate: bool) {\n         match tt {\n             TokenTree::Token(token, _) => {\n-                let token_str = self.token_to_string_ext(&token, convert_dollar_crate);\n+                let token_str = self.token_to_string_ext(token, convert_dollar_crate);\n                 self.word(token_str);\n                 if let token::DocComment(..) = token.kind {\n                     self.hardbreak()\n@@ -998,7 +998,7 @@ impl<'a> State<'a> {\n             ast::AssocConstraintKind::Bound { bounds } => {\n                 if !bounds.is_empty() {\n                     self.word_nbsp(\":\");\n-                    self.print_type_bounds(&bounds);\n+                    self.print_type_bounds(bounds);\n                 }\n             }\n         }\n@@ -1035,7 +1035,7 @@ impl<'a> State<'a> {\n             }\n             ast::TyKind::Tup(elts) => {\n                 self.popen();\n-                self.commasep(Inconsistent, &elts, |s, ty| s.print_type(ty));\n+                self.commasep(Inconsistent, elts, |s, ty| s.print_type(ty));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n@@ -1254,7 +1254,7 @@ impl<'a> State<'a> {\n \n         self.popen();\n         self.commasep(Consistent, &args, |s, arg| match arg {\n-            AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n+            AsmArg::Template(template) => s.print_string(template, ast::StrStyle::Cooked),\n             AsmArg::Operand(op) => {\n                 let print_reg_or_class = |s: &mut Self, r: &InlineAsmRegOrRegClass| match r {\n                     InlineAsmRegOrRegClass::Reg(r) => s.print_symbol(*r, ast::StrStyle::Cooked),\n@@ -1424,11 +1424,11 @@ impl<'a> State<'a> {\n                     self.print_path(path, true, 0);\n                 }\n                 self.popen();\n-                self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n+                self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                 self.pclose();\n             }\n             PatKind::Or(pats) => {\n-                self.strsep(\"|\", true, Inconsistent, &pats, |s, p| s.print_pat(p));\n+                self.strsep(\"|\", true, Inconsistent, pats, |s, p| s.print_pat(p));\n             }\n             PatKind::Path(None, path) => {\n                 self.print_path(path, true, 0);\n@@ -1450,7 +1450,7 @@ impl<'a> State<'a> {\n                 }\n                 self.commasep_cmnt(\n                     Consistent,\n-                    &fields,\n+                    fields,\n                     |s, f| {\n                         s.cbox(INDENT_UNIT);\n                         if !f.is_shorthand {\n@@ -1475,7 +1475,7 @@ impl<'a> State<'a> {\n             }\n             PatKind::Tuple(elts) => {\n                 self.popen();\n-                self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n+                self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n@@ -1498,7 +1498,7 @@ impl<'a> State<'a> {\n                     self.print_pat(inner);\n                 }\n             }\n-            PatKind::Lit(e) => self.print_expr(&**e),\n+            PatKind::Lit(e) => self.print_expr(e),\n             PatKind::Range(begin, end, Spanned { node: end_kind, .. }) => {\n                 if let Some(e) = begin {\n                     self.print_expr(e);\n@@ -1514,7 +1514,7 @@ impl<'a> State<'a> {\n             }\n             PatKind::Slice(elts) => {\n                 self.word(\"[\");\n-                self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n+                self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                 self.word(\"]\");\n             }\n             PatKind::Rest => self.word(\"..\"),\n@@ -1600,7 +1600,7 @@ impl<'a> State<'a> {\n \n         self.word(\"<\");\n \n-        self.commasep(Inconsistent, &generic_params, |s, param| {\n+        self.commasep(Inconsistent, generic_params, |s, param| {\n             s.print_outer_attributes_inline(&param.attrs);\n \n             match &param.kind {"}, {"sha": "4ed16e337d297483ce5cec9d914ef69c03313a10", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -305,10 +305,10 @@ impl<'a> State<'a> {\n                 self.print_expr_tup(exprs);\n             }\n             ast::ExprKind::Call(func, args) => {\n-                self.print_expr_call(func, &args);\n+                self.print_expr_call(func, args);\n             }\n             ast::ExprKind::MethodCall(box ast::MethodCall { seg, receiver, args, .. }) => {\n-                self.print_expr_method_call(seg, &receiver, &args);\n+                self.print_expr_method_call(seg, receiver, args);\n             }\n             ast::ExprKind::Binary(op, lhs, rhs) => {\n                 self.print_expr_binary(*op, lhs, rhs);\n@@ -402,6 +402,7 @@ impl<'a> State<'a> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: _,\n+                fn_arg_span: _,\n             }) => {\n                 self.print_closure_binder(binder);\n                 self.print_movability(*movability);\n@@ -605,7 +606,7 @@ impl<'a> State<'a> {\n         match binder {\n             ast::ClosureBinder::NotPresent => {}\n             ast::ClosureBinder::For { generic_params, .. } => {\n-                self.print_formal_generic_params(&generic_params)\n+                self.print_formal_generic_params(generic_params)\n             }\n         }\n     }"}, {"sha": "f3bdacf6085552109871140a10cacd1e2757d24b", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -258,13 +258,12 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n         OptimizeAttr::Speed => {}\n     }\n \n-    let inline = if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-        InlineAttr::Never\n-    } else if codegen_fn_attrs.inline == InlineAttr::None && instance.def.requires_inline(cx.tcx) {\n-        InlineAttr::Hint\n-    } else {\n-        codegen_fn_attrs.inline\n-    };\n+    let inline =\n+        if codegen_fn_attrs.inline == InlineAttr::None && instance.def.requires_inline(cx.tcx) {\n+            InlineAttr::Hint\n+        } else {\n+            codegen_fn_attrs.inline\n+        };\n     to_add.extend(inline_attr(cx, inline));\n \n     // The `uwtable` attribute according to LLVM is:"}, {"sha": "76a1288e6d3512622ea743779239605942bf82cf", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -72,7 +72,7 @@ impl<'a, T: PartialOrd> PartialOrd for Interned<'a, T> {\n         if ptr::eq(self.0, other.0) {\n             Some(Ordering::Equal)\n         } else {\n-            let res = self.0.partial_cmp(&other.0);\n+            let res = self.0.partial_cmp(other.0);\n             debug_assert_ne!(res, Some(Ordering::Equal));\n             res\n         }\n@@ -86,7 +86,7 @@ impl<'a, T: Ord> Ord for Interned<'a, T> {\n         if ptr::eq(self.0, other.0) {\n             Ordering::Equal\n         } else {\n-            let res = self.0.cmp(&other.0);\n+            let res = self.0.cmp(other.0);\n             debug_assert_ne!(res, Ordering::Equal);\n             res\n         }"}, {"sha": "3d44e17f31d1fb81ed10f0bf3fb4f0745283a614", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -36,7 +36,7 @@ impl Deref for Mmap {\n \n     #[inline]\n     fn deref(&self) -> &[u8] {\n-        &*self.0\n+        &self.0\n     }\n }\n \n@@ -102,13 +102,13 @@ impl Deref for MmapMut {\n \n     #[inline]\n     fn deref(&self) -> &[u8] {\n-        &*self.0\n+        &self.0\n     }\n }\n \n impl DerefMut for MmapMut {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut [u8] {\n-        &mut *self.0\n+        &mut self.0\n     }\n }"}, {"sha": "980a540ccba7a5c0758f954cabd9cc5b8fc4a05a", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -899,25 +899,25 @@ unsafe impl<O, T: ?Sized> StableAddress for OwningRef<O, T> {}\n \n impl<O, T: ?Sized> AsRef<T> for OwningRef<O, T> {\n     fn as_ref(&self) -> &T {\n-        &*self\n+        self\n     }\n }\n \n impl<O, T: ?Sized> AsRef<T> for OwningRefMut<O, T> {\n     fn as_ref(&self) -> &T {\n-        &*self\n+        self\n     }\n }\n \n impl<O, T: ?Sized> AsMut<T> for OwningRefMut<O, T> {\n     fn as_mut(&mut self) -> &mut T {\n-        &mut *self\n+        self\n     }\n }\n \n impl<O, T: ?Sized> Borrow<T> for OwningRef<O, T> {\n     fn borrow(&self) -> &T {\n-        &*self\n+        self\n     }\n }\n \n@@ -1021,7 +1021,7 @@ where\n     T: PartialEq,\n {\n     fn eq(&self, other: &Self) -> bool {\n-        (&*self as &T).eq(&*other as &T)\n+        self.deref().eq(other.deref())\n     }\n }\n \n@@ -1032,7 +1032,7 @@ where\n     T: PartialOrd,\n {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        (&*self as &T).partial_cmp(&*other as &T)\n+        self.deref().partial_cmp(other.deref())\n     }\n }\n \n@@ -1041,7 +1041,7 @@ where\n     T: Ord,\n {\n     fn cmp(&self, other: &Self) -> Ordering {\n-        (&*self as &T).cmp(&*other as &T)\n+        self.deref().cmp(other.deref())\n     }\n }\n \n@@ -1050,7 +1050,7 @@ where\n     T: Hash,\n {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        (&*self as &T).hash(state);\n+        self.deref().hash(state);\n     }\n }\n \n@@ -1059,7 +1059,7 @@ where\n     T: PartialEq,\n {\n     fn eq(&self, other: &Self) -> bool {\n-        (&*self as &T).eq(&*other as &T)\n+        self.deref().eq(other.deref())\n     }\n }\n \n@@ -1070,7 +1070,7 @@ where\n     T: PartialOrd,\n {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        (&*self as &T).partial_cmp(&*other as &T)\n+        self.deref().partial_cmp(other.deref())\n     }\n }\n \n@@ -1079,7 +1079,7 @@ where\n     T: Ord,\n {\n     fn cmp(&self, other: &Self) -> Ordering {\n-        (&*self as &T).cmp(&*other as &T)\n+        self.deref().cmp(other.deref())\n     }\n }\n \n@@ -1088,7 +1088,7 @@ where\n     T: Hash,\n {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        (&*self as &T).hash(state);\n+        self.deref().hash(state);\n     }\n }\n "}, {"sha": "aa7a01eed15c9a1438dbfb133632091fc4018a02", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -192,7 +192,7 @@ impl SelfProfilerRef {\n             F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>,\n         {\n             let profiler = profiler_ref.profiler.as_ref().unwrap();\n-            f(&**profiler)\n+            f(profiler)\n         }\n \n         if self.event_filter_mask.contains(event_filter) {\n@@ -466,7 +466,7 @@ impl SelfProfilerRef {\n \n     pub fn with_profiler(&self, f: impl FnOnce(&SelfProfiler)) {\n         if let Some(profiler) = &self.profiler {\n-            f(&profiler)\n+            f(profiler)\n         }\n     }\n \n@@ -733,7 +733,7 @@ impl Drop for VerboseTimingGuard<'_> {\n         if let Some((start_time, start_rss, ref message)) = self.start_and_message {\n             let end_rss = get_resident_set_size();\n             let dur = start_time.elapsed();\n-            print_time_passes_entry(&message, dur, start_rss, end_rss);\n+            print_time_passes_entry(message, dur, start_rss, end_rss);\n         }\n     }\n }"}, {"sha": "cd392a7b678b66ee470e2b36cf8fda14aec9247b", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -366,7 +366,7 @@ impl<CTX> HashStable<CTX> for [u8] {\n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n     #[inline]\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        (&self[..]).hash_stable(ctx, hasher);\n+        self[..].hash_stable(ctx, hasher);\n     }\n }\n \n@@ -405,7 +405,7 @@ where\n {\n     #[inline]\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        (&self[..]).hash_stable(ctx, hasher);\n+        self[..].hash_stable(ctx, hasher);\n     }\n }\n \n@@ -440,7 +440,7 @@ impl<CTX> HashStable<CTX> for str {\n impl<CTX> HashStable<CTX> for String {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        (&self[..]).hash_stable(hcx, hasher);\n+        self[..].hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "e4f47b22ac3584d5336ed0d42d5c030f2e82872e", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -201,7 +201,7 @@ cfg_if! {\n \n             #[inline(always)]\n             fn deref(&self) -> &T {\n-                &*self.0\n+                &self.0\n             }\n         }\n "}, {"sha": "d8879bf70ed39730ee41f5029b51f096b17278b2", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -39,7 +39,7 @@ impl Translate for AnnotateSnippetEmitterWriter {\n     }\n \n     fn fallback_fluent_bundle(&self) -> &FluentBundle {\n-        &**self.fallback_bundle\n+        &self.fallback_bundle\n     }\n }\n \n@@ -49,7 +49,7 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(diag, &fluent_args);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n             &mut primary_span,\n@@ -65,7 +65,7 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n             &diag.code,\n             &primary_span,\n             &children,\n-            &suggestions,\n+            suggestions,\n         );\n     }\n "}, {"sha": "06bb5edc090f48c8b6c326961982ce9730aa6957", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -292,7 +292,7 @@ impl Diagnostic {\n             let lint_index = expectation_id.get_lint_index();\n             expectation_id.set_lint_index(None);\n             let mut stable_id = unstable_to_stable\n-                .get(&expectation_id)\n+                .get(expectation_id)\n                 .expect(\"each unstable `LintExpectationId` must have a matching stable id\")\n                 .normalize();\n "}, {"sha": "db595df8ec18c8cfc2c8c5428996a4bfda4febde", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -283,7 +283,7 @@ pub trait Emitter: Translate {\n                         if self\n                             .source_map()\n                             .map(|sm| is_case_difference(\n-                                &**sm,\n+                                sm,\n                                 substitution,\n                                 sugg.substitutions[0].parts[0].span,\n                             ))\n@@ -525,7 +525,7 @@ impl Translate for EmitterWriter {\n     }\n \n     fn fallback_fluent_bundle(&self) -> &FluentBundle {\n-        &**self.fallback_bundle\n+        &self.fallback_bundle\n     }\n }\n \n@@ -538,7 +538,7 @@ impl Emitter for EmitterWriter {\n         let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(diag, &fluent_args);\n         debug!(\"emit_diagnostic: suggestions={:?}\", suggestions);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n@@ -555,7 +555,7 @@ impl Emitter for EmitterWriter {\n             &diag.code,\n             &primary_span,\n             &children,\n-            &suggestions,\n+            suggestions,\n             self.track_diagnostics.then_some(&diag.emitted_at),\n         );\n     }\n@@ -801,7 +801,7 @@ impl EmitterWriter {\n         }\n \n         let source_string = match file.get_line(line.line_index - 1) {\n-            Some(s) => normalize_whitespace(&*s),\n+            Some(s) => normalize_whitespace(&s),\n             None => return Vec::new(),\n         };\n \n@@ -1148,7 +1148,7 @@ impl EmitterWriter {\n                 (pos + 2, annotation.start_col.saturating_sub(left))\n             };\n             if let Some(ref label) = annotation.label {\n-                buffer.puts(line_offset + pos, code_offset + col, &label, style);\n+                buffer.puts(line_offset + pos, code_offset + col, label, style);\n             }\n         }\n \n@@ -1358,7 +1358,7 @@ impl EmitterWriter {\n             // only render error codes, not lint codes\n             if let Some(DiagnosticId::Error(ref code)) = *code {\n                 buffer.append(0, \"[\", Style::Level(*level));\n-                buffer.append(0, &code, Style::Level(*level));\n+                buffer.append(0, code, Style::Level(*level));\n                 buffer.append(0, \"]\", Style::Level(*level));\n                 label_width += 2 + code.len();\n             }\n@@ -1683,7 +1683,7 @@ impl EmitterWriter {\n         };\n \n         // Render the replacements for each suggestion\n-        let suggestions = suggestion.splice_lines(&**sm);\n+        let suggestions = suggestion.splice_lines(sm);\n         debug!(\"emit_suggestion_default: suggestions={:?}\", suggestions);\n \n         if suggestions.is_empty() {\n@@ -1784,7 +1784,7 @@ impl EmitterWriter {\n                     buffer.puts(\n                         row_num - 1 + line - line_start,\n                         max_line_num_len + 3,\n-                        &normalize_whitespace(&*file_lines.file.get_line(line - 1).unwrap()),\n+                        &normalize_whitespace(&file_lines.file.get_line(line - 1).unwrap()),\n                         Style::Removal,\n                     );\n                 }\n@@ -1926,7 +1926,7 @@ impl EmitterWriter {\n                             buffer.putc(\n                                 row_num,\n                                 (padding as isize + p) as usize,\n-                                if part.is_addition(&sm) { '+' } else { '~' },\n+                                if part.is_addition(sm) { '+' } else { '~' },\n                                 Style::Addition,\n                             );\n                         }\n@@ -1973,7 +1973,7 @@ impl EmitterWriter {\n             buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n         } else if notice_capitalization {\n             let msg = \"notice the capitalization difference\";\n-            buffer.puts(row_num, max_line_num_len + 3, &msg, Style::NoStyle);\n+            buffer.puts(row_num, max_line_num_len + 3, msg, Style::NoStyle);\n         }\n         emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         Ok(())\n@@ -2028,7 +2028,7 @@ impl EmitterWriter {\n                     for child in children {\n                         let span = child.render_span.as_ref().unwrap_or(&child.span);\n                         if let Err(err) = self.emit_message_default(\n-                            &span,\n+                            span,\n                             &child.message,\n                             args,\n                             &None,\n@@ -2113,7 +2113,7 @@ impl EmitterWriter {\n                 *row_num - 1,\n                 max_line_num_len + 3,\n                 &normalize_whitespace(\n-                    &*file_lines.file.get_line(file_lines.lines[line_pos].line_index).unwrap(),\n+                    &file_lines.file.get_line(file_lines.lines[line_pos].line_index).unwrap(),\n                 ),\n                 Style::NoStyle,\n             );"}, {"sha": "a37073d8fa32a5a653bdce4cc2280429e4cbb4b3", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -136,7 +136,7 @@ impl Translate for JsonEmitter {\n     }\n \n     fn fallback_fluent_bundle(&self) -> &FluentBundle {\n-        &**self.fallback_bundle\n+        &self.fallback_bundle\n     }\n }\n "}, {"sha": "6176120b3016bfe31e97b12b505a5c8977a25383", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1328,7 +1328,7 @@ impl HandlerInner {\n \n             diagnostic.children.drain_filter(already_emitted_sub).for_each(|_| {});\n \n-            self.emitter.emit_diagnostic(&diagnostic);\n+            self.emitter.emit_diagnostic(diagnostic);\n             if diagnostic.is_error() {\n                 self.deduplicated_err_count += 1;\n             } else if let Warning(_) = diagnostic.level {"}, {"sha": "afd660ff1bf1fb6c13d70c6a385243e8c0294f33", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -59,21 +59,21 @@ pub trait Translate {\n         trace!(?message, ?args);\n         let (identifier, attr) = match message {\n             DiagnosticMessage::Str(msg) | DiagnosticMessage::Eager(msg) => {\n-                return Cow::Borrowed(&msg);\n+                return Cow::Borrowed(msg);\n             }\n             DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n         };\n \n         let translate_with_bundle = |bundle: &'a FluentBundle| -> Option<(Cow<'_, str>, Vec<_>)> {\n-            let message = bundle.get_message(&identifier)?;\n+            let message = bundle.get_message(identifier)?;\n             let value = match attr {\n                 Some(attr) => message.get_attribute(attr)?.value(),\n                 None => message.value()?,\n             };\n             debug!(?message, ?value);\n \n             let mut errs = vec![];\n-            let translated = bundle.format_pattern(value, Some(&args), &mut errs);\n+            let translated = bundle.format_pattern(value, Some(args), &mut errs);\n             debug!(?translated, ?errs);\n             Some((translated, errs))\n         };"}, {"sha": "4812bdd9dd8b9c50097fab9ebaa332a65f896bc5", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -539,6 +539,9 @@ impl<'a> ExtCtxt<'a> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: span,\n+                // FIXME(SarthakSingh31): This points to the start of the declaration block and\n+                // not the span of the argument block.\n+                fn_arg_span: span,\n             })),\n         )\n     }"}, {"sha": "a7dfce3b9b8fce1ed528e61df14fc8cad1a2a699", "filename": "compiler/rustc_fs_util/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -65,7 +65,7 @@ pub enum LinkOrCopy {\n pub fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<LinkOrCopy> {\n     let p = p.as_ref();\n     let q = q.as_ref();\n-    match fs::remove_file(&q) {\n+    match fs::remove_file(q) {\n         Ok(()) => (),\n         Err(err) if err.kind() == io::ErrorKind::NotFound => (),\n         Err(err) => return Err(err),"}, {"sha": "1f8268cc17c539b813021c21f1f1c88fd2689bdc", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -410,7 +410,7 @@ impl<'a> Id<'a> {\n     }\n \n     pub fn as_slice(&'a self) -> &'a str {\n-        &*self.name\n+        &self.name\n     }\n }\n \n@@ -515,7 +515,7 @@ impl<'a> LabelText<'a> {\n     pub fn to_dot_string(&self) -> String {\n         match *self {\n             LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),\n-            EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(&s)),\n+            EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(s)),\n             HtmlStr(ref s) => format!(\"<{}>\", s),\n         }\n     }\n@@ -529,7 +529,7 @@ impl<'a> LabelText<'a> {\n             EscStr(s) => s,\n             LabelStr(s) => {\n                 if s.contains('\\\\') {\n-                    (&*s).escape_default().to_string().into()\n+                    s.escape_default().to_string().into()\n                 } else {\n                     s\n                 }"}, {"sha": "636e6e1b48d0ed61e8c64ca9aca4dd3442bddd77", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -943,7 +943,10 @@ pub struct Closure<'hir> {\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n     pub fn_decl: &'hir FnDecl<'hir>,\n     pub body: BodyId,\n+    /// The span of the declaration block: 'move |...| -> ...'\n     pub fn_decl_span: Span,\n+    /// The span of the argument block `|...|`\n+    pub fn_arg_span: Option<Span>,\n     pub movability: Option<Movability>,\n }\n \n@@ -2434,7 +2437,7 @@ impl<'hir> Ty<'hir> {\n     pub fn peel_refs(&self) -> &Self {\n         let mut final_ty = self;\n         while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n-            final_ty = &ty;\n+            final_ty = ty;\n         }\n         final_ty\n     }"}, {"sha": "93613ef27d404df43e5429ce36591de783b983ef", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -116,7 +116,7 @@ impl Ord for HirId {\n \n impl PartialOrd for HirId {\n     fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n-        Some(self.cmp(&other))\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "938ace2c785bbf1aa7d2bd9cfd50a5bf98146979", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -448,7 +448,7 @@ pub trait Visitor<'v>: Sized {\n \n pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n-    visitor.visit_pat(&param.pat);\n+    visitor.visit_pat(param.pat);\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n@@ -470,7 +470,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n         }\n         ItemKind::Fn(ref sig, ref generics, body_id) => visitor.visit_fn(\n             FnKind::ItemFn(item.ident, generics, sig.header),\n-            &sig.decl,\n+            sig.decl,\n             body_id,\n             item.span,\n             item.hir_id(),\n@@ -544,7 +544,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n \n pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n     walk_list!(visitor, visit_param, body.params);\n-    visitor.visit_expr(&body.value);\n+    visitor.visit_expr(body.value);\n }\n \n pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n@@ -580,7 +580,7 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n     visitor.visit_id(local.hir_id);\n-    visitor.visit_pat(&local.pat);\n+    visitor.visit_pat(local.pat);\n     if let Some(els) = local.els {\n         visitor.visit_block(els);\n     }\n@@ -606,7 +606,7 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n     visitor.visit_id(arm.hir_id);\n-    visitor.visit_pat(&arm.pat);\n+    visitor.visit_pat(arm.pat);\n     if let Some(ref g) = arm.guard {\n         match g {\n             Guard::If(ref e) => visitor.visit_expr(e),\n@@ -615,7 +615,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n             }\n         }\n     }\n-    visitor.visit_expr(&arm.body);\n+    visitor.visit_expr(arm.body);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n@@ -660,7 +660,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n pub fn walk_pat_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v PatField<'v>) {\n     visitor.visit_id(field.hir_id);\n     visitor.visit_ident(field.ident);\n-    visitor.visit_pat(&field.pat)\n+    visitor.visit_pat(field.pat)\n }\n \n pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n@@ -740,6 +740,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             body,\n             capture_clause: _,\n             fn_decl_span: _,\n+            fn_arg_span: _,\n             movability: _,\n         }) => {\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n@@ -799,26 +800,26 @@ pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>)\n pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n     visitor.visit_id(field.hir_id);\n     visitor.visit_ident(field.ident);\n-    visitor.visit_expr(&field.expr)\n+    visitor.visit_expr(field.expr)\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n     visitor.visit_id(typ.hir_id);\n \n     match typ.kind {\n         TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(mutable_type.ty),\n         TyKind::Rptr(ref lifetime, ref mutable_type) => {\n             visitor.visit_lifetime(lifetime);\n-            visitor.visit_ty(&mutable_type.ty)\n+            visitor.visit_ty(mutable_type.ty)\n         }\n         TyKind::Never => {}\n         TyKind::Tup(tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n         TyKind::BareFn(ref function_declaration) => {\n             walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n-            visitor.visit_fn_decl(&function_declaration.decl);\n+            visitor.visit_fn_decl(function_declaration.decl);\n         }\n         TyKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n@@ -951,8 +952,8 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n     let TraitItem { ident, generics, ref defaultness, ref kind, span, owner_id: _ } = *trait_item;\n     let hir_id = trait_item.hir_id();\n     visitor.visit_ident(ident);\n-    visitor.visit_generics(&generics);\n-    visitor.visit_defaultness(&defaultness);\n+    visitor.visit_generics(generics);\n+    visitor.visit_defaultness(defaultness);\n     match *kind {\n         TraitItemKind::Const(ref ty, default) => {\n             visitor.visit_id(hir_id);\n@@ -961,13 +962,13 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Required(param_names)) => {\n             visitor.visit_id(hir_id);\n-            visitor.visit_fn_decl(&sig.decl);\n+            visitor.visit_fn_decl(sig.decl);\n             for &param_name in param_names {\n                 visitor.visit_ident(param_name);\n             }\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Provided(body_id)) => {\n-            visitor.visit_fn(FnKind::Method(ident, sig), &sig.decl, body_id, span, hir_id);\n+            visitor.visit_fn(FnKind::Method(ident, sig), sig.decl, body_id, span, hir_id);\n         }\n         TraitItemKind::Type(bounds, ref default) => {\n             visitor.visit_id(hir_id);\n@@ -1009,7 +1010,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         ImplItemKind::Fn(ref sig, body_id) => {\n             visitor.visit_fn(\n                 FnKind::Method(impl_item.ident, sig),\n-                &sig.decl,\n+                sig.decl,\n                 body_id,\n                 impl_item.span,\n                 impl_item.hir_id(),\n@@ -1042,7 +1043,7 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n \n pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n     visitor.visit_id(trait_ref.hir_ref_id);\n-    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n+    visitor.visit_path(trait_ref.path, trait_ref.hir_ref_id)\n }\n \n pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n@@ -1074,7 +1075,7 @@ pub fn walk_struct_def<'v, V: Visitor<'v>>(\n pub fn walk_field_def<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v FieldDef<'v>) {\n     visitor.visit_id(field.hir_id);\n     visitor.visit_ident(field.ident);\n-    visitor.visit_ty(&field.ty);\n+    visitor.visit_ty(field.ty);\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>("}, {"sha": "5749b04783ce4ff8c7608e83771a3754471fffe4", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -56,25 +56,6 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let unused_extern_crates: FxHashMap<LocalDefId, Span> = tcx\n         .maybe_unused_extern_crates(())\n         .iter()\n-        .filter(|&&(def_id, _)| {\n-            // The `def_id` here actually was calculated during resolution (at least\n-            // at the time of this writing) and is being shipped to us via a side\n-            // channel of the tcx. There may have been extra expansion phases,\n-            // however, which ended up removing the `def_id` *after* expansion.\n-            //\n-            // As a result we need to verify that `def_id` is indeed still valid for\n-            // our AST and actually present in the HIR map. If it's not there then\n-            // there's safely nothing to warn about, and otherwise we carry on with\n-            // our execution.\n-            //\n-            // Note that if we carry through to the `extern_mod_stmt_cnum` query\n-            // below it'll cause a panic because `def_id` is actually bogus at this\n-            // point in time otherwise.\n-            if tcx.hir().find(tcx.hir().local_def_id_to_hir_id(def_id)).is_none() {\n-                return false;\n-            }\n-            true\n-        })\n         .filter(|&&(def_id, _)| {\n             tcx.extern_mod_stmt_cnum(def_id).map_or(true, |cnum| {\n                 !tcx.is_compiler_builtins(cnum)"}, {"sha": "b7084303aafb1d0b85c1c0f2c0423b30c6e519f5", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -2073,6 +2073,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n         }\n     }\n \n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+        codegen_fn_attrs.inline = InlineAttr::Never;\n+    }\n+\n     // Weak lang items have the same semantics as \"std internal\" symbols in the\n     // sense that they're preserved through all our LTO passes and only\n     // strippable by the linker."}, {"sha": "3791b2c8661a71a318da4d94848795109e40682e", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1480,6 +1480,7 @@ impl<'a> State<'a> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: _,\n+                fn_arg_span: _,\n                 movability: _,\n                 def_id: _,\n             }) => {"}, {"sha": "429cb60ba2b6161692c9153041a068ce638e69d5", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -456,10 +456,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .map(|ty| ArgKind::from_expected_ty(*ty, None))\n             .collect();\n-        let (closure_span, found_args) = match self.get_fn_like_arguments(expr_map_node) {\n-            Some((sp, args)) => (Some(sp), args),\n-            None => (None, Vec::new()),\n-        };\n+        let (closure_span, closure_arg_span, found_args) =\n+            match self.get_fn_like_arguments(expr_map_node) {\n+                Some((sp, arg_sp, args)) => (Some(sp), arg_sp, args),\n+                None => (None, None, Vec::new()),\n+            };\n         let expected_span =\n             expected_sig.cause_span.unwrap_or_else(|| self.tcx.def_span(expr_def_id));\n         self.report_arg_count_mismatch(\n@@ -468,6 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expected_args,\n             found_args,\n             true,\n+            closure_arg_span,\n         )\n         .emit();\n "}, {"sha": "3078e0cbeda59cd42a0b3b63ef9945165386f0fb", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1918,6 +1918,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         receiver: Option<&'tcx hir::Expr<'tcx>>,\n         args: &'tcx [hir::Expr<'tcx>],\n     ) -> bool {\n+        // Do not call `fn_sig` on non-functions.\n+        if !matches!(\n+            self.tcx.def_kind(def_id),\n+            DefKind::Fn | DefKind::AssocFn | DefKind::Variant | DefKind::Ctor(..)\n+        ) {\n+            return false;\n+        }\n+\n         let sig = self.tcx.fn_sig(def_id).skip_binder();\n         let args_referencing_param: Vec<_> = sig\n             .inputs()"}, {"sha": "a2ca5c3b7b7493a9d0330b772fd87e9bdbced645", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, GenericParamDefKind, Ty, TypeVisitable};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             // We probe again, taking all traits into account (not only those in scope).\n-            let mut candidates =\n+            let candidates =\n                 match self.lookup_probe(segment.ident, self_ty, call_expr, ProbeScope::AllTraits) {\n                     // If we find a different result the caller probably forgot to import a trait.\n                     Ok(ref new_pick) if pick.differs_from(new_pick) => {\n@@ -236,7 +236,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .collect(),\n                     _ => Vec::new(),\n                 };\n-            candidates.retain(|candidate| *candidate != self.tcx.parent(result.callee.def_id));\n \n             return Err(IllegalSizedBound(candidates, needs_mut, span));\n         }"}, {"sha": "684835d8c5c86b88e60713d8639ab1962a4eb0da", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -29,8 +29,8 @@ impl<'a> DiagnosticDerive<'a> {\n         let DiagnosticDerive { mut structure, mut builder } = self;\n \n         let implementation = builder.each_variant(&mut structure, |mut builder, variant| {\n-            let preamble = builder.preamble(&variant);\n-            let body = builder.body(&variant);\n+            let preamble = builder.preamble(variant);\n+            let body = builder.body(variant);\n \n             let diag = &builder.parent.diag;\n             let DiagnosticDeriveKind::Diagnostic { handler } = &builder.parent.kind else {\n@@ -39,7 +39,7 @@ impl<'a> DiagnosticDerive<'a> {\n             let init = match builder.slug.value_ref() {\n                 None => {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n-                        .help(&format!(\n+                        .help(format!(\n                             \"specify the slug as the first argument to the `#[diag(...)]` \\\n                             attribute, such as `#[diag(hir_analysis_example_error)]`\",\n                         ))\n@@ -48,10 +48,10 @@ impl<'a> DiagnosticDerive<'a> {\n                 }\n                 Some(slug) if let Some( Mismatch { slug_name, crate_name, slug_prefix }) = Mismatch::check(slug) => {\n                     span_err(slug.span().unwrap(), \"diagnostic slug and crate name do not match\")\n-                        .note(&format!(\n+                        .note(format!(\n                             \"slug is `{slug_name}` but the crate name is `{crate_name}`\"\n                         ))\n-                        .help(&format!(\n+                        .help(format!(\n                             \"expected a slug starting with `{slug_prefix}_...`\"\n                         ))\n                         .emit();\n@@ -113,8 +113,8 @@ impl<'a> LintDiagnosticDerive<'a> {\n         let LintDiagnosticDerive { mut structure, mut builder } = self;\n \n         let implementation = builder.each_variant(&mut structure, |mut builder, variant| {\n-            let preamble = builder.preamble(&variant);\n-            let body = builder.body(&variant);\n+            let preamble = builder.preamble(variant);\n+            let body = builder.body(variant);\n \n             let diag = &builder.parent.diag;\n             let formatting_init = &builder.formatting_init;\n@@ -128,28 +128,28 @@ impl<'a> LintDiagnosticDerive<'a> {\n \n         let msg = builder.each_variant(&mut structure, |mut builder, variant| {\n             // Collect the slug by generating the preamble.\n-            let _ = builder.preamble(&variant);\n+            let _ = builder.preamble(variant);\n \n             match builder.slug.value_ref() {\n                 None => {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n-                        .help(&format!(\n+                        .help(format!(\n                             \"specify the slug as the first argument to the attribute, such as \\\n                             `#[diag(compiletest_example)]`\",\n                         ))\n                         .emit();\n-                    return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    DiagnosticDeriveError::ErrorHandled.to_compile_error()\n                 }\n                 Some(slug) if let Some( Mismatch { slug_name, crate_name, slug_prefix }) = Mismatch::check(slug) => {\n                     span_err(slug.span().unwrap(), \"diagnostic slug and crate name do not match\")\n-                        .note(&format!(\n+                        .note(format!(\n                             \"slug is `{slug_name}` but the crate name is `{crate_name}`\"\n                         ))\n-                        .help(&format!(\n+                        .help(format!(\n                             \"expected a slug starting with `{slug_prefix}_...`\"\n                         ))\n                         .emit();\n-                    return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    DiagnosticDeriveError::ErrorHandled.to_compile_error()\n                 }\n                 Some(slug) => {\n                     quote! {"}, {"sha": "9f2ac5112f1cd9d3aa4b78a9cf1deeda1c0ae799", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -100,7 +100,7 @@ impl DiagnosticDeriveBuilder {\n                 _ => variant.ast().ident.span().unwrap(),\n             };\n             let builder = DiagnosticDeriveVariantBuilder {\n-                parent: &self,\n+                parent: self,\n                 span,\n                 field_map: build_field_mapping(variant),\n                 formatting_init: TokenStream::new(),\n@@ -211,7 +211,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     nested_iter.next();\n                 }\n                 Some(NestedMeta::Meta(Meta::NameValue { .. })) => {}\n-                Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| diag\n+                Some(nested_attr) => throw_invalid_nested_attr!(attr, nested_attr, |diag| diag\n                     .help(\"a diagnostic slug is required as the first argument\")),\n                 None => throw_invalid_attr!(attr, &meta, |diag| diag\n                     .help(\"a diagnostic slug is required as the first argument\")),\n@@ -227,13 +227,13 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                         ..\n                     })) => (value, path),\n                     NestedMeta::Meta(Meta::Path(_)) => {\n-                        invalid_nested_attr(attr, &nested_attr)\n+                        invalid_nested_attr(attr, nested_attr)\n                             .help(\"diagnostic slug must be the first argument\")\n                             .emit();\n                         continue;\n                     }\n                     _ => {\n-                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        invalid_nested_attr(attr, nested_attr).emit();\n                         continue;\n                     }\n                 };\n@@ -251,7 +251,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                             #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n                         });\n                     }\n-                    _ => invalid_nested_attr(attr, &nested_attr)\n+                    _ => invalid_nested_attr(attr, nested_attr)\n                         .help(\"only `code` is a valid nested attributes following the slug\")\n                         .emit(),\n                 }\n@@ -427,9 +427,9 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n             }\n             SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n-                if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                if type_matches_path(info.ty, &[\"rustc_span\", \"Span\"]) {\n                     Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n-                } else if type_is_unit(&info.ty) {\n+                } else if type_is_unit(info.ty) {\n                     Ok(self.add_subdiagnostic(&fn_ident, slug))\n                 } else {\n                     report_type_error(attr, \"`Span` or `()`\")?"}, {"sha": "446aebe4f83f59a3d95a4903227bd4fa7b9cbb92", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -409,7 +409,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 let mut code = None;\n                 for nested_attr in list.nested.iter() {\n                     let NestedMeta::Meta(ref meta) = nested_attr else {\n-                        throw_invalid_nested_attr!(attr, &nested_attr);\n+                        throw_invalid_nested_attr!(attr, nested_attr);\n                     };\n \n                     let span = meta.span().unwrap();\n@@ -427,7 +427,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                             );\n                             code.set_once((code_field, formatting_init), span);\n                         }\n-                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                        _ => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n                             diag.help(\"`code` is the only valid nested attribute\")\n                         }),\n                     }"}, {"sha": "da90233523ca3c83e503f45bb351207bcdcd5f74", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -80,7 +80,7 @@ fn report_error_if_not_applied_to_ty(\n     path: &[&str],\n     ty_name: &str,\n ) -> Result<(), DiagnosticDeriveError> {\n-    if !type_matches_path(&info.ty, path) {\n+    if !type_matches_path(info.ty, path) {\n         report_type_error(attr, ty_name)?;\n     }\n \n@@ -105,8 +105,8 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n ) -> Result<(), DiagnosticDeriveError> {\n-    if !type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"])\n-        && !type_matches_path(&info.ty, &[\"rustc_errors\", \"MultiSpan\"])\n+    if !type_matches_path(info.ty, &[\"rustc_span\", \"Span\"])\n+        && !type_matches_path(info.ty, &[\"rustc_errors\", \"MultiSpan\"])\n     {\n         report_type_error(attr, \"`Span` or `MultiSpan`\")?;\n     }\n@@ -686,7 +686,7 @@ impl SubdiagnosticKind {\n             let meta = match nested_attr {\n                 NestedMeta::Meta(ref meta) => meta,\n                 NestedMeta::Lit(_) => {\n-                    invalid_nested_attr(attr, &nested_attr).emit();\n+                    invalid_nested_attr(attr, nested_attr).emit();\n                     continue;\n                 }\n             };\n@@ -698,7 +698,7 @@ impl SubdiagnosticKind {\n             let string_value = match meta {\n                 Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => Some(value),\n \n-                Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                Meta::Path(_) => throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n                     diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n                 }),\n                 _ => None,\n@@ -720,7 +720,7 @@ impl SubdiagnosticKind {\n                     | SubdiagnosticKind::MultipartSuggestion { ref mut applicability, .. },\n                 ) => {\n                     let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        invalid_nested_attr(attr, nested_attr).emit();\n                         continue;\n                     };\n \n@@ -736,7 +736,7 @@ impl SubdiagnosticKind {\n                     | SubdiagnosticKind::MultipartSuggestion { .. },\n                 ) => {\n                     let Some(value) = string_value else {\n-                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        invalid_nested_attr(attr, nested_attr).emit();\n                         continue;\n                     };\n \n@@ -752,19 +752,19 @@ impl SubdiagnosticKind {\n \n                 // Invalid nested attribute\n                 (_, SubdiagnosticKind::Suggestion { .. }) => {\n-                    invalid_nested_attr(attr, &nested_attr)\n+                    invalid_nested_attr(attr, nested_attr)\n                         .help(\n                             \"only `style`, `code` and `applicability` are valid nested attributes\",\n                         )\n                         .emit();\n                 }\n                 (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n-                    invalid_nested_attr(attr, &nested_attr)\n+                    invalid_nested_attr(attr, nested_attr)\n                         .help(\"only `style` and `applicability` are valid nested attributes\")\n                         .emit()\n                 }\n                 _ => {\n-                    invalid_nested_attr(attr, &nested_attr).emit();\n+                    invalid_nested_attr(attr, nested_attr).emit();\n                 }\n             }\n         }"}, {"sha": "1bd8f95350879d29e86136f6c5d7c7bd1892bbb7", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1022,7 +1022,7 @@ impl<'hir> Map<'hir> {\n                 ..\n             }) => {\n                 // Ensure that the returned span has the item's SyntaxContext.\n-                fn_decl_span.find_ancestor_in_same_ctxt(*span).unwrap_or(*span)\n+                fn_decl_span.find_ancestor_inside(*span).unwrap_or(*span)\n             }\n             _ => self.span_with_body(hir_id),\n         };"}, {"sha": "bf670c5c26a7753394e631bca6d73d77ccaf664d", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -363,10 +363,6 @@ impl<'tcx> Inliner<'tcx> {\n             return Err(\"C variadic\");\n         }\n \n-        if callee_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-            return Err(\"naked\");\n-        }\n-\n         if callee_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n             return Err(\"cold\");\n         }"}, {"sha": "fe3cfde2e6383dfc024a56812bb09b726ae7ee6b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -2060,7 +2060,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let capture_clause = self.parse_capture_clause()?;\n-        let fn_decl = self.parse_fn_block_decl()?;\n+        let (fn_decl, fn_arg_span) = self.parse_fn_block_decl()?;\n         let decl_hi = self.prev_token.span;\n         let mut body = match fn_decl.output {\n             FnRetTy::Default(_) => {\n@@ -2101,6 +2101,7 @@ impl<'a> Parser<'a> {\n                 fn_decl,\n                 body,\n                 fn_decl_span: lo.to(decl_hi),\n+                fn_arg_span,\n             })),\n         );\n \n@@ -2129,7 +2130,9 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the `|arg, arg|` header of a closure.\n-    fn parse_fn_block_decl(&mut self) -> PResult<'a, P<FnDecl>> {\n+    fn parse_fn_block_decl(&mut self) -> PResult<'a, (P<FnDecl>, Span)> {\n+        let arg_start = self.token.span.lo();\n+\n         let inputs = if self.eat(&token::OrOr) {\n             Vec::new()\n         } else {\n@@ -2145,10 +2148,11 @@ impl<'a> Parser<'a> {\n             self.expect_or()?;\n             args\n         };\n+        let arg_span = self.prev_token.span.with_lo(arg_start);\n         let output =\n             self.parse_ret_ty(AllowPlus::Yes, RecoverQPath::Yes, RecoverReturnSign::Yes)?;\n \n-        Ok(P(FnDecl { inputs, output }))\n+        Ok((P(FnDecl { inputs, output }), arg_span))\n     }\n \n     /// Parses a parameter in a closure header (e.g., `|arg, arg|`)."}, {"sha": "b100a8c17cf398ba08c82d0fc8a226e93c82dd85", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -4,7 +4,10 @@ use crate::diagnostics::{import_candidates, Suggestion};\n use crate::Determinacy::{self, *};\n use crate::Namespace::*;\n use crate::{module_to_string, names_to_string, ImportSuggestion};\n-use crate::{AmbiguityKind, BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n+use crate::{\n+    AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BindingKey, ModuleKind, ResolutionError,\n+    Resolver, Segment,\n+};\n use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet};\n use crate::{NameBinding, NameBindingKind, PathResult};\n \n@@ -791,7 +794,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 match binding {\n                     Ok(binding) => {\n                         // Consistency checks, analogous to `finalize_macro_resolutions`.\n-                        let initial_res = source_bindings[ns].get().map(|initial_binding| {\n+                        let initial_binding = source_bindings[ns].get().map(|initial_binding| {\n                             all_ns_err = false;\n                             if let Some(target_binding) = target_bindings[ns].get() {\n                                 if target.name == kw::Underscore\n@@ -805,12 +808,20 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                     );\n                                 }\n                             }\n-                            initial_binding.res()\n+                            initial_binding\n                         });\n                         let res = binding.res();\n-                        if let Ok(initial_res) = initial_res {\n+                        if let Ok(initial_binding) = initial_binding {\n+                            let initial_res = initial_binding.res();\n                             if res != initial_res && this.ambiguity_errors.is_empty() {\n-                                span_bug!(import.span, \"inconsistent resolution for an import\");\n+                                this.ambiguity_errors.push(AmbiguityError {\n+                                    kind: AmbiguityKind::Import,\n+                                    ident,\n+                                    b1: initial_binding,\n+                                    b2: binding,\n+                                    misc1: AmbiguityErrorMisc::None,\n+                                    misc2: AmbiguityErrorMisc::None,\n+                                });\n                             }\n                         } else if res != Res::Err\n                             && this.ambiguity_errors.is_empty()"}, {"sha": "8703e5754655f3c0a39792a7813da26054e0e5e4", "filename": "compiler/rustc_session/src/cgu_reuse_tracker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_session%2Fsrc%2Fcgu_reuse_tracker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_session%2Fsrc%2Fcgu_reuse_tracker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcgu_reuse_tracker.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -121,7 +121,7 @@ impl CguReuseTracker {\n                         let at_least = if at_least { 1 } else { 0 };\n                         IncorrectCguReuseType {\n                             span: error_span.0,\n-                            cgu_user_name: &cgu_user_name,\n+                            cgu_user_name,\n                             actual_reuse,\n                             expected_reuse,\n                             at_least,"}, {"sha": "d8c4b0845d0acb67bc60114c74b98196ec25ed31", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -622,7 +622,7 @@ impl OutputFilenames {\n     /// should be placed on disk.\n     pub fn output_path(&self, flavor: OutputType) -> PathBuf {\n         let extension = flavor.extension();\n-        self.with_directory_and_extension(&self.out_directory, &extension)\n+        self.with_directory_and_extension(&self.out_directory, extension)\n     }\n \n     /// Gets the path where a compilation artifact of the given type for the\n@@ -659,7 +659,7 @@ impl OutputFilenames {\n \n         let temps_directory = self.temps_directory.as_ref().unwrap_or(&self.out_directory);\n \n-        self.with_directory_and_extension(&temps_directory, &extension)\n+        self.with_directory_and_extension(temps_directory, &extension)\n     }\n \n     pub fn with_extension(&self, extension: &str) -> PathBuf {\n@@ -1159,7 +1159,7 @@ impl CrateCheckConfig {\n                 values_target_family\n                     .extend(target.options.families.iter().map(|family| Symbol::intern(family)));\n                 values_target_arch.insert(Symbol::intern(&target.arch));\n-                values_target_endian.insert(Symbol::intern(&target.options.endian.as_str()));\n+                values_target_endian.insert(Symbol::intern(target.options.endian.as_str()));\n                 values_target_env.insert(Symbol::intern(&target.options.env));\n                 values_target_abi.insert(Symbol::intern(&target.options.abi));\n                 values_target_vendor.insert(Symbol::intern(&target.options.vendor));\n@@ -1846,7 +1846,7 @@ pub fn parse_target_triple(\n     match matches.opt_str(\"target\") {\n         Some(target) if target.ends_with(\".json\") => {\n             let path = Path::new(&target);\n-            TargetTriple::from_path(&path).unwrap_or_else(|_| {\n+            TargetTriple::from_path(path).unwrap_or_else(|_| {\n                 early_error(error_format, &format!(\"target file {path:?} does not exist\"))\n             })\n         }\n@@ -1992,7 +1992,7 @@ fn parse_native_lib_modifiers(\n ) -> (NativeLibKind, Option<bool>) {\n     let mut verbatim = None;\n     for modifier in modifiers.split(',') {\n-        let (modifier, value) = match modifier.strip_prefix(&['+', '-']) {\n+        let (modifier, value) = match modifier.strip_prefix(['+', '-']) {\n             Some(m) => (m, modifier.starts_with('+')),\n             None => early_error(\n                 error_format,\n@@ -2421,7 +2421,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut search_paths = vec![];\n     for s in &matches.opt_strs(\"L\") {\n-        search_paths.push(SearchPath::from_cli_opt(&s, error_format));\n+        search_paths.push(SearchPath::from_cli_opt(s, error_format));\n     }\n \n     let libs = parse_libs(matches, error_format);"}, {"sha": "8cb9e1a6f1ae81462eb65293fb736409083ddef2", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -317,7 +317,7 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n         LitError::InvalidIntSuffix => {\n             let suf = suffix.expect(\"suffix error with no suffix\");\n             let suf = suf.as_str();\n-            if looks_like_width_suffix(&['i', 'u'], &suf) {\n+            if looks_like_width_suffix(&['i', 'u'], suf) {\n                 // If it looks like a width, try to be helpful.\n                 sess.emit_err(InvalidIntLiteralWidth { span, width: suf[1..].into() });\n             } else if let Some(fixed) = fix_base_capitalisation(suf) {"}, {"sha": "d3c2c5113bcdec663f1b00fb9d873d316d7bccae", "filename": "compiler/rustc_span/src/analyze_source_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fanalyze_source_file.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -247,7 +247,7 @@ fn analyze_source_file_generic(\n             // The slow path:\n             // This is either ASCII control character \"DEL\" or the beginning of\n             // a multibyte char. Just decode to `char`.\n-            let c = (&src[i..]).chars().next().unwrap();\n+            let c = src[i..].chars().next().unwrap();\n             char_len = c.len_utf8();\n \n             let pos = BytePos::from_usize(i) + output_offset;"}, {"sha": "886112769a977f78db57a95c9ddabafe985133dc", "filename": "compiler/rustc_span/src/caching_source_map_view.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -165,7 +165,7 @@ impl<'sm> CachingSourceMapView<'sm> {\n             Some(new_file_and_idx)\n         } else {\n             let file = &self.line_cache[oldest].file;\n-            if !file_contains(&file, span_data.hi) {\n+            if !file_contains(file, span_data.hi) {\n                 return None;\n             }\n "}, {"sha": "038699154c727dc72d9add71fc1e6ecc6f70b78c", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -381,7 +381,7 @@ impl HygieneData {\n     }\n \n     pub fn with<T, F: FnOnce(&mut HygieneData) -> T>(f: F) -> T {\n-        with_session_globals(|session_globals| f(&mut *session_globals.hygiene_data.borrow_mut()))\n+        with_session_globals(|session_globals| f(&mut session_globals.hygiene_data.borrow_mut()))\n     }\n \n     #[inline]"}, {"sha": "cef4c6f79cefd9d813824284f5d2886d973f0b86", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -238,7 +238,7 @@ impl RealFileName {\n     pub fn remapped_path_if_available(&self) -> &Path {\n         match self {\n             RealFileName::LocalPath(p)\n-            | RealFileName::Remapped { local_path: _, virtual_name: p } => &p,\n+            | RealFileName::Remapped { local_path: _, virtual_name: p } => p,\n         }\n     }\n "}, {"sha": "f0e91e5a6a917c3373fa399a2e496fe243ab805d", "filename": "compiler/rustc_span/src/span_encoding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -166,5 +166,5 @@ impl SpanInterner {\n // If an interner exists, return it. Otherwise, prepare a fresh one.\n #[inline]\n fn with_span_interner<T, F: FnOnce(&mut SpanInterner) -> T>(f: F) -> T {\n-    crate::with_session_globals(|session_globals| f(&mut *session_globals.span_interner.lock()))\n+    crate::with_session_globals(|session_globals| f(&mut session_globals.span_interner.lock()))\n }"}, {"sha": "9e446c96db319cc11d2221a23aad75c005f7438a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1877,7 +1877,7 @@ impl<S: Encoder> Encodable<S> for Symbol {\n impl<D: Decoder> Decodable<D> for Symbol {\n     #[inline]\n     default fn decode(d: &mut D) -> Symbol {\n-        Symbol::intern(&d.read_str())\n+        Symbol::intern(d.read_str())\n     }\n }\n "}, {"sha": "c8b6ac5ae25b2eb60152c2f3ae166471d0bb3f58", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -78,7 +78,7 @@ fn arg_scalar_pair<C>(\n where\n     C: HasDataLayout,\n {\n-    data = arg_scalar(cx, &scalar1, offset, data);\n+    data = arg_scalar(cx, scalar1, offset, data);\n     match (scalar1.primitive(), scalar2.primitive()) {\n         (abi::F32, _) => offset += Reg::f32().size,\n         (_, abi::F64) => offset += Reg::f64().size,\n@@ -90,7 +90,7 @@ where\n     if (offset.bytes() % 4) != 0 && scalar2.primitive().is_float() {\n         offset += Size::from_bytes(4 - (offset.bytes() % 4));\n     }\n-    data = arg_scalar(cx, &scalar2, offset, data);\n+    data = arg_scalar(cx, scalar2, offset, data);\n     return data;\n }\n "}, {"sha": "d05b8aa420067a9b4f8d1a66aa1650ce924f0216", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -2658,7 +2658,7 @@ impl Target {\n \n                 // Additionally look in the sysroot under `lib/rustlib/<triple>/target.json`\n                 // as a fallback.\n-                let rustlib_path = crate::target_rustlib_path(&sysroot, &target_triple);\n+                let rustlib_path = crate::target_rustlib_path(sysroot, target_triple);\n                 let p = PathBuf::from_iter([\n                     Path::new(sysroot),\n                     Path::new(&rustlib_path),"}, {"sha": "56dea916b305f447d03c63cc09016bf058e51f5b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -71,7 +71,7 @@ pub trait InferCtxtExt<'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)>;\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Option<Span>, Vec<ArgKind>)>;\n \n     /// Reports an error when the number of arguments needed by a\n     /// trait match doesn't match the number that the expression\n@@ -83,6 +83,7 @@ pub trait InferCtxtExt<'tcx> {\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n+        closure_pipe_span: Option<Span>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed>;\n \n     /// Checks if the type implements one of `Fn`, `FnMut`, or `FnOnce`\n@@ -135,15 +136,16 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)> {\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Option<Span>, Vec<ArgKind>)> {\n         let sm = self.tcx.sess.source_map();\n         let hir = self.tcx.hir();\n         Some(match node {\n             Node::Expr(&hir::Expr {\n-                kind: hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }),\n+                kind: hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, fn_arg_span, .. }),\n                 ..\n             }) => (\n                 fn_decl_span,\n+                fn_arg_span,\n                 hir.body(body)\n                     .params\n                     .iter()\n@@ -174,6 +176,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                 kind: hir::TraitItemKind::Fn(ref sig, _), ..\n             }) => (\n                 sig.span,\n+                None,\n                 sig.decl\n                     .inputs\n                     .iter()\n@@ -188,7 +191,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             ),\n             Node::Ctor(ref variant_data) => {\n                 let span = variant_data.ctor_hir_id().map_or(DUMMY_SP, |id| hir.span(id));\n-                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n+                (span, None, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n         })\n@@ -204,6 +207,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n+        closure_arg_span: Option<Span>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let kind = if is_closure { \"closure\" } else { \"function\" };\n \n@@ -241,24 +245,13 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         if let Some(found_span) = found_span {\n             err.span_label(found_span, format!(\"takes {}\", found_str));\n \n-            // move |_| { ... }\n-            // ^^^^^^^^-- def_span\n-            //\n-            // move |_| { ... }\n-            // ^^^^^-- prefix\n-            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n-            // move |_| { ... }\n-            //      ^^^-- pipe_span\n-            let pipe_span =\n-                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n-\n             // Suggest to take and ignore the arguments with expected_args_length `_`s if\n             // found arguments is empty (assume the user just wants to ignore args in this case).\n             // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n             if found_args.is_empty() && is_closure {\n                 let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n                 err.span_suggestion_verbose(\n-                    pipe_span,\n+                    closure_arg_span.unwrap_or(found_span),\n                     &format!(\n                         \"consider changing the closure to take and ignore the expected argument{}\",\n                         pluralize!(expected_args.len())\n@@ -1252,20 +1245,22 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         obligation.cause.code(),\n                     )\n                 } else {\n-                    let (closure_span, found) = found_did\n+                    let (closure_span, closure_arg_span, found) = found_did\n                         .and_then(|did| {\n                             let node = self.tcx.hir().get_if_local(did)?;\n-                            let (found_span, found) = self.get_fn_like_arguments(node)?;\n-                            Some((Some(found_span), found))\n+                            let (found_span, closure_arg_span, found) =\n+                                self.get_fn_like_arguments(node)?;\n+                            Some((Some(found_span), closure_arg_span, found))\n                         })\n-                        .unwrap_or((found_span, found));\n+                        .unwrap_or((found_span, None, found));\n \n                     self.report_arg_count_mismatch(\n                         span,\n                         closure_span,\n                         expected,\n                         found,\n                         found_trait_ty.is_closure(),\n+                        closure_arg_span,\n                     )\n                 }\n             }"}, {"sha": "524658bce139d73794a18ca88237241a6aec1dce", "filename": "library/test/src/cli.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/library%2Ftest%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/library%2Ftest%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fcli.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -26,6 +26,10 @@ pub struct TestOpts {\n     pub test_threads: Option<usize>,\n     pub skip: Vec<String>,\n     pub time_options: Option<TestTimeOptions>,\n+    /// Stop at first failing test.\n+    /// May run a few more tests due to threading, but will\n+    /// abort as soon as possible.\n+    pub fail_fast: bool,\n     pub options: Options,\n }\n \n@@ -296,6 +300,7 @@ fn parse_opts_impl(matches: getopts::Matches) -> OptRes {\n         skip,\n         time_options,\n         options,\n+        fail_fast: false,\n     };\n \n     Ok(test_opts)"}, {"sha": "a3c39f71f08b88ef38fd3e7673a78d062a78f630", "filename": "library/test/src/console.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -293,7 +293,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n     run_tests(opts, tests, |x| on_test_event(&x, &mut st, &mut *out))?;\n     st.exec_time = start_time.map(|t| TestSuiteExecTime(t.elapsed()));\n \n-    assert!(st.current_test_count() == st.total);\n+    assert!(opts.fail_fast || st.current_test_count() == st.total);\n \n     out.write_run_finish(&st)\n }"}, {"sha": "256c9e8d141e0baa57684ec5ebdb9c74cb5fc7c0", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -384,8 +384,17 @@ where\n             let mut completed_test = rx.recv().unwrap();\n             RunningTest { join_handle }.join(&mut completed_test);\n \n+            let fail_fast = match completed_test.result {\n+                TrIgnored | TrOk | TrBench(_) => false,\n+                TrFailed | TrFailedMsg(_) | TrTimedFail => opts.fail_fast,\n+            };\n+\n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n+\n+            if fail_fast {\n+                return Ok(());\n+            }\n         }\n     } else {\n         while pending > 0 || !remaining.is_empty() {\n@@ -431,9 +440,20 @@ where\n             let running_test = running_tests.remove(&completed_test.id).unwrap();\n             running_test.join(&mut completed_test);\n \n+            let fail_fast = match completed_test.result {\n+                TrIgnored | TrOk | TrBench(_) => false,\n+                TrFailed | TrFailedMsg(_) | TrTimedFail => opts.fail_fast,\n+            };\n+\n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n             pending -= 1;\n+\n+            if fail_fast {\n+                // Prevent remaining test threads from panicking\n+                std::mem::forget(rx);\n+                return Ok(());\n+            }\n         }\n     }\n "}, {"sha": "3a0260f86cf5d081f08a4b6122a0f40c3ed77b38", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -51,6 +51,7 @@ impl TestOpts {\n             skip: vec![],\n             time_options: None,\n             options: Options::new(),\n+            fail_fast: false,\n         }\n     }\n }"}, {"sha": "91a6260bf2aa2f1794b3f676a1b231ab91b69848", "filename": "src/test/codegen/naked-nocoverage.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fcodegen%2Fnaked-nocoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fcodegen%2Fnaked-nocoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnaked-nocoverage.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,19 @@\n+// Checks that naked functions are not instrumented by -Cinstrument-coverage.\n+// Regression test for issue #105170.\n+//\n+// needs-asm-support\n+// needs-profiler-support\n+// compile-flags: -Cinstrument-coverage\n+#![crate_type = \"lib\"]\n+#![feature(naked_functions)]\n+use std::arch::asm;\n+\n+#[naked]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn f() {\n+    // CHECK:       define void @f()\n+    // CHECK-NEXT:  start:\n+    // CHECK-NEXT:    call void asm\n+    // CHECK-NEXT:    unreachable\n+    asm!(\"\", options(noreturn));\n+}"}, {"sha": "a93ba87470a9c045703a8d31a2d39b51884d04a5", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -126,6 +126,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                         fn_decl: decl.clone(),\n                         body: e,\n                         fn_decl_span: DUMMY_SP,\n+                        fn_arg_span: DUMMY_SP,\n                     })))\n                 });\n             }"}, {"sha": "70dcd5413f1ee0b2a445e4cedd3058f9326b881f", "filename": "src/test/ui/attributes/unused-item-in-attr.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,6 @@\n+#[w = { extern crate alloc; }]\n+//~^ ERROR unexpected expression: `{\n+//~| ERROR cannot find attribute `w` in this scope\n+fn f() {}\n+\n+fn main() {}"}, {"sha": "92a8f58582136a05f808b34a53f3d5d0b1d7a89d", "filename": "src/test/ui/attributes/unused-item-in-attr.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Funused-item-in-attr.stderr?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,16 @@\n+error: unexpected expression: `{\n+           extern crate alloc;\n+       }`\n+  --> $DIR/unused-item-in-attr.rs:1:7\n+   |\n+LL | #[w = { extern crate alloc; }]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot find attribute `w` in this scope\n+  --> $DIR/unused-item-in-attr.rs:1:3\n+   |\n+LL | #[w = { extern crate alloc; }]\n+   |   ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "aa6f74cb5d45ae0ffd98fd5d231cd79d67198f91", "filename": "src/test/ui/issues/issue-35976.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fissues%2Fissue-35976.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fissues%2Fissue-35976.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35976.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1,5 +1,9 @@\n+// revisions: imported unimported\n+//[imported] check-pass\n+\n mod private {\n     pub trait Future {\n+        //[unimported]~^^ HELP perhaps add a `use` for it\n         fn wait(&self) where Self: Sized;\n     }\n \n@@ -8,13 +12,13 @@ mod private {\n     }\n }\n \n-//use private::Future;\n+#[cfg(imported)]\n+use private::Future;\n \n fn bar(arg: Box<dyn private::Future>) {\n+    // Importing the trait means that we don't autoderef `Box<dyn Future>`\n     arg.wait();\n-    //~^ ERROR the `wait` method cannot be invoked on a trait object\n+    //[unimported]~^ ERROR the `wait` method cannot be invoked on a trait object\n }\n \n-fn main() {\n-\n-}\n+fn main() {}"}, {"sha": "5d61bb8ea379992abb59771028d5f1c466bc94f8", "filename": "src/test/ui/issues/issue-35976.unimported.stderr", "status": "renamed", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fissues%2Fissue-35976.unimported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fissues%2Fissue-35976.unimported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35976.unimported.stderr?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1,11 +1,16 @@\n error: the `wait` method cannot be invoked on a trait object\n-  --> $DIR/issue-35976.rs:14:9\n+  --> $DIR/issue-35976.rs:20:9\n    |\n LL |         fn wait(&self) where Self: Sized;\n    |                                    ----- this has a `Sized` requirement\n ...\n LL |     arg.wait();\n    |         ^^^^\n+   |\n+help: another candidate was found in the following trait, perhaps add a `use` for it:\n+   |\n+LL | use private::Future;\n+   |\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/issues/issue-35976.stderr"}, {"sha": "73455cf7711c6b623c5c4c316755629903698852", "filename": "src/test/ui/resolve/issue-105069.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,11 @@\n+use self::A::*;\n+use V; //~ ERROR `V` is ambiguous\n+use self::B::*;\n+enum A {\n+    V\n+}\n+enum B {\n+    V\n+}\n+\n+fn main() {}"}, {"sha": "1e6c9c6e2dc34fa9b331b60a763f55dc119dc4ed", "filename": "src/test/ui/resolve/issue-105069.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-105069.stderr?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,21 @@\n+error[E0659]: `V` is ambiguous\n+  --> $DIR/issue-105069.rs:2:5\n+   |\n+LL | use V;\n+   |     ^ ambiguous name\n+   |\n+   = note: ambiguous because of multiple potential import sources\n+note: `V` could refer to the variant imported here\n+  --> $DIR/issue-105069.rs:1:5\n+   |\n+LL | use self::A::*;\n+   |     ^^^^^^^^^^\n+note: `V` could also refer to the variant imported here\n+  --> $DIR/issue-105069.rs:3:5\n+   |\n+LL | use self::B::*;\n+   |     ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "4b4595dd5e6a5e70fce2e754b5532f44f50eb8a9", "filename": "src/test/ui/suggestions/assoc-const-as-fn.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,18 @@\n+unsafe fn pointer(v: usize, w: u32) {}\n+\n+pub trait UniformScalar {}\n+impl UniformScalar for u32 {}\n+\n+pub trait GlUniformScalar: UniformScalar {\n+    const FACTORY: unsafe fn(usize, Self) -> ();\n+}\n+impl GlUniformScalar for u32 {\n+    const FACTORY: unsafe fn(usize, Self) -> () = pointer;\n+}\n+\n+pub fn foo<T: UniformScalar>(value: T) {\n+    <T as GlUniformScalar>::FACTORY(1, value);\n+    //~^ ERROR the trait bound `T: GlUniformScalar` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "fa740687858275b0ba5bad5c15ff31cacaacc3cb", "filename": "src/test/ui/suggestions/assoc-const-as-fn.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-fn.stderr?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the trait bound `T: GlUniformScalar` is not satisfied\n+  --> $DIR/assoc-const-as-fn.rs:14:5\n+   |\n+LL |     <T as GlUniformScalar>::FACTORY(1, value);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `GlUniformScalar` is not implemented for `T`\n+   |\n+help: consider further restricting this bound\n+   |\n+LL | pub fn foo<T: UniformScalar + GlUniformScalar>(value: T) {\n+   |                             +++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "91c701a5ddd2e469b9115fc02af7eab28dd5349e", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -514,6 +514,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         options: test::Options::new(),\n         time_options: None,\n         force_run_in_process: false,\n+        fail_fast: std::env::var_os(\"RUSTC_TEST_FAIL_FAST\").is_some(),\n     }\n }\n "}, {"sha": "9d61cc4e2d5f0f0a686ef639e5940e5ed49ba777", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "modified", "additions": 14, "deletions": 47, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -203,65 +203,32 @@ for more information about configuring VS Code and `rust-analyzer`.\n \n [rdg-r-a]: https://rustc-dev-guide.rust-lang.org/building/suggested.html#configuring-rust-analyzer-for-rustc\n \n-## Advanced topic: other build environments\n+## Advanced topic: Working on Miri in the rustc tree\n \n We described above the simplest way to get a working build environment for Miri,\n which is to use the version of rustc indicated by `rustc-version`. But\n sometimes, that is not enough.\n \n-### Building Miri with a locally built rustc\n+A big part of the Miri driver is shared with rustc, so working on Miri will\n+sometimes require also working on rustc itself. In this case, you should *not*\n+work in a clone of the Miri repository, but in a clone of the\n+[main Rust repository](https://github.com/rust-lang/rust/). There is a copy of\n+Miri located at `src/tools/miri` that you can work on directly. A maintainer\n+will eventually sync those changes back into this repository.\n \n-[building Miri with a locally built rustc]: #building-miri-with-a-locally-built-rustc\n+When working on Miri in the rustc tree, here's how you can run tests:\n \n-A big part of the Miri driver lives in rustc, so working on Miri will sometimes\n-require using a locally built rustc. The bug you want to fix may actually be on\n-the rustc side, or you just need to get more detailed trace of the execution\n-than what is possible with release builds -- in both cases, you should develop\n-Miri against a rustc you compiled yourself, with debug assertions (and hence\n-tracing) enabled.\n-\n-The setup for a local rustc works as follows:\n-```sh\n-# Clone the rust-lang/rust repo.\n-git clone https://github.com/rust-lang/rust rustc\n-cd rustc\n-# Create a config.toml with defaults for working on Miri.\n-./x.py setup compiler\n- # Now edit `config.toml` and under `[rust]` set `debug-assertions = true`.\n-\n-# Build a stage 2 rustc, and build the rustc libraries with that rustc.\n-# This step can take 30 minutes or more.\n-./x.py build --stage 2 compiler/rustc\n-# If you change something, you can get a faster rebuild by doing\n-./x.py build --keep-stage 0 --stage 2 compiler/rustc\n-# You may have to change the architecture in the next command\n-rustup toolchain link stage2 build/x86_64-unknown-linux-gnu/stage2\n-# Now cd to your Miri directory, then configure rustup\n-rustup override set stage2\n ```\n-\n-Note: When you are working with a locally built rustc or any other toolchain that\n-is not the same as the one in `rust-version`, you should not have `.auto-everything` or\n-`.auto-toolchain` as that will keep resetting your toolchain.\n-\n-```sh\n-rm -f .auto-everything .auto-toolchain\n+./x.py test miri --stage 0\n ```\n \n-Important: You need to delete the Miri cache when you change the stdlib; otherwise the\n-old, chached version will be used. On Linux, the cache is located at `~/.cache/miri`,\n-and on Windows, it is located at `%LOCALAPPDATA%\\rust-lang\\miri\\cache`; the exact\n-location is printed after the library build: \"A libstd for Miri is now available in ...\".\n-\n-Note: `./x.py --stage 2 compiler/rustc` currently errors with `thread 'main'\n-panicked at 'fs::read(stamp) failed with No such file or directory (os error 2)`,\n-you can simply ignore that error; Miri will build anyway.\n+`--bless` will work, too.\n \n-For more information about building and configuring a local compiler,\n-see <https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html>.\n+You can also directly run Miri on a Rust source file:\n \n-With this, you should now have a working development setup! See\n-[above](#building-and-testing-miri) for how to proceed working on Miri.\n+```\n+./x.py run miri --stage 0 --args src/tools/miri/tests/pass/hello.rs\n+```\n \n ## Advanced topic: Syncing with the rustc repo\n "}, {"sha": "876d49257caa5beb283092fddea261457706a970", "filename": "src/tools/miri/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.lock?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -724,9 +724,9 @@ dependencies = [\n \n [[package]]\n name = \"ui_test\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf4559da3fe6b481f8674a29379677cb9606cd6f75fc254a2c9834c55638503d\"\n+checksum = \"54ddb6f31025943e2f9d59237f433711c461a43d9415974c3eb3a4902edc1c1f\"\n dependencies = [\n  \"bstr\",\n  \"cargo_metadata\","}, {"sha": "717020f43c4f0c869c0432ffbdbfdfa8080c05af", "filename": "src/tools/miri/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.toml?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -39,7 +39,7 @@ libloading = \"0.7\"\n \n [dev-dependencies]\n colored = \"2\"\n-ui_test = \"0.4\"\n+ui_test = \"0.5\"\n rustc_version = \"0.4\"\n # Features chosen to match those required by env_logger, to avoid rebuilds\n regex = { version = \"1.5.5\", default-features = false, features = [\"perf\", \"std\"] }"}, {"sha": "2bffff47722704d7b863b4a5aa6ea7ec0024a6c5", "filename": "src/tools/miri/cargo-miri/src/phases.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -94,7 +94,7 @@ pub fn phase_cargo_miri(mut args: impl Iterator<Item = String>) {\n     let target = target.as_ref().unwrap_or(host);\n \n     // We always setup.\n-    setup(&subcommand, target, &rustc_version);\n+    setup(&subcommand, target, &rustc_version, verbose);\n \n     // Invoke actual cargo for the job, but with different flags.\n     // We re-use `cargo test` and `cargo run`, which makes target and binary handling very easy but\n@@ -486,8 +486,7 @@ pub fn phase_runner(mut binary_args: impl Iterator<Item = String>, phase: Runner\n                 continue;\n             } else if verbose > 0 {\n                 eprintln!(\n-                    \"[cargo-miri runner] Overwriting run-time env var {:?}={:?} with build-time value {:?}\",\n-                    name, old_val, val\n+                    \"[cargo-miri runner] Overwriting run-time env var {name:?}={old_val:?} with build-time value {val:?}\"\n                 );\n             }\n         }"}, {"sha": "a696546954f90b9b3450aeb4610784cd1139742d", "filename": "src/tools/miri/cargo-miri/src/setup.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fsetup.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -13,7 +13,7 @@ use crate::util::*;\n /// Performs the setup required to make `cargo miri` work: Getting a custom-built libstd. Then sets\n /// `MIRI_SYSROOT`. Skipped if `MIRI_SYSROOT` is already set, in which case we expect the user has\n /// done all this already.\n-pub fn setup(subcommand: &MiriCommand, target: &str, rustc_version: &VersionMeta) {\n+pub fn setup(subcommand: &MiriCommand, target: &str, rustc_version: &VersionMeta, verbose: usize) {\n     let only_setup = matches!(subcommand, MiriCommand::Setup);\n     let ask_user = !only_setup;\n     let print_sysroot = only_setup && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n@@ -99,12 +99,13 @@ pub fn setup(subcommand: &MiriCommand, target: &str, rustc_version: &VersionMeta\n         // `config.toml`.\n         command.env(\"RUSTC_WRAPPER\", \"\");\n \n-        if only_setup {\n-            if print_sysroot {\n-                // Be extra sure there is no noise on stdout.\n-                command.stdout(process::Stdio::null());\n+        if only_setup && !print_sysroot {\n+            // Forward output. Even make it verbose, if requested.\n+            for _ in 0..verbose {\n+                command.arg(\"-v\");\n             }\n         } else {\n+            // Supress output.\n             command.stdout(process::Stdio::null());\n             command.stderr(process::Stdio::null());\n         }\n@@ -120,7 +121,9 @@ pub fn setup(subcommand: &MiriCommand, target: &str, rustc_version: &VersionMeta\n     std::env::set_var(\"MIRI_SYSROOT\", &sysroot_dir);\n \n     // Do the build.\n-    if only_setup {\n+    if print_sysroot {\n+        // Be silent.\n+    } else if only_setup {\n         // We want to be explicit.\n         eprintln!(\"Preparing a sysroot for Miri (target: {target})...\");\n     } else {\n@@ -143,7 +146,9 @@ pub fn setup(subcommand: &MiriCommand, target: &str, rustc_version: &VersionMeta\n                 )\n             }\n         });\n-    if only_setup {\n+    if print_sysroot {\n+        // Be silent.\n+    } else if only_setup {\n         eprintln!(\"A sysroot for Miri is now available in `{}`.\", sysroot_dir.display());\n     } else {\n         eprintln!(\"done\");"}, {"sha": "e455b482338f4b7d4cd748b1bfa8f34f799e5ead", "filename": "src/tools/miri/ci.sh", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fci.sh?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -40,10 +40,15 @@ function run_tests {\n   ./miri test\n   if [ -z \"${MIRI_TEST_TARGET+exists}\" ]; then\n     # Only for host architecture: tests with optimizations (`-O` is what cargo passes, but crank MIR\n-    # optimizations up all the way).\n-    # Optimizations change diagnostics (mostly backtraces), so we don't check them\n-    #FIXME(#2155): we want to only run the pass and panic tests here, not the fail tests.\n+    # optimizations up all the way, too).\n+    # Optimizations change diagnostics (mostly backtraces), so we don't check\n+    # them. Also error locations change so we don't run the failing tests.\n     MIRIFLAGS=\"${MIRIFLAGS:-} -O -Zmir-opt-level=4\" MIRI_SKIP_UI_CHECKS=1 ./miri test -- tests/{pass,panic}\n+\n+    # Also run some many-seeds tests. 64 seeds means this takes around a minute per test.\n+    for FILE in tests/many-seeds/*.rs; do\n+      MIRI_SEEDS=64 CARGO_EXTRA_FLAGS=\"$CARGO_EXTRA_FLAGS -q\" ./miri many-seeds ./miri run \"$FILE\"\n+    done\n   fi\n \n   ## test-cargo-miri"}, {"sha": "a259576ed42a0edb8f2529f827a46ac216efa629", "filename": "src/tools/miri/miri", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fmiri?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -36,7 +36,8 @@ Mainly meant to be invoked by rust-analyzer.\n ./miri many-seeds <command>:\n Runs <command> over and over again with different seeds for Miri. The MIRIFLAGS\n variable is set to its original value appended with ` -Zmiri-seed=$SEED` for\n-many different seeds.\n+many different seeds. The MIRI_SEEDS variable controls how many seeds are being\n+tried; MIRI_SEED_START controls the first seed to try.\n \n ./miri bench <benches>:\n Runs the benchmarks from bench-cargo-miri in hyperfine. hyperfine needs to be installed.\n@@ -174,7 +175,9 @@ rustc-push)\n     fi\n     ;;\n many-seeds)\n-    for SEED in $(seq 0 255); do\n+    MIRI_SEED_START=${MIRI_SEED_START:-0} # default to 0\n+    MIRI_SEEDS=${MIRI_SEEDS:-256} # default to 256\n+    for SEED in $(seq $MIRI_SEED_START $(( $MIRI_SEED_START + $MIRI_SEEDS - 1 )) ); do\n         echo \"Trying seed: $SEED\"\n         MIRIFLAGS=\"$MIRIFLAGS -Zlayout-seed=$SEED -Zmiri-seed=$SEED\" $@ || { echo \"Failing seed: $SEED\"; break; }\n     done\n@@ -249,6 +252,8 @@ export RUSTFLAGS=\"-C link-args=-Wl,-rpath,$LIBDIR $RUSTFLAGS\"\n # Build a sysroot and set MIRI_SYSROOT to use it. Arguments are passed to `cargo miri setup`.\n build_sysroot() {\n     if ! MIRI_SYSROOT=\"$($CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml -- miri setup --print-sysroot \"$@\")\"; then\n+        # Run it again so the user can see the error.\n+        $CARGO run $CARGO_EXTRA_FLAGS --manifest-path \"$MIRIDIR\"/cargo-miri/Cargo.toml -- miri setup \"$@\"\n         echo \"'cargo miri setup' failed\"\n         exit 1\n     fi"}, {"sha": "0a6b9417cc2e2804410a5d64c412e158c0f53e05", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1 +1 @@\n-454784afba5bf35b5ff14ada0e31265ad1d75e73\n+cef44f53034eac46be3a0e3eec7b2b3d4ef5140b"}, {"sha": "fce95b987f729dc26c353bb8f7871905b6b57f3a", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -192,10 +192,7 @@ fn init_late_loggers(tcx: TyCtxt<'_>) {\n             if log::Level::from_str(&var).is_ok() {\n                 env::set_var(\n                     \"RUSTC_LOG\",\n-                    format!(\n-                        \"rustc_middle::mir::interpret={0},rustc_const_eval::interpret={0}\",\n-                        var\n-                    ),\n+                    format!(\"rustc_middle::mir::interpret={var},rustc_const_eval::interpret={var}\"),\n                 );\n             } else {\n                 env::set_var(\"RUSTC_LOG\", &var);\n@@ -317,7 +314,7 @@ fn main() {\n         } else if arg == \"-Zmiri-disable-validation\" {\n             miri_config.validate = false;\n         } else if arg == \"-Zmiri-disable-stacked-borrows\" {\n-            miri_config.stacked_borrows = false;\n+            miri_config.borrow_tracker = None;\n         } else if arg == \"-Zmiri-disable-data-race-detector\" {\n             miri_config.data_race_detector = false;\n             miri_config.weak_memory_emulation = false;\n@@ -413,7 +410,7 @@ fn main() {\n                         err\n                     ),\n             };\n-            for id in ids.into_iter().map(miri::SbTag::new) {\n+            for id in ids.into_iter().map(miri::BorTag::new) {\n                 if let Some(id) = id {\n                     miri_config.tracked_pointer_tags.insert(id);\n                 } else {"}, {"sha": "10e6e252e94b70428b58a4a7511522307c305266", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,371 @@\n+use std::cell::RefCell;\n+use std::fmt;\n+use std::num::NonZeroU64;\n+\n+use log::trace;\n+use smallvec::SmallVec;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_middle::mir::RetagKind;\n+use rustc_target::abi::Size;\n+\n+use crate::*;\n+pub mod stacked_borrows;\n+use stacked_borrows::diagnostics::RetagCause;\n+\n+pub type CallId = NonZeroU64;\n+\n+/// Tracking pointer provenance\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct BorTag(NonZeroU64);\n+\n+impl BorTag {\n+    pub fn new(i: u64) -> Option<Self> {\n+        NonZeroU64::new(i).map(BorTag)\n+    }\n+\n+    pub fn get(&self) -> u64 {\n+        self.0.get()\n+    }\n+\n+    pub fn inner(&self) -> NonZeroU64 {\n+        self.0\n+    }\n+\n+    pub fn succ(self) -> Option<Self> {\n+        self.0.checked_add(1).map(Self)\n+    }\n+\n+    /// The minimum representable tag\n+    pub fn one() -> Self {\n+        Self::new(1).unwrap()\n+    }\n+}\n+\n+impl std::default::Default for BorTag {\n+    /// The default to be used when borrow tracking is disabled\n+    fn default() -> Self {\n+        Self::one()\n+    }\n+}\n+\n+impl fmt::Debug for BorTag {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"<{}>\", self.0)\n+    }\n+}\n+\n+/// Per-call-stack-frame data for borrow tracking\n+#[derive(Debug)]\n+pub struct FrameState {\n+    /// The ID of the call this frame corresponds to.\n+    pub call_id: CallId,\n+\n+    /// If this frame is protecting any tags, they are listed here. We use this list to do\n+    /// incremental updates of the global list of protected tags stored in the\n+    /// `stacked_borrows::GlobalState` upon function return, and if we attempt to pop a protected\n+    /// tag, to identify which call is responsible for protecting the tag.\n+    /// See `Stack::item_popped` for more explanation.\n+    ///\n+    /// This will contain one tag per reference passed to the function, so\n+    /// a size of 2 is enough for the vast majority of functions.\n+    pub protected_tags: SmallVec<[BorTag; 2]>,\n+}\n+\n+impl VisitTags for FrameState {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n+        // `protected_tags` are fine to GC.\n+    }\n+}\n+\n+/// Extra global state, available to the memory access hooks.\n+#[derive(Debug)]\n+pub struct GlobalStateInner {\n+    /// Borrow tracker method currently in use.\n+    pub borrow_tracker_method: BorrowTrackerMethod,\n+    /// Next unused pointer ID (tag).\n+    pub next_ptr_tag: BorTag,\n+    /// Table storing the \"base\" tag for each allocation.\n+    /// The base tag is the one used for the initial pointer.\n+    /// We need this in a separate table to handle cyclic statics.\n+    pub base_ptr_tags: FxHashMap<AllocId, BorTag>,\n+    /// Next unused call ID (for protectors).\n+    pub next_call_id: CallId,\n+    /// All currently protected tags.\n+    /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n+    /// We add tags to this when they are created with a protector in `reborrow`, and\n+    /// we remove tags from this when the call which is protecting them returns, in\n+    /// `GlobalStateInner::end_call`. See `Stack::item_popped` for more details.\n+    pub protected_tags: FxHashMap<BorTag, ProtectorKind>,\n+    /// The pointer ids to trace\n+    pub tracked_pointer_tags: FxHashSet<BorTag>,\n+    /// The call ids to trace\n+    pub tracked_call_ids: FxHashSet<CallId>,\n+    /// Whether to recurse into datatypes when searching for pointers to retag.\n+    pub retag_fields: RetagFields,\n+}\n+\n+impl VisitTags for GlobalStateInner {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n+        // The only candidate is base_ptr_tags, and that does not need visiting since we don't ever\n+        // GC the bottommost tag.\n+    }\n+}\n+\n+/// We need interior mutable access to the global state.\n+pub type GlobalState = RefCell<GlobalStateInner>;\n+\n+/// Indicates which kind of access is being performed.\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n+pub enum AccessKind {\n+    Read,\n+    Write,\n+}\n+\n+impl fmt::Display for AccessKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AccessKind::Read => write!(f, \"read access\"),\n+            AccessKind::Write => write!(f, \"write access\"),\n+        }\n+    }\n+}\n+\n+/// Policy on whether to recurse into fields to retag\n+#[derive(Copy, Clone, Debug)]\n+pub enum RetagFields {\n+    /// Don't retag any fields.\n+    No,\n+    /// Retag all fields.\n+    Yes,\n+    /// Only retag fields of types with Scalar and ScalarPair layout,\n+    /// to match the LLVM `noalias` we generate.\n+    OnlyScalar,\n+}\n+\n+/// The flavor of the protector.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ProtectorKind {\n+    /// Protected against aliasing violations from other pointers.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated, *but* the pointer itself may\n+    /// still be used to issue a deallocation.\n+    ///\n+    /// This is required for LLVM IR pointers that are `noalias` but *not* `dereferenceable`.\n+    WeakProtector,\n+\n+    /// Protected against any kind of invalidation.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated or the memory is deallocated.\n+    /// This is strictly stronger protection than `WeakProtector`.\n+    ///\n+    /// This is required for LLVM IR pointers that are `dereferenceable` (and also allows `noalias`).\n+    StrongProtector,\n+}\n+\n+/// Utilities for initialization and ID generation\n+impl GlobalStateInner {\n+    pub fn new(\n+        borrow_tracker_method: BorrowTrackerMethod,\n+        tracked_pointer_tags: FxHashSet<BorTag>,\n+        tracked_call_ids: FxHashSet<CallId>,\n+        retag_fields: RetagFields,\n+    ) -> Self {\n+        GlobalStateInner {\n+            borrow_tracker_method,\n+            next_ptr_tag: BorTag::one(),\n+            base_ptr_tags: FxHashMap::default(),\n+            next_call_id: NonZeroU64::new(1).unwrap(),\n+            protected_tags: FxHashMap::default(),\n+            tracked_pointer_tags,\n+            tracked_call_ids,\n+            retag_fields,\n+        }\n+    }\n+\n+    /// Generates a new pointer tag. Remember to also check track_pointer_tags and log its creation!\n+    pub fn new_ptr(&mut self) -> BorTag {\n+        let id = self.next_ptr_tag;\n+        self.next_ptr_tag = id.succ().unwrap();\n+        id\n+    }\n+\n+    pub fn new_frame(&mut self, machine: &MiriMachine<'_, '_>) -> FrameState {\n+        let call_id = self.next_call_id;\n+        trace!(\"new_frame: Assigning call ID {}\", call_id);\n+        if self.tracked_call_ids.contains(&call_id) {\n+            machine.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n+        }\n+        self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n+        FrameState { call_id, protected_tags: SmallVec::new() }\n+    }\n+\n+    pub fn end_call(&mut self, frame: &machine::FrameExtra<'_>) {\n+        for tag in &frame\n+            .borrow_tracker\n+            .as_ref()\n+            .expect(\"we should have borrow tracking data\")\n+            .protected_tags\n+        {\n+            self.protected_tags.remove(tag);\n+        }\n+    }\n+\n+    pub fn base_ptr_tag(&mut self, id: AllocId, machine: &MiriMachine<'_, '_>) -> BorTag {\n+        self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n+            let tag = self.new_ptr();\n+            if self.tracked_pointer_tags.contains(&tag) {\n+                machine.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n+                    tag.inner(),\n+                    None,\n+                    None,\n+                ));\n+            }\n+            trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n+            self.base_ptr_tags.try_insert(id, tag).unwrap();\n+            tag\n+        })\n+    }\n+}\n+\n+/// Which borrow tracking method to use\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum BorrowTrackerMethod {\n+    /// Stacked Borrows, as implemented in borrow_tracker/stacked\n+    StackedBorrows,\n+}\n+\n+impl BorrowTrackerMethod {\n+    pub fn instanciate_global_state(self, config: &MiriConfig) -> GlobalState {\n+        RefCell::new(GlobalStateInner::new(\n+            self,\n+            config.tracked_pointer_tags.clone(),\n+            config.tracked_call_ids.clone(),\n+            config.retag_fields,\n+        ))\n+    }\n+}\n+\n+impl GlobalStateInner {\n+    pub fn new_allocation(\n+        &mut self,\n+        id: AllocId,\n+        alloc_size: Size,\n+        kind: MemoryKind<machine::MiriMemoryKind>,\n+        machine: &MiriMachine<'_, '_>,\n+    ) -> AllocState {\n+        match self.borrow_tracker_method {\n+            BorrowTrackerMethod::StackedBorrows =>\n+                AllocState::StackedBorrows(Box::new(RefCell::new(Stacks::new_allocation(\n+                    id, alloc_size, self, kind, machine,\n+                )))),\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag(kind, place),\n+        }\n+    }\n+\n+    fn retag_return_place(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag_return_place(),\n+        }\n+    }\n+\n+    fn expose_tag(&mut self, alloc_id: AllocId, tag: BorTag) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_expose_tag(alloc_id, tag),\n+        }\n+    }\n+}\n+\n+/// Extra per-allocation data for borrow tracking\n+#[derive(Debug, Clone)]\n+pub enum AllocState {\n+    /// Data corresponding to Stacked Borrows\n+    StackedBorrows(Box<RefCell<stacked_borrows::AllocState>>),\n+}\n+\n+impl machine::AllocExtra {\n+    #[track_caller]\n+    pub fn borrow_tracker_sb(&self) -> &RefCell<stacked_borrows::AllocState> {\n+        match self.borrow_tracker {\n+            Some(AllocState::StackedBorrows(ref sb)) => sb,\n+            _ => panic!(\"expected Stacked Borrows borrow tracking, got something else\"),\n+        }\n+    }\n+\n+    #[track_caller]\n+    pub fn borrow_tracker_sb_mut(&mut self) -> &mut RefCell<stacked_borrows::AllocState> {\n+        match self.borrow_tracker {\n+            Some(AllocState::StackedBorrows(ref mut sb)) => sb,\n+            _ => panic!(\"expected Stacked Borrows borrow tracking, got something else\"),\n+        }\n+    }\n+}\n+\n+impl AllocState {\n+    pub fn before_memory_read<'tcx>(\n+        &self,\n+        alloc_id: AllocId,\n+        prov_extra: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match self {\n+            AllocState::StackedBorrows(sb) =>\n+                sb.borrow_mut().before_memory_read(alloc_id, prov_extra, range, machine),\n+        }\n+    }\n+\n+    pub fn before_memory_write<'tcx>(\n+        &mut self,\n+        alloc_id: AllocId,\n+        prov_extra: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match self {\n+            AllocState::StackedBorrows(sb) =>\n+                sb.get_mut().before_memory_write(alloc_id, prov_extra, range, machine),\n+        }\n+    }\n+\n+    pub fn before_memory_deallocation<'tcx>(\n+        &mut self,\n+        alloc_id: AllocId,\n+        prov_extra: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match self {\n+            AllocState::StackedBorrows(sb) =>\n+                sb.get_mut().before_memory_deallocation(alloc_id, prov_extra, range, machine),\n+        }\n+    }\n+\n+    pub fn remove_unreachable_tags(&self, tags: &FxHashSet<BorTag>) {\n+        match self {\n+            AllocState::StackedBorrows(sb) => sb.borrow_mut().remove_unreachable_tags(tags),\n+        }\n+    }\n+}\n+\n+impl VisitTags for AllocState {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        match self {\n+            AllocState::StackedBorrows(sb) => sb.visit_tags(visit),\n+        }\n+    }\n+}"}, {"sha": "9a7b38b13a3ade0d98fd88f702e9f14dfffde491", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/diagnostics.rs", "status": "renamed", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1,15 +1,16 @@\n use smallvec::SmallVec;\n use std::fmt;\n \n-use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange};\n+use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange, InterpError};\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n-use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission, ProtectorKind};\n+use crate::borrow_tracker::{\n+    stacked_borrows::{err_sb_ub, Permission},\n+    AccessKind, GlobalStateInner, ProtectorKind,\n+};\n use crate::*;\n \n-use rustc_middle::mir::interpret::InterpError;\n-\n #[derive(Clone, Debug)]\n pub struct AllocHistory {\n     id: AllocId,\n@@ -51,7 +52,7 @@ impl Creation {\n \n #[derive(Clone, Debug)]\n struct Invalidation {\n-    tag: SbTag,\n+    tag: BorTag,\n     range: AllocRange,\n     span: Span,\n     cause: InvalidationCause,\n@@ -98,7 +99,7 @@ impl fmt::Display for InvalidationCause {\n \n #[derive(Clone, Debug)]\n struct Protection {\n-    tag: SbTag,\n+    tag: BorTag,\n     span: Span,\n }\n \n@@ -133,7 +134,7 @@ impl<'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     pub fn retag(\n         machine: &'ecx MiriMachine<'mir, 'tcx>,\n         cause: RetagCause,\n-        new_tag: SbTag,\n+        new_tag: BorTag,\n         orig_tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n@@ -183,7 +184,7 @@ enum Operation {\n #[derive(Debug, Clone)]\n struct RetagOp {\n     cause: RetagCause,\n-    new_tag: SbTag,\n+    new_tag: BorTag,\n     orig_tag: ProvenanceExtra,\n     range: AllocRange,\n     permission: Option<Permission>,\n@@ -255,7 +256,7 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             .push(Creation { retag: op.clone(), span: self.machine.current_span() });\n     }\n \n-    pub fn log_invalidation(&mut self, tag: SbTag) {\n+    pub fn log_invalidation(&mut self, tag: BorTag) {\n         let mut span = self.machine.current_span();\n         let (range, cause) = match &self.operation {\n             Operation::Retag(RetagOp { cause, range, permission, .. }) => {\n@@ -286,8 +287,8 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n \n     pub fn get_logs_relevant_to(\n         &self,\n-        tag: SbTag,\n-        protector_tag: Option<SbTag>,\n+        tag: BorTag,\n+        protector_tag: Option<BorTag>,\n     ) -> Option<TagHistory> {\n         let Some(created) = self.history\n             .creations\n@@ -408,7 +409,7 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             .all_stacks()\n             .flatten()\n             .map(|frame| {\n-                frame.extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\")\n+                frame.extra.borrow_tracker.as_ref().expect(\"we should have borrow tracking data\")\n             })\n             .find(|frame| frame.protected_tags.contains(&item.tag()))\n             .map(|frame| frame.call_id)\n@@ -454,23 +455,18 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n         if !global.tracked_pointer_tags.contains(&item.tag()) {\n             return;\n         }\n-        let summary = match self.operation {\n-            Operation::Dealloc(_) => None,\n-            Operation::Access(AccessOp { kind, tag, .. }) => Some((tag, kind)),\n+        let cause = match self.operation {\n+            Operation::Dealloc(_) => format!(\" due to deallocation\"),\n+            Operation::Access(AccessOp { kind, tag, .. }) =>\n+                format!(\" due to {kind:?} access for {tag:?}\"),\n             Operation::Retag(RetagOp { orig_tag, permission, .. }) => {\n-                let kind = match permission\n-                    .expect(\"start_grant should set the current permission before popping a tag\")\n-                {\n-                    Permission::SharedReadOnly => AccessKind::Read,\n-                    Permission::Unique => AccessKind::Write,\n-                    Permission::SharedReadWrite | Permission::Disabled => {\n-                        panic!(\"Only SharedReadOnly and Unique retags can pop tags\");\n-                    }\n-                };\n-                Some((orig_tag, kind))\n+                let permission = permission\n+                    .expect(\"start_grant should set the current permission before popping a tag\");\n+                format!(\" due to {permission:?} retag from {orig_tag:?}\")\n             }\n         };\n-        self.machine.emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n+\n+        self.machine.emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, cause));\n     }\n }\n ", "previous_filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs"}, {"sha": "b9a52e4966cd7230914e084d568b77e782a2195f", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/item.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fitem.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1,13 +1,13 @@\n-use crate::stacked_borrows::SbTag;\n use std::fmt;\n-use std::num::NonZeroU64;\n+\n+use crate::borrow_tracker::BorTag;\n \n /// An item in the per-location borrow stack.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Item(u64);\n \n // An Item contains 3 bitfields:\n-// * Bits 0-61 store an SbTag\n+// * Bits 0-61 store a BorTag\n // * Bits 61-63 store a Permission\n // * Bit 64 stores a flag which indicates if we have a protector\n const TAG_MASK: u64 = u64::MAX >> 3;\n@@ -18,9 +18,9 @@ const PERM_SHIFT: u64 = 61;\n const PROTECTED_SHIFT: u64 = 63;\n \n impl Item {\n-    pub fn new(tag: SbTag, perm: Permission, protected: bool) -> Self {\n-        assert!(tag.0.get() <= TAG_MASK);\n-        let packed_tag = tag.0.get();\n+    pub fn new(tag: BorTag, perm: Permission, protected: bool) -> Self {\n+        assert!(tag.get() <= TAG_MASK);\n+        let packed_tag = tag.get();\n         let packed_perm = perm.to_bits() << PERM_SHIFT;\n         let packed_protected = u64::from(protected) << PROTECTED_SHIFT;\n \n@@ -34,8 +34,8 @@ impl Item {\n     }\n \n     /// The pointers the permission is granted to.\n-    pub fn tag(self) -> SbTag {\n-        SbTag(NonZeroU64::new(self.0 & TAG_MASK).unwrap())\n+    pub fn tag(self) -> BorTag {\n+        BorTag::new(self.0 & TAG_MASK).unwrap()\n     }\n \n     /// The permission this item grants.", "previous_filename": "src/tools/miri/src/stacked_borrows/item.rs"}, {"sha": "50c2ad75ca71e6113334dd5b965b86ef6fb06683", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "renamed", "additions": 62, "deletions": 267, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -2,81 +2,30 @@\n //! for further information.\n \n use log::trace;\n-use std::cell::RefCell;\n use std::cmp;\n-use std::fmt;\n-use std::fmt::Write;\n-use std::num::NonZeroU64;\n+use std::fmt::{self, Write};\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::Mutability;\n-use rustc_middle::mir::RetagKind;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::mir::{Mutability, RetagKind};\n use rustc_middle::ty::{\n     self,\n     layout::{HasParamEnv, LayoutOf},\n };\n-use rustc_target::abi::Abi;\n-use rustc_target::abi::Size;\n-use smallvec::SmallVec;\n+use rustc_target::abi::{Abi, Size};\n \n+use crate::borrow_tracker::{\n+    stacked_borrows::diagnostics::{AllocHistory, DiagnosticCx, DiagnosticCxBuilder, TagHistory},\n+    AccessKind, GlobalStateInner, ProtectorKind, RetagCause, RetagFields,\n+};\n use crate::*;\n \n-pub mod diagnostics;\n-use diagnostics::{AllocHistory, DiagnosticCx, DiagnosticCxBuilder, RetagCause, TagHistory};\n-\n mod item;\n pub use item::{Item, Permission};\n mod stack;\n pub use stack::Stack;\n+pub mod diagnostics;\n \n-pub type CallId = NonZeroU64;\n-\n-// Even reading memory can have effects on the stack, so we need a `RefCell` here.\n-pub type AllocExtra = RefCell<Stacks>;\n-\n-/// Tracking pointer provenance\n-#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct SbTag(NonZeroU64);\n-\n-impl SbTag {\n-    pub fn new(i: u64) -> Option<Self> {\n-        NonZeroU64::new(i).map(SbTag)\n-    }\n-\n-    // The default to be used when SB is disabled\n-    #[allow(clippy::should_implement_trait)]\n-    pub fn default() -> Self {\n-        Self::new(1).unwrap()\n-    }\n-}\n-\n-impl fmt::Debug for SbTag {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<{}>\", self.0)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct FrameExtra {\n-    /// The ID of the call this frame corresponds to.\n-    call_id: CallId,\n-\n-    /// If this frame is protecting any tags, they are listed here. We use this list to do\n-    /// incremental updates of the global list of protected tags stored in the\n-    /// `stacked_borrows::GlobalState` upon function return, and if we attempt to pop a protected\n-    /// tag, to identify which call is responsible for protecting the tag.\n-    /// See `Stack::item_invalidated` for more explanation.\n-    ///\n-    /// This will contain one tag per reference passed to the function, so\n-    /// a size of 2 is enough for the vast majority of functions.\n-    protected_tags: SmallVec<[SbTag; 2]>,\n-}\n-\n-impl VisitTags for FrameExtra {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n-        // `protected_tags` are fine to GC.\n-    }\n-}\n+pub type AllocState = Stacks;\n \n /// Extra per-allocation state.\n #[derive(Clone, Debug)]\n@@ -86,98 +35,16 @@ pub struct Stacks {\n     /// Stores past operations on this allocation\n     history: AllocHistory,\n     /// The set of tags that have been exposed inside this allocation.\n-    exposed_tags: FxHashSet<SbTag>,\n+    exposed_tags: FxHashSet<BorTag>,\n     /// Whether this memory has been modified since the last time the tag GC ran\n     modified_since_last_gc: bool,\n }\n \n-/// The flavor of the protector.\n-#[derive(Copy, Clone, Debug)]\n-enum ProtectorKind {\n-    /// Protected against aliasing violations from other pointers.\n-    ///\n-    /// Items protected like this cause UB when they are invalidated, *but* the pointer itself may\n-    /// still be used to issue a deallocation.\n-    ///\n-    /// This is required for LLVM IR pointers that are `noalias` but *not* `dereferenceable`.\n-    WeakProtector,\n-\n-    /// Protected against any kind of invalidation.\n-    ///\n-    /// Items protected like this cause UB when they are invalidated or the memory is deallocated.\n-    /// This is strictly stronger protection than `WeakProtector`.\n-    ///\n-    /// This is required for LLVM IR pointers that are `dereferenceable` (and also allows `noalias`).\n-    StrongProtector,\n-}\n-\n-/// Extra global state, available to the memory access hooks.\n-#[derive(Debug)]\n-pub struct GlobalStateInner {\n-    /// Next unused pointer ID (tag).\n-    next_ptr_tag: SbTag,\n-    /// Table storing the \"base\" tag for each allocation.\n-    /// The base tag is the one used for the initial pointer.\n-    /// We need this in a separate table to handle cyclic statics.\n-    base_ptr_tags: FxHashMap<AllocId, SbTag>,\n-    /// Next unused call ID (for protectors).\n-    next_call_id: CallId,\n-    /// All currently protected tags, and the status of their protection.\n-    /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n-    /// We add tags to this when they are created with a protector in `reborrow`, and\n-    /// we remove tags from this when the call which is protecting them returns, in\n-    /// `GlobalStateInner::end_call`. See `Stack::item_invalidated` for more details.\n-    protected_tags: FxHashMap<SbTag, ProtectorKind>,\n-    /// The pointer ids to trace\n-    tracked_pointer_tags: FxHashSet<SbTag>,\n-    /// The call ids to trace\n-    tracked_call_ids: FxHashSet<CallId>,\n-    /// Whether to recurse into datatypes when searching for pointers to retag.\n-    retag_fields: RetagFields,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum RetagFields {\n-    /// Don't retag any fields.\n-    No,\n-    /// Retag all fields.\n-    Yes,\n-    /// Only retag fields of types with Scalar and ScalarPair layout,\n-    /// to match the LLVM `noalias` we generate.\n-    OnlyScalar,\n-}\n-\n-impl VisitTags for GlobalStateInner {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n-        // The only candidate is base_ptr_tags, and that does not need visiting since we don't ever\n-        // GC the bottommost tag.\n-    }\n-}\n-\n-/// We need interior mutable access to the global state.\n-pub type GlobalState = RefCell<GlobalStateInner>;\n-\n-/// Indicates which kind of access is being performed.\n-#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n-pub enum AccessKind {\n-    Read,\n-    Write,\n-}\n-\n-impl fmt::Display for AccessKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            AccessKind::Read => write!(f, \"read access\"),\n-            AccessKind::Write => write!(f, \"write access\"),\n-        }\n-    }\n-}\n-\n /// Indicates which kind of reference is being created.\n /// Used by high-level `reborrow` to compute which permissions to grant to the\n /// new pointer.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-pub enum RefKind {\n+enum RefKind {\n     /// `&mut` and `Box`.\n     Unique { two_phase: bool },\n     /// `&` with or without interior mutability.\n@@ -198,65 +65,6 @@ impl fmt::Display for RefKind {\n     }\n }\n \n-/// Utilities for initialization and ID generation\n-impl GlobalStateInner {\n-    pub fn new(\n-        tracked_pointer_tags: FxHashSet<SbTag>,\n-        tracked_call_ids: FxHashSet<CallId>,\n-        retag_fields: RetagFields,\n-    ) -> Self {\n-        GlobalStateInner {\n-            next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n-            base_ptr_tags: FxHashMap::default(),\n-            next_call_id: NonZeroU64::new(1).unwrap(),\n-            protected_tags: FxHashMap::default(),\n-            tracked_pointer_tags,\n-            tracked_call_ids,\n-            retag_fields,\n-        }\n-    }\n-\n-    /// Generates a new pointer tag. Remember to also check track_pointer_tags and log its creation!\n-    fn new_ptr(&mut self) -> SbTag {\n-        let id = self.next_ptr_tag;\n-        self.next_ptr_tag = SbTag(NonZeroU64::new(id.0.get() + 1).unwrap());\n-        id\n-    }\n-\n-    pub fn new_frame(&mut self, machine: &MiriMachine<'_, '_>) -> FrameExtra {\n-        let call_id = self.next_call_id;\n-        trace!(\"new_frame: Assigning call ID {}\", call_id);\n-        if self.tracked_call_ids.contains(&call_id) {\n-            machine.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n-        }\n-        self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n-        FrameExtra { call_id, protected_tags: SmallVec::new() }\n-    }\n-\n-    pub fn end_call(&mut self, frame: &machine::FrameData<'_>) {\n-        for tag in &frame\n-            .stacked_borrows\n-            .as_ref()\n-            .expect(\"we should have Stacked Borrows data\")\n-            .protected_tags\n-        {\n-            self.protected_tags.remove(tag);\n-        }\n-    }\n-\n-    pub fn base_ptr_tag(&mut self, id: AllocId, machine: &MiriMachine<'_, '_>) -> SbTag {\n-        self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n-            let tag = self.new_ptr();\n-            if self.tracked_pointer_tags.contains(&tag) {\n-                machine.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(tag.0, None, None));\n-            }\n-            trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n-            self.base_ptr_tags.try_insert(id, tag).unwrap();\n-            tag\n-        })\n-    }\n-}\n-\n /// Error reporting\n pub fn err_sb_ub<'tcx>(\n     msg: String,\n@@ -329,14 +137,7 @@ impl<'tcx> Stack {\n         }\n     }\n \n-    /// Check if the given item is protected.\n-    ///\n-    /// The `provoking_access` argument is only used to produce diagnostics.\n-    /// It is `Some` when we are granting the contained access for said tag, and it is\n-    /// `None` during a deallocation.\n-    /// Within `provoking_access, the `AllocRange` refers the entire operation, and\n-    /// the `Size` refers to the specific location in the `AllocRange` that we are\n-    /// currently checking.\n+    /// The given item was invalidated -- check its protectors for whether that will cause UB.\n     fn item_invalidated(\n         item: &Item,\n         global: &GlobalStateInner,\n@@ -386,7 +187,7 @@ impl<'tcx> Stack {\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n-        exposed_tags: &FxHashSet<SbTag>,\n+        exposed_tags: &FxHashSet<BorTag>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n@@ -442,23 +243,24 @@ impl<'tcx> Stack {\n         if granting_idx.is_none() || matches!(tag, ProvenanceExtra::Wildcard) {\n             // Compute the upper bound of the items that remain.\n             // (This is why we did all the work above: to reduce the items we have to consider here.)\n-            let mut max = NonZeroU64::new(1).unwrap();\n+            let mut max = BorTag::one();\n             for i in 0..self.len() {\n                 let item = self.get(i).unwrap();\n                 // Skip disabled items, they cannot be matched anyway.\n                 if !matches!(item.perm(), Permission::Disabled) {\n                     // We are looking for a strict upper bound, so add 1 to this tag.\n-                    max = cmp::max(item.tag().0.checked_add(1).unwrap(), max);\n+                    max = cmp::max(item.tag().succ().unwrap(), max);\n                 }\n             }\n             if let Some(unk) = self.unknown_bottom() {\n-                max = cmp::max(unk.0, max);\n+                max = cmp::max(unk, max);\n             }\n             // Use `max` as new strict upper bound for everything.\n             trace!(\n-                \"access: forgetting stack to upper bound {max} due to wildcard or unknown access\"\n+                \"access: forgetting stack to upper bound {max} due to wildcard or unknown access\",\n+                max = max.get(),\n             );\n-            self.set_unknown_bottom(SbTag(max));\n+            self.set_unknown_bottom(max);\n         }\n \n         // Done.\n@@ -472,7 +274,7 @@ impl<'tcx> Stack {\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n-        exposed_tags: &FxHashSet<SbTag>,\n+        exposed_tags: &FxHashSet<BorTag>,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make a write access.\n         // As part of this we do regular protector checking, i.e. even weakly protected items cause UB when popped.\n@@ -497,7 +299,7 @@ impl<'tcx> Stack {\n         access: Option<AccessKind>,\n         global: &GlobalStateInner,\n         dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n-        exposed_tags: &FxHashSet<SbTag>,\n+        exposed_tags: &FxHashSet<BorTag>,\n     ) -> InterpResult<'tcx> {\n         dcx.start_grant(new.perm());\n \n@@ -550,9 +352,9 @@ impl<'tcx> Stack {\n }\n // # Stacked Borrows Core End\n \n-/// Integration with the SbTag garbage collector\n+/// Integration with the BorTag garbage collector\n impl Stacks {\n-    pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<SbTag>) {\n+    pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<BorTag>) {\n         if self.modified_since_last_gc {\n             for stack in self.stacks.iter_mut_all() {\n                 if stack.len() > 64 {\n@@ -565,7 +367,7 @@ impl Stacks {\n }\n \n impl VisitTags for Stacks {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for tag in self.exposed_tags.iter().copied() {\n             visit(tag);\n         }\n@@ -579,7 +381,7 @@ impl<'tcx> Stacks {\n     fn new(\n         size: Size,\n         perm: Permission,\n-        tag: SbTag,\n+        tag: BorTag,\n         id: AllocId,\n         machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n@@ -602,7 +404,7 @@ impl<'tcx> Stacks {\n         mut f: impl FnMut(\n             &mut Stack,\n             &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n-            &mut FxHashSet<SbTag>,\n+            &mut FxHashSet<BorTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         self.modified_since_last_gc = true;\n@@ -620,20 +422,19 @@ impl Stacks {\n     pub fn new_allocation(\n         id: AllocId,\n         size: Size,\n-        state: &GlobalState,\n+        state: &mut GlobalStateInner,\n         kind: MemoryKind<MiriMemoryKind>,\n         machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n-        let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n             // New unique borrow. This tag is not accessible by the program,\n             // so it will only ever be used when using the local directly (i.e.,\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (extra.base_ptr_tag(id, machine), Permission::Unique),\n+            MemoryKind::Stack => (state.base_ptr_tag(id, machine), Permission::Unique),\n             // Everything else is shared by default.\n-            _ => (extra.base_ptr_tag(id, machine), Permission::SharedReadWrite),\n+            _ => (state.base_ptr_tag(id, machine), Permission::SharedReadWrite),\n         };\n         Stacks::new(size, perm, base_tag, id, machine)\n     }\n@@ -656,7 +457,7 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let dcx = DiagnosticCxBuilder::read(machine, tag, range);\n-        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n+        let state = machine.borrow_tracker.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Read, tag, &state, dcx, exposed_tags)\n         })\n@@ -677,7 +478,7 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let dcx = DiagnosticCxBuilder::write(machine, tag, range);\n-        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n+        let state = machine.borrow_tracker.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Write, tag, &state, dcx, exposed_tags)\n         })\n@@ -693,7 +494,7 @@ impl Stacks {\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let dcx = DiagnosticCxBuilder::dealloc(machine, tag);\n-        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n+        let state = machine.borrow_tracker.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.dealloc(tag, &state, dcx, exposed_tags)\n         })?;\n@@ -710,13 +511,13 @@ impl<'mir: 'ecx, 'tcx: 'mir, 'ecx> EvalContextPrivExt<'mir, 'tcx, 'ecx>\n trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Returns the `AllocId` the reborrow was done in, if some actual borrow stack manipulation\n     /// happened.\n-    fn reborrow(\n+    fn sb_reborrow(\n         &mut self,\n         place: &MPlaceTy<'tcx, Provenance>,\n         size: Size,\n         kind: RefKind,\n         retag_cause: RetagCause, // What caused this retag, for diagnostics only\n-        new_tag: SbTag,\n+        new_tag: BorTag,\n         protect: Option<ProtectorKind>,\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n@@ -725,7 +526,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let log_creation = |this: &MiriInterpCx<'mir, 'tcx>,\n                             loc: Option<(AllocId, Size, ProvenanceExtra)>| // alloc_id, base_offset, orig_tag\n          -> InterpResult<'tcx> {\n-            let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n+            let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n             let ty = place.layout.ty;\n             if global.tracked_pointer_tags.contains(&new_tag) {\n                 let mut kind_str = format!(\"{kind}\");\n@@ -743,7 +544,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     _ => write!(kind_str, \" (pointee type {ty})\").unwrap(),\n                 };\n                 this.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n-                    new_tag.0,\n+                    new_tag.inner(),\n                     Some(kind_str),\n                     loc.map(|(alloc_id, base_offset, orig_tag)| (alloc_id, alloc_range(base_offset, size), orig_tag)),\n                 ));\n@@ -762,9 +563,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     // uncovers a non-supported `extern static`.\n                     let extra = this.get_alloc_extra(alloc_id)?;\n                     let mut stacked_borrows = extra\n-                        .stacked_borrows\n-                        .as_ref()\n-                        .expect(\"we should have Stacked Borrows data\")\n+                        .borrow_tracker_sb()\n                         .borrow_mut();\n                     // Note that we create a *second* `DiagnosticCxBuilder` below for the actual retag.\n                     // FIXME: can this be done cleaner?\n@@ -780,7 +579,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     if protect.is_some() {\n                         dcx.log_protector();\n                     }\n-                }\n+                },\n                 AllocKind::Function | AllocKind::VTable | AllocKind::Dead => {\n                     // No stacked borrows on these allocations.\n                 }\n@@ -839,9 +638,9 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n \n         if let Some(protect) = protect {\n             // See comment in `Stack::item_invalidated` for why we store the tag twice.\n-            this.frame_mut().extra.stacked_borrows.as_mut().unwrap().protected_tags.push(new_tag);\n+            this.frame_mut().extra.borrow_tracker.as_mut().unwrap().protected_tags.push(new_tag);\n             this.machine\n-                .stacked_borrows\n+                .borrow_tracker\n                 .as_mut()\n                 .unwrap()\n                 .get_mut()\n@@ -875,11 +674,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n                 let alloc_extra = this.get_alloc_extra(alloc_id)?;\n-                let mut stacked_borrows = alloc_extra\n-                    .stacked_borrows\n-                    .as_ref()\n-                    .expect(\"we should have Stacked Borrows data\")\n-                    .borrow_mut();\n+                let mut stacked_borrows = alloc_extra.borrow_tracker_sb().borrow_mut();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -900,7 +695,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                         false\n                     };\n                     let item = Item::new(new_tag, perm, protected);\n-                    let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n+                    let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n                     let dcx = DiagnosticCxBuilder::retag(\n                         &this.machine,\n                         retag_cause,\n@@ -929,14 +724,10 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n-        let stacked_borrows = alloc_extra\n-            .stacked_borrows\n-            .as_mut()\n-            .expect(\"we should have Stacked Borrows data\")\n-            .get_mut();\n+        let stacked_borrows = alloc_extra.borrow_tracker_sb_mut().get_mut();\n         let item = Item::new(new_tag, perm, protect.is_some());\n         let range = alloc_range(base_offset, size);\n-        let global = machine.stacked_borrows.as_ref().unwrap().borrow();\n+        let global = machine.borrow_tracker.as_ref().unwrap().borrow();\n         let dcx = DiagnosticCxBuilder::retag(\n             machine,\n             retag_cause,\n@@ -960,8 +751,8 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n-    /// `mutbl` can be `None` to make this a raw pointer.\n-    fn retag_reference(\n+    /// `kind` indicates what kind of reference is being created.\n+    fn sb_retag_reference(\n         &mut self,\n         val: &ImmTy<'tcx, Provenance>,\n         kind: RefKind,\n@@ -981,10 +772,10 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         };\n \n         // Compute new borrow.\n-        let new_tag = this.machine.stacked_borrows.as_mut().unwrap().get_mut().new_ptr();\n+        let new_tag = this.machine.borrow_tracker.as_mut().unwrap().get_mut().new_ptr();\n \n         // Reborrow.\n-        let alloc_id = this.reborrow(&place, size, kind, retag_cause, new_tag, protect)?;\n+        let alloc_id = this.sb_reborrow(&place, size, kind, retag_cause, new_tag, protect)?;\n \n         // Adjust pointer.\n         let new_place = place.map_provenance(|p| {\n@@ -993,7 +784,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     Some(alloc_id) => {\n                         // If `reborrow` could figure out the AllocId of this ptr, hard-code it into the new one.\n                         // Even if we started out with a wildcard, this newly retagged pointer is tied to that allocation.\n-                        Provenance::Concrete { alloc_id, sb: new_tag }\n+                        Provenance::Concrete { alloc_id, tag: new_tag }\n                     }\n                     None => {\n                         // Looks like this has to stay a wildcard pointer.\n@@ -1011,9 +802,13 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+    fn sb_retag(\n+        &mut self,\n+        kind: RetagKind,\n+        place: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let retag_fields = this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields;\n+        let retag_fields = this.machine.borrow_tracker.as_mut().unwrap().get_mut().retag_fields;\n         let retag_cause = match kind {\n             RetagKind::TwoPhase { .. } => RetagCause::TwoPhase,\n             RetagKind::FnEntry => RetagCause::FnEntry,\n@@ -1039,7 +834,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 protector: Option<ProtectorKind>,\n             ) -> InterpResult<'tcx> {\n                 let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n-                let val = self.ecx.retag_reference(&val, ref_kind, retag_cause, protector)?;\n+                let val = self.ecx.sb_retag_reference(&val, ref_kind, retag_cause, protector)?;\n                 self.ecx.write_immediate(*val, place)?;\n                 Ok(())\n             }\n@@ -1138,7 +933,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ///\n     /// This is a HACK because there is nothing in MIR that would make the retag\n     /// explicit. Also see <https://github.com/rust-lang/rust/issues/71117>.\n-    fn retag_return_place(&mut self) -> InterpResult<'tcx> {\n+    fn sb_retag_return_place(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let return_place = &this.frame().return_place;\n         if return_place.layout.is_zst() {\n@@ -1153,7 +948,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n         // Reborrow it. With protection! That is part of the point.\n-        let val = this.retag_reference(\n+        let val = this.sb_retag_reference(\n             &val,\n             RefKind::Unique { two_phase: false },\n             RetagCause::FnReturn,\n@@ -1167,7 +962,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     /// Mark the given tag as exposed. It was found on a pointer with the given AllocId.\n-    fn expose_tag(&mut self, alloc_id: AllocId, tag: SbTag) -> InterpResult<'tcx> {\n+    fn sb_expose_tag(&mut self, alloc_id: AllocId, tag: BorTag) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         // Function pointers and dead objects don't have an alloc_extra so we ignore them.\n@@ -1181,7 +976,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // uncovers a non-supported `extern static`.\n                 let alloc_extra = this.get_alloc_extra(alloc_id)?;\n                 trace!(\"Stacked Borrows tag {tag:?} exposed in {alloc_id:?}\");\n-                alloc_extra.stacked_borrows.as_ref().unwrap().borrow_mut().exposed_tags.insert(tag);\n+                alloc_extra.borrow_tracker_sb().borrow_mut().exposed_tags.insert(tag);\n             }\n             AllocKind::Function | AllocKind::VTable | AllocKind::Dead => {\n                 // No stacked borrows on these allocations.\n@@ -1193,7 +988,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn print_stacks(&mut self, alloc_id: AllocId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let alloc_extra = this.get_alloc_extra(alloc_id)?;\n-        let stacks = alloc_extra.stacked_borrows.as_ref().unwrap().borrow();\n+        let stacks = alloc_extra.borrow_tracker_sb().borrow();\n         for (range, stack) in stacks.stacks.iter_all() {\n             print!(\"{range:?}: [\");\n             if let Some(bottom) = stack.unknown_bottom() {", "previous_filename": "src/tools/miri/src/stacked_borrows/mod.rs"}, {"sha": "1d5cfec3500aeeef7d05339592a8f37c0745e4df", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/stack.rs", "status": "renamed", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -3,11 +3,14 @@ use std::ops::Range;\n \n use rustc_data_structures::fx::FxHashSet;\n \n-use crate::stacked_borrows::{AccessKind, Item, Permission, SbTag};\n+use crate::borrow_tracker::{\n+    stacked_borrows::{Item, Permission},\n+    AccessKind, BorTag,\n+};\n use crate::ProvenanceExtra;\n \n /// Exactly what cache size we should use is a difficult tradeoff. There will always be some\n-/// workload which has a `SbTag` working set which exceeds the size of the cache, and ends up\n+/// workload which has a `BorTag` working set which exceeds the size of the cache, and ends up\n /// falling back to linear searches of the borrow stack very often.\n /// The cost of making this value too large is that the loop in `Stack::insert` which ensures the\n /// entries in the cache stay correct after an insert becomes expensive.\n@@ -28,7 +31,7 @@ pub struct Stack {\n     /// than `id`.\n     /// When the bottom is unknown, `borrows` always has a `SharedReadOnly` or `Unique` at the bottom;\n     /// we never have the unknown-to-known boundary in an SRW group.\n-    unknown_bottom: Option<SbTag>,\n+    unknown_bottom: Option<BorTag>,\n \n     /// A small LRU cache of searches of the borrow stack.\n     #[cfg(feature = \"stack-cache\")]\n@@ -40,7 +43,7 @@ pub struct Stack {\n }\n \n impl Stack {\n-    pub fn retain(&mut self, tags: &FxHashSet<SbTag>) {\n+    pub fn retain(&mut self, tags: &FxHashSet<BorTag>) {\n         let mut first_removed = None;\n \n         // We never consider removing the bottom-most tag. For stacks without an unknown\n@@ -185,7 +188,7 @@ impl<'tcx> Stack {\n         &mut self,\n         access: AccessKind,\n         tag: ProvenanceExtra,\n-        exposed_tags: &FxHashSet<SbTag>,\n+        exposed_tags: &FxHashSet<BorTag>,\n     ) -> Result<Option<usize>, ()> {\n         #[cfg(all(feature = \"stack-cache\", debug_assertions))]\n         self.verify_cache_consistency();\n@@ -219,12 +222,12 @@ impl<'tcx> Stack {\n \n         // Couldn't find it in the stack; but if there is an unknown bottom it might be there.\n         let found = self.unknown_bottom.is_some_and(|unknown_limit| {\n-            tag.0 < unknown_limit.0 // unknown_limit is an upper bound for what can be in the unknown bottom.\n+            tag < unknown_limit // unknown_limit is an upper bound for what can be in the unknown bottom.\n         });\n         if found { Ok(None) } else { Err(()) }\n     }\n \n-    fn find_granting_tagged(&mut self, access: AccessKind, tag: SbTag) -> Option<usize> {\n+    fn find_granting_tagged(&mut self, access: AccessKind, tag: BorTag) -> Option<usize> {\n         #[cfg(feature = \"stack-cache\")]\n         if let Some(idx) = self.find_granting_cache(access, tag) {\n             return Some(idx);\n@@ -243,7 +246,7 @@ impl<'tcx> Stack {\n     }\n \n     #[cfg(feature = \"stack-cache\")]\n-    fn find_granting_cache(&mut self, access: AccessKind, tag: SbTag) -> Option<usize> {\n+    fn find_granting_cache(&mut self, access: AccessKind, tag: BorTag) -> Option<usize> {\n         // This looks like a common-sense optimization; we're going to do a linear search of the\n         // cache or the borrow stack to scan the shorter of the two. This optimization is miniscule\n         // and this check actually ensures we do not access an invalid cache.\n@@ -349,11 +352,11 @@ impl<'tcx> Stack {\n         self.borrows.len()\n     }\n \n-    pub fn unknown_bottom(&self) -> Option<SbTag> {\n+    pub fn unknown_bottom(&self) -> Option<BorTag> {\n         self.unknown_bottom\n     }\n \n-    pub fn set_unknown_bottom(&mut self, tag: SbTag) {\n+    pub fn set_unknown_bottom(&mut self, tag: BorTag) {\n         // We clear the borrow stack but the lookup cache doesn't support clearing per se. Instead,\n         // there is a check explained in `find_granting_cache` which protects against accessing the\n         // cache when it has been cleared and not yet refilled.", "previous_filename": "src/tools/miri/src/stacked_borrows/stack.rs"}, {"sha": "bcbf45a3d24085fa01f97b9a9fd13dcf3f1c3380", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -59,7 +59,7 @@ use super::{\n     weak_memory::EvalContextExt as _,\n };\n \n-pub type AllocExtra = VClockAlloc;\n+pub type AllocState = VClockAlloc;\n \n /// Valid atomic read-write orderings, alias of atomic::Ordering (not non-exhaustive).\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -670,7 +670,7 @@ pub struct VClockAlloc {\n }\n \n impl VisitTags for VClockAlloc {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n         // No tags here.\n     }\n }\n@@ -1220,7 +1220,7 @@ pub struct GlobalState {\n }\n \n impl VisitTags for GlobalState {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n         // We don't have any tags.\n     }\n }"}, {"sha": "9c9d505297c2dd88bb4bff1f4893ca31e79eba68", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -45,7 +45,7 @@ pub(super) struct InitOnce<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for waiter in self.waiters.iter() {\n             waiter.callback.visit_tags(visit);\n         }"}, {"sha": "402c9ce6fc9af927e9331eafd3ea9056f7f34c18", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -181,7 +181,7 @@ pub(crate) struct SynchronizationState<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> VisitTags for SynchronizationState<'mir, 'tcx> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for init_once in self.init_onces.iter() {\n             init_once.visit_tags(visit);\n         }"}, {"sha": "03f9ed351fb694db10a0d7e7f9a081db80bc29b8", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 146, "deletions": 143, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -3,6 +3,7 @@\n use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::num::TryFromIntError;\n+use std::task::Poll;\n use std::time::{Duration, SystemTime};\n \n use log::trace;\n@@ -16,18 +17,17 @@ use rustc_target::spec::abi::Abi;\n \n use crate::concurrency::data_race;\n use crate::concurrency::sync::SynchronizationState;\n+use crate::shims::tls;\n use crate::*;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-pub enum SchedulingAction {\n+enum SchedulingAction {\n     /// Execute step on the active thread.\n     ExecuteStep,\n     /// Execute a timeout callback.\n     ExecuteTimeoutCallback,\n-    /// Execute destructors of the active thread.\n-    ExecuteDtors,\n-    /// Stop the program.\n-    Stop,\n+    /// Wait for a bit, until there is a timeout to be called.\n+    Sleep(Duration),\n }\n \n /// Trait for callbacks that can be executed when some event happens, such as after a timeout.\n@@ -41,9 +41,6 @@ type TimeoutCallback<'mir, 'tcx> = Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>;\n #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n pub struct ThreadId(u32);\n \n-/// The main thread. When it terminates, the whole application terminates.\n-const MAIN_THREAD: ThreadId = ThreadId(0);\n-\n impl ThreadId {\n     pub fn to_u32(self) -> u32 {\n         self.0\n@@ -116,7 +113,13 @@ pub struct Thread<'mir, 'tcx> {\n     thread_name: Option<Vec<u8>>,\n \n     /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>>,\n+    stack: Vec<Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>>,\n+\n+    /// The function to call when the stack ran empty, to figure out what to do next.\n+    /// Conceptually, this is the interpreter implementation of the things that happen 'after' the\n+    /// Rust language entry point for this thread returns (usually implemented by the C or OS runtime).\n+    /// (`None` is an error, it means the callback has not been set up yet or is actively running.)\n+    pub(crate) on_stack_empty: Option<StackEmptyCallback<'mir, 'tcx>>,\n \n     /// The index of the topmost user-relevant frame in `stack`. This field must contain\n     /// the value produced by `get_top_user_relevant_frame`.\n@@ -137,19 +140,10 @@ pub struct Thread<'mir, 'tcx> {\n     pub(crate) last_error: Option<MPlaceTy<'tcx, Provenance>>,\n }\n \n-impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n-    /// Check if the thread is done executing (no more stack frames). If yes,\n-    /// change the state to terminated and return `true`.\n-    fn check_terminated(&mut self) -> bool {\n-        if self.state == ThreadState::Enabled {\n-            if self.stack.is_empty() {\n-                self.state = ThreadState::Terminated;\n-                return true;\n-            }\n-        }\n-        false\n-    }\n+pub type StackEmptyCallback<'mir, 'tcx> =\n+    Box<dyn FnMut(&mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx, Poll<()>>>;\n \n+impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n     /// Get the name of the current thread, or `<unnamed>` if it was not set.\n     fn thread_name(&self) -> &[u8] {\n         if let Some(ref thread_name) = self.thread_name { thread_name } else { b\"<unnamed>\" }\n@@ -202,30 +196,23 @@ impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n     }\n }\n \n-impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n-    fn default() -> Self {\n+impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n+    fn new(name: Option<&str>, on_stack_empty: Option<StackEmptyCallback<'mir, 'tcx>>) -> Self {\n         Self {\n             state: ThreadState::Enabled,\n-            thread_name: None,\n+            thread_name: name.map(|name| Vec::from(name.as_bytes())),\n             stack: Vec::new(),\n             top_user_relevant_frame: None,\n             join_status: ThreadJoinStatus::Joinable,\n             panic_payload: None,\n             last_error: None,\n+            on_stack_empty,\n         }\n     }\n }\n \n-impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n-    fn new(name: &str) -> Self {\n-        let mut thread = Thread::default();\n-        thread.thread_name = Some(Vec::from(name.as_bytes()));\n-        thread\n-    }\n-}\n-\n impl VisitTags for Thread<'_, '_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let Thread {\n             panic_payload,\n             last_error,\n@@ -234,6 +221,7 @@ impl VisitTags for Thread<'_, '_> {\n             state: _,\n             thread_name: _,\n             join_status: _,\n+            on_stack_empty: _, // we assume the closure captures no GC-relevant state\n         } = self;\n \n         panic_payload.visit_tags(visit);\n@@ -244,8 +232,8 @@ impl VisitTags for Thread<'_, '_> {\n     }\n }\n \n-impl VisitTags for Frame<'_, '_, Provenance, FrameData<'_>> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+impl VisitTags for Frame<'_, '_, Provenance, FrameExtra<'_>> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let Frame {\n             return_place,\n             locals,\n@@ -327,24 +315,8 @@ pub struct ThreadManager<'mir, 'tcx> {\n     timeout_callbacks: FxHashMap<ThreadId, TimeoutCallbackInfo<'mir, 'tcx>>,\n }\n \n-impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n-    fn default() -> Self {\n-        let mut threads = IndexVec::new();\n-        // Create the main thread and add it to the list of threads.\n-        threads.push(Thread::new(\"main\"));\n-        Self {\n-            active_thread: ThreadId::new(0),\n-            threads,\n-            sync: SynchronizationState::default(),\n-            thread_local_alloc_ids: Default::default(),\n-            yield_active_thread: false,\n-            timeout_callbacks: FxHashMap::default(),\n-        }\n-    }\n-}\n-\n impl VisitTags for ThreadManager<'_, '_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let ThreadManager {\n             threads,\n             thread_local_alloc_ids,\n@@ -367,8 +339,28 @@ impl VisitTags for ThreadManager<'_, '_> {\n     }\n }\n \n+impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n+    fn default() -> Self {\n+        let mut threads = IndexVec::new();\n+        // Create the main thread and add it to the list of threads.\n+        threads.push(Thread::new(Some(\"main\"), None));\n+        Self {\n+            active_thread: ThreadId::new(0),\n+            threads,\n+            sync: SynchronizationState::default(),\n+            thread_local_alloc_ids: Default::default(),\n+            yield_active_thread: false,\n+            timeout_callbacks: FxHashMap::default(),\n+        }\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n-    pub(crate) fn init(ecx: &mut MiriInterpCx<'mir, 'tcx>) {\n+    pub(crate) fn init(\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+        on_main_stack_empty: StackEmptyCallback<'mir, 'tcx>,\n+    ) {\n+        ecx.machine.threads.threads[ThreadId::new(0)].on_stack_empty = Some(on_main_stack_empty);\n         if ecx.tcx.sess.target.os.as_ref() != \"windows\" {\n             // The main thread can *not* be joined on except on windows.\n             ecx.machine.threads.threads[ThreadId::new(0)].join_status = ThreadJoinStatus::Detached;\n@@ -393,27 +385,27 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Borrow the stack of the active thread.\n-    pub fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>] {\n+    pub fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>] {\n         &self.threads[self.active_thread].stack\n     }\n \n     /// Mutably borrow the stack of the active thread.\n     fn active_thread_stack_mut(\n         &mut self,\n-    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n+    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>> {\n         &mut self.threads[self.active_thread].stack\n     }\n \n     pub fn all_stacks(\n         &self,\n-    ) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>]> {\n+    ) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>]> {\n         self.threads.iter().map(|t| &t.stack[..])\n     }\n \n     /// Create a new thread and returns its id.\n-    fn create_thread(&mut self) -> ThreadId {\n+    fn create_thread(&mut self, on_stack_empty: StackEmptyCallback<'mir, 'tcx>) -> ThreadId {\n         let new_thread_id = ThreadId::new(self.threads.len());\n-        self.threads.push(Default::default());\n+        self.threads.push(Thread::new(None, Some(on_stack_empty)));\n         new_thread_id\n     }\n \n@@ -458,7 +450,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get a mutable borrow of the currently active thread.\n-    fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n+    pub fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n         &mut self.threads[self.active_thread]\n     }\n \n@@ -669,37 +661,25 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// long as we can and switch only when we have to (the active thread was\n     /// blocked, terminated, or has explicitly asked to be preempted).\n     fn schedule(&mut self, clock: &Clock) -> InterpResult<'tcx, SchedulingAction> {\n-        // Check whether the thread has **just** terminated (`check_terminated`\n-        // checks whether the thread has popped all its stack and if yes, sets\n-        // the thread state to terminated).\n-        if self.threads[self.active_thread].check_terminated() {\n-            return Ok(SchedulingAction::ExecuteDtors);\n-        }\n-        // If we get here again and the thread is *still* terminated, there are no more dtors to run.\n-        if self.threads[MAIN_THREAD].state == ThreadState::Terminated {\n-            // The main thread terminated; stop the program.\n-            // We do *not* run TLS dtors of remaining threads, which seems to match rustc behavior.\n-            return Ok(SchedulingAction::Stop);\n-        }\n         // This thread and the program can keep going.\n         if self.threads[self.active_thread].state == ThreadState::Enabled\n             && !self.yield_active_thread\n         {\n             // The currently active thread is still enabled, just continue with it.\n             return Ok(SchedulingAction::ExecuteStep);\n         }\n-        // The active thread yielded. Let's see if there are any timeouts to take care of. We do\n-        // this *before* running any other thread, to ensure that timeouts \"in the past\" fire before\n-        // any other thread can take an action. This ensures that for `pthread_cond_timedwait`, \"an\n-        // error is returned if [...] the absolute time specified by abstime has already been passed\n-        // at the time of the call\".\n+        // The active thread yielded or got terminated. Let's see if there are any timeouts to take\n+        // care of. We do this *before* running any other thread, to ensure that timeouts \"in the\n+        // past\" fire before any other thread can take an action. This ensures that for\n+        // `pthread_cond_timedwait`, \"an error is returned if [...] the absolute time specified by\n+        // abstime has already been passed at the time of the call\".\n         // <https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html>\n         let potential_sleep_time =\n             self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time(clock)).min();\n         if potential_sleep_time == Some(Duration::new(0, 0)) {\n             return Ok(SchedulingAction::ExecuteTimeoutCallback);\n         }\n-        // No callbacks scheduled, pick a regular thread to execute.\n+        // No callbacks immediately scheduled, pick a regular thread to execute.\n         // The active thread blocked or yielded. So we go search for another enabled thread.\n         // Crucially, we start searching at the current active thread ID, rather than at 0, since we\n         // want to avoid always scheduling threads 0 and 1 without ever making progress in thread 2.\n@@ -730,15 +710,58 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             // All threads are currently blocked, but we have unexecuted\n             // timeout_callbacks, which may unblock some of the threads. Hence,\n             // sleep until the first callback.\n-\n-            clock.sleep(sleep_time);\n-            Ok(SchedulingAction::ExecuteTimeoutCallback)\n+            Ok(SchedulingAction::Sleep(sleep_time))\n         } else {\n             throw_machine_stop!(TerminationInfo::Deadlock);\n         }\n     }\n }\n \n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n+    /// Execute a timeout callback on the callback's thread.\n+    #[inline]\n+    fn run_timeout_callback(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (thread, callback) = if let Some((thread, callback)) =\n+            this.machine.threads.get_ready_callback(&this.machine.clock)\n+        {\n+            (thread, callback)\n+        } else {\n+            // get_ready_callback can return None if the computer's clock\n+            // was shifted after calling the scheduler and before the call\n+            // to get_ready_callback (see issue\n+            // https://github.com/rust-lang/miri/issues/1763). In this case,\n+            // just do nothing, which effectively just returns to the\n+            // scheduler.\n+            return Ok(());\n+        };\n+        // This back-and-forth with `set_active_thread` is here because of two\n+        // design decisions:\n+        // 1. Make the caller and not the callback responsible for changing\n+        //    thread.\n+        // 2. Make the scheduler the only place that can change the active\n+        //    thread.\n+        let old_thread = this.set_active_thread(thread);\n+        callback.call(this)?;\n+        this.set_active_thread(old_thread);\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn run_on_stack_empty(&mut self) -> InterpResult<'tcx, Poll<()>> {\n+        let this = self.eval_context_mut();\n+        let mut callback = this\n+            .active_thread_mut()\n+            .on_stack_empty\n+            .take()\n+            .expect(\"`on_stack_empty` not set up, or already running\");\n+        let res = callback(this)?;\n+        this.active_thread_mut().on_stack_empty = Some(callback);\n+        Ok(res)\n+    }\n+}\n+\n // Public interface to thread management.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n@@ -773,18 +796,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n+    /// Start a regular (non-main) thread.\n     #[inline]\n-    fn create_thread(&mut self) -> ThreadId {\n-        let this = self.eval_context_mut();\n-        let id = this.machine.threads.create_thread();\n-        if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.thread_created(&this.machine.threads, id);\n-        }\n-        id\n-    }\n-\n-    #[inline]\n-    fn start_thread(\n+    fn start_regular_thread(\n         &mut self,\n         thread: Option<MPlaceTy<'tcx, Provenance>>,\n         start_routine: Pointer<Option<Provenance>>,\n@@ -795,7 +809,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         // Create the new thread\n-        let new_thread_id = this.create_thread();\n+        let new_thread_id = this.machine.threads.create_thread({\n+            let mut state = tls::TlsDtorsState::default();\n+            Box::new(move |m| state.on_stack_empty(m))\n+        });\n+        if let Some(data_race) = &mut this.machine.data_race {\n+            data_race.thread_created(&this.machine.threads, new_thread_id);\n+        }\n \n         // Write the current thread-id, switch to the next thread later\n         // to treat this write operation as occuring on the current thread.\n@@ -888,12 +908,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.machine.threads.get_total_thread_count()\n     }\n \n-    #[inline]\n-    fn has_terminated(&self, thread_id: ThreadId) -> bool {\n-        let this = self.eval_context_ref();\n-        this.machine.threads.has_terminated(thread_id)\n-    }\n-\n     #[inline]\n     fn have_all_terminated(&self) -> bool {\n         let this = self.eval_context_ref();\n@@ -907,15 +921,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     #[inline]\n-    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>] {\n+    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>] {\n         let this = self.eval_context_ref();\n         this.machine.threads.active_thread_stack()\n     }\n \n     #[inline]\n     fn active_thread_stack_mut(\n         &mut self,\n-    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n+    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>> {\n         let this = self.eval_context_mut();\n         this.machine.threads.active_thread_stack_mut()\n     }\n@@ -943,26 +957,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     where\n         'mir: 'c,\n     {\n-        let this = self.eval_context_ref();\n-        this.machine.threads.get_thread_name(thread)\n+        self.eval_context_ref().machine.threads.get_thread_name(thread)\n     }\n \n     #[inline]\n     fn block_thread(&mut self, thread: ThreadId) {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.block_thread(thread);\n+        self.eval_context_mut().machine.threads.block_thread(thread);\n     }\n \n     #[inline]\n     fn unblock_thread(&mut self, thread: ThreadId) {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.unblock_thread(thread);\n+        self.eval_context_mut().machine.threads.unblock_thread(thread);\n     }\n \n     #[inline]\n     fn yield_active_thread(&mut self) {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.yield_active_thread();\n+        self.eval_context_mut().machine.threads.yield_active_thread();\n     }\n \n     #[inline]\n@@ -995,49 +1005,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.machine.threads.unregister_timeout_callback_if_exists(thread);\n     }\n \n-    /// Execute a timeout callback on the callback's thread.\n-    #[inline]\n-    fn run_timeout_callback(&mut self) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        let (thread, callback) = if let Some((thread, callback)) =\n-            this.machine.threads.get_ready_callback(&this.machine.clock)\n-        {\n-            (thread, callback)\n-        } else {\n-            // get_ready_callback can return None if the computer's clock\n-            // was shifted after calling the scheduler and before the call\n-            // to get_ready_callback (see issue\n-            // https://github.com/rust-lang/miri/issues/1763). In this case,\n-            // just do nothing, which effectively just returns to the\n-            // scheduler.\n-            return Ok(());\n-        };\n-        // This back-and-forth with `set_active_thread` is here because of two\n-        // design decisions:\n-        // 1. Make the caller and not the callback responsible for changing\n-        //    thread.\n-        // 2. Make the scheduler the only place that can change the active\n-        //    thread.\n-        let old_thread = this.set_active_thread(thread);\n-        callback.call(this)?;\n-        this.set_active_thread(old_thread);\n-        Ok(())\n-    }\n-\n-    /// Decide which action to take next and on which thread.\n-    #[inline]\n-    fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n+    /// Run the core interpreter loop. Returns only when an interrupt occurs (an error or program\n+    /// termination).\n+    fn run_threads(&mut self) -> InterpResult<'tcx, !> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.schedule(&this.machine.clock)\n+        loop {\n+            match this.machine.threads.schedule(&this.machine.clock)? {\n+                SchedulingAction::ExecuteStep => {\n+                    if !this.step()? {\n+                        // See if this thread can do something else.\n+                        match this.run_on_stack_empty()? {\n+                            Poll::Pending => {} // keep going\n+                            Poll::Ready(()) => this.terminate_active_thread()?,\n+                        }\n+                    }\n+                }\n+                SchedulingAction::ExecuteTimeoutCallback => {\n+                    this.run_timeout_callback()?;\n+                }\n+                SchedulingAction::Sleep(duration) => {\n+                    this.machine.clock.sleep(duration);\n+                }\n+            }\n+        }\n     }\n \n     /// Handles thread termination of the active thread: wakes up threads joining on this one,\n     /// and deallocated thread-local statics.\n     ///\n-    /// This is called from `tls.rs` after handling the TLS dtors.\n+    /// This is called by the eval loop when a thread's on_stack_empty returns `Ready`.\n     #[inline]\n-    fn thread_terminated(&mut self) -> InterpResult<'tcx> {\n+    fn terminate_active_thread(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        let thread = this.active_thread_mut();\n+        assert!(thread.stack.is_empty(), \"only threads with an empty stack can be terminated\");\n+        thread.state = ThreadState::Terminated;\n+\n         for ptr in this.machine.threads.thread_terminated(this.machine.data_race.as_mut()) {\n             this.deallocate_ptr(ptr.into(), None, MiriMemoryKind::Tls.into())?;\n         }"}, {"sha": "ba04991a5889d8bc5f7454f6558753af90e67f0b", "filename": "src/tools/miri/src/concurrency/vector_clock.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -404,67 +404,49 @@ mod tests {\n         assert_eq!(\n             alt_compare,\n             o.map(Ordering::reverse),\n-            \"Invalid alt comparison\\n l: {:?}\\n r: {:?}\",\n-            l,\n-            r\n+            \"Invalid alt comparison\\n l: {l:?}\\n r: {r:?}\"\n         );\n \n         //Test operators with faster implementations\n         assert_eq!(\n             matches!(compare, Some(Ordering::Less)),\n             l < r,\n-            \"Invalid (<):\\n l: {:?}\\n r: {:?}\",\n-            l,\n-            r\n+            \"Invalid (<):\\n l: {l:?}\\n r: {r:?}\"\n         );\n         assert_eq!(\n             matches!(compare, Some(Ordering::Less) | Some(Ordering::Equal)),\n             l <= r,\n-            \"Invalid (<=):\\n l: {:?}\\n r: {:?}\",\n-            l,\n-            r\n+            \"Invalid (<=):\\n l: {l:?}\\n r: {r:?}\"\n         );\n         assert_eq!(\n             matches!(compare, Some(Ordering::Greater)),\n             l > r,\n-            \"Invalid (>):\\n l: {:?}\\n r: {:?}\",\n-            l,\n-            r\n+            \"Invalid (>):\\n l: {l:?}\\n r: {r:?}\"\n         );\n         assert_eq!(\n             matches!(compare, Some(Ordering::Greater) | Some(Ordering::Equal)),\n             l >= r,\n-            \"Invalid (>=):\\n l: {:?}\\n r: {:?}\",\n-            l,\n-            r\n+            \"Invalid (>=):\\n l: {l:?}\\n r: {r:?}\"\n         );\n         assert_eq!(\n             matches!(alt_compare, Some(Ordering::Less)),\n             r < l,\n-            \"Invalid alt (<):\\n l: {:?}\\n r: {:?}\",\n-            l,\n-            r\n+            \"Invalid alt (<):\\n l: {l:?}\\n r: {r:?}\"\n         );\n         assert_eq!(\n             matches!(alt_compare, Some(Ordering::Less) | Some(Ordering::Equal)),\n             r <= l,\n-            \"Invalid alt (<=):\\n l: {:?}\\n r: {:?}\",\n-            l,\n-            r\n+            \"Invalid alt (<=):\\n l: {l:?}\\n r: {r:?}\"\n         );\n         assert_eq!(\n             matches!(alt_compare, Some(Ordering::Greater)),\n             r > l,\n-            \"Invalid alt (>):\\n l: {:?}\\n r: {:?}\",\n-            l,\n-            r\n+            \"Invalid alt (>):\\n l: {l:?}\\n r: {r:?}\"\n         );\n         assert_eq!(\n             matches!(alt_compare, Some(Ordering::Greater) | Some(Ordering::Equal)),\n             r >= l,\n-            \"Invalid alt (>=):\\n l: {:?}\\n r: {:?}\",\n-            l,\n-            r\n+            \"Invalid alt (>=):\\n l: {l:?}\\n r: {r:?}\"\n         );\n     }\n }"}, {"sha": "391681444d9ba03ce2c26b413a77ebe7eee2acf4", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -93,7 +93,7 @@ use super::{\n     vector_clock::{VClock, VTimestamp, VectorIdx},\n };\n \n-pub type AllocExtra = StoreBufferAlloc;\n+pub type AllocState = StoreBufferAlloc;\n \n // Each store buffer must be bounded otherwise it will grow indefinitely.\n // However, bounding the store buffer means restricting the amount of weak\n@@ -109,7 +109,7 @@ pub struct StoreBufferAlloc {\n }\n \n impl VisitTags for StoreBufferAlloc {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let Self { store_buffers } = self;\n         for val in store_buffers\n             .borrow()"}, {"sha": "074fa032dcc427537ef840c750aeee4830e657f3", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -6,12 +6,15 @@ use log::trace;\n use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n use rustc_target::abi::{Align, Size};\n \n-use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind};\n+use crate::borrow_tracker::stacked_borrows::diagnostics::TagHistory;\n use crate::*;\n \n /// Details of premature program termination.\n pub enum TerminationInfo {\n-    Exit(i64),\n+    Exit {\n+        code: i64,\n+        leak_check: bool,\n+    },\n     Abort(String),\n     UnsupportedInIsolation(String),\n     StackedBorrowsUb {\n@@ -38,7 +41,7 @@ impl fmt::Display for TerminationInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use TerminationInfo::*;\n         match self {\n-            Exit(code) => write!(f, \"the evaluated program completed with exit code {code}\"),\n+            Exit { code, .. } => write!(f, \"the evaluated program completed with exit code {code}\"),\n             Abort(msg) => write!(f, \"{msg}\"),\n             UnsupportedInIsolation(msg) => write!(f, \"{msg}\"),\n             Int2PtrWithStrictProvenance =>\n@@ -64,9 +67,8 @@ pub enum NonHaltingDiagnostic {\n     ///\n     /// new_kind is `None` for base tags.\n     CreatedPointerTag(NonZeroU64, Option<String>, Option<(AllocId, AllocRange, ProvenanceExtra)>),\n-    /// This `Item` was popped from the borrow stack, either due to an access with the given tag or\n-    /// a deallocation when the second argument is `None`.\n-    PoppedPointerTag(Item, Option<(ProvenanceExtra, AccessKind)>),\n+    /// This `Item` was popped from the borrow stack. The string explains the reason.\n+    PoppedPointerTag(Item, String),\n     CreatedCallId(CallId),\n     CreatedAlloc(AllocId, Size, Align, MemoryKind<MiriMemoryKind>),\n     FreedAlloc(AllocId),\n@@ -148,11 +150,11 @@ fn prune_stacktrace<'tcx>(\n \n /// Emit a custom diagnostic without going through the miri-engine machinery.\n ///\n-/// Returns `Some` if this was regular program termination with a given exit code, `None` otherwise.\n+/// Returns `Some` if this was regular program termination with a given exit code and a `bool` indicating whether a leak check should happen; `None` otherwise.\n pub fn report_error<'tcx, 'mir>(\n     ecx: &InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n     e: InterpErrorInfo<'tcx>,\n-) -> Option<i64> {\n+) -> Option<(i64, bool)> {\n     use InterpError::*;\n \n     let mut msg = vec![];\n@@ -161,7 +163,7 @@ pub fn report_error<'tcx, 'mir>(\n         let info = info.downcast_ref::<TerminationInfo>().expect(\"invalid MachineStop payload\");\n         use TerminationInfo::*;\n         let title = match info {\n-            Exit(code) => return Some(*code),\n+            Exit { code, leak_check } => return Some((*code, *leak_check)),\n             Abort(_) => Some(\"abnormal termination\"),\n             UnsupportedInIsolation(_) | Int2PtrWithStrictProvenance =>\n                 Some(\"unsupported operation\"),\n@@ -396,15 +398,7 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n                 format!(\n                     \"created tag {tag:?} for {kind} at {alloc_id:?}{range:?} derived from {orig_tag:?}\"\n                 ),\n-            PoppedPointerTag(item, tag) =>\n-                match tag {\n-                    None => format!(\"popped tracked tag for item {item:?} due to deallocation\",),\n-                    Some((tag, access)) => {\n-                        format!(\n-                            \"popped tracked tag for item {item:?} due to {access:?} access for {tag:?}\",\n-                        )\n-                    }\n-                },\n+            PoppedPointerTag(item, cause) => format!(\"popped tracked tag for item {item:?}{cause}\"),\n             CreatedCallId(id) => format!(\"function call with id {id}\"),\n             CreatedAlloc(AllocId(id), size, align, kind) =>\n                 format!("}, {"sha": "7b4973f3b9daf2bdf3bce7e7f19bfd25db85c17c", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 112, "deletions": 60, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -4,10 +4,12 @@ use std::ffi::{OsStr, OsString};\n use std::iter;\n use std::panic::{self, AssertUnwindSafe};\n use std::path::PathBuf;\n+use std::task::Poll;\n use std::thread;\n \n use log::info;\n \n+use crate::borrow_tracker::RetagFields;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n@@ -20,8 +22,14 @@ use rustc_target::spec::abi::Abi;\n \n use rustc_session::config::EntryFnType;\n \n+use crate::shims::tls;\n use crate::*;\n \n+/// When the main thread would exit, we will yield to any other thread that is ready to execute.\n+/// But we must only do that a finite number of times, or a background thread running `loop {}`\n+/// will hang the program.\n+const MAIN_THREAD_YIELDS_AT_SHUTDOWN: u32 = 256;\n+\n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum AlignmentCheck {\n     /// Do not check alignment.\n@@ -80,7 +88,7 @@ pub struct MiriConfig {\n     /// Determine if validity checking is enabled.\n     pub validate: bool,\n     /// Determines if Stacked Borrows is enabled.\n-    pub stacked_borrows: bool,\n+    pub borrow_tracker: Option<BorrowTrackerMethod>,\n     /// Controls alignment checking.\n     pub check_alignment: AlignmentCheck,\n     /// Controls function [ABI](Abi) checking.\n@@ -96,7 +104,7 @@ pub struct MiriConfig {\n     /// The seed to use when non-determinism or randomness are required (e.g. ptr-to-int cast, `getrandom()`).\n     pub seed: Option<u64>,\n     /// The stacked borrows pointer ids to report about\n-    pub tracked_pointer_tags: FxHashSet<SbTag>,\n+    pub tracked_pointer_tags: FxHashSet<BorTag>,\n     /// The stacked borrows call IDs to report about\n     pub tracked_call_ids: FxHashSet<CallId>,\n     /// The allocation ids to report about.\n@@ -131,7 +139,7 @@ pub struct MiriConfig {\n     /// The location of a shared object file to load when calling external functions\n     /// FIXME! consider allowing users to specify paths to multiple SO files, or to a directory\n     pub external_so_file: Option<PathBuf>,\n-    /// Run a garbage collector for SbTags every N basic blocks.\n+    /// Run a garbage collector for BorTags every N basic blocks.\n     pub gc_interval: u32,\n     /// The number of CPUs to be reported by miri.\n     pub num_cpus: u32,\n@@ -142,7 +150,7 @@ impl Default for MiriConfig {\n         MiriConfig {\n             env: vec![],\n             validate: true,\n-            stacked_borrows: true,\n+            borrow_tracker: Some(BorrowTrackerMethod::StackedBorrows),\n             check_alignment: AlignmentCheck::Int,\n             check_abi: true,\n             isolated_op: IsolatedOp::Reject(RejectOpWith::Abort),\n@@ -172,17 +180,79 @@ impl Default for MiriConfig {\n     }\n }\n \n-/// Returns a freshly created `InterpCx`, along with an `MPlaceTy` representing\n-/// the location where the return value of the `start` function will be\n-/// written to.\n+/// The state of the main thread. Implementation detail of `on_main_stack_empty`.\n+#[derive(Default, Debug)]\n+enum MainThreadState {\n+    #[default]\n+    Running,\n+    TlsDtors(tls::TlsDtorsState),\n+    Yield {\n+        remaining: u32,\n+    },\n+    Done,\n+}\n+\n+impl MainThreadState {\n+    fn on_main_stack_empty<'tcx>(\n+        &mut self,\n+        this: &mut MiriInterpCx<'_, 'tcx>,\n+    ) -> InterpResult<'tcx, Poll<()>> {\n+        use MainThreadState::*;\n+        match self {\n+            Running => {\n+                *self = TlsDtors(Default::default());\n+            }\n+            TlsDtors(state) =>\n+                match state.on_stack_empty(this)? {\n+                    Poll::Pending => {} // just keep going\n+                    Poll::Ready(()) => {\n+                        // Give background threads a chance to finish by yielding the main thread a\n+                        // couple of times -- but only if we would also preempt threads randomly.\n+                        if this.machine.preemption_rate > 0.0 {\n+                            // There is a non-zero chance they will yield back to us often enough to\n+                            // make Miri terminate eventually.\n+                            *self = Yield { remaining: MAIN_THREAD_YIELDS_AT_SHUTDOWN };\n+                        } else {\n+                            // The other threads did not get preempted, so no need to yield back to\n+                            // them.\n+                            *self = Done;\n+                        }\n+                    }\n+                },\n+            Yield { remaining } =>\n+                match remaining.checked_sub(1) {\n+                    None => *self = Done,\n+                    Some(new_remaining) => {\n+                        *remaining = new_remaining;\n+                        this.yield_active_thread();\n+                    }\n+                },\n+            Done => {\n+                // Figure out exit code.\n+                let ret_place = MPlaceTy::from_aligned_ptr(\n+                    this.machine.main_fn_ret_place.unwrap().ptr,\n+                    this.machine.layouts.isize,\n+                );\n+                let exit_code = this.read_scalar(&ret_place.into())?.to_machine_isize(this)?;\n+                // Need to call this ourselves since we are not going to return to the scheduler\n+                // loop, and we want the main thread TLS to not show up as memory leaks.\n+                this.terminate_active_thread()?;\n+                // Stop interpreter loop.\n+                throw_machine_stop!(TerminationInfo::Exit { code: exit_code, leak_check: true });\n+            }\n+        }\n+        Ok(Poll::Pending)\n+    }\n+}\n+\n+/// Returns a freshly created `InterpCx`.\n /// Public because this is also used by `priroda`.\n pub fn create_ecx<'mir, 'tcx: 'mir>(\n     tcx: TyCtxt<'tcx>,\n     entry_id: DefId,\n     entry_type: EntryFnType,\n     config: &MiriConfig,\n-) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>, MPlaceTy<'tcx, Provenance>)>\n-{\n+) -> InterpResult<'tcx, InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>> {\n     let param_env = ty::ParamEnv::reveal_all();\n     let layout_cx = LayoutCx { tcx, param_env };\n     let mut ecx = InterpCx::new(\n@@ -193,7 +263,11 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     );\n \n     // Some parts of initialization require a full `InterpCx`.\n-    MiriMachine::late_init(&mut ecx, config)?;\n+    MiriMachine::late_init(&mut ecx, config, {\n+        let mut state = MainThreadState::default();\n+        // Cannot capture anything GC-relevant here.\n+        Box::new(move |m| state.on_main_stack_empty(m))\n+    })?;\n \n     // Make sure we have MIR. We check MIR for some stable monomorphic function in libcore.\n     let sentinel = ecx.try_resolve_path(&[\"core\", \"ascii\", \"escape_default\"], Namespace::ValueNS);\n@@ -274,6 +348,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n \n     // Return place (in static memory so that it does not count as leak).\n     let ret_place = ecx.allocate(ecx.machine.layouts.isize, MiriMemoryKind::Machine.into())?;\n+    ecx.machine.main_fn_ret_place = Some(*ret_place);\n     // Call start function.\n \n     match entry_type {\n@@ -321,7 +396,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         }\n     }\n \n-    Ok((ecx, ret_place))\n+    Ok(ecx)\n }\n \n /// Evaluates the entry function specified by `entry_id`.\n@@ -337,7 +412,7 @@ pub fn eval_entry<'tcx>(\n     // Copy setting before we move `config`.\n     let ignore_leaks = config.ignore_leaks;\n \n-    let (mut ecx, ret_place) = match create_ecx(tcx, entry_id, entry_type, &config) {\n+    let mut ecx = match create_ecx(tcx, entry_id, entry_type, &config) {\n         Ok(v) => v,\n         Err(err) => {\n             err.print_backtrace();\n@@ -346,34 +421,17 @@ pub fn eval_entry<'tcx>(\n     };\n \n     // Perform the main execution.\n-    let res: thread::Result<InterpResult<'_, i64>> = panic::catch_unwind(AssertUnwindSafe(|| {\n-        // Main loop.\n-        loop {\n-            match ecx.schedule()? {\n-                SchedulingAction::ExecuteStep => {\n-                    assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n-                }\n-                SchedulingAction::ExecuteTimeoutCallback => {\n-                    ecx.run_timeout_callback()?;\n-                }\n-                SchedulingAction::ExecuteDtors => {\n-                    // This will either enable the thread again (so we go back\n-                    // to `ExecuteStep`), or determine that this thread is done\n-                    // for good.\n-                    ecx.schedule_next_tls_dtor_for_active_thread()?;\n-                }\n-                SchedulingAction::Stop => {\n-                    break;\n-                }\n-            }\n-        }\n-        let return_code = ecx.read_scalar(&ret_place.into())?.to_machine_isize(&ecx)?;\n-        Ok(return_code)\n-    }));\n+    let res: thread::Result<InterpResult<'_, !>> =\n+        panic::catch_unwind(AssertUnwindSafe(|| ecx.run_threads()));\n     let res = res.unwrap_or_else(|panic_payload| {\n         ecx.handle_ice();\n         panic::resume_unwind(panic_payload)\n     });\n+    let res = match res {\n+        Err(res) => res,\n+        // `Ok` can never happen\n+        Ok(never) => match never {},\n+    };\n \n     // Machine cleanup. Only do this if all threads have terminated; threads that are still running\n     // might cause Stacked Borrows errors (https://github.com/rust-lang/miri/issues/2396).\n@@ -386,32 +444,26 @@ pub fn eval_entry<'tcx>(\n     }\n \n     // Process the result.\n-    match res {\n-        Ok(return_code) => {\n-            if !ignore_leaks {\n-                // Check for thread leaks.\n-                if !ecx.have_all_terminated() {\n-                    tcx.sess.err(\n-                        \"the main thread terminated without waiting for all remaining threads\",\n-                    );\n-                    tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n-                    return None;\n-                }\n-                // Check for memory leaks.\n-                info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n-                let leaks = ecx.leak_report(&ecx.machine.static_roots);\n-                if leaks != 0 {\n-                    tcx.sess.err(\"the evaluated program leaked memory\");\n-                    tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n-                    // Ignore the provided return code - let the reported error\n-                    // determine the return code.\n-                    return None;\n-                }\n-            }\n-            Some(return_code)\n+    let (return_code, leak_check) = report_error(&ecx, res)?;\n+    if leak_check && !ignore_leaks {\n+        // Check for thread leaks.\n+        if !ecx.have_all_terminated() {\n+            tcx.sess.err(\"the main thread terminated without waiting for all remaining threads\");\n+            tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n+            return None;\n+        }\n+        // Check for memory leaks.\n+        info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n+        let leaks = ecx.leak_report(&ecx.machine.static_roots);\n+        if leaks != 0 {\n+            tcx.sess.err(\"the evaluated program leaked memory\");\n+            tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n+            // Ignore the provided return code - let the reported error\n+            // determine the return code.\n+            return None;\n         }\n-        Err(e) => report_error(&ecx, e),\n     }\n+    Some(return_code)\n }\n \n /// Turns an array of arguments into a Windows command line string."}, {"sha": "7fb2539ca5a678824649211f3b9bb4b3309467ee", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -554,9 +554,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         assert_eq!(\n             self.eval_context_ref().tcx.sess.target.os,\n             target_os,\n-            \"`{}` is only available on the `{}` target OS\",\n-            name,\n-            target_os,\n+            \"`{name}` is only available on the `{target_os}` target OS\",\n         )\n     }\n \n@@ -566,8 +564,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn assert_target_os_is_unix(&self, name: &str) {\n         assert!(\n             target_os_is_unix(self.eval_context_ref().tcx.sess.target.os.as_ref()),\n-            \"`{}` is only available for supported UNIX family targets\",\n-            name,\n+            \"`{name}` is only available for supported UNIX family targets\",\n         );\n     }\n \n@@ -988,7 +985,7 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n         self.stack()[frame_idx].current_span()\n     }\n \n-    fn stack(&self) -> &[Frame<'mir, 'tcx, Provenance, machine::FrameData<'tcx>>] {\n+    fn stack(&self) -> &[Frame<'mir, 'tcx, Provenance, machine::FrameExtra<'tcx>>] {\n         self.threads.active_thread_stack()\n     }\n \n@@ -1019,8 +1016,7 @@ where\n \n pub fn isolation_abort_error<'tcx>(name: &str) -> InterpResult<'tcx> {\n     throw_machine_stop!(TerminationInfo::UnsupportedInIsolation(format!(\n-        \"{} not available when isolation is enabled\",\n-        name,\n+        \"{name} not available when isolation is enabled\",\n     )))\n }\n "}, {"sha": "c26828b11e0e1322e29fdb0d5069966f1237590f", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -45,7 +45,7 @@ pub struct GlobalStateInner {\n }\n \n impl VisitTags for GlobalStateInner {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n         // Nothing to visit here.\n     }\n }\n@@ -105,15 +105,15 @@ impl<'mir, 'tcx> GlobalStateInner {\n     pub fn expose_ptr(\n         ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         alloc_id: AllocId,\n-        sb: SbTag,\n+        tag: BorTag,\n     ) -> InterpResult<'tcx> {\n         let global_state = ecx.machine.intptrcast.get_mut();\n         // In strict mode, we don't need this, so we can save some cycles by not tracking it.\n         if global_state.provenance_mode != ProvenanceMode::Strict {\n             trace!(\"Exposing allocation id {alloc_id:?}\");\n             global_state.exposed.insert(alloc_id);\n-            if ecx.machine.stacked_borrows.is_some() {\n-                ecx.expose_tag(alloc_id, sb)?;\n+            if ecx.machine.borrow_tracker.is_some() {\n+                ecx.expose_tag(alloc_id, tag)?;\n             }\n         }\n         Ok(())"}, {"sha": "42519797976b7795805ca245c1ccd0c3ec80640d", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -53,6 +53,7 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n \n+mod borrow_tracker;\n mod clock;\n mod concurrency;\n mod diagnostics;\n@@ -64,7 +65,6 @@ mod mono_hash_map;\n mod operator;\n mod range_map;\n mod shims;\n-mod stacked_borrows;\n mod tag_gc;\n \n // Establish a \"crate-wide prelude\": we often import `crate::*`.\n@@ -81,15 +81,21 @@ pub use crate::shims::intrinsics::EvalContextExt as _;\n pub use crate::shims::os_str::EvalContextExt as _;\n pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as _};\n pub use crate::shims::time::EvalContextExt as _;\n-pub use crate::shims::tls::{EvalContextExt as _, TlsData};\n+pub use crate::shims::tls::TlsData;\n pub use crate::shims::EvalContextExt as _;\n \n+pub use crate::borrow_tracker::stacked_borrows::{\n+    EvalContextExt as _, Item, Permission, Stack, Stacks,\n+};\n+pub use crate::borrow_tracker::{\n+    BorTag, BorrowTrackerMethod, CallId, EvalContextExt as _, RetagFields,\n+};\n pub use crate::clock::{Clock, Instant};\n pub use crate::concurrency::{\n     data_race::{AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, EvalContextExt as _},\n     init_once::{EvalContextExt as _, InitOnceId},\n     sync::{CondvarId, EvalContextExt as _, MutexId, RwLockId, SyncId},\n-    thread::{EvalContextExt as _, SchedulingAction, ThreadId, ThreadManager, ThreadState, Time},\n+    thread::{EvalContextExt as _, StackEmptyCallback, ThreadId, ThreadManager, Time},\n };\n pub use crate::diagnostics::{\n     report_error, EvalContextExt as _, NonHaltingDiagnostic, TerminationInfo,\n@@ -100,15 +106,12 @@ pub use crate::eval::{\n pub use crate::helpers::EvalContextExt as _;\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,\n+    AllocExtra, FrameExtra, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,\n     PrimitiveLayouts, Provenance, ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as _;\n pub use crate::range_map::RangeMap;\n-pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as _, Item, Permission, RetagFields, SbTag, Stack, Stacks,\n-};\n pub use crate::tag_gc::{EvalContextExt as _, VisitTags};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be"}, {"sha": "c110229c985db78600cd18626a2b1899852047df", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 83, "deletions": 86, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -37,9 +37,9 @@ pub const STACK_ADDR: u64 = 32 * PAGE_SIZE; // not really about the \"stack\", but\n pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n \n /// Extra data stored with each stack frame\n-pub struct FrameData<'tcx> {\n+pub struct FrameExtra<'tcx> {\n     /// Extra data for Stacked Borrows.\n-    pub stacked_borrows: Option<stacked_borrows::FrameExtra>,\n+    pub borrow_tracker: Option<borrow_tracker::FrameState>,\n \n     /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of `try_fn`\n     /// called by `try`). When this frame is popped during unwinding a panic,\n@@ -58,23 +58,23 @@ pub struct FrameData<'tcx> {\n     pub is_user_relevant: bool,\n }\n \n-impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n+impl<'tcx> std::fmt::Debug for FrameExtra<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { stacked_borrows, catch_unwind, timing: _, is_user_relevant: _ } = self;\n+        let FrameExtra { borrow_tracker, catch_unwind, timing: _, is_user_relevant: _ } = self;\n         f.debug_struct(\"FrameData\")\n-            .field(\"stacked_borrows\", stacked_borrows)\n+            .field(\"borrow_tracker\", borrow_tracker)\n             .field(\"catch_unwind\", catch_unwind)\n             .finish()\n     }\n }\n \n-impl VisitTags for FrameData<'_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let FrameData { catch_unwind, stacked_borrows, timing: _, is_user_relevant: _ } = self;\n+impl VisitTags for FrameExtra<'_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        let FrameExtra { catch_unwind, borrow_tracker, timing: _, is_user_relevant: _ } = self;\n \n         catch_unwind.visit_tags(visit);\n-        stacked_borrows.visit_tags(visit);\n+        borrow_tracker.visit_tags(visit);\n     }\n }\n \n@@ -147,7 +147,7 @@ pub enum Provenance {\n     Concrete {\n         alloc_id: AllocId,\n         /// Stacked Borrows tag.\n-        sb: SbTag,\n+        tag: BorTag,\n     },\n     Wildcard,\n }\n@@ -173,7 +173,7 @@ impl std::hash::Hash for Provenance {\n /// The \"extra\" information a pointer has over a regular AllocId.\n #[derive(Copy, Clone, PartialEq)]\n pub enum ProvenanceExtra {\n-    Concrete(SbTag),\n+    Concrete(BorTag),\n     Wildcard,\n }\n \n@@ -188,15 +188,15 @@ static_assert_size!(Scalar<Provenance>, 32);\n impl fmt::Debug for Provenance {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match self {\n-            Provenance::Concrete { alloc_id, sb } => {\n+            Provenance::Concrete { alloc_id, tag } => {\n                 // Forward `alternate` flag to `alloc_id` printing.\n                 if f.alternate() {\n                     write!(f, \"[{alloc_id:#?}]\")?;\n                 } else {\n                     write!(f, \"[{alloc_id:?}]\")?;\n                 }\n                 // Print Stacked Borrows tag.\n-                write!(f, \"{sb:?}\")?;\n+                write!(f, \"{tag:?}\")?;\n             }\n             Provenance::Wildcard => {\n                 write!(f, \"[wildcard]\")?;\n@@ -221,9 +221,9 @@ impl interpret::Provenance for Provenance {\n         match (left, right) {\n             // If both are the *same* concrete tag, that is the result.\n             (\n-                Some(Provenance::Concrete { alloc_id: left_alloc, sb: left_sb }),\n-                Some(Provenance::Concrete { alloc_id: right_alloc, sb: right_sb }),\n-            ) if left_alloc == right_alloc && left_sb == right_sb => left,\n+                Some(Provenance::Concrete { alloc_id: left_alloc, tag: left_tag }),\n+                Some(Provenance::Concrete { alloc_id: right_alloc, tag: right_tag }),\n+            ) if left_alloc == right_alloc && left_tag == right_tag => left,\n             // If one side is a wildcard, the best possible outcome is that it is equal to the other\n             // one, and we use that.\n             (Some(Provenance::Wildcard), o) | (o, Some(Provenance::Wildcard)) => o,\n@@ -243,7 +243,7 @@ impl fmt::Debug for ProvenanceExtra {\n }\n \n impl ProvenanceExtra {\n-    pub fn and_then<T>(self, f: impl FnOnce(SbTag) -> Option<T>) -> Option<T> {\n+    pub fn and_then<T>(self, f: impl FnOnce(BorTag) -> Option<T>) -> Option<T> {\n         match self {\n             ProvenanceExtra::Concrete(pid) => f(pid),\n             ProvenanceExtra::Wildcard => None,\n@@ -254,21 +254,21 @@ impl ProvenanceExtra {\n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n pub struct AllocExtra {\n-    /// Stacked Borrows state is only added if it is enabled.\n-    pub stacked_borrows: Option<stacked_borrows::AllocExtra>,\n+    /// Global state of the borrow tracker, if enabled.\n+    pub borrow_tracker: Option<borrow_tracker::AllocState>,\n     /// Data race detection via the use of a vector-clock,\n     ///  this is only added if it is enabled.\n-    pub data_race: Option<data_race::AllocExtra>,\n+    pub data_race: Option<data_race::AllocState>,\n     /// Weak memory emulation via the use of store buffers,\n     ///  this is only added if it is enabled.\n-    pub weak_memory: Option<weak_memory::AllocExtra>,\n+    pub weak_memory: Option<weak_memory::AllocState>,\n }\n \n impl VisitTags for AllocExtra {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let AllocExtra { stacked_borrows, data_race, weak_memory } = self;\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        let AllocExtra { borrow_tracker, data_race, weak_memory } = self;\n \n-        stacked_borrows.visit_tags(visit);\n+        borrow_tracker.visit_tags(visit);\n         data_race.visit_tags(visit);\n         weak_memory.visit_tags(visit);\n     }\n@@ -350,8 +350,8 @@ pub struct MiriMachine<'mir, 'tcx> {\n     // We carry a copy of the global `TyCtxt` for convenience, so methods taking just `&Evaluator` have `tcx` access.\n     pub tcx: TyCtxt<'tcx>,\n \n-    /// Stacked Borrows global data.\n-    pub stacked_borrows: Option<stacked_borrows::GlobalState>,\n+    /// Global data for borrow tracking.\n+    pub borrow_tracker: Option<borrow_tracker::GlobalState>,\n \n     /// Data race detector global data.\n     pub data_race: Option<data_race::GlobalState>,\n@@ -363,6 +363,9 @@ pub struct MiriMachine<'mir, 'tcx> {\n     /// Miri does not expose env vars from the host to the emulated program.\n     pub(crate) env_vars: EnvVars<'tcx>,\n \n+    /// Return place of the main function.\n+    pub(crate) main_fn_ret_place: Option<MemPlace<Provenance>>,\n+\n     /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n     /// These are *pointers* to argc/argv because macOS.\n     /// We also need the full command line as one string because of Windows.\n@@ -460,9 +463,9 @@ pub struct MiriMachine<'mir, 'tcx> {\n     #[cfg(not(target_os = \"linux\"))]\n     pub external_so_lib: Option<!>,\n \n-    /// Run a garbage collector for SbTags every N basic blocks.\n+    /// Run a garbage collector for BorTags every N basic blocks.\n     pub(crate) gc_interval: u32,\n-    /// The number of blocks that passed since the last SbTag GC pass.\n+    /// The number of blocks that passed since the last BorTag GC pass.\n     pub(crate) since_gc: u32,\n     /// The number of CPUs to be reported by miri.\n     pub(crate) num_cpus: u32,\n@@ -477,21 +480,16 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n             measureme::Profiler::new(out).expect(\"Couldn't create `measureme` profiler\")\n         });\n         let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n-        let stacked_borrows = config.stacked_borrows.then(|| {\n-            RefCell::new(stacked_borrows::GlobalStateInner::new(\n-                config.tracked_pointer_tags.clone(),\n-                config.tracked_call_ids.clone(),\n-                config.retag_fields,\n-            ))\n-        });\n+        let borrow_tracker = config.borrow_tracker.map(|bt| bt.instanciate_global_state(config));\n         let data_race = config.data_race_detector.then(|| data_race::GlobalState::new(config));\n         MiriMachine {\n             tcx: layout_cx.tcx,\n-            stacked_borrows,\n+            borrow_tracker,\n             data_race,\n             intptrcast: RefCell::new(intptrcast::GlobalStateInner::new(config)),\n             // `env_vars` depends on a full interpreter so we cannot properly initialize it yet.\n             env_vars: EnvVars::default(),\n+            main_fn_ret_place: None,\n             argc: None,\n             argv: None,\n             cmd_line: None,\n@@ -556,10 +554,11 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n     pub(crate) fn late_init(\n         this: &mut MiriInterpCx<'mir, 'tcx>,\n         config: &MiriConfig,\n+        on_main_stack_empty: StackEmptyCallback<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         EnvVars::init(this, config)?;\n         MiriMachine::init_extern_statics(this)?;\n-        ThreadManager::init(this);\n+        ThreadManager::init(this, on_main_stack_empty);\n         Ok(())\n     }\n \n@@ -651,18 +650,19 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n }\n \n impl VisitTags for MiriMachine<'_, '_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         #[rustfmt::skip]\n         let MiriMachine {\n             threads,\n             tls,\n             env_vars,\n+            main_fn_ret_place,\n             argc,\n             argv,\n             cmd_line,\n             extern_statics,\n             dir_handler,\n-            stacked_borrows,\n+            borrow_tracker,\n             data_race,\n             intptrcast,\n             file_handler,\n@@ -700,8 +700,9 @@ impl VisitTags for MiriMachine<'_, '_> {\n         dir_handler.visit_tags(visit);\n         file_handler.visit_tags(visit);\n         data_race.visit_tags(visit);\n-        stacked_borrows.visit_tags(visit);\n+        borrow_tracker.visit_tags(visit);\n         intptrcast.visit_tags(visit);\n+        main_fn_ret_place.visit_tags(visit);\n         argc.visit_tags(visit);\n         argv.visit_tags(visit);\n         cmd_line.visit_tags(visit);\n@@ -735,7 +736,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     type MemoryKind = MiriMemoryKind;\n     type ExtraFnVal = Dlsym;\n \n-    type FrameExtra = FrameData<'tcx>;\n+    type FrameExtra = FrameExtra<'tcx>;\n     type AllocExtra = AllocExtra;\n \n     type Provenance = Provenance;\n@@ -900,25 +901,24 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         }\n \n         let alloc = alloc.into_owned();\n-        let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n-            Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind, &ecx.machine)\n-        });\n+        let borrow_tracker = ecx\n+            .machine\n+            .borrow_tracker\n+            .as_ref()\n+            .map(|bt| bt.borrow_mut().new_allocation(id, alloc.size(), kind, &ecx.machine));\n+\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n-            data_race::AllocExtra::new_allocation(\n+            data_race::AllocState::new_allocation(\n                 data_race,\n                 &ecx.machine.threads,\n                 alloc.size(),\n                 kind,\n             )\n         });\n-        let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocExtra::new_allocation);\n+        let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocState::new_allocation);\n         let alloc: Allocation<Provenance, Self::AllocExtra> = alloc.adjust_from_tcx(\n             &ecx.tcx,\n-            AllocExtra {\n-                stacked_borrows: stacks.map(RefCell::new),\n-                data_race: race_alloc,\n-                weak_memory: buffer_alloc,\n-            },\n+            AllocExtra { borrow_tracker, data_race: race_alloc, weak_memory: buffer_alloc },\n             |ptr| ecx.global_base_pointer(ptr),\n         )?;\n         Ok(Cow::Owned(alloc))\n@@ -942,14 +942,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             }\n         }\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n-        let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n+        let tag = if let Some(borrow_tracker) = &ecx.machine.borrow_tracker {\n+            borrow_tracker.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n         } else {\n             // Value does not matter, SB is disabled\n-            SbTag::default()\n+            BorTag::default()\n         };\n         Pointer::new(\n-            Provenance::Concrete { alloc_id: ptr.provenance, sb: sb_tag },\n+            Provenance::Concrete { alloc_id: ptr.provenance, tag },\n             Size::from_bytes(absolute_addr),\n         )\n     }\n@@ -967,8 +967,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         ptr: Pointer<Self::Provenance>,\n     ) -> InterpResult<'tcx> {\n         match ptr.provenance {\n-            Provenance::Concrete { alloc_id, sb } =>\n-                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, sb),\n+            Provenance::Concrete { alloc_id, tag } =>\n+                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, tag),\n             Provenance::Wildcard => {\n                 // No need to do anything for wildcard pointers as\n                 // their provenances have already been previously exposed.\n@@ -986,11 +986,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         let rel = intptrcast::GlobalStateInner::abs_ptr_to_rel(ecx, ptr);\n \n         rel.map(|(alloc_id, size)| {\n-            let sb = match ptr.provenance {\n-                Provenance::Concrete { sb, .. } => ProvenanceExtra::Concrete(sb),\n+            let tag = match ptr.provenance {\n+                Provenance::Concrete { tag, .. } => ProvenanceExtra::Concrete(tag),\n                 Provenance::Wildcard => ProvenanceExtra::Wildcard,\n             };\n-            (alloc_id, size, sb)\n+            (alloc_id, size, tag)\n         })\n     }\n \n@@ -1005,10 +1005,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n             data_race.read(alloc_id, range, machine)?;\n         }\n-        if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows\n-                .borrow_mut()\n-                .before_memory_read(alloc_id, prov_extra, range, machine)?;\n+        if let Some(borrow_tracker) = &alloc_extra.borrow_tracker {\n+            borrow_tracker.before_memory_read(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1027,8 +1025,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.write(alloc_id, range, machine)?;\n         }\n-        if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_write(alloc_id, prov_extra, range, machine)?;\n+        if let Some(borrow_tracker) = &mut alloc_extra.borrow_tracker {\n+            borrow_tracker.before_memory_write(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1050,16 +1048,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.deallocate(alloc_id, range, machine)?;\n         }\n-        if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_deallocation(\n-                alloc_id,\n-                prove_extra,\n-                range,\n-                machine,\n-            )\n-        } else {\n-            Ok(())\n+        if let Some(borrow_tracker) = &mut alloc_extra.borrow_tracker {\n+            borrow_tracker.before_memory_deallocation(alloc_id, prove_extra, range, machine)?;\n         }\n+        Ok(())\n     }\n \n     #[inline(always)]\n@@ -1068,14 +1060,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         kind: mir::RetagKind,\n         place: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.machine.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n+        if ecx.machine.borrow_tracker.is_some() {\n+            ecx.retag(kind, place)?;\n+        }\n+        Ok(())\n     }\n \n     #[inline(always)]\n     fn init_frame_extra(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         frame: Frame<'mir, 'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>> {\n         // Start recording our event before doing anything else\n         let timing = if let Some(profiler) = ecx.machine.profiler.as_ref() {\n             let fn_name = frame.instance.to_string();\n@@ -1091,10 +1086,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             None\n         };\n \n-        let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n+        let borrow_tracker = ecx.machine.borrow_tracker.as_ref();\n \n-        let extra = FrameData {\n-            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n+        let extra = FrameExtra {\n+            borrow_tracker: borrow_tracker.map(|bt| bt.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n             is_user_relevant: ecx.machine.is_user_relevant(&frame),\n@@ -1127,7 +1122,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             }\n         }\n \n-        // Search for SbTags to find all live pointers, then remove all other tags from borrow\n+        // Search for BorTags to find all live pointers, then remove all other tags from borrow\n         // stacks.\n         // When debug assertions are enabled, run the GC as often as possible so that any cases\n         // where it mistakenly removes an important tag become visible.\n@@ -1153,14 +1148,16 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             let stack_len = ecx.active_thread_stack().len();\n             ecx.active_thread_mut().set_top_user_relevant_frame(stack_len - 1);\n         }\n-\n-        if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n+        if ecx.machine.borrow_tracker.is_some() {\n+            ecx.retag_return_place()?;\n+        }\n+        Ok(())\n     }\n \n     #[inline(always)]\n     fn after_stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        mut frame: Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>,\n+        mut frame: Frame<'mir, 'tcx, Provenance, FrameExtra<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n         if frame.extra.is_user_relevant {\n@@ -1171,8 +1168,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             ecx.active_thread_mut().recompute_top_user_relevant_frame();\n         }\n         let timing = frame.extra.timing.take();\n-        if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().end_call(&frame.extra);\n+        if let Some(borrow_tracker) = &ecx.machine.borrow_tracker {\n+            borrow_tracker.borrow_mut().end_call(&frame.extra);\n         }\n         let res = ecx.handle_stack_pop_unwind(frame.extra, unwinding);\n         if let Some(profiler) = ecx.machine.profiler.as_ref() {"}, {"sha": "80fb4ff2fe9802e051d61389f3f90c67978bddce", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -37,7 +37,7 @@ pub struct EnvVars<'tcx> {\n }\n \n impl VisitTags for EnvVars<'_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let EnvVars { map, environ } = self;\n \n         environ.visit_tags(visit);"}, {"sha": "8370e02b588afb7f5d19da5052cde4d5a2994cb3", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -286,7 +286,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         let [code] = this.check_shim(abi, exp_abi, link_name, args)?;\n                         // it's really u32 for ExitProcess, but we have to put it into the `Exit` variant anyway\n                         let code = this.read_scalar(code)?.to_i32()?;\n-                        throw_machine_stop!(TerminationInfo::Exit(code.into()));\n+                        throw_machine_stop!(TerminationInfo::Exit { code: code.into(), leak_check: false });\n                     }\n                     \"abort\" => {\n                         let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n@@ -299,8 +299,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                             return Ok(Some(body));\n                         }\n                         this.handle_unsupported(format!(\n-                            \"can't call (diverging) foreign function: {}\",\n-                            link_name\n+                            \"can't call (diverging) foreign function: {link_name}\"\n                         ))?;\n                         return Ok(None);\n                     }"}, {"sha": "db3e42facadd03958c1d8725b7c44be4645692db", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -36,7 +36,7 @@ pub struct CatchUnwindData<'tcx> {\n }\n \n impl VisitTags for CatchUnwindData<'_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let CatchUnwindData { catch_fn, data, dest, ret: _ } = self;\n         catch_fn.visit_tags(visit);\n         data.visit_tags(visit);\n@@ -125,7 +125,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn handle_stack_pop_unwind(\n         &mut self,\n-        mut extra: FrameData<'tcx>,\n+        mut extra: FrameExtra<'tcx>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n         let this = self.eval_context_mut();"}, {"sha": "d263aab351b12e07591210cc85ede4bc60c461c0", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -278,7 +278,7 @@ struct UnblockCallback {\n }\n \n impl VisitTags for UnblockCallback {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {}\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {}\n }\n \n impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for UnblockCallback {"}, {"sha": "54fdf2872ab4d3967c594fba3d30def27840b96f", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 82, "deletions": 113, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -1,12 +1,11 @@\n //! Implement thread-local storage.\n \n use std::collections::btree_map::Entry as BTreeEntry;\n-use std::collections::hash_map::Entry as HashMapEntry;\n use std::collections::BTreeMap;\n+use std::task::Poll;\n \n use log::trace;\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty;\n use rustc_target::abi::{HasDataLayout, Size};\n use rustc_target::spec::abi::Abi;\n@@ -23,12 +22,12 @@ pub struct TlsEntry<'tcx> {\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n-#[derive(Clone, Debug)]\n-struct RunningDtorsState {\n+#[derive(Default, Debug)]\n+struct RunningDtorState {\n     /// The last TlsKey used to retrieve a TLS destructor. `None` means that we\n     /// have not tried to retrieve a TLS destructor yet or that we already tried\n     /// all keys.\n-    last_dtor_key: Option<TlsKey>,\n+    last_key: Option<TlsKey>,\n }\n \n #[derive(Debug)]\n@@ -42,11 +41,6 @@ pub struct TlsData<'tcx> {\n     /// A single per thread destructor of the thread local storage (that's how\n     /// things work on macOS) with a data argument.\n     macos_thread_dtors: BTreeMap<ThreadId, (ty::Instance<'tcx>, Scalar<Provenance>)>,\n-\n-    /// State for currently running TLS dtors. If this map contains a key for a\n-    /// specific thread, it means that we are in the \"destruct\" phase, during\n-    /// which some operations are UB.\n-    dtors_running: FxHashMap<ThreadId, RunningDtorsState>,\n }\n \n impl<'tcx> Default for TlsData<'tcx> {\n@@ -55,7 +49,6 @@ impl<'tcx> Default for TlsData<'tcx> {\n             next_key: 1, // start with 1 as we must not use 0 on Windows\n             keys: Default::default(),\n             macos_thread_dtors: Default::default(),\n-            dtors_running: Default::default(),\n         }\n     }\n }\n@@ -143,12 +136,6 @@ impl<'tcx> TlsData<'tcx> {\n         dtor: ty::Instance<'tcx>,\n         data: Scalar<Provenance>,\n     ) -> InterpResult<'tcx> {\n-        if self.dtors_running.contains_key(&thread) {\n-            // UB, according to libstd docs.\n-            throw_ub_format!(\n-                \"setting thread's local storage destructor while destructors are already running\"\n-            );\n-        }\n         if self.macos_thread_dtors.insert(thread, (dtor, data)).is_some() {\n             throw_unsup_format!(\n                 \"setting more than one thread local storage destructor for the same thread is not supported\"\n@@ -211,21 +198,6 @@ impl<'tcx> TlsData<'tcx> {\n         None\n     }\n \n-    /// Set that dtors are running for `thread`. It is guaranteed not to change\n-    /// the existing values stored in `dtors_running` for this thread. Returns\n-    /// `true` if dtors for `thread` are already running.\n-    fn set_dtors_running_for_thread(&mut self, thread: ThreadId) -> bool {\n-        match self.dtors_running.entry(thread) {\n-            HashMapEntry::Occupied(_) => true,\n-            HashMapEntry::Vacant(entry) => {\n-                // We cannot just do `self.dtors_running.insert` because that\n-                // would overwrite `last_dtor_key` with `None`.\n-                entry.insert(RunningDtorsState { last_dtor_key: None });\n-                false\n-            }\n-        }\n-    }\n-\n     /// Delete all TLS entries for the given thread. This function should be\n     /// called after all TLS destructors have already finished.\n     fn delete_all_thread_tls(&mut self, thread_id: ThreadId) {\n@@ -236,8 +208,8 @@ impl<'tcx> TlsData<'tcx> {\n }\n \n impl VisitTags for TlsData<'_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let TlsData { keys, macos_thread_dtors, next_key: _, dtors_running: _ } = self;\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        let TlsData { keys, macos_thread_dtors, next_key: _ } = self;\n \n         for scalar in keys.values().flat_map(|v| v.data.values()) {\n             scalar.visit_tags(visit);\n@@ -248,13 +220,77 @@ impl VisitTags for TlsData<'_> {\n     }\n }\n \n+#[derive(Debug, Default)]\n+pub struct TlsDtorsState(TlsDtorsStatePriv);\n+\n+#[derive(Debug, Default)]\n+enum TlsDtorsStatePriv {\n+    #[default]\n+    Init,\n+    PthreadDtors(RunningDtorState),\n+    Done,\n+}\n+\n+impl TlsDtorsState {\n+    pub fn on_stack_empty<'tcx>(\n+        &mut self,\n+        this: &mut MiriInterpCx<'_, 'tcx>,\n+    ) -> InterpResult<'tcx, Poll<()>> {\n+        use TlsDtorsStatePriv::*;\n+        match &mut self.0 {\n+            Init => {\n+                match this.tcx.sess.target.os.as_ref() {\n+                    \"linux\" | \"freebsd\" | \"android\" => {\n+                        // Run the pthread dtors.\n+                        self.0 = PthreadDtors(Default::default());\n+                    }\n+                    \"macos\" => {\n+                        // The macOS thread wide destructor runs \"before any TLS slots get\n+                        // freed\", so do that first.\n+                        this.schedule_macos_tls_dtor()?;\n+                        // When the stack is empty again, go on with the pthread dtors.\n+                        self.0 = PthreadDtors(Default::default());\n+                    }\n+                    \"windows\" => {\n+                        // Run the special magic hook.\n+                        this.schedule_windows_tls_dtors()?;\n+                        // And move to the final state.\n+                        self.0 = Done;\n+                    }\n+                    \"wasi\" | \"none\" => {\n+                        // No OS, no TLS dtors.\n+                        // FIXME: should we do something on wasi?\n+                        self.0 = Done;\n+                    }\n+                    os => {\n+                        throw_unsup_format!(\n+                            \"the TLS machinery does not know how to handle OS `{os}`\"\n+                        );\n+                    }\n+                }\n+            }\n+            PthreadDtors(state) => {\n+                match this.schedule_next_pthread_tls_dtor(state)? {\n+                    Poll::Pending => {} // just keep going\n+                    Poll::Ready(()) => self.0 = Done,\n+                }\n+            }\n+            Done => {\n+                this.machine.tls.delete_all_thread_tls(this.get_active_thread());\n+                return Ok(Poll::Ready(()));\n+            }\n+        }\n+\n+        Ok(Poll::Pending)\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Schedule TLS destructors for Windows.\n     /// On windows, TLS destructors are managed by std.\n     fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let active_thread = this.get_active_thread();\n \n         // Windows has a special magic linker section that is run on certain events.\n         // Instead of searching for that section and supporting arbitrary hooks in there\n@@ -284,16 +320,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             None,\n             StackPopCleanup::Root { cleanup: true },\n         )?;\n-\n-        this.enable_thread(active_thread);\n         Ok(())\n     }\n \n     /// Schedule the MacOS thread destructor of the thread local storage to be\n-    /// executed. Returns `true` if scheduled.\n-    ///\n-    /// Note: It is safe to call this function also on other Unixes.\n-    fn schedule_macos_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n+    /// executed.\n+    fn schedule_macos_tls_dtor(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let thread_id = this.get_active_thread();\n         if let Some((instance, data)) = this.machine.tls.macos_thread_dtors.remove(&thread_id) {\n@@ -306,35 +338,27 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 None,\n                 StackPopCleanup::Root { cleanup: true },\n             )?;\n-\n-            // Enable the thread so that it steps through the destructor which\n-            // we just scheduled. Since we deleted the destructor, it is\n-            // guaranteed that we will schedule it again. The `dtors_running`\n-            // flag will prevent the code from adding the destructor again.\n-            this.enable_thread(thread_id);\n-            Ok(true)\n-        } else {\n-            Ok(false)\n         }\n+        Ok(())\n     }\n \n     /// Schedule a pthread TLS destructor. Returns `true` if found\n     /// a destructor to schedule, and `false` otherwise.\n-    fn schedule_next_pthread_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n+    fn schedule_next_pthread_tls_dtor(\n+        &mut self,\n+        state: &mut RunningDtorState,\n+    ) -> InterpResult<'tcx, Poll<()>> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread();\n \n-        assert!(this.has_terminated(active_thread), \"running TLS dtors for non-terminated thread\");\n         // Fetch next dtor after `key`.\n-        let last_key = this.machine.tls.dtors_running[&active_thread].last_dtor_key;\n-        let dtor = match this.machine.tls.fetch_tls_dtor(last_key, active_thread) {\n+        let dtor = match this.machine.tls.fetch_tls_dtor(state.last_key, active_thread) {\n             dtor @ Some(_) => dtor,\n             // We ran each dtor once, start over from the beginning.\n             None => this.machine.tls.fetch_tls_dtor(None, active_thread),\n         };\n         if let Some((instance, ptr, key)) = dtor {\n-            this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key =\n-                Some(key);\n+            state.last_key = Some(key);\n             trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, active_thread);\n             assert!(\n                 !ptr.to_machine_usize(this).unwrap() != 0,\n@@ -349,64 +373,9 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 StackPopCleanup::Root { cleanup: true },\n             )?;\n \n-            this.enable_thread(active_thread);\n-            return Ok(true);\n-        }\n-        this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key = None;\n-\n-        Ok(false)\n-    }\n-}\n-\n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    /// Schedule an active thread's TLS destructor to run on the active thread.\n-    /// Note that this function does not run the destructors itself, it just\n-    /// schedules them one by one each time it is called and reenables the\n-    /// thread so that it can be executed normally by the main execution loop.\n-    ///\n-    /// Note: we consistently run TLS destructors for all threads, including the\n-    /// main thread. However, it is not clear that we should run the TLS\n-    /// destructors for the main thread. See issue:\n-    /// <https://github.com/rust-lang/rust/issues/28129>.\n-    fn schedule_next_tls_dtor_for_active_thread(&mut self) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        let active_thread = this.get_active_thread();\n-        trace!(\"schedule_next_tls_dtor_for_active_thread on thread {:?}\", active_thread);\n-\n-        if !this.machine.tls.set_dtors_running_for_thread(active_thread) {\n-            // This is the first time we got asked to schedule a destructor. The\n-            // Windows schedule destructor function must be called exactly once,\n-            // this is why it is in this block.\n-            if this.tcx.sess.target.os == \"windows\" {\n-                // On Windows, we signal that the thread quit by starting the\n-                // relevant function, reenabling the thread, and going back to\n-                // the scheduler.\n-                this.schedule_windows_tls_dtors()?;\n-                return Ok(());\n-            }\n+            return Ok(Poll::Pending);\n         }\n-        // The remaining dtors make some progress each time around the scheduler loop,\n-        // until they return `false` to indicate that they are done.\n-\n-        // The macOS thread wide destructor runs \"before any TLS slots get\n-        // freed\", so do that first.\n-        if this.schedule_macos_tls_dtor()? {\n-            // We have scheduled a MacOS dtor to run on the thread. Execute it\n-            // to completion and come back here. Scheduling a destructor\n-            // destroys it, so we will not enter this branch again.\n-            return Ok(());\n-        }\n-        if this.schedule_next_pthread_tls_dtor()? {\n-            // We have scheduled a pthread destructor and removed it from the\n-            // destructors list. Run it to completion and come back here.\n-            return Ok(());\n-        }\n-\n-        // All dtors done!\n-        this.machine.tls.delete_all_thread_tls(active_thread);\n-        this.thread_terminated()?;\n \n-        Ok(())\n+        Ok(Poll::Ready(()))\n     }\n }"}, {"sha": "988627db5611c283c0ee35c8b5e77fe6a97f18e7", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -278,7 +278,7 @@ pub struct FileHandler {\n }\n \n impl VisitTags for FileHandler {\n-    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n         // All our FileDescriptor do not have any tags.\n     }\n }\n@@ -490,7 +490,7 @@ impl Default for DirHandler {\n }\n \n impl VisitTags for DirHandler {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let DirHandler { streams, next_id: _ } = self;\n \n         for dir in streams.values() {"}, {"sha": "343232c4bbb2913a247d6c13c622806660ecbb84", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -183,7 +183,7 @@ pub fn futex<'tcx>(\n                     }\n \n                     impl<'tcx> VisitTags for Callback<'tcx> {\n-                        fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                        fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                             let Callback { thread: _, addr_usize: _, dest } = self;\n                             dest.visit_tags(visit);\n                         }"}, {"sha": "f9b5774f0090e05ece1d5e2703386a2452091fae", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -747,7 +747,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         impl<'tcx> VisitTags for Callback<'tcx> {\n-            fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+            fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                 let Callback { active_thread: _, mutex_id: _, id: _, dest } = self;\n                 dest.visit_tags(visit);\n             }"}, {"sha": "5b9dc90f0f0060c63524e4297e83aec4d8301532", "filename": "src/tools/miri/src/shims/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -19,7 +19,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let func_arg = this.read_immediate(arg)?;\n \n-        this.start_thread(\n+        this.start_regular_thread(\n             Some(thread_info_place),\n             start_routine,\n             Abi::C { unwind: false },"}, {"sha": "6b043c6d2c9e1c723d2d242d1ff12e896f3a61c7", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -182,7 +182,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n \n                 impl<'tcx> VisitTags for Callback<'tcx> {\n-                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                         let Callback { init_once_id: _, pending_place } = self;\n                         pending_place.visit_tags(visit);\n                     }\n@@ -315,7 +315,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n \n                 impl<'tcx> VisitTags for Callback<'tcx> {\n-                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                         let Callback { thread: _, addr: _, dest } = self;\n                         dest.visit_tags(visit);\n                     }\n@@ -419,7 +419,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n \n             impl<'tcx> VisitTags for Callback<'tcx> {\n-                fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n                     let Callback { thread: _, condvar_id: _, lock_id: _, mode: _, dest } = self;\n                     dest.visit_tags(visit);\n                 }"}, {"sha": "25a5194caa096540d997df4c13dfe33c42ca9464", "filename": "src/tools/miri/src/shims/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -46,7 +46,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             throw_unsup_format!(\"non-null `lpThreadAttributes` in `CreateThread`\")\n         }\n \n-        this.start_thread(\n+        this.start_regular_thread(\n             thread,\n             start_routine,\n             Abi::System { unwind: false },"}, {"sha": "c1194fe22163a65cbe8977e849e73161dcc0c48c", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -3,53 +3,53 @@ use rustc_data_structures::fx::FxHashSet;\n use crate::*;\n \n pub trait VisitTags {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag));\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag));\n }\n \n impl<T: VisitTags> VisitTags for Option<T> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         if let Some(x) = self {\n             x.visit_tags(visit);\n         }\n     }\n }\n \n impl<T: VisitTags> VisitTags for std::cell::RefCell<T> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         self.borrow().visit_tags(visit)\n     }\n }\n \n-impl VisitTags for SbTag {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+impl VisitTags for BorTag {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         visit(*self)\n     }\n }\n \n impl VisitTags for Provenance {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        if let Provenance::Concrete { sb, .. } = self {\n-            visit(*sb);\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        if let Provenance::Concrete { tag, .. } = self {\n+            visit(*tag);\n         }\n     }\n }\n \n impl VisitTags for Pointer<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let (prov, _offset) = self.into_parts();\n         prov.visit_tags(visit);\n     }\n }\n \n impl VisitTags for Pointer<Option<Provenance>> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let (prov, _offset) = self.into_parts();\n         prov.visit_tags(visit);\n     }\n }\n \n impl VisitTags for Scalar<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             Scalar::Ptr(ptr, _) => ptr.visit_tags(visit),\n             Scalar::Int(_) => (),\n@@ -58,7 +58,7 @@ impl VisitTags for Scalar<Provenance> {\n }\n \n impl VisitTags for Immediate<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             Immediate::Scalar(s) => {\n                 s.visit_tags(visit);\n@@ -73,7 +73,7 @@ impl VisitTags for Immediate<Provenance> {\n }\n \n impl VisitTags for MemPlaceMeta<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             MemPlaceMeta::Meta(m) => m.visit_tags(visit),\n             MemPlaceMeta::None => {}\n@@ -82,21 +82,21 @@ impl VisitTags for MemPlaceMeta<Provenance> {\n }\n \n impl VisitTags for MemPlace<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         let MemPlace { ptr, meta } = self;\n         ptr.visit_tags(visit);\n         meta.visit_tags(visit);\n     }\n }\n \n impl VisitTags for MPlaceTy<'_, Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         (**self).visit_tags(visit)\n     }\n }\n \n impl VisitTags for Place<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             Place::Ptr(p) => p.visit_tags(visit),\n             Place::Local { .. } => {\n@@ -107,13 +107,13 @@ impl VisitTags for Place<Provenance> {\n }\n \n impl VisitTags for PlaceTy<'_, Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         (**self).visit_tags(visit)\n     }\n }\n \n impl VisitTags for Operand<Provenance> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             Operand::Immediate(imm) => {\n                 imm.visit_tags(visit);\n@@ -126,7 +126,7 @@ impl VisitTags for Operand<Provenance> {\n }\n \n impl VisitTags for Allocation<Provenance, AllocExtra> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for prov in self.provenance().provenances() {\n             prov.visit_tags(visit);\n         }\n@@ -136,7 +136,7 @@ impl VisitTags for Allocation<Provenance, AllocExtra> {\n }\n \n impl VisitTags for crate::MiriInterpCx<'_, '_> {\n-    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         // Memory.\n         self.memory.alloc_map().iter(|it| {\n             for (_id, (_kind, alloc)) in it {\n@@ -154,7 +154,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     fn garbage_collect_tags(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // No reason to do anything at all if stacked borrows is off.\n-        if this.machine.stacked_borrows.is_none() {\n+        if this.machine.borrow_tracker.is_none() {\n             return Ok(());\n         }\n \n@@ -167,17 +167,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn remove_unreachable_tags(&mut self, tags: FxHashSet<SbTag>) {\n+    fn remove_unreachable_tags(&mut self, tags: FxHashSet<BorTag>) {\n         let this = self.eval_context_mut();\n         this.memory.alloc_map().iter(|it| {\n             for (_id, (_kind, alloc)) in it {\n-                alloc\n-                    .extra\n-                    .stacked_borrows\n-                    .as_ref()\n-                    .unwrap()\n-                    .borrow_mut()\n-                    .remove_unreachable_tags(&tags);\n+                if let Some(bt) = &alloc.extra.borrow_tracker {\n+                    bt.remove_unreachable_tags(&tags);\n+                }\n             }\n         });\n     }"}, {"sha": "50a0e8e6edef8e551c36a89056c9d52212501c55", "filename": "src/tools/miri/tests/fail/function_calls/exported_symbol_abi_mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     #[cfg(fn_ptr)]\n     unsafe {\n         std::mem::transmute::<unsafe fn(), unsafe extern \"C\" fn()>(foo)();\n-        //[fn_ptr]~^ ERROR: calling a function with calling convention Rust using calling convention C\n+        //~[fn_ptr]^ ERROR: calling a function with calling convention Rust using calling convention C\n     }\n \n     // `Instance` caching should not suppress ABI check.\n@@ -28,8 +28,8 @@ fn main() {\n         }\n         unsafe {\n             foo();\n-            //[no_cache]~^ ERROR: calling a function with calling convention Rust using calling convention C\n-            //[cache]~| ERROR: calling a function with calling convention Rust using calling convention C\n+            //~[no_cache]^ ERROR: calling a function with calling convention Rust using calling convention C\n+            //~[cache]| ERROR: calling a function with calling convention Rust using calling convention C\n         }\n     }\n }"}, {"sha": "554cbe09cf03d18d4c29b47b3b1779e600246166", "filename": "src/tools/miri/tests/fail/function_calls/exported_symbol_bad_unwind2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_bad_unwind2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_bad_unwind2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_bad_unwind2.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -4,8 +4,8 @@\n #[cfg_attr(any(definition, both), rustc_nounwind)]\n #[no_mangle]\n extern \"C-unwind\" fn nounwind() {\n-    //[definition]~^ ERROR: abnormal termination: the program aborted execution\n-    //[both]~^^ ERROR: abnormal termination: the program aborted execution\n+    //~[definition]^ ERROR: abnormal termination: the program aborted execution\n+    //~[both]^^ ERROR: abnormal termination: the program aborted execution\n     panic!();\n }\n \n@@ -15,5 +15,5 @@ fn main() {\n         fn nounwind();\n     }\n     unsafe { nounwind() }\n-    //[extern_block]~^ ERROR: unwinding past a stack frame that does not allow unwinding\n+    //~[extern_block]^ ERROR: unwinding past a stack frame that does not allow unwinding\n }"}, {"sha": "f28e43696f709c850a231daff02d5ea8d9488d99", "filename": "src/tools/miri/tests/many-seeds/scoped-thread-leak.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Ftests%2Fmany-seeds%2Fscoped-thread-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Ftests%2Fmany-seeds%2Fscoped-thread-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fmany-seeds%2Fscoped-thread-leak.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,8 @@\n+//! Regression test for https://github.com/rust-lang/miri/issues/2629\n+use std::thread;\n+\n+fn main() {\n+    thread::scope(|s| {\n+        s.spawn(|| {});\n+    });\n+}"}, {"sha": "ce5d17f5f2dc59ec9e0b81e0762cfdd699703b30", "filename": "src/tools/miri/tests/pass/concurrency/scope.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fscope.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -0,0 +1,24 @@\n+use std::thread;\n+\n+fn main() {\n+    let mut a = vec![1, 2, 3];\n+    let mut x = 0;\n+\n+    thread::scope(|s| {\n+        s.spawn(|| {\n+            // We can borrow `a` here.\n+            let _s = format!(\"hello from the first scoped thread: {a:?}\");\n+        });\n+        s.spawn(|| {\n+            let _s = format!(\"hello from the second scoped thread\");\n+            // We can even mutably borrow `x` here,\n+            // because no other threads are using it.\n+            x += a[0] + a[2];\n+        });\n+        let _s = format!(\"hello from the main thread\");\n+    });\n+\n+    // After the scope, we can modify and access our variables again:\n+    a.push(4);\n+    assert_eq!(x, a.len());\n+}"}, {"sha": "244d4427c562359c695f7095ab936cdd3ba3be21", "filename": "src/tools/rustfmt/src/closures.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8a52e3a4ba9549edb71836561be13e73a8a50a7/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs?ref=b8a52e3a4ba9549edb71836561be13e73a8a50a7", "patch": "@@ -335,6 +335,7 @@ pub(crate) fn rewrite_last_closure(\n             ref fn_decl,\n             ref body,\n             fn_decl_span: _,\n+            fn_arg_span: _,\n         } = **closure;\n         let body = match body.kind {\n             ast::ExprKind::Block(ref block, _)"}]}