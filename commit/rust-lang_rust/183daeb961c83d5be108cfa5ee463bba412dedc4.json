{"sha": "183daeb961c83d5be108cfa5ee463bba412dedc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4M2RhZWI5NjFjODNkNWJlMTA4Y2ZhNWVlNDYzYmJhNDEyZGVkYzQ=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T08:55:29Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:24Z"}, "message": "move filter_map to its own module", "tree": {"sha": "b7ccdc24317f88251cc06de6179d17bd58343ccc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7ccdc24317f88251cc06de6179d17bd58343ccc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/183daeb961c83d5be108cfa5ee463bba412dedc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/183daeb961c83d5be108cfa5ee463bba412dedc4", "html_url": "https://github.com/rust-lang/rust/commit/183daeb961c83d5be108cfa5ee463bba412dedc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/183daeb961c83d5be108cfa5ee463bba412dedc4/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9", "html_url": "https://github.com/rust-lang/rust/commit/2561b7ea062f0c07f27d9ebdf0c355ab29a4edf9"}], "stats": {"total": 166, "additions": 89, "deletions": 77}, "files": [{"sha": "f559160004cb1f56ad61fb21a5aa4a427c7e2b36", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/183daeb961c83d5be108cfa5ee463bba412dedc4/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183daeb961c83d5be108cfa5ee463bba412dedc4/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=183daeb961c83d5be108cfa5ee463bba412dedc4", "patch": "@@ -0,0 +1,85 @@\n+use crate::utils::{match_trait_method, path_to_local_id, paths, snippet, span_lint_and_sugg, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::{Expr, ExprKind, PatKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+use rustc_span::symbol::sym;\n+\n+use super::MANUAL_FILTER_MAP;\n+use super::MANUAL_FIND_MAP;\n+\n+/// lint use of `filter().map()` or `find().map()` for `Iterators`\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_find: bool) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(_, _, [map_recv, map_arg], map_span) = expr.kind;\n+        if let ExprKind::MethodCall(_, _, [_, filter_arg], filter_span) = map_recv.kind;\n+        if match_trait_method(cx, map_recv, &paths::ITERATOR);\n+\n+        // filter(|x| ...is_some())...\n+        if let ExprKind::Closure(_, _, filter_body_id, ..) = filter_arg.kind;\n+        let filter_body = cx.tcx.hir().body(filter_body_id);\n+        if let [filter_param] = filter_body.params;\n+        // optional ref pattern: `filter(|&x| ..)`\n+        let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n+            (ref_pat, true)\n+        } else {\n+            (filter_param.pat, false)\n+        };\n+        // closure ends with is_some() or is_ok()\n+        if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n+        if let ExprKind::MethodCall(path, _, [filter_arg], _) = filter_body.value.kind;\n+        if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n+        if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::option_type, opt_ty.did) {\n+            Some(false)\n+        } else if cx.tcx.is_diagnostic_item(sym::result_type, opt_ty.did) {\n+            Some(true)\n+        } else {\n+            None\n+        };\n+        if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n+\n+        // ...map(|x| ...unwrap())\n+        if let ExprKind::Closure(_, _, map_body_id, ..) = map_arg.kind;\n+        let map_body = cx.tcx.hir().body(map_body_id);\n+        if let [map_param] = map_body.params;\n+        if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n+        // closure ends with expect() or unwrap()\n+        if let ExprKind::MethodCall(seg, _, [map_arg, ..], _) = map_body.value.kind;\n+        if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n+\n+        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+            // in `filter(|x| ..)`, replace `*x` with `x`\n+            let a_path = if_chain! {\n+                if !is_filter_param_ref;\n+                if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n+                then { expr_path } else { a }\n+            };\n+            // let the filter closure arg and the map closure arg be equal\n+            if_chain! {\n+                if path_to_local_id(a_path, filter_param_id);\n+                if path_to_local_id(b, map_param_id);\n+                if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n+                then {\n+                    return true;\n+                }\n+            }\n+            false\n+        };\n+        if SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg);\n+        then {\n+            let span = filter_span.to(map_span);\n+            let (filter_name, lint) = if is_find {\n+                (\"find\", MANUAL_FIND_MAP)\n+            } else {\n+                (\"filter\", MANUAL_FILTER_MAP)\n+            };\n+            let msg = format!(\"`{}(..).map(..)` can be simplified as `{0}_map(..)`\", filter_name);\n+            let to_opt = if is_result { \".ok()\" } else { \"\" };\n+            let sugg = format!(\"{}_map(|{}| {}{})\", filter_name, map_param_ident,\n+                snippet(cx, map_arg.span, \"..\"), to_opt);\n+            span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n+        }\n+    }\n+}"}, {"sha": "61d562cbc284438c96599c83a4157cd2d93b5c40", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/183daeb961c83d5be108cfa5ee463bba412dedc4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/183daeb961c83d5be108cfa5ee463bba412dedc4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=183daeb961c83d5be108cfa5ee463bba412dedc4", "patch": "@@ -3,6 +3,7 @@ mod bytes_nth;\n mod clone_on_ref_ptr;\n mod expect_used;\n mod filetype_is_file;\n+mod filter_map;\n mod filter_map_identity;\n mod filter_next;\n mod from_iter_instead_of_collect;\n@@ -43,7 +44,7 @@ use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{Expr, ExprKind, PatKind, TraitItem, TraitItemKind, UnOp};\n+use rustc_hir::{PatKind, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n@@ -1698,10 +1699,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"next\", \"filter\"] => filter_next::check(cx, expr, arg_lists[1]),\n             [\"next\", \"skip_while\"] => skip_while_next::check(cx, expr, arg_lists[1]),\n             [\"next\", \"iter\"] => iter_next_slice::check(cx, expr, arg_lists[1]),\n-            [\"map\", \"filter\"] => lint_filter_map(cx, expr, false),\n+            [\"map\", \"filter\"] => filter_map::check(cx, expr, false),\n             [\"map\", \"filter_map\"] => lint_filter_map_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"next\", \"filter_map\"] => lint_filter_map_next(cx, expr, arg_lists[1], self.msrv.as_ref()),\n-            [\"map\", \"find\"] => lint_filter_map(cx, expr, true),\n+            [\"map\", \"find\"] => filter_map::check(cx, expr, true),\n             [\"flat_map\", \"filter\"] => lint_filter_flat_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"flat_map\", \"filter_map\"] => lint_filter_map_flat_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"flat_map\", ..] => lint_flat_map_identity(cx, expr, arg_lists[0], method_spans[0]),\n@@ -2750,80 +2751,6 @@ fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     );\n }\n \n-/// lint use of `filter().map()` or `find().map()` for `Iterators`\n-fn lint_filter_map<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_find: bool) {\n-    if_chain! {\n-        if let ExprKind::MethodCall(_, _, [map_recv, map_arg], map_span) = expr.kind;\n-        if let ExprKind::MethodCall(_, _, [_, filter_arg], filter_span) = map_recv.kind;\n-        if match_trait_method(cx, map_recv, &paths::ITERATOR);\n-\n-        // filter(|x| ...is_some())...\n-        if let ExprKind::Closure(_, _, filter_body_id, ..) = filter_arg.kind;\n-        let filter_body = cx.tcx.hir().body(filter_body_id);\n-        if let [filter_param] = filter_body.params;\n-        // optional ref pattern: `filter(|&x| ..)`\n-        let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n-            (ref_pat, true)\n-        } else {\n-            (filter_param.pat, false)\n-        };\n-        // closure ends with is_some() or is_ok()\n-        if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n-        if let ExprKind::MethodCall(path, _, [filter_arg], _) = filter_body.value.kind;\n-        if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n-        if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::option_type, opt_ty.did) {\n-            Some(false)\n-        } else if cx.tcx.is_diagnostic_item(sym::result_type, opt_ty.did) {\n-            Some(true)\n-        } else {\n-            None\n-        };\n-        if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n-\n-        // ...map(|x| ...unwrap())\n-        if let ExprKind::Closure(_, _, map_body_id, ..) = map_arg.kind;\n-        let map_body = cx.tcx.hir().body(map_body_id);\n-        if let [map_param] = map_body.params;\n-        if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n-        // closure ends with expect() or unwrap()\n-        if let ExprKind::MethodCall(seg, _, [map_arg, ..], _) = map_body.value.kind;\n-        if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n-\n-        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-            // in `filter(|x| ..)`, replace `*x` with `x`\n-            let a_path = if_chain! {\n-                if !is_filter_param_ref;\n-                if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n-                then { expr_path } else { a }\n-            };\n-            // let the filter closure arg and the map closure arg be equal\n-            if_chain! {\n-                if path_to_local_id(a_path, filter_param_id);\n-                if path_to_local_id(b, map_param_id);\n-                if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n-                then {\n-                    return true;\n-                }\n-            }\n-            false\n-        };\n-        if SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg);\n-        then {\n-            let span = filter_span.to(map_span);\n-            let (filter_name, lint) = if is_find {\n-                (\"find\", MANUAL_FIND_MAP)\n-            } else {\n-                (\"filter\", MANUAL_FILTER_MAP)\n-            };\n-            let msg = format!(\"`{}(..).map(..)` can be simplified as `{0}_map(..)`\", filter_name);\n-            let to_opt = if is_result { \".ok()\" } else { \"\" };\n-            let sugg = format!(\"{}_map(|{}| {}{})\", filter_name, map_param_ident,\n-                snippet(cx, map_arg.span, \"..\"), to_opt);\n-            span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n-        }\n-    }\n-}\n-\n const FILTER_MAP_NEXT_MSRV: RustcVersion = RustcVersion::new(1, 30, 0);\n \n /// lint use of `filter_map().next()` for `Iterators`"}]}