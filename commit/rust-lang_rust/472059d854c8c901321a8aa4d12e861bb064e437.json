{"sha": "472059d854c8c901321a8aa4d12e861bb064e437", "node_id": "C_kwDOAAsO6NoAKDQ3MjA1OWQ4NTRjOGM5MDEzMjFhOGFhNGQxMmU4NjFiYjA2NGU0Mzc", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-02-20T14:07:19Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-02-20T14:11:38Z"}, "message": "Deduplicate some logic between dyn* and dyn", "tree": {"sha": "26d3081b1597092d6c58b0ec2728e725fbfb6cc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d3081b1597092d6c58b0ec2728e725fbfb6cc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/472059d854c8c901321a8aa4d12e861bb064e437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/472059d854c8c901321a8aa4d12e861bb064e437", "html_url": "https://github.com/rust-lang/rust/commit/472059d854c8c901321a8aa4d12e861bb064e437", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/472059d854c8c901321a8aa4d12e861bb064e437/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad6dd60396d2a4e493e65ee5ba66562168d28cec", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6dd60396d2a4e493e65ee5ba66562168d28cec", "html_url": "https://github.com/rust-lang/rust/commit/ad6dd60396d2a4e493e65ee5ba66562168d28cec"}], "stats": {"total": 83, "additions": 37, "deletions": 46}, "files": [{"sha": "94ac3b6ebad8655f36fe6443459222c6a3e7d3bb", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/472059d854c8c901321a8aa4d12e861bb064e437/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/472059d854c8c901321a8aa4d12e861bb064e437/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=472059d854c8c901321a8aa4d12e861bb064e437", "patch": "@@ -571,64 +571,55 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Obtain the underlying trait we are working on, and the adjusted receiver argument.\n                 let recv_ty = receiver.layout.ty;\n-                let (vptr, dyn_ty, adjusted_receiver) = match recv_ty.kind() {\n-                    ty::Ref(..) | ty::RawPtr(..)\n-                        if matches!(\n-                            recv_ty.builtin_deref(true).unwrap().ty.kind(),\n-                            ty::Dynamic(_, _, ty::DynStar)\n-                        ) =>\n-                    {\n-                        let receiver = self.deref_operand(&receiver)?;\n-                        let ty::Dynamic(data, ..) = receiver.layout.ty.kind() else { bug!() };\n-                        let (recv, vptr) = self.unpack_dyn_star(&receiver.into())?;\n-                        let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n-                        if dyn_trait != data.principal() {\n-                            throw_ub_format!(\n-                                \"`dyn*` call on a pointer whose vtable does not match its type\"\n-                            );\n-                        }\n-                        let recv = recv.assert_mem_place(); // we passed an MPlaceTy to `unpack_dyn_star` so we definitely still have one\n-\n-                        (vptr, dyn_ty, recv.ptr)\n-                    }\n+                let receiver_place = match recv_ty.kind() {\n+                    ty::Ref(..) | ty::RawPtr(..) => self.deref_operand(&receiver)?,\n+                    ty::Dynamic(_, _, ty::Dyn) => receiver.assert_mem_place(), // unsized (`dyn`) cannot be immediate\n                     ty::Dynamic(_, _, ty::DynStar) => {\n                         // Not clear how to handle this, so far we assume the receiver is always a pointer.\n                         span_bug!(\n                             self.cur_span(),\n                             \"by-value calls on a `dyn*`... are those a thing?\"\n                         );\n                     }\n-                    _ => {\n-                        let receiver_place = match recv_ty.kind() {\n-                            ty::Ref(..) | ty::RawPtr(..) => self.deref_operand(&receiver)?,\n-                            ty::Dynamic(_, _, ty::Dyn) => receiver.assert_mem_place(), // unsized (`dyn`) cannot be immediate\n-                            _ => bug!(),\n-                        };\n-                        // Doesn't have to be a `dyn Trait`, but the unsized tail must be `dyn Trait`.\n-                        // (For that reason we also cannot use `unpack_dyn_trait`.)\n-                        let receiver_tail = self.tcx.struct_tail_erasing_lifetimes(\n-                            receiver_place.layout.ty,\n-                            self.param_env,\n+                    _ => bug!(),\n+                };\n+                let (vptr, dyn_ty, adjusted_receiver) = if let ty::Dynamic(data, _, ty::DynStar) =\n+                    receiver_place.layout.ty.kind()\n+                {\n+                    let (recv, vptr) = self.unpack_dyn_star(&receiver_place.into())?;\n+                    let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n+                    if dyn_trait != data.principal() {\n+                        throw_ub_format!(\n+                            \"`dyn*` call on a pointer whose vtable does not match its type\"\n                         );\n-                        let ty::Dynamic(data, _, ty::Dyn) = receiver_tail.kind() else {\n+                    }\n+                    let recv = recv.assert_mem_place(); // we passed an MPlaceTy to `unpack_dyn_star` so we definitely still have one\n+\n+                    (vptr, dyn_ty, recv.ptr)\n+                } else {\n+                    // Doesn't have to be a `dyn Trait`, but the unsized tail must be `dyn Trait`.\n+                    // (For that reason we also cannot use `unpack_dyn_trait`.)\n+                    let receiver_tail = self\n+                        .tcx\n+                        .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env);\n+                    let ty::Dynamic(data, _, ty::Dyn) = receiver_tail.kind() else {\n                             span_bug!(self.cur_span(), \"dynamic call on non-`dyn` type {}\", receiver_tail)\n                         };\n-                        assert!(receiver_place.layout.is_unsized());\n-\n-                        // Get the required information from the vtable.\n-                        let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n-                        let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n-                        if dyn_trait != data.principal() {\n-                            throw_ub_format!(\n-                                \"`dyn` call on a pointer whose vtable does not match its type\"\n-                            );\n-                        }\n+                    assert!(receiver_place.layout.is_unsized());\n \n-                        // It might be surprising that we use a pointer as the receiver even if this\n-                        // is a by-val case; this works because by-val passing of an unsized `dyn\n-                        // Trait` to a function is actually desugared to a pointer.\n-                        (vptr, dyn_ty, receiver_place.ptr)\n+                    // Get the required information from the vtable.\n+                    let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n+                    let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n+                    if dyn_trait != data.principal() {\n+                        throw_ub_format!(\n+                            \"`dyn` call on a pointer whose vtable does not match its type\"\n+                        );\n                     }\n+\n+                    // It might be surprising that we use a pointer as the receiver even if this\n+                    // is a by-val case; this works because by-val passing of an unsized `dyn\n+                    // Trait` to a function is actually desugared to a pointer.\n+                    (vptr, dyn_ty, receiver_place.ptr)\n                 };\n \n                 // Now determine the actual method to call. We can do that in two different ways and"}]}