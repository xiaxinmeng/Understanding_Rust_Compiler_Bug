{"sha": "0f39dc7b78fb5e6d79ab74756de2e717e6c19058", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMzlkYzdiNzhmYjVlNmQ3OWFiNzQ3NTZkZTJlNzE3ZTZjMTkwNTg=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-06-21T03:05:42Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-06-21T21:42:22Z"}, "message": "std: inline many of the Writer/Reader methods\n\nThis allows llvm to optimize away much of the overhead from using\nthe MemReader/MemWriters. My benchmarks showed it to shave 15% off\nof my in progress serialization/json encoding.", "tree": {"sha": "4a1e2c2730940c98cd30eacdc66438093f325485", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a1e2c2730940c98cd30eacdc66438093f325485"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f39dc7b78fb5e6d79ab74756de2e717e6c19058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f39dc7b78fb5e6d79ab74756de2e717e6c19058", "html_url": "https://github.com/rust-lang/rust/commit/0f39dc7b78fb5e6d79ab74756de2e717e6c19058", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f39dc7b78fb5e6d79ab74756de2e717e6c19058/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76371d1ff1b6fc7c84e12513816a4586e14aa24b", "url": "https://api.github.com/repos/rust-lang/rust/commits/76371d1ff1b6fc7c84e12513816a4586e14aa24b", "html_url": "https://github.com/rust-lang/rust/commit/76371d1ff1b6fc7c84e12513816a4586e14aa24b"}], "stats": {"total": 127, "additions": 127, "deletions": 0}, "files": [{"sha": "ec3d93708331c0b6e47e73348ef5b4cf0c1305f3", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0f39dc7b78fb5e6d79ab74756de2e717e6c19058/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f39dc7b78fb5e6d79ab74756de2e717e6c19058/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=0f39dc7b78fb5e6d79ab74756de2e717e6c19058", "patch": "@@ -59,11 +59,13 @@ pub struct MemWriter {\n \n impl MemWriter {\n     /// Create a new `MemWriter`.\n+    #[inline]\n     pub fn new() -> MemWriter {\n         MemWriter::with_capacity(128)\n     }\n     /// Create a new `MemWriter`, allocating at least `n` bytes for\n     /// the internal buffer.\n+    #[inline]\n     pub fn with_capacity(n: uint) -> MemWriter {\n         MemWriter { buf: Vec::with_capacity(n), pos: 0 }\n     }\n@@ -73,13 +75,16 @@ impl MemWriter {\n     ///\n     /// No method is exposed for acquiring a mutable reference to the buffer\n     /// because it could corrupt the state of this `MemWriter`.\n+    #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n \n     /// Unwraps this `MemWriter`, returning the underlying buffer\n+    #[inline]\n     pub fn unwrap(self) -> Vec<u8> { self.buf }\n }\n \n impl Writer for MemWriter {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         // Make sure the internal buffer is as least as big as where we\n         // currently are\n@@ -112,7 +117,10 @@ impl Writer for MemWriter {\n }\n \n impl Seek for MemWriter {\n+    #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n@@ -140,6 +148,7 @@ pub struct MemReader {\n impl MemReader {\n     /// Creates a new `MemReader` which will read the buffer given. The buffer\n     /// can be re-acquired through `unwrap`\n+    #[inline]\n     pub fn new(buf: Vec<u8>) -> MemReader {\n         MemReader {\n             buf: buf,\n@@ -150,20 +159,24 @@ impl MemReader {\n     /// Tests whether this reader has read all bytes in its buffer.\n     ///\n     /// If `true`, then this will no longer return bytes from `read`.\n+    #[inline]\n     pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n \n     /// Acquires an immutable reference to the underlying buffer of this\n     /// `MemReader`.\n     ///\n     /// No method is exposed for acquiring a mutable reference to the buffer\n     /// because it could corrupt the state of this `MemReader`.\n+    #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n \n     /// Unwraps this `MemReader`, returning the underlying buffer\n+    #[inline]\n     pub fn unwrap(self) -> Vec<u8> { self.buf }\n }\n \n impl Reader for MemReader {\n+    #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n \n@@ -182,7 +195,10 @@ impl Reader for MemReader {\n }\n \n impl Seek for MemReader {\n+    #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n@@ -191,13 +207,16 @@ impl Seek for MemReader {\n }\n \n impl Buffer for MemReader {\n+    #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf.slice_from(self.pos))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n     }\n+\n+    #[inline]\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n@@ -227,6 +246,7 @@ pub struct BufWriter<'a> {\n impl<'a> BufWriter<'a> {\n     /// Creates a new `BufWriter` which will wrap the specified buffer. The\n     /// writer initially starts at position 0.\n+    #[inline]\n     pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> {\n         BufWriter {\n             buf: buf,\n@@ -236,6 +256,7 @@ impl<'a> BufWriter<'a> {\n }\n \n impl<'a> Writer for BufWriter<'a> {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         // return an error if the entire write does not fit in the buffer\n         let max_size = self.buf.len();\n@@ -254,7 +275,10 @@ impl<'a> Writer for BufWriter<'a> {\n }\n \n impl<'a> Seek for BufWriter<'a> {\n+    #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n@@ -282,6 +306,7 @@ pub struct BufReader<'a> {\n \n impl<'a> BufReader<'a> {\n     /// Creates a new buffered reader which will read the specified buffer\n+    #[inline]\n     pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> {\n         BufReader {\n             buf: buf,\n@@ -292,10 +317,12 @@ impl<'a> BufReader<'a> {\n     /// Tests whether this reader has read all bytes in its buffer.\n     ///\n     /// If `true`, then this will no longer return bytes from `read`.\n+    #[inline]\n     pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n }\n \n impl<'a> Reader for BufReader<'a> {\n+    #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n \n@@ -314,7 +341,10 @@ impl<'a> Reader for BufReader<'a> {\n }\n \n impl<'a> Seek for BufReader<'a> {\n+    #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n@@ -323,22 +353,27 @@ impl<'a> Seek for BufReader<'a> {\n }\n \n impl<'a> Buffer for BufReader<'a> {\n+    #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf.slice_from(self.pos))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n     }\n+\n+    #[inline]\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n #[cfg(test)]\n mod test {\n+    extern crate test;\n     use prelude::*;\n     use super::*;\n     use io::*;\n     use io;\n+    use self::test::Bencher;\n     use str::StrSlice;\n \n     #[test]\n@@ -571,4 +606,59 @@ mod test {\n         assert!(r.read_at_least(buf.len(), buf).is_err());\n         assert_eq!(buf.as_slice(), &[7, 8, 6]);\n     }\n+\n+    #[bench]\n+    fn bench_mem_writer(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut wr = MemWriter::new();\n+            for _i in range(0, 10) {\n+                wr.write([5, .. 10]).unwrap();\n+            }\n+            assert_eq!(wr.unwrap().as_slice(), [5, .. 100].as_slice());\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_mem_reader(b: &mut Bencher) {\n+        b.iter(|| {\n+            let buf = Vec::from_slice([5 as u8, ..100]);\n+            {\n+                let mut rdr = MemReader::new(buf);\n+                for _i in range(0, 10) {\n+                    let mut buf = [0 as u8, .. 10];\n+                    rdr.read(buf).unwrap();\n+                    assert_eq!(buf.as_slice(), [5, .. 10].as_slice());\n+                }\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_buf_writer(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut buf = [0 as u8, ..100];\n+            {\n+                let mut wr = BufWriter::new(buf);\n+                for _i in range(0, 10) {\n+                    wr.write([5, .. 10]).unwrap();\n+                }\n+            }\n+            assert_eq!(buf.as_slice(), [5, .. 100].as_slice());\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_buf_reader(b: &mut Bencher) {\n+        b.iter(|| {\n+            let buf = [5 as u8, ..100];\n+            {\n+                let mut rdr = BufReader::new(buf);\n+                for _i in range(0, 10) {\n+                    let mut buf = [0 as u8, .. 10];\n+                    rdr.read(buf).unwrap();\n+                    assert_eq!(buf.as_slice(), [5, .. 10].as_slice());\n+                }\n+            }\n+        });\n+    }\n }"}, {"sha": "1d6ad7c31e2fd5ff29c3ce7501ed057658b41411", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f39dc7b78fb5e6d79ab74756de2e717e6c19058/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f39dc7b78fb5e6d79ab74756de2e717e6c19058/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0f39dc7b78fb5e6d79ab74756de2e717e6c19058", "patch": "@@ -1084,6 +1084,7 @@ pub trait Writer {\n     /// If other encodings are desired, it is recommended to compose this stream\n     /// with another performing the conversion, or to use `write` with a\n     /// converted byte-array instead.\n+    #[inline]\n     fn write_str(&mut self, s: &str) -> IoResult<()> {\n         self.write(s.as_bytes())\n     }\n@@ -1095,123 +1096,146 @@ pub trait Writer {\n     ///\n     /// If other encodings or line ending flavors are desired, it is recommended\n     /// that the `write` method is used specifically instead.\n+    #[inline]\n     fn write_line(&mut self, s: &str) -> IoResult<()> {\n         self.write_str(s).and_then(|()| self.write(['\\n' as u8]))\n     }\n \n     /// Write a single char, encoded as UTF-8.\n+    #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n         let n = c.encode_utf8(buf.as_mut_slice());\n         self.write(buf.slice_to(n))\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n+    #[inline]\n     fn write_int(&mut self, n: int) -> IoResult<()> {\n         write!(self, \"{:d}\", n)\n     }\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n+    #[inline]\n     fn write_uint(&mut self, n: uint) -> IoResult<()> {\n         write!(self, \"{:u}\", n)\n     }\n \n     /// Write a little-endian uint (number of bytes depends on system).\n+    #[inline]\n     fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n+    #[inline]\n     fn write_le_int(&mut self, n: int) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n+    #[inline]\n     fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n+    #[inline]\n     fn write_be_int(&mut self, n: int) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes).\n+    #[inline]\n     fn write_be_u64(&mut self, n: u64) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n, 8u, |v| self.write(v))\n     }\n \n     /// Write a big-endian u32 (4 bytes).\n+    #[inline]\n     fn write_be_u32(&mut self, n: u32) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a big-endian u16 (2 bytes).\n+    #[inline]\n     fn write_be_u16(&mut self, n: u16) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i64 (8 bytes).\n+    #[inline]\n     fn write_be_i64(&mut self, n: i64) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i32 (4 bytes).\n+    #[inline]\n     fn write_be_i32(&mut self, n: i32) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i16 (2 bytes).\n+    #[inline]\n     fn write_be_i16(&mut self, n: i16) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n+    #[inline]\n     fn write_be_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n             self.write_be_u64(transmute(f))\n         }\n     }\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n+    #[inline]\n     fn write_be_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n             self.write_be_u32(transmute(f))\n         }\n     }\n \n     /// Write a little-endian u64 (8 bytes).\n+    #[inline]\n     fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n, 8u, |v| self.write(v))\n     }\n \n     /// Write a little-endian u32 (4 bytes).\n+    #[inline]\n     fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a little-endian u16 (2 bytes).\n+    #[inline]\n     fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i64 (8 bytes).\n+    #[inline]\n     fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i32 (4 bytes).\n+    #[inline]\n     fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i16 (2 bytes).\n+    #[inline]\n     fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n     /// (8 bytes).\n+    #[inline]\n     fn write_le_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n             self.write_le_u64(transmute(f))\n@@ -1220,18 +1244,21 @@ pub trait Writer {\n \n     /// Write a little-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n+    #[inline]\n     fn write_le_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n             self.write_le_u32(transmute(f))\n         }\n     }\n \n     /// Write a u8 (1 byte).\n+    #[inline]\n     fn write_u8(&mut self, n: u8) -> IoResult<()> {\n         self.write([n])\n     }\n \n     /// Write an i8 (1 byte).\n+    #[inline]\n     fn write_i8(&mut self, n: i8) -> IoResult<()> {\n         self.write([n as u8])\n     }\n@@ -1240,18 +1267,25 @@ pub trait Writer {\n     ///\n     /// This is useful to allow applying wrappers while still\n     /// retaining ownership of the original value.\n+    #[inline]\n     fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self> {\n         RefWriter { inner: self }\n     }\n }\n \n impl Writer for Box<Writer> {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n+\n+    #[inline]\n     fn flush(&mut self) -> IoResult<()> { self.flush() }\n }\n \n impl<'a> Writer for &'a mut Writer {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n+\n+    #[inline]\n     fn flush(&mut self) -> IoResult<()> { self.flush() }\n }\n \n@@ -1285,7 +1319,10 @@ pub struct RefWriter<'a, W> {\n }\n \n impl<'a, W: Writer> Writer for RefWriter<'a, W> {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write(buf) }\n+\n+    #[inline]\n     fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n }\n "}]}