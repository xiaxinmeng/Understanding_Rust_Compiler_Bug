{"sha": "b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYTk2NGE5YmYyM2M5MmE2YjZjYjU3NjJiNTRlMGYwZjRhMzM3ZDU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-24T19:10:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-13T21:06:20Z"}, "message": "native: Search the child's PATH on win32\n\nIn order to have the spawning semantics be the same for unix/windows, the\nchild's PATH environment variable needs to be searched rather than the parent's\nenvironment variable.\n\nIf the child is inheriting the parent's PATH, then no action need be taken as\nwindows will do the heavy lifting. If the child specifies its own PATH, then it\nis searched beforehand for the target program and the result is favored if a hit\nis found.\n\ncc #15149, but does not close the issue because libgreen still needs to be\nupdated.", "tree": {"sha": "7055bf34f4196565524721fb478b5b2bfbb1d3b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7055bf34f4196565524721fb478b5b2bfbb1d3b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5", "html_url": "https://github.com/rust-lang/rust/commit/b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbeee04f31ac16fe61f29749145a29e562d065fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbeee04f31ac16fe61f29749145a29e562d065fe", "html_url": "https://github.com/rust-lang/rust/commit/fbeee04f31ac16fe61f29749145a29e562d065fe"}], "stats": {"total": 78, "additions": 77, "deletions": 1}, "files": [{"sha": "e3e6ae425266e586265c3e2866390bd8c83c4420", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5", "patch": "@@ -305,6 +305,25 @@ fn spawn_process_os(cfg: ProcessConfig,\n         })\n     }\n \n+    // To have the spawning semantics of unix/windows stay the same, we need to\n+    // read the *child's* PATH if one is provided. See #15149 for more details.\n+    let program = cfg.env.and_then(|env| {\n+        for &(ref key, ref v) in env.iter() {\n+            if b\"PATH\" != key.as_bytes_no_nul() { continue }\n+\n+            // Split the value and test each path to see if the program exists.\n+            for path in os::split_paths(v.as_bytes_no_nul()).move_iter() {\n+                let path = path.join(cfg.program.as_bytes_no_nul())\n+                               .with_extension(os::consts::EXE_EXTENSION);\n+                if path.exists() {\n+                    return Some(path.to_c_str())\n+                }\n+            }\n+            break\n+        }\n+        None\n+    });\n+\n     unsafe {\n         let mut si = zeroed_startupinfo();\n         si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n@@ -362,7 +381,8 @@ fn spawn_process_os(cfg: ProcessConfig,\n         try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n         try!(set_fd(&err_fd, &mut si.hStdError, false));\n \n-        let cmd_str = make_command_line(cfg.program, cfg.args);\n+        let cmd_str = make_command_line(program.as_ref().unwrap_or(cfg.program),\n+                                        cfg.args);\n         let mut pi = zeroed_process_information();\n         let mut create_err = None;\n "}, {"sha": "d76a7109ced8e7d87a192cc263432a7cede1116f", "filename": "src/test/run-pass/issue-15149.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=b1a964a9bf23c92a6b6cb5762b54e0f0f4a337d5", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(phase)]\n+extern crate native;\n+#[phase(plugin)]\n+extern crate green;\n+\n+use native::NativeTaskBuilder;\n+use std::io::{TempDir, Command, fs};\n+use std::os;\n+use std::task::TaskBuilder;\n+\n+// FIXME(#15149) libgreen still needs to be update. There is an open PR for it\n+//               but it is not yet merged.\n+// green_start!(main)\n+\n+fn main() {\n+    // If we're the child, make sure we were invoked correctly\n+    let args = os::args();\n+    if args.len() > 1 && args.get(1).as_slice() == \"child\" {\n+        return assert_eq!(args.get(0).as_slice(), \"mytest\");\n+    }\n+\n+    test();\n+    let (tx, rx) = channel();\n+    TaskBuilder::new().native().spawn(proc() {\n+        tx.send(test());\n+    });\n+    rx.recv();\n+}\n+\n+fn test() {\n+    // If we're the parent, copy our own binary to a tempr directory, and then\n+    // make it executable.\n+    let dir = TempDir::new(\"mytest\").unwrap();\n+    let me = os::self_exe_name().unwrap();\n+    let dest = dir.path().join(format!(\"mytest{}\", os::consts::EXE_SUFFIX));\n+    fs::copy(&me, &dest).unwrap();\n+\n+    // Append the temp directory to our own PATH.\n+    let mut path = os::split_paths(os::getenv(\"PATH\").unwrap_or(String::new()));\n+    path.push(dir.path().clone());\n+    let path = os::join_paths(path.as_slice()).unwrap();\n+\n+    Command::new(\"mytest\").env(\"PATH\", path.as_slice())\n+                          .arg(\"child\")\n+                          .spawn().unwrap();\n+}"}]}