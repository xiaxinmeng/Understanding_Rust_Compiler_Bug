{"sha": "de11710d807bed5c0a29cc0413d404552a42c89d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMTE3MTBkODA3YmVkNWMwYTI5Y2MwNDEzZDQwNDU1MmE0MmM4OWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T20:51:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T20:51:23Z"}, "message": "rollup merge of #19891: nikomatsakis/unique-fn-types-3\n\nConflicts:\n\tsrc/libcore/str.rs\n\tsrc/librustc_trans/trans/closure.rs\n\tsrc/librustc_typeck/collect.rs\n\tsrc/libstd/path/posix.rs\n\tsrc/libstd/path/windows.rs", "tree": {"sha": "a352475a1db5cdc5a19f557ba66a375766cda87c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a352475a1db5cdc5a19f557ba66a375766cda87c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de11710d807bed5c0a29cc0413d404552a42c89d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de11710d807bed5c0a29cc0413d404552a42c89d", "html_url": "https://github.com/rust-lang/rust/commit/de11710d807bed5c0a29cc0413d404552a42c89d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de11710d807bed5c0a29cc0413d404552a42c89d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "459f3b2cfa0e618d6e28ce564a363a9477567f71", "url": "https://api.github.com/repos/rust-lang/rust/commits/459f3b2cfa0e618d6e28ce564a363a9477567f71", "html_url": "https://github.com/rust-lang/rust/commit/459f3b2cfa0e618d6e28ce564a363a9477567f71"}, {"sha": "763152b995bb506ac88c852a030c84a012bcf983", "url": "https://api.github.com/repos/rust-lang/rust/commits/763152b995bb506ac88c852a030c84a012bcf983", "html_url": "https://github.com/rust-lang/rust/commit/763152b995bb506ac88c852a030c84a012bcf983"}], "stats": {"total": 792, "additions": 537, "deletions": 255}, "files": [{"sha": "65c644da3d8926dee83b3556c87237424f45ecce", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -1230,6 +1230,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n \n         Keys { inner: self.iter().map(first) }\n     }\n@@ -1251,6 +1252,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n \n         Values { inner: self.iter().map(second) }\n     }"}, {"sha": "2935692ed1580d9537b1cb5d0f0a900e6b4bdf5a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -126,6 +126,7 @@ impl<T> BTreeSet<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n \n         IntoIter { iter: self.map.into_iter().map(first) }\n     }"}, {"sha": "207e27ccdccc3619571257e1e2d6e712e0a3f517", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -144,6 +144,7 @@ impl<V> VecMap<V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n \n         Keys { iter: self.iter().map(first) }\n     }\n@@ -153,6 +154,7 @@ impl<V> VecMap<V> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n \n         Values { iter: self.iter().map(second) }\n     }\n@@ -239,6 +241,7 @@ impl<V> VecMap<V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n             v.map(|v| (i, v))\n         }\n+        let filter: fn((uint, Option<V>)) -> Option<(uint, V)> = filter; // coerce to fn ptr\n \n         let values = replace(&mut self.v, vec!());\n         IntoIter { iter: values.into_iter().enumerate().filter_map(filter) }"}, {"sha": "1cd4d7b89d6d66bd303b2bfd3f083b5d1375e42a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -2612,6 +2612,9 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n         val.clone()\n     }\n \n+    // coerce to a fn pointer\n+    let next: fn(&mut IterateState<T,F>) -> Option<T> = next;\n+\n     Unfold::new((f, Some(seed), true), next)\n }\n "}, {"sha": "de5b34ff0cadfc4f18150ad4d3fb6ca815cc5887", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -1310,6 +1310,7 @@ impl StrExt for str {\n             else { line }\n         }\n \n+        let f: fn(&str) -> &str = f; // coerce to fn pointer\n         LinesAny { inner: self.lines().map(f) }\n     }\n "}, {"sha": "f05607a999b668eea80d3fd6348d80872ed618a4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -700,7 +700,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n                                 item, tcx, cdata);\n         let name = item_name(&*intr, item);\n         let (ctor_ty, arg_tys, arg_names) = match ctor_ty.sty {\n-            ty::ty_bare_fn(ref f) =>\n+            ty::ty_bare_fn(_, ref f) =>\n                 (Some(ctor_ty), f.sig.0.inputs.clone(), None),\n             _ => { // Nullary or struct enum variant.\n                 let mut arg_names = Vec::new();"}, {"sha": "61ea93a9fdd1be38338597e2c0ccb33d35cb05e1", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -453,7 +453,11 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n         return ty::mk_closure(st.tcx, parse_closure_ty(st, |x,y| conv(x,y)));\n       }\n       'F' => {\n-        return ty::mk_bare_fn(st.tcx, parse_bare_fn_ty(st, |x,y| conv(x,y)));\n+          let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n+          return ty::mk_bare_fn(st.tcx, Some(def_id), parse_bare_fn_ty(st, |x,y| conv(x,y)));\n+      }\n+      'G' => {\n+          return ty::mk_bare_fn(st.tcx, None, parse_bare_fn_ty(st, |x,y| conv(x,y)));\n       }\n       '#' => {\n         let pos = parse_hex(st);"}, {"sha": "7fa23620af4b63e0abbd2b6be7b35738bed31b33", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -123,8 +123,13 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n             mywrite!(w, \"f\");\n             enc_closure_ty(w, cx, &**f);\n         }\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(Some(def_id), ref f) => {\n             mywrite!(w, \"F\");\n+            mywrite!(w, \"{}|\", (cx.ds)(def_id));\n+            enc_bare_fn_ty(w, cx, f);\n+        }\n+        ty::ty_bare_fn(None, ref f) => {\n+            mywrite!(w, \"G\");\n             enc_bare_fn_ty(w, cx, f);\n         }\n         ty::ty_infer(_) => {"}, {"sha": "e8627dfa64b0bdc5e11e79e03f2256658b65c88e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -1007,14 +1007,21 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                ty::AdjustAddEnv(store) => {\n-                    this.emit_enum_variant(\"AutoAddEnv\", 0, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| store.encode(this))\n+                ty::AdjustAddEnv(def_id, store) => {\n+                    this.emit_enum_variant(\"AdjustAddEnv\", 0, 2, |this| {\n+                        this.emit_enum_variant_arg(0, |this| def_id.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| store.encode(this))\n+                    })\n+                }\n+\n+                ty::AdjustReifyFnPointer(def_id) => {\n+                    this.emit_enum_variant(\"AdjustReifyFnPointer\", 1, 2, |this| {\n+                        this.emit_enum_variant_arg(0, |this| def_id.encode(this))\n                     })\n                 }\n \n                 ty::AdjustDerefRef(ref auto_deref_ref) => {\n-                    this.emit_enum_variant(\"AutoDerefRef\", 1, 1, |this| {\n+                    this.emit_enum_variant(\"AdjustDerefRef\", 2, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n                             |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n                     })\n@@ -1648,12 +1655,20 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n+                        let def_id: ast::DefId =\n+                            this.read_def_id(dcx);\n                         let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty::AdjustAddEnv(store.tr(dcx))\n+                        ty::AdjustAddEnv(def_id, store.tr(dcx))\n                     }\n                     1 => {\n+                        let def_id: ast::DefId =\n+                            this.read_def_id(dcx);\n+\n+                        ty::AdjustReifyFnPointer(def_id)\n+                    }\n+                    2 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n                                 |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();"}, {"sha": "e08dd64d4d4111480a01152c283d299668bb6da1", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -127,7 +127,11 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n         ast::ExprCast(ref from, _) => {\n             let toty = ty::expr_ty(v.tcx, e);\n             let fromty = ty::expr_ty(v.tcx, &**from);\n-            if !ty::type_is_numeric(toty) && !ty::type_is_unsafe_ptr(toty) {\n+            let is_legal_cast =\n+                ty::type_is_numeric(toty) ||\n+                ty::type_is_unsafe_ptr(toty) ||\n+                (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n+            if !is_legal_cast {\n                 span_err!(v.tcx.sess, e.span, E0012,\n                           \"can not cast to `{}` in a constant expression\",\n                           ppaux::ty_to_string(v.tcx, toty));"}, {"sha": "52899aaba412f8f4fdd4f961c4d04b428299b809", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -32,7 +32,7 @@ enum UnsafeContext {\n \n fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n-        ty::ty_bare_fn(ref f) => f.unsafety == ast::Unsafety::Unsafe,\n+        ty::ty_bare_fn(_, ref f) => f.unsafety == ast::Unsafety::Unsafe,\n         ty::ty_closure(ref f) => f.unsafety == ast::Unsafety::Unsafe,\n         _ => false,\n     }"}, {"sha": "7e31ae04ae083cabd79232e015dcf96502be3d6e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -824,10 +824,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             None => { }\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AdjustAddEnv(..) => {\n-                        // Creating a closure consumes the input and stores it\n-                        // into the resulting rvalue.\n-                        debug!(\"walk_adjustment(AutoAddEnv)\");\n+                    ty::AdjustAddEnv(..) |\n+                    ty::AdjustReifyFnPointer(..) => {\n+                        // Creating a closure/fn-pointer consumes the\n+                        // input and stores it into the resulting\n+                        // rvalue.\n+                        debug!(\"walk_adjustment(AutoAddEnv|AdjustReifyFnPointer)\");\n                         let cmt_unadjusted =\n                             return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);"}, {"sha": "62cf47da687019317fe1408baabaa5e96216ddda", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -83,7 +83,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_closure(ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n         ty::ty_param(_) => {"}, {"sha": "ec83b8fae9b7c6d23a2d35f89d7f3d9bdc87d783", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 66, "deletions": 50, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -84,10 +84,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let Coerce(ref v) = *self; v\n     }\n \n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.get_ref().infcx.tcx\n+    }\n+\n     pub fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         // Consider coercing the subtype to a DST\n         let unsize = self.unpack_actual_value(a, |a| {\n@@ -170,13 +174,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         self.unpack_actual_value(a, |a| {\n             match a.sty {\n-                ty::ty_bare_fn(ref a_f) => {\n-                    // Bare functions are coercible to any closure type.\n-                    //\n-                    // FIXME(#3320) this should go away and be\n-                    // replaced with proper inference, got a patch\n-                    // underway - ndm\n-                    self.coerce_from_bare_fn(a, a_f, b)\n+                ty::ty_bare_fn(Some(a_def_id), ref a_f) => {\n+                    // Function items are coercible to any closure\n+                    // type; function pointers are not (that would\n+                    // require double indirection).\n+                    self.coerce_from_fn_item(a, a_def_id, a_f, b)\n                 }\n                 _ => {\n                     // Otherwise, just use subtyping rules.\n@@ -206,8 +208,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                    mutbl_b: ast::Mutability)\n                                    -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -227,7 +229,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         };\n \n-        let a_borrowed = ty::mk_rptr(self.get_ref().infcx.tcx,\n+        let a_borrowed = ty::mk_rptr(self.tcx(),\n                                      r_borrow,\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n         try!(sub.tys(a_borrowed, b));\n@@ -247,8 +249,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                       b: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsized(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n         // a DST unless we have to. This currently comes out in the wash since\n@@ -268,7 +270,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                             let coercion = Coercion(self.get_ref().trace.clone());\n                             let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n-                            let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n+                            let ty = ty::mk_rptr(self.tcx(),\n                                                  r_borrow,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n@@ -292,7 +294,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 return Err(ty::terr_mutability);\n                             }\n \n-                            let ty = ty::mk_ptr(self.get_ref().infcx.tcx,\n+                            let ty = ty::mk_ptr(self.tcx(),\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n@@ -311,7 +313,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 self.unpack_actual_value(t_a, |a| {\n                     match self.unsize_ty(t_a, a, t_b) {\n                         Some((ty, kind)) => {\n-                            let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n+                            let ty = ty::mk_uniq(self.tcx(), ty);\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({}))\", kind);\n@@ -336,9 +338,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                  a: Ty<'tcx>,\n                  ty_b: Ty<'tcx>)\n                  -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n-        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.get_ref().infcx.tcx));\n+        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.tcx()));\n \n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         self.unpack_actual_value(ty_b, |b|\n             match (&a.sty, &b.sty) {\n@@ -412,7 +414,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                               b: Ty<'tcx>,\n                               b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={})\",\n                a.repr(tcx),\n@@ -431,7 +433,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             b: Ty<'tcx>,\n                             b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={})\",\n                a.repr(tcx),\n@@ -451,7 +453,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n         G: FnOnce() -> ty::AutoRef<'tcx>,\n     {\n-        let tcx = self.get_ref().infcx.tcx;\n+        let tcx = self.tcx();\n \n         match a.sty {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n@@ -480,45 +482,59 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                               b: Ty<'tcx>)\n                               -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_fn(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         match a.sty {\n-            ty::ty_bare_fn(ref f) => {\n-                self.coerce_from_bare_fn(a, f, b)\n+            ty::ty_bare_fn(Some(a_def_id), ref f) => {\n+                self.coerce_from_fn_item(a, a_def_id, f, b)\n             }\n             _ => {\n                 self.subtype(a, b)\n             }\n         }\n     }\n \n-    ///  Attempts to coerce from a bare Rust function (`extern \"Rust\" fn`) into a closure or a\n-    ///  `proc`.\n-    fn coerce_from_bare_fn(&self, a: Ty<'tcx>, fn_ty_a: &ty::BareFnTy<'tcx>, b: Ty<'tcx>)\n+    fn coerce_from_fn_item(&self,\n+                           a: Ty<'tcx>,\n+                           fn_def_id_a: ast::DefId,\n+                           fn_ty_a: &ty::BareFnTy<'tcx>,\n+                           b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n+        /*!\n+         * Attempts to coerce from the type of a Rust function item\n+         * into a closure or a `proc`.\n+         */\n+\n         self.unpack_actual_value(b, |b| {\n+            debug!(\"coerce_from_fn_item(a={}, b={})\",\n+                   a.repr(self.tcx()), b.repr(self.tcx()));\n \n-            debug!(\"coerce_from_bare_fn(a={}, b={})\",\n-                   a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n+            match b.sty {\n+                ty::ty_closure(ref f) => {\n+                    if fn_ty_a.abi != abi::Rust || fn_ty_a.unsafety != ast::Unsafety::Normal {\n+                        return self.subtype(a, b);\n+                    }\n \n-            if fn_ty_a.abi != abi::Rust || fn_ty_a.unsafety != ast::Unsafety::Normal {\n-                return self.subtype(a, b);\n+                    let fn_ty_b = (*f).clone();\n+                    let adj = ty::AdjustAddEnv(fn_def_id_a, fn_ty_b.store);\n+                    let a_closure = ty::mk_closure(self.tcx(),\n+                                                   ty::ClosureTy {\n+                                                       sig: fn_ty_a.sig.clone(),\n+                                                       .. *fn_ty_b\n+                                                   });\n+                    try!(self.subtype(a_closure, b));\n+                    Ok(Some(adj))\n+                }\n+                ty::ty_bare_fn(None, _) => {\n+                    let a_fn_pointer = ty::mk_bare_fn(self.tcx(), None, (*fn_ty_a).clone());\n+                    try!(self.subtype(a_fn_pointer, b));\n+                    Ok(Some(ty::AdjustReifyFnPointer(fn_def_id_a)))\n+                }\n+                _ => {\n+                    return self.subtype(a, b)\n+                }\n             }\n-\n-            let fn_ty_b = match b.sty {\n-                ty::ty_closure(ref f) => (*f).clone(),\n-                _ => return self.subtype(a, b)\n-            };\n-\n-            let adj = ty::AdjustAddEnv(fn_ty_b.store);\n-            let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n-                                           ty::ClosureTy {\n-                                                sig: fn_ty_a.sig.clone(),\n-                                                .. *fn_ty_b\n-                                           });\n-            try!(self.subtype(a_closure, b));\n-            Ok(Some(adj))\n         })\n     }\n \n@@ -528,8 +544,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                              mutbl_b: ast::Mutability)\n                              -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx),\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         let mt_a = match a.sty {\n             ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => mt,\n@@ -539,7 +555,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n \n         // Check that the types which they point at are compatible.\n-        let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n+        let a_unsafe = ty::mk_ptr(self.tcx(), ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n         try!(self.subtype(a_unsafe, b));\n         if !can_coerce_mutbls(mt_a.mutbl, mutbl_b) {\n             return Err(ty::terr_mutability);"}, {"sha": "14687b8fd75c61ef645743eae55ac8f9e74a18e8", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -568,11 +568,12 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n         }\n       }\n \n-      (&ty::ty_bare_fn(ref a_fty), &ty::ty_bare_fn(ref b_fty)) => {\n-        this.bare_fn_tys(a_fty, b_fty).and_then(|fty| {\n-            Ok(ty::mk_bare_fn(tcx, fty))\n-        })\n-      }\n+        (&ty::ty_bare_fn(a_opt_def_id, ref a_fty), &ty::ty_bare_fn(b_opt_def_id, ref b_fty))\n+            if a_opt_def_id == b_opt_def_id =>\n+        {\n+            let fty = try!(this.bare_fn_tys(a_fty, b_fty));\n+            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, fty))\n+        }\n \n       (&ty::ty_closure(ref a_fty), &ty::ty_closure(ref b_fty)) => {\n         this.closure_tys(&**a_fty, &**b_fty).and_then(|fty| {"}, {"sha": "6acbc98b4b27b651ec4f2bb04eb4aea44f381d9a", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -74,7 +74,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match ty::lookup_item_type(self.tcx, def_id).ty.sty {\n-            ty::ty_bare_fn(ref bfty) => bfty.abi == RustIntrinsic,\n+            ty::ty_bare_fn(_, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n         if def_id.krate == ast::LOCAL_CRATE {\n@@ -123,7 +123,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                 DefFn(did, _) if self.def_id_is_transmute(did) => {\n                     let typ = ty::node_id_to_type(self.tcx, expr.id);\n                     match typ.sty {\n-                        ty_bare_fn(ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n+                        ty_bare_fn(_, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n                                 let from = bare_fn_ty.sig.0.inputs[0];\n                                 self.check_transmute(expr.span, from, to, expr.id);"}, {"sha": "006515ea0a051cd506dbe59a186a3b5fbccb1e65", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -441,8 +441,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AdjustAddEnv(..) => {\n-                        debug!(\"cat_expr(AdjustAddEnv): {}\",\n+                    ty::AdjustAddEnv(..) | ty::AdjustReifyFnPointer(..) => {\n+                        debug!(\"cat_expr(AdjustAddEnv|AdjustReifyFnPointer): {}\",\n                                expr.repr(self.tcx()));\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue."}, {"sha": "f849f4c9b937ef247db7b096c2420ec4c66cc288", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -795,7 +795,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::ty_bare_fn(ty::BareFnTy {\n+            ty::ty_bare_fn(_, ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -984,7 +984,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_int(_) |\n             ty::ty_bool |\n             ty::ty_float(_) |\n-            ty::ty_bare_fn(_) |\n+            ty::ty_bare_fn(..) |\n             ty::ty_char => {\n                 // safe for everything\n                 Ok(If(Vec::new()))\n@@ -1543,7 +1543,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         let sig = match self_ty.sty {\n-            ty::ty_bare_fn(ty::BareFnTy {\n+            ty::ty_bare_fn(_, ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 ref sig"}, {"sha": "22fdea8afb59bbcace7efc92f52bb19c1e9f1d4f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 63, "deletions": 21, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -293,7 +293,8 @@ pub enum Variance {\n \n #[deriving(Clone, Show)]\n pub enum AutoAdjustment<'tcx> {\n-    AdjustAddEnv(ty::TraitStore),\n+    AdjustAddEnv(ast::DefId, ty::TraitStore),\n+    AdjustReifyFnPointer(ast::DefId), // go from a fn-item type to a fn-pointer type\n     AdjustDerefRef(AutoDerefRef<'tcx>)\n }\n \n@@ -1245,11 +1246,17 @@ pub enum sty<'tcx> {\n     ty_vec(Ty<'tcx>, Option<uint>), // Second field is length.\n     ty_ptr(mt<'tcx>),\n     ty_rptr(Region, mt<'tcx>),\n-    ty_bare_fn(BareFnTy<'tcx>),\n+\n+    // If the def-id is Some(_), then this is the type of a specific\n+    // fn item. Otherwise, if None(_), it a fn pointer type.\n+    ty_bare_fn(Option<DefId>, BareFnTy<'tcx>),\n+\n     ty_closure(Box<ClosureTy<'tcx>>),\n     ty_trait(Box<TyTrait<'tcx>>),\n     ty_struct(DefId, Substs<'tcx>),\n+\n     ty_unboxed_closure(DefId, Region, Substs<'tcx>),\n+\n     ty_tup(Vec<Ty<'tcx>>),\n \n     ty_param(ParamTy), // type parameter\n@@ -2181,7 +2188,7 @@ impl FlagComputation {\n                 self.add_tys(ts[]);\n             }\n \n-            &ty_bare_fn(ref f) => {\n+            &ty_bare_fn(_, ref f) => {\n                 self.add_fn_sig(&f.sig);\n             }\n \n@@ -2342,15 +2349,19 @@ pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, fty: ClosureTy<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_closure(box fty))\n }\n \n-pub fn mk_bare_fn<'tcx>(cx: &ctxt<'tcx>, fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, ty_bare_fn(fty))\n+pub fn mk_bare_fn<'tcx>(cx: &ctxt<'tcx>,\n+                        opt_def_id: Option<ast::DefId>,\n+                        fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n+    mk_t(cx, ty_bare_fn(opt_def_id, fty))\n }\n \n pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n+                        def_id: ast::DefId,\n                         input_tys: &[Ty<'tcx>],\n                         output: Ty<'tcx>) -> Ty<'tcx> {\n     let input_args = input_tys.iter().map(|ty| *ty).collect();\n     mk_bare_fn(cx,\n+               Some(def_id),\n                BareFnTy {\n                    unsafety: ast::Unsafety::Normal,\n                    abi: abi::Rust,\n@@ -2449,7 +2460,7 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n             }\n         }\n         ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n-        ty_bare_fn(ref ft) => {\n+        ty_bare_fn(_, ref ft) => {\n             for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n             if let ty::FnConverging(output) = ft.sig.0.output {\n                 maybe_walk_ty(output, f);\n@@ -2932,7 +2943,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             // Scalar and unique types are sendable, and durable\n             ty_infer(ty::FreshIntTy(_)) |\n             ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-            ty_bare_fn(_) | ty::ty_char => {\n+            ty_bare_fn(..) | ty::ty_char => {\n                 TC::None\n             }\n \n@@ -3267,7 +3278,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_uint(_) |\n             ty_float(_) |\n             ty_str |\n-            ty_bare_fn(_) |\n+            ty_bare_fn(..) |\n             ty_closure(_) |\n             ty_infer(_) |\n             ty_err |\n@@ -3563,6 +3574,13 @@ pub fn type_is_bare_fn(ty: Ty) -> bool {\n     }\n }\n \n+pub fn type_is_bare_fn_item(ty: Ty) -> bool {\n+    match ty.sty {\n+        ty_bare_fn(Some(_), _) => true,\n+        _ => false\n+    }\n+}\n+\n pub fn type_is_fp(ty: Ty) -> bool {\n     match ty.sty {\n       ty_infer(FloatVar(_)) | ty_float(_) => true,\n@@ -3795,7 +3813,7 @@ pub fn node_id_item_substs<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> ItemSubsts\n \n pub fn fn_is_variadic(fty: Ty) -> bool {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.sig.0.variadic,\n+        ty_bare_fn(_, ref f) => f.sig.0.variadic,\n         ty_closure(ref f) => f.sig.0.variadic,\n         ref s => {\n             panic!(\"fn_is_variadic() called on non-fn type: {}\", s)\n@@ -3805,7 +3823,7 @@ pub fn fn_is_variadic(fty: Ty) -> bool {\n \n pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n     match fty.sty {\n-        ty_bare_fn(ref f) => &f.sig,\n+        ty_bare_fn(_, ref f) => &f.sig,\n         ty_closure(ref f) => &f.sig,\n         ref s => {\n             panic!(\"ty_fn_sig() called on non-fn type: {}\", s)\n@@ -3816,7 +3834,7 @@ pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n /// Returns the ABI of the given function.\n pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.abi,\n+        ty_bare_fn(_, ref f) => f.abi,\n         ty_closure(ref f) => f.abi,\n         _ => panic!(\"ty_fn_abi() called on non-fn type\"),\n     }\n@@ -3843,7 +3861,7 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n \n pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.sig.0.output,\n+        ty_bare_fn(_, ref f) => f.sig.0.output,\n         ty_closure(ref f) => f.sig.0.output,\n         ref s => {\n             panic!(\"ty_fn_ret() called on non-fn type: {}\", s)\n@@ -3853,7 +3871,7 @@ pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n \n pub fn is_fn_ty(fty: Ty) -> bool {\n     match fty.sty {\n-        ty_bare_fn(_) => true,\n+        ty_bare_fn(..) => true,\n         ty_closure(_) => true,\n         _ => false\n     }\n@@ -3978,9 +3996,9 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n     return match adjustment {\n         Some(adjustment) => {\n             match *adjustment {\n-                AdjustAddEnv(store) => {\n+                AdjustAddEnv(_, store) => {\n                     match unadjusted_ty.sty {\n-                        ty::ty_bare_fn(ref b) => {\n+                        ty::ty_bare_fn(Some(_), ref b) => {\n                             let bounds = ty::ExistentialBounds {\n                                 region_bound: ReStatic,\n                                 builtin_bounds: all_builtin_bounds(),\n@@ -3997,7 +4015,21 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                         }\n                         ref b => {\n                             cx.sess.bug(\n-                                format!(\"add_env adjustment on non-bare-fn: \\\n+                                format!(\"add_env adjustment on non-fn-item: \\\n+                                         {}\",\n+                                        b).as_slice());\n+                        }\n+                    }\n+                }\n+\n+                AdjustReifyFnPointer(_) => {\n+                    match unadjusted_ty.sty {\n+                        ty::ty_bare_fn(Some(_), ref b) => {\n+                            ty::mk_bare_fn(cx, None, (*b).clone())\n+                        }\n+                        ref b => {\n+                            cx.sess.bug(\n+                                format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n                                          {}\",\n                                         b)[]);\n                         }\n@@ -4356,7 +4388,8 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_vec(_, None) => \"slice\".to_string(),\n         ty_ptr(_) => \"*-ptr\".to_string(),\n         ty_rptr(_, _) => \"&-ptr\".to_string(),\n-        ty_bare_fn(_) => \"extern fn\".to_string(),\n+        ty_bare_fn(Some(_), _) => format!(\"fn item\"),\n+        ty_bare_fn(None, _) => \"fn pointer\".to_string(),\n         ty_closure(_) => \"fn\".to_string(),\n         ty_trait(ref inner) => {\n             format!(\"trait {}\", item_path_str(cx, inner.principal.def_id()))\n@@ -4547,6 +4580,10 @@ pub fn note_and_explain_type_err(cx: &ctxt, err: &type_err) {\n                                     \"concrete lifetime that was found is \",\n                                     conc_region, \"\");\n         }\n+        terr_regions_overly_polymorphic(_, ty::ReInfer(ty::ReVar(_))) => {\n+            // don't bother to print out the message below for\n+            // inference variables, it's not very illuminating.\n+        }\n         terr_regions_overly_polymorphic(_, conc_region) => {\n             note_and_explain_region(cx,\n                                     \"expected concrete lifetime is \",\n@@ -5887,8 +5924,9 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     region(state, r);\n                     mt(state, m);\n                 }\n-                ty_bare_fn(ref b) => {\n+                ty_bare_fn(opt_def_id, ref b) => {\n                     byte!(14);\n+                    hash!(opt_def_id);\n                     hash!(b.unsafety);\n                     hash!(b.abi);\n                     fn_sig(state, &b.sig);\n@@ -6203,7 +6241,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_str |\n             ty_vec(_, _) |\n             ty_ptr(_) |\n-            ty_bare_fn(_) |\n+            ty_bare_fn(..) |\n             ty_tup(_) |\n             ty_param(_) |\n             ty_infer(_) |\n@@ -6255,6 +6293,7 @@ impl<'tcx> AutoAdjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n         match *self {\n             AdjustAddEnv(..) => false,\n+            AdjustReifyFnPointer(..) => false,\n             AdjustDerefRef(ref r) => r.is_identity(),\n         }\n     }\n@@ -6370,8 +6409,11 @@ impl DebruijnIndex {\n impl<'tcx> Repr<'tcx> for AutoAdjustment<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n-            AdjustAddEnv(ref trait_store) => {\n-                format!(\"AdjustAddEnv({})\", trait_store)\n+            AdjustAddEnv(def_id, ref trait_store) => {\n+                format!(\"AdjustAddEnv({},{})\", def_id.repr(tcx), trait_store)\n+            }\n+            AdjustReifyFnPointer(def_id) => {\n+                format!(\"AdjustAddEnv({})\", def_id.repr(tcx))\n             }\n             AdjustDerefRef(ref data) => {\n                 data.repr(tcx)"}, {"sha": "a35ea30b217913ac4e789ef1062620250570b66f", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -538,8 +538,8 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         ty::ty_tup(ref ts) => {\n             ty::ty_tup(ts.fold_with(this))\n         }\n-        ty::ty_bare_fn(ref f) => {\n-            ty::ty_bare_fn(f.fold_with(this))\n+        ty::ty_bare_fn(opt_def_id, ref f) => {\n+            ty::ty_bare_fn(opt_def_id, f.fold_with(this))\n         }\n         ty::ty_closure(ref f) => {\n             ty::ty_closure(box f.fold_with(this))"}, {"sha": "a02004e6d18a3a2aa673322d5e3bcd1ade3269ef", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -254,12 +254,14 @@ pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n \n pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n     fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                               opt_def_id: Option<ast::DefId>,\n                                unsafety: ast::Unsafety,\n                                abi: abi::Abi,\n                                ident: Option<ast::Ident>,\n                                sig: &ty::PolyFnSig<'tcx>)\n                                -> String {\n         let mut s = String::new();\n+\n         match unsafety {\n             ast::Unsafety::Normal => {}\n             ast::Unsafety::Unsafe => {\n@@ -284,6 +286,16 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n \n         push_sig_to_string(cx, &mut s, '(', ')', sig, \"\");\n \n+        match opt_def_id {\n+            Some(def_id) => {\n+                s.push_str(\" {\");\n+                let path_str = ty::item_path_str(cx, def_id);\n+                s.push_str(path_str[]);\n+                s.push_str(\"}\");\n+            }\n+            None => { }\n+        }\n+\n         s\n     }\n \n@@ -408,8 +420,8 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         ty_closure(ref f) => {\n             closure_to_string(cx, &**f)\n         }\n-        ty_bare_fn(ref f) => {\n-            bare_fn_to_string(cx, f.unsafety, f.abi, None, &f.sig)\n+        ty_bare_fn(opt_def_id, ref f) => {\n+            bare_fn_to_string(cx, opt_def_id, f.unsafety, f.abi, None, &f.sig)\n         }\n         ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n         ty_err => \"[type error]\".to_string(),"}, {"sha": "526bbca8d70ddb0a34812bce2b87868bf2fd4960", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -253,7 +253,18 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                 output_ty: Ty<'tcx>)\n                 -> Ty<'tcx>\n     {\n-        ty::mk_ctor_fn(self.infcx.tcx, input_tys, output_ty)\n+        let input_args = input_tys.iter().map(|ty| *ty).collect();\n+        ty::mk_bare_fn(self.infcx.tcx,\n+                       None,\n+                       ty::BareFnTy {\n+                           unsafety: ast::Unsafety::Normal,\n+                           abi: abi::Rust,\n+                           sig: ty::Binder(ty::FnSig {\n+                               inputs: input_args,\n+                               output: ty::FnConverging(output_ty),\n+                               variadic: false\n+                           })\n+                       })\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {"}, {"sha": "f49fc7f06c5014a2b5e656af9da9d5fdddcd1770", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -282,7 +282,7 @@ pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let (inputs, output, abi, env) = match fn_ty.sty {\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n             (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, None)\n         }\n         ty::ty_closure(ref f) => {\n@@ -542,6 +542,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n         let dtor_ty = ty::mk_ctor_fn(ccx.tcx(),\n+                                     did,\n                                      &[glue::get_drop_glue_type(ccx, t)],\n                                      ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n@@ -955,7 +956,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      did: ast::DefId, t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match t.sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n                     get_extern_rust_fn(ccx, t, name[], did)\n@@ -2014,7 +2015,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.0.output.unwrap(),\n+        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output.unwrap(),\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n@@ -2086,7 +2087,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n     let ctor_ty = ctor_ty.subst(ccx.tcx(), param_substs);\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.0.output,\n+        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n@@ -2421,7 +2422,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                          node_type: Ty<'tcx>)\n                          -> ValueRef {\n     match node_type.sty {\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n             assert!(f.abi == Rust || f.abi == RustCall);\n         }\n         _ => panic!(\"expected bare rust fn\")\n@@ -2438,7 +2439,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n \n     let (fn_sig, abi, has_env) = match fn_ty.sty {\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n-        ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n+        ty::ty_bare_fn(_, ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let ref function_type = (*unboxed_closures)[closure_did]\n@@ -2467,7 +2468,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n-        ty::ty_bare_fn(_) if abi == RustCall => {\n+        ty::ty_bare_fn(..) if abi == RustCall => {\n             let mut inputs = vec![fn_sig.0.inputs[0]];\n \n             match fn_sig.0.inputs[1].sty {"}, {"sha": "ab25343ff5fe0c46e4832c70fe7cf641eb11ba3f", "filename": "src/librustc_trans/trans/basic_block.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -37,7 +37,10 @@ impl BasicBlock {\n \n     pub fn pred_iter(self) -> Preds {\n         fn is_a_terminator_inst(user: &Value) -> bool { user.is_a_terminator_inst() }\n+        let is_a_terminator_inst: fn(&Value) -> bool = is_a_terminator_inst;\n+\n         fn get_parent(user: Value) -> BasicBlock { user.get_parent().unwrap() }\n+        let get_parent: fn(Value) -> BasicBlock = get_parent;\n \n         self.as_value().user_iter()\n             .filter(is_a_terminator_inst)"}, {"sha": "7f22faf050da04e98350e2e12fc98226c048d7da", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -21,7 +21,8 @@ pub use self::CallArgs::*;\n use arena::TypedArena;\n use back::{abi,link};\n use session;\n-use llvm::{ValueRef, get_param};\n+use llvm::{ValueRef};\n+use llvm::get_param;\n use llvm;\n use metadata::csearch;\n use middle::def;\n@@ -158,7 +159,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefFn(did, _) if match expr_ty.sty {\n-                ty::ty_bare_fn(ref f) => f.abi == synabi::RustIntrinsic,\n+                ty::ty_bare_fn(_, ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n             } => {\n                 let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n@@ -275,15 +276,16 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let (input_tys, output_ty) =\n+    let (opt_def_id, input_tys, output_ty) =\n         match bare_fn_ty.sty {\n-            ty::ty_bare_fn(ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n+            ty::ty_bare_fn(opt_def_id,\n+                           ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                           abi: synabi::Rust,\n                                           sig: ty::Binder(ty::FnSig { inputs: ref input_tys,\n                                                                       output: output_ty,\n                                                                       variadic: false })}) =>\n             {\n-                (input_tys, output_ty)\n+                (opt_def_id, input_tys, output_ty)\n             }\n \n             _ => {\n@@ -293,6 +295,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         };\n     let tuple_input_ty = ty::mk_tup(tcx, input_tys.to_vec());\n     let tuple_fn_ty = ty::mk_bare_fn(tcx,\n+                                     opt_def_id,\n                                      ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                                     abi: synabi::RustCall,\n                                                     sig: ty::Binder(ty::FnSig {\n@@ -655,7 +658,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) => (f.abi, f.sig.0.output),\n+        ty::ty_bare_fn(_, ref f) => (f.abi, f.sig.0.output),\n         ty::ty_closure(ref f) => (f.abi, f.sig.0.output),\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n     };"}, {"sha": "28716f0a48195c5b75fb141a31ed6c6e8cfdf8dd", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -13,7 +13,6 @@ pub use self::ClosureKind::*;\n use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n use llvm::ValueRef;\n-use middle::def;\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n@@ -603,7 +602,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n \n pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                          closure_ty: Ty<'tcx>,\n-                                         def: def::Def,\n+                                         def_id: ast::DefId,\n                                          fn_ptr: ValueRef,\n                                          is_local: bool) -> ValueRef {\n \n@@ -697,11 +696,11 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn make_closure_from_bare_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                              closure_ty: Ty<'tcx>,\n-                                             def: def::Def,\n+                                             def_id: ast::DefId,\n                                              fn_ptr: ValueRef)\n                                              -> DatumBlock<'blk, 'tcx, Expr>  {\n     let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");\n-    let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def, fn_ptr, true);\n+    let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def_id, fn_ptr, true);\n     fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p(bcx.ccx())));\n \n     DatumBlock::new(bcx, scratch.to_expr_datum())"}, {"sha": "bc386dc96a469230182c48529ba28b7307229158", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -190,21 +190,24 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n         None => { }\n         Some(adj) => {\n             match adj {\n-                ty::AdjustAddEnv(ty::RegionTraitStore(ty::ReStatic, _)) => {\n-                    let def = ty::resolve_expr(cx.tcx(), e);\n+                ty::AdjustAddEnv(def_id, ty::RegionTraitStore(ty::ReStatic, _)) => {\n                     let wrapper = closure::get_wrapper_for_bare_fn(cx,\n                                                                    ety_adjusted,\n-                                                                   def,\n+                                                                   def_id,\n                                                                    llconst,\n                                                                    true);\n                     llconst = C_struct(cx, &[wrapper, C_null(Type::i8p(cx))], false)\n                 }\n-                ty::AdjustAddEnv(store) => {\n+                ty::AdjustAddEnv(_, store) => {\n                     cx.sess()\n                       .span_bug(e.span,\n                                 format!(\"unexpected static function: {}\",\n                                         store)[])\n                 }\n+                ty::AdjustReifyFnPointer(_def_id) => {\n+                    // FIXME(#19925) once fn item types are\n+                    // zero-sized, we'll need to do something here\n+                }\n                 ty::AdjustDerefRef(ref adj) => {\n                     let mut ty = ety;\n                     // Save the last autoderef in case we can avoid it."}, {"sha": "adad2d5013212fdd532949370a849f2a7ae53dca", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -430,7 +430,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        trait_data.principal.substs(),\n                                        &mut unique_type_id);\n             },\n-            ty::ty_bare_fn(ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            ty::ty_bare_fn(_, ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n                 if unsafety == ast::Unsafety::Unsafe {\n                     unique_type_id.push_str(\"unsafe \");\n                 }\n@@ -2997,7 +2997,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ty::ty_bare_fn(ref barefnty) => {\n+        ty::ty_bare_fn(_, ref barefnty) => {\n             subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n         ty::ty_closure(ref closurety) => {\n@@ -3814,7 +3814,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             push_item_name(cx, trait_data.principal.def_id(), false, output);\n             push_type_params(cx, trait_data.principal.substs(), output);\n         },\n-        ty::ty_bare_fn(ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+        ty::ty_bare_fn(_, ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }"}, {"sha": "3388a7623e315e12f0e3671fc5044279dc013e52", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -54,7 +54,7 @@ use trans::inline;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{struct_fields, tup_fields};\n-use middle::ty::{AdjustDerefRef, AdjustAddEnv, AutoUnsafe};\n+use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustAddEnv, AutoUnsafe};\n use middle::ty::{AutoPtr};\n use middle::ty::{mod, Ty};\n use middle::ty::MethodCall;\n@@ -177,8 +177,12 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            datum.to_string(bcx.ccx()),\n            adjustment.repr(bcx.tcx()));\n     match adjustment {\n-        AdjustAddEnv(..) => {\n-            datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n+        AdjustAddEnv(def_id, _) => {\n+            datum = unpack_datum!(bcx, add_env(bcx, def_id, expr, datum));\n+        }\n+        AdjustReifyFnPointer(_def_id) => {\n+            // FIXME(#19925) once fn item types are\n+            // zero-sized, we'll need to do something here\n         }\n         AdjustDerefRef(ref adj) => {\n             let (autoderefs, use_autoref) = match adj.autoref {\n@@ -466,6 +470,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     fn add_env<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           def_id: ast::DefId,\n                            expr: &ast::Expr,\n                            datum: Datum<'tcx, Expr>)\n                            -> DatumBlock<'blk, 'tcx, Expr> {\n@@ -477,8 +482,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let closure_ty = expr_ty_adjusted(bcx, expr);\n         let fn_ptr = datum.to_llscalarish(bcx);\n-        let def = ty::resolve_expr(bcx.tcx(), expr);\n-        closure::make_closure_from_bare_fn(bcx, closure_ty, def, fn_ptr)\n+        closure::make_closure_from_bare_fn(bcx, closure_ty, def_id, fn_ptr)\n     }\n }\n "}, {"sha": "1bad476863fdb6fdec5c65ddd916f5f7cc049bd0", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -228,7 +228,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            ccx.tn().val_to_string(llretptr));\n \n     let (fn_abi, fn_sig) = match callee_ty.sty {\n-        ty::ty_bare_fn(ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n+        ty::ty_bare_fn(_, ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys[]);\n@@ -479,7 +479,7 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tys = foreign_types_for_fn_ty(ccx, t);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let cconv = match t.sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(_, ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n@@ -502,7 +502,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let t = ty::node_id_to_type(ccx.tcx(), node_id);\n     let cconv = match t.sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(_, ref fn_ty) => {\n             llvm_calling_convention(ccx, fn_ty.abi)\n         }\n         _ => panic!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n@@ -556,7 +556,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn.\n         match t.sty {\n-            ty::ty_bare_fn(ref f) => {\n+            ty::ty_bare_fn(_, ref f) => {\n                 assert!(f.abi != Rust && f.abi != RustIntrinsic);\n             }\n             _ => {\n@@ -849,7 +849,7 @@ fn foreign_types_for_id<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n     let fn_sig = match ty.sty {\n-        ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n+        ty::ty_bare_fn(_, ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, fn_sig.0.inputs.as_slice());"}, {"sha": "26734d854afc036f1a1d9ec9cff5048208233eac", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -226,7 +226,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n     let self_ty = match fty.sty {\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n             assert!(f.sig.0.inputs.len() == 1);\n             f.sig.0.inputs[0]\n         }\n@@ -289,6 +289,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         let dtor_ty = ty::mk_ctor_fn(bcx.tcx(),\n+                                     class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n         let (_, variant_cx) = invoke(variant_cx, dtor_addr, args[], dtor_ty, None, false);"}, {"sha": "fff89999d99b58cb599ad334ea0fbff7a6a0a26e", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -150,7 +150,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n \n     let ret_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) => f.sig.0.output,\n+        ty::ty_bare_fn(_, ref f) => f.sig.0.output,\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);"}, {"sha": "38c6b802d0485f4205b73ab265b9af581464aee5", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -477,7 +477,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"(translating trait callee) loading method\");\n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) if f.abi == Rust || f.abi == RustCall => {\n+        ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n             type_of_rust_fn(ccx,\n                             Some(Type::i8p(ccx)),\n                             f.sig.0.inputs.slice_from(1),\n@@ -639,7 +639,8 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                        m.repr(tcx),\n                        substs.repr(tcx));\n                 if m.generics.has_type_params(subst::FnSpace) ||\n-                   ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n+                    ty::type_has_self(ty::mk_bare_fn(tcx, None, m.fty.clone()))\n+                {\n                     debug!(\"(making impl vtable) method has self or type \\\n                             params: {}\",\n                            token::get_name(name));"}, {"sha": "499195b51b9cea434f62de0288269d166d17b864", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -150,7 +150,9 @@ pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>)\n                             f.sig.0.output,\n                             f.abi)\n         }\n-        ty::ty_bare_fn(ref f) => {\n+        ty::ty_bare_fn(_, ref f) => {\n+            // FIXME(#19925) once fn item types are\n+            // zero-sized, we'll need to do something here\n             if f.abi == abi::Rust || f.abi == abi::RustCall {\n                 type_of_rust_fn(cx,\n                                 None,\n@@ -364,7 +366,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n \n       ty::ty_str => Type::i8(cx),\n \n-      ty::ty_bare_fn(_) => {\n+      ty::ty_bare_fn(..) => {\n           type_of_fn_from_ty(cx, t).ptr_to()\n       }\n       ty::ty_closure(_) => {"}, {"sha": "ff577d2d45d4bdf001e32a4a46aaed8d31645dbd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -954,7 +954,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     tcx.sess.span_err(ast_ty.span,\n                                       \"variadic function must have C calling convention\");\n                 }\n-                ty::mk_bare_fn(tcx, ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl))\n+                ty::mk_bare_fn(tcx, None, ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl))\n             }\n             ast::TyClosure(ref f) => {\n                 // Use corresponding trait store to figure out default bounds"}, {"sha": "d3b518ec2e3ab5489965686c268a1611a9f37370", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -113,7 +113,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.add_obligations(&pick, &method_bounds_substs, &method_bounds);\n \n         // Create the final `MethodCallee`.\n-        let fty = ty::mk_bare_fn(self.tcx(), ty::BareFnTy {\n+        let fty = ty::mk_bare_fn(self.tcx(), None, ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: pick.method_ty.fty.unsafety,\n             abi: pick.method_ty.fty.abi.clone(),\n@@ -466,7 +466,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn fixup_derefs_on_method_receiver_if_necessary(&self,\n                                                     method_callee: &MethodCallee) {\n         let sig = match method_callee.ty.sty {\n-            ty::ty_bare_fn(ref f) => f.sig.clone(),\n+            ty::ty_bare_fn(_, ref f) => f.sig.clone(),\n             ty::ty_closure(ref f) => f.sig.clone(),\n             _ => return,\n         };"}, {"sha": "19776318c876d712f84587b19dc047cd3f4d5f0e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -199,7 +199,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                                                        infer::FnCall,\n                                                                        &fn_sig).0;\n     let transformed_self_ty = fn_sig.inputs[0];\n-    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+    let fty = ty::mk_bare_fn(tcx, None, ty::BareFnTy {\n         sig: ty::Binder(fn_sig),\n         unsafety: bare_fn_ty.unsafety,\n         abi: bare_fn_ty.abi.clone(),"}, {"sha": "3139a17f9989eacf022405208c52e303a1742e55", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -399,7 +399,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n \n     match fty.sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n             let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_ty.sig,\n                                decl, id, body, &inh);\n@@ -1132,9 +1132,9 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     // Compute skolemized form of impl and trait method tys.\n-    let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n+    let impl_fty = ty::mk_bare_fn(tcx, None, impl_m.fty.clone());\n     let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n-    let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n+    let trait_fty = ty::mk_bare_fn(tcx, None, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n     // Check the impl method type IM is a subtype of the trait method\n@@ -1389,14 +1389,18 @@ fn check_cast(fcx: &FnCtxt,\n         }, t_e, None);\n     }\n \n+    let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n+\n     let t_1_is_scalar = ty::type_is_scalar(t_1);\n     let t_1_is_char = ty::type_is_char(t_1);\n     let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n     let t_1_is_float = ty::type_is_floating_point(t_1);\n \n     // casts to scalars other than `char` and `bare fn` are trivial\n     let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n-    if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n+    if t_e_is_bare_fn_item && t_1_is_bare_fn {\n+        demand::coerce(fcx, e.span, t_1, &*e);\n+    } else if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n         if t_1_is_float || ty::type_is_unsafe_ptr(t_1) {\n             fcx.type_error_message(span, |actual| {\n                 format!(\"illegal cast; cast through an \\\n@@ -1634,7 +1638,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                        span: Span,\n                                        adj: &ty::AutoAdjustment<'tcx>) {\n         match *adj {\n-            ty::AdjustAddEnv(..) => { }\n+            ty::AdjustAddEnv(..) |\n+            ty::AdjustReifyFnPointer(..) => {\n+            }\n             ty::AdjustDerefRef(ref d_r) => {\n                 match d_r.autoref {\n                     Some(ref a_r) => {\n@@ -2043,7 +2049,7 @@ fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n     match structurally_resolved_type(fcx, callee.span, callee_type).sty {\n-        ty::ty_bare_fn(_) | ty::ty_closure(_) => return false,\n+        ty::ty_bare_fn(..) | ty::ty_closure(_) => return false,\n         _ => {}\n     }\n \n@@ -2493,7 +2499,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ty::FnConverging(ty::mk_err())\n     } else {\n         match method_fn_ty.sty {\n-            ty::ty_bare_fn(ref fty) => {\n+            ty::ty_bare_fn(_, ref fty) => {\n                 // HACK(eddyb) ignore self in the definition (see above).\n                 check_argument_types(fcx,\n                                      sp,\n@@ -2921,7 +2927,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         });\n \n         let fn_sig = match fn_ty.sty {\n-            ty::ty_bare_fn(ty::BareFnTy {ref sig, ..}) |\n+            ty::ty_bare_fn(_, ty::BareFnTy {ref sig, ..}) |\n             ty::ty_closure(box ty::ClosureTy {ref sig, ..}) => sig,\n             _ => {\n                 fcx.type_error_message(call_expr.span, |actual| {\n@@ -3875,7 +3881,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         let lhs_ty = fcx.expr_ty(&**lhs);\n-        check_expr_has_type(fcx, &**rhs, lhs_ty);\n+        check_expr_coercable_to_type(fcx, &**rhs, lhs_ty);\n         let rhs_ty = fcx.expr_ty(&**rhs);\n \n         fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n@@ -5641,7 +5647,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n     };\n-    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+    let fty = ty::mk_bare_fn(tcx, None, ty::BareFnTy {\n         unsafety: ast::Unsafety::Unsafe,\n         abi: abi::RustIntrinsic,\n         sig: ty::Binder(FnSig {"}, {"sha": "a2fb44fff796fa5573594115888e5bbe8f0c39ed", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -355,7 +355,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n \n                 self.fold_substs(substs);\n             }\n-            ty::ty_bare_fn(ty::BareFnTy{sig: ref fn_sig, ..}) |\n+            ty::ty_bare_fn(_, ty::BareFnTy{sig: ref fn_sig, ..}) |\n             ty::ty_closure(box ty::ClosureTy{sig: ref fn_sig, ..}) => {\n                 self.binding_count += 1;\n "}, {"sha": "b123d97d8970c42945f1ed8142defbd951ba8de2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -15,7 +15,6 @@ use self::ResolveReason::*;\n \n use astconv::AstConv;\n use check::FnCtxt;\n-use middle::def;\n use middle::pat_util;\n use middle::ty::{mod, Ty, MethodCall, MethodCallee};\n use middle::ty_fold::{TypeFolder,TypeFoldable};\n@@ -267,25 +266,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             Some(adjustment) => {\n                 let adj_object = ty::adjust_is_object(&adjustment);\n                 let resolved_adjustment = match adjustment {\n-                    ty::AdjustAddEnv(store) => {\n-                        // FIXME(eddyb) #2190 Allow only statically resolved\n-                        // bare functions to coerce to a closure to avoid\n-                        // constructing (slower) indirect call wrappers.\n-                        match self.tcx().def_map.borrow().get(&id) {\n-                            Some(&def::DefFn(..)) |\n-                            Some(&def::DefStaticMethod(..)) |\n-                            Some(&def::DefVariant(..)) |\n-                            Some(&def::DefStruct(_)) => {\n-                            }\n-                            _ => {\n-                                span_err!(self.tcx().sess, reason.span(self.tcx()), E0100,\n-                                    \"cannot coerce non-statically resolved bare fn to closure\");\n-                                span_help!(self.tcx().sess, reason.span(self.tcx()),\n-                                    \"consider embedding the function in a closure\");\n-                            }\n-                        }\n+                    ty::AdjustAddEnv(def_id, store) => {\n+                        ty::AdjustAddEnv(def_id, self.resolve(&store, reason))\n+                    }\n \n-                        ty::AdjustAddEnv(self.resolve(&store, reason))\n+                    ty::AdjustReifyFnPointer(def_id) => {\n+                        ty::AdjustReifyFnPointer(def_id)\n                     }\n \n                     ty::AdjustDerefRef(adj) => {"}, {"sha": "b08db39c18984308eafc2b8042129a0e99bfdea9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             // impl, plus its own.\n             let new_polytype = ty::Polytype {\n                 generics: new_method_ty.generics.clone(),\n-                ty: ty::mk_bare_fn(tcx, new_method_ty.fty.clone())\n+                ty: ty::mk_bare_fn(tcx, Some(new_did), new_method_ty.fty.clone())\n             };\n             debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n "}, {"sha": "c7c33db5746aaf39c33eebc5b6e310e70b40c4a3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -211,6 +211,8 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Create a set of parameter types shared among all the variants.\n     for variant in variants.iter() {\n+        let variant_def_id = local_def(variant.node.id);\n+\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n         let result_ty = match variant.node.kind {\n@@ -246,7 +248,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty: result_ty\n         };\n \n-        tcx.tcache.borrow_mut().insert(local_def(variant.node.id), pty);\n+        tcx.tcache.borrow_mut().insert(variant_def_id, pty);\n \n         write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n@@ -353,7 +355,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             m.def_id,\n             Polytype {\n                 generics: m.generics.clone(),\n-                ty: ty::mk_bare_fn(ccx.tcx, m.fty.clone()) });\n+                ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), m.fty.clone()) });\n     }\n \n     fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -519,20 +521,21 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n         }\n \n+        let m_def_id = local_def(m.id);\n         let mty = Rc::new(ty_of_method(ccx,\n                                        convert_method_context,\n                                        container,\n                                        m,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ty_generics,\n                                        rcvr_visibility));\n-        let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n+        let fty = ty::mk_bare_fn(tcx, Some(m_def_id), mty.fty.clone());\n         debug!(\"method {} (id {}) has type {}\",\n                 m.pe_ident().repr(tcx),\n                 m.id,\n                 fty.repr(tcx));\n         tcx.tcache.borrow_mut().insert(\n-            local_def(m.id),\n+            m_def_id,\n             Polytype {\n                 generics: mty.generics.clone(),\n                 ty: fty\n@@ -1461,7 +1464,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             };\n             let pty = Polytype {\n                 generics: ty_generics,\n-                ty: ty::mk_bare_fn(ccx.tcx, tofd)\n+                ty: ty::mk_bare_fn(ccx.tcx, Some(local_def(it.id)), tofd)\n             };\n             debug!(\"type of {} (id {}) is {}\",\n                     token::get_ident(it.ident),\n@@ -2138,6 +2141,7 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,\n+        None,\n         ty::BareFnTy {\n             abi: abi,\n             unsafety: ast::Unsafety::Unsafe,"}, {"sha": "65dff774528a7d7be5013faf729debda4eb6c2c5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -102,6 +102,7 @@ use util::ppaux;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n+use syntax::ast_util::local_def;\n \n #[cfg(stage0)]\n mod diagnostics;\n@@ -224,7 +225,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 }\n                 _ => ()\n             }\n-            let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(main_id)), ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -256,7 +257,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let start_t = ty::node_id_to_type(tcx, start_id);\n     match start_t.sty {\n-        ty::ty_bare_fn(_) => {\n+        ty::ty_bare_fn(..) => {\n             match tcx.map.find(start_id) {\n                 Some(ast_map::NodeItem(it)) => {\n                     match it.node {\n@@ -272,7 +273,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(start_id)), ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {"}, {"sha": "8e69bc42d9a0d03714daae21bc12461cfb3917d5", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -814,12 +814,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::ty_bare_fn(ty::BareFnTy { ref sig, .. }) |\n+            ty::ty_bare_fn(_, ty::BareFnTy { ref sig, .. }) |\n             ty::ty_closure(box ty::ClosureTy {\n                     ref sig,\n                     store: ty::UniqTraitStore,\n                     ..\n-                }) => {\n+                }) =>\n+            {\n                 self.add_constraints_from_sig(sig, variance);\n             }\n "}, {"sha": "2bc93ade7774e87d3757efae574f9d1081c5a647", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -176,7 +176,7 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Function {\n     let t = ty::lookup_item_type(tcx, did);\n     let (decl, style) = match t.ty.sty {\n-        ty::ty_bare_fn(ref f) => ((did, &f.sig).clean(cx), f.unsafety),\n+        ty::ty_bare_fn(_, ref f) => ((did, &f.sig).clean(cx), f.unsafety),\n         _ => panic!(\"bad function\"),\n     };\n     clean::Function {"}, {"sha": "0dd6c2a7ce7305b6fa17e1d25e6e83095e03a1f6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -1360,7 +1360,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 mutability: mt.mutbl.clean(cx),\n                 type_: box mt.ty.clean(cx),\n             },\n-            ty::ty_bare_fn(ref fty) => BareFunction(box BareFunctionDecl {\n+            ty::ty_bare_fn(_, ref fty) => BareFunction(box BareFunctionDecl {\n                 unsafety: fty.unsafety,\n                 generics: Generics {\n                     lifetimes: Vec::new(),"}, {"sha": "f7984b8973cc6a0968cf6c2d84cc7a7ea4430190", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -65,17 +65,21 @@ const HOEDOWN_EXTENSIONS: libc::c_uint =\n \n type hoedown_document = libc::c_void;  // this is opaque to us\n \n+type blockcodefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                 *const hoedown_buffer, *mut libc::c_void);\n+\n+type headerfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                              libc::c_int, *mut libc::c_void);\n+\n #[repr(C)]\n struct hoedown_renderer {\n     opaque: *mut hoedown_html_renderer_state,\n-    blockcode: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                    *const hoedown_buffer, *mut libc::c_void)>,\n+    blockcode: Option<blockcodefn>,\n     blockquote: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                      *mut libc::c_void)>,\n     blockhtml: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                     *mut libc::c_void)>,\n-    header: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                 libc::c_int, *mut libc::c_void)>,\n+    header: Option<headerfn>,\n     other: [libc::size_t, ..28],\n }\n \n@@ -281,8 +285,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n             toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n         };\n         (*(*renderer).opaque).opaque = &mut opaque as *mut _ as *mut libc::c_void;\n-        (*renderer).blockcode = Some(block);\n-        (*renderer).header = Some(header);\n+        (*renderer).blockcode = Some(block as blockcodefn);\n+        (*renderer).header = Some(header as headerfn);\n \n         let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n         hoedown_document_render(document, ob, s.as_ptr(),\n@@ -354,8 +358,8 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n         let renderer = hoedown_html_renderer_new(0, 0);\n-        (*renderer).blockcode = Some(block);\n-        (*renderer).header = Some(header);\n+        (*renderer).blockcode = Some(block as blockcodefn);\n+        (*renderer).header = Some(header as headerfn);\n         (*(*renderer).opaque).opaque = tests as *mut _ as *mut libc::c_void;\n \n         let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);"}, {"sha": "d749cd77cef2dc0b385ae47a0d1ea9ba5ab2c226", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -838,8 +838,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn keys(&self) -> Keys<K, V> {\n+    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n \n         Keys { inner: self.iter().map(first) }\n     }\n@@ -862,8 +863,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn values(&self) -> Values<K, V> {\n+    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n \n         Values { inner: self.iter().map(second) }\n     }\n@@ -938,6 +940,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n \n         IntoIter {\n             inner: self.table.into_iter().map(last_two)\n@@ -1007,6 +1010,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn drain(&mut self) -> Drain<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two; // coerce to fn pointer\n \n         Drain {\n             inner: self.table.drain().map(last_two),"}, {"sha": "6d83d5510b35735603d535dd01974c68bca04cfa", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -276,6 +276,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first;\n \n         IntoIter { iter: self.map.into_iter().map(first) }\n     }\n@@ -418,6 +419,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn drain(&mut self) -> Drain<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n+\n         Drain { iter: self.map.drain().map(first) }\n     }\n "}, {"sha": "f0a00b421c3a34d55d5e35e8cd0e3d6f4240a459", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -390,6 +390,7 @@ impl Path {\n         let v = if self.repr[0] == SEP_BYTE {\n             self.repr[1..]\n         } else { self.repr.as_slice() };\n+        let is_sep_byte: fn(&u8) -> bool = is_sep_byte; // coerce to fn ptr\n         let mut ret = v.split(is_sep_byte);\n         if v.is_empty() {\n             // consume the empty \"\" component\n@@ -404,7 +405,8 @@ impl Path {\n         fn from_utf8(s: &[u8]) -> Option<&str> {\n             str::from_utf8(s).ok()\n         }\n-        self.components().map(from_utf8)\n+        let f: fn(&[u8]) -> Option<&str> = from_utf8; // coerce to fn ptr\n+        self.components().map(f)\n     }\n }\n "}, {"sha": "b24966241ff664d8e3dd5e74d197c95cee3cb9ad", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -651,7 +651,8 @@ impl Path {\n             None if repr.as_bytes()[0] == SEP_BYTE => repr[1..],\n             None => repr\n         };\n-        let ret = s.split_terminator(SEP).map(Some);\n+        let some: fn(&'a str) -> Option<&'a str> = Some; // coerce to fn ptr\n+        let ret = s.split_terminator(SEP).map(some);\n         ret\n     }\n \n@@ -662,6 +663,7 @@ impl Path {\n             #![inline]\n             x.unwrap().as_bytes()\n         }\n+        let convert: for<'b> fn(Option<&'b str>) -> &'b [u8] = convert; // coerce to fn ptr\n         self.str_components().map(convert)\n     }\n \n@@ -1044,7 +1046,11 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n \n // None result means the string didn't need normalizing\n fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option<Vec<&'a str>>) {\n-    let f = if !prefix_is_verbatim(prefix) { is_sep } else { is_sep_verbatim };\n+    let f: fn(char) -> bool = if !prefix_is_verbatim(prefix) {\n+        is_sep\n+    } else {\n+        is_sep_verbatim\n+    };\n     let is_abs = s.len() > prefix_len(prefix) && f(s.char_at(prefix_len(prefix)));\n     let s_ = s[prefix_len(prefix)..];\n     let s_ = if is_abs { s_[1..] } else { s_ };"}, {"sha": "04718dcc6ae3bb8435437dc817256cb0317f6897", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -189,11 +189,12 @@ macro_rules! __thread_local_inner {\n             }\n         };\n \n-        #[cfg(not(any(target_os = \"macos\", target_os = \"linux\")))]\n+        #[cfg(all(stage0, not(any(target_os = \"macos\", target_os = \"linux\"))))]\n         const INIT: ::std::thread_local::KeyInner<$t> = {\n             unsafe extern fn __destroy(ptr: *mut u8) {\n                 ::std::thread_local::destroy_value::<$t>(ptr);\n             }\n+\n             ::std::thread_local::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: $init },\n                 os: ::std::thread_local::OsStaticKey {\n@@ -203,6 +204,21 @@ macro_rules! __thread_local_inner {\n             }\n         };\n \n+        #[cfg(all(not(stage0), not(any(target_os = \"macos\", target_os = \"linux\"))))]\n+        const INIT: ::std::thread_local::KeyInner<$t> = {\n+            unsafe extern fn __destroy(ptr: *mut u8) {\n+                ::std::thread_local::destroy_value::<$t>(ptr);\n+            }\n+\n+            ::std::thread_local::KeyInner {\n+                inner: ::std::cell::UnsafeCell { value: $init },\n+                os: ::std::thread_local::OsStaticKey {\n+                    inner: ::std::thread_local::OS_INIT_INNER,\n+                    dtor: ::std::option::Option::Some(__destroy as unsafe extern fn(*mut u8)),\n+                },\n+            }\n+        };\n+\n         INIT\n     });\n }\n@@ -323,6 +339,12 @@ mod imp {\n         // *should* be the case that this loop always terminates because we\n         // provide the guarantee that a TLS key cannot be set after it is\n         // flagged for destruction.\n+        #[cfg(not(stage0))]\n+        static DTORS: os::StaticKey = os::StaticKey {\n+            inner: os::INIT_INNER,\n+            dtor: Some(run_dtors as unsafe extern \"C\" fn(*mut u8)),\n+        };\n+        #[cfg(stage0)]\n         static DTORS: os::StaticKey = os::StaticKey {\n             inner: os::INIT_INNER,\n             dtor: Some(run_dtors),"}, {"sha": "d45871708dc20dd6fef7899c2591e97ca5ed50c8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -50,14 +50,16 @@ pub trait ItemDecorator {\n               push: |P<ast::Item>|);\n }\n \n-impl ItemDecorator for fn(&mut ExtCtxt, Span, &ast::MetaItem, &ast::Item, |P<ast::Item>|) {\n+impl<F> ItemDecorator for F\n+    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &ast::Item, |P<ast::Item>|)\n+{\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &ast::Item,\n               push: |P<ast::Item>|) {\n-        self.clone()(ecx, sp, meta_item, item, push)\n+        (*self)(ecx, sp, meta_item, item, push)\n     }\n }\n \n@@ -70,14 +72,16 @@ pub trait ItemModifier {\n               -> P<ast::Item>;\n }\n \n-impl ItemModifier for fn(&mut ExtCtxt, Span, &ast::MetaItem, P<ast::Item>) -> P<ast::Item> {\n+impl<F> ItemModifier for F\n+    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, P<ast::Item>) -> P<ast::Item>\n+{\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n               meta_item: &ast::MetaItem,\n               item: P<ast::Item>)\n               -> P<ast::Item> {\n-        self.clone()(ecx, span, meta_item, item)\n+        (*self)(ecx, span, meta_item, item)\n     }\n }\n \n@@ -93,13 +97,15 @@ pub trait TTMacroExpander {\n pub type MacroExpanderFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, &[ast::TokenTree]) -> Box<MacResult+'cx>;\n \n-impl TTMacroExpander for MacroExpanderFn {\n+impl<F> TTMacroExpander for F\n+    where F : for<'cx> Fn(&'cx mut ExtCtxt, Span, &[ast::TokenTree]) -> Box<MacResult+'cx>\n+{\n     fn expand<'cx>(&self,\n                    ecx: &'cx mut ExtCtxt,\n                    span: Span,\n                    token_tree: &[ast::TokenTree])\n                    -> Box<MacResult+'cx> {\n-        self.clone()(ecx, span, token_tree)\n+        (*self)(ecx, span, token_tree)\n     }\n }\n \n@@ -115,14 +121,18 @@ pub trait IdentMacroExpander {\n pub type IdentMacroExpanderFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree>) -> Box<MacResult+'cx>;\n \n-impl IdentMacroExpander for IdentMacroExpanderFn {\n+impl<F> IdentMacroExpander for F\n+    where F : for<'cx> Fn(&'cx mut ExtCtxt, Span, ast::Ident,\n+                          Vec<ast::TokenTree>) -> Box<MacResult+'cx>\n+{\n     fn expand<'cx>(&self,\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    ident: ast::Ident,\n                    token_tree: Vec<ast::TokenTree> )\n-                   -> Box<MacResult+'cx> {\n-        self.clone()(cx, sp, ident, token_tree)\n+                   -> Box<MacResult+'cx>\n+    {\n+        (*self)(cx, sp, ident, token_tree)\n     }\n }\n "}, {"sha": "65b8ad997f6a1426528696bdcfce826c74a2c885", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -64,7 +64,10 @@ impl UnicodeStr for str {\n     #[inline]\n     fn words(&self) -> Words {\n         fn is_not_empty(s: &&str) -> bool { !s.is_empty() }\n+        let is_not_empty: fn(&&str) -> bool = is_not_empty; // coerce to fn pointer\n+\n         fn is_whitespace(c: char) -> bool { c.is_whitespace() }\n+        let is_whitespace: fn(char) -> bool = is_whitespace; // coerce to fn pointer\n \n         Words { inner: self.split(is_whitespace).filter(is_not_empty) }\n     }"}, {"sha": "1b4e5891f941de493f284cf808da66326a7b88ea", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -20,7 +20,7 @@ impl X {\n }\n \n fn main() {\n-    let mut x = X(Either::Right(main));\n+    let mut x = X(Either::Right(main as fn()));\n     (&mut x).with(\n         |opt| { //~ ERROR cannot borrow `x` as mutable more than once at a time\n             match opt {"}, {"sha": "1db813292b01241b79535116219a01fa6f2b93c5", "filename": "src/test/compile-fail/cast-to-bare-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -13,7 +13,7 @@ fn foo(_x: int) { }\n fn main() {\n     let v: u64 = 5;\n     let x = foo as extern \"C\" fn() -> int;\n-    //~^ ERROR non-scalar cast\n+    //~^ ERROR mismatched types\n     let y = v as extern \"Rust\" fn(int) -> (int, int);\n     //~^ ERROR non-scalar cast\n     y(x());"}, {"sha": "52f4c4749e224f90e1455befddc899c5cf7557a6", "filename": "src/test/compile-fail/coerce-bare-fn-to-closure-and-proc.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-bare-fn-to-closure-and-proc.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -8,12 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that coercions from fn item types are ok, but not fn pointer\n+// types to closures/procs are not allowed.\n+\n fn foo() {}\n \n-fn main() {\n+fn fn_item_type() {\n     let f = foo;\n \n     let f_closure: || = f;\n-    //~^ ERROR: cannot coerce non-statically resolved bare fn to closure\n-    //~^^ HELP: consider embedding the function in a closure\n }\n+\n+fn fn_pointer_type() {\n+    let f = foo as fn();\n+    let f_closure: || = f;\n+    //~^ ERROR: mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "dd4a24bfb2fdc17a6fbb89ef8b222e8568a41013", "filename": "src/test/compile-fail/fn-item-type.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the types of distinct fn items are not compatible by\n+// default. See also `run-pass/fn-item-type-*.rs`.\n+\n+fn foo(x: int) -> int { x * 2 }\n+fn bar(x: int) -> int { x * 4 }\n+\n+fn eq<T>(x: T, y: T) { }\n+\n+fn main() {\n+    let f = if true { foo } else { bar };\n+    //~^ ERROR expected fn item, found a different fn item\n+\n+    eq(foo, bar);\n+    //~^ ERROR expected fn item, found a different fn item\n+}"}, {"sha": "cd4ec495556c562303249997f20c36d31f7b3694", "filename": "src/test/compile-fail/issue-10764.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fissue-10764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fissue-10764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10764.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -12,4 +12,4 @@ fn f(_: extern \"Rust\" fn()) {}\n extern fn bar() {}\n \n fn main() { f(bar) }\n-//~^ ERROR: expected `fn()`, found `extern \"C\" fn()`\n+//~^ ERROR mismatched types"}, {"sha": "6e8f7ffb68da4285549855b1da38623942474616", "filename": "src/test/compile-fail/issue-9575.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -10,6 +10,6 @@\n \n #[start]\n fn start(argc: int, argv: *const *const u8, crate_map: *const u8) -> int {\n-    //~^ ERROR start function expects type: `fn(int, *const *const u8) -> int`\n+    //~^ ERROR incorrect number of function parameters\n     0\n }"}, {"sha": "3e6a95b04f743ab8e7a6e56dc48afba0110f5aae", "filename": "src/test/compile-fail/region-lifetime-bounds-on-fns-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -15,7 +15,7 @@ fn a<'a, 'b>(x: &mut &'a int, y: &mut &'b int) where 'b: 'a {\n \n fn b<'a, 'b>(x: &mut &'a int, y: &mut &'b int) {\n     // Illegal now because there is no `'b:'a` declaration.\n-    *x = *y; //~ ERROR mismatched types\n+    *x = *y; //~ ERROR cannot infer\n }\n \n fn c<'a,'b>(x: &mut &'a int, y: &mut &'b int) {"}, {"sha": "2d635e9fc2718067c399cb060bc588ef8ea76e56", "filename": "src/test/compile-fail/region-multiple-lifetime-bounds-on-fns-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -16,8 +16,8 @@ fn a<'a, 'b, 'c>(x: &mut &'a int, y: &mut &'b int, z: &mut &'c int) where 'b: 'a\n \n fn b<'a, 'b, 'c>(x: &mut &'a int, y: &mut &'b int, z: &mut &'c int) {\n     // Illegal now because there is no `'b:'a` declaration.\n-    *x = *y; //~ ERROR mismatched types\n-    *z = *y; //~ ERROR mismatched types\n+    *x = *y; //~ ERROR cannot infer\n+    *z = *y; //~ ERROR cannot infer\n }\n \n fn c<'a,'b, 'c>(x: &mut &'a int, y: &mut &'b int, z: &mut &'c int) {"}, {"sha": "4a42728da6f580f0aab75f13891ba84b9eb8b670", "filename": "src/test/compile-fail/regions-lifetime-bounds-on-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-bounds-on-fns.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -15,7 +15,7 @@ fn a<'a, 'b:'a>(x: &mut &'a int, y: &mut &'b int) {\n \n fn b<'a, 'b>(x: &mut &'a int, y: &mut &'b int) {\n     // Illegal now because there is no `'b:'a` declaration.\n-    *x = *y; //~ ERROR mismatched types\n+    *x = *y; //~ ERROR cannot infer\n }\n \n fn c<'a,'b>(x: &mut &'a int, y: &mut &'b int) {"}, {"sha": "f4654367970d11d052b16a23f73f54b8933e3113", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -12,10 +12,10 @@ fn ignore<T>(t: T) {}\n \n fn nested<'x>(x: &'x int) {\n     let y = 3;\n-    let mut ay = &y; //~ ERROR cannot infer\n+    let mut ay = &y;\n \n     ignore::< for<'z>|&'z int|>(|z| {\n-        ay = x;\n+        ay = x; //~ ERROR cannot infer\n         ay = &y;\n         ay = z;\n     });"}, {"sha": "bce397c47932f453baa83c8deffb871c1a593b04", "filename": "src/test/compile-fail/static-reference-to-fn-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-1.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -24,7 +24,7 @@ fn foo() -> Option<int> {\n \n fn create() -> A<'static> {\n     A {\n-        func: &foo, //~ ERROR borrowed value does not live long enough\n+        func: &foo, //~ ERROR mismatched types\n     }\n }\n "}, {"sha": "d7255c3ba0694ff96f10149795d439cb22bba3c7", "filename": "src/test/compile-fail/static-reference-to-fn-2.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -9,29 +9,31 @@\n // except according to those terms.\n \n struct StateMachineIter<'a> {\n-    statefn: &'a fn(&mut StateMachineIter<'a>) -> Option<&'static str>\n+    statefn: &'a StateMachineFunc<'a>\n }\n \n+type StateMachineFunc<'a> = fn(&mut StateMachineIter<'a>) -> Option<&'static str>;\n+\n impl<'a> Iterator<&'static str> for StateMachineIter<'a> {\n     fn next(&mut self) -> Option<&'static str> {\n         return  (*self.statefn)(self);\n     }\n }\n \n fn state1(self_: &mut StateMachineIter) -> Option<&'static str> {\n-    self_.statefn = &state2;\n+    self_.statefn = &(state2 as StateMachineFunc);\n     //~^ ERROR borrowed value does not live long enough\n     return Some(\"state1\");\n }\n \n fn state2(self_: &mut StateMachineIter) -> Option<(&'static str)> {\n-    self_.statefn = &state3;\n+    self_.statefn = &(state3 as StateMachineFunc);\n     //~^ ERROR borrowed value does not live long enough\n     return Some(\"state2\");\n }\n \n fn state3(self_: &mut StateMachineIter) -> Option<(&'static str)> {\n-    self_.statefn = &finished;\n+    self_.statefn = &(finished as StateMachineFunc);\n     //~^ ERROR borrowed value does not live long enough\n     return Some(\"state3\");\n }\n@@ -42,7 +44,7 @@ fn finished(_: &mut StateMachineIter) -> Option<(&'static str)> {\n \n fn state_iter() -> StateMachineIter<'static> {\n     StateMachineIter {\n-        statefn: &state1 //~ ERROR borrowed value does not live long enough\n+        statefn: &(state1 as StateMachineFunc) //~ ERROR borrowed value does not live long enough\n     }\n }\n "}, {"sha": "e4389cd69dd62f88ed6b53ca928abe3999b912a6", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -50,20 +50,20 @@\n \n \n              ((::std::fmt::format as\n-                  fn(&core::fmt::Arguments<'_>) -> collections::string::String)((&((::std::fmt::Arguments::new\n-                                                                                       as\n-                                                                                       fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_>)((__STATIC_FMTSTR\n-                                                                                                                                                                as\n-                                                                                                                                                                &'static [&'static str]),\n-                                                                                                                                                            (&([]\n-                                                                                                                                                                  as\n-                                                                                                                                                                  [core::fmt::Argument<'_>; 0])\n-                                                                                                                                                                as\n-                                                                                                                                                                &[core::fmt::Argument<'_>; 0]))\n-                                                                                      as\n-                                                                                      core::fmt::Arguments<'_>)\n-                                                                                    as\n-                                                                                    &core::fmt::Arguments<'_>))\n+                  fn(&core::fmt::Arguments<'_>) -> collections::string::String {std::fmt::format})((&((::std::fmt::Arguments::new\n+                                                                                                          as\n+                                                                                                          fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new})((__STATIC_FMTSTR\n+                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                   &'static [&'static str]),\n+                                                                                                                                                                                                               (&([]\n+                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                     [core::fmt::Argument<'_>; 0])\n+                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                   &[core::fmt::Argument<'_>; 0]))\n+                                                                                                         as\n+                                                                                                         core::fmt::Arguments<'_>)\n+                                                                                                       as\n+                                                                                                       &core::fmt::Arguments<'_>))\n                  as collections::string::String)\n          }\n      } as collections::string::String);\n@@ -78,7 +78,8 @@\n pub fn use_id() {\n     let _ =\n         ((id::<[int; (3u as uint)]> as\n-             fn([int; 3]) -> [int; 3])(([(1 as int), (2 as int), (3 as int)]\n-                                           as [int; 3])) as [int; 3]);\n+             fn([int; 3]) -> [int; 3] {id})(([(1 as int), (2 as int),\n+                                              (3 as int)] as [int; 3])) as\n+            [int; 3]);\n }\n fn main() { }"}, {"sha": "069ca6ecf49dd4c3f1ef83212d7e7fef3beebfa0", "filename": "src/test/run-pass/const-extern-function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-extern-function.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -18,6 +18,6 @@ struct S {\n }\n \n pub fn main() {\n-    assert!(foopy == f);\n+    assert!(foopy as extern \"C\" fn() == f);\n     assert!(f == s.f);\n }"}, {"sha": "3febff18704deea2faf81c12c4d46e9966d6d09c", "filename": "src/test/run-pass/extern-compare-with-return-type.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Fextern-compare-with-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Fextern-compare-with-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-compare-with-return-type.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -18,15 +18,17 @@ extern fn uintret() -> uint { 22 }\n extern fn uintvoidret(_x: uint) {}\n \n extern fn uintuintuintuintret(x: uint, y: uint, z: uint) -> uint { x+y+z }\n+type uintuintuintuintret = extern fn(uint,uint,uint) -> uint;\n \n pub fn main() {\n-    assert!(voidret1 == voidret1);\n-    assert!(voidret1 != voidret2);\n+    assert!(voidret1 as extern fn() == voidret1 as extern fn());\n+    assert!(voidret1 as extern fn() != voidret2 as extern fn());\n \n-    assert!(uintret == uintret);\n+    assert!(uintret as extern fn() -> uint == uintret as extern fn() -> uint);\n \n-    assert!(uintvoidret == uintvoidret);\n+    assert!(uintvoidret as extern fn(uint) == uintvoidret as extern fn(uint));\n \n-    assert!(uintuintuintuintret == uintuintuintuintret);\n+    assert!(uintuintuintuintret as uintuintuintuintret ==\n+            uintuintuintuintret as uintuintuintuintret);\n }\n "}, {"sha": "bfd02f5e27b0c4bced6290d6c5973584916c27b5", "filename": "src/test/run-pass/fn-item-type-cast.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Ffn-item-type-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Ffn-item-type-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-item-type-cast.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test explicit coercions from a fn item type to a fn pointer type.\n+\n+fn foo(x: int) -> int { x * 2 }\n+fn bar(x: int) -> int { x * 4 }\n+type IntMap = fn(int) -> int;\n+\n+fn eq<T>(x: T, y: T) { }\n+\n+static TEST: Option<IntMap> = Some(foo as IntMap);\n+\n+fn main() {\n+    let f = foo as IntMap;\n+\n+    let f = if true { foo as IntMap } else { bar as IntMap };\n+    assert_eq!(f(4), 8);\n+\n+    eq(foo as IntMap, bar as IntMap);\n+}"}, {"sha": "8427a0f444621ce93cdbf25a07240b7eacfbbcdc", "filename": "src/test/run-pass/fn-item-type-coerce.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Ffn-item-type-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Ffn-item-type-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-item-type-coerce.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test implicit coercions from a fn item type to a fn pointer type.\n+\n+fn foo(x: int) -> int { x * 2 }\n+fn bar(x: int) -> int { x * 4 }\n+type IntMap = fn(int) -> int;\n+\n+fn eq<T>(x: T, y: T) { }\n+\n+fn main() {\n+    let f: IntMap = foo;\n+\n+    eq::<IntMap>(foo, bar);\n+}"}, {"sha": "d28950241874d2db112f1d5be09a2adc696933c5", "filename": "src/test/run-pass/issue-10767.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Fissue-10767.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Fissue-10767.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10767.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -12,5 +12,5 @@\n pub fn main() {\n     fn f() {\n     };\n-    let _: Box<fn()> = box f;\n+    let _: Box<fn()> = box() (f as fn());\n }"}, {"sha": "0f4978d78dd86700d0961236461cb6a7ca632250", "filename": "src/test/run-pass/issue-15444.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Fissue-15444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de11710d807bed5c0a29cc0413d404552a42c89d/src%2Ftest%2Frun-pass%2Fissue-15444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15444.rs?ref=de11710d807bed5c0a29cc0413d404552a42c89d", "patch": "@@ -25,5 +25,6 @@ fn thing(a: int, b: int) -> int {\n }\n \n fn main() {\n+    let thing: fn(int, int) -> int = thing; // coerce to fn type\n     bar(&thing);\n }"}]}