{"sha": "db73863c42301ffc4ff0adf250359806017c5065", "node_id": "C_kwDOAAsO6NoAKGRiNzM4NjNjNDIzMDFmZmM0ZmYwYWRmMjUwMzU5ODA2MDE3YzUwNjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-26T13:44:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-26T13:44:39Z"}, "message": "Auto merge of #2857 - RalfJung:endian, r=RalfJung\n\nfix endianess handling in eventfd::write\n\nFixes https://github.com/rust-lang/miri/issues/2800", "tree": {"sha": "8885ac852269946102926750e8665ff306a6e3ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8885ac852269946102926750e8665ff306a6e3ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db73863c42301ffc4ff0adf250359806017c5065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db73863c42301ffc4ff0adf250359806017c5065", "html_url": "https://github.com/rust-lang/rust/commit/db73863c42301ffc4ff0adf250359806017c5065", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db73863c42301ffc4ff0adf250359806017c5065/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "html_url": "https://github.com/rust-lang/rust/commit/9f22b37f7b500ee69d851d140a9feb83bcfb1d00"}, {"sha": "99e3034bd2dc400a15063a347d322b43dcf63e2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/99e3034bd2dc400a15063a347d322b43dcf63e2d", "html_url": "https://github.com/rust-lang/rust/commit/99e3034bd2dc400a15063a347d322b43dcf63e2d"}], "stats": {"total": 34, "additions": 26, "deletions": 8}, "files": [{"sha": "abec782b4f0487888e06942b12ea4e6c5f92288e", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db73863c42301ffc4ff0adf250359806017c5065/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db73863c42301ffc4ff0adf250359806017c5065/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=db73863c42301ffc4ff0adf250359806017c5065", "patch": "@@ -11,6 +11,7 @@ use std::time::SystemTime;\n use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::TyCtxt;\n use rustc_target::abi::{Align, Size};\n \n use crate::shims::os_str::bytes_to_os_str;\n@@ -31,6 +32,7 @@ pub trait FileDescriptor: std::fmt::Debug + helpers::AsAny {\n         &mut self,\n         _communicate_allowed: bool,\n         _bytes: &mut [u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot read from {}\", self.name());\n     }\n@@ -39,6 +41,7 @@ pub trait FileDescriptor: std::fmt::Debug + helpers::AsAny {\n         &self,\n         _communicate_allowed: bool,\n         _bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot write to {}\", self.name());\n     }\n@@ -79,6 +82,7 @@ impl FileDescriptor for FileHandle {\n         &mut self,\n         communicate_allowed: bool,\n         bytes: &mut [u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.read(bytes))\n@@ -88,6 +92,7 @@ impl FileDescriptor for FileHandle {\n         &self,\n         communicate_allowed: bool,\n         bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok((&mut &self.file).write(bytes))\n@@ -153,6 +158,7 @@ impl FileDescriptor for io::Stdin {\n         &mut self,\n         communicate_allowed: bool,\n         bytes: &mut [u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         if !communicate_allowed {\n             // We want isolation mode to be deterministic, so we have to disallow all reads, even stdin.\n@@ -184,6 +190,7 @@ impl FileDescriptor for io::Stdout {\n         &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n         let result = Write::write(&mut { self }, bytes);\n@@ -220,6 +227,7 @@ impl FileDescriptor for io::Stderr {\n         &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n         // No need to flush, stderr is not buffered.\n@@ -252,6 +260,7 @@ impl FileDescriptor for NullOutput {\n         &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We just don't write anything, but report to the user that we did.\n         Ok(Ok(bytes.len()))\n@@ -756,8 +765,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             let mut bytes = vec![0; usize::try_from(count).unwrap()];\n             // `File::read` never returns a value larger than `count`,\n             // so this cannot fail.\n-            let result =\n-                file_descriptor.read(communicate, &mut bytes)?.map(|c| i64::try_from(c).unwrap());\n+            let result = file_descriptor\n+                .read(communicate, &mut bytes, *this.tcx)?\n+                .map(|c| i64::try_from(c).unwrap());\n \n             match result {\n                 Ok(read_bytes) => {\n@@ -803,8 +813,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             let bytes = this.read_bytes_ptr_strip_provenance(buf, Size::from_bytes(count))?;\n-            let result =\n-                file_descriptor.write(communicate, bytes)?.map(|c| i64::try_from(c).unwrap());\n+            let result = file_descriptor\n+                .write(communicate, bytes, *this.tcx)?\n+                .map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()"}, {"sha": "1f17ffb88c886973c82f0c0d67953daa94752934", "filename": "src/tools/miri/src/shims/unix/linux/fd/event.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db73863c42301ffc4ff0adf250359806017c5065/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db73863c42301ffc4ff0adf250359806017c5065/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs?ref=db73863c42301ffc4ff0adf250359806017c5065", "patch": "@@ -1,6 +1,8 @@\n use crate::shims::unix::fs::FileDescriptor;\n \n use rustc_const_eval::interpret::InterpResult;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_target::abi::Endian;\n \n use std::cell::Cell;\n use std::io;\n@@ -36,7 +38,7 @@ impl FileDescriptor for Event {\n     }\n \n     /// A write call adds the 8-byte integer value supplied in\n-    /// its buffer to the counter.  The maximum value that may be\n+    /// its buffer (in native endianess) to the counter.  The maximum value that may be\n     /// stored in the counter is the largest unsigned 64-bit value\n     /// minus 1 (i.e., 0xfffffffffffffffe).  If the addition would\n     /// cause the counter's value to exceed the maximum, then the\n@@ -47,17 +49,22 @@ impl FileDescriptor for Event {\n     /// A write fails with the error EINVAL if the size of the\n     /// supplied buffer is less than 8 bytes, or if an attempt is\n     /// made to write the value 0xffffffffffffffff.\n-    ///\n-    /// FIXME: use endianness\n     fn write<'tcx>(\n         &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n+        tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         let v1 = self.val.get();\n+        let bytes: [u8; 8] = bytes.try_into().unwrap(); // FIXME fail gracefully when this has the wrong size\n+        // Convert from target endianess to host endianess.\n+        let num = match tcx.sess.target.endian {\n+            Endian::Little => u64::from_le_bytes(bytes),\n+            Endian::Big => u64::from_be_bytes(bytes),\n+        };\n         // FIXME handle blocking when addition results in exceeding the max u64 value\n         // or fail with EAGAIN if the file descriptor is nonblocking.\n-        let v2 = v1.checked_add(u64::from_be_bytes(bytes.try_into().unwrap())).unwrap();\n+        let v2 = v1.checked_add(num).unwrap();\n         self.val.set(v2);\n         assert_eq!(8, bytes.len());\n         Ok(Ok(8))"}]}