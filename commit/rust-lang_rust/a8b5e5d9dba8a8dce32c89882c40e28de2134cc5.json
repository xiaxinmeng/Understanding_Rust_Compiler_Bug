{"sha": "a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "node_id": "C_kwDOAAsO6NoAKGE4YjVlNWQ5ZGJhOGE4ZGNlMzJjODk4ODJjNDBlMjhkZTIxMzRjYzU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-26T05:15:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-26T05:15:27Z"}, "message": "Rollup merge of #107248 - erikdesjardins:addrspace, r=oli-obk\n\nabi: add AddressSpace field to Primitive::Pointer\n\n...and remove it from `PointeeInfo`, which isn't meant for this.\n\nThere are still various places (marked with FIXMEs) that assume all pointers\nhave the same size and alignment. Fixing this requires parsing non-default\naddress spaces in the data layout string (and various other changes),\nwhich will be done in a followup.\n(That is, if it's actually worth it to support multiple different pointer sizes.\nThere is a lot of code that would be affected by that.)\n\nFixes #106367\n\nr? ``@oli-obk``\ncc ``@Patryk27``", "tree": {"sha": "c41b4d5e0f7a7ac2cc266eec9a1ad4bdb555241c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c41b4d5e0f7a7ac2cc266eec9a1ad4bdb555241c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj0gxvCRBK7hj4Ov3rIwAAwsQIABBTD5TzBCkqyTLY5Vc/yNib\nRBOK9VXM0FBLqgtsc+925tkbg7mWMQ80M5uOvNk0GPuzlTCNwh0xXxcDc+5/6Pk1\nX+kcKXHDekuG31pY0ZW+mvHhAoscDx4uTnG6CQiRWe3vp36aY7NebUHnck6M9hsv\naXS5BZszWXZ465bo416Jk8zh+Q0OKgiBPETv4MCPCb59YhxA05RkpDLlD68ohmz5\nKrv5SfDikusu6f/le+a5MIrN0RjwEE6GjD82UvyfpTf5OvlFvVM19qaR9VHRJnf9\nXxCcaU2Sm54co8IruIJT4xJi9YXQ2RJ6UO3Tj6Dpn94YaWxWkt/2nf2GQeV/h0c=\n=l51U\n-----END PGP SIGNATURE-----\n", "payload": "tree c41b4d5e0f7a7ac2cc266eec9a1ad4bdb555241c\nparent a8e8406e609972350f9fd10189895d3e8e341cd9\nparent adc18904483fbd9df409291da4c4e299c8b6cb3e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674710127 +0100\ncommitter GitHub <noreply@github.com> 1674710127 +0100\n\nRollup merge of #107248 - erikdesjardins:addrspace, r=oli-obk\n\nabi: add AddressSpace field to Primitive::Pointer\n\n...and remove it from `PointeeInfo`, which isn't meant for this.\n\nThere are still various places (marked with FIXMEs) that assume all pointers\nhave the same size and alignment. Fixing this requires parsing non-default\naddress spaces in the data layout string (and various other changes),\nwhich will be done in a followup.\n(That is, if it's actually worth it to support multiple different pointer sizes.\nThere is a lot of code that would be affected by that.)\n\nFixes #106367\n\nr? ``@oli-obk``\ncc ``@Patryk27``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "html_url": "https://github.com/rust-lang/rust/commit/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8e8406e609972350f9fd10189895d3e8e341cd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e8406e609972350f9fd10189895d3e8e341cd9", "html_url": "https://github.com/rust-lang/rust/commit/a8e8406e609972350f9fd10189895d3e8e341cd9"}, {"sha": "adc18904483fbd9df409291da4c4e299c8b6cb3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc18904483fbd9df409291da4c4e299c8b6cb3e", "html_url": "https://github.com/rust-lang/rust/commit/adc18904483fbd9df409291da4c4e299c8b6cb3e"}], "stats": {"total": 426, "additions": 229, "deletions": 197}, "files": [{"sha": "fe65ad9c6cb0e9bde1aaff6e4801ef2f2b8c964a", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -267,6 +267,9 @@ impl TargetDataLayout {\n                 [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n                 [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n                 [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n+                // FIXME(erikdesjardins): we should be parsing nonzero address spaces\n+                // this will require replacing TargetDataLayout::{pointer_size,pointer_align}\n+                // with e.g. `fn pointer_size_in(AddressSpace)`\n                 [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n                     dl.pointer_size = size(s, p)?;\n                     dl.pointer_align = align(a, p)?;\n@@ -861,7 +864,7 @@ pub enum Primitive {\n     Int(Integer, bool),\n     F32,\n     F64,\n-    Pointer,\n+    Pointer(AddressSpace),\n }\n \n impl Primitive {\n@@ -872,7 +875,10 @@ impl Primitive {\n             Int(i, _) => i.size(),\n             F32 => Size::from_bits(32),\n             F64 => Size::from_bits(64),\n-            Pointer => dl.pointer_size,\n+            // FIXME(erikdesjardins): ignoring address space is technically wrong, pointers in\n+            // different address spaces can have different sizes\n+            // (but TargetDataLayout doesn't currently parse that part of the DL string)\n+            Pointer(_) => dl.pointer_size,\n         }\n     }\n \n@@ -883,26 +889,12 @@ impl Primitive {\n             Int(i, _) => i.align(dl),\n             F32 => dl.f32_align,\n             F64 => dl.f64_align,\n-            Pointer => dl.pointer_align,\n+            // FIXME(erikdesjardins): ignoring address space is technically wrong, pointers in\n+            // different address spaces can have different alignments\n+            // (but TargetDataLayout doesn't currently parse that part of the DL string)\n+            Pointer(_) => dl.pointer_align,\n         }\n     }\n-\n-    // FIXME(eddyb) remove, it's trivial thanks to `matches!`.\n-    #[inline]\n-    pub fn is_float(self) -> bool {\n-        matches!(self, F32 | F64)\n-    }\n-\n-    // FIXME(eddyb) remove, it's completely unused.\n-    #[inline]\n-    pub fn is_int(self) -> bool {\n-        matches!(self, Int(..))\n-    }\n-\n-    #[inline]\n-    pub fn is_ptr(self) -> bool {\n-        matches!(self, Pointer)\n-    }\n }\n \n /// Inclusive wrap-around range of valid values, that is, if\n@@ -1188,7 +1180,8 @@ impl FieldsShape {\n /// An identifier that specifies the address space that some operation\n /// should operate on. Special address spaces have an effect on code generation,\n /// depending on the target and the address spaces it implements.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n pub struct AddressSpace(pub u32);\n \n impl AddressSpace {\n@@ -1468,7 +1461,6 @@ pub struct PointeeInfo {\n     pub size: Size,\n     pub align: Align,\n     pub safe: Option<PointerKind>,\n-    pub address_space: AddressSpace,\n }\n \n /// Used in `might_permit_raw_init` to indicate the kind of initialisation"}, {"sha": "63ed10cdfcc59f59216c4f30d68eee45b4091d3f", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -35,7 +35,8 @@ pub(crate) fn scalar_to_clif_type(tcx: TyCtxt<'_>, scalar: Scalar) -> Type {\n         },\n         Primitive::F32 => types::F32,\n         Primitive::F64 => types::F64,\n-        Primitive::Pointer => pointer_ty(tcx),\n+        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+        Primitive::Pointer(_) => pointer_ty(tcx),\n     }\n }\n "}, {"sha": "e88c12716ecd3d240da161bd05e7c7900067a39b", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -709,7 +709,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         bx.range_metadata(load, vr);\n                     }\n                 }\n-                abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n+                abi::Pointer(_) if vr.start < vr.end && !vr.contains(0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}"}, {"sha": "c939da9cec3c21346be0ed6b5db214830bb858b1", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -211,7 +211,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 let base_addr = self.const_bitcast(base_addr, self.usize_type);\n                 let offset = self.context.new_rvalue_from_long(self.usize_type, offset.bytes() as i64);\n                 let ptr = self.const_bitcast(base_addr + offset, ptr_type);\n-                if layout.primitive() != Pointer {\n+                if !matches!(layout.primitive(), Pointer(_)) {\n                     self.const_bitcast(ptr.dereference(None).to_rvalue(), ty)\n                 }\n                 else {"}, {"sha": "dc41cb761b59c44b9e60d2567d3b5b5b276a315f", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -322,13 +322,16 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n             )\n             .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n+\n+        let address_space = cx.tcx.global_alloc(alloc_id).address_space(cx);\n+\n         llvals.push(cx.scalar_to_backend(\n             InterpScalar::from_pointer(\n                 interpret::Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            abi::Scalar::Initialized { value: Primitive::Pointer, valid_range: WrappingRange::full(dl.pointer_size) },\n-            cx.type_i8p(),\n+            abi::Scalar::Initialized { value: Primitive::Pointer(address_space), valid_range: WrappingRange::full(dl.pointer_size) },\n+            cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;\n     }"}, {"sha": "1326af670cde4e4cc78f3eb1e48eabb79eaf39bb", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -253,7 +253,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             Int(i, false) => cx.type_from_unsigned_integer(i),\n             F32 => cx.type_f32(),\n             F64 => cx.type_f64(),\n-            Pointer => {\n+            Pointer(address_space) => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee =\n                     if let Some(pointee) = self.pointee_info_at(cx, offset) {\n@@ -262,7 +262,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                     else {\n                         cx.type_i8()\n                     };\n-                cx.type_ptr_to(pointee)\n+                cx.type_ptr_to_ext(pointee, address_space)\n             }\n         }\n     }"}, {"sha": "d9f8170a3cffa0617172e93f5d0d5d4a0038efdd", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -849,14 +849,16 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n /// Helper function to get the LLVM type for a Scalar. Pointers are returned as\n /// the equivalent integer type.\n fn llvm_asm_scalar_type<'ll>(cx: &CodegenCx<'ll, '_>, scalar: Scalar) -> &'ll Type {\n+    let dl = &cx.tcx.data_layout;\n     match scalar.primitive() {\n         Primitive::Int(Integer::I8, _) => cx.type_i8(),\n         Primitive::Int(Integer::I16, _) => cx.type_i16(),\n         Primitive::Int(Integer::I32, _) => cx.type_i32(),\n         Primitive::Int(Integer::I64, _) => cx.type_i64(),\n         Primitive::F32 => cx.type_f32(),\n         Primitive::F64 => cx.type_f64(),\n-        Primitive::Pointer => cx.type_isize(),\n+        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+        Primitive::Pointer(_) => cx.type_from_integer(dl.ptr_sized_integer()),\n         _ => unreachable!(),\n     }\n }\n@@ -868,6 +870,7 @@ fn llvm_fixup_input<'ll, 'tcx>(\n     reg: InlineAsmRegClass,\n     layout: &TyAndLayout<'tcx>,\n ) -> &'ll Value {\n+    let dl = &bx.tcx.data_layout;\n     match (reg, layout.abi) {\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n             if let Primitive::Int(Integer::I8, _) = s.primitive() {\n@@ -881,8 +884,10 @@ fn llvm_fixup_input<'ll, 'tcx>(\n             let elem_ty = llvm_asm_scalar_type(bx.cx, s);\n             let count = 16 / layout.size.bytes();\n             let vec_ty = bx.cx.type_vector(elem_ty, count);\n-            if let Primitive::Pointer = s.primitive() {\n-                value = bx.ptrtoint(value, bx.cx.type_isize());\n+            // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+            if let Primitive::Pointer(_) = s.primitive() {\n+                let t = bx.type_from_integer(dl.ptr_sized_integer());\n+                value = bx.ptrtoint(value, t);\n             }\n             bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n         }\n@@ -958,7 +963,7 @@ fn llvm_fixup_output<'ll, 'tcx>(\n         }\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n             value = bx.extract_element(value, bx.const_i32(0));\n-            if let Primitive::Pointer = s.primitive() {\n+            if let Primitive::Pointer(_) = s.primitive() {\n                 value = bx.inttoptr(value, layout.llvm_type(bx.cx));\n             }\n             value"}, {"sha": "0f33b98548984877a230edeb0004e8ba403e7132", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -511,7 +511,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         bx.range_metadata(load, scalar.valid_range(bx));\n                     }\n                 }\n-                abi::Pointer => {\n+                abi::Pointer(_) => {\n                     if !scalar.valid_range(bx).contains(0) {\n                         bx.nonnull_metadata(load);\n                     }"}, {"sha": "edb1c160626ea7cf3a24b89e9d61541bbd887b17", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -236,7 +236,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             Scalar::Int(int) => {\n                 let data = int.assert_bits(layout.size(self));\n                 let llval = self.const_uint_big(self.type_ix(bitsize), data);\n-                if layout.primitive() == Pointer {\n+                if matches!(layout.primitive(), Pointer(_)) {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)\n@@ -284,7 +284,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         1,\n                     )\n                 };\n-                if layout.primitive() != Pointer {\n+                if !matches!(layout.primitive(), Pointer(_)) {\n                     unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)"}, {"sha": "cad3c5d87b73c6bf445a15a08bf8f99702f40e2f", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -13,17 +13,15 @@ use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ConstAllocation, ErrorHandled, GlobalAlloc, InitChunk, Pointer,\n+    read_target_uint, Allocation, ConstAllocation, ErrorHandled, InitChunk, Pointer,\n     Scalar as InterpScalar,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::Lto;\n-use rustc_target::abi::{\n-    AddressSpace, Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange,\n-};\n+use rustc_target::abi::{Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange};\n use std::ops::Range;\n \n pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n@@ -98,20 +96,15 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n \n-        let address_space = match cx.tcx.global_alloc(alloc_id) {\n-            GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n-            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) | GlobalAlloc::VTable(..) => {\n-                AddressSpace::DATA\n-            }\n-        };\n+        let address_space = cx.tcx.global_alloc(alloc_id).address_space(cx);\n \n         llvals.push(cx.scalar_to_backend(\n             InterpScalar::from_pointer(\n                 Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n             Scalar::Initialized {\n-                value: Primitive::Pointer,\n+                value: Primitive::Pointer(address_space),\n                 valid_range: WrappingRange::full(dl.pointer_size),\n             },\n             cx.type_i8p_ext(address_space),"}, {"sha": "54e850f25996b0d1894b038e197480f581ab630e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -122,7 +122,8 @@ fn tag_base_type<'ll, 'tcx>(\n                 Primitive::Int(t, _) => t,\n                 Primitive::F32 => Integer::I32,\n                 Primitive::F64 => Integer::I64,\n-                Primitive::Pointer => {\n+                // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                Primitive::Pointer(_) => {\n                     // If the niche is the NULL value of a reference, then `discr_enum_ty` will be\n                     // a RawPtr. CodeView doesn't know what to do with enums whose base type is a\n                     // pointer so we fix this up to just be `usize`."}, {"sha": "dd89c4c59c14d83e0ac639f5557e628b26ac17ff", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -149,7 +149,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                                     emit_va_arg(self, args[0], ret_ty)\n                                 }\n                             }\n-                            Primitive::F64 | Primitive::Pointer => {\n+                            Primitive::F64 | Primitive::Pointer(_) => {\n                                 emit_va_arg(self, args[0], ret_ty)\n                             }\n                             // `va_arg` should never be used with the return type f32."}, {"sha": "c73d233b767a41cb20720ebd1696a7a9ec0f04b0", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Ty, TypeVisitable};\n-use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n+use rustc_target::abi::{Abi, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{PointeeInfo, Scalar, Size, TyAbiInterface, Variants};\n use smallvec::{smallvec, SmallVec};\n@@ -312,14 +312,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             Int(i, _) => cx.type_from_integer(i),\n             F32 => cx.type_f32(),\n             F64 => cx.type_f64(),\n-            Pointer => {\n+            Pointer(address_space) => {\n                 // If we know the alignment, pick something better than i8.\n-                let (pointee, address_space) =\n-                    if let Some(pointee) = self.pointee_info_at(cx, offset) {\n-                        (cx.type_pointee_for_align(pointee.align), pointee.address_space)\n-                    } else {\n-                        (cx.type_i8(), AddressSpace::DATA)\n-                    };\n+                let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n+                    cx.type_pointee_for_align(pointee.align)\n+                } else {\n+                    cx.type_i8()\n+                };\n                 cx.type_ptr_to_ext(pointee, address_space)\n             }\n         }"}, {"sha": "e2106f8b5c57042f211fc765128554e3c494dbb5", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -1801,8 +1801,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         match (src.layout.abi, dst.layout.abi) {\n             (abi::Abi::Scalar(src_scalar), abi::Abi::Scalar(dst_scalar)) => {\n                 // HACK(eddyb) LLVM doesn't like `bitcast`s between pointers and non-pointers.\n-                let src_is_ptr = src_scalar.primitive() == abi::Pointer;\n-                let dst_is_ptr = dst_scalar.primitive() == abi::Pointer;\n+                let src_is_ptr = matches!(src_scalar.primitive(), abi::Pointer(_));\n+                let dst_is_ptr = matches!(dst_scalar.primitive(), abi::Pointer(_));\n                 if src_is_ptr == dst_is_ptr {\n                     assert_eq!(src.layout.size, dst.layout.size);\n "}, {"sha": "cf02f59f67b97c3470c281d511ed4ade1390ec84", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, FieldsShape, Int, TagEncoding};\n+use rustc_target::abi::{Abi, Align, FieldsShape, Int, Pointer, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n #[derive(Copy, Clone, Debug)]\n@@ -209,6 +209,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         cast_to: Ty<'tcx>,\n     ) -> V {\n+        let dl = &bx.tcx().data_layout;\n         let cast_to_layout = bx.cx().layout_of(cast_to);\n         let cast_to_size = cast_to_layout.layout.size();\n         let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n@@ -250,12 +251,14 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n                 // Cast to an integer so we don't have to treat a pointer as a\n                 // special case.\n-                let (tag, tag_llty) = if tag_scalar.primitive().is_ptr() {\n-                    let t = bx.type_isize();\n-                    let tag = bx.ptrtoint(tag_imm, t);\n-                    (tag, t)\n-                } else {\n-                    (tag_imm, bx.cx().immediate_backend_type(tag_op.layout))\n+                let (tag, tag_llty) = match tag_scalar.primitive() {\n+                    // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                    Pointer(_) => {\n+                        let t = bx.type_from_integer(dl.ptr_sized_integer());\n+                        let tag = bx.ptrtoint(tag_imm, t);\n+                        (tag, t)\n+                    }\n+                    _ => (tag_imm, bx.cx().immediate_backend_type(tag_op.layout)),\n                 };\n \n                 let tag_size = tag_scalar.size(bx.cx());"}, {"sha": "a1b3985dce4e6ecfa27ff80b225e28e28f1d9d91", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -319,7 +319,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n                 let scalar = alloc.read_scalar(\n                     alloc_range(Size::ZERO, size),\n-                    /*read_provenance*/ s.is_ptr(),\n+                    /*read_provenance*/ matches!(s, abi::Pointer(_)),\n                 )?;\n                 Some(ImmTy { imm: scalar.into(), layout: mplace.layout })\n             }\n@@ -335,11 +335,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n                 let a_val = alloc.read_scalar(\n                     alloc_range(Size::ZERO, a_size),\n-                    /*read_provenance*/ a.is_ptr(),\n+                    /*read_provenance*/ matches!(a, abi::Pointer(_)),\n                 )?;\n                 let b_val = alloc.read_scalar(\n                     alloc_range(b_offset, b_size),\n-                    /*read_provenance*/ b.is_ptr(),\n+                    /*read_provenance*/ matches!(b, abi::Pointer(_)),\n                 )?;\n                 Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout })\n             }"}, {"sha": "2c76582f2ec8fbd14b9b911b4f922498a747b4d0", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -38,6 +38,7 @@ fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_transmute(&self, from: Ty<'tcx>, to: Ty<'tcx>, hir_id: HirId) {\n         let tcx = self.tcx;\n+        let dl = &tcx.data_layout;\n         let span = tcx.hir().span(hir_id);\n         let normalize = |ty| {\n             let ty = self.resolve_vars_if_possible(ty);\n@@ -69,7 +70,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Special-case transmuting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n             let from = unpack_option_like(tcx, from);\n-            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer.size(&tcx) {\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer(dl.instruction_address_space).size(&tcx) {\n                 struct_span_err!(tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n                     .note(&format!(\"source type: {from}\"))\n                     .note(&format!(\"target type: {to}\"))"}, {"sha": "b0975616b6151546773253fb88af57da891f678f", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -110,7 +110,7 @@ use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_serialize::{Decodable, Encodable};\n-use rustc_target::abi::Endian;\n+use rustc_target::abi::{AddressSpace, Endian, HasDataLayout};\n \n use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -438,6 +438,17 @@ impl<'tcx> GlobalAlloc<'tcx> {\n             _ => bug!(\"expected vtable, got {:?}\", self),\n         }\n     }\n+\n+    /// The address space that this `GlobalAlloc` should be placed in.\n+    #[inline]\n+    pub fn address_space(&self, cx: &impl HasDataLayout) -> AddressSpace {\n+        match self {\n+            GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n+            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) | GlobalAlloc::VTable(..) => {\n+                AddressSpace::DATA\n+            }\n+        }\n+    }\n }\n \n pub(crate) struct AllocMap<'tcx> {"}, {"sha": "66b9d96e69577606abaec0bd90a1c0be9a723761", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 110, "deletions": 112, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -128,7 +128,8 @@ impl PrimitiveExt for Primitive {\n             Int(i, signed) => i.to_ty(tcx, signed),\n             F32 => tcx.types.f32,\n             F64 => tcx.types.f64,\n-            Pointer => tcx.mk_mut_ptr(tcx.mk_unit()),\n+            // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+            Pointer(_) => tcx.mk_mut_ptr(tcx.mk_unit()),\n         }\n     }\n \n@@ -138,7 +139,11 @@ impl PrimitiveExt for Primitive {\n     fn to_int_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n-            Pointer => tcx.types.usize,\n+            // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+            Pointer(_) => {\n+                let signed = false;\n+                tcx.data_layout().ptr_sized_integer().to_ty(tcx, signed)\n+            }\n             F32 | F64 => bug!(\"floats do not have an int type\"),\n         }\n     }\n@@ -812,132 +817,125 @@ where\n         let tcx = cx.tcx();\n         let param_env = cx.param_env();\n \n-        let addr_space_of_ty = |ty: Ty<'tcx>| {\n-            if ty.is_fn() { cx.data_layout().instruction_address_space } else { AddressSpace::DATA }\n-        };\n-\n-        let pointee_info = match *this.ty.kind() {\n-            ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n-                    size: layout.size,\n-                    align: layout.align.abi,\n-                    safe: None,\n-                    address_space: addr_space_of_ty(mt.ty),\n-                })\n-            }\n-            ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n-                tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| PointeeInfo {\n-                    size: layout.size,\n-                    align: layout.align.abi,\n-                    safe: None,\n-                    address_space: cx.data_layout().instruction_address_space,\n-                })\n-            }\n-            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n-                let address_space = addr_space_of_ty(ty);\n-                let kind = if tcx.sess.opts.optimize == OptLevel::No {\n-                    // Use conservative pointer kind if not optimizing. This saves us the\n-                    // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n-                    // attributes in LLVM have compile-time cost even in unoptimized builds).\n-                    PointerKind::SharedMutable\n-                } else {\n-                    match mt {\n-                        hir::Mutability::Not => {\n-                            if ty.is_freeze(tcx, cx.param_env()) {\n-                                PointerKind::Frozen\n-                            } else {\n-                                PointerKind::SharedMutable\n+        let pointee_info =\n+            match *this.ty.kind() {\n+                ty::RawPtr(mt) if offset.bytes() == 0 => {\n+                    tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: None,\n+                    })\n+                }\n+                ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n+                    tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| {\n+                        PointeeInfo { size: layout.size, align: layout.align.abi, safe: None }\n+                    })\n+                }\n+                ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n+                    let kind = if tcx.sess.opts.optimize == OptLevel::No {\n+                        // Use conservative pointer kind if not optimizing. This saves us the\n+                        // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n+                        // attributes in LLVM have compile-time cost even in unoptimized builds).\n+                        PointerKind::SharedMutable\n+                    } else {\n+                        match mt {\n+                            hir::Mutability::Not => {\n+                                if ty.is_freeze(tcx, cx.param_env()) {\n+                                    PointerKind::Frozen\n+                                } else {\n+                                    PointerKind::SharedMutable\n+                                }\n                             }\n-                        }\n-                        hir::Mutability::Mut => {\n-                            // References to self-referential structures should not be considered\n-                            // noalias, as another pointer to the structure can be obtained, that\n-                            // is not based-on the original reference. We consider all !Unpin\n-                            // types to be potentially self-referential here.\n-                            if ty.is_unpin(tcx, cx.param_env()) {\n-                                PointerKind::UniqueBorrowed\n-                            } else {\n-                                PointerKind::UniqueBorrowedPinned\n+                            hir::Mutability::Mut => {\n+                                // References to self-referential structures should not be considered\n+                                // noalias, as another pointer to the structure can be obtained, that\n+                                // is not based-on the original reference. We consider all !Unpin\n+                                // types to be potentially self-referential here.\n+                                if ty.is_unpin(tcx, cx.param_env()) {\n+                                    PointerKind::UniqueBorrowed\n+                                } else {\n+                                    PointerKind::UniqueBorrowedPinned\n+                                }\n                             }\n                         }\n-                    }\n-                };\n+                    };\n \n-                tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n-                    size: layout.size,\n-                    align: layout.align.abi,\n-                    safe: Some(kind),\n-                    address_space,\n-                })\n-            }\n+                    tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: Some(kind),\n+                    })\n+                }\n \n-            _ => {\n-                let mut data_variant = match this.variants {\n-                    // Within the discriminant field, only the niche itself is\n-                    // always initialized, so we only check for a pointer at its\n-                    // offset.\n-                    //\n-                    // If the niche is a pointer, it's either valid (according\n-                    // to its type), or null (which the niche field's scalar\n-                    // validity range encodes). This allows using\n-                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n-                    // this will continue to work as long as we don't start\n-                    // using more niches than just null (e.g., the first page of\n-                    // the address space, or unaligned pointers).\n-                    Variants::Multiple {\n-                        tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n-                        tag_field,\n-                        ..\n-                    } if this.fields.offset(tag_field) == offset => {\n-                        Some(this.for_variant(cx, untagged_variant))\n-                    }\n-                    _ => Some(this),\n-                };\n+                _ => {\n+                    let mut data_variant = match this.variants {\n+                        // Within the discriminant field, only the niche itself is\n+                        // always initialized, so we only check for a pointer at its\n+                        // offset.\n+                        //\n+                        // If the niche is a pointer, it's either valid (according\n+                        // to its type), or null (which the niche field's scalar\n+                        // validity range encodes). This allows using\n+                        // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n+                        // this will continue to work as long as we don't start\n+                        // using more niches than just null (e.g., the first page of\n+                        // the address space, or unaligned pointers).\n+                        Variants::Multiple {\n+                            tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n+                            tag_field,\n+                            ..\n+                        } if this.fields.offset(tag_field) == offset => {\n+                            Some(this.for_variant(cx, untagged_variant))\n+                        }\n+                        _ => Some(this),\n+                    };\n \n-                if let Some(variant) = data_variant {\n-                    // We're not interested in any unions.\n-                    if let FieldsShape::Union(_) = variant.fields {\n-                        data_variant = None;\n+                    if let Some(variant) = data_variant {\n+                        // We're not interested in any unions.\n+                        if let FieldsShape::Union(_) = variant.fields {\n+                            data_variant = None;\n+                        }\n                     }\n-                }\n \n-                let mut result = None;\n-\n-                if let Some(variant) = data_variant {\n-                    let ptr_end = offset + Pointer.size(cx);\n-                    for i in 0..variant.fields.count() {\n-                        let field_start = variant.fields.offset(i);\n-                        if field_start <= offset {\n-                            let field = variant.field(cx, i);\n-                            result = field.to_result().ok().and_then(|field| {\n-                                if ptr_end <= field_start + field.size {\n-                                    // We found the right field, look inside it.\n-                                    let field_info =\n-                                        field.pointee_info_at(cx, offset - field_start);\n-                                    field_info\n-                                } else {\n-                                    None\n+                    let mut result = None;\n+\n+                    if let Some(variant) = data_variant {\n+                        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                        // (requires passing in the expected address space from the caller)\n+                        let ptr_end = offset + Pointer(AddressSpace::DATA).size(cx);\n+                        for i in 0..variant.fields.count() {\n+                            let field_start = variant.fields.offset(i);\n+                            if field_start <= offset {\n+                                let field = variant.field(cx, i);\n+                                result = field.to_result().ok().and_then(|field| {\n+                                    if ptr_end <= field_start + field.size {\n+                                        // We found the right field, look inside it.\n+                                        let field_info =\n+                                            field.pointee_info_at(cx, offset - field_start);\n+                                        field_info\n+                                    } else {\n+                                        None\n+                                    }\n+                                });\n+                                if result.is_some() {\n+                                    break;\n                                 }\n-                            });\n-                            if result.is_some() {\n-                                break;\n                             }\n                         }\n                     }\n-                }\n \n-                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n-                if let Some(ref mut pointee) = result {\n-                    if let ty::Adt(def, _) = this.ty.kind() {\n-                        if def.is_box() && offset.bytes() == 0 {\n-                            pointee.safe = Some(PointerKind::UniqueOwned);\n+                    // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n+                    if let Some(ref mut pointee) = result {\n+                        if let ty::Adt(def, _) = this.ty.kind() {\n+                            if def.is_box() && offset.bytes() == 0 {\n+                                pointee.safe = Some(PointerKind::UniqueOwned);\n+                            }\n                         }\n                     }\n-                }\n \n-                result\n-            }\n-        };\n+                    result\n+                }\n+            };\n \n         debug!(\n             \"pointee_info_at (offset={:?}, type kind: {:?}) => {:?}\","}, {"sha": "247256f076ba9b195c6cbe1286387b4ba7a9c3f8", "filename": "compiler/rustc_target/src/abi/call/loongarch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -39,7 +39,7 @@ where\n {\n     match arg_layout.abi {\n         Abi::Scalar(scalar) => match scalar.primitive() {\n-            abi::Int(..) | abi::Pointer => {\n+            abi::Int(..) | abi::Pointer(_) => {\n                 if arg_layout.size.bits() > xlen {\n                     return Err(CannotUseFpConv);\n                 }"}, {"sha": "a0730fbb650dc9b4527882bbe232afa1ed17201b", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -346,7 +346,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             // The primitive for this algorithm.\n             Abi::Scalar(scalar) => {\n                 let kind = match scalar.primitive() {\n-                    abi::Int(..) | abi::Pointer => RegKind::Integer,\n+                    abi::Int(..) | abi::Pointer(_) => RegKind::Integer,\n                     abi::F32 | abi::F64 => RegKind::Float,\n                 };\n                 Ok(HomogeneousAggregate::Homogeneous(Reg { kind, size: self.size }))"}, {"sha": "d90dce2a08785cbd2e6995bfb5f16fd9acc77f7d", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -45,7 +45,7 @@ where\n {\n     match arg_layout.abi {\n         Abi::Scalar(scalar) => match scalar.primitive() {\n-            abi::Int(..) | abi::Pointer => {\n+            abi::Int(..) | abi::Pointer(_) => {\n                 if arg_layout.size.bits() > xlen {\n                     return Err(CannotUseFpConv);\n                 }"}, {"sha": "cbed5b4afc134931a0ba5851f90218399775b5b4", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -20,7 +20,7 @@ where\n {\n     let dl = cx.data_layout();\n \n-    if !scalar.primitive().is_float() {\n+    if !matches!(scalar.primitive(), abi::F32 | abi::F64) {\n         return data;\n     }\n \n@@ -83,11 +83,11 @@ where\n         (abi::F32, _) => offset += Reg::f32().size,\n         (_, abi::F64) => offset += Reg::f64().size,\n         (abi::Int(i, _signed), _) => offset += i.size(),\n-        (abi::Pointer, _) => offset += Reg::i64().size,\n+        (abi::Pointer(_), _) => offset += Reg::i64().size,\n         _ => {}\n     }\n \n-    if (offset.bytes() % 4) != 0 && scalar2.primitive().is_float() {\n+    if (offset.bytes() % 4) != 0 && matches!(scalar2.primitive(), abi::F32 | abi::F64) {\n         offset += Size::from_bytes(4 - (offset.bytes() % 4));\n     }\n     data = arg_scalar(cx, scalar2, offset, data);"}, {"sha": "9427f27d1b7bb327893a287c1d83db37822159b3", "filename": "compiler/rustc_target/src/abi/call/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -50,7 +50,7 @@ where\n             Abi::Uninhabited => return Ok(()),\n \n             Abi::Scalar(scalar) => match scalar.primitive() {\n-                abi::Int(..) | abi::Pointer => Class::Int,\n+                abi::Int(..) | abi::Pointer(_) => Class::Int,\n                 abi::F32 | abi::F64 => Class::Sse,\n             },\n "}, {"sha": "39761baf1bc2919401d823dc4d17aaae56d59195", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -129,7 +129,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n         C: HasDataLayout,\n     {\n         match self.abi {\n-            Abi::Scalar(scalar) => scalar.primitive().is_float(),\n+            Abi::Scalar(scalar) => matches!(scalar.primitive(), F32 | F64),\n             Abi::Aggregate { .. } => {\n                 if self.fields.count() == 1 && self.fields.offset(0).bytes() == 0 {\n                     self.field(cx, 0).is_single_fp_element(cx)"}, {"sha": "e47e68e0670b9475a19080561dade3f4098940c3", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -244,7 +244,7 @@ fn adjust_for_rust_scalar<'tcx>(\n     }\n \n     // Only pointer types handled below.\n-    let Scalar::Initialized { value: Pointer, valid_range} = scalar else { return };\n+    let Scalar::Initialized { value: Pointer(_), valid_range} = scalar else { return };\n \n     if !valid_range.contains(0) {\n         attrs.set(ArgAttribute::NonNull);\n@@ -479,7 +479,7 @@ fn fn_abi_adjust_for_abi<'tcx>(\n             }\n \n             let size = arg.layout.size;\n-            if arg.layout.is_unsized() || size > Pointer.size(cx) {\n+            if arg.layout.is_unsized() || size > Pointer(AddressSpace::DATA).size(cx) {\n                 arg.make_indirect();\n             } else {\n                 // We want to pass small aggregates as immediates, but using"}, {"sha": "0f25579c7bfa19f8fc609ce9adabd167f9e37116", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -134,7 +134,7 @@ fn layout_of_uncached<'tcx>(\n             ty::FloatTy::F64 => F64,\n         }),\n         ty::FnPtr(_) => {\n-            let mut ptr = scalar_unit(Pointer);\n+            let mut ptr = scalar_unit(Pointer(dl.instruction_address_space));\n             ptr.valid_range_mut().start = 1;\n             tcx.intern_layout(LayoutS::scalar(cx, ptr))\n         }\n@@ -144,7 +144,7 @@ fn layout_of_uncached<'tcx>(\n \n         // Potentially-wide pointers.\n         ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-            let mut data_ptr = scalar_unit(Pointer);\n+            let mut data_ptr = scalar_unit(Pointer(AddressSpace::DATA));\n             if !ty.is_unsafe_ptr() {\n                 data_ptr.valid_range_mut().start = 1;\n             }\n@@ -178,7 +178,7 @@ fn layout_of_uncached<'tcx>(\n                     }\n                     ty::Slice(_) | ty::Str => scalar_unit(Int(dl.ptr_sized_integer(), false)),\n                     ty::Dynamic(..) => {\n-                        let mut vtable = scalar_unit(Pointer);\n+                        let mut vtable = scalar_unit(Pointer(AddressSpace::DATA));\n                         vtable.valid_range_mut().start = 1;\n                         vtable\n                     }\n@@ -195,7 +195,7 @@ fn layout_of_uncached<'tcx>(\n         ty::Dynamic(_, _, ty::DynStar) => {\n             let mut data = scalar_unit(Int(dl.ptr_sized_integer(), false));\n             data.valid_range_mut().start = 0;\n-            let mut vtable = scalar_unit(Pointer);\n+            let mut vtable = scalar_unit(Pointer(AddressSpace::DATA));\n             vtable.valid_range_mut().start = 1;\n             tcx.intern_layout(cx.scalar_pair(data, vtable))\n         }"}, {"sha": "bc11e1081244ad84017d516a76acf4272afab19a", "filename": "tests/codegen/avr/avr-func-addrspace.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/tests%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8b5e5d9dba8a8dce32c89882c40e28de2134cc5/tests%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Favr%2Favr-func-addrspace.rs?ref=a8b5e5d9dba8a8dce32c89882c40e28de2134cc5", "patch": "@@ -109,3 +109,28 @@ pub unsafe fn transmute_fn_ptr_to_data(x: fn()) -> *const () {\n     // as long as it doesn't cause a verifier error by using `bitcast`.\n     transmute(x)\n }\n+\n+pub enum Either<T, U> { A(T), B(U) }\n+\n+// Previously, we would codegen this as passing/returning a scalar pair of `{ i8, ptr }`,\n+// with the `ptr` field representing both `&i32` and `fn()` depending on the variant.\n+// This is incorrect, because `fn()` should be `ptr addrspace(1)`, not `ptr`.\n+\n+// CHECK: define{{.+}}void @should_not_combine_addrspace({{.+\\*|ptr}}{{.+}}sret{{.+}}%0, {{.+\\*|ptr}}{{.+}}%x)\n+#[no_mangle]\n+#[inline(never)]\n+pub fn should_not_combine_addrspace(x: Either<&i32, fn()>) -> Either<&i32, fn()> {\n+    x\n+}\n+\n+// The incorrectness described above would result in us producing (after optimizations)\n+// a `ptrtoint`/`inttoptr` roundtrip to convert from `ptr` to `ptr addrspace(1)`.\n+\n+// CHECK-LABEL: @call_with_fn_ptr\n+#[no_mangle]\n+pub fn call_with_fn_ptr<'a>(f: fn()) -> Either<&'a i32, fn()> {\n+    // CHECK-NOT: ptrtoint\n+    // CHECK-NOT: inttoptr\n+    // CHECK: call addrspace(1) void @should_not_combine_addrspace\n+    should_not_combine_addrspace(Either::B(f))\n+}"}]}