{"sha": "327b9be9e98288dfe1a0d6a96804cb0529ea6222", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyN2I5YmU5ZTk4Mjg4ZGZlMWEwZDZhOTY4MDRjYjA1MjllYTYyMjI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-04-05T23:01:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-05T23:01:04Z"}, "message": "Rollup merge of #40561 - arthurprs:hm-adapt2, r=pczarn\n\nSimplify HashMap Bucket interface\n\n> Simplify HashMap Bucket interface\n>\n> * Store capacity_mask instead of capacity\n> * Move bucket index into RawBucket\n> * Valid bucket index is now always within [0..table_capacity)\n> * Simplify iterators by moving logic into RawBuckets\n> * Clone RawTable using RawBucket\n> * Make retain aware of the number of elements\n\nThe idea was to put idx in RawBucket instead of the other Bucket types and simplify next() and prev() as much as possible. The rest was a side-effect of that change, except maybe the last 2.\n\nThis change makes iteration and other next/prev() heavy operations noticeably faster. Clone is way faster.\n\n```\n\u279c  hashmap2 git:(adapt) \u2717 cargo benchcmp pre:: adp:: bench.txt\n name                        pre:: ns/iter  adp:: ns/iter  diff ns/iter   diff %\n clone_10_000                74,364         39,736              -34,628  -46.57%\n grow_100_000                8,343,553      8,233,785          -109,768   -1.32%\n grow_10_000                 817,825        723,958             -93,867  -11.48%\n grow_big_value_100_000      18,418,979     17,906,186         -512,793   -2.78%\n grow_big_value_10_000       1,219,242      1,103,334          -115,908   -9.51%\n insert_1000                 74,546         58,343              -16,203  -21.74%\n insert_100_000              6,743,770      6,238,017          -505,753   -7.50%\n insert_10_000               798,079        719,123             -78,956   -9.89%\n insert_1_000_000            275,215,605    266,975,875      -8,239,730   -2.99%\n insert_int_bigvalue_10_000  1,517,387      1,419,838           -97,549   -6.43%\n insert_str_10_000           316,179        278,896             -37,283  -11.79%\n insert_string_10_000        770,927        747,449             -23,478   -3.05%\n iter_keys_100_000           386,099        333,104             -52,995  -13.73%\n iterate_100_000             387,320        355,707             -31,613   -8.16%\n lookup_100_000              206,757        193,063             -13,694   -6.62%\n lookup_100_000_unif         219,366        193,180             -26,186  -11.94%\n lookup_1_000_000            206,456        205,716                -740   -0.36%\n lookup_1_000_000_unif       659,934        629,659             -30,275   -4.59%\n lru_sim                     20,194,334     18,442,149       -1,752,185   -8.68%\n merge_shuffle               1,168,044      1,063,055          -104,989   -8.99%\n```\n\nNote 2: I may have messed up porting the diff, let's see what CI says.", "tree": {"sha": "6af1e3349ba4e2004dd73b6e41b15c90e1b2d459", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6af1e3349ba4e2004dd73b6e41b15c90e1b2d459"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/327b9be9e98288dfe1a0d6a96804cb0529ea6222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/327b9be9e98288dfe1a0d6a96804cb0529ea6222", "html_url": "https://github.com/rust-lang/rust/commit/327b9be9e98288dfe1a0d6a96804cb0529ea6222", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/327b9be9e98288dfe1a0d6a96804cb0529ea6222/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "540fc2c546797cab48565c07e5de78a062c5464f", "url": "https://api.github.com/repos/rust-lang/rust/commits/540fc2c546797cab48565c07e5de78a062c5464f", "html_url": "https://github.com/rust-lang/rust/commit/540fc2c546797cab48565c07e5de78a062c5464f"}, {"sha": "f07ebd609796226e672737e502525fbbf5e27940", "url": "https://api.github.com/repos/rust-lang/rust/commits/f07ebd609796226e672737e502525fbbf5e27940", "html_url": "https://github.com/rust-lang/rust/commit/f07ebd609796226e672737e502525fbbf5e27940"}], "stats": {"total": 356, "additions": 165, "deletions": 191}, "files": [{"sha": "a06299eaefe0ad47ac8068c65747bb1396fdbd5d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/327b9be9e98288dfe1a0d6a96804cb0529ea6222/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/327b9be9e98288dfe1a0d6a96804cb0529ea6222/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=327b9be9e98288dfe1a0d6a96804cb0529ea6222", "patch": "@@ -472,7 +472,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>)\n     }\n \n     // Now we've done all our shifting. Return the value we grabbed earlier.\n-    (retkey, retval, gap.into_bucket().into_table())\n+    (retkey, retval, gap.into_table())\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n@@ -485,14 +485,14 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                                 mut key: K,\n                                 mut val: V)\n                                 -> FullBucketMut<'a, K, V> {\n-    let start_index = bucket.index();\n     let size = bucket.table().size();\n-    // Save the *starting point*.\n-    let mut bucket = bucket.stash();\n+    let raw_capacity = bucket.table().capacity();\n     // There can be at most `size - dib` buckets to displace, because\n     // in the worst case, there are `size` elements and we already are\n     // `displacement` buckets away from the initial one.\n-    let idx_end = start_index + size - bucket.displacement();\n+    let idx_end = (bucket.index() + size - bucket.displacement()) % raw_capacity;\n+    // Save the *starting point*.\n+    let mut bucket = bucket.stash();\n \n     loop {\n         let (old_hash, old_key, old_val) = bucket.replace(hash, key, val);\n@@ -568,11 +568,8 @@ impl<K, V, S> HashMap<K, V, S>\n     // The caller should ensure that invariants by Robin Hood Hashing hold\n     // and that there's space in the underlying table.\n     fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n-        let raw_cap = self.raw_capacity();\n         let mut buckets = Bucket::new(&mut self.table, hash);\n-        // note that buckets.index() keeps increasing\n-        // even if the pointer wraps back to the first bucket.\n-        let limit_bucket = buckets.index() + raw_cap;\n+        let start_index = buckets.index();\n \n         loop {\n             // We don't need to compare hashes for value swap.\n@@ -585,7 +582,7 @@ impl<K, V, S> HashMap<K, V, S>\n                 Full(b) => b.into_bucket(),\n             };\n             buckets.next();\n-            debug_assert!(buckets.index() < limit_bucket);\n+            debug_assert!(buckets.index() != start_index);\n         }\n     }\n }\n@@ -1244,24 +1241,25 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(&K, &mut V) -> bool\n     {\n-        if self.table.capacity() == 0 || self.table.size() == 0 {\n+        if self.table.size() == 0 {\n             return;\n         }\n+        let mut elems_left = self.table.size();\n         let mut bucket = Bucket::head_bucket(&mut self.table);\n         bucket.prev();\n-        let tail = bucket.index();\n-        loop {\n+        let start_index = bucket.index();\n+        while elems_left != 0 {\n             bucket = match bucket.peek() {\n                 Full(mut full) => {\n+                    elems_left -= 1;\n                     let should_remove = {\n                         let (k, v) = full.read_mut();\n                         !f(k, v)\n                     };\n                     if should_remove {\n-                        let prev_idx = full.index();\n                         let prev_raw = full.raw();\n                         let (_, _, t) = pop_internal(full);\n-                        Bucket::new_from(prev_raw, prev_idx, t)\n+                        Bucket::new_from(prev_raw, t)\n                     } else {\n                         full.into_bucket()\n                     }\n@@ -1271,9 +1269,7 @@ impl<K, V, S> HashMap<K, V, S>\n                 }\n             };\n             bucket.prev();  // reverse iteration\n-            if bucket.index() == tail {\n-                break;\n-            }\n+            debug_assert!(elems_left == 0 || bucket.index() != start_index);\n         }\n     }\n }"}, {"sha": "9623706548b322d32c9e2a887e92cf6dbedd810d", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 151, "deletions": 173, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/327b9be9e98288dfe1a0d6a96804cb0529ea6222/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/327b9be9e98288dfe1a0d6a96804cb0529ea6222/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=327b9be9e98288dfe1a0d6a96804cb0529ea6222", "patch": "@@ -113,7 +113,7 @@ impl TaggedHashUintPtr {\n /// when the RawTable is created and is accessible with the `tag` and `set_tag`\n /// functions.\n pub struct RawTable<K, V> {\n-    capacity: usize,\n+    capacity_mask: usize,\n     size: usize,\n     hashes: TaggedHashUintPtr,\n \n@@ -125,10 +125,13 @@ pub struct RawTable<K, V> {\n unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}\n unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n+// An unsafe view of a RawTable bucket\n+// Valid indexes are within [0..table_capacity)\n pub struct RawBucket<K, V> {\n-    hash: *mut HashUint,\n+    hash_start: *mut HashUint,\n     // We use *const to ensure covariance with respect to K and V\n-    pair: *const (K, V),\n+    pair_start: *const (K, V),\n+    idx: usize,\n     _marker: marker::PhantomData<(K, V)>,\n }\n \n@@ -141,7 +144,6 @@ impl<K, V> Clone for RawBucket<K, V> {\n \n pub struct Bucket<K, V, M> {\n     raw: RawBucket<K, V>,\n-    idx: usize,\n     table: M,\n }\n \n@@ -154,13 +156,11 @@ impl<K, V, M: Copy> Clone for Bucket<K, V, M> {\n \n pub struct EmptyBucket<K, V, M> {\n     raw: RawBucket<K, V>,\n-    idx: usize,\n     table: M,\n }\n \n pub struct FullBucket<K, V, M> {\n     raw: RawBucket<K, V>,\n-    idx: usize,\n     table: M,\n }\n \n@@ -232,13 +232,17 @@ fn can_alias_safehash_as_hash() {\n     assert_eq!(size_of::<SafeHash>(), size_of::<HashUint>())\n }\n \n+// RawBucket methods are unsafe as it's possible to\n+// make a RawBucket point to invalid memory using safe code.\n impl<K, V> RawBucket<K, V> {\n-    unsafe fn offset(self, count: isize) -> RawBucket<K, V> {\n-        RawBucket {\n-            hash: self.hash.offset(count),\n-            pair: self.pair.offset(count),\n-            _marker: marker::PhantomData,\n-        }\n+    unsafe fn hash(&self) -> *mut HashUint {\n+        self.hash_start.offset(self.idx as isize)\n+    }\n+    unsafe fn pair(&self) -> *mut (K, V) {\n+        self.pair_start.offset(self.idx as isize) as *mut (K, V)\n+    }\n+    unsafe fn hash_pair(&self) -> (*mut HashUint, *mut (K, V)) {\n+        (self.hash(), self.pair())\n     }\n }\n \n@@ -258,7 +262,7 @@ impl<K, V, M> FullBucket<K, V, M> {\n     }\n     /// Get the raw index.\n     pub fn index(&self) -> usize {\n-        self.idx\n+        self.raw.idx\n     }\n     /// Get the raw bucket.\n     pub fn raw(&self) -> RawBucket<K, V> {\n@@ -280,7 +284,7 @@ impl<K, V, M> EmptyBucket<K, V, M> {\n impl<K, V, M> Bucket<K, V, M> {\n     /// Get the raw index.\n     pub fn index(&self) -> usize {\n-        self.idx\n+        self.raw.idx\n     }\n     /// get the table.\n     pub fn into_table(self) -> M {\n@@ -331,12 +335,11 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as usize)\n     }\n \n-    pub fn new_from(r: RawBucket<K, V>, i: usize, t: M)\n+    pub fn new_from(r: RawBucket<K, V>, t: M)\n         -> Bucket<K, V, M>\n     {\n         Bucket {\n             raw: r,\n-            idx: i,\n             table: t,\n         }\n     }\n@@ -346,18 +349,16 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         // This is an uncommon case though, so avoid it in release builds.\n         debug_assert!(table.capacity() > 0,\n                       \"Table should have capacity at this point\");\n-        let ib_index = ib_index & (table.capacity() - 1);\n+        let ib_index = ib_index & table.capacity_mask;\n         Bucket {\n-            raw: unsafe { table.first_bucket_raw().offset(ib_index as isize) },\n-            idx: ib_index,\n+            raw: table.raw_bucket_at(ib_index),\n             table: table,\n         }\n     }\n \n     pub fn first(table: M) -> Bucket<K, V, M> {\n         Bucket {\n-            raw: table.first_bucket_raw(),\n-            idx: 0,\n+            raw: table.raw_bucket_at(0),\n             table: table,\n         }\n     }\n@@ -401,48 +402,30 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n     /// the appropriate types to call most of the other functions in\n     /// this module.\n     pub fn peek(self) -> BucketState<K, V, M> {\n-        match unsafe { *self.raw.hash } {\n+        match unsafe { *self.raw.hash() } {\n             EMPTY_BUCKET => {\n                 Empty(EmptyBucket {\n                     raw: self.raw,\n-                    idx: self.idx,\n                     table: self.table,\n                 })\n             }\n             _ => {\n                 Full(FullBucket {\n                     raw: self.raw,\n-                    idx: self.idx,\n                     table: self.table,\n                 })\n             }\n         }\n     }\n \n-    /// Modifies the bucket pointer in place to make it point to the next slot.\n+    /// Modifies the bucket in place to make it point to the next slot.\n     pub fn next(&mut self) {\n-        self.idx += 1;\n-        let range = self.table.capacity();\n-        // This code is branchless thanks to a conditional move.\n-        let dist = if self.idx & (range - 1) == 0 {\n-            1 - range as isize\n-        } else {\n-            1\n-        };\n-        unsafe {\n-            self.raw = self.raw.offset(dist);\n-        }\n+        self.raw.idx = self.raw.idx.wrapping_add(1) & self.table.capacity_mask;\n     }\n \n-    /// Modifies the bucket pointer in place to make it point to the previous slot.\n+    /// Modifies the bucket in place to make it point to the previous slot.\n     pub fn prev(&mut self) {\n-        let range = self.table.capacity();\n-        let new_idx = self.idx.wrapping_sub(1) & (range - 1);\n-        let dist = (new_idx as isize).wrapping_sub(self.idx as isize);\n-        self.idx = new_idx;\n-        unsafe {\n-            self.raw = self.raw.offset(dist);\n-        }\n+        self.raw.idx = self.raw.idx.wrapping_sub(1) & self.table.capacity_mask;\n     }\n }\n \n@@ -458,15 +441,13 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> EmptyBucket<K, V, M> {\n     pub fn into_bucket(self) -> Bucket<K, V, M> {\n         Bucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n \n     pub fn gap_peek(self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n         let gap = EmptyBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: (),\n         };\n \n@@ -494,31 +475,29 @@ impl<K, V, M> EmptyBucket<K, V, M>\n     /// Use `make_hash` to construct a `SafeHash` to pass to this function.\n     pub fn put(mut self, hash: SafeHash, key: K, value: V) -> FullBucket<K, V, M> {\n         unsafe {\n-            *self.raw.hash = hash.inspect();\n-            ptr::write(self.raw.pair as *mut (K, V), (key, value));\n+            *self.raw.hash() = hash.inspect();\n+            ptr::write(self.raw.pair(), (key, value));\n \n             self.table.borrow_table_mut().size += 1;\n         }\n \n         FullBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n \n     /// Puts given key, remain value uninitialized.\n     /// It is only used for inplacement insertion.\n     pub unsafe fn put_key(mut self, hash: SafeHash, key: K) -> FullBucket<K, V, M> {\n-        *self.raw.hash = hash.inspect();\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        ptr::write(&mut (*pair_mut).0, key);\n+        *self.raw.hash() = hash.inspect();\n+        let pair_ptr = self.raw.pair();\n+        ptr::write(&mut (*pair_ptr).0, key);\n \n         self.table.borrow_table_mut().size += 1;\n \n         FullBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n@@ -536,7 +515,6 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n     pub fn into_bucket(self) -> Bucket<K, V, M> {\n         Bucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self.table,\n         }\n     }\n@@ -546,7 +524,6 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n     pub fn stash(self) -> FullBucket<K, V, Self> {\n         FullBucket {\n             raw: self.raw,\n-            idx: self.idx,\n             table: self,\n         }\n     }\n@@ -560,17 +537,20 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n         // Calculates the distance one has to travel when going from\n         // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n         // if the destination is not reached before the end of the table.\n-        (self.idx.wrapping_sub(self.hash().inspect() as usize)) & (self.table.capacity() - 1)\n+        (self.raw.idx.wrapping_sub(self.hash().inspect() as usize)) & self.table.capacity_mask\n     }\n \n     #[inline]\n     pub fn hash(&self) -> SafeHash {\n-        unsafe { SafeHash { hash: *self.raw.hash } }\n+        unsafe { SafeHash { hash: *self.raw.hash() } }\n     }\n \n     /// Gets references to the key and value at a given index.\n     pub fn read(&self) -> (&K, &V) {\n-        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&(*pair_ptr).0, &(*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -586,11 +566,10 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n         self.table.size -= 1;\n \n         unsafe {\n-            *self.raw.hash = EMPTY_BUCKET;\n-            let (k, v) = ptr::read(self.raw.pair);\n+            *self.raw.hash() = EMPTY_BUCKET;\n+            let (k, v) = ptr::read(self.raw.pair());\n             (EmptyBucket {\n                  raw: self.raw,\n-                 idx: self.idx,\n                  table: self.table,\n              },\n             k,\n@@ -604,9 +583,9 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n     pub unsafe fn remove_key(&mut self) {\n         self.table.size -= 1;\n \n-        *self.raw.hash = EMPTY_BUCKET;\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        ptr::drop_in_place(&mut (*pair_mut).0); // only drop key\n+        *self.raw.hash() = EMPTY_BUCKET;\n+        let pair_ptr = self.raw.pair();\n+        ptr::drop_in_place(&mut (*pair_ptr).0); // only drop key\n     }\n }\n \n@@ -617,8 +596,8 @@ impl<K, V, M> FullBucket<K, V, M>\n {\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n-            let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n-            let (old_key, old_val) = ptr::replace(self.raw.pair as *mut (K, V), (k, v));\n+            let old_hash = ptr::replace(self.raw.hash() as *mut SafeHash, h);\n+            let (old_key, old_val) = ptr::replace(self.raw.pair(), (k, v));\n \n             (old_hash, old_key, old_val)\n         }\n@@ -630,8 +609,10 @@ impl<K, V, M> FullBucket<K, V, M>\n {\n     /// Gets mutable references to the key and value at a given index.\n     pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&mut (*pair_ptr).0, &mut (*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -644,7 +625,10 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// in exchange for this, the returned references have a longer lifetime\n     /// than the references returned by `read()`.\n     pub fn into_refs(self) -> (&'t K, &'t V) {\n-        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&(*pair_ptr).0, &(*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -654,8 +638,10 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// This works similarly to `into_refs`, exchanging a bucket state\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n-        let pair_mut = self.raw.pair as *mut (K, V);\n-        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n+        unsafe {\n+            let pair_ptr = self.raw.pair();\n+            (&mut (*pair_ptr).0, &mut (*pair_ptr).1)\n+        }\n     }\n }\n \n@@ -667,22 +653,23 @@ impl<K, V, M> GapThenFull<K, V, M>\n         &self.full\n     }\n \n-    pub fn into_bucket(self) -> Bucket<K, V, M> {\n-        self.full.into_bucket()\n+    pub fn into_table(self) -> M {\n+        self.full.into_table()\n     }\n \n     pub fn shift(mut self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n         unsafe {\n-            *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(self.full.raw.pair, self.gap.raw.pair as *mut (K, V), 1);\n+            let (gap_hash, gap_pair) = self.gap.raw.hash_pair();\n+            let (full_hash, full_pair) = self.full.raw.hash_pair();\n+            *gap_hash = mem::replace(&mut *full_hash, EMPTY_BUCKET);\n+            ptr::copy_nonoverlapping(full_pair, gap_pair, 1);\n         }\n \n-        let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;\n+        let FullBucket { raw: prev_raw, .. } = self.full;\n \n         match self.full.next().peek() {\n             Full(bucket) => {\n                 self.gap.raw = prev_raw;\n-                self.gap.idx = prev_idx;\n \n                 self.full = bucket;\n \n@@ -761,7 +748,7 @@ impl<K, V> RawTable<K, V> {\n         if capacity == 0 {\n             return RawTable {\n                 size: 0,\n-                capacity: 0,\n+                capacity_mask: capacity.wrapping_sub(1),\n                 hashes: TaggedHashUintPtr::new(EMPTY as *mut HashUint),\n                 marker: marker::PhantomData,\n             };\n@@ -801,25 +788,27 @@ impl<K, V> RawTable<K, V> {\n         let hashes = buffer.offset(hash_offset as isize) as *mut HashUint;\n \n         RawTable {\n-            capacity: capacity,\n+            capacity_mask: capacity.wrapping_sub(1),\n             size: 0,\n             hashes: TaggedHashUintPtr::new(hashes),\n             marker: marker::PhantomData,\n         }\n     }\n \n-    fn first_bucket_raw(&self) -> RawBucket<K, V> {\n-        let hashes_size = self.capacity * size_of::<HashUint>();\n-        let pairs_size = self.capacity * size_of::<(K, V)>();\n+    fn raw_bucket_at(&self, index: usize) -> RawBucket<K, V> {\n+        let hashes_size = self.capacity() * size_of::<HashUint>();\n+        let pairs_size = self.capacity() * size_of::<(K, V)>();\n \n-        let buffer = self.hashes.ptr() as *mut u8;\n         let (pairs_offset, _, oflo) =\n             calculate_offsets(hashes_size, pairs_size, align_of::<(K, V)>());\n         debug_assert!(!oflo, \"capacity overflow\");\n+\n+        let buffer = self.hashes.ptr() as *mut u8;\n         unsafe {\n             RawBucket {\n-                hash: self.hashes.ptr(),\n-                pair: buffer.offset(pairs_offset as isize) as *const _,\n+                hash_start: buffer as *mut HashUint,\n+                pair_start: buffer.offset(pairs_offset as isize) as *const (K, V),\n+                idx: index,\n                 _marker: marker::PhantomData,\n             }\n         }\n@@ -837,7 +826,7 @@ impl<K, V> RawTable<K, V> {\n \n     /// The hashtable's capacity, similar to a vector's.\n     pub fn capacity(&self) -> usize {\n-        self.capacity\n+        self.capacity_mask.wrapping_add(1)\n     }\n \n     /// The number of elements ever `put` in the hashtable, minus the number\n@@ -848,47 +837,45 @@ impl<K, V> RawTable<K, V> {\n \n     fn raw_buckets(&self) -> RawBuckets<K, V> {\n         RawBuckets {\n-            raw: self.first_bucket_raw(),\n-            hashes_end: unsafe { self.hashes.ptr().offset(self.capacity as isize) },\n+            raw: self.raw_bucket_at(0),\n+            elems_left: self.size,\n             marker: marker::PhantomData,\n         }\n     }\n \n     pub fn iter(&self) -> Iter<K, V> {\n         Iter {\n             iter: self.raw_buckets(),\n-            elems_left: self.size(),\n         }\n     }\n \n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         IterMut {\n             iter: self.raw_buckets(),\n-            elems_left: self.size(),\n             _marker: marker::PhantomData,\n         }\n     }\n \n     pub fn into_iter(self) -> IntoIter<K, V> {\n-        let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n+        let RawBuckets { raw, elems_left, .. } = self.raw_buckets();\n         // Replace the marker regardless of lifetime bounds on parameters.\n         IntoIter {\n             iter: RawBuckets {\n                 raw: raw,\n-                hashes_end: hashes_end,\n+                elems_left: elems_left,\n                 marker: marker::PhantomData,\n             },\n             table: self,\n         }\n     }\n \n     pub fn drain(&mut self) -> Drain<K, V> {\n-        let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n+        let RawBuckets { raw, elems_left, .. } = self.raw_buckets();\n         // Replace the marker regardless of lifetime bounds on parameters.\n         Drain {\n             iter: RawBuckets {\n                 raw: raw,\n-                hashes_end: hashes_end,\n+                elems_left: elems_left,\n                 marker: marker::PhantomData,\n             },\n             table: unsafe { Shared::new(self) },\n@@ -900,18 +887,16 @@ impl<K, V> RawTable<K, V> {\n     /// state and should only be used for dropping the table's remaining\n     /// entries. It's used in the implementation of Drop.\n     unsafe fn rev_drop_buckets(&mut self) {\n-        let first_raw = self.first_bucket_raw();\n-        let mut raw = first_raw.offset(self.capacity as isize);\n+        // initialize the raw bucket past the end of the table\n+        let mut raw = self.raw_bucket_at(self.capacity());\n         let mut elems_left = self.size;\n \n         while elems_left != 0 {\n-            debug_assert!(raw.hash != first_raw.hash);\n+            raw.idx -= 1;\n \n-            raw = raw.offset(-1);\n-\n-            if *raw.hash != EMPTY_BUCKET {\n+            if *raw.hash() != EMPTY_BUCKET {\n                 elems_left -= 1;\n-                ptr::drop_in_place(raw.pair as *mut (K, V));\n+                ptr::drop_in_place(raw.pair());\n             }\n         }\n     }\n@@ -931,7 +916,7 @@ impl<K, V> RawTable<K, V> {\n /// this interface is safe, it's not used outside this module.\n struct RawBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n-    hashes_end: *mut HashUint,\n+    elems_left: usize,\n \n     // Strictly speaking, this should be &'a (K,V), but that would\n     // require that K:'a, and we often use RawBuckets<'static...> for\n@@ -946,7 +931,7 @@ impl<'a, K, V> Clone for RawBuckets<'a, K, V> {\n     fn clone(&self) -> RawBuckets<'a, K, V> {\n         RawBuckets {\n             raw: self.raw,\n-            hashes_end: self.hashes_end,\n+            elems_left: self.elems_left,\n             marker: marker::PhantomData,\n         }\n     }\n@@ -957,25 +942,36 @@ impl<'a, K, V> Iterator for RawBuckets<'a, K, V> {\n     type Item = RawBucket<K, V>;\n \n     fn next(&mut self) -> Option<RawBucket<K, V>> {\n-        while self.raw.hash != self.hashes_end {\n+        if self.elems_left == 0 {\n+            return None;\n+        }\n+\n+        loop {\n             unsafe {\n-                // We are swapping out the pointer to a bucket and replacing\n-                // it with the pointer to the next one.\n-                let prev = ptr::replace(&mut self.raw, self.raw.offset(1));\n-                if *prev.hash != EMPTY_BUCKET {\n-                    return Some(prev);\n+                let item = self.raw;\n+                self.raw.idx += 1;\n+                if *item.hash() != EMPTY_BUCKET {\n+                    self.elems_left -= 1;\n+                    return Some(item);\n                 }\n             }\n         }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.elems_left, Some(self.elems_left))\n+    }\n+}\n \n-        None\n+impl<'a, K, V> ExactSizeIterator for RawBuckets<'a, K, V> {\n+    fn len(&self) -> usize {\n+        self.elems_left\n     }\n }\n \n /// Iterator over shared references to entries in a table.\n pub struct Iter<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: usize,\n }\n \n unsafe impl<'a, K: Sync, V: Sync> Sync for Iter<'a, K, V> {}\n@@ -986,16 +982,13 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n     fn clone(&self) -> Iter<'a, K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.elems_left,\n         }\n     }\n }\n \n-\n /// Iterator over mutable references to entries in a table.\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: usize,\n     // To ensure invariance with respect to V\n     _marker: marker::PhantomData<&'a mut V>,\n }\n@@ -1009,7 +1002,6 @@ impl<'a, K: 'a, V: 'a> IterMut<'a, K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.elems_left,\n         }\n     }\n }\n@@ -1027,7 +1019,6 @@ impl<K, V> IntoIter<K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n         Iter {\n             iter: self.iter.clone(),\n-            elems_left: self.table.size,\n         }\n     }\n }\n@@ -1044,11 +1035,8 @@ unsafe impl<'a, K: Send, V: Send> Send for Drain<'a, K, V> {}\n \n impl<'a, K, V> Drain<'a, K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n-        unsafe {\n-            Iter {\n-                iter: self.iter.clone(),\n-                elems_left: (**self.table).size,\n-            }\n+        Iter {\n+            iter: self.iter.clone(),\n         }\n     }\n }\n@@ -1057,64 +1045,65 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.iter.next().map(|bucket| {\n-            self.elems_left -= 1;\n-            unsafe { (&(*bucket.pair).0, &(*bucket.pair).1) }\n+        self.iter.next().map(|raw| unsafe {\n+            let pair_ptr = raw.pair();\n+            (&(*pair_ptr).0, &(*pair_ptr).1)\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.elems_left, Some(self.elems_left))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n     fn len(&self) -> usize {\n-        self.elems_left\n+        self.iter.len()\n     }\n }\n \n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.iter.next().map(|bucket| {\n-            self.elems_left -= 1;\n-            let pair_mut = bucket.pair as *mut (K, V);\n-            unsafe { (&(*pair_mut).0, &mut (*pair_mut).1) }\n+        self.iter.next().map(|raw| unsafe {\n+            let pair_ptr = raw.pair();\n+            (&(*pair_ptr).0, &mut (*pair_ptr).1)\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.elems_left, Some(self.elems_left))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n     fn len(&self) -> usize {\n-        self.elems_left\n+        self.iter.len()\n     }\n }\n \n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (SafeHash, K, V);\n \n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|bucket| {\n+        self.iter.next().map(|raw| {\n             self.table.size -= 1;\n             unsafe {\n-                let (k, v) = ptr::read(bucket.pair);\n-                (SafeHash { hash: *bucket.hash }, k, v)\n+                let (k, v) = ptr::read(raw.pair());\n+                (SafeHash { hash: *raw.hash() }, k, v)\n             }\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = self.table.size();\n-        (size, Some(size))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     fn len(&self) -> usize {\n-        self.table.size()\n+        self.iter().len()\n     }\n }\n \n@@ -1123,23 +1112,21 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|bucket| {\n-            unsafe {\n-                (*self.table.as_mut_ptr()).size -= 1;\n-                let (k, v) = ptr::read(bucket.pair);\n-                (SafeHash { hash: ptr::replace(bucket.hash, EMPTY_BUCKET) }, k, v)\n-            }\n+        self.iter.next().map(|raw| unsafe {\n+            (*self.table.as_mut_ptr()).size -= 1;\n+            let (k, v) = ptr::read(raw.pair());\n+            (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n         })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = unsafe { (**self.table).size() };\n-        (size, Some(size))\n+        self.iter.size_hint()\n     }\n }\n+\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     fn len(&self) -> usize {\n-        unsafe { (**self.table).size() }\n+        self.iter.len()\n     }\n }\n \n@@ -1152,30 +1139,21 @@ impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> {\n impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n     fn clone(&self) -> RawTable<K, V> {\n         unsafe {\n-            let mut new_ht = RawTable::new_uninitialized(self.capacity());\n-\n-            {\n-                let cap = self.capacity();\n-                let mut new_buckets = Bucket::first(&mut new_ht);\n-                let mut buckets = Bucket::first(self);\n-                while buckets.index() != cap {\n-                    match buckets.peek() {\n-                        Full(full) => {\n-                            let (h, k, v) = {\n-                                let (k, v) = full.read();\n-                                (full.hash(), k.clone(), v.clone())\n-                            };\n-                            *new_buckets.raw.hash = h.inspect();\n-                            ptr::write(new_buckets.raw.pair as *mut (K, V), (k, v));\n-                        }\n-                        Empty(..) => {\n-                            *new_buckets.raw.hash = EMPTY_BUCKET;\n-                        }\n-                    }\n-                    new_buckets.next();\n-                    buckets.next();\n+            let cap = self.capacity();\n+            let mut new_ht = RawTable::new_uninitialized(cap);\n+\n+            let mut new_buckets = new_ht.raw_bucket_at(0);\n+            let mut buckets = self.raw_bucket_at(0);\n+            while buckets.idx < cap {\n+                *new_buckets.hash() = *buckets.hash();\n+                if *new_buckets.hash() != EMPTY_BUCKET {\n+                    let pair_ptr = buckets.pair();\n+                    let kv = ((*pair_ptr).0.clone(), (*pair_ptr).1.clone());\n+                    ptr::write(new_buckets.pair(), kv);\n                 }\n-            };\n+                buckets.idx += 1;\n+                new_buckets.idx += 1;\n+            }\n \n             new_ht.size = self.size();\n \n@@ -1186,7 +1164,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n \n unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.capacity == 0 {\n+        if self.capacity() == 0 {\n             return;\n         }\n \n@@ -1202,8 +1180,8 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n             }\n         }\n \n-        let hashes_size = self.capacity * size_of::<HashUint>();\n-        let pairs_size = self.capacity * size_of::<(K, V)>();\n+        let hashes_size = self.capacity() * size_of::<HashUint>();\n+        let pairs_size = self.capacity() * size_of::<(K, V)>();\n         let (align, _, size, oflo) = calculate_allocation(hashes_size,\n                                                           align_of::<HashUint>(),\n                                                           pairs_size,"}]}