{"sha": "0ea22717a1e01fa535534b85a5347a7e49fc79de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYTIyNzE3YTFlMDFmYTUzNTUzNGI4NWE1MzQ3YTdlNDlmYzc5ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-02T19:07:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-02T19:07:22Z"}, "message": "Auto merge of #58836 - ljedrz:begone_NodeId, r=Zoxc\n\nRemove NodeId from even more HIR nodes\n\nThe next iteration of HirIdification (#57578).\n\nRemoves `NodeId` from:\n\n- [x] `StructField`\n- [x] `ForeignItem`\n- [x] `Item`\n- [x] `Pat`\n- [x] `FieldPat`\n- [x] `VariantData`\n- [x] `ImplItemId` (replaces it with `HirId`)\n- [x] `TraitItemId` (replaces it with `HirId`)", "tree": {"sha": "ce6c58ec21d51d974962da7f8eadf40c8cc83817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce6c58ec21d51d974962da7f8eadf40c8cc83817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ea22717a1e01fa535534b85a5347a7e49fc79de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ea22717a1e01fa535534b85a5347a7e49fc79de", "html_url": "https://github.com/rust-lang/rust/commit/0ea22717a1e01fa535534b85a5347a7e49fc79de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ea22717a1e01fa535534b85a5347a7e49fc79de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fab272e5ef92b5f0b4f10c1b42c7dbcb5cec0f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/fab272e5ef92b5f0b4f10c1b42c7dbcb5cec0f78", "html_url": "https://github.com/rust-lang/rust/commit/fab272e5ef92b5f0b4f10c1b42c7dbcb5cec0f78"}, {"sha": "299ed9af947db19a35e540bbb4ac5dac5a72e0ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/299ed9af947db19a35e540bbb4ac5dac5a72e0ae", "html_url": "https://github.com/rust-lang/rust/commit/299ed9af947db19a35e540bbb4ac5dac5a72e0ae"}], "stats": {"total": 1086, "additions": 528, "deletions": 558}, "files": [{"sha": "8b304007a3572bbc5ca5bc9cd12edf11911c6ff9", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.id));\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n         } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(\"target_feature\")) {\n             self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n                 .span_label(item.span, \"not a function\")"}, {"sha": "52ad800e81c6abf65e693802bccd980925a6d70f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -469,8 +469,8 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_trait_item(&mut self, item: &'lcx TraitItem) {\n                 self.lctx.with_hir_id_owner(item.id, |lctx| {\n-                    let id = hir::TraitItemId { node_id: item.id };\n                     let hir_item = lctx.lower_trait_item(item);\n+                    let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n                     lctx.trait_items.insert(id, hir_item);\n                     lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n                 });\n@@ -480,8 +480,8 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_impl_item(&mut self, item: &'lcx ImplItem) {\n                 self.lctx.with_hir_id_owner(item.id, |lctx| {\n-                    let id = hir::ImplItemId { node_id: item.id };\n                     let hir_item = lctx.lower_impl_item(item);\n+                    let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n                     lctx.impl_items.insert(id, hir_item);\n                     lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n                 });\n@@ -1414,7 +1414,6 @@ impl<'a> LoweringContext<'a> {\n \n             trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n             let exist_ty_item = hir::Item {\n-                id: exist_ty_id.node_id,\n                 hir_id: exist_ty_id.hir_id,\n                 ident: keywords::Invalid.ident(),\n                 attrs: Default::default(),\n@@ -2675,35 +2674,33 @@ impl<'a> LoweringContext<'a> {\n     fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData {\n         match *vdata {\n             VariantData::Struct(ref fields, id) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n                 hir::VariantData::Struct(\n                     fields\n                         .iter()\n                         .enumerate()\n                         .map(|f| self.lower_struct_field(f))\n                         .collect(),\n-                    node_id,\n                     hir_id,\n                 )\n             },\n             VariantData::Tuple(ref fields, id) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n                 hir::VariantData::Tuple(\n                     fields\n                         .iter()\n                         .enumerate()\n                         .map(|f| self.lower_struct_field(f))\n                         .collect(),\n-                    node_id,\n                     hir_id,\n                 )\n             },\n             VariantData::Unit(id) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n-                hir::VariantData::Unit(node_id, hir_id)\n+                hir::VariantData::Unit(hir_id)\n             },\n         }\n     }\n@@ -2743,11 +2740,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(f.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(f.id);\n \n         hir::StructField {\n             span: f.span,\n-            id: node_id,\n             hir_id,\n             ident: match f.ident {\n                 Some(ident) => ident,\n@@ -3129,7 +3125,6 @@ impl<'a> LoweringContext<'a> {\n                         this.insert_item(\n                             new_id.node_id,\n                             hir::Item {\n-                                id: new_id.node_id,\n                                 hir_id: new_id.hir_id,\n                                 ident,\n                                 attrs: attrs.clone(),\n@@ -3235,7 +3230,6 @@ impl<'a> LoweringContext<'a> {\n                         this.insert_item(\n                             new_id,\n                             hir::Item {\n-                                id: new_id,\n                                 hir_id: new_hir_id,\n                                 ident,\n                                 attrs: attrs.clone(),\n@@ -3369,7 +3363,7 @@ impl<'a> LoweringContext<'a> {\n             TraitItemKind::Macro(..) => unimplemented!(),\n         };\n         hir::TraitItemRef {\n-            id: hir::TraitItemId { node_id: i.id },\n+            id: hir::TraitItemId { hir_id: self.lower_node_id(i.id).hir_id },\n             ident: i.ident,\n             span: i.span,\n             defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n@@ -3433,7 +3427,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { node_id: i.id },\n+            id: hir::ImplItemId { hir_id: self.lower_node_id(i.id).hir_id },\n             ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n@@ -3535,10 +3529,9 @@ impl<'a> LoweringContext<'a> {\n \n         let node = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.node);\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(i.id);\n \n         Some(hir::Item {\n-            id: node_id,\n             hir_id,\n             ident,\n             attrs,\n@@ -3552,7 +3545,6 @@ impl<'a> LoweringContext<'a> {\n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n         let def_id = self.resolver.definitions().local_def_id(node_id);\n         hir::ForeignItem {\n-            id: node_id,\n             hir_id,\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n@@ -3746,12 +3738,11 @@ impl<'a> LoweringContext<'a> {\n                 let fs = fields\n                     .iter()\n                     .map(|f| {\n-                        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n                         Spanned {\n                             span: f.span,\n                             node: hir::FieldPat {\n-                                id: node_id,\n                                 hir_id,\n                                 ident: f.node.ident,\n                                 pat: self.lower_pat(&f.node.pat),\n@@ -3783,9 +3774,8 @@ impl<'a> LoweringContext<'a> {\n             PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(p.id);\n         P(hir::Pat {\n-            id: node_id,\n             hir_id,\n             node,\n             span: p.span,\n@@ -4359,7 +4349,7 @@ impl<'a> LoweringContext<'a> {\n                 let iter = self.str_to_ident(\"iter\");\n \n                 let next_ident = self.str_to_ident(\"__next\");\n-                let next_pat = self.pat_ident_binding_mode(\n+                let (next_pat, next_pat_nid) = self.pat_ident_binding_mode(\n                     desugared_span,\n                     next_ident,\n                     hir::BindingAnnotation::Mutable,\n@@ -4368,9 +4358,9 @@ impl<'a> LoweringContext<'a> {\n                 // `::std::option::Option::Some(val) => next = val`\n                 let pat_arm = {\n                     let val_ident = self.str_to_ident(\"val\");\n-                    let val_pat = self.pat_ident(pat.span, val_ident);\n-                    let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat.id));\n-                    let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat.id));\n+                    let (val_pat, val_pat_nid) = self.pat_ident(pat.span, val_ident);\n+                    let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_nid));\n+                    let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_nid));\n                     let assign = P(self.expr(\n                         pat.span,\n                         hir::ExprKind::Assign(next_expr, val_expr),\n@@ -4389,15 +4379,15 @@ impl<'a> LoweringContext<'a> {\n                 };\n \n                 // `mut iter`\n-                let iter_pat = self.pat_ident_binding_mode(\n+                let (iter_pat, iter_pat_nid) = self.pat_ident_binding_mode(\n                     desugared_span,\n                     iter,\n                     hir::BindingAnnotation::Mutable\n                 );\n \n                 // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                 let match_expr = {\n-                    let iter = P(self.expr_ident(head_sp, iter, iter_pat.id));\n+                    let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n                     let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n                     let next_path = &[\"iter\", \"Iterator\", \"next\"];\n                     let next_path = P(self.expr_std_path(head_sp, next_path, None, ThinVec::new()));\n@@ -4421,7 +4411,7 @@ impl<'a> LoweringContext<'a> {\n                     span: head_sp,\n                 };\n \n-                let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat.id));\n+                let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_nid));\n \n                 // `let mut __next`\n                 let next_let = self.stmt_let_pat(\n@@ -4548,11 +4538,11 @@ impl<'a> LoweringContext<'a> {\n                 // `Ok(val) => #[allow(unreachable_code)] val,`\n                 let ok_arm = {\n                     let val_ident = self.str_to_ident(\"val\");\n-                    let val_pat = self.pat_ident(e.span, val_ident);\n+                    let (val_pat, val_pat_nid) = self.pat_ident(e.span, val_ident);\n                     let val_expr = P(self.expr_ident_with_attrs(\n                         e.span,\n                         val_ident,\n-                        val_pat.id,\n+                        val_pat_nid,\n                         ThinVec::from(attrs.clone()),\n                     ));\n                     let ok_pat = self.pat_ok(e.span, val_pat);\n@@ -4564,12 +4554,12 @@ impl<'a> LoweringContext<'a> {\n                 //              return Try::from_error(From::from(err)),`\n                 let err_arm = {\n                     let err_ident = self.str_to_ident(\"err\");\n-                    let err_local = self.pat_ident(e.span, err_ident);\n+                    let (err_local, err_local_nid) = self.pat_ident(e.span, err_ident);\n                     let from_expr = {\n                         let path = &[\"convert\", \"From\", \"from\"];\n                         let from = P(self.expr_std_path(\n                                 e.span, path, None, ThinVec::new()));\n-                        let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n+                        let err_expr = self.expr_ident(e.span, err_ident, err_local_nid);\n \n                         self.expr_call(e.span, from, hir_vec![err_expr])\n                     };\n@@ -4917,15 +4907,15 @@ impl<'a> LoweringContext<'a> {\n         ident: Ident,\n         ex: P<hir::Expr>,\n     ) -> (hir::Stmt, NodeId) {\n-        let pat = if mutbl {\n+        let (pat, pat_nid) = if mutbl {\n             self.pat_ident_binding_mode(sp, ident, hir::BindingAnnotation::Mutable)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n-        let pat_id = pat.id;\n+\n         (\n             self.stmt_let_pat(sp, Some(ex), pat, hir::LocalSource::Normal),\n-            pat_id,\n+            pat_nid,\n         )\n     }\n \n@@ -4983,7 +4973,7 @@ impl<'a> LoweringContext<'a> {\n         self.pat(span, pt)\n     }\n \n-    fn pat_ident(&mut self, span: Span, ident: Ident) -> P<hir::Pat> {\n+    fn pat_ident(&mut self, span: Span, ident: Ident) -> (P<hir::Pat>, NodeId) {\n         self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n     }\n \n@@ -4992,25 +4982,26 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         ident: Ident,\n         bm: hir::BindingAnnotation,\n-    ) -> P<hir::Pat> {\n+    ) -> (P<hir::Pat>, NodeId) {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n \n-        P(hir::Pat {\n-            id: node_id,\n-            hir_id,\n-            node: hir::PatKind::Binding(bm, node_id, hir_id, ident.with_span_pos(span), None),\n-            span,\n-        })\n+        (\n+            P(hir::Pat {\n+                hir_id,\n+                node: hir::PatKind::Binding(bm, node_id, hir_id, ident.with_span_pos(span), None),\n+                span,\n+            }),\n+            node_id\n+        )\n     }\n \n     fn pat_wild(&mut self, span: Span) -> P<hir::Pat> {\n         self.pat(span, hir::PatKind::Wild)\n     }\n \n     fn pat(&mut self, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         P(hir::Pat {\n-            id: node_id,\n             hir_id,\n             node: pat,\n             span,"}, {"sha": "9f39d648df1bfcf08df8590669cf482eb94ef6b1", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -356,7 +356,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(i.hir_id.owner,\n-                         self.definitions.opt_def_index(i.id).unwrap());\n+                         self.definitions.opt_def_index(self.hir_to_node_id[&i.hir_id]).unwrap());\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n             this.insert(i.span, i.hir_id, Node::Item(i));\n             this.with_parent(i.hir_id, |this| {"}, {"sha": "21a9ed5ebe03a15d11efec49dc8b6edb23516c16", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -319,7 +319,7 @@ impl<'hir> Map<'hir> {\n \n         match node {\n             Node::Item(item) => {\n-                let def_id = || self.local_def_id(item.id);\n+                let def_id = || self.local_def_id_from_hir_id(item.hir_id);\n \n                 match item.node {\n                     ItemKind::Static(_, m, _) => Some(Def::Static(def_id(), m == MutMutable)),\n@@ -341,7 +341,7 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::ForeignItem(item) => {\n-                let def_id = self.local_def_id(item.id);\n+                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n                     ForeignItemKind::Fn(..) => Some(Def::Fn(def_id)),\n                     ForeignItemKind::Static(_, m) => Some(Def::Static(def_id, m)),\n@@ -366,11 +366,11 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::Variant(variant) => {\n-                let def_id = self.local_def_id(variant.node.data.id());\n+                let def_id = self.local_def_id_from_hir_id(variant.node.data.hir_id());\n                 Some(Def::Variant(def_id))\n             }\n             Node::StructCtor(variant) => {\n-                let def_id = self.local_def_id(variant.id());\n+                let def_id = self.local_def_id_from_hir_id(variant.hir_id());\n                 Some(Def::StructCtor(def_id, def::CtorKind::from_hir(variant)))\n             }\n             Node::AnonConst(_) |\n@@ -427,15 +427,15 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem {\n-        self.read(id.node_id);\n+        self.read_by_hir_id(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_item(id)\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem {\n-        self.read(id.node_id);\n+        self.read_by_hir_id(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n@@ -618,11 +618,11 @@ impl<'hir> Map<'hir> {\n         }\n \n         for id in &module.trait_items {\n-            visitor.visit_trait_item(self.expect_trait_item(id.node_id));\n+            visitor.visit_trait_item(self.expect_trait_item_by_hir_id(id.hir_id));\n         }\n \n         for id in &module.impl_items {\n-            visitor.visit_impl_item(self.expect_impl_item(id.node_id));\n+            visitor.visit_impl_item(self.expect_impl_item_by_hir_id(id.hir_id));\n         }\n     }\n "}, {"sha": "2d0296aa38c704e3306cbe6437dffc3d00edded4", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -834,15 +834,14 @@ pub struct Block {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Pat {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub node: PatKind,\n     pub span: Span,\n }\n \n impl fmt::Debug for Pat {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"pat({}: {})\", self.id,\n+        write!(f, \"pat({}: {})\", self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_pat(self)))\n     }\n }\n@@ -897,7 +896,6 @@ impl Pat {\n /// except `is_shorthand` is true.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FieldPat {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     /// The identifier for the field.\n     pub ident: Ident,\n@@ -1659,7 +1657,7 @@ pub struct MethodSig {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItemId {\n-    pub node_id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// Represents an item declaration within a trait declaration,\n@@ -1704,7 +1702,7 @@ pub enum TraitItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItemId {\n-    pub node_id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// Represents anything within an `impl` block\n@@ -2132,7 +2130,6 @@ pub struct StructField {\n     pub span: Span,\n     pub ident: Ident,\n     pub vis: Visibility,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub ty: P<Ty>,\n     pub attrs: HirVec<Attribute>,\n@@ -2159,9 +2156,9 @@ impl StructField {\n /// Id of the whole struct lives in `Item`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum VariantData {\n-    Struct(HirVec<StructField>, NodeId, HirId),\n-    Tuple(HirVec<StructField>, NodeId, HirId),\n-    Unit(NodeId, HirId),\n+    Struct(HirVec<StructField>, HirId),\n+    Tuple(HirVec<StructField>, HirId),\n+    Unit(HirId),\n }\n \n impl VariantData {\n@@ -2171,18 +2168,11 @@ impl VariantData {\n             _ => &[],\n         }\n     }\n-    pub fn id(&self) -> NodeId {\n-        match *self {\n-            VariantData::Struct(_, id, ..)\n-            | VariantData::Tuple(_, id, ..)\n-            | VariantData::Unit(id, ..) => id,\n-        }\n-    }\n     pub fn hir_id(&self) -> HirId {\n         match *self {\n-            VariantData::Struct(_, _, hir_id)\n-            | VariantData::Tuple(_, _, hir_id)\n-            | VariantData::Unit(_, hir_id) => hir_id,\n+            VariantData::Struct(_, hir_id)\n+            | VariantData::Tuple(_, hir_id)\n+            | VariantData::Unit(hir_id) => hir_id,\n         }\n     }\n     pub fn is_struct(&self) -> bool {\n@@ -2222,7 +2212,6 @@ pub struct ItemId {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Item {\n     pub ident: Ident,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n     pub node: ItemKind,\n@@ -2379,7 +2368,6 @@ pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n     pub node: ForeignItemKind,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub vis: Visibility,"}, {"sha": "0803816fb03f45a13c9741df938445b97682b4de", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -116,11 +116,11 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n-            node_id\n+            hir_id\n         } = * self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            node_id.hash_stable(hcx, hasher);\n+            hir_id.hash_stable(hcx, hasher);\n         })\n     }\n }\n@@ -130,11 +130,11 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n-            node_id\n+            hir_id\n         } = * self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            node_id.hash_stable(hcx, hasher);\n+            hir_id.hash_stable(hcx, hasher);\n         })\n     }\n }\n@@ -421,7 +421,6 @@ impl_stable_hash_for!(struct hir::Block {\n });\n \n impl_stable_hash_for!(struct hir::Pat {\n-    id -> _,\n     hir_id -> _,\n     node,\n     span,\n@@ -430,7 +429,6 @@ impl_stable_hash_for!(struct hir::Pat {\n impl_stable_hash_for_spanned!(hir::FieldPat);\n \n impl_stable_hash_for!(struct hir::FieldPat {\n-    id -> _,\n     hir_id -> _,\n     ident -> (ident.name),\n     pat,\n@@ -838,16 +836,15 @@ impl_stable_hash_for!(struct hir::StructField {\n     span,\n     ident -> (ident.name),\n     vis,\n-    id,\n     hir_id,\n     ty,\n     attrs\n });\n \n impl_stable_hash_for!(enum hir::VariantData {\n-    Struct(fields, id, hir_id),\n-    Tuple(fields, id, hir_id),\n-    Unit(id, hir_id)\n+    Struct(fields, hir_id),\n+    Tuple(fields, hir_id),\n+    Unit(hir_id)\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n@@ -857,7 +854,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n         let hir::Item {\n             ident,\n             ref attrs,\n-            id: _,\n             hir_id: _,\n             ref node,\n             ref vis,\n@@ -932,7 +928,6 @@ impl_stable_hash_for!(struct hir::ForeignItem {\n     ident -> (ident.name),\n     attrs,\n     node,\n-    id,\n     hir_id,\n     span,\n     vis"}, {"sha": "8ffd119f95c0ba9a2062391b4ea4dedd9b9661dc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                        let def_id = self.tcx.hir().local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                         let def = self.tcx.adt_def(def_id);\n                         self.repr_has_repr_c = def.repr.c();\n \n@@ -376,7 +376,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                             has_allow_dead_code_or_lang_attr(self.tcx,\n                                                              impl_item.hir_id,\n                                                              &impl_item.attrs) {\n-                        self.worklist.push(self.tcx.hir().node_to_hir_id(impl_item_ref.id.node_id));\n+                        self.worklist.push(impl_item_ref.id.hir_id);\n                     }\n                 }\n             }\n@@ -465,7 +465,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n+        let field_type = self.tcx.type_of(self.tcx.hir().local_def_id_from_hir_id(field.hir_id));\n         !field.is_positional()\n             && !self.symbol_is_live(field.hir_id)\n             && !field_type.is_phantom_data()"}, {"sha": "c20454a8822cd65915aadf872bd6246a4c99d4d8", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -2,11 +2,10 @@ use crate::hir::map as hir_map;\n use crate::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use crate::session::{config, Session};\n use crate::session::config::EntryFnType;\n-use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use crate::hir::{Item, ItemKind, ImplItem, TraitItem};\n+use crate::hir::{HirId, Item, ItemKind, ImplItem, TraitItem};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n@@ -17,22 +16,22 @@ struct EntryContext<'a, 'tcx: 'a> {\n     map: &'a hir_map::Map<'tcx>,\n \n     // The top-level function called 'main'\n-    main_fn: Option<(NodeId, Span)>,\n+    main_fn: Option<(HirId, Span)>,\n \n     // The function that has attribute named 'main'\n-    attr_main_fn: Option<(NodeId, Span)>,\n+    attr_main_fn: Option<(HirId, Span)>,\n \n     // The function that has the attribute 'start' on it\n-    start_fn: Option<(NodeId, Span)>,\n+    start_fn: Option<(HirId, Span)>,\n \n     // The functions that one might think are 'main' but aren't, e.g.\n     // main functions not defined at the top level. For diagnostics.\n-    non_main_fns: Vec<(NodeId, Span)> ,\n+    non_main_fns: Vec<(HirId, Span)> ,\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n-        let def_id = self.map.local_def_id(item.id);\n+        let def_id = self.map.local_def_id_from_hir_id(item.hir_id);\n         let def_key = self.map.def_key(def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n@@ -106,18 +105,18 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n     match entry_point_type(item, at_root) {\n         EntryPointType::MainNamed => {\n             if ctxt.main_fn.is_none() {\n-                ctxt.main_fn = Some((item.id, item.span));\n+                ctxt.main_fn = Some((item.hir_id, item.span));\n             } else {\n                 span_err!(ctxt.session, item.span, E0136,\n                           \"multiple 'main' functions\");\n             }\n         },\n         EntryPointType::OtherMain => {\n-            ctxt.non_main_fns.push((item.id, item.span));\n+            ctxt.non_main_fns.push((item.hir_id, item.span));\n         },\n         EntryPointType::MainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n-                ctxt.attr_main_fn = Some((item.id, item.span));\n+                ctxt.attr_main_fn = Some((item.hir_id, item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0137,\n                                  \"multiple functions with a #[main] attribute\")\n@@ -128,7 +127,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n         },\n         EntryPointType::Start => {\n             if ctxt.start_fn.is_none() {\n-                ctxt.start_fn = Some((item.id, item.span));\n+                ctxt.start_fn = Some((item.hir_id, item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0138, \"multiple 'start' functions\")\n                     .span_label(ctxt.start_fn.unwrap().1, \"previous `start` function here\")\n@@ -144,12 +143,12 @@ fn configure_main(\n     tcx: TyCtxt<'_, '_, '_>,\n     visitor: &EntryContext<'_, '_>,\n ) -> Option<(DefId, EntryFnType)> {\n-    if let Some((node_id, _)) = visitor.start_fn {\n-        Some((tcx.hir().local_def_id(node_id), EntryFnType::Start))\n-    } else if let Some((node_id, _)) = visitor.attr_main_fn {\n-        Some((tcx.hir().local_def_id(node_id), EntryFnType::Main))\n-    } else if let Some((node_id, _)) = visitor.main_fn {\n-        Some((tcx.hir().local_def_id(node_id), EntryFnType::Main))\n+    if let Some((hir_id, _)) = visitor.start_fn {\n+        Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Start))\n+    } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n+        Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Main))\n+    } else if let Some((hir_id, _)) = visitor.main_fn {\n+        Some((tcx.hir().local_def_id_from_hir_id(hir_id), EntryFnType::Main))\n     } else {\n         // No main function\n         let mut err = struct_err!(tcx.sess, E0601,"}, {"sha": "6e8b661b7b895b1714730e47c8c1b13148734175", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -19,7 +19,6 @@ use crate::ty::{self, TyCtxt, adjustment};\n use crate::hir::{self, PatKind};\n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n-use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use crate::util::nodemap::ItemLocalSet;\n@@ -74,7 +73,7 @@ pub trait Delegate<'tcx> {\n \n     // The local variable `id` is declared but not initialized.\n     fn decl_without_init(&mut self,\n-                         id: ast::NodeId,\n+                         id: hir::HirId,\n                          span: Span);\n \n     // The path at `cmt` is being assigned to.\n@@ -609,8 +608,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 local.pat.each_binding(|_, hir_id, span, _| {\n-                    let node_id = self.mc.tcx.hir().hir_to_node_id(hir_id);\n-                    self.delegate.decl_without_init(node_id, span);\n+                    self.delegate.decl_without_init(hir_id, span);\n                 })\n             }\n "}, {"sha": "7626310ea4eb3e3cf95d304e6723de1d0a1fe7d5", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             match self.item_refs.get(&*value.as_str()).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir().local_def_id(item.id);\n+                    let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                     self.collect_item(item_index, def_id);\n                 },\n                 // Known lang item with attribute on incorrect target."}, {"sha": "a3e8598194e790550f12d5a3ff5f08a412a571b7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -88,7 +88,7 @@ pub enum Categorization<'tcx> {\n     ThreadLocal(ty::Region<'tcx>),       // value that cannot move, but still restricted in scope\n     StaticItem,\n     Upvar(Upvar),                        // upvar referenced by closure env\n-    Local(ast::NodeId),                  // local variable\n+    Local(hir::HirId),                   // local variable\n     Deref(cmt<'tcx>, PointerKind<'tcx>), // deref of a ptr\n     Interior(cmt<'tcx>, InteriorKind),   // something interior: field, tuple, etc\n     Downcast(cmt<'tcx>, DefId),          // selects a particular enum variant (*1)\n@@ -198,9 +198,9 @@ pub struct cmt_<'tcx> {\n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n pub enum ImmutabilityBlame<'tcx> {\n-    ImmLocal(ast::NodeId),\n+    ImmLocal(hir::HirId),\n     ClosureEnv(LocalDefId),\n-    LocalDeref(ast::NodeId),\n+    LocalDeref(hir::HirId),\n     AdtFieldDeref(&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n }\n \n@@ -230,8 +230,8 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Deref(ref base_cmt, BorrowedPtr(ty::ImmBorrow, _)) => {\n                 // try to figure out where the immutable reference came from\n                 match base_cmt.cat {\n-                    Categorization::Local(node_id) =>\n-                        Some(ImmutabilityBlame::LocalDeref(node_id)),\n+                    Categorization::Local(hir_id) =>\n+                        Some(ImmutabilityBlame::LocalDeref(hir_id)),\n                     Categorization::Interior(ref base_cmt, InteriorField(field_index)) => {\n                         base_cmt.resolve_field(field_index.0).map(|(adt_def, field_def)| {\n                             ImmutabilityBlame::AdtFieldDeref(adt_def, field_def)\n@@ -247,8 +247,8 @@ impl<'tcx> cmt_<'tcx> {\n                     _ => None\n                 }\n             }\n-            Categorization::Local(node_id) => {\n-                Some(ImmutabilityBlame::ImmLocal(node_id))\n+            Categorization::Local(hir_id) => {\n+                Some(ImmutabilityBlame::ImmLocal(hir_id))\n             }\n             Categorization::Rvalue(..) |\n             Categorization::Upvar(..) |\n@@ -741,7 +741,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 Ok(cmt_ {\n                     hir_id,\n                     span,\n-                    cat: Categorization::Local(vid),\n+                    cat: Categorization::Local(self.tcx.hir().node_to_hir_id(vid)),\n                     mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n                     ty: expr_ty,\n                     note: NoteNone\n@@ -1495,7 +1495,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"non-place\".into()\n             }\n             Categorization::Local(vid) => {\n-                if tcx.hir().is_argument(vid) {\n+                if tcx.hir().is_argument(tcx.hir().hir_to_node_id(vid)) {\n                     \"argument\"\n                 } else {\n                     \"local variable\""}, {"sha": "086b3a318e6b6e9f004c196da728a895aaeae220", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -14,10 +14,9 @@ use crate::ty::{self, TyCtxt};\n use crate::ty::query::Providers;\n use crate::middle::privacy;\n use crate::session::config;\n-use crate::util::nodemap::{NodeSet, FxHashSet};\n+use crate::util::nodemap::{HirIdSet, FxHashSet};\n \n use rustc_target::spec::abi::Abi;\n-use syntax::ast;\n use crate::hir;\n use crate::hir::def_id::LOCAL_CRATE;\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -37,7 +36,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match item.node {\n         hir::ItemKind::Impl(..) |\n         hir::ItemKind::Fn(..) => {\n-            let generics = tcx.generics_of(tcx.hir().local_def_id(item.id));\n+            let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(item.hir_id));\n             generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n@@ -70,10 +69,10 @@ struct ReachableContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: NodeSet,\n+    reachable_symbols: HirIdSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: Vec<ast::NodeId>,\n+    worklist: Vec<hir::HirId>,\n     // Whether any output of this compilation is a library\n     any_library: bool,\n }\n@@ -104,27 +103,28 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n \n         match def {\n             Some(Def::Local(node_id)) | Some(Def::Upvar(node_id, ..)) => {\n-                self.reachable_symbols.insert(node_id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+                self.reachable_symbols.insert(hir_id);\n             }\n             Some(def) => {\n-                if let Some((node_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n-                    self.tcx.hir().as_local_node_id(def_id).map(|node_id| (node_id, def_id))\n+                if let Some((hir_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n+                    self.tcx.hir().as_local_hir_id(def_id).map(|hir_id| (hir_id, def_id))\n                 }) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(node_id);\n+                        self.worklist.push(hir_id);\n                     } else {\n                         match def {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n                             Def::Const(..) | Def::AssociatedConst(..) => {\n-                                self.worklist.push(node_id);\n+                                self.worklist.push(hir_id);\n                             }\n \n                             // If this wasn't a static, then the destination is\n                             // surely reachable.\n                             _ => {\n-                                self.reachable_symbols.insert(node_id);\n+                                self.reachable_symbols.insert(hir_id);\n                             }\n                         }\n                     }\n@@ -204,14 +204,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref item) = self.tcx.hir().find(search_item) {\n+            if let Some(ref item) = self.tcx.hir().find_by_hir_id(search_item) {\n                 self.propagate_node(item, search_item);\n             }\n         }\n     }\n \n     fn propagate_node(&mut self, node: &Node<'tcx>,\n-                      search_item: ast::NodeId) {\n+                      search_item: hir::HirId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n@@ -221,7 +221,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 } else {\n                     false\n                 };\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n                 let is_extern = codegen_attrs.contains_extern_indicator();\n                 let std_internal = codegen_attrs.flags.contains(\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n-                        let def_id = self.tcx.hir().local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                         if item_might_be_inlined(self.tcx,\n                                                  &item,\n                                                  self.tcx.codegen_fn_attrs(def_id)) {\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(_, body) => {\n-                        let did = self.tcx.hir().get_parent_did(search_item);\n+                        let did = self.tcx.hir().get_parent_did_by_hir_id(search_item);\n                         if method_might_be_inlined(self.tcx, impl_item, did) {\n                             self.visit_nested_body(body)\n                         }\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             _ => {\n                 bug!(\n                     \"found unexpected node kind in worklist: {} ({:?})\",\n-                    self.tcx.hir().node_to_string(search_item),\n+                    self.tcx.hir().hir_to_string(search_item),\n                     node,\n                 );\n             }\n@@ -336,25 +336,26 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n-    worklist: &'a mut Vec<ast::NodeId>,\n+    worklist: &'a mut Vec<hir::HirId>,\n }\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\"\n         // which are currently akin to allocator symbols.\n-        let def_id = self.tcx.hir().local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n         if codegen_attrs.contains_extern_indicator() ||\n             codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-            self.worklist.push(item.id);\n+            self.worklist.push(item.hir_id);\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n-            if !self.access_levels.is_reachable(item.id) {\n-                self.worklist.extend(impl_item_refs.iter().map(|r| r.id.node_id));\n+            let node_id = self.tcx.hir().hir_to_node_id(item.hir_id);\n+            if !self.access_levels.is_reachable(node_id) {\n+                self.worklist.extend(impl_item_refs.iter().map(|ii_ref| ii_ref.id.hir_id));\n \n                 let trait_def_id = match trait_ref.path.def {\n                     Def::Trait(def_id) => def_id,\n@@ -368,11 +369,11 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n                 let provided_trait_methods = self.tcx.provided_trait_methods(trait_def_id);\n                 self.worklist.reserve(provided_trait_methods.len());\n                 for default_method in provided_trait_methods {\n-                    let node_id = self.tcx\n-                                      .hir()\n-                                      .as_local_node_id(default_method.def_id)\n-                                      .unwrap();\n-                    self.worklist.push(node_id);\n+                    let hir_id = self.tcx\n+                                     .hir()\n+                                     .as_local_hir_id(default_method.def_id)\n+                                     .unwrap();\n+                    self.worklist.push(hir_id);\n                 }\n             }\n         }\n@@ -388,7 +389,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n // We introduce a new-type here, so we can have a specialized HashStable\n // implementation for it.\n #[derive(Clone)]\n-pub struct ReachableSet(pub Lrc<NodeSet>);\n+pub struct ReachableSet(pub Lrc<HirIdSet>);\n \n fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n@@ -412,11 +413,12 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n+    reachable_context.worklist.extend(\n+        access_levels.map.iter().map(|(id, _)| tcx.hir().node_to_hir_id(*id)));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n-            if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n-                reachable_context.worklist.push(node_id);\n+            if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+                reachable_context.worklist.push(hir_id);\n             }\n         }\n     }"}, {"sha": "2618d0874cbc389cc2f5d8a29b581e0737821e97", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -13,7 +13,7 @@ use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n \n use crate::rustc::lint;\n use crate::session::Session;\n-use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, HirIdMap, HirIdSet, NodeMap};\n+use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, HirIdMap, HirIdSet};\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use std::borrow::Cow;\n@@ -204,7 +204,7 @@ struct NamedRegionMap {\n \n     // For each type and trait definition, maps type parameters\n     // to the trait object lifetime defaults computed from them.\n-    pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n+    pub object_lifetime_defaults: HirIdMap<Vec<ObjectLifetimeDefault>>,\n }\n \n /// See [`NamedRegionMap`].\n@@ -395,8 +395,7 @@ fn resolve_lifetimes<'tcx>(\n             .or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id);\n     }\n-    for (k, v) in named_region_map.object_lifetime_defaults {\n-        let hir_id = tcx.hir().node_to_hir_id(k);\n+    for (hir_id, v) in named_region_map.object_lifetime_defaults {\n         let map = rl.object_lifetime_defaults\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n@@ -672,13 +671,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // In the future, this should be fixed and this error should be removed.\n                         let def = self.map.defs.get(&lifetime.hir_id).cloned();\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n-                            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n+                            if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n                                 // Ensure that the parent of the def is an item, not HRTB\n-                                let parent_id = self.tcx.hir().get_parent_node(node_id);\n-                                let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n-                                let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n+                                let parent_id = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+                                let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n+                                let parent_trait_id = hir::TraitItemId { hir_id: parent_id };\n                                 let krate = self.tcx.hir().forest.krate();\n-                                if !(krate.items.contains_key(&parent_id)\n+                                let parent_node_id = self.tcx.hir().hir_to_node_id(parent_id);\n+                                if !(krate.items.contains_key(&parent_node_id)\n                                     || krate.impl_items.contains_key(&parent_impl_id)\n                                     || krate.trait_items.contains_key(&parent_trait_id))\n                                 {\n@@ -1266,8 +1266,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n \n fn compute_object_lifetime_defaults(\n     tcx: TyCtxt<'_, '_, '_>,\n-) -> NodeMap<Vec<ObjectLifetimeDefault>> {\n-    let mut map = NodeMap::default();\n+) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n+    let mut map = HirIdMap::default();\n     for item in tcx.hir().krate().items.values() {\n         match item.node {\n             hir::ItemKind::Struct(_, ref generics)\n@@ -1311,7 +1311,7 @@ fn compute_object_lifetime_defaults(\n                     tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n                 }\n \n-                map.insert(item.id, result);\n+                map.insert(item.hir_id, result);\n             }\n             _ => {}\n         }\n@@ -1959,7 +1959,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let unsubst = if let Some(id) = self.tcx.hir().as_local_node_id(def_id) {\n+            let unsubst = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let tcx = self.tcx;\n@@ -2073,10 +2073,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .expect_item_by_hir_id(self.tcx.hir().get_parent_item(parent))\n                     .node\n                 {\n-                    let parent_node_id = self.tcx.hir().hir_to_node_id(parent);\n                     assoc_item_kind = trait_items\n                         .iter()\n-                        .find(|ti| ti.id.node_id == parent_node_id)\n+                        .find(|ti| ti.id.hir_id == parent)\n                         .map(|ti| ti.kind);\n                 }\n                 match *m {\n@@ -2095,10 +2094,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .node\n                 {\n                     impl_self = Some(self_ty);\n-                    let parent_node_id = self.tcx.hir().hir_to_node_id(parent);\n                     assoc_item_kind = impl_items\n                         .iter()\n-                        .find(|ii| ii.id.node_id == parent_node_id)\n+                        .find(|ii| ii.id.hir_id == parent)\n                         .map(|ii| ii.kind);\n                 }\n                 Some(body)\n@@ -2398,7 +2396,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             let help_name = if let Some(body) = parent {\n                 let arg = &self.tcx.hir().body(body).arguments[index];\n-                format!(\"`{}`\", self.tcx.hir().node_to_pretty_string(arg.pat.id))\n+                format!(\"`{}`\", self.tcx.hir().hir_to_pretty_string(arg.pat.hir_id))\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };"}, {"sha": "aa23924486165c0222608ea9d1f383d7a9530815", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -317,10 +317,9 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n     fn check_missing_stability(&self, hir_id: HirId, span: Span, name: &str) {\n         let stab = self.tcx.stability().local_stability(hir_id);\n-        let node_id = self.tcx.hir().hir_to_node_id(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n                         stab.is_none() &&\n-                        self.access_levels.is_reachable(node_id);\n+                        self.access_levels.is_reachable(self.tcx.hir().hir_to_node_id(hir_id));\n         if is_error {\n             self.tcx.sess.span_err(\n                 span,\n@@ -762,7 +761,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span.is_dummy() { return }\n \n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n@@ -792,7 +791,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n             hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);\n "}, {"sha": "1f897d29a1eb86c3c39c6893e2680c11845d3a72", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl Visibility {\n-    pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: TyCtxt<'_, '_, '_>) -> Self {\n+    pub fn from_hir(visibility: &hir::Visibility, id: hir::HirId, tcx: TyCtxt<'_, '_, '_>) -> Self {\n         match visibility.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n@@ -271,7 +271,7 @@ impl Visibility {\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::VisibilityKind::Inherited => {\n-                Visibility::Restricted(tcx.hir().get_module_parent(id))\n+                Visibility::Restricted(tcx.hir().get_module_parent_by_hir_id(id))\n             }\n         }\n     }\n@@ -2727,7 +2727,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                            parent_vis: &hir::Visibility,\n                                            trait_item_ref: &hir::TraitItemRef)\n                                            -> AssociatedItem {\n-        let def_id = self.hir().local_def_id(trait_item_ref.id.node_id);\n+        let def_id = self.hir().local_def_id_from_hir_id(trait_item_ref.id.hir_id);\n         let (kind, has_self) = match trait_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2741,7 +2741,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ident: trait_item_ref.ident,\n             kind,\n             // Visibility of trait items is inherited from their traits.\n-            vis: Visibility::from_hir(parent_vis, trait_item_ref.id.node_id, self),\n+            vis: Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, self),\n             defaultness: trait_item_ref.defaultness,\n             def_id,\n             container: TraitContainer(parent_def_id),\n@@ -2753,7 +2753,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           parent_def_id: DefId,\n                                           impl_item_ref: &hir::ImplItemRef)\n                                           -> AssociatedItem {\n-        let def_id = self.hir().local_def_id(impl_item_ref.id.node_id);\n+        let def_id = self.hir().local_def_id_from_hir_id(impl_item_ref.id.hir_id);\n         let (kind, has_self) = match impl_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2767,7 +2767,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ident: impl_item_ref.ident,\n             kind,\n             // Visibility of trait impl items doesn't matter.\n-            vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.node_id, self),\n+            vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, self),\n             defaultness: impl_item_ref.defaultness,\n             def_id,\n             container: ImplContainer(parent_def_id),\n@@ -3037,13 +3037,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> AssociatedItem {\n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let parent_id = tcx.hir().get_parent(id);\n-    let parent_def_id = tcx.hir().local_def_id(parent_id);\n-    let parent_item = tcx.hir().expect_item(parent_id);\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let parent_id = tcx.hir().get_parent_item(id);\n+    let parent_def_id = tcx.hir().local_def_id_from_hir_id(parent_id);\n+    let parent_item = tcx.hir().expect_item_by_hir_id(parent_id);\n     match parent_item.node {\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-            if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.node_id == id) {\n+            if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n                 let assoc_item = tcx.associated_item_from_impl_item_ref(parent_def_id,\n                                                                         impl_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n@@ -3052,7 +3052,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Asso\n         }\n \n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-            if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.node_id == id) {\n+            if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.hir_id == id) {\n                 let assoc_item = tcx.associated_item_from_trait_item_ref(parent_def_id,\n                                                                          &parent_item.vis,\n                                                                          trait_item_ref);\n@@ -3106,13 +3106,13 @@ fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             trait_item_refs.iter()\n                            .map(|trait_item_ref| trait_item_ref.id)\n-                           .map(|id| tcx.hir().local_def_id(id.node_id))\n+                           .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n                            .collect()\n         }\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             impl_item_refs.iter()\n                           .map(|impl_item_ref| impl_item_ref.id)\n-                          .map(|id| tcx.hir().local_def_id(id.node_id))\n+                          .map(|id| tcx.hir().local_def_id_from_hir_id(id.hir_id))\n                           .collect()\n         }\n         hir::ItemKind::TraitAlias(..) => vec![],"}, {"sha": "bd854e3aa3c812597e77a46ec51a4d2c4704e812", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -17,7 +17,6 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt, RegionKind};\n-use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Node;\n@@ -177,7 +176,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         self.check_assignment(assignment_id.local_id, assignment_span, assignee_cmt);\n     }\n \n-    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n+    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) { }\n }\n \n pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n@@ -887,11 +886,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         // Check for reassignments to (immutable) local variables. This\n         // needs to be done here instead of in check_loans because we\n         // depend on move data.\n-        if let Categorization::Local(local_id) = assignee_cmt.cat {\n+        if let Categorization::Local(hir_id) = assignee_cmt.cat {\n             let lp = opt_loan_path(assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {\n-                    let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                     self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                 } else {\n                     self.bccx.report_reassigned_immutable_variable("}, {"sha": "310a9a2ef8dad57320cae6f8fb42ed47640d2068", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -11,7 +11,6 @@ use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::ty::{self, Ty};\n \n use std::rc::Rc;\n-use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir::*;\n use rustc::hir::Node;\n@@ -48,9 +47,9 @@ pub enum PatternSource<'tcx> {\n /// with a reference to the let\n fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n \n-    let parent = tcx.hir().get_parent_node(pat.id);\n+    let parent = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n \n-    match tcx.hir().get(parent) {\n+    match tcx.hir().get_by_hir_id(parent) {\n         Node::Expr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n@@ -67,11 +66,10 @@ fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> Patte\n \n pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              move_data: &MoveData<'tcx>,\n-                             var_id: ast::NodeId,\n+                             var_id: hir::HirId,\n                              var_ty: Ty<'tcx>) {\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    let hir_id = bccx.tcx.hir().node_to_hir_id(var_id);\n-    move_data.add_move(bccx.tcx, loan_path, hir_id.local_id, Declared);\n+    move_data.add_move(bccx.tcx, loan_path, var_id.local_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,"}, {"sha": "0e08b62668ac8f7d72c99b71c144e97e21027286", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -104,8 +104,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             Categorization::Upvar(..) => {\n                 self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n-            Categorization::Local(local_id) => {\n-                let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n+            Categorization::Local(hir_id) => {\n                 self.bccx.tcx.mk_region(ty::ReScope(\n                     self.bccx.region_scope_tree.var_scope(hir_id.local_id)))\n             }"}, {"sha": "bf730ba41f42845b3100edd21fe05111df730bfe", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -147,10 +147,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                                         assignee_cmt);\n     }\n \n-    fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n+    fn decl_without_init(&mut self, id: hir::HirId, _span: Span) {\n         let ty = self.bccx\n                      .tables\n-                     .node_type(self.bccx.tcx.hir().node_to_hir_id(id));\n+                     .node_type(id);\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }\n@@ -438,9 +438,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n         while let Some(current_path) = wrapped_path {\n             wrapped_path = match current_path.kind {\n-                LpVar(local_id) => {\n+                LpVar(hir_id) => {\n                     if !through_borrow {\n-                        let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                         self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                     }\n                     None"}, {"sha": "6d0efb163b8f7f9314614280a90627a9cb0321d9", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -335,7 +335,7 @@ impl<'tcx> Hash for LoanPath<'tcx> {\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathKind<'tcx> {\n-    LpVar(ast::NodeId),                         // `x` in README.md\n+    LpVar(hir::HirId),                          // `x` in README.md\n     LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n     LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n     LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem<'tcx>)\n@@ -417,8 +417,7 @@ fn closure_to_block(closure_id: LocalDefId,\n impl<'a, 'tcx> LoanPath<'tcx> {\n     pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n         match self.kind {\n-            LpVar(local_id) => {\n-                let hir_id = bccx.tcx.hir().node_to_hir_id(local_id);\n+            LpVar(hir_id) => {\n                 bccx.region_scope_tree.var_scope(hir_id.local_id)\n             }\n             LpUpvar(upvar_id) => {\n@@ -919,7 +918,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.note_immutability_blame(\n                     &mut db,\n                     err.cmt.immutability_blame(),\n-                    self.tcx.hir().hir_to_node_id(err.cmt.hir_id)\n+                    err.cmt.hir_id\n                 );\n                 db.emit();\n                 self.signal_error();\n@@ -1135,7 +1134,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.note_immutability_blame(\n             &mut err,\n             blame,\n-            self.tcx.hir().hir_to_node_id(cmt.hir_id)\n+            cmt.hir_id\n         );\n \n         if is_closure {\n@@ -1175,8 +1174,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n-        let pat = match self.tcx.hir().get(node_id) {\n+    fn local_binding_mode(&self, hir_id: hir::HirId) -> ty::BindingMode {\n+        let pat = match self.tcx.hir().get_by_hir_id(hir_id) {\n             Node::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n@@ -1192,16 +1191,16 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn local_ty(&self, node_id: ast::NodeId) -> (Option<&hir::Ty>, bool) {\n-        let parent = self.tcx.hir().get_parent_node(node_id);\n-        let parent_node = self.tcx.hir().get(parent);\n+    fn local_ty(&self, hir_id: hir::HirId) -> (Option<&hir::Ty>, bool) {\n+        let parent = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+        let parent_node = self.tcx.hir().get_by_hir_id(parent);\n \n         // The parent node is like a fn\n         if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n             // `nid`'s parent's `Body`\n             let fn_body = self.tcx.hir().body(fn_like.body());\n             // Get the position of `node_id` in the arguments list\n-            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == node_id);\n+            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.hir_id == hir_id);\n             if let Some(i) = arg_pos {\n                 // The argument's `Ty`\n                 (Some(&fn_like.decl().inputs[i]),\n@@ -1217,17 +1216,17 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn note_immutability_blame(&self,\n                                db: &mut DiagnosticBuilder<'_>,\n                                blame: Option<ImmutabilityBlame<'_>>,\n-                               error_node_id: ast::NodeId) {\n+                               error_hir_id: hir::HirId) {\n         match blame {\n             None => {}\n             Some(ImmutabilityBlame::ClosureEnv(_)) => {}\n-            Some(ImmutabilityBlame::ImmLocal(node_id)) => {\n-                self.note_immutable_local(db, error_node_id, node_id)\n+            Some(ImmutabilityBlame::ImmLocal(hir_id)) => {\n+                self.note_immutable_local(db, error_hir_id, hir_id)\n             }\n-            Some(ImmutabilityBlame::LocalDeref(node_id)) => {\n-                match self.local_binding_mode(node_id) {\n+            Some(ImmutabilityBlame::LocalDeref(hir_id)) => {\n+                match self.local_binding_mode(hir_id) {\n                     ty::BindByReference(..) => {\n-                        let let_span = self.tcx.hir().span(node_id);\n+                        let let_span = self.tcx.hir().span_by_hir_id(hir_id);\n                         let suggestion = suggest_ref_mut(self.tcx, let_span);\n                         if let Some(replace_str) = suggestion {\n                             db.span_suggestion(\n@@ -1244,7 +1243,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                     }\n                     ty::BindByValue(..) => {\n-                        if let (Some(local_ty), is_implicit_self) = self.local_ty(node_id) {\n+                        if let (Some(local_ty), is_implicit_self) = self.local_ty(hir_id) {\n                             if let Some(msg) =\n                                  self.suggest_mut_for_immutable(local_ty, is_implicit_self) {\n                                 db.span_label(local_ty.span, msg);\n@@ -1273,12 +1272,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n      // not a mutable reference) or to avoid borrowing altogether\n     fn note_immutable_local(&self,\n                             db: &mut DiagnosticBuilder<'_>,\n-                            borrowed_node_id: ast::NodeId,\n-                            binding_node_id: ast::NodeId) {\n-        let let_span = self.tcx.hir().span(binding_node_id);\n-        if let ty::BindByValue(..) = self.local_binding_mode(binding_node_id) {\n+                            borrowed_hir_id: hir::HirId,\n+                            binding_hir_id: hir::HirId) {\n+        let let_span = self.tcx.hir().span_by_hir_id(binding_hir_id);\n+        if let ty::BindByValue(..) = self.local_binding_mode(binding_hir_id) {\n             if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n-                let (ty, is_implicit_self) = self.local_ty(binding_node_id);\n+                let (ty, is_implicit_self) = self.local_ty(binding_hir_id);\n                 if is_implicit_self && snippet != \"self\" {\n                     // avoid suggesting `mut &self`.\n                     return\n@@ -1291,9 +1290,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     },\n                 )) = ty.map(|t| &t.node)\n                 {\n-                    let borrow_expr_id = self.tcx.hir().get_parent_node(borrowed_node_id);\n+                    let borrow_expr_id = self.tcx.hir().get_parent_node_by_hir_id(borrowed_hir_id);\n                     db.span_suggestion(\n-                        self.tcx.hir().span(borrow_expr_id),\n+                        self.tcx.hir().span_by_hir_id(borrow_expr_id),\n                         \"consider removing the `&mut`, as it is an \\\n                         immutable binding to a mutable reference\",\n                         snippet,\n@@ -1373,7 +1372,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n                     db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n-                    let span = self.tcx.hir().span(local_id);\n+                    let span = self.tcx.hir().span_by_hir_id(local_id);\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, \"cannot reborrow mutably\");\n@@ -1401,7 +1400,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push_str(&self.tcx.hir().name_by_hir_id(id).as_str());\n             }\n             LpVar(id) => {\n-                out.push_str(&self.tcx.hir().name(id).as_str());\n+                out.push_str(&self.tcx.hir().name_by_hir_id(id).as_str());\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n@@ -1512,7 +1511,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n@@ -1547,7 +1546,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_user_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_user_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {"}, {"sha": "7da28c19d2412d4e30d8040639c5088c297d9312", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -69,7 +69,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mut reachable_non_generics: DefIdMap<_> = tcx.reachable_set(LOCAL_CRATE).0\n         .iter()\n-        .filter_map(|&node_id| {\n+        .filter_map(|&hir_id| {\n             // We want to ignore some FFI functions that are not exposed from\n             // this crate. Reachable FFI functions can be lumped into two\n             // categories:\n@@ -83,9 +83,9 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir().get(node_id) {\n+            match tcx.hir().get_by_hir_id(hir_id) {\n                 Node::ForeignItem(..) => {\n-                    let def_id = tcx.hir().local_def_id(node_id);\n+                    let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n                     if tcx.is_statically_included_foreign_item(def_id) {\n                         Some(def_id)\n                     } else {\n@@ -105,7 +105,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     node: hir::ImplItemKind::Method(..),\n                     ..\n                 }) => {\n-                    let def_id = tcx.hir().local_def_id(node_id);\n+                    let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n                     let generics = tcx.generics_of(def_id);\n                     if !generics.requires_monomorphization(tcx) &&\n                         // Functions marked with #[inline] are only ever codegened\n@@ -343,8 +343,8 @@ fn upstream_monomorphizations_for_provider<'a, 'tcx>(\n }\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> bool {\n-    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-        !tcx.reachable_set(LOCAL_CRATE).0.contains(&node_id)\n+    if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+        !tcx.reachable_set(LOCAL_CRATE).0.contains(&hir_id)\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\",\n              def_id)"}, {"sha": "1750aa62dd5e0f9d43b82e5123be8ddb327d3989", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -408,8 +408,8 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             pprust_hir::AnnNode::Name(_) => Ok(()),\n             pprust_hir::AnnNode::Item(item) => {\n                 s.s.space()?;\n-                s.synth_comment(format!(\"node_id: {} hir local_id: {}\",\n-                                        item.id, item.hir_id.local_id.as_u32()))\n+                s.synth_comment(format!(\"hir_id: {} hir local_id: {}\",\n+                                        item.hir_id, item.hir_id.local_id.as_u32()))\n             }\n             pprust_hir::AnnNode::SubItem(id) => {\n                 s.s.space()?;\n@@ -428,8 +428,8 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             }\n             pprust_hir::AnnNode::Pat(pat) => {\n                 s.s.space()?;\n-                s.synth_comment(format!(\"pat node_id: {} hir local_id: {}\",\n-                                        pat.id, pat.hir_id.local_id.as_u32()))\n+                s.synth_comment(format!(\"pat hir_id: {} hir local_id: {}\",\n+                                        pat.hir_id, pat.hir_id.local_id.as_u32()))\n             }\n         }\n     }"}, {"sha": "65f8ce75bd1135d29e73f7591bbca5dd8d806b52", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -249,7 +249,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n-    pub fn lookup_item(&self, names: &[String]) -> ast::NodeId {\n+    pub fn lookup_item(&self, names: &[String]) -> hir::HirId {\n         return match search_mod(self, &self.infcx.tcx.hir().krate().module, 0, names) {\n             Some(id) => id,\n             None => {\n@@ -262,7 +262,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             m: &hir::Mod,\n             idx: usize,\n             names: &[String],\n-        ) -> Option<ast::NodeId> {\n+        ) -> Option<hir::HirId> {\n             assert!(idx < names.len());\n             for item in &m.item_ids {\n                 let item = this.infcx.tcx.hir().expect_item(item.id);\n@@ -273,9 +273,9 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        fn search(this: &Env, it: &hir::Item, idx: usize, names: &[String]) -> Option<ast::NodeId> {\n+        fn search(this: &Env, it: &hir::Item, idx: usize, names: &[String]) -> Option<hir::HirId> {\n             if idx == names.len() {\n-                return Some(it.id);\n+                return Some(it.hir_id);\n             }\n \n             return match it.node {"}, {"sha": "8ed03efd1a784ab8ca39ba712178d54d2e07e36d", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -3,7 +3,6 @@ use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use syntax::ast;\n use syntax::attr;\n \n pub fn find<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Option<DefId> {\n@@ -19,17 +18,17 @@ fn proc_macro_decls_static<'tcx>(\n     let mut finder = Finder { decls: None };\n     tcx.hir().krate().visit_all_item_likes(&mut finder);\n \n-    finder.decls.map(|id| tcx.hir().local_def_id(id))\n+    finder.decls.map(|id| tcx.hir().local_def_id_from_hir_id(id))\n }\n \n struct Finder {\n-    decls: Option<ast::NodeId>,\n+    decls: Option<hir::HirId>,\n }\n \n impl<'v> ItemLikeVisitor<'v> for Finder {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if attr::contains_name(&item.attrs, \"rustc_proc_macro_decls\") {\n-            self.decls = Some(item.id);\n+            self.decls = Some(item.hir_id);\n         }\n     }\n "}, {"sha": "641adec82cdd9e11d3e849445bc1bf43adee7339", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -26,7 +26,7 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::{self, Ty};\n use rustc::{lint, util};\n use hir::Node;\n-use util::nodemap::NodeSet;\n+use util::nodemap::HirIdSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass, EarlyLintPass, EarlyContext};\n \n@@ -137,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) => {\n-                let def_id = cx.tcx.hir().local_def_id(it.id);\n+                let def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n                 self.check_heap_type(cx, it.span, cx.tcx.type_of(def_id))\n             }\n             _ => ()\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n-                    let def_id = cx.tcx.hir().local_def_id(struct_field.id);\n+                    let def_id = cx.tcx.hir().local_def_id_from_hir_id(struct_field.hir_id);\n                     self.check_heap_type(cx, struct_field.span,\n                                          cx.tcx.type_of(def_id));\n                 }\n@@ -447,8 +447,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n                     self.private_traits.insert(it.hir_id);\n                     for trait_item_ref in trait_item_refs {\n-                        let hir_id = cx.tcx.hir().node_to_hir_id(trait_item_ref.id.node_id);\n-                        self.private_traits.insert(hir_id);\n+                        self.private_traits.insert(trait_item_ref.id.hir_id);\n                     }\n                     return;\n                 }\n@@ -464,9 +463,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                         Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {\n-                                    let hir_id = cx.tcx.hir().node_to_hir_id(\n-                                        impl_item_ref.id.node_id);\n-                                    self.private_traits.insert(hir_id);\n+                                    self.private_traits.insert(impl_item_ref.id.hir_id);\n                                 }\n                             }\n                         }\n@@ -560,29 +557,30 @@ impl LintPass for MissingCopyImplementations {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n-        if !cx.access_levels.is_reachable(item.id) {\n+        let node_id = cx.tcx.hir().hir_to_node_id(item.hir_id);\n+        if !cx.access_levels.is_reachable(node_id) {\n             return;\n         }\n         let (def, ty) = match item.node {\n             hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.id));\n+                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -610,7 +608,7 @@ declare_lint! {\n }\n \n pub struct MissingDebugImplementations {\n-    impling_types: Option<NodeSet>,\n+    impling_types: Option<HirIdSet>,\n }\n \n impl MissingDebugImplementations {\n@@ -631,7 +629,8 @@ impl LintPass for MissingDebugImplementations {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n-        if !cx.access_levels.is_reachable(item.id) {\n+        let node_id = cx.tcx.hir().hir_to_node_id(item.hir_id);\n+        if !cx.access_levels.is_reachable(node_id) {\n             return;\n         }\n \n@@ -648,11 +647,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let mut impls = NodeSet::default();\n+            let mut impls = HirIdSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                    if let Some(node_id) = cx.tcx.hir().as_local_node_id(ty_def.did) {\n-                        impls.insert(node_id);\n+                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(ty_def.did) {\n+                        impls.insert(hir_id);\n                     }\n                 }\n             });\n@@ -661,7 +660,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             debug!(\"{:?}\", self.impling_types);\n         }\n \n-        if !self.impling_types.as_ref().unwrap().contains(&item.id) {\n+        if !self.impling_types.as_ref().unwrap().contains(&item.hir_id) {\n             cx.span_lint(MISSING_DEBUG_IMPLEMENTATIONS,\n                          item.span,\n                          \"type does not implement `fmt::Debug`; consider adding #[derive(Debug)] \\\n@@ -858,7 +857,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n             _ => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id(it.id);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n         let prfn = match cx.tcx.extern_mod_stmt_cnum(def_id) {\n             Some(cnum) => cx.tcx.plugin_registrar_fn(cnum),\n             None => {\n@@ -1078,7 +1077,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext<'_, '_>, item: &hir::Item) {\n         if let hir::ItemKind::Union(ref vdata, _) = item.node {\n             for field in vdata.fields() {\n-                let field_ty = ctx.tcx.type_of(ctx.tcx.hir().local_def_id(field.id));\n+                let field_ty = ctx.tcx.type_of(\n+                    ctx.tcx.hir().local_def_id_from_hir_id(field.hir_id));\n                 if field_ty.needs_drop(ctx.tcx, ctx.param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,\n@@ -1357,7 +1357,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n \n \n         if cx.tcx.features().trivial_bounds {\n-            let def_id = cx.tcx.hir().local_def_id(item.id);\n+            let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in &predicates.predicates {\n                 let predicate_kind_name = match predicate {\n@@ -1497,14 +1497,14 @@ declare_lint! {\n }\n \n pub struct UnnameableTestItems {\n-    boundary: ast::NodeId, // NodeId of the item under which things are not nameable\n+    boundary: hir::HirId, // HirId of the item under which things are not nameable\n     items_nameable: bool,\n }\n \n impl UnnameableTestItems {\n     pub fn new() -> Self {\n         Self {\n-            boundary: ast::DUMMY_NODE_ID,\n+            boundary: hir::DUMMY_HIR_ID,\n             items_nameable: true\n         }\n     }\n@@ -1526,7 +1526,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n             if let hir::ItemKind::Mod(..) = it.node {}\n             else {\n                 self.items_nameable = false;\n-                self.boundary = it.id;\n+                self.boundary = it.hir_id;\n             }\n             return;\n         }\n@@ -1541,7 +1541,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n     }\n \n     fn check_item_post(&mut self, _cx: &LateContext<'_, '_>, it: &hir::Item) {\n-        if !self.items_nameable && self.boundary == it.id {\n+        if !self.items_nameable && self.boundary == it.hir_id {\n             self.items_nameable = true;\n         }\n     }\n@@ -1791,7 +1791,7 @@ impl ExplicitOutlivesRequirements {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n-        let def_id = cx.tcx.hir().local_def_id(item.id);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if let hir::ItemKind::Struct(_, ref generics) = item.node {\n             let mut bound_count = 0;\n             let mut lint_spans = Vec::new();"}, {"sha": "4ad1a00afe97c2fec84f4a4f92dd4e0a987ad68c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -762,8 +762,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_foreign_fn(&mut self, id: ast::NodeId, decl: &hir::FnDecl) {\n-        let def_id = self.cx.tcx.hir().local_def_id(id);\n+    fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl) {\n+        let def_id = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n         let inputs = if sig.c_variadic {\n@@ -786,8 +786,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_foreign_static(&mut self, id: ast::NodeId, span: Span) {\n-        let def_id = self.cx.tcx.hir().local_def_id(id);\n+    fn check_foreign_static(&mut self, id: hir::HirId, span: Span) {\n+        let def_id = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n         let ty = self.cx.tcx.type_of(def_id);\n         self.check_type_for_ffi_and_report_errors(span, ty);\n     }\n@@ -809,14 +809,14 @@ impl LintPass for ImproperCTypes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::ForeignItem) {\n         let mut vis = ImproperCTypesVisitor { cx };\n-        let abi = cx.tcx.hir().get_foreign_abi(it.id);\n+        let abi = cx.tcx.hir().get_foreign_abi_by_hir_id(it.hir_id);\n         if abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic {\n             match it.node {\n                 hir::ForeignItemKind::Fn(ref decl, _, _) => {\n-                    vis.check_foreign_fn(it.id, decl);\n+                    vis.check_foreign_fn(it.hir_id, decl);\n                 }\n                 hir::ForeignItemKind::Static(ref ty, _) => {\n-                    vis.check_foreign_static(it.id, ty.span);\n+                    vis.check_foreign_static(it.hir_id, ty.span);\n                 }\n                 hir::ForeignItemKind::Type => ()\n             }\n@@ -839,7 +839,7 @@ impl LintPass for VariantSizeDifferences {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.node {\n-            let item_def_id = cx.tcx.hir().local_def_id(it.id);\n+            let item_def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             let t = cx.tcx.type_of(item_def_id);\n             let ty = cx.tcx.erase_regions(&t);\n             match cx.layout_of(ty) {"}, {"sha": "f79cfa3b773eb48e35b7c5f060672d683119e8c7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -29,7 +29,7 @@ use std::hash::Hash;\n use std::path::Path;\n use rustc_data_structures::sync::Lrc;\n use std::u32;\n-use syntax::ast::{self, CRATE_NODE_ID};\n+use syntax::ast;\n use syntax::attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::keywords;\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Public };\n         index.record(DefId::local(CRATE_DEF_INDEX),\n                      IsolatedEncoder::encode_info_for_mod,\n-                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &vis)));\n+                     FromId(hir::CRATE_HIR_ID, (&krate.module, &krate.attrs, &vis)));\n         let mut visitor = EncodeVisitor { index };\n         krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n         for macro_def in &krate.exported_macros {\n@@ -588,8 +588,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             }\n         };\n \n-        let enum_id = tcx.hir().as_local_node_id(enum_did).unwrap();\n-        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n+        let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n+        let enum_vis = &tcx.hir().expect_item_by_hir_id(enum_id).vis;\n \n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n@@ -624,7 +624,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                                                                  &hir::Visibility)>)\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id(id);\n+        let def_id = tcx.hir().local_def_id_from_hir_id(id);\n         debug!(\"IsolatedEncoder::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n@@ -714,8 +714,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             }\n         };\n \n-        let struct_id = tcx.hir().as_local_node_id(adt_def_id).unwrap();\n-        let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n+        let struct_id = tcx.hir().as_local_hir_id(adt_def_id).unwrap();\n+        let struct_vis = &tcx.hir().expect_item_by_hir_id(struct_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n         for field in &variant.fields {\n             if ctor_vis.is_at_least(field.vis, tcx) {\n@@ -1055,7 +1055,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 EntryKind::Fn(self.lazy(&data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, &item.vis)));\n+                return self.encode_info_for_mod(FromId(item.hir_id, (m, &item.attrs, &item.vis)));\n             }\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1069,7 +1069,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n                 let struct_ctor = if !struct_def.is_struct() {\n-                    Some(tcx.hir().local_def_id(struct_def.id()).index)\n+                    Some(tcx.hir().local_def_id_from_hir_id(struct_def.hir_id()).index)\n                 } else {\n                     None\n                 };\n@@ -1154,14 +1154,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&item.vis, item.id, tcx)),\n+            visibility: self.lazy(&ty::Visibility::from_hir(&item.vis, item.hir_id, tcx)),\n             span: self.lazy(&item.span),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n                 hir::ItemKind::ForeignMod(ref fm) => {\n                     self.lazy_seq(fm.items\n                         .iter()\n-                        .map(|foreign_item| tcx.hir().local_def_id(foreign_item.id).index))\n+                        .map(|foreign_item| tcx.hir().local_def_id_from_hir_id(\n+                            foreign_item.hir_id).index))\n                 }\n                 hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n@@ -1609,7 +1610,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n         Entry {\n             kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.id, tcx)),\n+            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, tcx)),\n             span: self.lazy(&nitem.span),\n             attributes: self.encode_attributes(&nitem.attrs),\n             children: LazySeq::empty(),\n@@ -1645,7 +1646,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.index.tcx.hir().local_def_id(item.id);\n+        let def_id = self.index.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         match item.node {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => (), // ignore these\n@@ -1655,7 +1656,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.index.tcx.hir().local_def_id(ni.id);\n+        let def_id = self.index.tcx.hir().local_def_id_from_hir_id(ni.hir_id);\n         self.index.record(def_id,\n                           IsolatedEncoder::encode_info_for_foreign_item,\n                           (def_id, ni));\n@@ -1741,7 +1742,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.hir().local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         match item.node {\n             hir::ItemKind::Static(..) |\n             hir::ItemKind::Const(..) |\n@@ -1771,7 +1772,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n                 // If the struct has a constructor, encode it.\n                 if !struct_def.is_struct() {\n-                    let ctor_def_id = self.tcx.hir().local_def_id(struct_def.id());\n+                    let ctor_def_id = self.tcx.hir().local_def_id_from_hir_id(struct_def.hir_id());\n                     self.record(ctor_def_id,\n                                 IsolatedEncoder::encode_struct_ctor,\n                                 (def_id, ctor_def_id));\n@@ -1806,7 +1807,7 @@ struct ImplVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::Impl(..) = item.node {\n-            let impl_id = self.tcx.hir().local_def_id(item.id);\n+            let impl_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls\n                     .entry(trait_ref.def_id)"}, {"sha": "284f6796145a8a3487460ede44b661cd3e8e1c0d", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -25,11 +25,11 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n         };\n \n         let foreign_items = fm.items.iter()\n-            .map(|it| self.tcx.hir().local_def_id(it.id))\n+            .map(|it| self.tcx.hir().local_def_id_from_hir_id(it.hir_id))\n             .collect();\n         self.modules.push(ForeignModule {\n             foreign_items,\n-            def_id: self.tcx.hir().local_def_id(it.id),\n+            def_id: self.tcx.hir().local_def_id_from_hir_id(it.hir_id),\n         });\n     }\n "}, {"sha": "8343171b99f4b6f38d5195592c7e123312429dd0", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -215,10 +215,10 @@ impl<T> DepGraphRead for Untracked<T> {\n /// HIR node that doesn't carry its own ID. This will allow an\n /// arbitrary `T` to be passed in, but register a read on the given\n /// `NodeId`.\n-pub struct FromId<T>(pub ast::NodeId, pub T);\n+pub struct FromId<T>(pub hir::HirId, pub T);\n \n impl<T> DepGraphRead for FromId<T> {\n     fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-        tcx.hir().read(self.0);\n+        tcx.hir().read_by_hir_id(self.0);\n     }\n }"}, {"sha": "23898387cba4677680027793ec6fce3d0108b455", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                 name: None,\n                 kind: cstore::NativeUnknown,\n                 cfg: None,\n-                foreign_module: Some(self.tcx.hir().local_def_id(it.id)),\n+                foreign_module: Some(self.tcx.hir().local_def_id_from_hir_id(it.hir_id)),\n                 wasm_import_module: None,\n             };\n             let mut kind_specified = false;"}, {"sha": "61ead366a87c52121bd843b59e4b2c97dd0369ad", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -229,7 +229,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      -> Mir<'tcx>\n {\n     let span = tcx.hir().span(ctor_id);\n-    if let hir::VariantData::Tuple(ref fields, ctor_id, _) = *v {\n+    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n         tcx.infer_ctxt().enter(|infcx| {\n             let mut mir = shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n \n@@ -245,7 +245,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             };\n \n             mir_util::dump_mir(tcx, None, \"mir_map\", &0,\n-                               MirSource::item(tcx.hir().local_def_id(ctor_id)),\n+                               MirSource::item(tcx.hir().local_def_id_from_hir_id(ctor_id)),\n                                &mir, |_, _| Ok(()) );\n \n             mir"}, {"sha": "8b16eeeea23c0513743a93004d93ac3113a85a36", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n         let tcx = self.tcx.global_tcx();\n-        let p = match tcx.hir().get(p.id) {\n+        let p = match tcx.hir().get_by_hir_id(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };"}, {"sha": "3d8c085567f1c2768d65dde4577b066655e3b535", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -24,7 +24,6 @@ use rustc::hir::{self, Pat, PatKind};\n use smallvec::smallvec;\n use std::slice;\n \n-use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n \n@@ -241,7 +240,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n-        let module = self.tcx.hir().get_module_parent(pat.id);\n+        let module = self.tcx.hir().get_module_parent_by_hir_id(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx,\n                                                 self.param_env.and(self.identity_substs),\n@@ -586,7 +585,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n             ty::ImmBorrow | ty::UniqueImmBorrow => {}\n         }\n     }\n-    fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: hir::HirId, _: Span) {}\n     fn mutate(&mut self, _: hir::HirId, span: Span, _: &cmt_<'_>, mode: MutateMode) {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {"}, {"sha": "1f20c70dec503099698b908736200a908af10a38", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -952,7 +952,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemKind::Union(_, ref generics) => {\n                 if generics.params.is_empty() {\n                     if self.mode == MonoItemCollectionMode::Eager {\n-                        let def_id = self.tcx.hir().local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n                                def_id_to_string(self.tcx, def_id));\n \n@@ -964,11 +964,12 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemKind::GlobalAsm(..) => {\n                 debug!(\"RootCollector: ItemKind::GlobalAsm({})\",\n                        def_id_to_string(self.tcx,\n-                                        self.tcx.hir().local_def_id(item.id)));\n-                self.output.push(MonoItem::GlobalAsm(item.id));\n+                                        self.tcx.hir().local_def_id_from_hir_id(item.hir_id)));\n+                let node_id = self.tcx.hir().hir_to_node_id(item.hir_id);\n+                self.output.push(MonoItem::GlobalAsm(node_id));\n             }\n             hir::ItemKind::Static(..) => {\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 debug!(\"RootCollector: ItemKind::Static({})\",\n                        def_id_to_string(self.tcx, def_id));\n                 self.output.push(MonoItem::Static(def_id));\n@@ -978,7 +979,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 // actually used somewhere. Just declaring them is insufficient.\n \n                 // but even just declaring them must collect the items they refer to\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n                 let instance = Instance::mono(self.tcx, def_id);\n                 let cid = GlobalId {\n@@ -992,7 +993,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 }\n             }\n             hir::ItemKind::Fn(..) => {\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 self.push_if_root(def_id);\n             }\n         }\n@@ -1097,7 +1098,7 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n             }\n \n-            let impl_def_id = tcx.hir().local_def_id(item.id);\n+            let impl_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n             debug!(\"create_mono_items_for_default_impls(item={})\",\n                    def_id_to_string(tcx, impl_def_id));"}, {"sha": "db8476f3be5f79afa61b66ffef97a352be1b2006", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -10,7 +10,6 @@ use rustc::ty::query::Providers;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use rustc_target::spec::abi::Abi;\n-use syntax::ast;\n use syntax_pos::Span;\n \n use std::fmt;\n@@ -855,14 +854,14 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n-                                      ctor_id: ast::NodeId,\n+                                      ctor_id: hir::HirId,\n                                       fields: &[hir::StructField],\n                                       span: Span)\n                                       -> Mir<'tcx>\n {\n     let tcx = infcx.tcx;\n     let gcx = tcx.global_tcx();\n-    let def_id = tcx.hir().local_def_id(ctor_id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(ctor_id);\n     let param_env = gcx.param_env(def_id);\n \n     // Normalize the sig."}, {"sha": "8f5fc6963771a87c1889172a10d9430b7c6d8229", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -80,8 +80,8 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n                               _: &'tcx hir::Generics,\n                               _: hir::HirId,\n                               _: Span) {\n-            if let hir::VariantData::Tuple(_, node_id, _) = *v {\n-                self.set.insert(self.tcx.hir().local_def_id(node_id));\n+            if let hir::VariantData::Tuple(_, hir_id) = *v {\n+                self.set.insert(self.tcx.hir().local_def_id_from_hir_id(hir_id));\n             }\n             intravisit::walk_struct_def(self, v)\n         }"}, {"sha": "7fe3f5a36d850178804d2f06119005aebd31b24d", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -27,7 +27,7 @@ struct VarianceTest<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let item_def_id = self.tcx.hir().local_def_id(item.id);\n+        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n         if let ItemKind::Ty(..) = item.node {\n             for attr in self.tcx.get_attrs(item_def_id).iter() {"}, {"sha": "edd658254467f95a7da1721b7f2c5b43f36e104a", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -26,7 +26,6 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::util::nodemap::{ItemLocalSet, HirIdSet};\n use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n-use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use log::debug;\n use Promotability::*;\n@@ -677,7 +676,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n         }\n     }\n \n-    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n+    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) {}\n     fn mutate(&mut self,\n               _assignment_id: hir::HirId,\n               _assignment_span: Span,"}, {"sha": "31018a7cd7a3ca7969627a4fe3038687c32d8e57", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -1,6 +1,5 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n-use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -10,15 +9,15 @@ use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n \n struct RegistrarFinder {\n-    registrars: Vec<(ast::NodeId, Span)> ,\n+    registrars: Vec<(hir::HirId, Span)> ,\n }\n \n impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::Fn(..) = item.node {\n             if attr::contains_name(&item.attrs,\n                                    \"plugin_registrar\") {\n-                self.registrars.push((item.id, item.span));\n+                self.registrars.push((item.hir_id, item.span));\n             }\n         }\n     }\n@@ -47,8 +46,8 @@ fn plugin_registrar_fn<'tcx>(\n     match finder.registrars.len() {\n         0 => None,\n         1 => {\n-            let (node_id, _) = finder.registrars.pop().unwrap();\n-            Some(tcx.hir().local_def_id(node_id))\n+            let (hir_id, _) = finder.registrars.pop().unwrap();\n+            Some(tcx.hir().local_def_id_from_hir_id(hir_id))\n         },\n         _ => {\n             let diagnostic = tcx.sess.diagnostic();"}, {"sha": "550b333700b04939b3f39cc446368bd2ca35694e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 100, "deletions": 96, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::subst::InternalSubsts;\n use rustc::util::nodemap::HirIdSet;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n-use syntax::ast::{self, DUMMY_NODE_ID, Ident};\n+use syntax::ast::Ident;\n use syntax::attr;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n@@ -220,16 +220,16 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n \n fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                                -> (ty::Visibility, Span, &'static str) {\n-    match tcx.hir().as_local_node_id(def_id) {\n-        Some(node_id) => {\n-            let vis = match tcx.hir().get(node_id) {\n+    match tcx.hir().as_local_hir_id(def_id) {\n+        Some(hir_id) => {\n+            let vis = match tcx.hir().get_by_hir_id(hir_id) {\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n                 Node::TraitItem(..) | Node::Variant(..) => {\n-                    return def_id_visibility(tcx, tcx.hir().get_parent_did(node_id));\n+                    return def_id_visibility(tcx, tcx.hir().get_parent_did_by_hir_id(hir_id));\n                 }\n                 Node::ImplItem(impl_item) => {\n-                    match tcx.hir().get(tcx.hir().get_parent(node_id)) {\n+                    match tcx.hir().get_by_hir_id(tcx.hir().get_parent_item(hir_id)) {\n                         Node::Item(item) => match &item.node {\n                             hir::ItemKind::Impl(.., None, _, _) => &impl_item.vis,\n                             hir::ItemKind::Impl(.., Some(trait_ref), _, _)\n@@ -240,16 +240,16 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                     }\n                 }\n                 Node::StructCtor(vdata) => {\n-                    let struct_node_id = tcx.hir().get_parent(node_id);\n-                    let item = match tcx.hir().get(struct_node_id) {\n+                    let struct_hir_id = tcx.hir().get_parent_item(hir_id);\n+                    let item = match tcx.hir().get_by_hir_id(struct_hir_id) {\n                         Node::Item(item) => item,\n                         node => bug!(\"unexpected node kind: {:?}\", node),\n                     };\n                     let (mut ctor_vis, mut span, mut descr) =\n-                        (ty::Visibility::from_hir(&item.vis, struct_node_id, tcx),\n+                        (ty::Visibility::from_hir(&item.vis, struct_hir_id, tcx),\n                          item.vis.span, item.vis.node.descr());\n                     for field in vdata.fields() {\n-                        let field_vis = ty::Visibility::from_hir(&field.vis, node_id, tcx);\n+                        let field_vis = ty::Visibility::from_hir(&field.vis, hir_id, tcx);\n                         if ctor_vis.is_at_least(field_vis, tcx) {\n                             ctor_vis = field_vis;\n                             span = field.vis.span;\n@@ -260,7 +260,7 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                     // If the structure is marked as non_exhaustive then lower the\n                     // visibility to within the crate.\n                     if ctor_vis == ty::Visibility::Public {\n-                        let adt_def = tcx.adt_def(tcx.hir().get_parent_did(node_id));\n+                        let adt_def = tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id));\n                         if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n                             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n                             span = attr::find_by_name(&item.attrs, \"non_exhaustive\").unwrap().span;\n@@ -277,7 +277,7 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                 }\n                 node => bug!(\"unexpected node kind: {:?}\", node)\n             };\n-            (ty::Visibility::from_hir(vis, node_id, tcx), vis.span, vis.node.descr())\n+            (ty::Visibility::from_hir(vis, hir_id, tcx), vis.span, vis.node.descr())\n         }\n         None => {\n             let vis = tcx.visibility(def_id);\n@@ -349,10 +349,10 @@ trait VisibilityLike: Sized {\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl<'a, 'tcx>(node_id: ast::NodeId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn of_impl<'a, 'tcx>(hir_id: hir::HirId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          access_levels: &'a AccessLevels) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n-        let def_id = tcx.hir().local_def_id(node_id);\n+        let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n         find.visit(tcx.type_of(def_id));\n         if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n             find.visit_trait(trait_ref);\n@@ -409,28 +409,30 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n-    fn get(&self, id: ast::NodeId) -> Option<AccessLevel> {\n-        self.access_levels.map.get(&id).cloned()\n+    fn get(&self, id: hir::HirId) -> Option<AccessLevel> {\n+        let node_id = self.tcx.hir().hir_to_node_id(id);\n+        self.access_levels.map.get(&node_id).cloned()\n     }\n \n     // Updates node level and returns the updated level.\n-    fn update(&mut self, id: ast::NodeId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n+    fn update(&mut self, id: hir::HirId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n         let old_level = self.get(id);\n         // Accessibility levels can only grow.\n         if level > old_level {\n-            self.access_levels.map.insert(id, level.unwrap());\n+            let node_id = self.tcx.hir().hir_to_node_id(id);\n+            self.access_levels.map.insert(node_id, level.unwrap());\n             self.changed = true;\n             level\n         } else {\n             old_level\n         }\n     }\n \n-    fn reach(&mut self, item_id: ast::NodeId, access_level: Option<AccessLevel>)\n+    fn reach(&mut self, item_id: hir::HirId, access_level: Option<AccessLevel>)\n              -> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n-            item_def_id: self.tcx.hir().local_def_id(item_id),\n+            item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n             ev: self,\n         }\n     }\n@@ -464,7 +466,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n                         let def_id = self.tcx.hir().local_def_id(item_id.id);\n                         if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) { continue; }\n                         if let hir::ItemKind::Use(..) = item.node {\n-                            self.update(item.id, Some(AccessLevel::Exported));\n+                            self.update(item.hir_id, Some(AccessLevel::Exported));\n                         }\n                     }\n                 }\n@@ -483,7 +485,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             hir::ItemKind::Impl(..) =>\n-                Option::<AccessLevel>::of_impl(item.id, self.tcx, &self.access_levels),\n+                Option::<AccessLevel>::of_impl(item.hir_id, self.tcx, &self.access_levels),\n             // Foreign modules inherit level from parents.\n             hir::ItemKind::ForeignMod(..) => self.prev_level,\n             // Other `pub` items inherit levels from parents.\n@@ -498,44 +500,44 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         };\n \n         // Update level of the item itself.\n-        let item_level = self.update(item.id, inherited_item_level);\n+        let item_level = self.update(item.hir_id, inherited_item_level);\n \n         // Update levels of nested things.\n         match item.node {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    let variant_level = self.update(variant.node.data.id(), item_level);\n+                    let variant_level = self.update(variant.node.data.hir_id(), item_level);\n                     for field in variant.node.data.fields() {\n-                        self.update(field.id, variant_level);\n+                        self.update(field.hir_id, variant_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     if trait_ref.is_some() || impl_item_ref.vis.node.is_pub() {\n-                        self.update(impl_item_ref.id.node_id, item_level);\n+                        self.update(impl_item_ref.id.hir_id, item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.node_id, item_level);\n+                    self.update(trait_item_ref.id.hir_id, item_level);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 if !def.is_struct() {\n-                    self.update(def.id(), item_level);\n+                    self.update(def.hir_id(), item_level);\n                 }\n                 for field in def.fields() {\n                     if field.vis.node.is_pub() {\n-                        self.update(field.id, item_level);\n+                        self.update(field.hir_id, item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if foreign_item.vis.node.is_pub() {\n-                        self.update(foreign_item.id, item_level);\n+                        self.update(foreign_item.hir_id, item_level);\n                     }\n                 }\n             }\n@@ -572,21 +574,21 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                 // reachable if they are returned via `impl Trait`, even from private functions.\n                 let exist_level = cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n-                self.reach(item.id, exist_level).generics().predicates().ty();\n+                self.reach(item.hir_id, exist_level).generics().predicates().ty();\n             }\n             // Visit everything.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) |\n             hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates().ty();\n+                    self.reach(item.hir_id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates();\n+                    self.reach(item.hir_id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n-                        let mut reach = self.reach(trait_item_ref.id.node_id, item_level);\n+                        let mut reach = self.reach(trait_item_ref.id.hir_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssociatedItemKind::Type &&\n@@ -600,18 +602,18 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates();\n+                    self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(.., ref impl_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates().ty().trait_ref();\n+                    self.reach(item.hir_id, item_level).generics().predicates().ty().trait_ref();\n \n                     for impl_item_ref in impl_item_refs {\n-                        let impl_item_level = self.get(impl_item_ref.id.node_id);\n+                        let impl_item_level = self.get(impl_item_ref.id.hir_id);\n                         if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.node_id, impl_item_level)\n+                            self.reach(impl_item_ref.id.hir_id, impl_item_level)\n                                 .generics().predicates().ty();\n                         }\n                     }\n@@ -621,26 +623,26 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates();\n+                    self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n                 for variant in &def.variants {\n-                    let variant_level = self.get(variant.node.data.id());\n+                    let variant_level = self.get(variant.node.data.hir_id());\n                     if variant_level.is_some() {\n                         for field in variant.node.data.fields() {\n-                            self.reach(field.id, variant_level).ty();\n+                            self.reach(field.hir_id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.update(item.id, variant_level);\n+                        self.update(item.hir_id, variant_level);\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    let foreign_item_level = self.get(foreign_item.id);\n+                    let foreign_item_level = self.get(foreign_item.hir_id);\n                     if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id, foreign_item_level)\n+                        self.reach(foreign_item.hir_id, foreign_item_level)\n                             .generics().predicates().ty();\n                     }\n                 }\n@@ -649,11 +651,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates();\n+                    self.reach(item.hir_id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_level = self.get(field.id);\n+                        let field_level = self.get(field.hir_id);\n                         if field_level.is_some() {\n-                            self.reach(field.id, field_level).ty();\n+                            self.reach(field.hir_id, field_level).ty();\n                         }\n                     }\n                 }\n@@ -683,8 +685,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 for export in exports.iter() {\n                     if export.vis == ty::Visibility::Public {\n                         if let Some(def_id) = export.def.opt_def_id() {\n-                            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-                                self.update(node_id, Some(AccessLevel::Exported));\n+                            if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                                self.update(hir_id, Some(AccessLevel::Exported));\n                             }\n                         }\n                     }\n@@ -696,49 +698,48 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        let node_id = self.tcx.hir().hir_to_node_id(md.hir_id);\n-\n         if md.legacy {\n-            self.update(node_id, Some(AccessLevel::Public));\n+            self.update(md.hir_id, Some(AccessLevel::Public));\n             return\n         }\n \n         let module_did = ty::DefIdTree::parent(\n             self.tcx,\n             self.tcx.hir().local_def_id_from_hir_id(md.hir_id)\n         ).unwrap();\n-        let mut module_id = self.tcx.hir().as_local_node_id(module_did).unwrap();\n+        let mut module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n-        let level = self.update(node_id, level);\n+        let level = self.update(md.hir_id, level);\n         if level.is_none() {\n             return\n         }\n \n         loop {\n-            let module = if module_id == ast::CRATE_NODE_ID {\n+            let module = if module_id == hir::CRATE_HIR_ID {\n                 &self.tcx.hir().krate().module\n             } else if let hir::ItemKind::Mod(ref module) =\n-                          self.tcx.hir().expect_item(module_id).node {\n+                          self.tcx.hir().expect_item_by_hir_id(module_id).node {\n                 module\n             } else {\n                 unreachable!()\n             };\n             for id in &module.item_ids {\n-                self.update(id.id, level);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id.id);\n+                self.update(hir_id, level);\n             }\n-            let def_id = self.tcx.hir().local_def_id(module_id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(module_id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n-                    if let Some(node_id) = self.tcx.hir().as_local_node_id(export.def.def_id()) {\n-                        self.update(node_id, level);\n+                    if let Some(hir_id) = self.tcx.hir().as_local_hir_id(export.def.def_id()) {\n+                        self.update(hir_id, level);\n                     }\n                 }\n             }\n \n-            if module_id == ast::CRATE_NODE_ID {\n+            if module_id == hir::CRATE_HIR_ID {\n                 break\n             }\n-            module_id = self.tcx.hir().get_parent_node(module_id);\n+            module_id = self.tcx.hir().get_parent_node_by_hir_id(module_id);\n         }\n     }\n }\n@@ -779,8 +780,8 @@ impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.ev.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n-        if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(def_id) {\n-            self.ev.update(node_id, self.access_level);\n+        if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n+            self.ev.update(hir_id, self.access_level);\n         }\n         false\n     }\n@@ -796,7 +797,7 @@ impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'\n struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    current_item: ast::NodeId,\n+    current_item: hir::HirId,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n@@ -808,7 +809,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n                    def: &'tcx ty::AdtDef, // definition of the struct or enum\n                    field: &'tcx ty::FieldDef) { // definition of the field\n         let ident = Ident::new(keywords::Invalid.name(), use_ctxt);\n-        let current_hir = self.tcx.hir().node_to_hir_id(self.current_item);\n+        let current_hir = self.current_item;\n         let def_id = self.tcx.adjust_ident(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n@@ -839,7 +840,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.id);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.hir_id);\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n         intravisit::walk_item(self, item);\n@@ -1110,8 +1111,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item =\n-            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.id));\n+        let orig_current_item = mem::replace(&mut self.current_item,\n+            self.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n         let orig_in_body = mem::replace(&mut self.in_body, false);\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n@@ -1190,10 +1191,11 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n+    fn trait_is_public(&self, trait_id: hir::HirId) -> bool {\n         // FIXME: this would preferably be using `exported_items`, but all\n         // traits are exported currently (see `EmbargoVisitor.exported_trait`).\n-        self.access_levels.is_public(trait_id)\n+        let node_id = self.tcx.hir().hir_to_node_id(trait_id);\n+        self.access_levels.is_public(node_id)\n     }\n \n     fn check_generic_bound(&mut self, bound: &hir::GenericBound) {\n@@ -1204,8 +1206,9 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn item_is_public(&self, id: &ast::NodeId, vis: &hir::Visibility) -> bool {\n-        self.access_levels.is_reachable(*id) || vis.node.is_pub()\n+    fn item_is_public(&self, id: &hir::HirId, vis: &hir::Visibility) -> bool {\n+        let node_id = self.tcx.hir().hir_to_node_id(*id);\n+        self.access_levels.is_reachable(node_id) || vis.node.is_pub()\n     }\n }\n \n@@ -1253,7 +1256,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::ForeignMod(_) => {}\n \n             hir::ItemKind::Trait(.., ref bounds, _) => {\n-                if !self.trait_is_public(item.id) {\n+                if !self.trait_is_public(item.hir_id) {\n                     return\n                 }\n \n@@ -1295,8 +1298,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                               |tr| {\n                         let did = tr.path.def.def_id();\n \n-                        if let Some(node_id) = self.tcx.hir().as_local_node_id(did) {\n-                            self.trait_is_public(node_id)\n+                        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n+                            self.trait_is_public(hir_id)\n                         } else {\n                             true // external traits must be public\n                         }\n@@ -1318,9 +1321,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                      match impl_item.node {\n                                          hir::ImplItemKind::Const(..) |\n                                          hir::ImplItemKind::Method(..) => {\n-                                             let node_id = self.tcx.hir().hir_to_node_id(\n-                                                impl_item.hir_id);\n-                                             self.access_levels.is_reachable(node_id)\n+                                             self.access_levels.is_reachable(\n+                                                self.tcx.hir().hir_to_node_id(\n+                                                    impl_item_ref.id.hir_id))\n                                          }\n                                          hir::ImplItemKind::Existential(..) |\n                                          hir::ImplItemKind::Type(_) => false,\n@@ -1342,11 +1345,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                                let node_id = self.tcx.hir().hir_to_node_id(impl_item.hir_id);\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n-                                        if self.item_is_public(&node_id, &impl_item.vis) =>\n+                                        if self.item_is_public(&impl_item.hir_id, &impl_item.vis) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -1387,7 +1389,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_item_refs {\n-                        if self.item_is_public(&impl_item_ref.id.node_id, &impl_item_ref.vis) {\n+                        if self.item_is_public(&impl_item_ref.id.hir_id, &impl_item_ref.vis) {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n                                 AssociatedItemKind::Const => {\n@@ -1414,7 +1416,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::Ty(..) => return,\n \n             // Not at all public, so we don't care.\n-            _ if !self.item_is_public(&item.id, &item.vis) => {\n+            _ if !self.item_is_public(&item.hir_id, &item.vis) => {\n                 return;\n             }\n \n@@ -1450,7 +1452,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n-        if self.access_levels.is_reachable(item.id) {\n+        let node_id = self.tcx.hir().hir_to_node_id(item.hir_id);\n+        if self.access_levels.is_reachable(node_id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1468,7 +1471,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        if self.access_levels.is_reachable(v.node.data.id()) {\n+        let node_id = self.tcx.hir().hir_to_node_id(v.node.data.hir_id());\n+        if self.access_levels.is_reachable(node_id) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n@@ -1671,7 +1675,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let tcx = self.tcx;\n-        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, tcx);\n+        let item_visibility = ty::Visibility::from_hir(&item.vis, item.hir_id, tcx);\n \n         match item.node {\n             // Crates are always public.\n@@ -1696,8 +1700,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n-                    let hir_id = tcx.hir().node_to_hir_id(trait_item_ref.id.node_id);\n-                    self.check_trait_or_impl_item(hir_id, trait_item_ref.kind,\n+                    self.check_trait_or_impl_item(trait_item_ref.id.hir_id, trait_item_ref.kind,\n                                                   trait_item_ref.defaultness, item_visibility);\n                 }\n             }\n@@ -1716,7 +1719,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    let vis = ty::Visibility::from_hir(&foreign_item.vis, item.id, tcx);\n+                    let vis = ty::Visibility::from_hir(&foreign_item.vis, item.hir_id, tcx);\n                     self.check(foreign_item.hir_id, vis).generics().predicates().ty();\n                 }\n             }\n@@ -1726,7 +1729,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n-                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, tcx);\n+                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.hir_id, tcx);\n                     self.check(field.hir_id, min(item_visibility, field_visibility, tcx)).ty();\n                 }\n             }\n@@ -1735,17 +1738,18 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n-                let impl_vis = ty::Visibility::of_impl(item.id, tcx, &Default::default());\n+                let impl_vis = ty::Visibility::of_impl(item.hir_id, tcx, &Default::default());\n                 self.check(item.hir_id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n                     let impl_item_vis = if trait_ref.is_none() {\n-                        min(ty::Visibility::from_hir(&impl_item.vis, item.id, tcx), impl_vis, tcx)\n+                        min(ty::Visibility::from_hir(&impl_item.vis, item.hir_id, tcx),\n+                            impl_vis,\n+                            tcx)\n                     } else {\n                         impl_vis\n                     };\n-                    let hir_id = tcx.hir().node_to_hir_id(impl_item_ref.id.node_id);\n-                    self.check_trait_or_impl_item(hir_id, impl_item_ref.kind,\n+                    self.check_trait_or_impl_item(impl_item_ref.id.hir_id, impl_item_ref.kind,\n                                                   impl_item_ref.defaultness, impl_item_vis);\n                 }\n             }\n@@ -1773,7 +1777,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     let mut visitor = NamePrivacyVisitor {\n         tcx,\n         tables: &empty_tables,\n-        current_item: DUMMY_NODE_ID,\n+        current_item: hir::DUMMY_HIR_ID,\n         empty_tables: &empty_tables,\n     };\n     let (module, span, node_id) = tcx.hir().get_module(module_def_id);\n@@ -1827,7 +1831,7 @@ fn privacy_access_levels<'tcx>(\n             break\n         }\n     }\n-    visitor.update(ast::CRATE_NODE_ID, Some(AccessLevel::Public));\n+    visitor.update(hir::CRATE_HIR_ID, Some(AccessLevel::Public));\n \n     {\n         let mut visitor = ObsoleteVisiblePrivateTypesVisitor {"}, {"sha": "59766e7e47d6aeb3c22f1f264641110088623cf2", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -760,11 +760,11 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             .source_map()\n                             .span_to_snippet(trait_span)\n                             .ok()?;\n-                        let trait_m = tcx.hir().as_local_node_id(trait_m.def_id)?;\n-                        let trait_m = tcx.hir().trait_item(hir::TraitItemId { node_id: trait_m });\n+                        let trait_m = tcx.hir().as_local_hir_id(trait_m.def_id)?;\n+                        let trait_m = tcx.hir().trait_item(hir::TraitItemId { hir_id: trait_m });\n \n-                        let impl_m = tcx.hir().as_local_node_id(impl_m.def_id)?;\n-                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { node_id: impl_m });\n+                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n \n                         // in case there are no generics, take the spot between the function name\n                         // and the opening paren of the argument list\n@@ -805,8 +805,8 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (None, Some(hir::SyntheticTyParamKind::ImplTrait)) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n                     (|| {\n-                        let impl_m = tcx.hir().as_local_node_id(impl_m.def_id)?;\n-                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { node_id: impl_m });\n+                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n                         let input_tys = match impl_m.node {\n                             hir::ImplItemKind::Method(ref sig, _) => &sig.decl.inputs,\n                             _ => unreachable!(),"}, {"sha": "40c60caffa42d8eb7dd81d67af010c49b924e428", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -22,7 +22,7 @@ fn equate_intrinsic_type<'a, 'tcx>(\n     inputs: Vec<Ty<'tcx>>,\n     output: Ty<'tcx>,\n ) {\n-    let def_id = tcx.hir().local_def_id(it.id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n \n     match it.node {\n         hir::ForeignItemKind::Fn(..) => {}"}, {"sha": "4bf6471a6293cc3764768dff2a00576a5452dd51", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -732,7 +732,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n     impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n         fn visit_item(&mut self, i: &'v hir::Item) {\n             if let hir::ItemKind::Trait(..) = i.node {\n-                let def_id = self.map.local_def_id(i.id);\n+                let def_id = self.map.local_def_id_from_hir_id(i.hir_id);\n                 self.traits.push(def_id);\n             }\n         }"}, {"sha": "183667e224462a108d4df59055eaf37beadf7441", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -1008,9 +1008,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         if let PatKind::Binding(_, _, _, ident, _) = p.node {\n             let var_ty = self.assign(p.span, p.hir_id, None);\n \n+            let node_id = self.fcx.tcx.hir().hir_to_node_id(p.hir_id);\n             if !self.fcx.tcx.features().unsized_locals {\n                 self.fcx.require_type_is_sized(var_ty, p.span,\n-                                               traits::VariableType(p.id));\n+                                               traits::VariableType(node_id));\n             }\n \n             debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n@@ -1289,9 +1290,9 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          id: ast::NodeId,\n+                          id: hir::HirId,\n                           span: Span) {\n-    let def_id = tcx.hir().local_def_id(id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -1305,9 +1306,9 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         id: ast::NodeId,\n+                         id: hir::HirId,\n                          span: Span) {\n-    let def_id = tcx.hir().local_def_id(id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -1338,28 +1339,28 @@ fn check_opaque<'a, 'tcx>(\n \n pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n     debug!(\n-        \"check_item_type(it.id={}, it.name={})\",\n-        it.id,\n-        tcx.item_path_str(tcx.hir().local_def_id(it.id))\n+        \"check_item_type(it.hir_id={}, it.name={})\",\n+        it.hir_id,\n+        tcx.item_path_str(tcx.hir().local_def_id_from_hir_id(it.hir_id))\n     );\n     let _indenter = indenter();\n     match it.node {\n         // Consts can play a role in type-checking, so they are included here.\n         hir::ItemKind::Static(..) => {\n-            let def_id = tcx.hir().local_def_id(it.id);\n+            let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             tcx.typeck_tables_of(def_id);\n             maybe_check_static_with_link_section(tcx, def_id, it.span);\n         }\n         hir::ItemKind::Const(..) => {\n-            tcx.typeck_tables_of(tcx.hir().local_def_id(it.id));\n+            tcx.typeck_tables_of(tcx.hir().local_def_id_from_hir_id(it.hir_id));\n         }\n         hir::ItemKind::Enum(ref enum_definition, _) => {\n-            check_enum(tcx, it.span, &enum_definition.variants, it.id);\n+            check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n         }\n         hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-            debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.id);\n-            let impl_def_id = tcx.hir().local_def_id(it.id);\n+            debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.hir_id);\n+            let impl_def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n@@ -1373,23 +1374,23 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n             }\n         }\n         hir::ItemKind::Trait(..) => {\n-            let def_id = tcx.hir().local_def_id(it.id);\n+            let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             check_on_unimplemented(tcx, def_id, it);\n         }\n         hir::ItemKind::Struct(..) => {\n-            check_struct(tcx, it.id, it.span);\n+            check_struct(tcx, it.hir_id, it.span);\n         }\n         hir::ItemKind::Union(..) => {\n-            check_union(tcx, it.id, it.span);\n+            check_union(tcx, it.hir_id, it.span);\n         }\n         hir::ItemKind::Existential(..) => {\n-            let def_id = tcx.hir().local_def_id(it.id);\n+            let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n \n             let substs = InternalSubsts::identity_for_item(tcx, def_id);\n             check_opaque(tcx, def_id, substs, it.span);\n         }\n         hir::ItemKind::Ty(..) => {\n-            let def_id = tcx.hir().local_def_id(it.id);\n+            let def_id = tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             let pty_ty = tcx.type_of(def_id);\n             let generics = tcx.generics_of(def_id);\n             check_bounds_are_used(tcx, &generics, pty_ty);\n@@ -1407,7 +1408,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n                 }\n             } else {\n                 for item in &m.items {\n-                    let generics = tcx.generics_of(tcx.hir().local_def_id(item.id));\n+                    let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(item.hir_id));\n                     if generics.params.len() - generics.own_counts().lifetimes != 0 {\n                         let mut err = struct_span_err!(\n                             tcx.sess,\n@@ -1476,7 +1477,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_, '_, '_>, id: DefId, span\n fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     trait_def_id: DefId,\n                                     item: &hir::Item) {\n-    let item_def_id = tcx.hir().local_def_id(item.id);\n+    let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     // an error would be reported if this fails.\n     let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n }\n@@ -1842,8 +1843,8 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             sp: Span,\n                             vs: &'tcx [hir::Variant],\n-                            id: ast::NodeId) {\n-    let def_id = tcx.hir().local_def_id(id);\n+                            id: hir::HirId) {\n+    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n "}, {"sha": "89e8b2b840d1fee0e5c7ed9392f271a87fd9984b", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -635,7 +635,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n+    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) {}\n \n     fn mutate(\n         &mut self,"}, {"sha": "860fa526a1b9133343df385ee4f741bc04b066bd", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -241,7 +241,7 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n         let variants = lookup_fields(fcx);\n-        let def_id = fcx.tcx.hir().local_def_id(item.id);\n+        let def_id = fcx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let packed = fcx.tcx.adt_def(def_id).repr.packed();\n \n         for variant in &variants {\n@@ -302,9 +302,9 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n-    debug!(\"check_trait: {:?}\", item.id);\n+    debug!(\"check_trait: {:?}\", item.hir_id);\n \n-    let trait_def_id = tcx.hir().local_def_id(item.id);\n+    let trait_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n     let trait_def = tcx.trait_def(trait_def_id);\n     if trait_def.is_marker {\n@@ -326,7 +326,7 @@ fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n \n fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n-        let def_id = fcx.tcx.hir().local_def_id(item.id);\n+        let def_id = fcx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let sig = fcx.tcx.fn_sig(def_id);\n         let sig = fcx.normalize_associated_types_in(item.span, &sig);\n         let mut implied_bounds = vec![];\n@@ -376,7 +376,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"check_impl: {:?}\", item);\n \n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n-        let item_def_id = fcx.tcx.hir().local_def_id(item.id);\n+        let item_def_id = fcx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n@@ -887,7 +887,7 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            item: &hir::Item,\n                                            hir_generics: &hir::Generics)\n {\n-    let item_def_id = tcx.hir().local_def_id(item.id);\n+    let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     let ty = tcx.type_of(item_def_id);\n     if tcx.has_error_field(ty) {\n         return;\n@@ -1018,7 +1018,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n-        let def_id = self.tcx.hir().local_def_id(i.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(i.hir_id);\n         self.tcx.ensure().check_item_well_formed(def_id);\n     }\n \n@@ -1050,7 +1050,7 @@ struct AdtField<'tcx> {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn non_enum_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n         let fields = struct_def.fields().iter().map(|field| {\n-            let field_ty = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n+            let field_ty = self.tcx.type_of(self.tcx.hir().local_def_id_from_hir_id(field.hir_id));\n             let field_ty = self.normalize_associated_types_in(field.span,\n                                                               &field_ty);\n             AdtField { ty: field_ty, span: field.span }"}, {"sha": "6079f12936b5cf0fde634627ddf93f4eea7fdb33", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -212,7 +212,7 @@ struct ExternCrateToLint {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::ExternCrate(orig_name) = item.node {\n-            let extern_crate_def_id = self.tcx.hir().local_def_id(item.id);\n+            let extern_crate_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             self.crates_to_lint.push(\n                 ExternCrateToLint {\n                     def_id: extern_crate_def_id,"}, {"sha": "d167c7fcafbe4807ce8f7a0bf7bb44623e14c730", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             _ => return\n         };\n \n-        let def_id = self.tcx.hir().local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let self_ty = self.tcx.type_of(def_id);\n         let lang_items = self.tcx.lang_items();\n         match self_ty.sty {\n@@ -288,7 +288,7 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            let impl_def_id = self.tcx.hir().local_def_id(item.id);\n+            let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             let mut rc_vec = self.impls_map.inherent_impls\n                                            .entry(def_id)\n                                            .or_default();"}, {"sha": "832c172e97c18e79f089d82e1fbc47558f864b41", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Trait(..) |\n             hir::ItemKind::Union(..) => {\n-                let type_def_id = self.tcx.hir().local_def_id(item.id);\n+                let type_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n             }\n             _ => {}"}, {"sha": "c875b856f3a4f1805af5a3eccc8871ee04e5d676", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -22,11 +22,11 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.hir().local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         // \"Trait\" impl\n         if let hir::ItemKind::Impl(.., Some(_), _, _) = item.node {\n             debug!(\"coherence2::orphan check: trait impl {}\",\n-                   self.tcx.hir().node_to_string(item.id));\n+                   self.tcx.hir().hir_to_string(item.hir_id));\n             let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n             let trait_def_id = trait_ref.def_id;\n             let cm = self.tcx.sess.source_map();"}, {"sha": "0b1de510aa4bde686ef7ef797222e39457481bef", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -21,7 +21,8 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity)\n     {\n-        if let Some(trait_ref) = self.tcx.impl_trait_ref(self.tcx.hir().local_def_id(item.id)) {\n+        let local_did = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(local_did) {\n             let trait_def = self.tcx.trait_def(trait_ref.def_id);\n             let unsafe_attr = impl_generics.and_then(|generics| {\n                 generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\")"}, {"sha": "594e29ab9ddea5f80998e2f6dc8bd117aca85e02", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        convert_item(self.tcx, item.id);\n+        convert_item(self.tcx, item.hir_id);\n         intravisit::walk_item(self, item);\n     }\n \n@@ -397,10 +397,10 @@ fn is_param<'a, 'tcx>(\n     }\n }\n \n-fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n-    let it = tcx.hir().expect_item(item_id);\n-    debug!(\"convert: item {} with id {}\", it.ident, it.id);\n-    let def_id = tcx.hir().local_def_id(item_id);\n+fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n+    let it = tcx.hir().expect_item_by_hir_id(item_id);\n+    debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n     match it.node {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n@@ -409,7 +409,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n         | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n-                let def_id = tcx.hir().local_def_id(item.id);\n+                let def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n@@ -447,14 +447,14 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n             tcx.predicates_of(def_id);\n \n             for f in struct_def.fields() {\n-                let def_id = tcx.hir().local_def_id(f.id);\n+                let def_id = tcx.hir().local_def_id_from_hir_id(f.hir_id);\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n                 tcx.predicates_of(def_id);\n             }\n \n             if !struct_def.is_struct() {\n-                convert_variant_ctor(tcx, struct_def.id());\n+                convert_variant_ctor(tcx, struct_def.hir_id());\n             }\n         }\n \n@@ -510,8 +510,8 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: hir::H\n     }\n }\n \n-fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ctor_id: ast::NodeId) {\n-    let def_id = tcx.hir().local_def_id(ctor_id);\n+fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ctor_id: hir::HirId) {\n+    let def_id = tcx.hir().local_def_id_from_hir_id(ctor_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n@@ -555,15 +555,15 @@ fn convert_enum_variant_types<'a, 'tcx>(\n         );\n \n         for f in variant.node.data.fields() {\n-            let def_id = tcx.hir().local_def_id(f.id);\n+            let def_id = tcx.hir().local_def_id_from_hir_id(f.hir_id);\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        convert_variant_ctor(tcx, variant.node.data.id());\n+        convert_variant_ctor(tcx, variant.node.data.hir_id());\n     }\n }\n \n@@ -577,12 +577,12 @@ fn convert_variant<'a, 'tcx>(\n     attribute_def_id: DefId\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n-    let node_id = tcx.hir().as_local_node_id(did).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(did).unwrap();\n     let fields = def\n         .fields()\n         .iter()\n         .map(|f| {\n-            let fid = tcx.hir().local_def_id(f.id);\n+            let fid = tcx.hir().local_def_id_from_hir_id(f.hir_id);\n             let dup_span = seen_fields.get(&f.ident.modern()).cloned();\n             if let Some(prev_span) = dup_span {\n                 struct_span_err!(\n@@ -601,7 +601,7 @@ fn convert_variant<'a, 'tcx>(\n             ty::FieldDef {\n                 did: fid,\n                 ident: f.ident,\n-                vis: ty::Visibility::from_hir(&f.vis, node_id, tcx),\n+                vis: ty::Visibility::from_hir(&f.vis, hir_id, tcx),\n             }\n         })\n         .collect();\n@@ -634,7 +634,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n                 def.variants\n                     .iter()\n                     .map(|v| {\n-                        let did = tcx.hir().local_def_id(v.node.data.id());\n+                        let did = tcx.hir().local_def_id_from_hir_id(v.node.data.hir_id());\n                         let discr = if let Some(ref e) = v.node.disr_expr {\n                             distance_from_explicit = 0;\n                             ty::VariantDiscr::Explicit(tcx.hir().local_def_id_from_hir_id(e.hir_id))\n@@ -652,7 +652,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n         ItemKind::Struct(ref def, _) => {\n             // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n             let ctor_id = if !def.is_struct() {\n-                Some(tcx.hir().local_def_id(def.id()))\n+                Some(tcx.hir().local_def_id_from_hir_id(def.hir_id()))\n             } else {\n                 None\n             };\n@@ -937,12 +937,12 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                     //\n                     // Something of a hack: use the node id for the trait, also as\n                     // the node id for the Self type parameter.\n-                    let param_id = item.id;\n+                    let param_id = item.hir_id;\n \n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n                         name: keywords::SelfUpper.name().as_interned_str(),\n-                        def_id: tcx.hir().local_def_id(param_id),\n+                        def_id: tcx.hir().local_def_id_from_hir_id(param_id),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,\n@@ -1477,7 +1477,7 @@ fn find_existential_constraints<'a, 'tcx>(\n             intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n         fn visit_item(&mut self, it: &'tcx Item) {\n-            let def_id = self.tcx.hir().local_def_id(it.id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             // the existential type itself or its children are not within its reveal scope\n             if def_id != self.def_id {\n                 self.check(def_id);\n@@ -1577,7 +1577,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n             let ty = tcx.type_of(tcx.hir().get_parent_did(node_id));\n             let inputs = fields\n                 .iter()\n-                .map(|f| tcx.type_of(tcx.hir().local_def_id(f.id)));\n+                .map(|f| tcx.type_of(tcx.hir().local_def_id_from_hir_id(f.hir_id)));\n             ty::Binder::bind(tcx.mk_fn_sig(\n                 inputs,\n                 ty,"}, {"sha": "b79277ffbbce82e97180590604a8cf8300e277be", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -79,7 +79,7 @@ struct ImplWfCheck<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.node {\n-            let impl_def_id = self.tcx.hir().local_def_id(item.id);\n+            let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             enforce_impl_params_are_constrained(self.tcx,\n                                                 impl_def_id,\n                                                 impl_item_refs);\n@@ -108,7 +108,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()\n-        .map(|item_ref| tcx.hir().local_def_id(item_ref.id.node_id))\n+        .map(|item_ref| tcx.hir().local_def_id_from_hir_id(item_ref.id.hir_id))\n         .filter(|&def_id| {\n             let item = tcx.associated_item(def_id);\n             item.kind == ty::AssociatedKind::Type && item.defaultness.has_value()"}, {"sha": "b560f3b4979208e18b892538a73e6c3cdd951e2e", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -52,16 +52,16 @@ pub struct InferVisitor<'cx, 'tcx: 'cx> {\n \n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let item_did = self.tcx.hir().local_def_id(item.id);\n+        let item_did = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n-        let node_id = self\n+        let hir_id = self\n             .tcx\n             .hir()\n-            .as_local_node_id(item_did)\n+            .as_local_hir_id(item_did)\n             .expect(\"expected local def-id\");\n-        let item = match self.tcx.hir().get(node_id) {\n+        let item = match self.tcx.hir().get_by_hir_id(hir_id) {\n             Node::Item(item) => item,\n             _ => bug!(),\n         };"}, {"sha": "e10c8361207186d15e32b4b7aaeee89a690fa840", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -14,7 +14,7 @@ struct OutlivesTest<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for OutlivesTest<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let item_def_id = self.tcx.hir().local_def_id(item.id);\n+        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found."}, {"sha": "50c8d5adfa3702d255dcddf5bd5a8a0ca0ed5986", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         debug!(\"add_inferreds for item {}\",\n-               self.tcx.hir().node_to_string(item.id));\n+               self.tcx.hir().hir_to_string(item.hir_id));\n \n         match item.node {\n             hir::ItemKind::Struct(ref struct_def, _) |"}, {"sha": "d04b1b276a2cc9156a7a9583f76b2e266825e435", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -12,7 +12,7 @@ struct VarianceTest<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let item_def_id = self.tcx.hir().local_def_id(item.id);\n+        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found."}, {"sha": "c64a73fa308e111758e948d5f083a7b270d90f8d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -1725,7 +1725,7 @@ impl Clean<Item> for doctree::Function {\n             (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n         });\n \n-        let did = cx.tcx.hir().local_def_id(self.id);\n+        let did = cx.tcx.hir().local_def_id_from_hir_id(self.id);\n         let constness = if cx.tcx.is_min_const_fn(did) {\n             hir::Constness::Const\n         } else {\n@@ -1932,7 +1932,7 @@ impl Clean<Item> for doctree::Trait {\n             name: Some(self.name.clean(cx)),\n             attrs: attrs,\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -1962,7 +1962,7 @@ impl Clean<Item> for doctree::TraitAlias {\n             name: Some(self.name.clean(cx)),\n             attrs,\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2913,14 +2913,16 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n+\n         Item {\n             name: Some(self.ident.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.tcx.hir().local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.hir().local_def_id(self.id)),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            stability: get_stability(cx, local_did),\n+            deprecation: get_deprecation(cx, local_did),\n+            def_id: local_did,\n             inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n@@ -2992,7 +2994,7 @@ impl Clean<Item> for doctree::Struct {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3012,7 +3014,7 @@ impl Clean<Item> for doctree::Union {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3059,7 +3061,7 @@ impl Clean<Item> for doctree::Enum {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3086,7 +3088,7 @@ impl Clean<Item> for doctree::Variant {\n             visibility: None,\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.def.id()),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.def.hir_id()),\n             inner: VariantItem(Variant {\n                 kind: self.def.clean(cx),\n             }),\n@@ -3375,7 +3377,7 @@ impl Clean<Item> for doctree::Typedef {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id.clone()),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3399,7 +3401,7 @@ impl Clean<Item> for doctree::Existential {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id.clone()),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3450,7 +3452,7 @@ impl Clean<Item> for doctree::Static {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3475,7 +3477,7 @@ impl Clean<Item> for doctree::Constant {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3589,7 +3591,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -3819,14 +3821,16 @@ impl Clean<Item> for hir::ForeignItem {\n             }\n         };\n \n+        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n+\n         Item {\n             name: Some(self.ident.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: local_did,\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.tcx.hir().local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.hir().local_def_id(self.id)),\n+            stability: get_stability(cx, local_did),\n+            deprecation: get_deprecation(cx, local_did),\n             inner,\n         }\n     }\n@@ -4034,7 +4038,7 @@ impl Clean<Item> for doctree::ProcMacro {\n             visibility: Some(Public),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             inner: ProcMacroItem(ProcMacro {\n                 kind: self.kind,\n                 helpers: self.helpers.clean(cx),"}, {"sha": "9c54b40b422aedd3fbe713f0599b5b8a8838fa0a", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -89,7 +89,7 @@ pub struct Struct {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub id: NodeId,\n+    pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n     pub generics: hir::Generics,\n@@ -102,7 +102,7 @@ pub struct Union {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub id: NodeId,\n+    pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n     pub generics: hir::Generics,\n@@ -118,7 +118,7 @@ pub struct Enum {\n     pub variants: hir::HirVec<Variant>,\n     pub generics: hir::Generics,\n     pub attrs: hir::HirVec<ast::Attribute>,\n-    pub id: NodeId,\n+    pub id: hir::HirId,\n     pub whence: Span,\n     pub name: Name,\n }\n@@ -135,7 +135,7 @@ pub struct Variant {\n pub struct Function {\n     pub decl: hir::FnDecl,\n     pub attrs: hir::HirVec<ast::Attribute>,\n-    pub id: NodeId,\n+    pub id: hir::HirId,\n     pub name: Name,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -150,7 +150,7 @@ pub struct Typedef {\n     pub ty: P<hir::Ty>,\n     pub gen: hir::Generics,\n     pub name: Name,\n-    pub id: ast::NodeId,\n+    pub id: hir::HirId,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n@@ -161,7 +161,7 @@ pub struct Typedef {\n pub struct Existential {\n     pub exist_ty: hir::ExistTy,\n     pub name: Name,\n-    pub id: ast::NodeId,\n+    pub id: hir::HirId,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n@@ -179,7 +179,7 @@ pub struct Static {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub id: ast::NodeId,\n+    pub id: hir::HirId,\n     pub whence: Span,\n }\n \n@@ -191,7 +191,7 @@ pub struct Constant {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub id: ast::NodeId,\n+    pub id: hir::HirId,\n     pub whence: Span,\n }\n \n@@ -203,7 +203,7 @@ pub struct Trait {\n     pub generics: hir::Generics,\n     pub bounds: hir::HirVec<hir::GenericBound>,\n     pub attrs: hir::HirVec<ast::Attribute>,\n-    pub id: ast::NodeId,\n+    pub id: hir::HirId,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -215,7 +215,7 @@ pub struct TraitAlias {\n     pub generics: hir::Generics,\n     pub bounds: hir::HirVec<hir::GenericBound>,\n     pub attrs: hir::HirVec<ast::Attribute>,\n-    pub id: ast::NodeId,\n+    pub id: hir::HirId,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -236,7 +236,7 @@ pub struct Impl {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub id: ast::NodeId,\n+    pub id: hir::HirId,\n }\n \n // For Macro we store the DefId instead of the NodeId, since we also create\n@@ -263,7 +263,7 @@ pub struct ExternCrate {\n \n pub struct Import {\n     pub name: Name,\n-    pub id: NodeId,\n+    pub id: hir::HirId,\n     pub vis: hir::Visibility,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub path: hir::Path,\n@@ -273,7 +273,7 @@ pub struct Import {\n \n pub struct ProcMacro {\n     pub name: Name,\n-    pub id: NodeId,\n+    pub id: hir::HirId,\n     pub kind: MacroKind,\n     pub helpers: Vec<Name>,\n     pub attrs: hir::HirVec<ast::Attribute>,"}, {"sha": "c1bd1d83a5b00b17ed9c7f387ba0a3a42ced2e71", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea22717a1e01fa535534b85a5347a7e49fc79de/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0ea22717a1e01fa535534b85a5347a7e49fc79de", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n         Struct {\n-            id: item.id,\n+            id: item.hir_id,\n             struct_type,\n             name,\n             vis: item.vis.clone(),\n@@ -120,7 +120,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         debug!(\"Visiting union\");\n         let struct_type = struct_type_from_def(&*sd);\n         Union {\n-            id: item.id,\n+            id: item.hir_id,\n             struct_type,\n             name,\n             vis: item.vis.clone(),\n@@ -152,7 +152,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             depr: self.deprecation(it.hir_id),\n             generics: params.clone(),\n             attrs: it.attrs.clone(),\n-            id: it.id,\n+            id: it.hir_id,\n             whence: it.span,\n         }\n     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n \n                 om.proc_macros.push(ProcMacro {\n                     name,\n-                    id: item.id,\n+                    id: item.hir_id,\n                     kind,\n                     helpers,\n                     attrs: item.attrs.clone(),\n@@ -213,7 +213,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             }\n             None => {\n                 om.fns.push(Function {\n-                    id: item.id,\n+                    id: item.hir_id,\n                     vis: item.vis.clone(),\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n@@ -262,7 +262,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n     ///\n     /// Returns `true` if the target has been inlined.\n     fn maybe_inline_local(&mut self,\n-                          id: ast::NodeId,\n+                          id: hir::HirId,\n                           def: Def,\n                           renamed: Option<ast::Ident>,\n                           glob: bool,\n@@ -291,7 +291,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             return false;\n         };\n \n-        let use_attrs = tcx.hir().attrs(id);\n+        let use_attrs = tcx.hir().attrs_by_hir_id(id);\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n                            use_attrs.lists(\"doc\").has_word(\"hidden\");\n@@ -357,7 +357,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             Node::ForeignItem(it) if !glob => {\n                 // Generate a fresh `extern {}` block if we want to inline a foreign item.\n                 om.foreigns.push(hir::ForeignMod {\n-                    abi: tcx.hir().get_foreign_abi(it.id),\n+                    abi: tcx.hir().get_foreign_abi_by_hir_id(it.hir_id),\n                     items: vec![hir::ForeignItem {\n                         ident: renamed.unwrap_or(it.ident),\n                         .. it.clone()\n@@ -381,7 +381,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         let ident = renamed.unwrap_or(item.ident);\n \n         if item.vis.node.is_pub() {\n-            let def_id = self.cx.tcx.hir().local_def_id(item.id);\n+            let def_id = self.cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             self.store_path(def_id);\n         }\n \n@@ -401,7 +401,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             _ if self.inlining && !item.vis.node.is_pub() => {}\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::ExternCrate(orig_name) => {\n-                let def_id = self.cx.tcx.hir().local_def_id(item.id);\n+                let def_id = self.cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 om.extern_crates.push(ExternCrate {\n                     cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id)\n                                 .unwrap_or(LOCAL_CRATE),\n@@ -436,7 +436,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                         }\n                     });\n                     let ident = if is_glob { None } else { Some(ident) };\n-                    if self.maybe_inline_local(item.id,\n+                    if self.maybe_inline_local(item.hir_id,\n                                                path.def,\n                                                ident,\n                                                is_glob,\n@@ -448,7 +448,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n \n                 om.imports.push(Import {\n                     name: ident.name,\n-                    id: item.id,\n+                    id: item.hir_id,\n                     vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n                     path: (**path).clone(),\n@@ -477,7 +477,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     ty: ty.clone(),\n                     gen: gen.clone(),\n                     name: ident.name,\n-                    id: item.id,\n+                    id: item.hir_id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n@@ -490,7 +490,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 let t = Existential {\n                     exist_ty: exist_ty.clone(),\n                     name: ident.name,\n-                    id: item.id,\n+                    id: item.hir_id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n@@ -504,7 +504,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     type_: ty.clone(),\n                     mutability: mut_.clone(),\n                     expr: exp.clone(),\n-                    id: item.id,\n+                    id: item.hir_id,\n                     name: ident.name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n@@ -518,7 +518,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 let s = Constant {\n                     type_: ty.clone(),\n                     expr: exp.clone(),\n-                    id: item.id,\n+                    id: item.hir_id,\n                     name: ident.name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n@@ -539,7 +539,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     items,\n                     generics: gen.clone(),\n                     bounds: b.iter().cloned().collect(),\n-                    id: item.id,\n+                    id: item.hir_id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n@@ -553,7 +553,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     name: ident.name,\n                     generics: gen.clone(),\n                     bounds: b.iter().cloned().collect(),\n-                    id: item.id,\n+                    id: item.hir_id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n@@ -585,7 +585,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                         for_: ty.clone(),\n                         items,\n                         attrs: item.attrs.clone(),\n-                        id: item.id,\n+                        id: item.hir_id,\n                         whence: item.span,\n                         vis: item.vis.clone(),\n                         stab: self.stability(item.hir_id),"}]}