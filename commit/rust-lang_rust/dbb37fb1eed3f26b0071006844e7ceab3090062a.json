{"sha": "dbb37fb1eed3f26b0071006844e7ceab3090062a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYjM3ZmIxZWVkM2YyNmIwMDcxMDA2ODQ0ZTdjZWFiMzA5MDA2MmE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-15T02:02:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-15T02:02:37Z"}, "message": "Rollup merge of #78590 - DeveloperC286:issue_60302, r=varkor\n\nrefactor: removing alloc::collections::vec_deque ignore-tidy-filelength\n\nThis PR removes the need for ignore-tidy-filelength for alloc::collections::vec_deque which is part of the issue https://github.com/rust-lang/rust/issues/60302\n\nIt is probably easiest to review this PR by looking at it commit by commit rather than looking at the overall diff.", "tree": {"sha": "1499d1fd4ee4539439ccb201946dee41a39d5707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1499d1fd4ee4539439ccb201946dee41a39d5707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbb37fb1eed3f26b0071006844e7ceab3090062a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfsIw9CRBK7hj4Ov3rIwAAdHIIAEqgGNoxgacP5lG1ksqj4e2d\n9plf+p+d06++bh68CJxCHH8zfVxWB0obj1VMYU32yq3xU3xS57xvgl2bDe1gu2ra\nG8uxuYuDvYfOiIKrRXHmdNX9Ix/T1RSmDxn3zIi/sUVv9DtITt/xK/kfyXXhL43A\nb0eFKDXTiVon1oJ2ZJnjGdNAx6SYSVBHKwm/c2N8PSPZvUZsDzcLrNhs/tFnTJgk\npFGESa5l4lrYxgeWfeEDUHzmrnMRGNoELI9H5UTZ2se3VThSrO1uVmkWmw2I8F5+\nSvTVCyrfZCVI3BE/7gpqk9qQIjTMFpOO84z8pcxlFrEGJmFtMMDIi1iHD/M6XzM=\n=I5Yt\n-----END PGP SIGNATURE-----\n", "payload": "tree 1499d1fd4ee4539439ccb201946dee41a39d5707\nparent dc4d65579cd0ae6d92e207bb19682d0a2426706d\nparent 75dfc711da035ab8cc29a2dc32644f47e9d16ed8\nauthor Dylan DPC <dylan.dpc@gmail.com> 1605405757 +0100\ncommitter GitHub <noreply@github.com> 1605405757 +0100\n\nRollup merge of #78590 - DeveloperC286:issue_60302, r=varkor\n\nrefactor: removing alloc::collections::vec_deque ignore-tidy-filelength\n\nThis PR removes the need for ignore-tidy-filelength for alloc::collections::vec_deque which is part of the issue https://github.com/rust-lang/rust/issues/60302\n\nIt is probably easiest to review this PR by looking at it commit by commit rather than looking at the overall diff.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb37fb1eed3f26b0071006844e7ceab3090062a", "html_url": "https://github.com/rust-lang/rust/commit/dbb37fb1eed3f26b0071006844e7ceab3090062a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbb37fb1eed3f26b0071006844e7ceab3090062a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc4d65579cd0ae6d92e207bb19682d0a2426706d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4d65579cd0ae6d92e207bb19682d0a2426706d", "html_url": "https://github.com/rust-lang/rust/commit/dc4d65579cd0ae6d92e207bb19682d0a2426706d"}, {"sha": "75dfc711da035ab8cc29a2dc32644f47e9d16ed8", "url": "https://api.github.com/repos/rust-lang/rust/commits/75dfc711da035ab8cc29a2dc32644f47e9d16ed8", "html_url": "https://github.com/rust-lang/rust/commit/75dfc711da035ab8cc29a2dc32644f47e9d16ed8"}], "stats": {"total": 988, "additions": 515, "deletions": 473}, "files": [{"sha": "465b058cd98e9fed8c69b8fafadc08f980dbd246", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=dbb37fb1eed3f26b0071006844e7ceab3090062a", "patch": "@@ -0,0 +1,57 @@\n+use core::fmt;\n+use core::iter::FusedIterator;\n+\n+use super::VecDeque;\n+\n+/// An owning iterator over the elements of a `VecDeque`.\n+///\n+/// This `struct` is created by the [`into_iter`] method on [`VecDeque`]\n+/// (provided by the `IntoIterator` trait). See its documentation for more.\n+///\n+/// [`into_iter`]: VecDeque::into_iter\n+#[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IntoIter<T> {\n+    pub(crate) inner: VecDeque<T>,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"IntoIter\").field(&self.inner).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop_front()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.inner.len();\n+        (len, Some(len))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.pop_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ExactSizeIterator for IntoIter<T> {\n+    fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for IntoIter<T> {}"}, {"sha": "ad31b991cb6c34f078c36232fa194c37812cf7ef", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=dbb37fb1eed3f26b0071006844e7ceab3090062a", "patch": "@@ -0,0 +1,159 @@\n+use core::fmt;\n+use core::iter::FusedIterator;\n+use core::ops::Try;\n+\n+use super::{count, wrap_index, RingSlices};\n+\n+/// An iterator over the elements of a `VecDeque`.\n+///\n+/// This `struct` is created by the [`iter`] method on [`super::VecDeque`]. See its\n+/// documentation for more.\n+///\n+/// [`iter`]: super::VecDeque::iter\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Iter<'a, T: 'a> {\n+    pub(crate) ring: &'a [T],\n+    pub(crate) tail: usize,\n+    pub(crate) head: usize,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        f.debug_tuple(\"Iter\").field(&front).field(&back).finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Clone for Iter<'_, T> {\n+    fn clone(&self) -> Self {\n+        Iter { ring: self.ring, tail: self.tail, head: self.head }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n+        unsafe { Some(self.ring.get_unchecked(tail)) }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = count(self.tail, self.head, self.ring.len());\n+        (len, Some(len))\n+    }\n+\n+    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = front.iter().fold(accum, &mut f);\n+        back.iter().fold(accum, &mut f)\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let (mut iter, final_res);\n+        if self.tail <= self.head {\n+            // single slice self.ring[self.tail..self.head]\n+            iter = self.ring[self.tail..self.head].iter();\n+            final_res = iter.try_fold(init, &mut f);\n+        } else {\n+            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            let (front, back) = self.ring.split_at(self.tail);\n+            let mut back_iter = back.iter();\n+            let res = back_iter.try_fold(init, &mut f);\n+            let len = self.ring.len();\n+            self.tail = (self.ring.len() - back_iter.len()) & (len - 1);\n+            iter = front[..self.head].iter();\n+            final_res = iter.try_fold(res?, &mut f);\n+        }\n+        self.tail = self.head - iter.len();\n+        final_res\n+    }\n+\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n+        unsafe { Some(self.ring.get_unchecked(self.head)) }\n+    }\n+\n+    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = back.iter().rfold(accum, &mut f);\n+        front.iter().rfold(accum, &mut f)\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let (mut iter, final_res);\n+        if self.tail <= self.head {\n+            // single slice self.ring[self.tail..self.head]\n+            iter = self.ring[self.tail..self.head].iter();\n+            final_res = iter.try_rfold(init, &mut f);\n+        } else {\n+            // two slices: self.ring[self.tail..], self.ring[..self.head]\n+            let (front, back) = self.ring.split_at(self.tail);\n+            let mut front_iter = front[..self.head].iter();\n+            let res = front_iter.try_rfold(init, &mut f);\n+            self.head = front_iter.len();\n+            iter = back.iter();\n+            final_res = iter.try_rfold(res?, &mut f);\n+        }\n+        self.head = self.tail + iter.len();\n+        final_res\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ExactSizeIterator for Iter<'_, T> {\n+    fn is_empty(&self) -> bool {\n+        self.head == self.tail\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Iter<'_, T> {}"}, {"sha": "3d0c3094e26cd02d9cb6437cbc5e217684923bef", "filename": "library/alloc/src/collections/vec_deque/iter_mut.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs?ref=dbb37fb1eed3f26b0071006844e7ceab3090062a", "patch": "@@ -0,0 +1,128 @@\n+use core::fmt;\n+use core::iter::FusedIterator;\n+use core::marker::PhantomData;\n+\n+use super::{count, wrap_index, RingSlices};\n+\n+/// A mutable iterator over the elements of a `VecDeque`.\n+///\n+/// This `struct` is created by the [`iter_mut`] method on [`super::VecDeque`]. See its\n+/// documentation for more.\n+///\n+/// [`iter_mut`]: super::VecDeque::iter_mut\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IterMut<'a, T: 'a> {\n+    // Internal safety invariant: the entire slice is dereferencable.\n+    pub(crate) ring: *mut [T],\n+    pub(crate) tail: usize,\n+    pub(crate) head: usize,\n+    pub(crate) phantom: PhantomData<&'a mut [T]>,\n+}\n+\n+// SAFETY: we do nothing thread-local and there is no interior mutability,\n+// so the usual structural `Send`/`Sync` apply.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Send> Send for IterMut<'_, T> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // The `IterMut` invariant also ensures everything is dereferencable.\n+        let (front, back) = unsafe { (&*front, &*back) };\n+        f.debug_tuple(\"IterMut\").field(&front).field(&back).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n+\n+        unsafe {\n+            let elem = self.ring.get_unchecked_mut(tail);\n+            Some(&mut *elem)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = count(self.tail, self.head, self.ring.len());\n+        (len, Some(len))\n+    }\n+\n+    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // The `IterMut` invariant also ensures everything is dereferencable.\n+        let (front, back) = unsafe { (&mut *front, &mut *back) };\n+        accum = front.iter_mut().fold(accum, &mut f);\n+        back.iter_mut().fold(accum, &mut f)\n+    }\n+\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a mut T> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n+\n+        unsafe {\n+            let elem = self.ring.get_unchecked_mut(self.head);\n+            Some(&mut *elem)\n+        }\n+    }\n+\n+    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // The `IterMut` invariant also ensures everything is dereferencable.\n+        let (front, back) = unsafe { (&mut *front, &mut *back) };\n+        accum = back.iter_mut().rfold(accum, &mut f);\n+        front.iter_mut().rfold(accum, &mut f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ExactSizeIterator for IterMut<'_, T> {\n+    fn is_empty(&self) -> bool {\n+        self.head == self.tail\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for IterMut<'_, T> {}"}, {"sha": "0d59d312cf406d35c224e88f27b6a748f3e54598", "filename": "library/alloc/src/collections/vec_deque/macros.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmacros.rs?ref=dbb37fb1eed3f26b0071006844e7ceab3090062a", "patch": "@@ -0,0 +1,19 @@\n+macro_rules! __impl_slice_eq1 {\n+    ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n+        #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n+        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n+        where\n+            A: PartialEq<B>,\n+            $($constraints)*\n+        {\n+            fn eq(&self, other: &$rhs) -> bool {\n+                if self.len() != other.len() {\n+                    return false;\n+                }\n+                let (sa, sb) = self.as_slices();\n+                let (oa, ob) = other[..].split_at(sa.len());\n+                sa == oa && sb == ob\n+            }\n+        }\n+    }\n+}"}, {"sha": "1c183858e7a5e814554e2280568a78cd47ed9c85", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "renamed", "additions": 29, "deletions": 472, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=dbb37fb1eed3f26b0071006844e7ceab3090062a", "patch": "@@ -7,28 +7,51 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-// ignore-tidy-filelength\n-\n-use core::array;\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::iter::{repeat_with, FromIterator, FusedIterator};\n+use core::iter::{repeat_with, FromIterator};\n use core::marker::PhantomData;\n-use core::mem::{self, replace, ManuallyDrop};\n-use core::ops::{Index, IndexMut, Range, RangeBounds, Try};\n+use core::mem::{self, ManuallyDrop};\n+use core::ops::{Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice;\n \n use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n+#[macro_use]\n+mod macros;\n+\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub use self::drain::Drain;\n \n mod drain;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::iter_mut::IterMut;\n+\n+mod iter_mut;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::into_iter::IntoIter;\n+\n+mod into_iter;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::iter::Iter;\n+\n+mod iter;\n+\n+use self::pair_slices::PairSlices;\n+\n+mod pair_slices;\n+\n+use self::ring_slices::RingSlices;\n+\n+mod ring_slices;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -68,67 +91,6 @@ pub struct VecDeque<T> {\n     buf: RawVec<T>,\n }\n \n-/// PairSlices pairs up equal length slice parts of two deques\n-///\n-/// For example, given deques \"A\" and \"B\" with the following division into slices:\n-///\n-/// A: [0 1 2] [3 4 5]\n-/// B: [a b] [c d e]\n-///\n-/// It produces the following sequence of matching slices:\n-///\n-/// ([0 1], [a b])\n-/// (\\[2\\], \\[c\\])\n-/// ([3 4], [d e])\n-///\n-/// and the uneven remainder of either A or B is skipped.\n-struct PairSlices<'a, 'b, T> {\n-    a0: &'a mut [T],\n-    a1: &'a mut [T],\n-    b0: &'b [T],\n-    b1: &'b [T],\n-}\n-\n-impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n-    fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n-        let (a0, a1) = to.as_mut_slices();\n-        let (b0, b1) = from.as_slices();\n-        PairSlices { a0, a1, b0, b1 }\n-    }\n-\n-    fn has_remainder(&self) -> bool {\n-        !self.b0.is_empty()\n-    }\n-\n-    fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n-        array::IntoIter::new([self.b0, self.b1])\n-    }\n-}\n-\n-impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T> {\n-    type Item = (&'a mut [T], &'b [T]);\n-    fn next(&mut self) -> Option<Self::Item> {\n-        // Get next part length\n-        let part = cmp::min(self.a0.len(), self.b0.len());\n-        if part == 0 {\n-            return None;\n-        }\n-        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n-        let (q0, q1) = self.b0.split_at(part);\n-\n-        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n-        self.a0 = p1;\n-        self.b0 = q1;\n-        if self.a0.is_empty() {\n-            self.a0 = replace(&mut self.a1, &mut []);\n-        }\n-        if self.b0.is_empty() {\n-            self.b0 = replace(&mut self.b1, &[]);\n-        }\n-        Some((p0, q0))\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for VecDeque<T> {\n     fn clone(&self) -> VecDeque<T> {\n@@ -2605,398 +2567,13 @@ fn wrap_index(index: usize, size: usize) -> usize {\n     index & (size - 1)\n }\n \n-/// Returns the two slices that cover the `VecDeque`'s valid range\n-trait RingSlices: Sized {\n-    fn slice(self, from: usize, to: usize) -> Self;\n-    fn split_at(self, i: usize) -> (Self, Self);\n-\n-    fn ring_slices(buf: Self, head: usize, tail: usize) -> (Self, Self) {\n-        let contiguous = tail <= head;\n-        if contiguous {\n-            let (empty, buf) = buf.split_at(0);\n-            (buf.slice(tail, head), empty)\n-        } else {\n-            let (mid, right) = buf.split_at(tail);\n-            let (left, _) = mid.split_at(head);\n-            (right, left)\n-        }\n-    }\n-}\n-\n-impl<T> RingSlices for &[T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        &self[from..to]\n-    }\n-    fn split_at(self, i: usize) -> (Self, Self) {\n-        (*self).split_at(i)\n-    }\n-}\n-\n-impl<T> RingSlices for &mut [T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        &mut self[from..to]\n-    }\n-    fn split_at(self, i: usize) -> (Self, Self) {\n-        (*self).split_at_mut(i)\n-    }\n-}\n-\n-impl<T> RingSlices for *mut [T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        assert!(from <= to && to < self.len());\n-        // Not using `get_unchecked_mut` to keep this a safe operation.\n-        let len = to - from;\n-        ptr::slice_from_raw_parts_mut(self.as_mut_ptr().wrapping_add(from), len)\n-    }\n-\n-    fn split_at(self, mid: usize) -> (Self, Self) {\n-        let len = self.len();\n-        let ptr = self.as_mut_ptr();\n-        assert!(mid <= len);\n-        (\n-            ptr::slice_from_raw_parts_mut(ptr, mid),\n-            ptr::slice_from_raw_parts_mut(ptr.wrapping_add(mid), len - mid),\n-        )\n-    }\n-}\n-\n /// Calculate the number of elements left to be read in the buffer\n #[inline]\n fn count(tail: usize, head: usize, size: usize) -> usize {\n     // size is always a power of 2\n     (head.wrapping_sub(tail)) & (size - 1)\n }\n \n-/// An iterator over the elements of a `VecDeque`.\n-///\n-/// This `struct` is created by the [`iter`] method on [`VecDeque`]. See its\n-/// documentation for more.\n-///\n-/// [`iter`]: VecDeque::iter\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, T: 'a> {\n-    ring: &'a [T],\n-    tail: usize,\n-    head: usize,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        f.debug_tuple(\"Iter\").field(&front).field(&back).finish()\n-    }\n-}\n-\n-// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for Iter<'_, T> {\n-    fn clone(&self) -> Self {\n-        Iter { ring: self.ring, tail: self.tail, head: self.head }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Iterator for Iter<'a, T> {\n-    type Item = &'a T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a T> {\n-        if self.tail == self.head {\n-            return None;\n-        }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-        unsafe { Some(self.ring.get_unchecked(tail)) }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n-        (len, Some(len))\n-    }\n-\n-    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        accum = front.iter().fold(accum, &mut f);\n-        back.iter().fold(accum, &mut f)\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        let (mut iter, final_res);\n-        if self.tail <= self.head {\n-            // single slice self.ring[self.tail..self.head]\n-            iter = self.ring[self.tail..self.head].iter();\n-            final_res = iter.try_fold(init, &mut f);\n-        } else {\n-            // two slices: self.ring[self.tail..], self.ring[..self.head]\n-            let (front, back) = self.ring.split_at(self.tail);\n-            let mut back_iter = back.iter();\n-            let res = back_iter.try_fold(init, &mut f);\n-            let len = self.ring.len();\n-            self.tail = (self.ring.len() - back_iter.len()) & (len - 1);\n-            iter = front[..self.head].iter();\n-            final_res = iter.try_fold(res?, &mut f);\n-        }\n-        self.tail = self.head - iter.len();\n-        final_res\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        if n >= count(self.tail, self.head, self.ring.len()) {\n-            self.tail = self.head;\n-            None\n-        } else {\n-            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n-            self.next()\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<&'a T> {\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a T> {\n-        if self.tail == self.head {\n-            return None;\n-        }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n-        unsafe { Some(self.ring.get_unchecked(self.head)) }\n-    }\n-\n-    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        accum = back.iter().rfold(accum, &mut f);\n-        front.iter().rfold(accum, &mut f)\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        let (mut iter, final_res);\n-        if self.tail <= self.head {\n-            // single slice self.ring[self.tail..self.head]\n-            iter = self.ring[self.tail..self.head].iter();\n-            final_res = iter.try_rfold(init, &mut f);\n-        } else {\n-            // two slices: self.ring[self.tail..], self.ring[..self.head]\n-            let (front, back) = self.ring.split_at(self.tail);\n-            let mut front_iter = front[..self.head].iter();\n-            let res = front_iter.try_rfold(init, &mut f);\n-            self.head = front_iter.len();\n-            iter = back.iter();\n-            final_res = iter.try_rfold(res?, &mut f);\n-        }\n-        self.head = self.tail + iter.len();\n-        final_res\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for Iter<'_, T> {\n-    fn is_empty(&self) -> bool {\n-        self.head == self.tail\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Iter<'_, T> {}\n-\n-/// A mutable iterator over the elements of a `VecDeque`.\n-///\n-/// This `struct` is created by the [`iter_mut`] method on [`VecDeque`]. See its\n-/// documentation for more.\n-///\n-/// [`iter_mut`]: VecDeque::iter_mut\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, T: 'a> {\n-    // Internal safety invariant: the entire slice is dereferencable.\n-    ring: *mut [T],\n-    tail: usize,\n-    head: usize,\n-    phantom: PhantomData<&'a mut [T]>,\n-}\n-\n-// SAFETY: we do nothing thread-local and there is no interior mutability,\n-// so the usual structural `Send`/`Sync` apply.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for IterMut<'_, T> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferencable.\n-        let (front, back) = unsafe { (&*front, &*back) };\n-        f.debug_tuple(\"IterMut\").field(&front).field(&back).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Iterator for IterMut<'a, T> {\n-    type Item = &'a mut T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n-        }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-\n-        unsafe {\n-            let elem = self.ring.get_unchecked_mut(tail);\n-            Some(&mut *elem)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n-        (len, Some(len))\n-    }\n-\n-    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferencable.\n-        let (front, back) = unsafe { (&mut *front, &mut *back) };\n-        accum = front.iter_mut().fold(accum, &mut f);\n-        back.iter_mut().fold(accum, &mut f)\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        if n >= count(self.tail, self.head, self.ring.len()) {\n-            self.tail = self.head;\n-            None\n-        } else {\n-            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n-            self.next()\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<&'a mut T> {\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n-        }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n-\n-        unsafe {\n-            let elem = self.ring.get_unchecked_mut(self.head);\n-            Some(&mut *elem)\n-        }\n-    }\n-\n-    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferencable.\n-        let (front, back) = unsafe { (&mut *front, &mut *back) };\n-        accum = back.iter_mut().rfold(accum, &mut f);\n-        front.iter_mut().rfold(accum, &mut f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IterMut<'_, T> {\n-    fn is_empty(&self) -> bool {\n-        self.head == self.tail\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for IterMut<'_, T> {}\n-\n-/// An owning iterator over the elements of a `VecDeque`.\n-///\n-/// This `struct` is created by the [`into_iter`] method on [`VecDeque`]\n-/// (provided by the `IntoIterator` trait). See its documentation for more.\n-///\n-/// [`into_iter`]: VecDeque::into_iter\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<T> {\n-    inner: VecDeque<T>,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IntoIter\").field(&self.inner).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Iterator for IntoIter<T> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        self.inner.pop_front()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.inner.len();\n-        (len, Some(len))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        self.inner.pop_back()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {\n-    fn is_empty(&self) -> bool {\n-        self.inner.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for IntoIter<T> {}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for VecDeque<A> {\n     fn eq(&self, other: &VecDeque<A>) -> bool {\n@@ -3039,26 +2616,6 @@ impl<A: PartialEq> PartialEq for VecDeque<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for VecDeque<A> {}\n \n-macro_rules! __impl_slice_eq1 {\n-    ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n-        #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n-        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n-        where\n-            A: PartialEq<B>,\n-            $($constraints)*\n-        {\n-            fn eq(&self, other: &$rhs) -> bool {\n-                if self.len() != other.len() {\n-                    return false;\n-                }\n-                let (sa, sb) = self.as_slices();\n-                let (oa, ob) = other[..].split_at(sa.len());\n-                sa == oa && sb == ob\n-            }\n-        }\n-    }\n-}\n-\n __impl_slice_eq1! { [] VecDeque<A>, Vec<B>, }\n __impl_slice_eq1! { [] VecDeque<A>, &[B], }\n __impl_slice_eq1! { [] VecDeque<A>, &mut [B], }", "previous_filename": "library/alloc/src/collections/vec_deque.rs"}, {"sha": "812765d0b0ded37655344c9eb6321708612fe28f", "filename": "library/alloc/src/collections/vec_deque/pair_slices.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs?ref=dbb37fb1eed3f26b0071006844e7ceab3090062a", "patch": "@@ -0,0 +1,66 @@\n+use core::array;\n+use core::cmp::{self};\n+use core::mem::replace;\n+\n+use super::VecDeque;\n+\n+/// PairSlices pairs up equal length slice parts of two deques\n+///\n+/// For example, given deques \"A\" and \"B\" with the following division into slices:\n+///\n+/// A: [0 1 2] [3 4 5]\n+/// B: [a b] [c d e]\n+///\n+/// It produces the following sequence of matching slices:\n+///\n+/// ([0 1], [a b])\n+/// (\\[2\\], \\[c\\])\n+/// ([3 4], [d e])\n+///\n+/// and the uneven remainder of either A or B is skipped.\n+pub struct PairSlices<'a, 'b, T> {\n+    pub(crate) a0: &'a mut [T],\n+    pub(crate) a1: &'a mut [T],\n+    pub(crate) b0: &'b [T],\n+    pub(crate) b1: &'b [T],\n+}\n+\n+impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n+    pub fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n+        let (a0, a1) = to.as_mut_slices();\n+        let (b0, b1) = from.as_slices();\n+        PairSlices { a0, a1, b0, b1 }\n+    }\n+\n+    pub fn has_remainder(&self) -> bool {\n+        !self.b0.is_empty()\n+    }\n+\n+    pub fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n+        array::IntoIter::new([self.b0, self.b1])\n+    }\n+}\n+\n+impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T> {\n+    type Item = (&'a mut [T], &'b [T]);\n+    fn next(&mut self) -> Option<Self::Item> {\n+        // Get next part length\n+        let part = cmp::min(self.a0.len(), self.b0.len());\n+        if part == 0 {\n+            return None;\n+        }\n+        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n+        let (q0, q1) = self.b0.split_at(part);\n+\n+        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n+        self.a0 = p1;\n+        self.b0 = q1;\n+        if self.a0.is_empty() {\n+            self.a0 = replace(&mut self.a1, &mut []);\n+        }\n+        if self.b0.is_empty() {\n+            self.b0 = replace(&mut self.b1, &[]);\n+        }\n+        Some((p0, q0))\n+    }\n+}"}, {"sha": "dd0fa7d6074c00cbfed25293c649745930f564e9", "filename": "library/alloc/src/collections/vec_deque/ring_slices.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb37fb1eed3f26b0071006844e7ceab3090062a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs?ref=dbb37fb1eed3f26b0071006844e7ceab3090062a", "patch": "@@ -0,0 +1,56 @@\n+use core::ptr::{self};\n+\n+/// Returns the two slices that cover the `VecDeque`'s valid range\n+pub trait RingSlices: Sized {\n+    fn slice(self, from: usize, to: usize) -> Self;\n+    fn split_at(self, i: usize) -> (Self, Self);\n+\n+    fn ring_slices(buf: Self, head: usize, tail: usize) -> (Self, Self) {\n+        let contiguous = tail <= head;\n+        if contiguous {\n+            let (empty, buf) = buf.split_at(0);\n+            (buf.slice(tail, head), empty)\n+        } else {\n+            let (mid, right) = buf.split_at(tail);\n+            let (left, _) = mid.split_at(head);\n+            (right, left)\n+        }\n+    }\n+}\n+\n+impl<T> RingSlices for &[T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        &self[from..to]\n+    }\n+    fn split_at(self, i: usize) -> (Self, Self) {\n+        (*self).split_at(i)\n+    }\n+}\n+\n+impl<T> RingSlices for &mut [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        &mut self[from..to]\n+    }\n+    fn split_at(self, i: usize) -> (Self, Self) {\n+        (*self).split_at_mut(i)\n+    }\n+}\n+\n+impl<T> RingSlices for *mut [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        assert!(from <= to && to < self.len());\n+        // Not using `get_unchecked_mut` to keep this a safe operation.\n+        let len = to - from;\n+        ptr::slice_from_raw_parts_mut(self.as_mut_ptr().wrapping_add(from), len)\n+    }\n+\n+    fn split_at(self, mid: usize) -> (Self, Self) {\n+        let len = self.len();\n+        let ptr = self.as_mut_ptr();\n+        assert!(mid <= len);\n+        (\n+            ptr::slice_from_raw_parts_mut(ptr, mid),\n+            ptr::slice_from_raw_parts_mut(ptr.wrapping_add(mid), len - mid),\n+        )\n+    }\n+}"}, {"sha": "216b31586da3e6438db2063666b11cf25fb20d0d", "filename": "src/test/ui/hygiene/panic-location.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbb37fb1eed3f26b0071006844e7ceab3090062a/src%2Ftest%2Fui%2Fhygiene%2Fpanic-location.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbb37fb1eed3f26b0071006844e7ceab3090062a/src%2Ftest%2Fui%2Fhygiene%2Fpanic-location.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fpanic-location.run.stderr?ref=dbb37fb1eed3f26b0071006844e7ceab3090062a", "patch": "@@ -1,2 +1,2 @@\n-thread 'main' panicked at 'capacity overflow', $SRC_DIR/alloc/src/collections/vec_deque.rs:LL:COL\n+thread 'main' panicked at 'capacity overflow', $SRC_DIR/alloc/src/collections/vec_deque/mod.rs:LL:COL\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}]}