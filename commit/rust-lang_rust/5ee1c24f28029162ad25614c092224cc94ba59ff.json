{"sha": "5ee1c24f28029162ad25614c092224cc94ba59ff", "node_id": "C_kwDOAAsO6NoAKDVlZTFjMjRmMjgwMjkxNjJhZDI1NjE0YzA5MjIyNGNjOTRiYTU5ZmY", "commit": {"author": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-23T17:46:04Z"}, "committer": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-23T17:46:04Z"}, "message": "Lint suggests matches macro if PartialEq trait is not implemented", "tree": {"sha": "9cf0058dd5fcb9148cf9f3c1032e57068d66b721", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cf0058dd5fcb9148cf9f3c1032e57068d66b721"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ee1c24f28029162ad25614c092224cc94ba59ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ee1c24f28029162ad25614c092224cc94ba59ff", "html_url": "https://github.com/rust-lang/rust/commit/5ee1c24f28029162ad25614c092224cc94ba59ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ee1c24f28029162ad25614c092224cc94ba59ff/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6444a69e27275c69e7287fe02ba0c88d554c445", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6444a69e27275c69e7287fe02ba0c88d554c445", "html_url": "https://github.com/rust-lang/rust/commit/a6444a69e27275c69e7287fe02ba0c88d554c445"}], "stats": {"total": 71, "additions": 47, "deletions": 24}, "files": [{"sha": "6f26195d105cede0557fb5a1d7ee587d4ce66e21", "filename": "clippy_lints/src/equatable_if_let.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5ee1c24f28029162ad25614c092224cc94ba59ff/clippy_lints%2Fsrc%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee1c24f28029162ad25614c092224cc94ba59ff/clippy_lints%2Fsrc%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fequatable_if_let.rs?ref=5ee1c24f28029162ad25614c092224cc94ba59ff", "patch": "@@ -68,31 +68,47 @@ impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if !in_external_macro(cx.sess(), expr.span)\n             && let ExprKind::Let(let_expr) = expr.kind\n-            && unary_pattern(let_expr.pat)\n-            && let exp_ty = cx.typeck_results().expr_ty(let_expr.init)\n-            && let pat_ty = cx.typeck_results().pat_ty(let_expr.pat)\n-            && is_structural_partial_eq(cx, exp_ty, pat_ty) {\n+            && unary_pattern(let_expr.pat) {\n+            let exp_ty = cx.typeck_results().expr_ty(let_expr.init);\n+            let pat_ty = cx.typeck_results().pat_ty(let_expr.pat);\n             let mut applicability = Applicability::MachineApplicable;\n-            let pat_str = match let_expr.pat.kind {\n-                PatKind::Struct(..) => format!(\n-                    \"({})\",\n-                    snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n-                ),\n-                _ => snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0.to_string(),\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                EQUATABLE_IF_LET,\n-                expr.span,\n-                \"this pattern matching can be expressed using equality\",\n-                \"try\",\n-                format!(\n-                    \"{} == {}\",\n-                    snippet_with_context(cx, let_expr.init.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n-                    pat_str,\n-                ),\n-                applicability,\n-            );\n+\n+            if is_structural_partial_eq(cx, exp_ty, pat_ty) {\n+                let pat_str = match let_expr.pat.kind {\n+                    PatKind::Struct(..) => format!(\n+                        \"({})\",\n+                        snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                    ),\n+                    _ => snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0.to_string(),\n+                };\n+                span_lint_and_sugg(\n+                    cx,\n+                    EQUATABLE_IF_LET,\n+                    expr.span,\n+                    \"this pattern matching can be expressed using equality\",\n+                    \"try\",\n+                    format!(\n+                        \"{} == {}\",\n+                        snippet_with_context(cx, let_expr.init.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                        pat_str,\n+                    ),\n+                    applicability,\n+                );\n+            } else {\n+                span_lint_and_sugg(\n+                    cx, \n+                    EQUATABLE_IF_LET,\n+                    expr.span,\n+                    \"this pattern matching can be expressed using `matches!`\", \n+                    \"try\", \n+                    format!(\n+                        \"matches!({}, {})\",\n+                        snippet_with_context(cx, let_expr.init.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                        snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                    ), \n+                    applicability,\n+                )\n+            }\n         }\n     }\n }"}, {"sha": "c3626c081dd5e37d9c9ebc5522340473562d9954", "filename": "tests/ui/equatable_if_let.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ee1c24f28029162ad25614c092224cc94ba59ff/tests%2Fui%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee1c24f28029162ad25614c092224cc94ba59ff/tests%2Fui%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fequatable_if_let.rs?ref=5ee1c24f28029162ad25614c092224cc94ba59ff", "patch": "@@ -23,6 +23,11 @@ struct Struct {\n     b: bool,\n }\n \n+struct NoPartialEqStruct {\n+    a: i32,\n+    b: bool,\n+}\n+\n enum NotPartialEq {\n     A,\n     B,\n@@ -47,6 +52,7 @@ fn main() {\n     let e = Enum::UnitVariant;\n     let f = NotPartialEq::A;\n     let g = NotStructuralEq::A;\n+    let h = NoPartialEqStruct { a: 2, b: false };\n \n     // true\n \n@@ -70,6 +76,7 @@ fn main() {\n     if let NotStructuralEq::A = g {}\n     if let Some(NotPartialEq::A) = Some(f) {}\n     if let Some(NotStructuralEq::A) = Some(g) {}\n+    if let NoPartialEqStruct { a: 2, b: false } = h {}\n \n     macro_rules! m1 {\n         (x) => {"}]}