{"sha": "ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYjI5MzE0YTdlNmZjMmQ5ZjM1MjdlMzY1MzRiMmQxNjA4Mzk0ZDg=", "commit": {"author": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2014-05-03T02:32:47Z"}, "committer": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2014-05-05T18:18:53Z"}, "message": "log: Logger receiveis a LogRecord\n\nThe logging macros now create a LogRecord, and pass that to the\nLogger, instead of passing a `level` and `args`. The new signature is:\n\n    trait Logger {\n        fn log(&mut self, record: &LogRecord);\n    }\n\nThe LogRecord includes additional values that may be useful to custom\nloggers, and also allows for further expansion if not values are found\nuseful.\n\nDefaultLogger's formatting was taken from Python's default formatting:\n`LEVEL:from: message`\n\nAlso included: fmt::Arguments now implement Show, so they can be used to\nextend format strings.\n\n[breaking-change]", "tree": {"sha": "9889b1d7c7f928cc51b511f866c4e4e7caf9cda9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9889b1d7c7f928cc51b511f866c4e4e7caf9cda9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "html_url": "https://github.com/rust-lang/rust/commit/ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/comments", "author": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5d6b07370b665df6b54fa20e971e61041a233b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5d6b07370b665df6b54fa20e971e61041a233b0", "html_url": "https://github.com/rust-lang/rust/commit/b5d6b07370b665df6b54fa20e971e61041a233b0"}], "stats": {"total": 108, "additions": 92, "deletions": 16}, "files": [{"sha": "afbcf8c6ded5a7f35aadbb8614fd6d2995a401ed", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::ascii::StrAsciiExt;\n use std::cmp;\n \n #[deriving(Show, Clone)]\n@@ -16,13 +17,13 @@ pub struct LogDirective {\n     pub level: u32,\n }\n \n-static LOG_LEVEL_NAMES: [&'static str, ..4] = [\"error\", \"warn\", \"info\",\n-                                               \"debug\"];\n+pub static LOG_LEVEL_NAMES: [&'static str, ..4] = [\"ERROR\", \"WARN\", \"INFO\",\n+                                               \"DEBUG\"];\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n     from_str::<u32>(level).or_else(|| {\n-        let pos = LOG_LEVEL_NAMES.iter().position(|&name| name == level);\n+        let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n         pos.map(|p| p as u32 + 1)\n     }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n }"}, {"sha": "d0426b1e407330a036ae4a11f53ffa61ed3cb659", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "patch": "@@ -129,6 +129,8 @@ use std::slice;\n \n use sync::one::{Once, ONCE_INIT};\n \n+use directive::LOG_LEVEL_NAMES;\n+\n pub mod macros;\n mod directive;\n \n@@ -162,19 +164,42 @@ local_data_key!(local_logger: ~Logger:Send)\n /// can have its own custom logger which can respond to logging messages\n /// however it likes.\n pub trait Logger {\n-    /// Logs a single message described by the `args` structure. The level is\n-    /// provided in case you want to do things like color the message, etc.\n-    fn log(&mut self, level: u32, args: &fmt::Arguments);\n+    /// Logs a single message described by the `record`.\n+    fn log(&mut self, record: &LogRecord);\n }\n \n struct DefaultLogger {\n     handle: LineBufferedWriter<io::stdio::StdWriter>,\n }\n \n+/// Wraps the log level with fmt implementations.\n+#[deriving(Eq, Ord)]\n+pub struct LogLevel(pub u32);\n+\n+impl fmt::Show for LogLevel {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let LogLevel(level) = *self;\n+        match LOG_LEVEL_NAMES.get(level as uint - 1) {\n+            Some(name) => name.fmt(fmt),\n+            None => level.fmt(fmt)\n+        }\n+    }\n+}\n+\n+impl fmt::Signed for LogLevel {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let LogLevel(level) = *self;\n+        write!(fmt.buf, \"{}\", level)\n+    }\n+}\n+\n impl Logger for DefaultLogger {\n-    // by default, just ignore the level\n-    fn log(&mut self, _level: u32, args: &fmt::Arguments) {\n-        match fmt::writeln(&mut self.handle, args) {\n+    fn log(&mut self, record: &LogRecord) {\n+        match write!(&mut self.handle,\n+                     \"{}:{}: {}\",\n+                     record.level,\n+                     record.module_path,\n+                     record.args) {\n             Err(e) => fail!(\"failed to log: {}\", e),\n             Ok(()) => {}\n         }\n@@ -198,14 +223,21 @@ impl Drop for DefaultLogger {\n ///\n /// It is not recommended to call this function directly, rather it should be\n /// invoked through the logging family of macros.\n-pub fn log(level: u32, args: &fmt::Arguments) {\n+#[doc(hidden)]\n+pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n     let mut logger = local_data::pop(local_logger).unwrap_or_else(|| {\n         ~DefaultLogger { handle: io::stderr() } as ~Logger:Send\n     });\n-    logger.log(level, args);\n+    logger.log(&LogRecord {\n+        level: LogLevel(level),\n+        args: args,\n+        file: loc.file,\n+        module_path: loc.module_path,\n+        line: loc.line,\n+    });\n     local_data::set(local_logger, logger);\n }\n \n@@ -223,6 +255,34 @@ pub fn set_logger(logger: ~Logger:Send) -> Option<~Logger:Send> {\n     return prev;\n }\n \n+/// A LogRecord is created by the logging macros, and passed as the only\n+/// argument to Loggers.\n+#[deriving(Show)]\n+pub struct LogRecord<'a> {\n+\n+    /// The module path of where the LogRecord originated.\n+    pub module_path: &'a str,\n+\n+    /// The LogLevel of this record.\n+    pub level: LogLevel,\n+\n+    /// The arguments from the log line.\n+    pub args: &'a fmt::Arguments<'a>,\n+\n+    /// The file of where the LogRecord originated.\n+    pub file: &'a str,\n+\n+    /// The line number of where the LogRecord originated.\n+    pub line: uint,\n+}\n+\n+#[doc(hidden)]\n+pub struct LogLocation {\n+    pub module_path: &'static str,\n+    pub file: &'static str,\n+    pub line: uint,\n+}\n+\n /// Tests whether a given module's name is enabled for a particular level of\n /// logging. This is the second layer of defense about determining whether a\n /// module's log statement should be emitted or not."}, {"sha": "3bb49c237f14686651e21ca731aa0156bd81fc42", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "patch": "@@ -33,9 +33,14 @@\n #[macro_export]\n macro_rules! log(\n     ($lvl:expr, $($arg:tt)+) => ({\n+        static LOC: ::log::LogLocation = ::log::LogLocation {\n+            line: line!(),\n+            file: file!(),\n+            module_path: module_path!(),\n+        };\n         let lvl = $lvl;\n         if log_enabled!(lvl) {\n-            format_args!(|args| { ::log::log(lvl, args) }, $($arg)+)\n+            format_args!(|args| { ::log::log(lvl, &LOC, args) }, $($arg)+)\n         }\n     })\n )"}, {"sha": "e225dc42e057046333be8eaa73106c593a708e90", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "patch": "@@ -565,6 +565,12 @@ pub struct Arguments<'a> {\n     args: &'a [Argument<'a>],\n }\n \n+impl<'a> Show for Arguments<'a> {\n+    fn fmt(&self, fmt: &mut Formatter) -> Result {\n+        write(fmt.buf, self)\n+    }\n+}\n+\n /// When a format is not otherwise specified, types are formatted by ascribing\n /// to this trait. There is not an explicit way of selecting this trait to be\n /// used for formatting, it is only if no other format is specified."}, {"sha": "3859ed3a53d3ed21f2c570c4e2627683988516b2", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "patch": "@@ -19,14 +19,14 @@ extern crate native;\n \n use std::fmt;\n use std::io::{ChanReader, ChanWriter};\n-use log::{set_logger, Logger};\n+use log::{set_logger, Logger, LogRecord};\n \n struct MyWriter(ChanWriter);\n \n impl Logger for MyWriter {\n-    fn log(&mut self, _level: u32, args: &fmt::Arguments) {\n+    fn log(&mut self, record: &LogRecord) {\n         let MyWriter(ref mut inner) = *self;\n-        fmt::writeln(inner as &mut Writer, args);\n+        fmt::writeln(inner as &mut Writer, record.args);\n     }\n }\n "}, {"sha": "16b21f5f53729313b995393b981dfc1f361fd202", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceb29314a7e6fc2d9f3527e36534b2d1608394d8/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=ceb29314a7e6fc2d9f3527e36534b2d1608394d8", "patch": "@@ -33,7 +33,7 @@ impl fmt::Signed for B {\n     }\n }\n \n-macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n+macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) })\n \n pub fn main() {\n     // Make sure there's a poly formatter that takes anything\n@@ -202,6 +202,10 @@ fn test_format_args() {\n \n     let s = format_args!(fmt::format, \"hello {}\", \"world\");\n     t!(s, \"hello world\");\n+    let s = format_args!(|args| {\n+        format!(\"{}: {}\", \"args were\", args)\n+    }, \"hello {}\", \"world\");\n+    t!(s, \"args were: hello world\");\n }\n \n fn test_order() {"}]}