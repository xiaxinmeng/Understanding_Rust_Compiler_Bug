{"sha": "068c4364c7f793e12d998f5b9b212e723dafa210", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2OGM0MzY0YzdmNzkzZTEyZDk5OGY1YjliMjEyZTcyM2RhZmEyMTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-22T15:10:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-22T15:10:17Z"}, "message": "pass down information about the root tree and use that to guide lint", "tree": {"sha": "2b99c8214a3cc615cd6e1f63fafe27ca7e2b386b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b99c8214a3cc615cd6e1f63fafe27ca7e2b386b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/068c4364c7f793e12d998f5b9b212e723dafa210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/068c4364c7f793e12d998f5b9b212e723dafa210", "html_url": "https://github.com/rust-lang/rust/commit/068c4364c7f793e12d998f5b9b212e723dafa210", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/068c4364c7f793e12d998f5b9b212e723dafa210/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cce913278041031bce87563fa985b0718f8ad939", "url": "https://api.github.com/repos/rust-lang/rust/commits/cce913278041031bce87563fa985b0718f8ad939", "html_url": "https://github.com/rust-lang/rust/commit/cce913278041031bce87563fa985b0718f8ad939"}], "stats": {"total": 96, "additions": 62, "deletions": 34}, "files": [{"sha": "939e620225719f1671cc68a2fdb306b1c3e2b46f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/068c4364c7f793e12d998f5b9b212e723dafa210/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068c4364c7f793e12d998f5b9b212e723dafa210/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=068c4364c7f793e12d998f5b9b212e723dafa210", "patch": "@@ -12,6 +12,7 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(crate_visibility_modifier)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n \n@@ -1655,11 +1656,11 @@ impl<'a> Resolver<'a> {\n             .map(|seg| Ident::new(seg.name, span))\n             .collect();\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n-        match self.resolve_path(&path, Some(namespace), true, span, None) {\n+        match self.resolve_path(&path, Some(namespace), true, span, CrateLint::No) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n-            PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span, None) {\n+            PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span, CrateLint::No) {\n                 PathResult::Failed(span, msg, _) => {\n                     error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n@@ -2378,8 +2379,13 @@ impl<'a> Resolver<'a> {\n             if def != Def::Err {\n                 new_id = Some(def.def_id());\n                 let span = trait_ref.path.span;\n-                if let PathResult::Module(module) = self.resolve_path(&path, None, false, span,\n-                                                                      Some(trait_ref.ref_id)) {\n+                if let PathResult::Module(module) = self.resolve_path(\n+                    &path,\n+                    None,\n+                    false,\n+                    span,\n+                    CrateLint::SimplePath(trait_ref.ref_id),\n+                ) {\n                     new_val = Some((module, trait_ref.clone()));\n                 }\n             }\n@@ -2839,7 +2845,7 @@ impl<'a> Resolver<'a> {\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n                     let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS),\n-                                                             false, span, None) {\n+                                                             false, span, CrateLint::No) {\n                         PathResult::Module(module) => module.def(),\n                         _ => None,\n                     }.map_or(format!(\"\"), |def| format!(\"{} \", def.kind_name()));\n@@ -3169,7 +3175,7 @@ impl<'a> Resolver<'a> {\n             ));\n         }\n \n-        let result = match self.resolve_path(&path, Some(ns), true, span, Some(id)) {\n+        let result = match self.resolve_path(&path, Some(ns), true, span, CrateLint::SimplePath(id)) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(module) if !module.is_normal() => {\n                 PathResolution::new(module.def().unwrap())\n@@ -3206,7 +3212,7 @@ impl<'a> Resolver<'a> {\n            path[0].name != keywords::CrateRoot.name() &&\n            path[0].name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n-                match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span, None) {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span, CrateLint::No) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n                     PathResult::Module(module) => module.def().unwrap(),\n                     _ => return Some(result),\n@@ -3221,14 +3227,14 @@ impl<'a> Resolver<'a> {\n         Some(result)\n     }\n \n-    fn resolve_path(&mut self,\n-                    path: &[Ident],\n-                    opt_ns: Option<Namespace>, // `None` indicates a module path\n-                    record_used: bool,\n-                    path_span: Span,\n-                    node_id: Option<NodeId>) // None indicates that we don't care about linting\n-                                             // `::module` paths\n-                    -> PathResult<'a> {\n+    fn resolve_path(\n+        &mut self,\n+        path: &[Ident],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path\n+        record_used: bool,\n+        path_span: Span,\n+        crate_lint: CrateLint,\n+    ) -> PathResult<'a> {\n         let mut module = None;\n         let mut allow_super = true;\n         let mut second_binding = None;\n@@ -3347,7 +3353,7 @@ impl<'a> Resolver<'a> {\n                         return PathResult::NonModule(err_path_resolution());\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n                         self.lint_if_path_starts_with_module(\n-                            node_id,\n+                            crate_lint,\n                             path,\n                             path_span,\n                             second_binding,\n@@ -3392,19 +3398,22 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        self.lint_if_path_starts_with_module(node_id, path, path_span, second_binding);\n+        self.lint_if_path_starts_with_module(crate_lint, path, path_span, second_binding);\n \n         PathResult::Module(module.unwrap_or(self.graph_root))\n     }\n \n-    fn lint_if_path_starts_with_module(&self,\n-                                       id: Option<NodeId>,\n-                                       path: &[Ident],\n-                                       path_span: Span,\n-                                       second_binding: Option<&NameBinding>) {\n-        let id = match id {\n-            Some(id) => id,\n-            None => return,\n+    fn lint_if_path_starts_with_module(\n+        &self,\n+        crate_lint: CrateLint,\n+        path: &[Ident],\n+        path_span: Span,\n+        second_binding: Option<&NameBinding>,\n+    ) {\n+        let (diag_id, diag_span) = match crate_lint {\n+            CrateLint::No => return,\n+            CrateLint::SimplePath(id) => (id, path_span),\n+            CrateLint::UsePath { root_id, root_span } => (root_id, root_span),\n         };\n \n         let first_name = match path.get(0) {\n@@ -3440,7 +3449,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        self.lint_path_starts_with_module(id, path_span);\n+        self.lint_path_starts_with_module(diag_id, diag_span);\n     }\n \n     fn lint_path_starts_with_module(&self, id: NodeId, span: Span) {\n@@ -3676,7 +3685,7 @@ impl<'a> Resolver<'a> {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS),\n-                                                                  false, span, None) {\n+                                                                  false, span, CrateLint::No) {\n                 add_module_candidates(module, &mut names);\n             }\n         }\n@@ -4475,4 +4484,19 @@ pub enum MakeGlobMap {\n     No,\n }\n \n+enum CrateLint {\n+    /// Do not issue the lint\n+    No,\n+\n+    /// This lint applies to some random path like `impl ::foo::Bar`\n+    /// or whatever. In this case, we can take the span of that path.\n+    SimplePath(NodeId),\n+\n+    /// This lint comes from a `use` statement. In this case, what we\n+    /// care about really is the *root* `use` statement; e.g., if we\n+    /// have nested things like `use a::{b, c}`, we care about the\n+    /// `use a` part.\n+    UsePath { root_id: NodeId, root_span: Span },\n+}\n+\n __build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "c5d04293d038f98a23f36a19571dd322b1d132c8", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/068c4364c7f793e12d998f5b9b212e723dafa210/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068c4364c7f793e12d998f5b9b212e723dafa210/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=068c4364c7f793e12d998f5b9b212e723dafa210", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {AmbiguityError, Resolver, ResolutionError, resolve_error};\n+use {AmbiguityError, CrateLint, Resolver, ResolutionError, resolve_error};\n use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult};\n use Namespace::{self, MacroNS};\n use build_reduced_graph::BuildReducedGraphVisitor;\n@@ -441,7 +441,7 @@ impl<'a> Resolver<'a> {\n                 return Err(Determinacy::Determined);\n             }\n \n-            let def = match self.resolve_path(&path, Some(MacroNS), false, span, None) {\n+            let def = match self.resolve_path(&path, Some(MacroNS), false, span, CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -619,7 +619,7 @@ impl<'a> Resolver<'a> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(&path, Some(MacroNS), true, span, None) {\n+            match self.resolve_path(&path, Some(MacroNS), true, span, CrateLint::No) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));"}, {"sha": "2661cd7bb67764b2b26a3a0315bacffe9df00d6e", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/068c4364c7f793e12d998f5b9b212e723dafa210/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068c4364c7f793e12d998f5b9b212e723dafa210/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=068c4364c7f793e12d998f5b9b212e723dafa210", "patch": "@@ -10,7 +10,7 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use {AmbiguityError, Module, PerNS};\n+use {AmbiguityError, CrateLint, Module, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use Resolver;\n@@ -94,6 +94,10 @@ impl<'a> ImportDirective<'a> {\n     pub fn is_glob(&self) -> bool {\n         match self.subclass { ImportDirectiveSubclass::GlobImport { .. } => true, _ => false }\n     }\n+\n+    crate fn crate_lint(&self) -> CrateLint {\n+        CrateLint::UsePath { root_id: self.root_id, root_span: self.root_span }\n+    }\n }\n \n #[derive(Clone, Default, Debug)]\n@@ -599,7 +603,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n             let result = self.resolve_path(&directive.module_path[..], None, false,\n-                                           directive.span, Some(directive.id));\n+                                           directive.span, directive.crate_lint());\n             directive.vis.set(vis);\n \n             match result {\n@@ -733,7 +737,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n         }\n \n-        let module_result = self.resolve_path(&module_path, None, true, span, Some(directive.id));\n+        let module_result = self.resolve_path(&module_path, None, true, span, directive.crate_lint());\n         let module = match module_result {\n             PathResult::Module(module) => module,\n             PathResult::Failed(span, msg, false) => {\n@@ -748,7 +752,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                    !(self_path.len() > 1 && is_special(self_path[1])) {\n                     self_path[0].name = keywords::SelfValue.name();\n                     self_result = Some(self.resolve_path(&self_path, None, false,\n-                                                         span, None));\n+                                                         span, CrateLint::No));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n                     Some((span, format!(\"Did you mean `{}`?\", names_to_string(&self_path[..]))))"}]}