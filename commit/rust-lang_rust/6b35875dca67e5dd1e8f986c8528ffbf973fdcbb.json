{"sha": "6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMzU4NzVkY2E2N2U1ZGQxZThmOTg2Yzg1MjhmZmJmOTczZmRjYmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T18:03:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-15T00:46:36Z"}, "message": "annotate libstd and start enforcing mutability", "tree": {"sha": "d36cb21cbe8dde663f0f381ad9ce70c9c50fc295", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d36cb21cbe8dde663f0f381ad9ce70c9c50fc295"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "html_url": "https://github.com/rust-lang/rust/commit/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "273c5e5f1129949db780619901fe54b9a3d1fecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/273c5e5f1129949db780619901fe54b9a3d1fecf", "html_url": "https://github.com/rust-lang/rust/commit/273c5e5f1129949db780619901fe54b9a3d1fecf"}], "stats": {"total": 283, "additions": 145, "deletions": 138}, "files": [{"sha": "1d7fcbeaabfa3a6faf6ab982f739d387a3f0dbe0", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -38,7 +38,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB): \\\n         $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_CORELIB) \\\n \t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) --enforce-mut-vars -o $$@ $$< && touch $$@\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_RUSTLLVM): \\\n \t\trustllvm/$(2)/$$(CFG_RUSTLLVM)"}, {"sha": "9fb33d8bd5ae6452ca96ca159141ee2a578b4c5b", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -45,7 +45,7 @@ fn process(v0: t, v1: t, op: fn(uint, uint) -> uint) -> bool {\n     let len = vec::len(v1.storage);\n     assert (vec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n-    let changed = false;\n+    let mut changed = false;\n     uint::range(0u, len) {|i|\n         let w0 = v0.storage[i];\n         let w1 = v1.storage[i];\n@@ -113,7 +113,7 @@ fn equal(v0: t, v1: t) -> bool {\n     //        we can eliminate this painful while-loop\n \n     let len = vec::len(v1.storage);\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < len {\n         if v0.storage[i] != v1.storage[i] { ret false; }\n         i = i + 1u;\n@@ -201,7 +201,7 @@ The resulting string has the same length as the bitvector, and each character\n is either '0' or '1'.\n \"]\n fn to_str(v: t) -> str {\n-    let rs = \"\";\n+    let mut rs = \"\";\n     for i: uint in to_vec(v) { if i == 1u { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n }\n@@ -215,7 +215,7 @@ bitvector and vector must have the same length\n fn eq_vec(v0: t, v1: [uint]) -> bool {\n     assert (v0.nbits == vec::len::<uint>(v1));\n     let len = v0.nbits;\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < len {\n         let w0 = get(v0, i);\n         let w1 = v1[i];"}, {"sha": "dc5b2a66edbe7417ec09bad55830e83bde93e21c", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -26,9 +26,9 @@ fn create<T: copy>() -> t<T> {\n     fn grow<T: copy>(nelts: uint, lo: uint, elts: [mutable cell<T>]) ->\n        [mutable cell<T>] {\n         assert (nelts == vec::len(elts));\n-        let rv = [mutable];\n+        let mut rv = [mutable];\n \n-        let i = 0u;\n+        let mut i = 0u;\n         let nalloc = uint::next_power_of_two(nelts + 1u);\n         while i < nalloc {\n             if i < nelts {"}, {"sha": "364eb16408c6205aa9967ddc03de16d581af72ed", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -77,7 +77,7 @@ fn doc_at(data: @[u8], start: uint) -> tagged_doc {\n }\n \n fn maybe_get_doc(d: doc, tg: uint) -> option<doc> {\n-    let pos = d.start;\n+    let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n@@ -100,7 +100,7 @@ fn get_doc(d: doc, tg: uint) -> doc {\n }\n \n fn docs(d: doc, it: fn(uint, doc)) {\n-    let pos = d.start;\n+    let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n@@ -110,7 +110,7 @@ fn docs(d: doc, it: fn(uint, doc)) {\n }\n \n fn tagged_docs(d: doc, tg: uint, it: fn(doc)) {\n-    let pos = d.start;\n+    let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n@@ -154,20 +154,19 @@ fn doc_as_i64(d: doc) -> i64 { doc_as_u64(d) as i64 }\n type writer = {writer: io::writer, mutable size_positions: [uint]};\n \n fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n-    let buf: [u8];\n-    alt size {\n-      1u { buf = [0x80u8 | (n as u8)]; }\n-      2u { buf = [0x40u8 | ((n >> 8_u) as u8), n as u8]; }\n+    let buf: [u8] = alt size {\n+      1u { [0x80u8 | (n as u8)] }\n+      2u { [0x40u8 | ((n >> 8_u) as u8), n as u8] }\n       3u {\n-        buf = [0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n-               n as u8];\n+        [0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n+               n as u8]\n       }\n       4u {\n-        buf = [0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n-               (n >> 8_u) as u8, n as u8];\n+        [0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+               (n >> 8_u) as u8, n as u8]\n       }\n       _ { fail #fmt(\"vint to write too big: %?\", n); }\n-    }\n+    };\n     w.write(buf);\n }\n "}, {"sha": "75abfd6257b18c717cc6a25b3c0b14f3852fdb6f", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -171,21 +171,21 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n     let n_opts = vec::len::<opt>(opts);\n     fn f(_x: uint) -> [optval] { ret []; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n-    let free: [str] = [];\n+    let mut free: [str] = [];\n     let l = vec::len(args);\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < l {\n         let cur = args[i];\n         let curlen = str::len(cur);\n         if !is_arg(cur) {\n             free += [cur];\n         } else if str::eq(cur, \"--\") {\n-            let j = i + 1u;\n+            let mut j = i + 1u;\n             while j < l { free += [args[j]]; j += 1u; }\n             break;\n         } else {\n-            let names;\n-            let i_arg = option::none::<str>;\n+            let mut names;\n+            let mut i_arg = option::none::<str>;\n             if cur[1] == '-' as u8 {\n                 let tail = str::slice(cur, 2u, curlen);\n                 let tail_eq = str::splitn_char(tail, '=', 1u);\n@@ -198,22 +198,21 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n                         option::some::<str>(tail_eq[1]);\n                 }\n             } else {\n-                let j = 1u;\n+                let mut j = 1u;\n                 names = [];\n                 while j < curlen {\n                     let range = str::char_range_at(cur, j);\n                     names += [short(range.ch)];\n                     j = range.next;\n                 }\n             }\n-            let name_pos = 0u;\n+            let mut name_pos = 0u;\n             for nm: name in names {\n                 name_pos += 1u;\n-                let optid;\n-                alt find_opt(opts, nm) {\n-                  some(id) { optid = id; }\n+                let optid = alt find_opt(opts, nm) {\n+                  some(id) { id }\n                   none { ret err(unrecognized_option(name_str(nm))); }\n-                }\n+                };\n                 alt opts[optid].hasarg {\n                   no {\n                     if !option::is_none::<str>(i_arg) {\n@@ -289,7 +288,7 @@ Returns a vector of the arguments provided to all matches of the given option.\n Used when an option accepts multiple values.\n \"]\n fn opt_strs(m: match, nm: str) -> [str] {\n-    let acc: [str] = [];\n+    let mut acc: [str] = [];\n     for v: optval in opt_vals(m, nm) {\n         alt v { val(s) { acc += [s]; } _ { } }\n     }"}, {"sha": "b5f526da2ed92222701a3293e54c4a3c44ba8216", "filename": "src/libstd/json.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -46,7 +46,7 @@ fn to_writer(wr: io::writer, j: json) {\n       num(n) { wr.write_str(float::to_str(n, 6u)); }\n       string(s) {\n         wr.write_char('\"');\n-        let escaped = \"\";\n+        let mut escaped = \"\";\n         str::chars_iter(s) { |c|\n             alt c {\n               '\"' { escaped += \"\\\\\\\"\"; }\n@@ -67,7 +67,7 @@ fn to_writer(wr: io::writer, j: json) {\n       }\n       list(v) {\n         wr.write_char('[');\n-        let first = true;\n+        let mut first = true;\n         vec::iter(v) { |item|\n             if !first {\n                 wr.write_str(\", \");\n@@ -84,7 +84,7 @@ fn to_writer(wr: io::writer, j: json) {\n         }\n \n         wr.write_str(\"{ \");\n-        let first = true;\n+        let mut first = true;\n         d.items { |key, value|\n             if !first {\n                 wr.write_str(\", \");\n@@ -189,14 +189,14 @@ impl parser for parser {\n     }\n \n     fn parse_number() -> result<json, error> {\n-        let neg = 1f;\n+        let mut neg = 1f;\n \n         if self.ch == '-' {\n             self.bump();\n             neg = -1f;\n         }\n \n-        let res =  alt self.parse_integer() {\n+        let mut res = alt self.parse_integer() {\n           ok(res) { res }\n           err(e) { ret err(e); }\n         };\n@@ -219,7 +219,7 @@ impl parser for parser {\n     }\n \n     fn parse_integer() -> result<float, error> {\n-        let res = 0f;\n+        let mut res = 0f;\n \n         alt self.ch {\n           '0' {\n@@ -259,8 +259,8 @@ impl parser for parser {\n           _ { ret self.error(\"invalid number\"); }\n         }\n \n-        let res = res;\n-        let dec = 1f;\n+        let mut res = res;\n+        let mut dec = 1f;\n         while !self.eof() {\n             alt self.ch {\n               '0' to '9' {\n@@ -279,9 +279,9 @@ impl parser for parser {\n     fn parse_exponent(res: float) -> result<float, error> {\n         self.bump();\n \n-        let res = res;\n-        let exp = 0u;\n-        let neg_exp = false;\n+        let mut res = res;\n+        let mut exp = 0u;\n+        let mut neg_exp = false;\n \n         alt self.ch {\n           '+' { self.bump(); }\n@@ -318,8 +318,8 @@ impl parser for parser {\n     }\n \n     fn parse_str() -> result<str, error> {\n-        let escape = false;\n-        let res = \"\";\n+        let mut escape = false;\n+        let mut res = \"\";\n \n         while !self.eof() {\n             self.bump();\n@@ -336,8 +336,8 @@ impl parser for parser {\n                   't' { str::push_char(res, '\\t'); }\n                   'u' {\n                       // Parse \\u1234.\n-                      let i = 0u;\n-                      let n = 0u;\n+                      let mut i = 0u;\n+                      let mut n = 0u;\n                       while i < 4u {\n                           alt self.next_char() {\n                             '0' to '9' {\n@@ -346,6 +346,7 @@ impl parser for parser {\n                             }\n                             _ { ret self.error(\"invalid \\\\u escape\"); }\n                           }\n+                          i += 1u;\n                       }\n \n                       // Error out if we didn't parse 4 digits.\n@@ -376,7 +377,7 @@ impl parser for parser {\n         self.bump();\n         self.parse_whitespace();\n \n-        let values = [];\n+        let mut values = [];\n \n         if self.ch == ']' {\n             self.bump();\n@@ -479,7 +480,7 @@ fn eq(value0: json, value1: json) -> bool {\n       (list(l0), list(l1)) { vec::all2(l0, l1, eq) }\n       (dict(d0), dict(d1)) {\n           if d0.size() == d1.size() {\n-              let equal = true;\n+              let mut equal = true;\n               d0.items { |k, v0|\n                   alt d1.find(k) {\n                     some(v1) {"}, {"sha": "2636aa2bde173e5381fc65a9722eb10b19646bc7", "filename": "src/libstd/list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -28,7 +28,7 @@ accumulated result.\n * f - The function to apply\n \"]\n fn foldl<T: copy, U>(ls: list<U>, z: T, f: fn(T, U) -> T) -> T {\n-    let accum: T = z;\n+    let mut accum: T = z;\n     iter(ls) {|elt| accum = f(accum, elt);}\n     accum\n }\n@@ -41,7 +41,7 @@ When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n \"]\n fn find<T: copy>(ls: list<T>, f: fn(T) -> bool) -> option<T> {\n-    let ls = ls;\n+    let mut ls = ls;\n     loop {\n         alt ls {\n           cons(hd, tl) {\n@@ -55,7 +55,7 @@ fn find<T: copy>(ls: list<T>, f: fn(T) -> bool) -> option<T> {\n \n #[doc = \"Returns true if a list contains an element with the given value\"]\n fn has<T: copy>(ls: list<T>, elt: T) -> bool {\n-    let ls = ls;\n+    let mut ls = ls;\n     loop {\n         alt ls {\n           cons(hd, tl) { if elt == hd { ret true; } else { ls = *tl; } }\n@@ -79,7 +79,7 @@ pure fn is_not_empty<T: copy>(ls: list<T>) -> bool {\n \n #[doc = \"Returns the length of a list\"]\n fn len<T>(ls: list<T>) -> uint {\n-    let count = 0u;\n+    let mut count = 0u;\n     iter(ls) {|_e| count += 1u;}\n     count\n }\n@@ -110,7 +110,7 @@ fn iter<T>(l: list<T>, f: fn(T)) {\n     alt l {\n       cons(hd, tl) {\n         f(hd);\n-        let cur = tl;\n+        let mut cur = tl;\n         loop {\n             alt *cur {\n               cons(hd, tl) {"}, {"sha": "53eb04fe07005d348f9f055c4f920900be1dfb13", "filename": "src/libstd/map.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -94,8 +94,8 @@ mod chained {\n     fn search_rem<K: copy, V: copy>(\n         tbl: t<K,V>, k: K, h: uint, idx: uint,\n         e_root: @entry<K,V>) -> search_result<K,V> {\n-        let e0 = e_root;\n-        let comp = 1u;   // for logging\n+        let mut e0 = e_root;\n+        let mut comp = 1u;   // for logging\n         loop {\n             alt e0.next {\n               absent {\n@@ -207,7 +207,7 @@ mod chained {\n \n     fn foreach_entry<K: copy, V: copy>(chain0: chain<K,V>,\n                                      blk: fn(@entry<K,V>)) {\n-        let chain = chain0;\n+        let mut chain = chain0;\n         loop {\n             alt chain {\n               absent { ret; }\n@@ -222,7 +222,8 @@ mod chained {\n \n     fn foreach_chain<K: copy, V: copy>(chains: [const chain<K,V>],\n                                      blk: fn(@entry<K,V>)) {\n-        let i = 0u, n = vec::len(chains);\n+        let mut i = 0u;\n+        let n = vec::len(chains);\n         while i < n {\n             foreach_entry(chains[i], blk);\n             i += 1u;"}, {"sha": "8f790c88ae9c7df61f6d1d50b4791b22d14941b9", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -5,44 +5,45 @@ fn md4(msg: [u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     let orig_len: u64 = (vec::len(msg) * 8u) as u64;\n \n     // pad message\n-    let msg = msg + [0x80u8];\n-    let bitlen = orig_len + 8u64;\n+    let mut msg = msg + [0x80u8];\n+    let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n         msg += [0u8];\n         bitlen += 8u64;\n     }\n \n     // append length\n-    let i = 0u64;\n+    let mut i = 0u64;\n     while i < 8u64 {\n         msg += [(orig_len >> (i * 8u64)) as u8];\n         i += 1u64;\n     }\n \n-    let a = 0x67452301u32;\n-    let b = 0xefcdab89u32;\n-    let c = 0x98badcfeu32;\n-    let d = 0x10325476u32;\n+    let mut a = 0x67452301u32;\n+    let mut b = 0xefcdab89u32;\n+    let mut c = 0x98badcfeu32;\n+    let mut d = 0x10325476u32;\n \n     fn rot(r: int, x: u32) -> u32 {\n         let r = r as u32;\n         (x << r) | (x >> (32u32 - r))\n     }\n \n-    let i = 0u, e = vec::len(msg);\n+    let mut i = 0u;\n+    let e = vec::len(msg);\n     let x = vec::to_mut(vec::from_elem(16u, 0u32));\n     while i < e {\n         let aa = a, bb = b, cc = c, dd = d;\n \n-        let j = 0u, base = i;\n+        let mut j = 0u, base = i;\n         while j < 16u {\n             x[j] = (msg[base] as u32) + (msg[base + 1u] as u32 << 8u32) +\n                 (msg[base + 2u] as u32 << 16u32) +\n                 (msg[base + 3u] as u32 << 24u32);\n             j += 1u; base += 4u;\n         }\n \n-        let j = 0u;\n+        let mut j = 0u;\n         while j < 16u {\n             a = rot(3, a + ((b & c) | (!b & d)) + x[j]);\n             j += 1u;\n@@ -54,7 +55,8 @@ fn md4(msg: [u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n             j += 1u;\n         }\n \n-        let j = 0u, q = 0x5a827999u32;\n+        let mut j = 0u;\n+        let q = 0x5a827999u32;\n         while j < 4u {\n             a = rot(3, a + ((b & c) | ((b & d) | (c & d))) + x[j] + q);\n             d = rot(5, d + ((a & b) | ((a & c) | (b & c))) + x[j + 4u] + q);\n@@ -63,7 +65,8 @@ fn md4(msg: [u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n             j += 1u;\n         }\n \n-        let j = 0u, q = 0x6ed9eba1u32;\n+        let mut j = 0u;\n+        let q = 0x6ed9eba1u32;\n         while j < 8u {\n             let jj = if j > 2u { j - 3u } else { j };\n             a = rot(3, a + (b ^ c ^ d) + x[jj] + q);\n@@ -84,9 +87,9 @@ fn md4_str(msg: [u8]) -> str {\n     fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n         f(a); f(b); f(c); f(d);\n     }\n-    let result = \"\";\n+    let mut result = \"\";\n     app(a, b, c, d) {|u|\n-        let i = 0u32;\n+        let mut i = 0u32;\n         while i < 4u32 {\n             let byte = (u >> (i * 8u32)) as u8;\n             if byte <= 16u8 { result += \"0\"; }"}, {"sha": "eadd4b3e0dde36d793bef2c6823c260d93234818", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -155,7 +155,7 @@ measure to ensure that the result is balanced.\n \"]\n fn concat(v: [rope]) -> rope {\n     //Copy `v` into a mutable vector\n-    let len   = vec::len(v);\n+    let mut len = vec::len(v);\n     if len == 0u { ret node::empty; }\n     let ropes = vec::to_mut(vec::from_elem(len, v[0]));\n     uint::range(1u, len) {|i|\n@@ -684,12 +684,12 @@ mod node {\n             ret candidate;\n         } else {\n             //Firstly, split `str` in slices of hint_max_leaf_char_len\n-            let leaves = uint::div_ceil(char_len, hint_max_leaf_char_len);\n+            let mut leaves = uint::div_ceil(char_len, hint_max_leaf_char_len);\n             //Number of leaves\n             let nodes  = vec::to_mut(vec::from_elem(leaves, candidate));\n \n-            let i = 0u;\n-            let offset = byte_start;\n+            let mut i = 0u;\n+            let mut offset = byte_start;\n             let first_leaf_char_len =\n                 if char_len%hint_max_leaf_char_len == 0u {\n                   hint_max_leaf_char_len\n@@ -753,17 +753,17 @@ mod node {\n                execution and should be discarded as meaningless afterwards.\n     \"]\n     fn tree_from_forest_destructive(forest: [mutable @node]) -> @node {\n-        let i = 0u;\n-        let len = vec::len(forest);\n+        let mut i = 0u;\n+        let mut len = vec::len(forest);\n         while len > 1u {\n             i = 0u;\n             while i < len - 1u {//Concat nodes 0 with 1, 2 with 3 etc.\n-                let left  = forest[i];\n-                let right = forest[i+1u];\n+                let mut left  = forest[i];\n+                let mut right = forest[i+1u];\n                 let left_len = char_len(left);\n                 let right_len= char_len(right);\n-                let left_height= height(left);\n-                let right_height=height(right);\n+                let mut left_height= height(left);\n+                let mut right_height=height(right);\n                 if left_len + right_len > hint_max_leaf_char_len {\n                     if left_len <= hint_max_leaf_char_len {\n                         left = flatten(left);\n@@ -797,16 +797,17 @@ mod node {\n     }\n \n     fn serialize_node(node: @node) -> str unsafe {\n-        let buf = vec::to_mut(vec::from_elem(byte_len(node), 0u8));\n-        let offset = 0u;//Current position in the buffer\n+        let mut buf = vec::to_mut(vec::from_elem(byte_len(node), 0u8));\n+        let mut offset = 0u;//Current position in the buffer\n         let it = leaf_iterator::start(node);\n         loop {\n             alt(leaf_iterator::next(it)) {\n               option::none { break; }\n               option::some(x) {\n                 //TODO: Replace with memcpy or something similar\n-                let local_buf: [u8] = unsafe::reinterpret_cast(*x.content);\n-                let i = x.byte_offset;\n+                let mut local_buf: [u8] =\n+                    unsafe::reinterpret_cast(*x.content);\n+                let mut i = x.byte_offset;\n                 while i < x.byte_len {\n                     buf[offset] = local_buf[i];\n                     offset += 1u;\n@@ -860,7 +861,7 @@ mod node {\n     fn bal(node: @node) -> option<@node> {\n         if height(node) < hint_max_node_height { ret option::none; }\n         //1. Gather all leaves as a forest\n-        let forest = [mutable];\n+        let mut forest = [mutable];\n         let it = leaf_iterator::start(node);\n         loop {\n             alt (leaf_iterator::next(it)) {\n@@ -894,8 +895,8 @@ mod node {\n     valid positions in `node`.\n     \"]\n     fn sub_bytes(node: @node, byte_offset: uint, byte_len: uint) -> @node {\n-        let node        = node;\n-        let byte_offset = byte_offset;\n+        let mut node        = node;\n+        let mut byte_offset = byte_offset;\n         loop {\n             if byte_offset == 0u && byte_len == node::byte_len(node) {\n                 ret node;\n@@ -955,8 +956,8 @@ mod node {\n     valid positions in `node`.\n     \"]\n     fn sub_chars(node: @node, char_offset: uint, char_len: uint) -> @node {\n-        let node        = node;\n-        let char_offset = char_offset;\n+        let mut node        = node;\n+        let mut char_offset = char_offset;\n         loop {\n             alt(*node) {\n               node::leaf(x) {\n@@ -1018,8 +1019,8 @@ mod node {\n     fn cmp(a: @node, b: @node) -> int {\n         let ita = char_iterator::start(a);\n         let itb = char_iterator::start(b);\n-        let result = 0;\n-        let pos = 0u;\n+        let mut result = 0;\n+        let mut pos = 0u;\n         while result == 0 {\n             alt((char_iterator::next(ita), char_iterator::next(itb))) {\n               (option::none, option::none) {\n@@ -1063,7 +1064,7 @@ mod node {\n     that is if `it` returned `false` at any point.\n     \"]\n     fn loop_leaves(node: @node, it: fn(leaf) -> bool) -> bool{\n-        let current = node;\n+        let mut current = node;\n         loop {\n             alt(*current) {\n               leaf(x) {\n@@ -1098,8 +1099,8 @@ mod node {\n     length of the largest leaf.\n     \"]\n     fn char_at(node: @node, pos: uint) -> char {\n-        let node    = node;\n-        let pos     = pos;\n+        let mut node    = node;\n+        let mut pos     = pos;\n         loop {\n             alt *node {\n               leaf(x) {"}, {"sha": "d7deb7a3d0691f4e4373a6cf972330cacabd8b5b", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -82,13 +82,13 @@ fn sha1() -> sha1 {\n         // FIXME: Make precondition\n         assert (vec::len(st.h) == digest_buf_len);\n         assert (vec::len(st.work_buf) == work_buf_len);\n-        let t: int; // Loop counter\n+        let mut t: int; // Loop counter\n         let w = st.work_buf;\n \n         // Initialize the first 16 words of the vector w\n         t = 0;\n         while t < 16 {\n-            let tmp;\n+            let mut tmp;\n             tmp = (st.msg_block[t * 4] as u32) << 24u32;\n             tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n             tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n@@ -103,12 +103,12 @@ fn sha1() -> sha1 {\n             w[t] = circular_shift(1u32, val);\n             t += 1;\n         }\n-        let a = st.h[0];\n-        let b = st.h[1];\n-        let c = st.h[2];\n-        let d = st.h[3];\n-        let e = st.h[4];\n-        let temp: u32;\n+        let mut a = st.h[0];\n+        let mut b = st.h[1];\n+        let mut c = st.h[2];\n+        let mut d = st.h[3];\n+        let mut e = st.h[4];\n+        let mut temp: u32;\n         t = 0;\n         while t < 20 {\n             temp = circular_shift(5u32, a) + (b & c | !b & d) + e + w[t] + k0;\n@@ -160,7 +160,7 @@ fn sha1() -> sha1 {\n     }\n     fn mk_result(st: sha1state) -> [u8] {\n         if !st.computed { pad_msg(st); st.computed = true; }\n-        let rs: [u8] = [];\n+        let mut rs: [u8] = [];\n         for hpart: u32 in st.h {\n             let a = (hpart >> 24u32 & 0xFFu32) as u8;\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n@@ -237,7 +237,7 @@ fn sha1() -> sha1 {\n         fn result() -> [u8] { ret mk_result(self); }\n         fn result_str() -> str {\n             let r = mk_result(self);\n-            let s = \"\";\n+            let mut s = \"\";\n             for b: u8 in r { s += uint::to_str(b as uint, 16u); }\n             ret s;\n         }"}, {"sha": "e90fb1abd96b35e47850e413133fda9b70217936", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -66,7 +66,7 @@ fn max_key<T>(m: smallintmap<T>) -> uint {\n #[doc = \"Implements the map::map interface for smallintmap\"]\n impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn size() -> uint {\n-        let sz = 0u;\n+        let mut sz = 0u;\n         for item in self.v {\n             alt item { some(_) { sz += 1u; } _ {} }\n         }\n@@ -90,7 +90,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn find(&&key: uint) -> option<V> { find(self, key) }\n     fn rehash() { fail }\n     fn items(it: fn(&&uint, V)) {\n-        let idx = 0u;\n+        let mut idx = 0u;\n         for item in self.v {\n             alt item {\n               some(elt) {\n@@ -102,7 +102,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n         }\n     }\n     fn keys(it: fn(&&uint)) {\n-        let idx = 0u;\n+        let mut idx = 0u;\n         for item in self.v {\n             if item != none { it(idx); }\n             idx += 1u;"}, {"sha": "ce3982fb433c99dbb9d7f9a2451471b83a68e023", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -33,12 +33,12 @@ fn merge_sort<T: copy>(le: le<T>, v: [const T]) -> [T] {\n     }\n \n     fn merge<T: copy>(le: le<T>, a: [T], b: [T]) -> [T] {\n-        let rs = [];\n+        let mut rs = [];\n         vec::reserve(rs, len(a) + len(b));\n         let a_len = len(a);\n-        let a_ix = 0u;\n+        let mut a_ix = 0u;\n         let b_len = len(b);\n-        let b_ix = 0u;\n+        let mut b_ix = 0u;\n         while a_ix < a_len && b_ix < b_len {\n             if le(a[a_ix], b[b_ix]) {\n                 rs += [a[a_ix]];\n@@ -55,8 +55,8 @@ fn part<T: copy>(compare_func: le<T>, arr: [mutable T], left: uint,\n                 right: uint, pivot: uint) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n-    let storage_index: uint = left;\n-    let i: uint = left;\n+    let mut storage_index: uint = left;\n+    let mut i: uint = left;\n     while i < right {\n         if compare_func(copy arr[i], pivot_value) {\n             arr[i] <-> arr[storage_index];\n@@ -96,10 +96,10 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n                   arr: [mutable T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr[right];\n-    let i: int = left - 1;\n-    let j: int = right;\n-    let p: int = i;\n-    let q: int = j;\n+    let mut i: int = left - 1;\n+    let mut j: int = right;\n+    let mut p: int = i;\n+    let mut q: int = j;\n     loop {\n         i += 1;\n         while compare_func_lt(copy arr[i], v) { i += 1; }\n@@ -122,7 +122,7 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n     arr[i] <-> arr[right];\n     j = i - 1;\n     i += 1;\n-    let k: int = left;\n+    let mut k: int = left;\n     while k < p {\n         arr[k] <-> arr[j];\n         k += 1;"}, {"sha": "91b03ea6b71ae891fe33c137ede5a5bfac62fa0d", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -6,7 +6,7 @@ import rand;\n \n fn mkdtemp(prefix: str, suffix: str) -> option<str> {\n     let r = rand::rng();\n-    let i = 0u;\n+    let mut i = 0u;\n     while (i < 1000u) {\n         let s = prefix + r.gen_str(16u) + suffix;\n         if os::make_dir(s, 0x1c0i32) {  // FIXME: u+rwx"}, {"sha": "c18cc2a625d379daf028a4297190047dd6c7524a", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -49,7 +49,7 @@ fn color_supported() -> bool {\n fn set_color(writer: io::writer, first_char: u8, color: u8) {\n     assert (color < 16u8);\n     esc(writer);\n-    let color = color;\n+    let mut color = color;\n     if color >= 8u8 { writer.write(['1' as u8, ';' as u8]); color -= 8u8; }\n     writer.write([first_char, ('0' as u8) + color, 'm' as u8]);\n }"}, {"sha": "cbfad268adb07916a31baec6304b8a658c362abe", "filename": "src/libstd/test.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -237,7 +237,7 @@ type monitor_msg = (test_desc, test_result);\n fn run_tests(opts: test_opts, tests: [test_desc],\n              callback: fn@(testevent)) {\n \n-    let filtered_tests = filter_tests(opts, tests);\n+    let mut filtered_tests = filter_tests(opts, tests);\n     callback(te_filtered(filtered_tests));\n \n     // It's tempting to just spawn all the tests at once, but since we have\n@@ -246,9 +246,9 @@ fn run_tests(opts: test_opts, tests: [test_desc],\n     #debug(\"using %u test tasks\", concurrency);\n \n     let total = vec::len(filtered_tests);\n-    let run_idx = 0u;\n-    let wait_idx = 0u;\n-    let done_idx = 0u;\n+    let mut run_idx = 0u;\n+    let mut wait_idx = 0u;\n+    let mut done_idx = 0u;\n \n     let p = comm::port();\n     let ch = comm::chan(p);\n@@ -294,7 +294,7 @@ fn get_concurrency() -> uint {\n \n fn filter_tests(opts: test_opts,\n                 tests: [test_desc]) -> [test_desc] {\n-    let filtered = tests;\n+    let mut filtered = tests;\n \n     // Remove tests that don't match the test filter\n     filtered = if option::is_none(opts.filter) {\n@@ -355,9 +355,8 @@ fn run_test(+test: test_desc, monitor_ch: comm::chan<monitor_msg>) {\n     }\n \n     task::spawn {||\n-\n         let testfn = test.fn;\n-        let builder = task::task_builder();\n+        let mut builder = task::task_builder();\n         let result_future = task::future_result(builder);\n         task::unsupervise(builder);\n         task::run(builder, testfn);"}, {"sha": "1e48c307ac17a9d4f088672fff24abb8e67397fc", "filename": "src/libstd/time.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -12,8 +12,8 @@ Returns the current time as a `timeval` containing the seconds and\n microseconds since 1970-01-01T00:00:00Z.\n \"]\n fn get_time() -> timeval {\n-    let sec = 0u32;\n-    let usec = 0u32;\n+    let mut sec = 0u32;\n+    let mut usec = 0u32;\n     rustrt::get_time(sec, usec);\n     ret {sec: sec, usec: usec};\n }\n@@ -22,7 +22,11 @@ fn get_time() -> timeval {\n Returns the current value of a high-resolution performance counter\n in nanoseconds since an unspecified epoch.\n \"]\n-fn precise_time_ns() -> u64 { let ns = 0u64; rustrt::precise_time_ns(ns); ns }\n+fn precise_time_ns() -> u64 {\n+    let mut ns = 0u64;\n+    rustrt::precise_time_ns(ns);\n+    ns\n+}\n \n #[doc = \"\n Returns the current value of a high-resolution performance counter"}, {"sha": "53bdabfc203feae7f64796237cd9694b46031445", "filename": "src/libstd/ufind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fufind.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -47,6 +47,6 @@ fn set_count(ufnd: ufind) -> uint { ret vec::len::<node>(ufnd.nodes); }\n fn prune(ufnd: ufind, n: uint) {\n     // TODO: Use \"slice\" once we get rid of \"const\"\n \n-    let len = vec::len::<node>(ufnd.nodes);\n+    let mut len = vec::len::<node>(ufnd.nodes);\n     while len != n { vec::pop::<node>(ufnd.nodes); len -= 1u; }\n }"}, {"sha": "fd54f7d9291160f130cd9443c385465708285d60", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b35875dca67e5dd1e8f986c8528ffbf973fdcbb/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=6b35875dca67e5dd1e8f986c8528ffbf973fdcbb", "patch": "@@ -146,8 +146,8 @@ fn loop_new() -> uv_loop unsafe {\n         // the main loop that this task blocks on.\n         // should have the same lifetime as the C libuv\n         // event loop.\n-        let keep_going = true;\n-        while (keep_going) {\n+        let mut keep_going = true;\n+        while keep_going {\n             alt comm::recv(rust_loop_port) {\n               msg_run(end_chan) {\n                 // start the libuv event loop\n@@ -339,7 +339,7 @@ fn async_init (\n     lp: uv_loop,\n     async_cb: fn~(uv_handle),\n     after_cb: fn~(uv_handle)) {\n-    let msg = msg_async_init(async_cb, after_cb);\n+    let mut msg = msg_async_init(async_cb, after_cb);\n     let loop_chan = get_loop_chan_from_uv_loop(lp);\n     comm::send(loop_chan, msg);\n }\n@@ -363,7 +363,7 @@ fn close(h: uv_handle, cb: fn~()) {\n }\n \n fn timer_init(lp: uv_loop, after_cb: fn~(uv_handle)) {\n-    let msg = msg_timer_init(after_cb);\n+    let mut msg = msg_timer_init(after_cb);\n     let loop_chan = get_loop_chan_from_uv_loop(lp);\n     comm::send(loop_chan, msg);\n }\n@@ -372,7 +372,7 @@ fn timer_start(the_timer: uv_handle, timeout: u32, repeat:u32,\n                timer_cb: fn~(uv_handle)) {\n     alt the_timer {\n       uv_timer(id, lp) {\n-        let msg = msg_timer_start(id, timeout, repeat, timer_cb);\n+        let mut msg = msg_timer_start(id, timeout, repeat, timer_cb);\n         let loop_chan = get_loop_chan_from_uv_loop(lp);\n         comm::send(loop_chan, msg);\n       }\n@@ -387,7 +387,7 @@ fn timer_stop(the_timer: uv_handle, after_cb: fn~(uv_handle)) {\n     alt the_timer {\n       uv_timer(id, lp) {\n         let loop_chan = get_loop_chan_from_uv_loop(lp);\n-        let msg = msg_timer_stop(id, after_cb);\n+        let mut msg = msg_timer_stop(id, after_cb);\n         comm::send(loop_chan, msg);\n       }\n       _ {\n@@ -466,7 +466,7 @@ crust fn process_operation(\n         data: *uv_loop_data) unsafe {\n     let op_port = (*data).operation_port;\n     let loop_chan = get_loop_chan_from_data(data);\n-    let op_pending = comm::peek(op_port);\n+    let mut op_pending = comm::peek(op_port);\n     while(op_pending) {\n         alt comm::recv(op_port) {\n           op_async_init(id) {"}]}