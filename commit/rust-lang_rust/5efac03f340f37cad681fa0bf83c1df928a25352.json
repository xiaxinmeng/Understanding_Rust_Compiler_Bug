{"sha": "5efac03f340f37cad681fa0bf83c1df928a25352", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZmFjMDNmMzQwZjM3Y2FkNjgxZmEwYmY4M2MxZGY5MjhhMjUzNTI=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-10-05T20:33:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-05T20:33:11Z"}, "message": "Rollup merge of #54717 - ljedrz:cleanup_ty_p1, r=davidtwco\n\nCleanup rustc/ty part 1\n\nPart 2 will follow soon; I wouldn't want these changes to rot too quickly.\n\n- improve stack shifting and remove related allocations\n- move a faster early return up\n- improve allocations\n- use Cow<str> where applicable\n- simplify common patterns\n- whitespace fixes", "tree": {"sha": "eb501c6e4ac40e1991c977d5597c06f0197eb81c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb501c6e4ac40e1991c977d5597c06f0197eb81c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5efac03f340f37cad681fa0bf83c1df928a25352", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbt8qHCRBK7hj4Ov3rIwAAdHIIABd04PrvBqSVSPvdI4NZGhSY\n/BiCBY7Q/5085mktMZIjJlEsKID/NcW7lWgUpE1hvyLPlZA0JBVcCJQrWcOjmXUI\nP6qjUjiBUja1XUIuPkgw3MZyA2Idbp0EonMhTgf8W1FzHmHuxe4WGsSAjT8aMBgX\n7lOxm+bQLsEsL5eDGspQYW4h7xpqHx4uCsgDcvOP+7HeHMFulSMtK82jwdD1ASNS\niKogswT2GDt5+ruLG4aTSsV2Ix8fNjzY6Y6wI7nZULtasALLArafICRFouBHJYf3\nimL4LBIC5rqXKNvVLDOUPQxFVJwh6kgaV1DLjaJDuNaZy445hqPy22RQfcoanQs=\n=6jrp\n-----END PGP SIGNATURE-----\n", "payload": "tree eb501c6e4ac40e1991c977d5597c06f0197eb81c\nparent 6b24de1eddcfda83ce1acc9345b2215712993d27\nparent 7ad21a88e6e5016af53ec3b277c32dac65cc8c66\nauthor Pietro Albini <pietro@pietroalbini.org> 1538771591 +0200\ncommitter GitHub <noreply@github.com> 1538771591 +0200\n\nRollup merge of #54717 - ljedrz:cleanup_ty_p1, r=davidtwco\n\nCleanup rustc/ty part 1\n\nPart 2 will follow soon; I wouldn't want these changes to rot too quickly.\n\n- improve stack shifting and remove related allocations\n- move a faster early return up\n- improve allocations\n- use Cow<str> where applicable\n- simplify common patterns\n- whitespace fixes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5efac03f340f37cad681fa0bf83c1df928a25352", "html_url": "https://github.com/rust-lang/rust/commit/5efac03f340f37cad681fa0bf83c1df928a25352", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5efac03f340f37cad681fa0bf83c1df928a25352/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b24de1eddcfda83ce1acc9345b2215712993d27", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b24de1eddcfda83ce1acc9345b2215712993d27", "html_url": "https://github.com/rust-lang/rust/commit/6b24de1eddcfda83ce1acc9345b2215712993d27"}, {"sha": "7ad21a88e6e5016af53ec3b277c32dac65cc8c66", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ad21a88e6e5016af53ec3b277c32dac65cc8c66", "html_url": "https://github.com/rust-lang/rust/commit/7ad21a88e6e5016af53ec3b277c32dac65cc8c66"}], "stats": {"total": 763, "additions": 375, "deletions": 388}, "files": [{"sha": "8738f574148239e37966edc1ef3ef1a90f2f532e", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -178,19 +178,19 @@ pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n     Ok(ty::GenericPredicates {\n         parent: Decodable::decode(decoder)?,\n         predicates: (0..decoder.read_usize()?).map(|_| {\n-                // Handle shorthands first, if we have an usize > 0x80.\n-                let predicate = if decoder.positioned_at_shorthand() {\n-                    let pos = decoder.read_usize()?;\n-                    assert!(pos >= SHORTHAND_OFFSET);\n-                    let shorthand = pos - SHORTHAND_OFFSET;\n-\n-                    decoder.with_position(shorthand, ty::Predicate::decode)\n-                } else {\n-                    ty::Predicate::decode(decoder)\n-                }?;\n-                Ok((predicate, Decodable::decode(decoder)?))\n-            })\n-            .collect::<Result<Vec<_>, _>>()?,\n+            // Handle shorthands first, if we have an usize > 0x80.\n+            let predicate = if decoder.positioned_at_shorthand() {\n+                let pos = decoder.read_usize()?;\n+                assert!(pos >= SHORTHAND_OFFSET);\n+                let shorthand = pos - SHORTHAND_OFFSET;\n+\n+                decoder.with_position(shorthand, ty::Predicate::decode)\n+            } else {\n+                ty::Predicate::decode(decoder)\n+            }?;\n+            Ok((predicate, Decodable::decode(decoder)?))\n+        })\n+        .collect::<Result<Vec<_>, _>>()?,\n     })\n }\n \n@@ -267,7 +267,7 @@ pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n \n #[inline]\n pub fn decode_allocation<'a, 'tcx, D>(decoder: &mut D)\n-                                 -> Result<&'tcx Allocation, D::Error>\n+    -> Result<&'tcx Allocation, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {"}, {"sha": "46ba5f5ef362dfb30e6f5b5deb2186dbe577d255", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -190,8 +190,8 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             // types/regions in the global interner\n             if local as *const _ as usize == global as *const _ as usize {\n                 bug!(\"Attempted to intern `{:?}` which contains \\\n-                    inference types/regions in the global type context\",\n-                    &ty_struct);\n+                      inference types/regions in the global type context\",\n+                     &ty_struct);\n             }\n \n             // Don't be &mut TyS.\n@@ -272,9 +272,9 @@ fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n \n                     bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n                           TypeckTables with local_id_root {:?}\",\n-                          tcx.hir.node_to_string(node_id),\n-                          DefId::local(hir_id.owner),\n-                          local_id_root)\n+                         tcx.hir.node_to_string(node_id),\n+                         DefId::local(hir_id.owner),\n+                         local_id_root)\n                 });\n             }\n         } else {\n@@ -540,16 +540,13 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_id_to_type(&self, id: hir::HirId) -> Ty<'tcx> {\n-        match self.node_id_to_type_opt(id) {\n-            Some(ty) => ty,\n-            None => {\n-                bug!(\"node_id_to_type: no type for node `{}`\",\n-                    tls::with(|tcx| {\n-                        let id = tcx.hir.hir_to_node_id(id);\n-                        tcx.hir.node_to_string(id)\n-                    }))\n-            }\n-        }\n+        self.node_id_to_type_opt(id).unwrap_or_else(||\n+            bug!(\"node_id_to_type: no type for node `{}`\",\n+                 tls::with(|tcx| {\n+                     let id = tcx.hir.hir_to_node_id(id);\n+                     tcx.hir.node_to_string(id)\n+                 }))\n+        )\n     }\n \n     pub fn node_id_to_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n@@ -686,7 +683,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn pat_adjustments_mut(&mut self)\n-                           -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n+                               -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n             data: &mut self.pat_adjustments,\n@@ -1199,8 +1196,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let hir_id = hir.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner).or_default();\n             Lrc::get_mut(map).unwrap()\n-                            .insert(hir_id.local_id,\n-                                    Lrc::new(StableVec::new(v)));\n+                             .insert(hir_id.local_id,\n+                                     Lrc::new(StableVec::new(v)));\n         }\n \n         let gcx = &GlobalCtxt {\n@@ -2188,7 +2185,6 @@ macro_rules! sty_debug_print {\n                 };\n                 $(let mut $variant = total;)*\n \n-\n                 for &Interned(t) in tcx.interners.type_.borrow().iter() {\n                     let variant = match t.sty {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n@@ -2207,7 +2203,7 @@ macro_rules! sty_debug_print {\n                 }\n                 println!(\"Ty interner             total           ty region  both\");\n                 $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n-{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                            {ty:4.1}% {region:5.1}% {both:4.1}%\",\n                            stringify!($variant),\n                            uses = $variant.total,\n                            usespc = $variant.total as f64 * 100.0 / total.total as f64,\n@@ -2216,7 +2212,7 @@ macro_rules! sty_debug_print {\n                            both = $variant.both_infer as f64 * 100.0  / total.total as f64);\n                   )*\n                 println!(\"                  total {uses:6}        \\\n-{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                          {ty:4.1}% {region:5.1}% {both:4.1}%\",\n                          uses = total.total,\n                          ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n                          region = total.region_infer as f64 * 100.0  / total.total as f64,\n@@ -2653,7 +2649,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n     pub fn mk_closure(self, closure_id: DefId, closure_substs: ClosureSubsts<'tcx>)\n-                                          -> Ty<'tcx> {\n+                      -> Ty<'tcx> {\n         self.mk_ty(Closure(closure_id, closure_substs))\n     }\n \n@@ -2686,8 +2682,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_ty_param(self,\n-                    index: u32,\n-                    name: InternedString) -> Ty<'tcx> {\n+                       index: u32,\n+                       name: InternedString) -> Ty<'tcx> {\n         self.mk_ty(Param(ParamTy { idx: index, name: name }))\n     }\n "}, {"sha": "3123f0fbe31de3c9308c3b1999db83abe7862e52", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n+use std::borrow::Cow;\n use std::fmt;\n use rustc_target::spec::abi;\n use syntax::ast;\n@@ -71,7 +72,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::TypeError::*;\n         fn report_maybe_different(f: &mut fmt::Formatter<'_>,\n-                                  expected: String, found: String) -> fmt::Result {\n+                                  expected: &str, found: &str) -> fmt::Result {\n             // A naive approach to making sure that we're not reporting silly errors such as:\n             // (expected closure, found closure).\n             if expected == found {\n@@ -126,15 +127,15 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        br)\n             }\n             Sorts(values) => ty::tls::with(|tcx| {\n-                report_maybe_different(f, values.expected.sort_string(tcx),\n-                                       values.found.sort_string(tcx))\n+                report_maybe_different(f, &values.expected.sort_string(tcx),\n+                                       &values.found.sort_string(tcx))\n             }),\n             Traits(values) => ty::tls::with(|tcx| {\n                 report_maybe_different(f,\n-                                       format!(\"trait `{}`\",\n-                                               tcx.item_path_str(values.expected)),\n-                                       format!(\"trait `{}`\",\n-                                               tcx.item_path_str(values.found)))\n+                                       &format!(\"trait `{}`\",\n+                                                tcx.item_path_str(values.expected)),\n+                                       &format!(\"trait `{}`\",\n+                                                tcx.item_path_str(values.found)))\n             }),\n             IntMismatch(ref values) => {\n                 write!(f, \"expected `{:?}`, found `{:?}`\",\n@@ -162,8 +163,8 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        values.found)\n             },\n             ExistentialMismatch(ref values) => {\n-                report_maybe_different(f, format!(\"trait `{}`\", values.expected),\n-                                       format!(\"trait `{}`\", values.found))\n+                report_maybe_different(f, &format!(\"trait `{}`\", values.expected),\n+                                       &format!(\"trait `{}`\", values.found))\n             }\n             OldStyleLUB(ref err) => {\n                 write!(f, \"{}\", err)\n@@ -173,22 +174,22 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n }\n \n impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n-    pub fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> String {\n+    pub fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> Cow<'static, str> {\n         match self.sty {\n             ty::Bool | ty::Char | ty::Int(_) |\n-            ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string(),\n-            ty::Tuple(ref tys) if tys.is_empty() => self.to_string(),\n+            ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string().into(),\n+            ty::Tuple(ref tys) if tys.is_empty() => self.to_string().into(),\n \n-            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n-            ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)),\n+            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)).into(),\n+            ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)).into(),\n             ty::Array(_, n) => {\n                 match n.assert_usize(tcx) {\n-                    Some(n) => format!(\"array of {} elements\", n),\n-                    None => \"array\".to_string(),\n+                    Some(n) => format!(\"array of {} elements\", n).into(),\n+                    None => \"array\".into(),\n                 }\n             }\n-            ty::Slice(_) => \"slice\".to_string(),\n-            ty::RawPtr(_) => \"*-ptr\".to_string(),\n+            ty::Slice(_) => \"slice\".into(),\n+            ty::RawPtr(_) => \"*-ptr\".into(),\n             ty::Ref(region, ty, mutbl) => {\n                 let tymut = ty::TypeAndMut { ty, mutbl };\n                 let tymut_string = tymut.to_string();\n@@ -199,39 +200,39 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     format!(\"{}reference\", match mutbl {\n                         hir::Mutability::MutMutable => \"mutable \",\n                         _ => \"\"\n-                    })\n+                    }).into()\n                 } else {\n-                    format!(\"&{}\", tymut_string)\n+                    format!(\"&{}\", tymut_string).into()\n                 }\n             }\n-            ty::FnDef(..) => \"fn item\".to_string(),\n-            ty::FnPtr(_) => \"fn pointer\".to_string(),\n+            ty::FnDef(..) => \"fn item\".into(),\n+            ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n-                inner.principal().map_or_else(|| \"trait\".to_string(),\n-                    |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n+                inner.principal().map_or_else(|| \"trait\".into(),\n+                    |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())).into())\n             }\n-            ty::Closure(..) => \"closure\".to_string(),\n-            ty::Generator(..) => \"generator\".to_string(),\n-            ty::GeneratorWitness(..) => \"generator witness\".to_string(),\n-            ty::Tuple(..) => \"tuple\".to_string(),\n-            ty::Infer(ty::TyVar(_)) => \"inferred type\".to_string(),\n-            ty::Infer(ty::IntVar(_)) => \"integral variable\".to_string(),\n-            ty::Infer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n+            ty::Closure(..) => \"closure\".into(),\n+            ty::Generator(..) => \"generator\".into(),\n+            ty::GeneratorWitness(..) => \"generator witness\".into(),\n+            ty::Tuple(..) => \"tuple\".into(),\n+            ty::Infer(ty::TyVar(_)) => \"inferred type\".into(),\n+            ty::Infer(ty::IntVar(_)) => \"integral variable\".into(),\n+            ty::Infer(ty::FloatVar(_)) => \"floating-point variable\".into(),\n             ty::Infer(ty::CanonicalTy(_)) |\n-            ty::Infer(ty::FreshTy(_)) => \"fresh type\".to_string(),\n-            ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".to_string(),\n-            ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".to_string(),\n-            ty::Projection(_) => \"associated type\".to_string(),\n-            ty::UnnormalizedProjection(_) => \"non-normalized associated type\".to_string(),\n+            ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n+            ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n+            ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n+            ty::Projection(_) => \"associated type\".into(),\n+            ty::UnnormalizedProjection(_) => \"non-normalized associated type\".into(),\n             ty::Param(ref p) => {\n                 if p.is_self() {\n-                    \"Self\".to_string()\n+                    \"Self\".into()\n                 } else {\n-                    \"type parameter\".to_string()\n+                    \"type parameter\".into()\n                 }\n             }\n-            ty::Opaque(..) => \"opaque type\".to_string(),\n-            ty::Error => \"type error\".to_string(),\n+            ty::Opaque(..) => \"opaque type\".into(),\n+            ty::Error => \"type error\".into(),\n         }\n     }\n }\n@@ -251,20 +252,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     db.note(\"no two closures, even if identical, have the same type\");\n                     db.help(\"consider boxing your closure and/or using it as a trait object\");\n                 }\n-                match (&values.found.sty, &values.expected.sty) { // Issue #53280\n-                    (ty::Infer(ty::IntVar(_)), ty::Float(_)) => {\n-                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n-                            if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n-                                db.span_suggestion_with_applicability(\n-                                    sp,\n-                                    \"use a float literal\",\n-                                    format!(\"{}.0\", snippet),\n-                                    Applicability::MachineApplicable\n-                                );\n-                            }\n+                if let (ty::Infer(ty::IntVar(_)), ty::Float(_)) =\n+                       (&values.found.sty, &values.expected.sty) // Issue #53280\n+                {\n+                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n+                        if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n+                            db.span_suggestion_with_applicability(\n+                                sp,\n+                                \"use a float literal\",\n+                                format!(\"{}.0\", snippet),\n+                                Applicability::MachineApplicable\n+                            );\n                         }\n-                    },\n-                    _ => {}\n+                    }\n                 }\n             },\n             OldStyleLUB(err) => {"}, {"sha": "c3d41873009a7b1d294a88e611b96e8f1d127df9", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -62,9 +62,7 @@ impl FlagComputation {\n         let outer_exclusive_binder = computation.outer_exclusive_binder;\n         if outer_exclusive_binder > ty::INNERMOST {\n             self.add_exclusive_binder(outer_exclusive_binder.shifted_out(1));\n-        } else {\n-            // otherwise, this binder captures nothing\n-        }\n+        } // otherwise, this binder captures nothing\n     }\n \n     fn add_sty(&mut self, st: &ty::TyKind<'_>) {"}, {"sha": "7bc77e1b1a14053350f9b25e3bdfde56772840dd", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -66,12 +66,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     id: DefId) -> bool\n     {\n-        for root_id in self.root_ids.iter() {\n-            if tcx.is_descendant_of(id, *root_id) {\n-                return true;\n-            }\n-        }\n-        false\n+        self.root_ids.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n     }\n \n     /// Calculate the intersection of a collection of forests.\n@@ -92,11 +87,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n             }\n             ret.root_ids.extend(old_ret.drain());\n \n-            for id in next_forest.root_ids {\n-                if ret.contains(tcx, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n+            next_ret.extend(next_forest.root_ids.into_iter().filter(|&id| ret.contains(tcx, id)));\n \n             mem::swap(&mut next_ret, &mut ret.root_ids);\n             next_ret.drain();\n@@ -112,11 +103,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n         let mut ret = DefIdForest::empty();\n         let mut next_ret = SmallVec::new();\n         for next_forest in iter {\n-            for id in ret.root_ids.drain() {\n-                if !next_forest.contains(tcx, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n+            next_ret.extend(ret.root_ids.drain().filter(|&id| !next_forest.contains(tcx, id)));\n \n             for id in next_forest.root_ids {\n                 if !next_ret.contains(&id) {"}, {"sha": "79eab3c6f34b9eb79f674d974860cc624714671f", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 219, "deletions": 208, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -23,6 +23,7 @@ use ty::query::Query;\n use ty::query::QueryCache;\n use util::profiling::ProfileCategory;\n \n+use std::borrow::Cow;\n use std::hash::Hash;\n use std::fmt::Debug;\n use syntax_pos::symbol::InternedString;\n@@ -55,7 +56,7 @@ pub(super) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n }\n \n pub(super) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: Self::Key) -> String;\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n     fn cache_on_disk(_: Self::Key) -> bool {\n@@ -70,12 +71,12 @@ pub(super) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n }\n \n impl<'tcx, M: QueryAccessors<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n-    default fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    default fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n-            format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+            format!(\"processing `{}`\", tcx.item_path_str(def_id)).into()\n         } else {\n             let name = unsafe { ::std::intrinsics::type_name::<M>() };\n-            format!(\"processing `{}` applied to `{:?}`\", name, def_id)\n+            format!(\"processing `{}` applied to `{:?}`\", name, def_id).into()\n         }\n     }\n }\n@@ -84,201 +85,210 @@ impl<'tcx> QueryDescription<'tcx> for queries::normalize_projection_ty<'tcx> {\n     fn describe(\n         _tcx: TyCtxt<'_, '_, '_>,\n         goal: CanonicalProjectionGoal<'tcx>,\n-    ) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+    ) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::implied_outlives_bounds<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> String {\n-        format!(\"computing implied outlives bounds for `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"computing implied outlives bounds for `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::dropck_outlives<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> String {\n-        format!(\"computing dropck types for `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"computing dropck types for `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::normalize_ty_after_erasing_regions<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalPredicateGoal<'tcx>) -> String {\n-        format!(\"evaluating trait selection obligation `{}`\", goal.value.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalPredicateGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"evaluating trait selection obligation `{}`\", goal.value.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_eq<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpEqGoal<'tcx>) -> String {\n-        format!(\"evaluating `type_op_eq` `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpEqGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"evaluating `type_op_eq` `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_subtype<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpSubtypeGoal<'tcx>) -> String {\n-        format!(\"evaluating `type_op_subtype` `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpSubtypeGoal<'tcx>)\n+                -> Cow<'static, str> {\n+        format!(\"evaluating `type_op_subtype` `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_prove_predicate<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpProvePredicateGoal<'tcx>) -> String {\n-        format!(\"evaluating `type_op_prove_predicate` `{:?}`\", goal)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpProvePredicateGoal<'tcx>)\n+                -> Cow<'static, str> {\n+        format!(\"evaluating `type_op_prove_predicate` `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_ty<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>,\n-                goal: CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+                goal: CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_predicate<'tcx> {\n     fn describe(\n         _tcx: TyCtxt<'_, '_, '_>,\n         goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+    ) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_poly_fn_sig<'tcx> {\n     fn describe(\n         _tcx: TyCtxt<'_, '_, '_>,\n         goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>,\n-    ) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+    ) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_fn_sig<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>,\n-                goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>) -> String {\n-        format!(\"normalizing `{:?}`\", goal)\n+                goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>) -> Cow<'static, str> {\n+        format!(\"normalizing `{:?}`\", goal).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is `Copy`\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing whether `{}` is `Copy`\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_sized_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is `Sized`\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing whether `{}` is `Sized`\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_freeze_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is freeze\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing whether `{}` is freeze\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::needs_drop_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` needs drop\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing whether `{}` needs drop\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::layout_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing layout of `{}`\", env.value)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                -> Cow<'static, str> {\n+        format!(\"computing layout of `{}`\", env.value).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"computing the supertraits of `{}`\",\n-                tcx.item_path_str(def_id))\n+                tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::erase_regions_ty<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>) -> String {\n-        format!(\"erasing regions from `{:?}`\", ty)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>) -> Cow<'static, str> {\n+        format!(\"erasing regions from `{:?}`\", ty).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> Cow<'static, str> {\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         format!(\"computing the bounds for type parameter `{}`\",\n-                tcx.hir.ty_param_name(id))\n+                tcx.hir.ty_param_name(id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::coherent_trait<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"coherence checking all impls of trait `{}`\",\n-                tcx.item_path_str(def_id))\n+                tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::upstream_monomorphizations<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> String {\n-        format!(\"collecting available upstream monomorphizations `{:?}`\", k)\n+    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> Cow<'static, str> {\n+        format!(\"collecting available upstream monomorphizations `{:?}`\", k).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> String {\n-        format!(\"all inherent impls defined in crate `{:?}`\", k)\n+    fn describe(_: TyCtxt<'_, '_, '_>, k: CrateNum) -> Cow<'static, str> {\n+        format!(\"all inherent impls defined in crate `{:?}`\", k).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls_overlap_check<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"check for overlap between inherent impls defined in this crate\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"check for overlap between inherent impls defined in this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_variances<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"computing the variances for items in this crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"computing the variances for items in this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::inferred_outlives_crate<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"computing the inferred outlives predicates for items in this crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"computing the inferred outlives predicates for items in this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::mir_shims<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n         format!(\"generating MIR shim for `{}`\",\n-                tcx.item_path_str(def.def_id()))\n+                tcx.item_path_str(def.def_id())).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::privacy_access_levels<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"privacy access levels\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"privacy access levels\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::typeck_item_bodies<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"type-checking all item bodies\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"type-checking all item bodies\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::reachable_set<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"reachability\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"reachability\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>) -> String {\n-        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.instance.def.def_id()))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+        -> Cow<'static, str>\n+    {\n+        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.instance.def.def_id())).into()\n     }\n \n     #[inline]\n@@ -295,14 +305,14 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::mir_keys<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"getting a list of all mir_keys\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"getting a list of all mir_keys\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::symbol_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, instance: ty::Instance<'tcx>) -> String {\n-        format!(\"computing the symbol for `{}`\", instance)\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, instance: ty::Instance<'tcx>) -> Cow<'static, str> {\n+        format!(\"computing the symbol for `{}`\", instance).into()\n     }\n \n     #[inline]\n@@ -319,64 +329,64 @@ impl<'tcx> QueryDescription<'tcx> for queries::symbol_name<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::describe_def<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"describe_def\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::def_span<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"def_span\")\n     }\n }\n \n \n impl<'tcx> QueryDescription<'tcx> for queries::lookup_stability<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"stability\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::lookup_deprecation_entry<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"deprecation\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::item_attrs<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"item_attrs\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_reachable_non_generic<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"is_reachable_non_generic\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::fn_arg_names<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"fn_arg_names\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::impl_parent<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"impl_parent\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::trait_of_item<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n         bug!(\"trait_of_item\")\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_static<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"const checking if rvalue is promotable to static `{}`\",\n-            tcx.item_path_str(def_id))\n+            tcx.item_path_str(def_id)).into()\n     }\n \n     #[inline]\n@@ -386,30 +396,31 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_sta\n \n     #[inline]\n     fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          id: SerializedDepNodeIndex)\n-                          -> Option<Self::Value> {\n+                              id: SerializedDepNodeIndex)\n+                              -> Option<Self::Value> {\n         tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::rvalue_promotable_map<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"checking which parts of `{}` are promotable to static\",\n-                tcx.item_path_str(def_id))\n+                tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_mir_available<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n         format!(\"checking if item is mir available: `{}`\",\n-            tcx.item_path_str(def_id))\n+                tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>,\n-                key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> String {\n+                key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Cow<'static, str> {\n         format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n+            .into()\n     }\n \n     #[inline]\n@@ -426,320 +437,320 @@ impl<'tcx> QueryDescription<'tcx> for queries::codegen_fulfill_obligation<'tcx>\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::trait_impls_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n-        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n+        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_object_safe<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n-        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n+        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_const_fn_raw<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> String {\n-        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n+        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::dylib_dependency_formats<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"dylib dependency formats of crate\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"dylib dependency formats of crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_panic_runtime<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"checking if the crate is_panic_runtime\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking if the crate is_panic_runtime\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_compiler_builtins<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"checking if the crate is_compiler_builtins\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking if the crate is_compiler_builtins\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::has_global_allocator<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"checking if the crate has_global_allocator\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking if the crate has_global_allocator\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::has_panic_handler<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"checking if the crate has_panic_handler\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"checking if the crate has_panic_handler\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::extern_crate<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n-        \"getting crate's ExternCrateData\".to_string()\n+    fn describe(_: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n+        \"getting crate's ExternCrateData\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::lint_levels<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"computing the lint levels for items in this crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"computing the lint levels for items in this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::specializes<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (DefId, DefId)) -> String {\n-        \"computing whether impls specialize one another\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (DefId, DefId)) -> Cow<'static, str> {\n+        \"computing whether impls specialize one another\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::in_scope_traits_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> String {\n-        \"traits in scope at a block\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n+        \"traits in scope at a block\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_no_builtins<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"test whether a crate has #![no_builtins]\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"test whether a crate has #![no_builtins]\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::panic_strategy<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"query a crate's configured panic strategy\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"query a crate's configured panic strategy\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_profiler_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"query a crate is #![profiler_runtime]\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"query a crate is #![profiler_runtime]\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_sanitizer_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"query a crate is #![sanitizer_runtime]\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"query a crate is #![sanitizer_runtime]\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::reachable_non_generics<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the exported symbols of a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the exported symbols of a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::native_libraries<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the native libraries of a linked crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the native libraries of a linked crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::foreign_modules<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the foreign modules of a linked crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the foreign modules of a linked crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::plugin_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the plugin registrar for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the plugin registrar for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::derive_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the derive registrar for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the derive registrar for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_disambiguator<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the disambiguator a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the disambiguator a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_hash<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the hash a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the hash a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::original_crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the original name a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the original name a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::extra_filename<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the extra filename for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the extra filename for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::implementations_of_trait<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (CrateNum, DefId)) -> String {\n-        \"looking up implementations of a trait in a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (CrateNum, DefId)) -> Cow<'static, str> {\n+        \"looking up implementations of a trait in a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::all_trait_implementations<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up all (?) trait implementations\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up all (?) trait implementations\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::link_args<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up link arguments for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up link arguments for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::resolve_lifetimes<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"resolving lifetimes\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"resolving lifetimes\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::named_region_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> String {\n-        \"looking up a named region\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n+        \"looking up a named region\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::is_late_bound_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> String {\n-        \"testing if a region is late bound\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n+        \"testing if a region is late bound\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::object_lifetime_defaults_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> String {\n-        \"looking up lifetime defaults for a region\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefIndex) -> Cow<'static, str> {\n+        \"looking up lifetime defaults for a region\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::dep_kind<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"fetching what a dependency looks like\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"fetching what a dependency looks like\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"fetching what a crate is named\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"fetching what a crate is named\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::get_lib_features<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        format!(\"calculating the lib features map\")\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the lib features map\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::defined_lib_features<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        format!(\"calculating the lib features defined in a crate\")\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the lib features defined in a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::get_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the lang items map\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the lang items map\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::defined_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the lang items defined in a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the lang items defined in a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::missing_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the missing lang items in a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the missing lang items in a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::visible_parent_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the visible parent map\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the visible parent map\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::missing_extern_crate_item<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"seeing if we're missing an `extern crate` item for this crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"seeing if we're missing an `extern crate` item for this crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::used_crate_source<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking at the source for a crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking at the source for a crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::postorder_cnums<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"generating a postorder list of CrateNums\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"generating a postorder list of CrateNums\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::maybe_unused_extern_crates<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up all possibly unused extern crates\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up all possibly unused extern crates\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::stability_index<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"calculating the stability index for the local crate\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"calculating the stability index for the local crate\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::all_traits<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"fetching all foreign and local traits\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"fetching all foreign and local traits\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::all_crate_nums<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"fetching all foreign CrateNum instances\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"fetching all foreign CrateNum instances\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::exported_symbols<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"exported_symbols\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"exported_symbols\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::collect_and_partition_mono_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"collect_and_partition_mono_items\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"collect_and_partition_mono_items\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::codegen_unit<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: InternedString) -> String {\n-        \"codegen_unit\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: InternedString) -> Cow<'static, str> {\n+        \"codegen_unit\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::output_filenames<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"output_filenames\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"output_filenames\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::vtable_methods<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::PolyTraitRef<'tcx> ) -> String {\n-        format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id()))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, key: ty::PolyTraitRef<'tcx> ) -> Cow<'static, str> {\n+        format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id())).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::features_query<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up enabled feature gates\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up enabled feature gates\".into()\n     }\n }\n \n@@ -776,20 +787,20 @@ impl<'tcx> QueryDescription<'tcx> for queries::optimized_mir<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, &'tcx Substs<'tcx>)) -> String {\n-        format!(\"testing substituted normalized predicates:`{}`\", tcx.item_path_str(key.0))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, &'tcx Substs<'tcx>)) -> Cow<'static, str> {\n+        format!(\"testing substituted normalized predicates:`{}`\", tcx.item_path_str(key.0)).into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"looking up the whitelist of target features\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"looking up the whitelist of target features\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::instance_def_size_estimate<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> String {\n-        format!(\"estimating size for `{}`\", tcx.item_path_str(def.def_id()))\n+    fn describe(tcx: TyCtxt<'_, '_, '_>, def: ty::InstanceDef<'tcx>) -> Cow<'static, str> {\n+        format!(\"estimating size for `{}`\", tcx.item_path_str(def.def_id())).into()\n     }\n }\n \n@@ -809,26 +820,26 @@ impl<'tcx> QueryDescription<'tcx> for queries::generics_of<'tcx> {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefId) -> String {\n-        \"generating chalk-style clauses\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n+        \"generating chalk-style clauses\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for_env<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: ty::ParamEnv<'tcx>) -> String {\n-        \"generating chalk-style clauses for param env\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: ty::ParamEnv<'tcx>) -> Cow<'static, str> {\n+        \"generating chalk-style clauses for param env\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::wasm_import_module_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"wasm import module map\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"wasm import module map\".into()\n     }\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::dllimport_foreign_items<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> String {\n-        \"wasm import module map\".to_string()\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+        \"wasm import module map\".into()\n     }\n }\n "}, {"sha": "d588bc8c0cb5ca6992b57884fbad14e5ee5e81ec", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -123,9 +123,11 @@ impl<'tcx> QueryJob<'tcx> {\n         let mut cycle = Vec::new();\n \n         while let Some(job) = current_job {\n-            cycle.insert(0, job.info.clone());\n+            cycle.push(job.info.clone());\n \n             if ptr::eq(&*job, self) {\n+                cycle.reverse();\n+\n                 // This is the end of the cycle\n                 // The span entry we included was for the usage\n                 // of the cycle itself, and not part of the cycle\n@@ -324,16 +326,16 @@ fn connected_to_root<'tcx>(\n     query: Lrc<QueryJob<'tcx>>,\n     visited: &mut FxHashSet<*const QueryJob<'tcx>>\n ) -> bool {\n-    // We already visited this or we're deliberately ignoring it\n-    if visited.contains(&query.as_ptr()) {\n-        return false;\n-    }\n-\n     // This query is connected to the root (it has no query parent), return true\n     if query.parent.is_none() {\n         return true;\n     }\n \n+    // We already visited this or we're deliberately ignoring it\n+    if visited.contains(&query.as_ptr()) {\n+        return false;\n+    }\n+\n     visited.insert(query.as_ptr());\n \n     let mut connected = false;\n@@ -368,13 +370,11 @@ fn remove_cycle<'tcx>(\n         // Reverse the stack so earlier entries require later entries\n         stack.reverse();\n \n-        // Extract the spans and queries into separate arrays\n-        let mut spans: Vec<_> = stack.iter().map(|e| e.0).collect();\n-        let queries = stack.into_iter().map(|e| e.1);\n+        // The stack is a vector of pairs of spans and queries\n+        let (mut spans, queries): (Vec<_>, Vec<_>) = stack.into_iter().unzip();\n \n         // Shift the spans so that queries are matched with the span for their waitee\n-        let last = spans.pop().unwrap();\n-        spans.insert(0, last);\n+        spans.rotate_right(1);\n \n         // Zip them back together\n         let mut stack: Vec<_> = spans.into_iter().zip(queries).collect();\n@@ -388,7 +388,7 @@ fn remove_cycle<'tcx>(\n \n         // Find the queries in the cycle which are\n         // connected to queries outside the cycle\n-        let entry_points: Vec<Lrc<QueryJob<'tcx>>> = stack.iter().filter_map(|query| {\n+        let entry_points = stack.iter().filter_map(|query| {\n             // Mark all the other queries in the cycle as already visited\n             let mut visited = FxHashSet::from_iter(stack.iter().filter_map(|q| {\n                 if q.1.as_ptr() != query.1.as_ptr() {\n@@ -403,21 +403,21 @@ fn remove_cycle<'tcx>(\n             } else {\n                 None\n             }\n-        }).collect();\n+        });\n \n         // Deterministically pick an entry point\n         // FIXME: Sort this instead\n         let mut hcx = tcx.create_stable_hashing_context();\n-        let entry_point = entry_points.iter().min_by_key(|q| {\n+        let entry_point = entry_points.min_by_key(|q| {\n             let mut stable_hasher = StableHasher::<u64>::new();\n             q.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n             stable_hasher.finish()\n         }).unwrap().as_ptr();\n \n-        // Shift the stack until our entry point is first\n-        while stack[0].1.as_ptr() != entry_point {\n-            let last = stack.pop().unwrap();\n-            stack.insert(0, last);\n+        // Shift the stack so that our entry point is first\n+        let entry_point_pos = stack.iter().position(|(_, query)| query.as_ptr() == entry_point);\n+        if let Some(pos) = entry_point_pos {\n+            stack.rotate_right(pos);\n         }\n \n         // Create the cycle error"}, {"sha": "7f5bc35f91f9bbc4a60c14af289903767b664748", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -56,6 +56,7 @@ use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::PanicStrategy;\n \n+use std::borrow::Cow;\n use std::ops::Deref;\n use std::sync::Arc;\n use syntax_pos::{Span, DUMMY_SP};"}, {"sha": "ce580c7803355ea8e5de3b3baabd1ad4351572bf", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -254,23 +254,19 @@ impl<'sess> OnDiskCache<'sess> {\n             })?;\n \n             // Encode diagnostics\n-            let diagnostics_index = {\n-                let mut diagnostics_index = EncodedDiagnosticsIndex::new();\n-\n-                for (dep_node_index, diagnostics) in self.current_diagnostics\n-                                                        .borrow()\n-                                                        .iter() {\n-                    let pos = AbsoluteBytePos::new(encoder.position());\n-                    // Let's make sure we get the expected type here:\n-                    let diagnostics: &EncodedDiagnostics = diagnostics;\n-                    let dep_node_index =\n-                        SerializedDepNodeIndex::new(dep_node_index.index());\n-                    encoder.encode_tagged(dep_node_index, diagnostics)?;\n-                    diagnostics_index.push((dep_node_index, pos));\n-                }\n-\n-                diagnostics_index\n-            };\n+            let diagnostics_index: EncodedDiagnosticsIndex = self.current_diagnostics.borrow()\n+                .iter()\n+                .map(|(dep_node_index, diagnostics)|\n+            {\n+                let pos = AbsoluteBytePos::new(encoder.position());\n+                // Let's make sure we get the expected type here:\n+                let diagnostics: &EncodedDiagnostics = diagnostics;\n+                let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n+                encoder.encode_tagged(dep_node_index, diagnostics)?;\n+\n+                Ok((dep_node_index, pos))\n+            })\n+            .collect::<Result<_, _>>()?;\n \n             let interpret_alloc_index = {\n                 let mut interpret_alloc_index = Vec::new();\n@@ -282,6 +278,7 @@ impl<'sess> OnDiskCache<'sess> {\n                         // otherwise, abort\n                         break;\n                     }\n+                    interpret_alloc_index.reserve(new_n);\n                     for idx in n..new_n {\n                         let id = encoder.interpret_allocs_inverse[idx];\n                         let pos = encoder.position() as u32;\n@@ -441,16 +438,15 @@ impl<'sess> OnDiskCache<'sess> {\n         tcx.dep_graph.with_ignore(|| {\n             let current_cnums = tcx.all_crate_nums(LOCAL_CRATE).iter().map(|&cnum| {\n                 let crate_name = tcx.original_crate_name(cnum)\n-                                    .as_str()\n                                     .to_string();\n                 let crate_disambiguator = tcx.crate_disambiguator(cnum);\n                 ((crate_name, crate_disambiguator), cnum)\n             }).collect::<FxHashMap<_,_>>();\n \n             let map_size = prev_cnums.iter()\n-                                    .map(|&(cnum, ..)| cnum)\n-                                    .max()\n-                                    .unwrap_or(0) + 1;\n+                                     .map(|&(cnum, ..)| cnum)\n+                                     .max()\n+                                     .unwrap_or(0) + 1;\n             let mut map = IndexVec::new();\n             map.resize(map_size as usize, None);\n \n@@ -465,7 +461,6 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n }\n \n-\n //- DECODING -------------------------------------------------------------------\n \n /// A decoder that can read the incr. comp. cache. It is similar to the one\n@@ -494,7 +489,7 @@ impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n         file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n             source_map.source_file_by_stable_id(stable_id)\n-                   .expect(\"Failed to lookup SourceFile in new context.\")\n+                .expect(\"Failed to lookup SourceFile in new context.\")\n         }).clone()\n     }\n }\n@@ -761,7 +756,7 @@ for CacheDecoder<'a, 'tcx, 'x> {\n \n struct CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder,\n-          'tcx: 'a,\n+             'tcx: 'a,\n {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     encoder: &'enc mut E,\n@@ -839,9 +834,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx\n         let (file_lo, line_lo, col_lo) = match self.source_map\n                                                    .byte_pos_to_line_and_col(span_data.lo) {\n             Some(pos) => pos,\n-            None => {\n-                return TAG_INVALID_SPAN.encode(self);\n-            }\n+            None => return TAG_INVALID_SPAN.encode(self)\n         };\n \n         if !file_lo.contains(span_data.hi) {"}, {"sha": "39a59cf090ea80b5b99363c616ada5dc16d4a588", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efac03f340f37cad681fa0bf83c1df928a25352/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=5efac03f340f37cad681fa0bf83c1df928a25352", "patch": "@@ -449,14 +449,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let prev_dep_node_index =\n                 self.dep_graph.prev_dep_node_index_of(dep_node);\n             let result = Q::try_load_from_disk(self.global_tcx(),\n-                                                    prev_dep_node_index);\n+                                               prev_dep_node_index);\n \n             // We always expect to find a cached result for things that\n             // can be forced from DepNode.\n             debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n-                            result.is_some(),\n-                            \"Missing on-disk cache entry for {:?}\",\n-                            dep_node);\n+                          result.is_some(),\n+                          \"Missing on-disk cache entry for {:?}\",\n+                          dep_node);\n             result\n         } else {\n             // Some things are never cached on disk.\n@@ -491,7 +491,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n                     self.dep_graph.prev_fingerprint_of(dep_node),\n                     \"Fingerprint for green query instance not loaded \\\n-                        from cache: {:?}\", dep_node);\n+                     from cache: {:?}\", dep_node);\n \n             debug!(\"BEGIN verify_ich({:?})\", dep_node);\n             let mut hcx = self.create_stable_hashing_context();\n@@ -530,8 +530,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //    (see for example #48923)\n         assert!(!self.dep_graph.dep_node_exists(&dep_node),\n                 \"Forcing query with already existing DepNode.\\n\\\n-                    - query-key: {:?}\\n\\\n-                    - dep-node: {:?}\",\n+                 - query-key: {:?}\\n\\\n+                 - dep-node: {:?}\",\n                 key, dep_node);\n \n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n@@ -709,14 +709,19 @@ macro_rules! define_queries_inner {\n \n                 // We use try_lock here since we are only called from the\n                 // deadlock handler, and this shouldn't be locked\n-                $(for v in self.$name.try_lock().unwrap().active.values() {\n-                    match *v {\n-                        QueryResult::Started(ref job) => jobs.push(job.clone()),\n-                        _ => (),\n-                    }\n-                })*\n-\n-                return jobs;\n+                $(\n+                    jobs.extend(\n+                        self.$name.try_lock().unwrap().active.values().filter_map(|v|\n+                            if let QueryResult::Started(ref job) = *v {\n+                                Some(job.clone())\n+                            } else {\n+                                None\n+                            }\n+                        )\n+                    );\n+                )*\n+\n+                jobs\n             }\n         }\n \n@@ -733,14 +738,14 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            pub fn describe(&self, tcx: TyCtxt<'_, '_, '_>) -> String {\n+            pub fn describe(&self, tcx: TyCtxt<'_, '_, '_>) -> Cow<'static, str> {\n                 let (r, name) = match *self {\n                     $(Query::$name(key) => {\n                         (queries::$name::describe(tcx, key), stringify!($name))\n                     })*\n                 };\n                 if tcx.sess.verbose() {\n-                    format!(\"{} [{}]\", r, name)\n+                    format!(\"{} [{}]\", r, name).into()\n                 } else {\n                     r\n                 }\n@@ -753,9 +758,8 @@ macro_rules! define_queries_inner {\n                 }\n                 // The def_span query is used to calculate default_span,\n                 // so exit to avoid infinite recursion\n-                match *self {\n-                    Query::def_span(..) => return span,\n-                    _ => ()\n+                if let Query::def_span(..) = *self {\n+                    return span\n                 }\n                 match *self {\n                     $(Query::$name(key) => key.default_span(tcx),)*\n@@ -1028,13 +1032,10 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n                     )\n                 );\n \n-                match tcx.force_query::<::ty::query::queries::$query<'_>>(\n+                if let Err(e) = tcx.force_query::<::ty::query::queries::$query<'_>>(\n                     $key, DUMMY_SP, *dep_node\n                 ) {\n-                    Ok(_) => {},\n-                    Err(e) => {\n-                        tcx.report_cycle(e).emit();\n-                    }\n+                    tcx.report_cycle(e).emit();\n                 }\n             }\n         }"}]}