{"sha": "faae99deb7c613f580f4aca4087ffeec4159e1de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYWU5OWRlYjdjNjEzZjU4MGY0YWNhNDA4N2ZmZWVjNDE1OWUxZGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-09-30T18:06:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-09-30T21:31:32Z"}, "message": "rustc: More fixes for arch-independent hashing\n\nIn another attempt to fix #36793 this commit attempts to head off any future\nproblems by adding a custom `WidentUsizeHasher` which will widen any hashing of\n`isize` and `usize` to a `u64` as necessary. This obviates the need for a\nprevious number of `as u64` annotations and will hopefully protect us against\nfuture problems here.\n\nCloses #36793 (hopefully)", "tree": {"sha": "7a4a2c829a9b17b3bcacd6ce1a83783c32b79752", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a4a2c829a9b17b3bcacd6ce1a83783c32b79752"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faae99deb7c613f580f4aca4087ffeec4159e1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faae99deb7c613f580f4aca4087ffeec4159e1de", "html_url": "https://github.com/rust-lang/rust/commit/faae99deb7c613f580f4aca4087ffeec4159e1de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faae99deb7c613f580f4aca4087ffeec4159e1de/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d64acdceb6f0eebbc5e8774972b86e4cf192a0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d64acdceb6f0eebbc5e8774972b86e4cf192a0f", "html_url": "https://github.com/rust-lang/rust/commit/1d64acdceb6f0eebbc5e8774972b86e4cf192a0f"}], "stats": {"total": 87, "additions": 76, "deletions": 11}, "files": [{"sha": "c209503e90e7d50c83b88a412b409ed1b5ca3ba8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 73, "deletions": 8, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/faae99deb7c613f580f4aca4087ffeec4159e1de/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faae99deb7c613f580f4aca4087ffeec4159e1de/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=faae99deb7c613f580f4aca4087ffeec4159e1de", "patch": "@@ -12,6 +12,7 @@\n \n use hir::def_id::DefId;\n use infer::InferCtxt;\n+use hir::map as ast_map;\n use hir::pat_util;\n use traits::{self, Reveal};\n use ty::{self, Ty, AdtKind, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n@@ -388,16 +389,77 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+// When hashing a type this ends up affecting properties like symbol names. We\n+// want these symbol names to be calculated independent of other factors like\n+// what architecture you're compiling *from*.\n+//\n+// The hashing just uses the standard `Hash` trait, but the implementations of\n+// `Hash` for the `usize` and `isize` types are *not* architecture independent\n+// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n+// `isize` completely when hashing. To ensure that these don't leak in we use a\n+// custom hasher implementation here which inflates the size of these to a `u64`\n+// and `i64`.\n+struct WidenUsizeHasher<H> {\n+    inner: H,\n+}\n+\n+impl<H> WidenUsizeHasher<H> {\n+    fn new(inner: H) -> WidenUsizeHasher<H> {\n+        WidenUsizeHasher { inner: inner }\n+    }\n+}\n+\n+impl<H: Hasher> Hasher for WidenUsizeHasher<H> {\n+    fn write(&mut self, bytes: &[u8]) {\n+        self.inner.write(bytes)\n+    }\n+\n+    fn finish(&self) -> u64 {\n+        self.inner.finish()\n+    }\n+\n+    fn write_u8(&mut self, i: u8) {\n+        self.inner.write_u8(i)\n+    }\n+    fn write_u16(&mut self, i: u16) {\n+        self.inner.write_u16(i)\n+    }\n+    fn write_u32(&mut self, i: u32) {\n+        self.inner.write_u32(i)\n+    }\n+    fn write_u64(&mut self, i: u64) {\n+        self.inner.write_u64(i)\n+    }\n+    fn write_usize(&mut self, i: usize) {\n+        self.inner.write_u64(i as u64)\n+    }\n+    fn write_i8(&mut self, i: i8) {\n+        self.inner.write_i8(i)\n+    }\n+    fn write_i16(&mut self, i: i16) {\n+        self.inner.write_i16(i)\n+    }\n+    fn write_i32(&mut self, i: i32) {\n+        self.inner.write_i32(i)\n+    }\n+    fn write_i64(&mut self, i: i64) {\n+        self.inner.write_i64(i)\n+    }\n+    fn write_isize(&mut self, i: isize) {\n+        self.inner.write_i64(i as i64)\n+    }\n+}\n+\n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, H> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: H\n+    state: WidenUsizeHasher<H>,\n }\n \n impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, state: H) -> Self {\n         TypeIdHasher {\n             tcx: tcx,\n-            state: state\n+            state: WidenUsizeHasher::new(state),\n         }\n     }\n \n@@ -421,9 +483,12 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     fn def_id(&mut self, did: DefId) {\n         // Hash the DefPath corresponding to the DefId, which is independent\n         // of compiler internal state.\n-        let tcx = self.tcx;\n-        let def_path = tcx.def_path(did);\n-        def_path.deterministic_hash_to(tcx, &mut self.state);\n+        let path = self.tcx.def_path(did);\n+        self.def_path(&path)\n+    }\n+\n+    pub fn def_path(&mut self, def_path: &ast_map::DefPath) {\n+        def_path.deterministic_hash_to(self.tcx, &mut self.state);\n     }\n }\n \n@@ -436,7 +501,7 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n             TyInt(i) => self.hash(i),\n             TyUint(u) => self.hash(u),\n             TyFloat(f) => self.hash(f),\n-            TyArray(_, n) => self.hash(n as u64),\n+            TyArray(_, n) => self.hash(n),\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n@@ -447,14 +512,14 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n                 self.hash(f.unsafety);\n                 self.hash(f.abi);\n                 self.hash(f.sig.variadic());\n-                self.hash(f.sig.inputs().skip_binder().len() as u64);\n+                self.hash(f.sig.inputs().skip_binder().len());\n             }\n             TyTrait(ref data) => {\n                 self.def_id(data.principal.def_id());\n                 self.hash(data.builtin_bounds);\n             }\n             TyTuple(tys) => {\n-                self.hash(tys.len() as u64);\n+                self.hash(tys.len());\n             }\n             TyParam(p) => {\n                 self.hash(p.idx);"}, {"sha": "f0661e03bc8153f0f38a09a4dae47b1de386bbfd", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/faae99deb7c613f580f4aca4087ffeec4159e1de/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faae99deb7c613f580f4aca4087ffeec4159e1de/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=faae99deb7c613f580f4aca4087ffeec4159e1de", "patch": "@@ -152,17 +152,17 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     let mut hash_state = scx.symbol_hasher().borrow_mut();\n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         hash_state.reset();\n-        let mut hasher = Sha256Hasher(&mut hash_state);\n+        let hasher = Sha256Hasher(&mut hash_state);\n+        let mut hasher = ty::util::TypeIdHasher::new(tcx, hasher);\n \n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        def_path.deterministic_hash_to(tcx, &mut hasher);\n+        hasher.def_path(def_path);\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n         // ought to be the same for every reference anyway.\n-        let mut hasher = ty::util::TypeIdHasher::new(tcx, hasher);\n         assert!(!item_type.has_erasable_regions());\n         hasher.visit_ty(item_type);\n "}]}