{"sha": "4e17994b2ca5da45f219ad09cad591fc7d31dd59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMTc5OTRiMmNhNWRhNDVmMjE5YWQwOWNhZDU5MWZjN2QzMWRkNTk=", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-04-28T15:39:23Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-07-30T17:42:15Z"}, "message": "Move UnwindSafe, RefUnwindSafe, AssertUnwindSafe to core", "tree": {"sha": "33ff898f2fde44c54de0b517af80be02e438f15d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33ff898f2fde44c54de0b517af80be02e438f15d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e17994b2ca5da45f219ad09cad591fc7d31dd59", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmEEOfcACgkQ+boUO5X/\nbYKUNw//RR/W74aBIk8+Cb4UTuTBZphj1WkSysIItJ7PYnV18fAYAfNkP22KQh/N\nVnmd2DYwlcJ7lxIPBfdW0DZ4Uh0PTPsRguiWTgyWsUxscCsJ4kgWkzs0nQQGyD1F\nHcNU2SPUwuNDc1lB3NGX9G7WyP8EFTHIFOGquQEBxjDyihEAVR7+gWAuc7MLjzAI\na3JU0vzaodDVOGsj+IGpn7bpPBabW0Q+s4HiGmanWcVHzXxANypAVI+EFx2TDLDC\nfhVllS5iJKWH+tetu1HQuPBUmVxNK2B4QWTiFtW5TFPJD4PdaUZWJr2B2WnV8oEq\nSyDw8O/CA3nR2F12sJLCq0wjNKR+D9IfBnoYVtyfx/0MiMmgs4n64hMNktog4dQV\nCrVlpU1VD1OJOuVYjjy1lI6Ib956X53+Q7qePL2NdEAnW3PkCgQ63Y/E1KNEQfqB\n7a19YtFHCH9skNm5l9pVXkGc8aFmc+W/9DFxCPeVZxqOmtNFw2fKWLbP+e1hzwdK\nARhxXLiWApKc+gfbY6nds6Raq9X24ZVGvaGNRZNkaWrT4MLMNyVqc/J62YOi/pKG\nZVkRoV0CwZbrUamljNLJmcT+wZdfVg3MQSZzoGAxrbny1ZPRkinnMjk0w2q6VgKT\ngHiJnI7/EdngfxwphulAUL2tQy6AhQXQYrGPlEifQN/NS9EOH0k=\n=fYcf\n-----END PGP SIGNATURE-----", "payload": "tree 33ff898f2fde44c54de0b517af80be02e438f15d\nparent 76e73b74a65b25d7c2fc25e006e42e3b4c41027c\nauthor David Tolnay <dtolnay@gmail.com> 1619624363 -0700\ncommitter David Tolnay <dtolnay@gmail.com> 1627666935 -0700\n\nMove UnwindSafe, RefUnwindSafe, AssertUnwindSafe to core\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e17994b2ca5da45f219ad09cad591fc7d31dd59", "html_url": "https://github.com/rust-lang/rust/commit/4e17994b2ca5da45f219ad09cad591fc7d31dd59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e17994b2ca5da45f219ad09cad591fc7d31dd59/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76e73b74a65b25d7c2fc25e006e42e3b4c41027c", "url": "https://api.github.com/repos/rust-lang/rust/commits/76e73b74a65b25d7c2fc25e006e42e3b4c41027c", "html_url": "https://github.com/rust-lang/rust/commit/76e73b74a65b25d7c2fc25e006e42e3b4c41027c"}], "stats": {"total": 628, "additions": 319, "deletions": 309}, "files": [{"sha": "12a5868db74172c98ada99dfa4bf5af2b85fb903", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=4e17994b2ca5da45f219ad09cad591fc7d31dd59", "patch": "@@ -177,6 +177,7 @@ mod boxed {\n pub mod borrow;\n pub mod collections;\n pub mod fmt;\n+mod panic;\n pub mod prelude;\n pub mod raw_vec;\n pub mod rc;"}, {"sha": "666d4fa45aae203c3cbc2146bc0dc9c663938392", "filename": "library/alloc/src/panic.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Falloc%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Falloc%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fpanic.rs?ref=4e17994b2ca5da45f219ad09cad591fc7d31dd59", "patch": "@@ -0,0 +1,11 @@\n+use crate::rc::Rc;\n+use crate::sync::Arc;\n+use core::panic::{RefUnwindSafe, UnwindSafe};\n+\n+// not covered via the Shared impl above b/c the inner contents use\n+// Cell/AtomicUsize, but the usage here is unwind safe so we can lift the\n+// impl up one level to Arc/Rc itself\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Arc<T> {}"}, {"sha": "463bec37265d5035c7cbd34bb46d3cd3bc174070", "filename": "library/core/src/panic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Fcore%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Fcore%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic.rs?ref=4e17994b2ca5da45f219ad09cad591fc7d31dd59", "patch": "@@ -4,13 +4,16 @@\n \n mod location;\n mod panic_info;\n+mod unwind_safe;\n \n use crate::any::Any;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub use self::location::Location;\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub use self::panic_info::PanicInfo;\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+pub use self::unwind_safe::{AssertUnwindSafe, RefUnwindSafe, UnwindSafe};\n \n #[doc(hidden)]\n #[unstable(feature = \"edition_panic\", issue = \"none\", reason = \"use panic!() instead\")]"}, {"sha": "c889dd81846f9ff035f55bbc1e669add89c5128d", "filename": "library/core/src/panic/unwind_safe.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs?ref=4e17994b2ca5da45f219ad09cad591fc7d31dd59", "patch": "@@ -0,0 +1,300 @@\n+use crate::cell::UnsafeCell;\n+use crate::fmt;\n+use crate::future::Future;\n+use crate::ops::{Deref, DerefMut};\n+use crate::pin::Pin;\n+use crate::ptr::{NonNull, Unique};\n+use crate::stream::Stream;\n+use crate::sync::atomic;\n+use crate::task::{Context, Poll};\n+\n+/// A marker trait which represents \"panic safe\" types in Rust.\n+///\n+/// This trait is implemented by default for many types and behaves similarly in\n+/// terms of inference of implementation to the [`Send`] and [`Sync`] traits. The\n+/// purpose of this trait is to encode what types are safe to cross a [`catch_unwind`]\n+/// boundary with no fear of unwind safety.\n+///\n+/// ## What is unwind safety?\n+///\n+/// In Rust a function can \"return\" early if it either panics or calls a\n+/// function which transitively panics. This sort of control flow is not always\n+/// anticipated, and has the possibility of causing subtle bugs through a\n+/// combination of two critical components:\n+///\n+/// 1. A data structure is in a temporarily invalid state when the thread\n+///    panics.\n+/// 2. This broken invariant is then later observed.\n+///\n+/// Typically in Rust, it is difficult to perform step (2) because catching a\n+/// panic involves either spawning a thread (which in turns makes it difficult\n+/// to later witness broken invariants) or using the `catch_unwind` function in this\n+/// module. Additionally, even if an invariant is witnessed, it typically isn't a\n+/// problem in Rust because there are no uninitialized values (like in C or C++).\n+///\n+/// It is possible, however, for **logical** invariants to be broken in Rust,\n+/// which can end up causing behavioral bugs. Another key aspect of unwind safety\n+/// in Rust is that, in the absence of `unsafe` code, a panic cannot lead to\n+/// memory unsafety.\n+///\n+/// That was a bit of a whirlwind tour of unwind safety, but for more information\n+/// about unwind safety and how it applies to Rust, see an [associated RFC][rfc].\n+///\n+/// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n+///\n+/// ## What is `UnwindSafe`?\n+///\n+/// Now that we've got an idea of what unwind safety is in Rust, it's also\n+/// important to understand what this trait represents. As mentioned above, one\n+/// way to witness broken invariants is through the `catch_unwind` function in this\n+/// module as it allows catching a panic and then re-using the environment of\n+/// the closure.\n+///\n+/// Simply put, a type `T` implements `UnwindSafe` if it cannot easily allow\n+/// witnessing a broken invariant through the use of `catch_unwind` (catching a\n+/// panic). This trait is an auto trait, so it is automatically implemented for\n+/// many types, and it is also structurally composed (e.g., a struct is unwind\n+/// safe if all of its components are unwind safe).\n+///\n+/// Note, however, that this is not an unsafe trait, so there is not a succinct\n+/// contract that this trait is providing. Instead it is intended as more of a\n+/// \"speed bump\" to alert users of `catch_unwind` that broken invariants may be\n+/// witnessed and may need to be accounted for.\n+///\n+/// ## Who implements `UnwindSafe`?\n+///\n+/// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n+/// unwind safe. The general idea is that any mutable state which can be shared\n+/// across `catch_unwind` is not unwind safe by default. This is because it is very\n+/// easy to witness a broken invariant outside of `catch_unwind` as the data is\n+/// simply accessed as usual.\n+///\n+/// Types like `&Mutex<T>`, however, are unwind safe because they implement\n+/// poisoning by default. They still allow witnessing a broken invariant, but\n+/// they already provide their own \"speed bumps\" to do so.\n+///\n+/// ## When should `UnwindSafe` be used?\n+///\n+/// It is not intended that most types or functions need to worry about this trait.\n+/// It is only used as a bound on the `catch_unwind` function and as mentioned\n+/// above, the lack of `unsafe` means it is mostly an advisory. The\n+/// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n+/// implemented for any closed over variables passed to `catch_unwind`.\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"unwind_safe_trait\")]\n+#[rustc_on_unimplemented(\n+    message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n+    label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n+)]\n+pub auto trait UnwindSafe {}\n+\n+/// A marker trait representing types where a shared reference is considered\n+/// unwind safe.\n+///\n+/// This trait is namely not implemented by [`UnsafeCell`], the root of all\n+/// interior mutability.\n+///\n+/// This is a \"helper marker trait\" used to provide impl blocks for the\n+/// [`UnwindSafe`] trait, for more information see that documentation.\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"ref_unwind_safe_trait\")]\n+#[rustc_on_unimplemented(\n+    message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n+               transferrable across a catch_unwind boundary\",\n+    label = \"`{Self}` may contain interior mutability and a reference may not be safely \\\n+             transferrable across a catch_unwind boundary\"\n+)]\n+pub auto trait RefUnwindSafe {}\n+\n+/// A simple wrapper around a type to assert that it is unwind safe.\n+///\n+/// When using [`catch_unwind`] it may be the case that some of the closed over\n+/// variables are not unwind safe. For example if `&mut T` is captured the\n+/// compiler will generate a warning indicating that it is not unwind safe. It\n+/// might not be the case, however, that this is actually a problem due to the\n+/// specific usage of [`catch_unwind`] if unwind safety is specifically taken into\n+/// account. This wrapper struct is useful for a quick and lightweight\n+/// annotation that a variable is indeed unwind safe.\n+///\n+/// # Examples\n+///\n+/// One way to use `AssertUnwindSafe` is to assert that the entire closure\n+/// itself is unwind safe, bypassing all checks for all variables:\n+///\n+/// ```\n+/// use std::panic::{self, AssertUnwindSafe};\n+///\n+/// let mut variable = 4;\n+///\n+/// // This code will not compile because the closure captures `&mut variable`\n+/// // which is not considered unwind safe by default.\n+///\n+/// // panic::catch_unwind(|| {\n+/// //     variable += 3;\n+/// // });\n+///\n+/// // This, however, will compile due to the `AssertUnwindSafe` wrapper\n+/// let result = panic::catch_unwind(AssertUnwindSafe(|| {\n+///     variable += 3;\n+/// }));\n+/// // ...\n+/// ```\n+///\n+/// Wrapping the entire closure amounts to a blanket assertion that all captured\n+/// variables are unwind safe. This has the downside that if new captures are\n+/// added in the future, they will also be considered unwind safe. Therefore,\n+/// you may prefer to just wrap individual captures, as shown below. This is\n+/// more annotation, but it ensures that if a new capture is added which is not\n+/// unwind safe, you will get a compilation error at that time, which will\n+/// allow you to consider whether that new capture in fact represent a bug or\n+/// not.\n+///\n+/// ```\n+/// use std::panic::{self, AssertUnwindSafe};\n+///\n+/// let mut variable = 4;\n+/// let other_capture = 3;\n+///\n+/// let result = {\n+///     let mut wrapper = AssertUnwindSafe(&mut variable);\n+///     panic::catch_unwind(move || {\n+///         **wrapper += other_capture;\n+///     })\n+/// };\n+/// // ...\n+/// ```\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+pub struct AssertUnwindSafe<T>(#[stable(feature = \"catch_unwind\", since = \"1.9.0\")] pub T);\n+\n+// Implementations of the `UnwindSafe` trait:\n+//\n+// * By default everything is unwind safe\n+// * pointers T contains mutability of some form are not unwind safe\n+// * Unique, an owning pointer, lifts an implementation\n+// * Types like Mutex/RwLock which are explicitly poisoned are unwind safe\n+// * Our custom AssertUnwindSafe wrapper is indeed unwind safe\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: ?Sized> !UnwindSafe for &mut T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for &T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}\n+#[unstable(feature = \"ptr_internals\", issue = \"none\")]\n+impl<T: UnwindSafe + ?Sized> UnwindSafe for Unique<T> {}\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T: RefUnwindSafe + ?Sized> UnwindSafe for NonNull<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> UnwindSafe for AssertUnwindSafe<T> {}\n+\n+// Pretty simple implementations for the `RefUnwindSafe` marker trait,\n+// basically just saying that `UnsafeCell` is the\n+// only thing which doesn't implement it (which then transitively applies to\n+// everything else).\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T: ?Sized> !RefUnwindSafe for UnsafeCell<T> {}\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> RefUnwindSafe for AssertUnwindSafe<T> {}\n+\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl RefUnwindSafe for atomic::AtomicIsize {}\n+#[cfg(target_has_atomic_load_store = \"8\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for atomic::AtomicI8 {}\n+#[cfg(target_has_atomic_load_store = \"16\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for atomic::AtomicI16 {}\n+#[cfg(target_has_atomic_load_store = \"32\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for atomic::AtomicI32 {}\n+#[cfg(target_has_atomic_load_store = \"64\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for atomic::AtomicI64 {}\n+#[cfg(target_has_atomic_load_store = \"128\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicI128 {}\n+\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl RefUnwindSafe for atomic::AtomicUsize {}\n+#[cfg(target_has_atomic_load_store = \"8\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for atomic::AtomicU8 {}\n+#[cfg(target_has_atomic_load_store = \"16\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for atomic::AtomicU16 {}\n+#[cfg(target_has_atomic_load_store = \"32\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for atomic::AtomicU32 {}\n+#[cfg(target_has_atomic_load_store = \"64\")]\n+#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+impl RefUnwindSafe for atomic::AtomicU64 {}\n+#[cfg(target_has_atomic_load_store = \"128\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicU128 {}\n+\n+#[cfg(target_has_atomic_load_store = \"8\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl RefUnwindSafe for atomic::AtomicBool {}\n+\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> Deref for AssertUnwindSafe<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<T> DerefMut for AssertUnwindSafe<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.0\n+    }\n+}\n+\n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call_once(self, _args: ()) -> R {\n+        (self.0)()\n+    }\n+}\n+\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n+impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"AssertUnwindSafe\").field(&self.0).finish()\n+    }\n+}\n+\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+impl<F: Future> Future for AssertUnwindSafe<F> {\n+    type Output = F::Output;\n+\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n+        F::poll(pinned_field, cx)\n+    }\n+}\n+\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<S: Stream> Stream for AssertUnwindSafe<S> {\n+    type Item = S::Item;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<S::Item>> {\n+        unsafe { self.map_unchecked_mut(|x| &mut x.0) }.poll_next(cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}"}, {"sha": "c1c039584979d3817f876da3929daf69d1fb0433", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 4, "deletions": 309, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e17994b2ca5da45f219ad09cad591fc7d31dd59/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=4e17994b2ca5da45f219ad09cad591fc7d31dd59", "patch": "@@ -3,19 +3,9 @@\n #![stable(feature = \"std_panic\", since = \"1.9.0\")]\n \n use crate::any::Any;\n-use crate::cell::UnsafeCell;\n use crate::collections;\n-use crate::fmt;\n-use crate::future::Future;\n-use crate::ops::{Deref, DerefMut};\n use crate::panicking;\n-use crate::pin::Pin;\n-use crate::ptr::{NonNull, Unique};\n-use crate::rc::Rc;\n-use crate::stream::Stream;\n-use crate::sync::atomic;\n-use crate::sync::{Arc, Mutex, RwLock};\n-use crate::task::{Context, Poll};\n+use crate::sync::{Mutex, RwLock};\n use crate::thread::Result;\n \n #[doc(hidden)]\n@@ -45,6 +35,9 @@ pub use crate::panicking::{set_hook, take_hook};\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub use core::panic::{Location, PanicInfo};\n \n+#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n+pub use core::panic::{AssertUnwindSafe, RefUnwindSafe, UnwindSafe};\n+\n /// Panic the current thread with the given message as the panic payload.\n ///\n /// The message can be of any (`Any + Send`) type, not just strings.\n@@ -60,259 +53,16 @@ pub fn panic_any<M: 'static + Any + Send>(msg: M) -> ! {\n     crate::panicking::begin_panic(msg);\n }\n \n-/// A marker trait which represents \"panic safe\" types in Rust.\n-///\n-/// This trait is implemented by default for many types and behaves similarly in\n-/// terms of inference of implementation to the [`Send`] and [`Sync`] traits. The\n-/// purpose of this trait is to encode what types are safe to cross a [`catch_unwind`]\n-/// boundary with no fear of unwind safety.\n-///\n-/// ## What is unwind safety?\n-///\n-/// In Rust a function can \"return\" early if it either panics or calls a\n-/// function which transitively panics. This sort of control flow is not always\n-/// anticipated, and has the possibility of causing subtle bugs through a\n-/// combination of two critical components:\n-///\n-/// 1. A data structure is in a temporarily invalid state when the thread\n-///    panics.\n-/// 2. This broken invariant is then later observed.\n-///\n-/// Typically in Rust, it is difficult to perform step (2) because catching a\n-/// panic involves either spawning a thread (which in turns makes it difficult\n-/// to later witness broken invariants) or using the `catch_unwind` function in this\n-/// module. Additionally, even if an invariant is witnessed, it typically isn't a\n-/// problem in Rust because there are no uninitialized values (like in C or C++).\n-///\n-/// It is possible, however, for **logical** invariants to be broken in Rust,\n-/// which can end up causing behavioral bugs. Another key aspect of unwind safety\n-/// in Rust is that, in the absence of `unsafe` code, a panic cannot lead to\n-/// memory unsafety.\n-///\n-/// That was a bit of a whirlwind tour of unwind safety, but for more information\n-/// about unwind safety and how it applies to Rust, see an [associated RFC][rfc].\n-///\n-/// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n-///\n-/// ## What is `UnwindSafe`?\n-///\n-/// Now that we've got an idea of what unwind safety is in Rust, it's also\n-/// important to understand what this trait represents. As mentioned above, one\n-/// way to witness broken invariants is through the `catch_unwind` function in this\n-/// module as it allows catching a panic and then re-using the environment of\n-/// the closure.\n-///\n-/// Simply put, a type `T` implements `UnwindSafe` if it cannot easily allow\n-/// witnessing a broken invariant through the use of `catch_unwind` (catching a\n-/// panic). This trait is an auto trait, so it is automatically implemented for\n-/// many types, and it is also structurally composed (e.g., a struct is unwind\n-/// safe if all of its components are unwind safe).\n-///\n-/// Note, however, that this is not an unsafe trait, so there is not a succinct\n-/// contract that this trait is providing. Instead it is intended as more of a\n-/// \"speed bump\" to alert users of `catch_unwind` that broken invariants may be\n-/// witnessed and may need to be accounted for.\n-///\n-/// ## Who implements `UnwindSafe`?\n-///\n-/// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n-/// unwind safe. The general idea is that any mutable state which can be shared\n-/// across `catch_unwind` is not unwind safe by default. This is because it is very\n-/// easy to witness a broken invariant outside of `catch_unwind` as the data is\n-/// simply accessed as usual.\n-///\n-/// Types like `&Mutex<T>`, however, are unwind safe because they implement\n-/// poisoning by default. They still allow witnessing a broken invariant, but\n-/// they already provide their own \"speed bumps\" to do so.\n-///\n-/// ## When should `UnwindSafe` be used?\n-///\n-/// It is not intended that most types or functions need to worry about this trait.\n-/// It is only used as a bound on the `catch_unwind` function and as mentioned\n-/// above, the lack of `unsafe` means it is mostly an advisory. The\n-/// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n-/// implemented for any closed over variables passed to `catch_unwind`.\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"unwind_safe_trait\")]\n-#[rustc_on_unimplemented(\n-    message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n-    label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n-)]\n-pub auto trait UnwindSafe {}\n-\n-/// A marker trait representing types where a shared reference is considered\n-/// unwind safe.\n-///\n-/// This trait is namely not implemented by [`UnsafeCell`], the root of all\n-/// interior mutability.\n-///\n-/// This is a \"helper marker trait\" used to provide impl blocks for the\n-/// [`UnwindSafe`] trait, for more information see that documentation.\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"ref_unwind_safe_trait\")]\n-#[rustc_on_unimplemented(\n-    message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n-               transferrable across a catch_unwind boundary\",\n-    label = \"`{Self}` may contain interior mutability and a reference may not be safely \\\n-             transferrable across a catch_unwind boundary\"\n-)]\n-pub auto trait RefUnwindSafe {}\n-\n-/// A simple wrapper around a type to assert that it is unwind safe.\n-///\n-/// When using [`catch_unwind`] it may be the case that some of the closed over\n-/// variables are not unwind safe. For example if `&mut T` is captured the\n-/// compiler will generate a warning indicating that it is not unwind safe. It\n-/// might not be the case, however, that this is actually a problem due to the\n-/// specific usage of [`catch_unwind`] if unwind safety is specifically taken into\n-/// account. This wrapper struct is useful for a quick and lightweight\n-/// annotation that a variable is indeed unwind safe.\n-///\n-/// # Examples\n-///\n-/// One way to use `AssertUnwindSafe` is to assert that the entire closure\n-/// itself is unwind safe, bypassing all checks for all variables:\n-///\n-/// ```\n-/// use std::panic::{self, AssertUnwindSafe};\n-///\n-/// let mut variable = 4;\n-///\n-/// // This code will not compile because the closure captures `&mut variable`\n-/// // which is not considered unwind safe by default.\n-///\n-/// // panic::catch_unwind(|| {\n-/// //     variable += 3;\n-/// // });\n-///\n-/// // This, however, will compile due to the `AssertUnwindSafe` wrapper\n-/// let result = panic::catch_unwind(AssertUnwindSafe(|| {\n-///     variable += 3;\n-/// }));\n-/// // ...\n-/// ```\n-///\n-/// Wrapping the entire closure amounts to a blanket assertion that all captured\n-/// variables are unwind safe. This has the downside that if new captures are\n-/// added in the future, they will also be considered unwind safe. Therefore,\n-/// you may prefer to just wrap individual captures, as shown below. This is\n-/// more annotation, but it ensures that if a new capture is added which is not\n-/// unwind safe, you will get a compilation error at that time, which will\n-/// allow you to consider whether that new capture in fact represent a bug or\n-/// not.\n-///\n-/// ```\n-/// use std::panic::{self, AssertUnwindSafe};\n-///\n-/// let mut variable = 4;\n-/// let other_capture = 3;\n-///\n-/// let result = {\n-///     let mut wrapper = AssertUnwindSafe(&mut variable);\n-///     panic::catch_unwind(move || {\n-///         **wrapper += other_capture;\n-///     })\n-/// };\n-/// // ...\n-/// ```\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-pub struct AssertUnwindSafe<T>(#[stable(feature = \"catch_unwind\", since = \"1.9.0\")] pub T);\n-\n-// Implementations of the `UnwindSafe` trait:\n-//\n-// * By default everything is unwind safe\n-// * pointers T contains mutability of some form are not unwind safe\n-// * Unique, an owning pointer, lifts an implementation\n-// * Types like Mutex/RwLock which are explicitly poisoned are unwind safe\n-// * Our custom AssertUnwindSafe wrapper is indeed unwind safe\n-\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: ?Sized> !UnwindSafe for &mut T {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for &T {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}\n-#[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-impl<T: UnwindSafe + ?Sized> UnwindSafe for Unique<T> {}\n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for NonNull<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: ?Sized> UnwindSafe for Mutex<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: ?Sized> UnwindSafe for RwLock<T> {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T> UnwindSafe for AssertUnwindSafe<T> {}\n-\n-// not covered via the Shared impl above b/c the inner contents use\n-// Cell/AtomicUsize, but the usage here is unwind safe so we can lift the\n-// impl up one level to Arc/Rc itself\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Arc<T> {}\n-\n-// Pretty simple implementations for the `RefUnwindSafe` marker trait,\n-// basically just saying that `UnsafeCell` is the\n-// only thing which doesn't implement it (which then transitively applies to\n-// everything else).\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T: ?Sized> !RefUnwindSafe for UnsafeCell<T> {}\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T> RefUnwindSafe for AssertUnwindSafe<T> {}\n \n #[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n impl<T: ?Sized> RefUnwindSafe for Mutex<T> {}\n #[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n impl<T: ?Sized> RefUnwindSafe for RwLock<T> {}\n \n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-impl RefUnwindSafe for atomic::AtomicIsize {}\n-#[cfg(target_has_atomic_load_store = \"8\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicI8 {}\n-#[cfg(target_has_atomic_load_store = \"16\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicI16 {}\n-#[cfg(target_has_atomic_load_store = \"32\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicI32 {}\n-#[cfg(target_has_atomic_load_store = \"64\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicI64 {}\n-#[cfg(target_has_atomic_load_store = \"128\")]\n-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n-impl RefUnwindSafe for atomic::AtomicI128 {}\n-\n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-impl RefUnwindSafe for atomic::AtomicUsize {}\n-#[cfg(target_has_atomic_load_store = \"8\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicU8 {}\n-#[cfg(target_has_atomic_load_store = \"16\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicU16 {}\n-#[cfg(target_has_atomic_load_store = \"32\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicU32 {}\n-#[cfg(target_has_atomic_load_store = \"64\")]\n-#[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n-impl RefUnwindSafe for atomic::AtomicU64 {}\n-#[cfg(target_has_atomic_load_store = \"128\")]\n-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n-impl RefUnwindSafe for atomic::AtomicU128 {}\n-\n-#[cfg(target_has_atomic_load_store = \"8\")]\n-#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-impl RefUnwindSafe for atomic::AtomicBool {}\n-\n-#[cfg(target_has_atomic_load_store = \"ptr\")]\n-#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n-impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n-\n // https://github.com/rust-lang/rust/issues/62301\n #[stable(feature = \"hashbrown\", since = \"1.36.0\")]\n impl<K, V, S> UnwindSafe for collections::HashMap<K, V, S>\n@@ -323,61 +73,6 @@ where\n {\n }\n \n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T> Deref for AssertUnwindSafe<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        &self.0\n-    }\n-}\n-\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<T> DerefMut for AssertUnwindSafe<T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut self.0\n-    }\n-}\n-\n-#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n-    type Output = R;\n-\n-    extern \"rust-call\" fn call_once(self, _args: ()) -> R {\n-        (self.0)()\n-    }\n-}\n-\n-#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n-impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"AssertUnwindSafe\").field(&self.0).finish()\n-    }\n-}\n-\n-#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-impl<F: Future> Future for AssertUnwindSafe<F> {\n-    type Output = F::Output;\n-\n-    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n-        let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n-        F::poll(pinned_field, cx)\n-    }\n-}\n-\n-#[unstable(feature = \"async_stream\", issue = \"79024\")]\n-impl<S: Stream> Stream for AssertUnwindSafe<S> {\n-    type Item = S::Item;\n-\n-    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<S::Item>> {\n-        unsafe { self.map_unchecked_mut(|x| &mut x.0) }.poll_next(cx)\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.0.size_hint()\n-    }\n-}\n-\n /// Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n ///\n /// This function will return `Ok` with the closure's result if the closure"}]}