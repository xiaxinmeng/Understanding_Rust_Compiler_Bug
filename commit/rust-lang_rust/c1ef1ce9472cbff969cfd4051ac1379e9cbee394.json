{"sha": "c1ef1ce9472cbff969cfd4051ac1379e9cbee394", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZWYxY2U5NDcyY2JmZjk2OWNmZDQwNTFhYzEzNzllOWNiZWUzOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-23T05:51:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-23T05:51:10Z"}, "message": "auto merge of #10015 : huonw/rust/minor-fixes, r=alexcrichton\n\n- Use [\"nothing up my sleeve numbers\"](http://en.wikipedia.org/wiki/Nothing_up_my_sleeve_number) for the ISAAC tests.\r\n- Replace the default implementation of `Rng.fill_bytes` with something that doesn't try to do bad things with `transmute` and vectors just for the sake of a little speed.\r\n- Replace the transmutes used to seed the ISAAC RNGs with calls into `vec::raw`.", "tree": {"sha": "3c1cf56a59c190525c7dd34b1f2cc8d927662a1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c1cf56a59c190525c7dd34b1f2cc8d927662a1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1ef1ce9472cbff969cfd4051ac1379e9cbee394", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ef1ce9472cbff969cfd4051ac1379e9cbee394", "html_url": "https://github.com/rust-lang/rust/commit/c1ef1ce9472cbff969cfd4051ac1379e9cbee394", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1ef1ce9472cbff969cfd4051ac1379e9cbee394/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cbc8ad3979918fafb0527cc3326dc27b21936b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbc8ad3979918fafb0527cc3326dc27b21936b0", "html_url": "https://github.com/rust-lang/rust/commit/4cbc8ad3979918fafb0527cc3326dc27b21936b0"}, {"sha": "6e7bbdacb9bf04c1f5bf2c3aad487122d8377b7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e7bbdacb9bf04c1f5bf2c3aad487122d8377b7f", "html_url": "https://github.com/rust-lang/rust/commit/6e7bbdacb9bf04c1f5bf2c3aad487122d8377b7f"}], "stats": {"total": 148, "additions": 78, "deletions": 70}, "files": [{"sha": "7dc4e5b868b887cfb556907e37a4c2cc82298ce9", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c1ef1ce9472cbff969cfd4051ac1379e9cbee394/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ef1ce9472cbff969cfd4051ac1379e9cbee394/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=c1ef1ce9472cbff969cfd4051ac1379e9cbee394", "patch": "@@ -10,10 +10,11 @@\n \n //! The ISAAC random number generator.\n \n-use cast;\n use rand::{Rng, SeedableRng, OSRng};\n use iter::{Iterator, range, range_step, Repeat};\n use option::{None, Some};\n+use vec::raw;\n+use mem;\n \n static RAND_SIZE_LEN: u32 = 8;\n static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n@@ -42,9 +43,12 @@ impl IsaacRng {\n     pub fn new() -> IsaacRng {\n         let mut rng = EMPTY;\n \n-        {\n-            let bytes = unsafe {cast::transmute::<&mut [u32], &mut [u8]>(rng.rsl)};\n-            OSRng::new().fill_bytes(bytes);\n+        unsafe {\n+            let ptr = raw::to_mut_ptr(rng.rsl);\n+\n+            do raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl)) |slice| {\n+                OSRng::new().fill_bytes(slice);\n+            }\n         }\n \n         rng.init(true);\n@@ -238,10 +242,15 @@ impl Isaac64Rng {\n     /// seed.\n     pub fn new() -> Isaac64Rng {\n         let mut rng = EMPTY_64;\n-        {\n-            let bytes = unsafe {cast::transmute::<&mut [u64], &mut [u8]>(rng.rsl)};\n-            OSRng::new().fill_bytes(bytes);\n+\n+        unsafe {\n+            let ptr = raw::to_mut_ptr(rng.rsl);\n+\n+            do raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl)) |slice| {\n+                OSRng::new().fill_bytes(slice);\n+            }\n         }\n+\n         rng.init(true);\n         rng\n     }\n@@ -434,14 +443,14 @@ mod test {\n \n     #[test]\n     fn test_rng_32_seeded() {\n-        let seed = &[2, 32, 4, 32, 51];\n+        let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n     #[test]\n     fn test_rng_64_seeded() {\n-        let seed = &[2, 32, 4, 32, 51];\n+        let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n@@ -472,46 +481,46 @@ mod test {\n \n     #[test]\n     fn test_rng_32_true_values() {\n-        let seed = &[2, 32, 4, 32, 51];\n+        let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n         let v = vec::from_fn(10, |_| ra.next_u32());\n         assert_eq!(v,\n-                   ~[447462228, 2081944040, 3163797308, 2379916134, 2377489184,\n-                     1132373754, 536342443, 2995223415, 1265094839, 345325140]);\n+                   ~[2558573138, 873787463, 263499565, 2103644246, 3595684709,\n+                     4203127393, 264982119, 2765226902, 2737944514, 3900253796]);\n \n-        let seed = &[500, -4000, 123456, 9876543, 1, 1, 1, 1, 1];\n+        let seed = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0, 10000) { rb.next_u32(); }\n \n         let v = vec::from_fn(10, |_| rb.next_u32());\n         assert_eq!(v,\n-                   ~[612373032, 292987903, 1819311337, 3141271980, 422447569,\n-                     310096395, 1083172510, 867909094, 2478664230, 2073577855]);\n+                   ~[3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n+                     1576568959, 3507990155, 179069555, 141456972, 2478885421]);\n     }\n     #[test]\n     fn test_rng_64_true_values() {\n-        let seed = &[2, 32, 4, 32, 51];\n+        let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n         let v = vec::from_fn(10, |_| ra.next_u64());\n         assert_eq!(v,\n-                   ~[15015576812873463115, 12461067598045625862, 14818626436142668771,\n-                     5562406406765984441, 11813289907965514161, 13443797187798420053,\n-                     6935026941854944442, 7750800609318664042, 14428747036317928637,\n-                     14028894460301215947]);\n+                   ~[547121783600835980, 14377643087320773276, 17351601304698403469,\n+                     1238879483818134882, 11952566807690396487, 13970131091560099343,\n+                     4469761996653280935, 15552757044682284409, 6860251611068737823,\n+                     13722198873481261842]);\n \n-        let seed = &[500, -4000, 123456, 9876543, 1, 1, 1, 1, 1];\n+        let seed = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0, 10000) { rb.next_u64(); }\n \n         let v = vec::from_fn(10, |_| rb.next_u64());\n         assert_eq!(v,\n-                   ~[13557216323596688637, 17060829581390442094, 4927582063811333743,\n-                     2699639759356482270, 4819341314392384881, 6047100822963614452,\n-                     11086255989965979163, 11901890363215659856, 5370800226050011580,\n-                     16496463556025356451]);\n+                   ~[18143823860592706164, 8491801882678285927, 2699425367717515619,\n+                     17196852593171130876, 2606123525235546165, 15790932315217671084,\n+                     596345674630742204, 9947027391921273664, 11788097613744130851,\n+                     10391409374914919106]);\n     }\n }"}, {"sha": "9f611578c6a97c05a3235bbd296babffc31a273f", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c1ef1ce9472cbff969cfd4051ac1379e9cbee394/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ef1ce9472cbff969cfd4051ac1379e9cbee394/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=c1ef1ce9472cbff969cfd4051ac1379e9cbee394", "patch": "@@ -52,8 +52,6 @@ fn main () {\n  ```\n */\n \n-use mem::size_of;\n-use unstable::raw::Slice;\n use cast;\n use container::Container;\n use iter::{Iterator, range};\n@@ -136,46 +134,26 @@ pub trait Rng {\n     /// }\n     /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n-        let mut slice: Slice<u64> = unsafe { cast::transmute_copy(&dest) };\n-        slice.len /= size_of::<u64>();\n-        let as_u64: &mut [u64] = unsafe { cast::transmute(slice) };\n-        for dest in as_u64.mut_iter() {\n-            *dest = self.next_u64();\n-        }\n-\n-        // the above will have filled up the vector as much as\n-        // possible in multiples of 8 bytes.\n-        let mut remaining = dest.len() % 8;\n-\n-        // space for a u32\n-        if remaining >= 4 {\n-            let mut slice: Slice<u32> = unsafe { cast::transmute_copy(&dest) };\n-            slice.len /= size_of::<u32>();\n-            let as_u32: &mut [u32] = unsafe { cast::transmute(slice) };\n-            as_u32[as_u32.len() - 1] = self.next_u32();\n-            remaining -= 4;\n-        }\n-        // exactly filled\n-        if remaining == 0 { return }\n-\n-        // now we know we've either got 1, 2 or 3 spots to go,\n-        // i.e. exactly one u32 is enough.\n-        let rand = self.next_u32();\n-        let remaining_index = dest.len() - remaining;\n-        match dest.mut_slice_from(remaining_index) {\n-            [ref mut a] => {\n-                *a = rand as u8;\n+        // this could, in theory, be done by transmuting dest to a\n+        // [u64], but this is (1) likely to be undefined behaviour for\n+        // LLVM, (2) has to be very careful about alignment concerns,\n+        // (3) adds more `unsafe` that needs to be checked, (4)\n+        // probably doesn't give much performance gain if\n+        // optimisations are on.\n+        let mut count = 0;\n+        let mut num = 0;\n+        for byte in dest.mut_iter() {\n+            if count == 0 {\n+                // we could micro-optimise here by generating a u32 if\n+                // we only need a few more bytes to fill the vector\n+                // (i.e. at most 4).\n+                num = self.next_u64();\n+                count = 8;\n             }\n-            [ref mut a, ref mut b] => {\n-                *a = rand as u8;\n-                *b = (rand >> 8) as u8;\n-            }\n-            [ref mut a, ref mut b, ref mut c] => {\n-                *a = rand as u8;\n-                *b = (rand >> 8) as u8;\n-                *c = (rand >> 16) as u8;\n-            }\n-            _ => fail!(\"Rng.fill_bytes: the impossible occurred: remaining != 1, 2 or 3\")\n+\n+            *byte = (num & 0xff) as u8;\n+            num >>= 8;\n+            count -= 1;\n         }\n     }\n \n@@ -749,14 +727,35 @@ pub fn random<T: Rand>() -> T {\n mod test {\n     use iter::{Iterator, range};\n     use option::{Option, Some};\n+    use vec;\n     use super::*;\n \n+    struct ConstRng { i: u64 }\n+    impl Rng for ConstRng {\n+        fn next_u32(&mut self) -> u32 { self.i as u32 }\n+        fn next_u64(&mut self) -> u64 { self.i }\n+\n+        // no fill_bytes on purpose\n+    }\n+\n     #[test]\n     fn test_fill_bytes_default() {\n-        let mut r = weak_rng();\n-\n-        let mut v = [0u8, .. 100];\n-        r.fill_bytes(v);\n+        let mut r = ConstRng { i: 0x11_22_33_44_55_66_77_88 };\n+\n+        // check every remainder mod 8, both in small and big vectors.\n+        let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n+                       80, 81, 82, 83, 84, 85, 86, 87];\n+        for &n in lengths.iter() {\n+            let mut v = vec::from_elem(n, 0u8);\n+            r.fill_bytes(v);\n+\n+            // use this to get nicer error messages.\n+            for (i, &byte) in v.iter().enumerate() {\n+                if byte == 0 {\n+                    fail!(\"byte {} of {} is zero\", i, n)\n+                }\n+            }\n+        }\n     }\n \n     #[test]"}]}