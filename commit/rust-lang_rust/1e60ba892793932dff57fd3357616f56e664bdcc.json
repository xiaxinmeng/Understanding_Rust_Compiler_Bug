{"sha": "1e60ba892793932dff57fd3357616f56e664bdcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNjBiYTg5Mjc5MzkzMmRmZjU3ZmQzMzU3NjE2ZjU2ZTY2NGJkY2M=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-07-14T12:23:44Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-07-14T16:22:47Z"}, "message": "Have InferenceContext contain an InferenceResult instead of duplicating all fields", "tree": {"sha": "3e1b85ac6ffe03d069531316fee114eb4caf16d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e1b85ac6ffe03d069531316fee114eb4caf16d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e60ba892793932dff57fd3357616f56e664bdcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e60ba892793932dff57fd3357616f56e664bdcc", "html_url": "https://github.com/rust-lang/rust/commit/1e60ba892793932dff57fd3357616f56e664bdcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e60ba892793932dff57fd3357616f56e664bdcc/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a20770f46138909d91a1db371ed7371caf704e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a20770f46138909d91a1db371ed7371caf704e1", "html_url": "https://github.com/rust-lang/rust/commit/0a20770f46138909d91a1db371ed7371caf704e1"}], "stats": {"total": 55, "additions": 19, "deletions": 36}, "files": [{"sha": "0e030576d8706b9002bca958ef45f6445c4c8a3a", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1e60ba892793932dff57fd3357616f56e664bdcc/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e60ba892793932dff57fd3357616f56e664bdcc/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=1e60ba892793932dff57fd3357616f56e664bdcc", "patch": "@@ -107,7 +107,7 @@ impl Default for BindingMode {\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct InferenceResult {\n     /// For each method call expr, records the function it resolves to.\n     method_resolutions: FxHashMap<ExprId, Function>,\n@@ -172,27 +172,15 @@ struct InferenceContext<'a, D: HirDatabase> {\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     trait_env: Arc<TraitEnvironment>,\n     obligations: Vec<Obligation>,\n-    method_resolutions: FxHashMap<ExprId, Function>,\n-    field_resolutions: FxHashMap<ExprId, StructField>,\n-    variant_resolutions: FxHashMap<ExprId, VariantDef>,\n-    assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n-    type_of_expr: ArenaMap<ExprId, Ty>,\n-    type_of_pat: ArenaMap<PatId, Ty>,\n-    diagnostics: Vec<InferenceDiagnostic>,\n+    result: InferenceResult,\n     /// The return type of the function being inferred.\n     return_ty: Ty,\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(db: &'a D, body: Arc<Body>, resolver: Resolver) -> Self {\n         InferenceContext {\n-            method_resolutions: FxHashMap::default(),\n-            field_resolutions: FxHashMap::default(),\n-            variant_resolutions: FxHashMap::default(),\n-            assoc_resolutions: FxHashMap::default(),\n-            type_of_expr: ArenaMap::default(),\n-            type_of_pat: ArenaMap::default(),\n-            diagnostics: Vec::default(),\n+            result: InferenceResult::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n@@ -205,50 +193,45 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n+        let mut result = mem::replace(&mut self.result, InferenceResult::default());\n         let mut tv_stack = Vec::new();\n-        let mut expr_types = mem::replace(&mut self.type_of_expr, ArenaMap::default());\n-        for ty in expr_types.values_mut() {\n+        for ty in result.type_of_expr.values_mut() {\n             let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n-        let mut pat_types = mem::replace(&mut self.type_of_pat, ArenaMap::default());\n-        for ty in pat_types.values_mut() {\n+        for ty in result.type_of_pat.values_mut() {\n             let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n-        InferenceResult {\n-            method_resolutions: self.method_resolutions,\n-            field_resolutions: self.field_resolutions,\n-            variant_resolutions: self.variant_resolutions,\n-            assoc_resolutions: self.assoc_resolutions,\n-            type_of_expr: expr_types,\n-            type_of_pat: pat_types,\n-            diagnostics: self.diagnostics,\n-        }\n+        result\n     }\n \n     fn write_expr_ty(&mut self, expr: ExprId, ty: Ty) {\n-        self.type_of_expr.insert(expr, ty);\n+        self.result.type_of_expr.insert(expr, ty);\n     }\n \n     fn write_method_resolution(&mut self, expr: ExprId, func: Function) {\n-        self.method_resolutions.insert(expr, func);\n+        self.result.method_resolutions.insert(expr, func);\n     }\n \n     fn write_field_resolution(&mut self, expr: ExprId, field: StructField) {\n-        self.field_resolutions.insert(expr, field);\n+        self.result.field_resolutions.insert(expr, field);\n     }\n \n     fn write_variant_resolution(&mut self, expr: ExprId, variant: VariantDef) {\n-        self.variant_resolutions.insert(expr, variant);\n+        self.result.variant_resolutions.insert(expr, variant);\n     }\n \n     fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: ImplItem) {\n-        self.assoc_resolutions.insert(id, item);\n+        self.result.assoc_resolutions.insert(id, item);\n     }\n \n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n-        self.type_of_pat.insert(pat, ty);\n+        self.result.type_of_pat.insert(pat, ty);\n+    }\n+\n+    fn push_diagnostic(&mut self, diagnostic: InferenceDiagnostic) {\n+        self.result.diagnostics.push(diagnostic);\n     }\n \n     fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n@@ -565,7 +548,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Some(ty)\n             }\n             Resolution::LocalBinding(pat) => {\n-                let ty = self.type_of_pat.get(pat)?.clone();\n+                let ty = self.result.type_of_pat.get(pat)?.clone();\n                 let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n                 Some(ty)\n             }\n@@ -1090,7 +1073,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         .and_then(|it| match it.field(self.db, &field.name) {\n                             Some(field) => Some(field),\n                             None => {\n-                                self.diagnostics.push(InferenceDiagnostic::NoSuchField {\n+                                self.push_diagnostic(InferenceDiagnostic::NoSuchField {\n                                     expr: tgt_expr,\n                                     field: field_idx,\n                                 });"}]}