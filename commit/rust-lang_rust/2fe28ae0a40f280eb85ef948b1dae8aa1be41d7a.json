{"sha": "2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "node_id": "C_kwDOAAsO6NoAKDJmZTI4YWUwYTQwZjI4MGViODVlZjk0OGIxZGFlOGFhMWJlNDFkN2E", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-02-07T07:32:30Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-04-30T07:48:47Z"}, "message": "Use dynamic dispatch for queries", "tree": {"sha": "21e77a8aced08d42d001eff02338fa66364a9b5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21e77a8aced08d42d001eff02338fa66364a9b5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "html_url": "https://github.com/rust-lang/rust/commit/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3edfd18c790971c77845bfc1a2be4f9281c5416", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3edfd18c790971c77845bfc1a2be4f9281c5416", "html_url": "https://github.com/rust-lang/rust/commit/d3edfd18c790971c77845bfc1a2be4f9281c5416"}], "stats": {"total": 623, "additions": 377, "deletions": 246}, "files": [{"sha": "6593ef1e94a2dadde0ec6940272d09e9aa06bf65", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -318,7 +318,7 @@ pub fn try_print_query_stack(handler: &Handler, num_frames: Option<usize>) {\n     // state if it was responsible for triggering the panic.\n     let i = ty::tls::with_context_opt(|icx| {\n         if let Some(icx) = icx {\n-            print_query_stack(QueryCtxt { tcx: icx.tcx }, icx.query, handler, num_frames)\n+            print_query_stack(QueryCtxt::new(icx.tcx), icx.query, handler, num_frames)\n         } else {\n             0\n         }"}, {"sha": "d3af01474b85fd23434a59853f89f0d4bb3da5ca", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -700,9 +700,12 @@ pub fn create_global_ctxt<'tcx>(\n                 hir_arena,\n                 untracked,\n                 dep_graph,\n-                query_result_on_disk_cache,\n                 rustc_query_impl::query_callbacks(arena),\n-                rustc_query_impl::query_system_fns(local_providers, extern_providers),\n+                rustc_query_impl::query_system(\n+                    local_providers,\n+                    extern_providers,\n+                    query_result_on_disk_cache,\n+                ),\n             )\n         })\n     })"}, {"sha": "7c56af1da41a5f2c46ea3400db49dd1e49b08de8", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -11,6 +11,7 @@ chalk-ir = \"0.87.0\"\n derive_more = \"0.99.17\"\n either = \"1.5.0\"\n gsgdt = \"0.1.2\"\n+field-offset = \"0.3.5\"\n measureme = \"10.0.0\"\n polonius-engine = \"0.13.0\"\n rustc_apfloat = { path = \"../rustc_apfloat\" }"}, {"sha": "1a1b8b2f5c6ca3ce33581bacb7db7af759be4a6b", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -14,14 +14,12 @@ use crate::middle::resolve_bound_vars;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation};\n use crate::mir::{Body, Local, Place, PlaceElem, ProjectionKind, Promoted};\n-use crate::query::on_disk_cache::OnDiskCache;\n use crate::query::LocalCrate;\n use crate::thir::Thir;\n use crate::traits;\n use crate::traits::solve;\n use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use crate::ty::query::QuerySystem;\n-use crate::ty::query::QuerySystemFns;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, FloatTy, FloatVar, FloatVid,\n@@ -653,9 +651,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n         untracked: Untracked,\n         dep_graph: DepGraph,\n-        on_disk_cache: Option<OnDiskCache<'tcx>>,\n         query_kinds: &'tcx [DepKindStruct<'tcx>],\n-        query_system_fns: QuerySystemFns<'tcx>,\n+        query_system: QuerySystem<'tcx>,\n     ) -> GlobalCtxt<'tcx> {\n         let data_layout = s.target.parse_data_layout().unwrap_or_else(|err| {\n             s.emit_fatal(err);\n@@ -677,7 +674,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n             untracked,\n-            query_system: QuerySystem::new(query_system_fns, on_disk_cache),\n+            query_system,\n             query_kinds,\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),"}, {"sha": "fcdf33f9de471d87c169c7c5c6734b51d3291a15", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -43,6 +43,7 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;\n use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt, UnusedGenericParams};\n+use field_offset::FieldOffset;\n use measureme::StringId;\n use rustc_arena::TypedArena;\n use rustc_ast as ast;\n@@ -66,9 +67,12 @@ use rustc_hir::hir_id::OwnerId;\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::IndexVec;\n+use rustc_query_system::dep_graph::DepNodeIndex;\n+use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n use rustc_query_system::ich::StableHashingContext;\n pub(crate) use rustc_query_system::query::QueryJobId;\n use rustc_query_system::query::*;\n+use rustc_query_system::HandleCycleError;\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n@@ -78,8 +82,6 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi;\n use rustc_target::spec::PanicStrategy;\n-\n-use std::marker::PhantomData;\n use std::mem;\n use std::ops::Deref;\n use std::path::PathBuf;\n@@ -103,6 +105,31 @@ pub struct QueryStruct<'tcx> {\n         Option<fn(TyCtxt<'tcx>, &mut CacheEncoder<'_, 'tcx>, &mut EncodedDepNodeIndex)>,\n }\n \n+pub struct DynamicQuery<'tcx, C: QueryCache> {\n+    pub name: &'static str,\n+    pub eval_always: bool,\n+    pub dep_kind: rustc_middle::dep_graph::DepKind,\n+    pub handle_cycle_error: HandleCycleError,\n+    pub query_state: FieldOffset<QueryStates<'tcx>, QueryState<C::Key, crate::dep_graph::DepKind>>,\n+    pub query_cache: FieldOffset<QueryCaches<'tcx>, C>,\n+    pub cache_on_disk: fn(tcx: TyCtxt<'tcx>, key: &C::Key) -> bool,\n+    pub execute_query: fn(tcx: TyCtxt<'tcx>, k: C::Key) -> C::Value,\n+    pub compute: fn(tcx: TyCtxt<'tcx>, key: C::Key) -> C::Value,\n+    pub can_load_from_disk: bool,\n+    pub try_load_from_disk: fn(\n+        tcx: TyCtxt<'tcx>,\n+        key: &C::Key,\n+        prev_index: SerializedDepNodeIndex,\n+        index: DepNodeIndex,\n+    ) -> Option<C::Value>,\n+    pub loadable_from_disk:\n+        fn(tcx: TyCtxt<'tcx>, key: &C::Key, index: SerializedDepNodeIndex) -> bool,\n+    pub hash_result: HashResult<C::Value>,\n+    pub value_from_cycle_error:\n+        fn(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<crate::dep_graph::DepKind>]) -> C::Value,\n+    pub format_value: fn(&C::Value) -> String,\n+}\n+\n pub struct QuerySystemFns<'tcx> {\n     pub engine: QueryEngine,\n     pub local_providers: Providers,\n@@ -120,6 +147,7 @@ pub struct QuerySystem<'tcx> {\n     pub states: QueryStates<'tcx>,\n     pub arenas: QueryArenas<'tcx>,\n     pub caches: QueryCaches<'tcx>,\n+    pub dynamic_queries: DynamicQueries<'tcx>,\n \n     /// This provides access to the incremental compilation on-disk cache for query results.\n     /// Do not access this directly. It is only meant to be used by\n@@ -130,23 +158,6 @@ pub struct QuerySystem<'tcx> {\n     pub fns: QuerySystemFns<'tcx>,\n \n     pub jobs: AtomicU64,\n-\n-    // Since we erase query value types we tell the typesystem about them with `PhantomData`.\n-    _phantom_values: QueryPhantomValues<'tcx>,\n-}\n-\n-impl<'tcx> QuerySystem<'tcx> {\n-    pub fn new(fns: QuerySystemFns<'tcx>, on_disk_cache: Option<OnDiskCache<'tcx>>) -> Self {\n-        QuerySystem {\n-            states: Default::default(),\n-            arenas: Default::default(),\n-            caches: Default::default(),\n-            on_disk_cache,\n-            fns,\n-            jobs: AtomicU64::new(1),\n-            _phantom_values: Default::default(),\n-        }\n-    }\n }\n \n #[derive(Copy, Clone)]\n@@ -427,11 +438,6 @@ macro_rules! define_callbacks {\n             }\n         }\n \n-        #[derive(Default)]\n-        pub struct QueryPhantomValues<'tcx> {\n-            $($(#[$attr])* pub $name: PhantomData<query_values::$name<'tcx>>,)*\n-        }\n-\n         #[derive(Default)]\n         pub struct QueryCaches<'tcx> {\n             $($(#[$attr])* pub $name: query_storage::$name<'tcx>,)*\n@@ -490,6 +496,12 @@ macro_rules! define_callbacks {\n             })*\n         }\n \n+        pub struct DynamicQueries<'tcx> {\n+            $(\n+                pub $name: DynamicQuery<'tcx, query_storage::$name<'tcx>>,\n+            )*\n+        }\n+\n         #[derive(Default)]\n         pub struct QueryStates<'tcx> {\n             $("}, {"sha": "e596993465c1bf764a631c64cb25a6501fb71e64", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -7,6 +7,8 @@ edition = \"2021\"\n \n \n [dependencies]\n+memoffset = { version = \"0.6.0\", features = [\"unstable_const\"] }\n+field-offset = \"0.3.5\"\n measureme = \"10.0.0\"\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "39ca465954175903970ab39fff7ae5575c442e4b", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 182, "deletions": 19, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -3,60 +3,223 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n // this shouldn't be necessary, but the check for `&mut _` is too naive and denies returning a function pointer that takes a mut ref\n #![feature(const_mut_refs)]\n+#![feature(const_refs_to_cell)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n+#![allow(rustc::potential_query_instability, unused_parens)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;\n \n use crate::plumbing::{encode_all_query_results, try_mark_green};\n+use field_offset::offset_of;\n+use rustc_data_structures::stable_hasher::HashStable;\n+use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n+use rustc_middle::dep_graph::DepNodeIndex;\n use rustc_middle::dep_graph::{self, DepKind, DepKindStruct};\n use rustc_middle::query::erase::{erase, restore, Erase};\n+use rustc_middle::query::on_disk_cache::OnDiskCache;\n use rustc_middle::query::AsLocalKey;\n use rustc_middle::ty::query::{\n     query_keys, query_provided, query_provided_to_value, query_storage, query_values,\n+    DynamicQueries, DynamicQuery, ExternProviders, Providers, QueryCaches, QueryEngine,\n+    QueryStates, QuerySystem, QuerySystemFns,\n };\n-use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine, QuerySystemFns};\n use rustc_middle::ty::TyCtxt;\n use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n+use rustc_query_system::ich::StableHashingContext;\n+use rustc_query_system::query::{\n+    get_query, HashResult, QueryCache, QueryConfig, QueryInfo, QueryMap, QueryMode, QueryState,\n+};\n+use rustc_query_system::HandleCycleError;\n use rustc_query_system::Value;\n use rustc_span::Span;\n \n #[macro_use]\n mod plumbing;\n pub use crate::plumbing::QueryCtxt;\n \n-pub use rustc_query_system::query::QueryConfig;\n-use rustc_query_system::query::*;\n-\n mod profiling_support;\n pub use self::profiling_support::alloc_self_profile_query_strings;\n \n-/// This is implemented per query and restoring query values from their erased state.\n-trait QueryConfigRestored<'tcx>: QueryConfig<QueryCtxt<'tcx>> + Default {\n-    type RestoredValue;\n+struct DynamicConfig<\n+    'tcx,\n+    C: QueryCache,\n+    const ANON: bool,\n+    const DEPTH_LIMIT: bool,\n+    const FEEDABLE: bool,\n+> {\n+    dynamic: &'tcx DynamicQuery<'tcx, C>,\n+}\n \n-    fn restore(value: <Self as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue;\n+impl<'tcx, C: QueryCache, const ANON: bool, const DEPTH_LIMIT: bool, const FEEDABLE: bool> Copy\n+    for DynamicConfig<'tcx, C, ANON, DEPTH_LIMIT, FEEDABLE>\n+{\n+}\n+impl<'tcx, C: QueryCache, const ANON: bool, const DEPTH_LIMIT: bool, const FEEDABLE: bool> Clone\n+    for DynamicConfig<'tcx, C, ANON, DEPTH_LIMIT, FEEDABLE>\n+{\n+    fn clone(&self) -> Self {\n+        DynamicConfig { dynamic: self.dynamic }\n+    }\n }\n \n-rustc_query_append! { define_queries! }\n+impl<'tcx, C: QueryCache, const ANON: bool, const DEPTH_LIMIT: bool, const FEEDABLE: bool>\n+    QueryConfig<QueryCtxt<'tcx>> for DynamicConfig<'tcx, C, ANON, DEPTH_LIMIT, FEEDABLE>\n+where\n+    for<'a> C::Key: HashStable<StableHashingContext<'a>>,\n+{\n+    type Key = C::Key;\n+    type Value = C::Value;\n+    type Cache = C;\n+\n+    #[inline(always)]\n+    fn name(self) -> &'static str {\n+        self.dynamic.name\n+    }\n+\n+    #[inline(always)]\n+    fn cache_on_disk(self, tcx: TyCtxt<'tcx>, key: &Self::Key) -> bool {\n+        (self.dynamic.cache_on_disk)(tcx, key)\n+    }\n+\n+    #[inline(always)]\n+    fn query_state<'a>(self, qcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key, DepKind>\n+    where\n+        QueryCtxt<'tcx>: 'a,\n+    {\n+        self.dynamic.query_state.apply(&qcx.tcx.query_system.states)\n+    }\n+\n+    #[inline(always)]\n+    fn query_cache<'a>(self, qcx: QueryCtxt<'tcx>) -> &'a Self::Cache\n+    where\n+        'tcx: 'a,\n+    {\n+        self.dynamic.query_cache.apply(&qcx.tcx.query_system.caches)\n+    }\n+\n+    #[inline(always)]\n+    fn execute_query(self, tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+        (self.dynamic.execute_query)(tcx, key)\n+    }\n+\n+    #[inline(always)]\n+    fn compute(self, qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+        (self.dynamic.compute)(qcx.tcx, key)\n+    }\n+\n+    #[inline(always)]\n+    fn try_load_from_disk(\n+        self,\n+        qcx: QueryCtxt<'tcx>,\n+        key: &Self::Key,\n+        prev_index: SerializedDepNodeIndex,\n+        index: DepNodeIndex,\n+    ) -> Option<Self::Value> {\n+        if self.dynamic.can_load_from_disk {\n+            (self.dynamic.try_load_from_disk)(qcx.tcx, key, prev_index, index)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn loadable_from_disk(\n+        self,\n+        qcx: QueryCtxt<'tcx>,\n+        key: &Self::Key,\n+        index: SerializedDepNodeIndex,\n+    ) -> bool {\n+        (self.dynamic.loadable_from_disk)(qcx.tcx, key, index)\n+    }\n+\n+    fn value_from_cycle_error(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        cycle: &[QueryInfo<DepKind>],\n+    ) -> Self::Value {\n+        (self.dynamic.value_from_cycle_error)(tcx, cycle)\n+    }\n+\n+    #[inline(always)]\n+    fn format_value(self) -> fn(&Self::Value) -> String {\n+        self.dynamic.format_value\n+    }\n+\n+    #[inline(always)]\n+    fn anon(self) -> bool {\n+        ANON\n+    }\n+\n+    #[inline(always)]\n+    fn eval_always(self) -> bool {\n+        self.dynamic.eval_always\n+    }\n+\n+    #[inline(always)]\n+    fn depth_limit(self) -> bool {\n+        DEPTH_LIMIT\n+    }\n+\n+    #[inline(always)]\n+    fn feedable(self) -> bool {\n+        FEEDABLE\n+    }\n+\n+    #[inline(always)]\n+    fn dep_kind(self) -> DepKind {\n+        self.dynamic.dep_kind\n+    }\n+\n+    #[inline(always)]\n+    fn handle_cycle_error(self) -> HandleCycleError {\n+        self.dynamic.handle_cycle_error\n+    }\n+\n+    #[inline(always)]\n+    fn hash_result(self) -> HashResult<Self::Value> {\n+        self.dynamic.hash_result\n+    }\n+}\n \n-pub fn query_system_fns<'tcx>(\n+/// This is implemented per query. It allows restoring query values from their erased state\n+/// and constructing a QueryConfig.\n+trait QueryConfigRestored<'tcx> {\n+    type RestoredValue;\n+    type Config: QueryConfig<QueryCtxt<'tcx>>;\n+\n+    fn config(tcx: TyCtxt<'tcx>) -> Self::Config;\n+    fn restore(value: <Self::Config as QueryConfig<QueryCtxt<'tcx>>>::Value)\n+    -> Self::RestoredValue;\n+}\n+\n+pub fn query_system<'tcx>(\n     local_providers: Providers,\n     extern_providers: ExternProviders,\n-) -> QuerySystemFns<'tcx> {\n-    QuerySystemFns {\n-        engine: engine(),\n-        local_providers,\n-        extern_providers,\n-        query_structs: make_dep_kind_array!(query_structs).to_vec(),\n-        encode_query_results: encode_all_query_results,\n-        try_mark_green: try_mark_green,\n+    on_disk_cache: Option<OnDiskCache<'tcx>>,\n+) -> QuerySystem<'tcx> {\n+    QuerySystem {\n+        states: Default::default(),\n+        arenas: Default::default(),\n+        caches: Default::default(),\n+        dynamic_queries: dynamic_queries(),\n+        on_disk_cache,\n+        fns: QuerySystemFns {\n+            engine: engine(),\n+            local_providers,\n+            extern_providers,\n+            query_structs: make_dep_kind_array!(query_structs).to_vec(),\n+            encode_query_results: encode_all_query_results,\n+            try_mark_green: try_mark_green,\n+        },\n+        jobs: AtomicU64::new(1),\n     }\n }\n+\n+rustc_query_append! { define_queries! }"}, {"sha": "74924e8113e6fc5a70e87fa885ba1b93a29bed90", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 105, "deletions": 143, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -4,6 +4,7 @@\n \n use crate::rustc_middle::dep_graph::DepContext;\n use crate::rustc_middle::ty::TyEncoder;\n+use crate::QueryConfigRestored;\n use rustc_data_structures::stable_hasher::{Hash64, HashStable, StableHasher};\n use rustc_data_structures::sync::Lock;\n use rustc_errors::Diagnostic;\n@@ -265,14 +266,14 @@ macro_rules! hash_result {\n }\n \n macro_rules! call_provider {\n-    ([][$qcx:expr, $name:ident, $key:expr]) => {{\n-        ($qcx.query_system.fns.local_providers.$name)($qcx, $key)\n+    ([][$tcx:expr, $name:ident, $key:expr]) => {{\n+        ($tcx.query_system.fns.local_providers.$name)($tcx, $key)\n     }};\n-    ([(separate_provide_extern) $($rest:tt)*][$qcx:expr, $name:ident, $key:expr]) => {{\n+    ([(separate_provide_extern) $($rest:tt)*][$tcx:expr, $name:ident, $key:expr]) => {{\n         if let Some(key) = $key.as_local_key() {\n-            ($qcx.query_system.fns.local_providers.$name)($qcx, key)\n+            ($tcx.query_system.fns.local_providers.$name)($tcx, key)\n         } else {\n-            ($qcx.query_system.fns.extern_providers.$name)($qcx, $key)\n+            ($tcx.query_system.fns.extern_providers.$name)($tcx, $key)\n         }\n     }};\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n@@ -341,7 +342,7 @@ pub(crate) fn create_query_frame<\n }\n \n pub(crate) fn encode_query_results<'a, 'tcx, Q>(\n-    query: Q,\n+    query: Q::Config,\n     qcx: QueryCtxt<'tcx>,\n     encoder: &mut CacheEncoder<'a, 'tcx>,\n     query_result_index: &mut EncodedDepNodeIndex,\n@@ -392,12 +393,26 @@ pub(crate) fn loadable_from_disk<'tcx>(tcx: TyCtxt<'tcx>, id: SerializedDepNodeI\n \n pub(crate) fn try_load_from_disk<'tcx, V>(\n     tcx: TyCtxt<'tcx>,\n-    id: SerializedDepNodeIndex,\n+    prev_index: SerializedDepNodeIndex,\n+    index: DepNodeIndex,\n ) -> Option<V>\n where\n     V: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n {\n-    tcx.query_system.on_disk_cache.as_ref()?.try_load_query_result(tcx, id)\n+    let on_disk_cache = tcx.query_system.on_disk_cache.as_ref()?;\n+\n+    let prof_timer = tcx.prof.incr_cache_loading();\n+\n+    // The call to `with_query_deserialization` enforces that no new `DepNodes`\n+    // are created during deserialization. See the docs of that method for more\n+    // details.\n+    let value = tcx\n+        .dep_graph\n+        .with_query_deserialization(|| on_disk_cache.try_load_query_result(tcx, prev_index));\n+\n+    prof_timer.finish_with_query_invocation_id(index.into());\n+\n+    value\n }\n \n fn force_from_dep_node<'tcx, Q>(query: Q, tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n@@ -434,10 +449,9 @@ where\n \n pub(crate) fn query_callback<'tcx, Q>(is_anon: bool, is_eval_always: bool) -> DepKindStruct<'tcx>\n where\n-    Q: QueryConfig<QueryCtxt<'tcx>> + Default,\n-    Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n+    Q: QueryConfigRestored<'tcx>,\n {\n-    let fingerprint_style = Q::Key::fingerprint_style();\n+    let fingerprint_style = <Q::Config as QueryConfig<QueryCtxt<'tcx>>>::Key::fingerprint_style();\n \n     if is_anon || !fingerprint_style.reconstructible() {\n         return DepKindStruct {\n@@ -453,9 +467,11 @@ where\n         is_anon,\n         is_eval_always,\n         fingerprint_style,\n-        force_from_dep_node: Some(|tcx, dep_node| force_from_dep_node(Q::default(), tcx, dep_node)),\n+        force_from_dep_node: Some(|tcx, dep_node| {\n+            force_from_dep_node(Q::config(tcx), tcx, dep_node)\n+        }),\n         try_load_from_on_disk_cache: Some(|tcx, dep_node| {\n-            try_load_from_on_disk_cache(Q::default(), tcx, dep_node)\n+            try_load_from_on_disk_cache(Q::config(tcx), tcx, dep_node)\n         }),\n     }\n }\n@@ -491,7 +507,7 @@ macro_rules! define_queries {\n                     mode: QueryMode,\n                 ) -> Option<Erase<query_values::$name<'tcx>>> {\n                     get_query(\n-                        queries::$name::default(),\n+                        queries::$name::config(tcx),\n                         QueryCtxt::new(tcx),\n                         span,\n                         key,\n@@ -519,146 +535,91 @@ macro_rules! define_queries {\n             )*\n         }\n \n-        $(impl<'tcx> QueryConfig<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n-            type Key = query_keys::$name<'tcx>;\n-            type Value = Erase<query_values::$name<'tcx>>;\n-\n-            #[inline(always)]\n-            fn name(self) -> &'static str {\n-                stringify!($name)\n-            }\n-\n-            #[inline]\n-            fn format_value(self) -> fn(&Self::Value) -> String {\n-                |value| format!(\"{:?}\", restore::<query_values::$name<'tcx>>(*value))\n-            }\n-\n-            #[inline]\n-            fn cache_on_disk(self, tcx: TyCtxt<'tcx>, key: &Self::Key) -> bool {\n-                ::rustc_middle::query::cached::$name(tcx, key)\n-            }\n-\n-            type Cache = query_storage::$name<'tcx>;\n-\n-            #[inline(always)]\n-            fn query_state<'a>(self, tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key, crate::dep_graph::DepKind>\n-                where QueryCtxt<'tcx>: 'a\n-            {\n-                &tcx.query_system.states.$name\n-            }\n-\n-            #[inline(always)]\n-            fn query_cache<'a>(self, tcx: QueryCtxt<'tcx>) -> &'a Self::Cache\n-                where 'tcx:'a\n-            {\n-                &tcx.query_system.caches.$name\n-            }\n-\n-            fn execute_query(self, tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                erase(tcx.$name(key))\n-            }\n-\n-            #[inline]\n-            #[allow(unused_variables)]\n-            fn compute(self, qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                query_provided_to_value::$name(\n-                    qcx.tcx,\n-                    call_provider!([$($modifiers)*][qcx.tcx, $name, key])\n-                )\n-            }\n+        #[allow(nonstandard_style)]\n+        mod dynamic_query {\n+            use super::*;\n \n-            #[inline]\n-            fn try_load_from_disk(\n-                self,\n-                _qcx: QueryCtxt<'tcx>,\n-                _key: &Self::Key\n-            ) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self::Value> {\n-                should_ever_cache_on_disk!([$($modifiers)*] {\n-                    if ::rustc_middle::query::cached::$name(_qcx.tcx, _key) {\n-                        Some(|qcx: QueryCtxt<'tcx>, dep_node| {\n-                            let value = $crate::plumbing::try_load_from_disk::<query_provided::$name<'tcx>>(\n-                                qcx.tcx,\n-                                dep_node\n-                            );\n-                            value.map(|value| query_provided_to_value::$name(qcx.tcx, value))\n-                        })\n-                    } else {\n-                        None\n+            $(\n+                pub(super) fn $name<'tcx>() -> DynamicQuery<'tcx, query_storage::$name<'tcx>> {\n+                    DynamicQuery {\n+                        name: stringify!($name),\n+                        eval_always: is_eval_always!([$($modifiers)*]),\n+                        dep_kind: dep_graph::DepKind::$name,\n+                        handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n+                        query_state: offset_of!(QueryStates<'tcx> => $name),\n+                        query_cache: offset_of!(QueryCaches<'tcx> => $name),\n+                        cache_on_disk: |tcx, key| ::rustc_middle::query::cached::$name(tcx, key),\n+                        execute_query: |tcx, key| erase(tcx.$name(key)),\n+                        compute: |tcx, key| query_provided_to_value::$name(\n+                            tcx,\n+                            call_provider!([$($modifiers)*][tcx, $name, key])\n+                        ),\n+                        can_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] true false),\n+                        try_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] {\n+                            |tcx, key, prev_index, index| {\n+                                if ::rustc_middle::query::cached::$name(tcx, key) {\n+                                    let value = $crate::plumbing::try_load_from_disk::<query_provided::$name<'tcx>>(\n+                                        tcx,\n+                                        prev_index,\n+                                        index,\n+                                    );\n+                                    value.map(|value| query_provided_to_value::$name(tcx, value))\n+                                } else {\n+                                    None\n+                                }\n+                            }\n+                        } {\n+                            |_tcx, _key, _prev_index, _index| None\n+                        }),\n+                        value_from_cycle_error: |tcx, cycle| {\n+                            let result: query_values::$name<'tcx> = Value::from_cycle_error(tcx, cycle);\n+                            erase(result)\n+                        },\n+                        loadable_from_disk: |_tcx, _key, _index| {\n+                            should_ever_cache_on_disk!([$($modifiers)*] {\n+                                ::rustc_middle::query::cached::$name(_tcx, _key) &&\n+                                    $crate::plumbing::loadable_from_disk(_tcx, _index)\n+                            } {\n+                                false\n+                            })\n+                        },\n+                        hash_result: hash_result!([$($modifiers)*][query_values::$name<'tcx>]),\n+                        format_value: |value| format!(\"{:?}\", restore::<query_values::$name<'tcx>>(*value)),\n                     }\n-                } {\n-                    None\n-                })\n-            }\n-\n-            #[inline]\n-            fn loadable_from_disk(\n-                self,\n-                _qcx: QueryCtxt<'tcx>,\n-                _key: &Self::Key,\n-                _index: SerializedDepNodeIndex,\n-            ) -> bool {\n-                should_ever_cache_on_disk!([$($modifiers)*] {\n-                    self.cache_on_disk(_qcx.tcx, _key) &&\n-                        $crate::plumbing::loadable_from_disk(_qcx.tcx, _index)\n-                } {\n-                    false\n-                })\n-            }\n-\n-            #[inline]\n-            fn value_from_cycle_error(\n-                self,\n-                tcx: TyCtxt<'tcx>,\n-                cycle: &[QueryInfo<DepKind>],\n-            ) -> Self::Value {\n-                let result: query_values::$name<'tcx> = Value::from_cycle_error(tcx, cycle);\n-                erase(result)\n-            }\n-\n-            #[inline(always)]\n-            fn anon(self) -> bool {\n-                is_anon!([$($modifiers)*])\n-            }\n-\n-            #[inline(always)]\n-            fn eval_always(self) -> bool {\n-                is_eval_always!([$($modifiers)*])\n-            }\n-\n-            #[inline(always)]\n-            fn depth_limit(self) -> bool {\n-                depth_limit!([$($modifiers)*])\n-            }\n-\n-            #[inline(always)]\n-            fn feedable(self) -> bool {\n-                feedable!([$($modifiers)*])\n-            }\n+                }\n+            )*\n+        }\n \n-            #[inline(always)]\n-            fn dep_kind(self) -> rustc_middle::dep_graph::DepKind {\n-                dep_graph::DepKind::$name\n-            }\n+        $(impl<'tcx> QueryConfigRestored<'tcx> for queries::$name<'tcx> {\n+            type RestoredValue = query_values::$name<'tcx>;\n+            type Config = DynamicConfig<\n+                'tcx,\n+                query_storage::$name<'tcx>,\n+                { is_anon!([$($modifiers)*]) },\n+                { depth_limit!([$($modifiers)*]) },\n+                { feedable!([$($modifiers)*]) },\n+            >;\n \n             #[inline(always)]\n-            fn handle_cycle_error(self) -> rustc_query_system::HandleCycleError {\n-                handle_cycle_error!([$($modifiers)*])\n+            fn config(tcx: TyCtxt<'tcx>) -> Self::Config {\n+                DynamicConfig {\n+                    dynamic: &tcx.query_system.dynamic_queries.$name,\n+                }\n             }\n \n             #[inline(always)]\n-            fn hash_result(self) -> rustc_query_system::query::HashResult<Self::Value> {\n-                hash_result!([$($modifiers)*][query_values::$name<'tcx>])\n+            fn restore(value: <Self::Config as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n+                restore::<query_values::$name<'tcx>>(value)\n             }\n         })*\n \n-        $(impl<'tcx> QueryConfigRestored<'tcx> for queries::$name<'tcx> {\n-            type RestoredValue = query_values::$name<'tcx>;\n-\n-            #[inline(always)]\n-            fn restore(value: <Self as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n-                restore::<query_values::$name<'tcx>>(value)\n+        pub fn dynamic_queries<'tcx>() -> DynamicQueries<'tcx> {\n+            DynamicQueries {\n+                $(\n+                    $name: dynamic_query::$name(),\n+                )*\n             }\n-        })*\n+        }\n \n         #[allow(nonstandard_style)]\n         mod query_callbacks {\n@@ -730,6 +691,7 @@ macro_rules! define_queries {\n             use rustc_middle::ty::query::QueryStruct;\n             use rustc_middle::ty::query::QueryKeyStringCache;\n             use rustc_middle::dep_graph::DepKind;\n+            use crate::QueryConfigRestored;\n \n             pub(super) const fn dummy_query_struct<'tcx>() -> QueryStruct<'tcx> {\n                 fn noop_try_collect_active_jobs(_: TyCtxt<'_>, _: &mut QueryMap<DepKind>) -> Option<()> {\n@@ -774,7 +736,7 @@ macro_rules! define_queries {\n                 },\n                 encode_query_results: expand_if_cached!([$($modifiers)*], |tcx, encoder, query_result_index|\n                     $crate::plumbing::encode_query_results::<super::queries::$name<'tcx>>(\n-                        super::queries::$name::default(),\n+                        super::queries::$name::config(tcx),\n                         QueryCtxt::new(tcx),\n                         encoder,\n                         query_result_index,"}, {"sha": "7e47d701205447399498527ed938c00070e59f7e", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -4,6 +4,7 @@ use crate::dep_graph::{DepNode, DepNodeParams, SerializedDepNodeIndex};\n use crate::error::HandleCycleError;\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n+use crate::query::DepNodeIndex;\n use crate::query::{QueryContext, QueryInfo, QueryState};\n \n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -12,8 +13,6 @@ use std::hash::Hash;\n \n pub type HashResult<V> = Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>;\n \n-pub type TryLoadFromDisk<Qcx, V> = Option<fn(Qcx, SerializedDepNodeIndex) -> Option<V>>;\n-\n pub trait QueryConfig<Qcx: QueryContext>: Copy {\n     fn name(self) -> &'static str;\n \n@@ -43,7 +42,13 @@ pub trait QueryConfig<Qcx: QueryContext>: Copy {\n \n     fn compute(self, tcx: Qcx, key: Self::Key) -> Self::Value;\n \n-    fn try_load_from_disk(self, qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self::Value>;\n+    fn try_load_from_disk(\n+        self,\n+        tcx: Qcx,\n+        key: &Self::Key,\n+        prev_index: SerializedDepNodeIndex,\n+        index: DepNodeIndex,\n+    ) -> Option<Self::Value>;\n \n     fn loadable_from_disk(self, qcx: Qcx, key: &Self::Key, idx: SerializedDepNodeIndex) -> bool;\n "}, {"sha": "f7619d75be768134862ef984199c6a4f98ca90bf", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -12,7 +12,7 @@ pub use self::caches::{\n };\n \n mod config;\n-pub use self::config::{HashResult, QueryConfig, TryLoadFromDisk};\n+pub use self::config::{HashResult, QueryConfig};\n \n use crate::dep_graph::DepKind;\n use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};"}, {"sha": "4aaedc7a6c15e62f6230d04f75f10ec0ec097c28", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -564,59 +564,44 @@ where\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n-    if let Some(try_load_from_disk) = query.try_load_from_disk(qcx, &key) {\n-        let prof_timer = qcx.dep_context().profiler().incr_cache_loading();\n-\n-        // The call to `with_query_deserialization` enforces that no new `DepNodes`\n-        // are created during deserialization. See the docs of that method for more\n-        // details.\n-        let result = qcx\n-            .dep_context()\n-            .dep_graph()\n-            .with_query_deserialization(|| try_load_from_disk(qcx, prev_dep_node_index));\n-\n-        prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n-\n-        if let Some(result) = result {\n-            if std::intrinsics::unlikely(\n-                qcx.dep_context().sess().opts.unstable_opts.query_dep_graph,\n-            ) {\n-                dep_graph_data.mark_debug_loaded_from_disk(*dep_node)\n-            }\n-\n-            let prev_fingerprint = dep_graph_data.prev_fingerprint_of(prev_dep_node_index);\n-            // If `-Zincremental-verify-ich` is specified, re-hash results from\n-            // the cache and make sure that they have the expected fingerprint.\n-            //\n-            // If not, we still seek to verify a subset of fingerprints loaded\n-            // from disk. Re-hashing results is fairly expensive, so we can't\n-            // currently afford to verify every hash. This subset should still\n-            // give us some coverage of potential bugs though.\n-            let try_verify = prev_fingerprint.split().1.as_u64() % 32 == 0;\n-            if std::intrinsics::unlikely(\n-                try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n-            ) {\n-                incremental_verify_ich(\n-                    *qcx.dep_context(),\n-                    dep_graph_data,\n-                    &result,\n-                    prev_dep_node_index,\n-                    query.hash_result(),\n-                    query.format_value(),\n-                );\n-            }\n+    if let Some(result) = query.try_load_from_disk(qcx, key, prev_dep_node_index, dep_node_index) {\n+        if std::intrinsics::unlikely(qcx.dep_context().sess().opts.unstable_opts.query_dep_graph) {\n+            dep_graph_data.mark_debug_loaded_from_disk(*dep_node)\n+        }\n \n-            return Some((result, dep_node_index));\n+        let prev_fingerprint = dep_graph_data.prev_fingerprint_of(prev_dep_node_index);\n+        // If `-Zincremental-verify-ich` is specified, re-hash results from\n+        // the cache and make sure that they have the expected fingerprint.\n+        //\n+        // If not, we still seek to verify a subset of fingerprints loaded\n+        // from disk. Re-hashing results is fairly expensive, so we can't\n+        // currently afford to verify every hash. This subset should still\n+        // give us some coverage of potential bugs though.\n+        let try_verify = prev_fingerprint.split().1.as_u64() % 32 == 0;\n+        if std::intrinsics::unlikely(\n+            try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n+        ) {\n+            incremental_verify_ich(\n+                *qcx.dep_context(),\n+                dep_graph_data,\n+                &result,\n+                prev_dep_node_index,\n+                query.hash_result(),\n+                query.format_value(),\n+            );\n         }\n \n-        // We always expect to find a cached result for things that\n-        // can be forced from `DepNode`.\n-        debug_assert!(\n-            !qcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n-            \"missing on-disk cache entry for reconstructible {dep_node:?}\"\n-        );\n+        return Some((result, dep_node_index));\n     }\n \n+    // We always expect to find a cached result for things that\n+    // can be forced from `DepNode`.\n+    debug_assert!(\n+        !query.cache_on_disk(*qcx.dep_context(), key)\n+            || !qcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n+        \"missing on-disk cache entry for {dep_node:?}\"\n+    );\n+\n     // Sanity check for the logic in `ensure`: if the node is green and the result loadable,\n     // we should actually be able to load it.\n     debug_assert!("}, {"sha": "1f2912359705acde848eb78c9d28048d9c45cca1", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=2fe28ae0a40f280eb85ef948b1dae8aa1be41d7a", "patch": "@@ -135,6 +135,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"expect-test\",\n     \"fallible-iterator\", // dependency of `thorin`\n     \"fastrand\",\n+    \"field-offset\",\n     \"fixedbitset\",\n     \"flate2\",\n     \"fluent-bundle\","}]}