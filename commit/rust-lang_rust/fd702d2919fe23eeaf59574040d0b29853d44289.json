{"sha": "fd702d2919fe23eeaf59574040d0b29853d44289", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNzAyZDI5MTlmZTIzZWVhZjU5NTc0MDQwZDBiMjk4NTNkNDQyODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-19T09:21:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-19T09:21:22Z"}, "message": "Auto merge of #76886 - Aaron1011:fix/ensure-stack-predicate, r=Mark-Simulacrum\n\nWrap recursive predicate evaluation with `ensure_sufficient_stack`\n\nI haven't been able to come up with a minimized test case for #76770,\nbut this fixes a stack overflow in rustc as well.", "tree": {"sha": "49f2d8caa3bc8b3b5e75518f6ddae079560f4b66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49f2d8caa3bc8b3b5e75518f6ddae079560f4b66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd702d2919fe23eeaf59574040d0b29853d44289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd702d2919fe23eeaf59574040d0b29853d44289", "html_url": "https://github.com/rust-lang/rust/commit/fd702d2919fe23eeaf59574040d0b29853d44289", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd702d2919fe23eeaf59574040d0b29853d44289/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e8a8b49ae57233bc196f3529f5184bc208c3034", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8a8b49ae57233bc196f3529f5184bc208c3034", "html_url": "https://github.com/rust-lang/rust/commit/4e8a8b49ae57233bc196f3529f5184bc208c3034"}, {"sha": "6a96aea36ace13ad5b1be8cce0073ee8c2f2f32a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a96aea36ace13ad5b1be8cce0073ee8c2f2f32a", "html_url": "https://github.com/rust-lang/rust/commit/6a96aea36ace13ad5b1be8cce0073ee8c2f2f32a"}], "stats": {"total": 252, "additions": 133, "deletions": 119}, "files": [{"sha": "5e2f7d81d000a871ccb9c55fb6f7d7fdcb337014", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 133, "deletions": 119, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/fd702d2919fe23eeaf59574040d0b29853d44289/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd702d2919fe23eeaf59574040d0b29853d44289/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=fd702d2919fe23eeaf59574040d0b29853d44289", "patch": "@@ -450,153 +450,167 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => self.check_recursion_limit(&obligation, &obligation)?,\n         }\n \n-        match obligation.predicate.skip_binders() {\n-            ty::PredicateAtom::Trait(t, _) => {\n-                let t = ty::Binder::bind(t);\n-                debug_assert!(!t.has_escaping_bound_vars());\n-                let obligation = obligation.with(t);\n-                self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n-            }\n+        ensure_sufficient_stack(|| {\n+            match obligation.predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(t, _) => {\n+                    let t = ty::Binder::bind(t);\n+                    debug_assert!(!t.has_escaping_bound_vars());\n+                    let obligation = obligation.with(t);\n+                    self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n+                }\n+\n+                ty::PredicateAtom::Subtype(p) => {\n+                    let p = ty::Binder::bind(p);\n+                    // Does this code ever run?\n+                    match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n+                        Some(Ok(InferOk { mut obligations, .. })) => {\n+                            self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n+                            self.evaluate_predicates_recursively(\n+                                previous_stack,\n+                                obligations.into_iter(),\n+                            )\n+                        }\n+                        Some(Err(_)) => Ok(EvaluatedToErr),\n+                        None => Ok(EvaluatedToAmbig),\n+                    }\n+                }\n \n-            ty::PredicateAtom::Subtype(p) => {\n-                let p = ty::Binder::bind(p);\n-                // Does this code ever run?\n-                match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n-                    Some(Ok(InferOk { mut obligations, .. })) => {\n+                ty::PredicateAtom::WellFormed(arg) => match wf::obligations(\n+                    self.infcx,\n+                    obligation.param_env,\n+                    obligation.cause.body_id,\n+                    arg,\n+                    obligation.cause.span,\n+                ) {\n+                    Some(mut obligations) => {\n                         self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n                         self.evaluate_predicates_recursively(\n                             previous_stack,\n                             obligations.into_iter(),\n                         )\n                     }\n-                    Some(Err(_)) => Ok(EvaluatedToErr),\n                     None => Ok(EvaluatedToAmbig),\n-                }\n-            }\n+                },\n \n-            ty::PredicateAtom::WellFormed(arg) => match wf::obligations(\n-                self.infcx,\n-                obligation.param_env,\n-                obligation.cause.body_id,\n-                arg,\n-                obligation.cause.span,\n-            ) {\n-                Some(mut obligations) => {\n-                    self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n-                    self.evaluate_predicates_recursively(previous_stack, obligations.into_iter())\n+                ty::PredicateAtom::TypeOutlives(..) | ty::PredicateAtom::RegionOutlives(..) => {\n+                    // We do not consider region relationships when evaluating trait matches.\n+                    Ok(EvaluatedToOkModuloRegions)\n                 }\n-                None => Ok(EvaluatedToAmbig),\n-            },\n-\n-            ty::PredicateAtom::TypeOutlives(..) | ty::PredicateAtom::RegionOutlives(..) => {\n-                // We do not consider region relationships when evaluating trait matches.\n-                Ok(EvaluatedToOkModuloRegions)\n-            }\n \n-            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n-                if self.tcx().is_object_safe(trait_def_id) {\n-                    Ok(EvaluatedToOk)\n-                } else {\n-                    Ok(EvaluatedToErr)\n+                ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                    if self.tcx().is_object_safe(trait_def_id) {\n+                        Ok(EvaluatedToOk)\n+                    } else {\n+                        Ok(EvaluatedToErr)\n+                    }\n                 }\n-            }\n \n-            ty::PredicateAtom::Projection(data) => {\n-                let data = ty::Binder::bind(data);\n-                let project_obligation = obligation.with(data);\n-                match project::poly_project_and_unify_type(self, &project_obligation) {\n-                    Ok(Ok(Some(mut subobligations))) => {\n-                        self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n-                        let result = self.evaluate_predicates_recursively(\n-                            previous_stack,\n-                            subobligations.into_iter(),\n-                        );\n-                        if let Some(key) =\n-                            ProjectionCacheKey::from_poly_projection_predicate(self, data)\n-                        {\n-                            self.infcx.inner.borrow_mut().projection_cache().complete(key);\n+                ty::PredicateAtom::Projection(data) => {\n+                    let data = ty::Binder::bind(data);\n+                    let project_obligation = obligation.with(data);\n+                    match project::poly_project_and_unify_type(self, &project_obligation) {\n+                        Ok(Ok(Some(mut subobligations))) => {\n+                            self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n+                            let result = self.evaluate_predicates_recursively(\n+                                previous_stack,\n+                                subobligations.into_iter(),\n+                            );\n+                            if let Some(key) =\n+                                ProjectionCacheKey::from_poly_projection_predicate(self, data)\n+                            {\n+                                self.infcx.inner.borrow_mut().projection_cache().complete(key);\n+                            }\n+                            result\n                         }\n-                        result\n+                        Ok(Ok(None)) => Ok(EvaluatedToAmbig),\n+                        // EvaluatedToRecur might also be acceptable here, but use\n+                        // Unknown for now because it means that we won't dismiss a\n+                        // selection candidate solely because it has a projection\n+                        // cycle. This is closest to the previous behavior of\n+                        // immediately erroring.\n+                        Ok(Err(project::InProgress)) => Ok(EvaluatedToUnknown),\n+                        Err(_) => Ok(EvaluatedToErr),\n                     }\n-                    Ok(Ok(None)) => Ok(EvaluatedToAmbig),\n-                    // EvaluatedToRecur might also be acceptable here, but use\n-                    // Unknown for now because it means that we won't dismiss a\n-                    // selection candidate solely because it has a projection\n-                    // cycle. This is closest to the previous behavior of\n-                    // immediately erroring.\n-                    Ok(Err(project::InProgress)) => Ok(EvaluatedToUnknown),\n-                    Err(_) => Ok(EvaluatedToErr),\n                 }\n-            }\n \n-            ty::PredicateAtom::ClosureKind(_, closure_substs, kind) => {\n-                match self.infcx.closure_kind(closure_substs) {\n-                    Some(closure_kind) => {\n-                        if closure_kind.extends(kind) {\n-                            Ok(EvaluatedToOk)\n-                        } else {\n-                            Ok(EvaluatedToErr)\n+                ty::PredicateAtom::ClosureKind(_, closure_substs, kind) => {\n+                    match self.infcx.closure_kind(closure_substs) {\n+                        Some(closure_kind) => {\n+                            if closure_kind.extends(kind) {\n+                                Ok(EvaluatedToOk)\n+                            } else {\n+                                Ok(EvaluatedToErr)\n+                            }\n                         }\n+                        None => Ok(EvaluatedToAmbig),\n                     }\n-                    None => Ok(EvaluatedToAmbig),\n                 }\n-            }\n \n-            ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n-                match const_evaluatable::is_const_evaluatable(\n-                    self.infcx,\n-                    def_id,\n-                    substs,\n-                    obligation.param_env,\n-                    obligation.cause.span,\n-                ) {\n-                    Ok(()) => Ok(EvaluatedToOk),\n-                    Err(ErrorHandled::TooGeneric) => Ok(EvaluatedToAmbig),\n-                    Err(_) => Ok(EvaluatedToErr),\n+                ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n+                    match const_evaluatable::is_const_evaluatable(\n+                        self.infcx,\n+                        def_id,\n+                        substs,\n+                        obligation.param_env,\n+                        obligation.cause.span,\n+                    ) {\n+                        Ok(()) => Ok(EvaluatedToOk),\n+                        Err(ErrorHandled::TooGeneric) => Ok(EvaluatedToAmbig),\n+                        Err(_) => Ok(EvaluatedToErr),\n+                    }\n                 }\n-            }\n \n-            ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                debug!(\"evaluate_predicate_recursively: equating consts c1={:?} c2={:?}\", c1, c2);\n-\n-                let evaluate = |c: &'tcx ty::Const<'tcx>| {\n-                    if let ty::ConstKind::Unevaluated(def, substs, promoted) = c.val {\n-                        self.infcx\n-                            .const_eval_resolve(\n-                                obligation.param_env,\n-                                def,\n-                                substs,\n-                                promoted,\n-                                Some(obligation.cause.span),\n-                            )\n-                            .map(|val| ty::Const::from_value(self.tcx(), val, c.ty))\n-                    } else {\n-                        Ok(c)\n-                    }\n-                };\n+                ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                    debug!(\n+                        \"evaluate_predicate_recursively: equating consts c1={:?} c2={:?}\",\n+                        c1, c2\n+                    );\n \n-                match (evaluate(c1), evaluate(c2)) {\n-                    (Ok(c1), Ok(c2)) => {\n-                        match self.infcx().at(&obligation.cause, obligation.param_env).eq(c1, c2) {\n-                            Ok(_) => Ok(EvaluatedToOk),\n-                            Err(_) => Ok(EvaluatedToErr),\n+                    let evaluate = |c: &'tcx ty::Const<'tcx>| {\n+                        if let ty::ConstKind::Unevaluated(def, substs, promoted) = c.val {\n+                            self.infcx\n+                                .const_eval_resolve(\n+                                    obligation.param_env,\n+                                    def,\n+                                    substs,\n+                                    promoted,\n+                                    Some(obligation.cause.span),\n+                                )\n+                                .map(|val| ty::Const::from_value(self.tcx(), val, c.ty))\n+                        } else {\n+                            Ok(c)\n+                        }\n+                    };\n+\n+                    match (evaluate(c1), evaluate(c2)) {\n+                        (Ok(c1), Ok(c2)) => {\n+                            match self\n+                                .infcx()\n+                                .at(&obligation.cause, obligation.param_env)\n+                                .eq(c1, c2)\n+                            {\n+                                Ok(_) => Ok(EvaluatedToOk),\n+                                Err(_) => Ok(EvaluatedToErr),\n+                            }\n+                        }\n+                        (Err(ErrorHandled::Reported(ErrorReported)), _)\n+                        | (_, Err(ErrorHandled::Reported(ErrorReported))) => Ok(EvaluatedToErr),\n+                        (Err(ErrorHandled::Linted), _) | (_, Err(ErrorHandled::Linted)) => {\n+                            span_bug!(\n+                                obligation.cause.span(self.tcx()),\n+                                \"ConstEquate: const_eval_resolve returned an unexpected error\"\n+                            )\n+                        }\n+                        (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n+                            Ok(EvaluatedToAmbig)\n                         }\n-                    }\n-                    (Err(ErrorHandled::Reported(ErrorReported)), _)\n-                    | (_, Err(ErrorHandled::Reported(ErrorReported))) => Ok(EvaluatedToErr),\n-                    (Err(ErrorHandled::Linted), _) | (_, Err(ErrorHandled::Linted)) => span_bug!(\n-                        obligation.cause.span(self.tcx()),\n-                        \"ConstEquate: const_eval_resolve returned an unexpected error\"\n-                    ),\n-                    (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n-                        Ok(EvaluatedToAmbig)\n                     }\n                 }\n+                ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n+                }\n             }\n-            ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n-                bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n-            }\n-        }\n+        })\n     }\n \n     fn evaluate_trait_predicate_recursively<'o>("}]}