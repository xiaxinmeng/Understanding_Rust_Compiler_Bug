{"sha": "cada16f5e058d61a1ac8b3d75773c0d25658a55e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZGExNmY1ZTA1OGQ2MWExYWM4YjNkNzU3NzNjMGQyNTY1OGE1NWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-13T11:23:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-13T11:23:43Z"}, "message": "Merge #10221\n\n10221: internal: prevent possible bugs when adding magical comments r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "8c629a0147d15d8c68bd4797fc8ea1cce183ef26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c629a0147d15d8c68bd4797fc8ea1cce183ef26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cada16f5e058d61a1ac8b3d75773c0d25658a55e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhPzS/CRBK7hj4Ov3rIwAAW4IIADAkWUdhtlmYW+CLCXE0UYJq\nghFGV/yfo3h7MPrsFHC/bSnNaFe6TK42cP6ohEcoX9wY0NmOfHfJn0CUmEI208J/\n8mNLkkrqEfsg7VYSgsXrrle5hDHkSVZn1UG07sNexfQPBjhUmsxo/33JKCNZq5/r\nzuNioL1LP05E6jJ04B/1aDb02lCgSz2wfi2GK7qbB6Csuw+x2rfr9WIqxMYNq2U4\n7tv9GxcrY03fdzst9lr1fbIadWmscRaZZ/zEniRJXEa6/jrppdYQnygpdPWZmSyO\nXQySU5GYwnVqkgXAzlRnUfXCxQ1ikvWprt6BLW3rO8r9nAzdhHOhE2joMgnLtcw=\n=gj6S\n-----END PGP SIGNATURE-----\n", "payload": "tree 8c629a0147d15d8c68bd4797fc8ea1cce183ef26\nparent c45792ae8f1e39aba86d2999482ee9f1a7c6e4a5\nparent 46cdde75f83a18a97c32dadebfdec0a54c3be7c1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631532223 +0000\ncommitter GitHub <noreply@github.com> 1631532223 +0000\n\nMerge #10221\n\n10221: internal: prevent possible bugs when adding magical comments r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cada16f5e058d61a1ac8b3d75773c0d25658a55e", "html_url": "https://github.com/rust-lang/rust/commit/cada16f5e058d61a1ac8b3d75773c0d25658a55e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cada16f5e058d61a1ac8b3d75773c0d25658a55e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c45792ae8f1e39aba86d2999482ee9f1a7c6e4a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c45792ae8f1e39aba86d2999482ee9f1a7c6e4a5", "html_url": "https://github.com/rust-lang/rust/commit/c45792ae8f1e39aba86d2999482ee9f1a7c6e4a5"}, {"sha": "46cdde75f83a18a97c32dadebfdec0a54c3be7c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/46cdde75f83a18a97c32dadebfdec0a54c3be7c1", "html_url": "https://github.com/rust-lang/rust/commit/46cdde75f83a18a97c32dadebfdec0a54c3be7c1"}], "stats": {"total": 536, "additions": 368, "deletions": 168}, "files": [{"sha": "472aef26480bd3c31d061b6424738994118f6e3f", "filename": "crates/ide_assists/src/handlers/convert_comment_block.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -6,21 +6,21 @@ use syntax::{\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n-/// Assist: line_to_block\n-///\n-/// Converts comments between block and single-line form\n-///\n-/// ```\n-///    // Multi-line\n-///    // comment\n-/// ```\n-/// ->\n-/// ```\n-///   /**\n-///   Multi-line\n-///   comment\n-///   */\n-/// ```\n+// Assist: line_to_block\n+//\n+// Converts comments between block and single-line form.\n+//\n+// ```\n+//    // Multi-line$0\n+//    // comment\n+// ```\n+// ->\n+// ```\n+//   /*\n+//   Multi-line\n+//   comment\n+//   */\n+// ```\n pub(crate) fn convert_comment_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let comment = ctx.find_token_at_offset::<ast::Comment>()?;\n     // Only allow comments which are alone on their line"}, {"sha": "b4fb5c190f7bdd120a399d59c61e3a1bdacbbe25", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -1,10 +1,63 @@\n-//! `assists` crate provides a bunch of code assists, also known as code\n-//! actions (in LSP) or intentions (in IntelliJ).\n+//! `assists` crate provides a bunch of code assists, also known as code actions\n+//! (in LSP) or intentions (in IntelliJ).\n //!\n //! An assist is a micro-refactoring, which is automatically activated in\n //! certain context. For example, if the cursor is over `,`, a \"swap `,`\" assist\n //! becomes available.\n-\n+//!\n+//! ## Assists Guidelines\n+//!\n+//! Assists are the main mechanism to deliver advanced IDE features to the user,\n+//! so we should pay extra attention to the UX.\n+//!\n+//! The power of assists comes from their context-awareness. The main problem\n+//! with IDE features is that there are a lot of them, and it's hard to teach\n+//! the user what's available. Assists solve this problem nicely: \ud83d\udca1 signifies\n+//! that *something* is possible, and clicking on it reveals a *short* list of\n+//! actions. Contrast it with Emacs `M-x`, which just spits an infinite list of\n+//! all the features.\n+//!\n+//! Here are some considerations when creating a new assist:\n+//!\n+//! * It's good to preserve semantics, and it's good to keep the code compiling,\n+//!   but it isn't necessary. Example: \"flip binary operation\" might change\n+//!   semantics.\n+//! * Assist shouldn't necessary make the code \"better\". A lot of assist come in\n+//!   pairs: \"if let <-> match\".\n+//! * Assists should have as narrow scope as possible. Each new assists greatly\n+//!   improves UX for cases where the user actually invokes it, but it makes UX\n+//!   worse for every case where the user clicks \ud83d\udca1 to invoke some *other*\n+//!   assist. So, a rarely useful assist which is always applicable can be a net\n+//!   negative.\n+//! * Rarely useful actions are tricky. Sometimes there are features which are\n+//!   clearly useful to some users, but are just noise most of the time. We\n+//!   don't have a good solution here, our current approach is to make this\n+//!   functionality available only if assist is applicable to the whole\n+//!   selection. Example: `sort_items` sorts items alphabetically. Naively, it\n+//!   should be available more or less everywhere, which isn't useful. So\n+//!   instead we only show it if the user *selects* the items they want to sort.\n+//! * Consider grouping related assists together (see [`Assists::add_group`]).\n+//! * Make assists robust. If the assist depends on results of type-inference to\n+//!   much, it might only fire in fully-correct code. This makes assist less\n+//!   useful and (worse) less predictable. The user should have a clear\n+//!   intuition when each particular assist is available.\n+//! * Make small assists, which compose. Example: rather than auto-importing\n+//!   enums in `fill_match_arms`, we use fully-qualified names. There's a\n+//!   separate assist to shorten a fully-qualified name.\n+//! * Distinguish between assists and fixits for diagnostics. Internally, fixits\n+//!   and assists are equivalent. They have the same \"show a list + invoke a\n+//!   single element\" workflow, and both use [`Assist`] data structure. The main\n+//!   difference is in the UX: while \ud83d\udca1 looks only at the cursor position,\n+//!   diagnostics squigglies and fixits are calculated for the whole file and\n+//!   are presented to the user eagerly. So, diagnostics should be fixable\n+//!   errors, while assists can be just suggestions for an alternative way to do\n+//!   something. If something *could* be a diagnostic, it should be a\n+//!   diagnostic. Conversely, it might be valuable to turn a diagnostic with a\n+//!   lot of false errors into an assist.\n+//! *\n+//!\n+//! See also this post:\n+//! <https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html>\n #[allow(unused)]\n macro_rules! eprintln {\n     ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n@@ -28,6 +81,9 @@ pub use ide_db::assists::{\n };\n \n /// Return all the assists applicable at the given position.\n+///\n+// NOTE: We don't have a `Feature: ` section for assists, they are special-cased\n+// in the manual.\n pub fn assists(\n     db: &RootDatabase,\n     config: &AssistConfig,"}, {"sha": "46dd409409bc3f0dbe6c91befe24c131d0c8f5a7", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -1064,6 +1064,23 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_line_to_block() {\n+    check_doc_test(\n+        \"line_to_block\",\n+        r#####\"\n+   // Multi-line$0\n+   // comment\n+\"#####,\n+        r#####\"\n+  /*\n+  Multi-line\n+  comment\n+  */\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_make_raw_string() {\n     check_doc_test("}, {"sha": "9e6d26640e7eeac748f64fb3e5261a7847c3b3f2", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -1,95 +1,4 @@\n-//! Feature: completion with imports-on-the-fly\n-//!\n-//! When completing names in the current scope, proposes additional imports from other modules or crates,\n-//! if they can be qualified in the scope, and their name contains all symbols from the completion input.\n-//!\n-//! To be considered applicable, the name must contain all input symbols in the given order, not necessarily adjacent.\n-//! If any input symbol is not lowercased, the name must contain all symbols in exact case; otherwise the containing is checked case-insensitively.\n-//!\n-//! ```\n-//! fn main() {\n-//!     pda$0\n-//! }\n-//! # pub mod std { pub mod marker { pub struct PhantomData { } } }\n-//! ```\n-//! ->\n-//! ```\n-//! use std::marker::PhantomData;\n-//!\n-//! fn main() {\n-//!     PhantomData\n-//! }\n-//! # pub mod std { pub mod marker { pub struct PhantomData { } } }\n-//! ```\n-//!\n-//! Also completes associated items, that require trait imports.\n-//! If any unresolved and/or partially-qualified path precedes the input, it will be taken into account.\n-//! Currently, only the imports with their import path ending with the whole qualifier will be proposed\n-//! (no fuzzy matching for qualifier).\n-//!\n-//! ```\n-//! mod foo {\n-//!     pub mod bar {\n-//!         pub struct Item;\n-//!\n-//!         impl Item {\n-//!             pub const TEST_ASSOC: usize = 3;\n-//!         }\n-//!     }\n-//! }\n-//!\n-//! fn main() {\n-//!     bar::Item::TEST_A$0\n-//! }\n-//! ```\n-//! ->\n-//! ```\n-//! use foo::bar;\n-//!\n-//! mod foo {\n-//!     pub mod bar {\n-//!         pub struct Item;\n-//!\n-//!         impl Item {\n-//!             pub const TEST_ASSOC: usize = 3;\n-//!         }\n-//!     }\n-//! }\n-//!\n-//! fn main() {\n-//!     bar::Item::TEST_ASSOC\n-//! }\n-//! ```\n-//!\n-//! NOTE: currently, if an assoc item comes from a trait that's not currently imported, and it also has an unresolved and/or partially-qualified path,\n-//! no imports will be proposed.\n-//!\n-//! .Fuzzy search details\n-//!\n-//! To avoid an excessive amount of the results returned, completion input is checked for inclusion in the names only\n-//! (i.e. in `HashMap` in the `std::collections::HashMap` path).\n-//! For the same reasons, avoids searching for any path imports for inputs with their length less than 2 symbols\n-//! (but shows all associated items for any input length).\n-//!\n-//! .Import configuration\n-//!\n-//! It is possible to configure how use-trees are merged with the `importMergeBehavior` setting.\n-//! Mimics the corresponding behavior of the `Auto Import` feature.\n-//!\n-//! .LSP and performance implications\n-//!\n-//! The feature is enabled only if the LSP client supports LSP protocol version 3.16+ and reports the `additionalTextEdits`\n-//! (case-sensitive) resolve client capability in its client capabilities.\n-//! This way the server is able to defer the costly computations, doing them for a selected completion item only.\n-//! For clients with no such support, all edits have to be calculated on the completion request, including the fuzzy search completion ones,\n-//! which might be slow ergo the feature is automatically disabled.\n-//!\n-//! .Feature toggle\n-//!\n-//! The feature can be forcefully turned off in the settings with the `rust-analyzer.completion.autoimport.enable` flag.\n-//! Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corresponding\n-//! capability enabled.\n-\n+//! See [`import_on_the_fly`].\n use ide_db::helpers::{\n     import_assets::{ImportAssets, ImportCandidate},\n     insert_use::ImportScope,\n@@ -105,6 +14,97 @@ use crate::{\n \n use super::Completions;\n \n+// Feature: Completion With Autoimport\n+//\n+// When completing names in the current scope, proposes additional imports from other modules or crates,\n+// if they can be qualified in the scope, and their name contains all symbols from the completion input.\n+//\n+// To be considered applicable, the name must contain all input symbols in the given order, not necessarily adjacent.\n+// If any input symbol is not lowercased, the name must contain all symbols in exact case; otherwise the containing is checked case-insensitively.\n+//\n+// ```\n+// fn main() {\n+//     pda$0\n+// }\n+// # pub mod std { pub mod marker { pub struct PhantomData { } } }\n+// ```\n+// ->\n+// ```\n+// use std::marker::PhantomData;\n+//\n+// fn main() {\n+//     PhantomData\n+// }\n+// # pub mod std { pub mod marker { pub struct PhantomData { } } }\n+// ```\n+//\n+// Also completes associated items, that require trait imports.\n+// If any unresolved and/or partially-qualified path precedes the input, it will be taken into account.\n+// Currently, only the imports with their import path ending with the whole qualifier will be proposed\n+// (no fuzzy matching for qualifier).\n+//\n+// ```\n+// mod foo {\n+//     pub mod bar {\n+//         pub struct Item;\n+//\n+//         impl Item {\n+//             pub const TEST_ASSOC: usize = 3;\n+//         }\n+//     }\n+// }\n+//\n+// fn main() {\n+//     bar::Item::TEST_A$0\n+// }\n+// ```\n+// ->\n+// ```\n+// use foo::bar;\n+//\n+// mod foo {\n+//     pub mod bar {\n+//         pub struct Item;\n+//\n+//         impl Item {\n+//             pub const TEST_ASSOC: usize = 3;\n+//         }\n+//     }\n+// }\n+//\n+// fn main() {\n+//     bar::Item::TEST_ASSOC\n+// }\n+// ```\n+//\n+// NOTE: currently, if an assoc item comes from a trait that's not currently imported, and it also has an unresolved and/or partially-qualified path,\n+// no imports will be proposed.\n+//\n+// .Fuzzy search details\n+//\n+// To avoid an excessive amount of the results returned, completion input is checked for inclusion in the names only\n+// (i.e. in `HashMap` in the `std::collections::HashMap` path).\n+// For the same reasons, avoids searching for any path imports for inputs with their length less than 2 symbols\n+// (but shows all associated items for any input length).\n+//\n+// .Import configuration\n+//\n+// It is possible to configure how use-trees are merged with the `importMergeBehavior` setting.\n+// Mimics the corresponding behavior of the `Auto Import` feature.\n+//\n+// .LSP and performance implications\n+//\n+// The feature is enabled only if the LSP client supports LSP protocol version 3.16+ and reports the `additionalTextEdits`\n+// (case-sensitive) resolve client capability in its client capabilities.\n+// This way the server is able to defer the costly computations, doing them for a selected completion item only.\n+// For clients with no such support, all edits have to be calculated on the completion request, including the fuzzy search completion ones,\n+// which might be slow ergo the feature is automatically disabled.\n+//\n+// .Feature toggle\n+//\n+// The feature can be forcefully turned off in the settings with the `rust-analyzer.completion.autoimport.enable` flag.\n+// Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corresponding\n+// capability enabled.\n pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n     if !ctx.config.enable_imports_on_the_fly {\n         return None;"}, {"sha": "28da6d69c8c906721f794889ddbba92ba96d58fc", "filename": "crates/ide_completion/src/completions/fn_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -1,4 +1,4 @@\n-//! See `complete_fn_param`.\n+//! See [`complete_fn_param`].\n \n use rustc_hash::FxHashMap;\n use syntax::{"}, {"sha": "7243b895836c0ef74e907ba149878d79a10fefb4", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -194,10 +194,12 @@ fn opt_visibility(p: &mut Parser) -> bool {\n         // crate fn main() { }\n         // struct S { crate field: u32 }\n         // struct T(crate u32);\n-        //\n-        // test crate_keyword_path\n-        // fn foo() { crate::foo(); }\n-        T![crate] if !p.nth_at(1, T![::]) => {\n+        T![crate] => {\n+            if p.nth_at(1, T![::]) {\n+                // test crate_keyword_path\n+                // fn foo() { crate::foo(); }\n+                return false;\n+            }\n             let m = p.start();\n             p.bump(T![crate]);\n             m.complete(p, VISIBILITY);"}, {"sha": "001be099e6ef3e1b55b22b9020488802224e542a", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -374,7 +374,6 @@ fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)>\n             //    let mut p = F{x: 5};\n             //    {p}.x = 10;\n             // }\n-            //\n             let (lhs, blocklike) = atom::atom_expr(p, r)?;\n             return Some(postfix_expr(p, lhs, blocklike, !(r.prefer_stmt && blocklike.is_block())));\n         }"}, {"sha": "81e2051abb58134638954dd0cb8909b404ce3d0e", "filename": "crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -17,7 +17,7 @@ pub(crate) fn pattern(p: &mut Parser) {\n     pattern_r(p, PAT_RECOVERY_SET);\n }\n \n-/// Parses a pattern list separated by pipes `|`\n+/// Parses a pattern list separated by pipes `|`.\n pub(super) fn pattern_top(p: &mut Parser) {\n     pattern_top_r(p, PAT_RECOVERY_SET)\n }\n@@ -27,14 +27,15 @@ pub(crate) fn pattern_single(p: &mut Parser) {\n }\n \n /// Parses a pattern list separated by pipes `|`\n-/// using the given `recovery_set`\n+/// using the given `recovery_set`.\n pub(super) fn pattern_top_r(p: &mut Parser, recovery_set: TokenSet) {\n     p.eat(T![|]);\n     pattern_r(p, recovery_set);\n }\n \n /// Parses a pattern list separated by pipes `|`, with no leading `|`,using the\n-/// given `recovery_set`\n+/// given `recovery_set`.\n+\n // test or_pattern\n // fn main() {\n //     match () {"}, {"sha": "6a332bce85d84110b7b312947e6deaed0bc9ead4", "filename": "crates/sourcegen/src/lib.rs", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsourcegen%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsourcegen%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsourcegen%2Fsrc%2Flib.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -43,70 +43,73 @@ pub fn list_files(dir: &Path) -> Vec<PathBuf> {\n     res\n }\n \n+#[derive(Clone)]\n pub struct CommentBlock {\n     pub id: String,\n     pub line: usize,\n     pub contents: Vec<String>,\n+    is_doc: bool,\n }\n \n impl CommentBlock {\n     pub fn extract(tag: &str, text: &str) -> Vec<CommentBlock> {\n         assert!(tag.starts_with(char::is_uppercase));\n \n         let tag = format!(\"{}:\", tag);\n-        let mut res = Vec::new();\n-        for (line, mut block) in do_extract_comment_blocks(text, true) {\n-            let first = block.remove(0);\n-            if let Some(id) = first.strip_prefix(&tag) {\n-                let id = id.trim().to_string();\n-                let block = CommentBlock { id, line, contents: block };\n-                res.push(block);\n-            }\n-        }\n-        res\n+        // Would be nice if we had `.retain_mut` here!\n+        CommentBlock::extract_untagged(text)\n+            .into_iter()\n+            .filter_map(|mut block| {\n+                let first = block.contents.remove(0);\n+                first.strip_prefix(&tag).map(|id| {\n+                    if block.is_doc {\n+                        panic!(\n+                            \"Use plain (non-doc) comments with tags like {}:\\n    {}\",\n+                            tag, first\n+                        )\n+                    }\n+\n+                    block.id = id.trim().to_string();\n+                    block\n+                })\n+            })\n+            .collect()\n     }\n \n     pub fn extract_untagged(text: &str) -> Vec<CommentBlock> {\n         let mut res = Vec::new();\n-        for (line, block) in do_extract_comment_blocks(text, false) {\n-            let id = String::new();\n-            let block = CommentBlock { id, line, contents: block };\n-            res.push(block);\n-        }\n-        res\n-    }\n-}\n-\n-fn do_extract_comment_blocks(\n-    text: &str,\n-    allow_blocks_with_empty_lines: bool,\n-) -> Vec<(usize, Vec<String>)> {\n-    let mut res = Vec::new();\n \n-    let prefix = \"// \";\n-    let lines = text.lines().map(str::trim_start);\n-\n-    let mut block = (0, vec![]);\n-    for (line_num, line) in lines.enumerate() {\n-        if line == \"//\" && allow_blocks_with_empty_lines {\n-            block.1.push(String::new());\n-            continue;\n-        }\n-\n-        let is_comment = line.starts_with(prefix);\n-        if is_comment {\n-            block.1.push(line[prefix.len()..].to_string());\n-        } else {\n-            if !block.1.is_empty() {\n-                res.push(mem::take(&mut block));\n+        let lines = text.lines().map(str::trim_start);\n+\n+        let dummy_block =\n+            CommentBlock { id: String::new(), line: 0, contents: Vec::new(), is_doc: false };\n+        let mut block = dummy_block.clone();\n+        for (line_num, line) in lines.enumerate() {\n+            match line.strip_prefix(\"//\") {\n+                Some(mut contents) => {\n+                    if let Some('/' | '!') = contents.chars().next() {\n+                        contents = &contents[1..];\n+                        block.is_doc = true;\n+                    }\n+                    if let Some(' ') = contents.chars().next() {\n+                        contents = &contents[1..];\n+                    }\n+                    block.contents.push(contents.to_string());\n+                }\n+                None => {\n+                    if !block.contents.is_empty() {\n+                        let block = mem::replace(&mut block, dummy_block.clone());\n+                        res.push(block);\n+                    }\n+                    block.line = line_num + 2;\n+                }\n             }\n-            block.0 = line_num + 2;\n         }\n+        if !block.contents.is_empty() {\n+            res.push(block)\n+        }\n+        res\n     }\n-    if !block.1.is_empty() {\n-        res.push(block)\n-    }\n-    res\n }\n \n #[derive(Debug)]"}, {"sha": "ac51eb91d20ace1cae5c5bb9f173e73cacda99aa", "filename": "crates/syntax/test_data/parser/inline/ok/0110_use_path.rast", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0110_use_path.rast", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0110_use_path.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0110_use_path.rast?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -1,4 +1,4 @@\n-SOURCE_FILE@0..154\n+SOURCE_FILE@0..247\n   USE@0..17\n     USE_KW@0..3 \"use\"\n     WHITESPACE@3..4 \" \"\n@@ -35,4 +35,74 @@ SOURCE_FILE@0..154\n     SEMICOLON@123..124 \";\"\n   WHITESPACE@124..125 \" \"\n   COMMENT@125..153 \"// Rust 2018 - Unifor ...\"\n-  WHITESPACE@153..154 \"\\n\"\n+  WHITESPACE@153..155 \"\\n\\n\"\n+  USE@155..178\n+    USE_KW@155..158 \"use\"\n+    WHITESPACE@158..159 \" \"\n+    USE_TREE@159..177\n+      PATH@159..177\n+        PATH@159..171\n+          PATH@159..163\n+            PATH_SEGMENT@159..163\n+              NAME_REF@159..163\n+                SELF_KW@159..163 \"self\"\n+          COLON2@163..165 \"::\"\n+          PATH_SEGMENT@165..171\n+            NAME_REF@165..171\n+              IDENT@165..171 \"module\"\n+        COLON2@171..173 \"::\"\n+        PATH_SEGMENT@173..177\n+          NAME_REF@173..177\n+            IDENT@173..177 \"Item\"\n+    SEMICOLON@177..178 \";\"\n+  WHITESPACE@178..179 \"\\n\"\n+  USE@179..195\n+    USE_KW@179..182 \"use\"\n+    WHITESPACE@182..183 \" \"\n+    USE_TREE@183..194\n+      PATH@183..194\n+        PATH@183..188\n+          PATH_SEGMENT@183..188\n+            NAME_REF@183..188\n+              CRATE_KW@183..188 \"crate\"\n+        COLON2@188..190 \"::\"\n+        PATH_SEGMENT@190..194\n+          NAME_REF@190..194\n+            IDENT@190..194 \"Item\"\n+    SEMICOLON@194..195 \";\"\n+  WHITESPACE@195..196 \"\\n\"\n+  USE@196..219\n+    USE_KW@196..199 \"use\"\n+    WHITESPACE@199..200 \" \"\n+    USE_TREE@200..218\n+      PATH@200..218\n+        PATH@200..210\n+          PATH@200..204\n+            PATH_SEGMENT@200..204\n+              NAME_REF@200..204\n+                SELF_KW@200..204 \"self\"\n+          COLON2@204..206 \"::\"\n+          PATH_SEGMENT@206..210\n+            NAME_REF@206..210\n+              IDENT@206..210 \"some\"\n+        COLON2@210..212 \"::\"\n+        PATH_SEGMENT@212..218\n+          NAME_REF@212..218\n+            IDENT@212..218 \"Struct\"\n+    SEMICOLON@218..219 \";\"\n+  WHITESPACE@219..220 \"\\n\"\n+  USE@220..246\n+    USE_KW@220..223 \"use\"\n+    WHITESPACE@223..224 \" \"\n+    USE_TREE@224..245\n+      PATH@224..245\n+        PATH@224..234\n+          PATH_SEGMENT@224..234\n+            NAME_REF@224..234\n+              IDENT@224..234 \"crate_name\"\n+        COLON2@234..236 \"::\"\n+        PATH_SEGMENT@236..245\n+          NAME_REF@236..245\n+            IDENT@236..245 \"some_item\"\n+    SEMICOLON@245..246 \";\"\n+  WHITESPACE@246..247 \"\\n\""}, {"sha": "1e436a6bc2b4e2441aa4f41b834e201d33386d2b", "filename": "crates/syntax/test_data/parser/inline/ok/0110_use_path.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0110_use_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0110_use_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0110_use_path.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -1,3 +1,8 @@\n use ::crate_name; // Rust 2018 - All flavours\n use crate_name; // Rust 2018 - Anchored paths\n use item_in_scope_or_crate_name; // Rust 2018 - Uniform Paths\n+\n+use self::module::Item;\n+use crate::Item;\n+use self::some::Struct;\n+use crate_name::some_item;"}, {"sha": "533f738e1553e96c7d4c5b42ddab060f3cfbf1cc", "filename": "crates/syntax/test_data/parser/inline/ok/0115_tuple_field_attrs.rast", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0115_tuple_field_attrs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0115_tuple_field_attrs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0115_tuple_field_attrs.rast?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -1,4 +1,4 @@\n-SOURCE_FILE@0..60\n+SOURCE_FILE@0..115\n   STRUCT@0..59\n     STRUCT_KW@0..6 \"struct\"\n     WHITESPACE@6..7 \" \"\n@@ -39,4 +39,47 @@ SOURCE_FILE@0..60\n       WHITESPACE@56..57 \"\\n\"\n       R_PAREN@57..58 \")\"\n     SEMICOLON@58..59 \";\"\n-  WHITESPACE@59..60 \"\\n\"\n+  WHITESPACE@59..61 \"\\n\\n\"\n+  ENUM@61..114\n+    ENUM_KW@61..65 \"enum\"\n+    WHITESPACE@65..66 \" \"\n+    NAME@66..67\n+      IDENT@66..67 \"S\"\n+    WHITESPACE@67..68 \" \"\n+    VARIANT_LIST@68..114\n+      L_CURLY@68..69 \"{\"\n+      WHITESPACE@69..74 \"\\n    \"\n+      VARIANT@74..111\n+        NAME@74..77\n+          IDENT@74..77 \"Uri\"\n+        TUPLE_FIELD_LIST@77..111\n+          L_PAREN@77..78 \"(\"\n+          TUPLE_FIELD@78..110\n+            ATTR@78..106\n+              POUND@78..79 \"#\"\n+              L_BRACK@79..80 \"[\"\n+              META@80..105\n+                PATH@80..85\n+                  PATH_SEGMENT@80..85\n+                    NAME_REF@80..85\n+                      IDENT@80..85 \"serde\"\n+                TOKEN_TREE@85..105\n+                  L_PAREN@85..86 \"(\"\n+                  IDENT@86..90 \"with\"\n+                  WHITESPACE@90..91 \" \"\n+                  EQ@91..92 \"=\"\n+                  WHITESPACE@92..93 \" \"\n+                  STRING@93..104 \"\\\"url_serde\\\"\"\n+                  R_PAREN@104..105 \")\"\n+              R_BRACK@105..106 \"]\"\n+            WHITESPACE@106..107 \" \"\n+            PATH_TYPE@107..110\n+              PATH@107..110\n+                PATH_SEGMENT@107..110\n+                  NAME_REF@107..110\n+                    IDENT@107..110 \"Uri\"\n+          R_PAREN@110..111 \")\"\n+      COMMA@111..112 \",\"\n+      WHITESPACE@112..113 \"\\n\"\n+      R_CURLY@113..114 \"}\"\n+  WHITESPACE@114..115 \"\\n\""}, {"sha": "4da379d0ed0b55783df686eda186d6b145178e7f", "filename": "crates/syntax/test_data/parser/inline/ok/0115_tuple_field_attrs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0115_tuple_field_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cada16f5e058d61a1ac8b3d75773c0d25658a55e/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0115_tuple_field_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0115_tuple_field_attrs.rs?ref=cada16f5e058d61a1ac8b3d75773c0d25658a55e", "patch": "@@ -2,3 +2,7 @@ struct S (\n     #[serde(with = \"url_serde\")]\n     pub Uri,\n );\n+\n+enum S {\n+    Uri(#[serde(with = \"url_serde\")] Uri),\n+}"}]}