{"sha": "a4635a199bc446bd103aa5821e57dc19b8a15751", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NjM1YTE5OWJjNDQ2YmQxMDNhYTU4MjFlNTdkYzE5YjhhMTU3NTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-03T15:59:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-03T15:59:17Z"}, "message": "more enterprisey assists API", "tree": {"sha": "5dcdd940d8627f021062245cb79589a790b60e04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dcdd940d8627f021062245cb79589a790b60e04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4635a199bc446bd103aa5821e57dc19b8a15751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4635a199bc446bd103aa5821e57dc19b8a15751", "html_url": "https://github.com/rust-lang/rust/commit/a4635a199bc446bd103aa5821e57dc19b8a15751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4635a199bc446bd103aa5821e57dc19b8a15751/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aea2183799e7975d3d9000cec9bb9a3c001a3d4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/aea2183799e7975d3d9000cec9bb9a3c001a3d4e", "html_url": "https://github.com/rust-lang/rust/commit/aea2183799e7975d3d9000cec9bb9a3c001a3d4e"}], "stats": {"total": 497, "additions": 287, "deletions": 210}, "files": [{"sha": "771dad47555b9b3dbafcb24276ad46b2ebc8db7f", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -333,19 +333,9 @@ impl db::RootDatabase {\n \n     pub(crate) fn assists(&self, frange: FileRange) -> Vec<SourceChange> {\n         let file = self.source_file(frange.file_id);\n-        let offset = frange.range.start();\n-        let actions = vec![\n-            assists::flip_comma(&file, offset).map(|f| f()),\n-            assists::add_derive(&file, offset).map(|f| f()),\n-            assists::add_impl(&file, offset).map(|f| f()),\n-            assists::change_visibility(&file, offset).map(|f| f()),\n-            assists::introduce_variable(&file, frange.range).map(|f| f()),\n-        ];\n-        actions\n+        assists::assists(&file, frange.range)\n             .into_iter()\n-            .filter_map(|local_edit| {\n-                Some(SourceChange::from_local_edit(frange.file_id, local_edit?))\n-            })\n+            .map(|local_edit| SourceChange::from_local_edit(frange.file_id, local_edit))\n             .collect()\n     }\n \n@@ -440,7 +430,7 @@ impl db::RootDatabase {\n             .map(|(file_id, text_range)| SourceFileEdit {\n                 file_id: *file_id,\n                 edit: {\n-                    let mut builder = ra_text_edit::TextEditBuilder::new();\n+                    let mut builder = ra_text_edit::TextEditBuilder::default();\n                     builder.replace(*text_range, new_name.into());\n                     builder.finish()\n                 },"}, {"sha": "cc40ee4c8ff90adbef969a95f3636a58162fdf0a", "filename": "crates/ra_editor/src/assists.rs", "status": "modified", "additions": 153, "deletions": 2, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -9,8 +9,13 @@ mod add_impl;\n mod introduce_variable;\n mod change_visibility;\n \n-use ra_text_edit::TextEdit;\n-use ra_syntax::{Direction, SyntaxNodeRef, TextUnit};\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n+use ra_syntax::{\n+    Direction, SyntaxNodeRef, TextUnit, TextRange,SourceFileNode, AstNode,\n+    algo::{find_leaf_at_offset, find_covering_node, LeafAtOffset},\n+};\n+\n+use crate::find_node_at_offset;\n \n pub use self::{\n     flip_comma::flip_comma,\n@@ -20,6 +25,21 @@ pub use self::{\n     change_visibility::change_visibility,\n };\n \n+/// Return all the assists applicable at the given position.\n+pub fn assists(file: &SourceFileNode, range: TextRange) -> Vec<LocalEdit> {\n+    let ctx = AssistCtx::new(file, range);\n+    [\n+        flip_comma,\n+        add_derive,\n+        add_impl,\n+        introduce_variable,\n+        change_visibility,\n+    ]\n+    .iter()\n+    .filter_map(|&assist| ctx.clone().apply(assist))\n+    .collect()\n+}\n+\n #[derive(Debug)]\n pub struct LocalEdit {\n     pub label: String,\n@@ -32,3 +52,134 @@ fn non_trivia_sibling(node: SyntaxNodeRef, direction: Direction) -> Option<Synta\n         .skip(1)\n         .find(|node| !node.kind().is_trivia())\n }\n+\n+/// `AssistCtx` allows to apply an assist or check if it could be applied.\n+///\n+/// Assists use a somewhat overengeneered approach, given the current needs. The\n+/// assists workflow consists of two phases. In the first phase, a user asks for\n+/// the list of available assists. In the second phase, the user picks a\n+/// particular assist and it gets applied.\n+///\n+/// There are two peculiarities here:\n+///\n+/// * first, we ideally avoid computing more things then neccessary to answer\n+///   \"is assist applicable\" in the first phase.\n+/// * second, when we are appling assist, we don't have a gurantee that there\n+///   weren't any changes between the point when user asked for assists and when\n+///   they applied a particular assist. So, when applying assist, we need to do\n+///   all the checks from scratch.\n+///\n+/// To avoid repeating the same code twice for both \"check\" and \"apply\"\n+/// functions, we use an approach remeniscent of that of Django's function based\n+/// views dealing with forms. Each assist receives a runtime parameter,\n+/// `should_compute_edit`. It first check if an edit is applicable (potentially\n+/// computing info required to compute the actual edit). If it is applicable,\n+/// and `should_compute_edit` is `true`, it then computes the actual edit.\n+///\n+/// So, to implement the original assists workflow, we can first apply each edit\n+/// with `should_compute_edit = false`, and then applying the selected edit\n+/// again, with `should_compute_edit = true` this time.\n+///\n+/// Note, however, that we don't actually use such two-phase logic at the\n+/// moment, because the LSP API is pretty awkward in this place, and it's much\n+/// easier to just compute the edit eagarly :-)\n+#[derive(Debug, Clone)]\n+pub struct AssistCtx<'a> {\n+    source_file: &'a SourceFileNode,\n+    range: TextRange,\n+    should_compute_edit: bool,\n+}\n+\n+#[derive(Debug)]\n+pub enum Assist {\n+    Applicable,\n+    Edit(LocalEdit),\n+}\n+\n+#[derive(Default)]\n+struct AssistBuilder {\n+    edit: TextEditBuilder,\n+    cursor_position: Option<TextUnit>,\n+}\n+\n+impl<'a> AssistCtx<'a> {\n+    pub fn new(source_file: &'a SourceFileNode, range: TextRange) -> AssistCtx {\n+        AssistCtx {\n+            source_file,\n+            range,\n+            should_compute_edit: false,\n+        }\n+    }\n+\n+    pub fn apply(mut self, assist: fn(AssistCtx) -> Option<Assist>) -> Option<LocalEdit> {\n+        self.should_compute_edit = true;\n+        match assist(self) {\n+            None => None,\n+            Some(Assist::Edit(e)) => Some(e),\n+            Some(Assist::Applicable) => unreachable!(),\n+        }\n+    }\n+\n+    pub fn check(mut self, assist: fn(AssistCtx) -> Option<Assist>) -> bool {\n+        self.should_compute_edit = false;\n+        match assist(self) {\n+            None => false,\n+            Some(Assist::Edit(_)) => unreachable!(),\n+            Some(Assist::Applicable) => true,\n+        }\n+    }\n+\n+    fn build(self, label: impl Into<String>, f: impl FnOnce(&mut AssistBuilder)) -> Option<Assist> {\n+        if !self.should_compute_edit {\n+            return Some(Assist::Applicable);\n+        }\n+        let mut edit = AssistBuilder::default();\n+        f(&mut edit);\n+        Some(Assist::Edit(LocalEdit {\n+            label: label.into(),\n+            edit: edit.edit.finish(),\n+            cursor_position: edit.cursor_position,\n+        }))\n+    }\n+\n+    pub(crate) fn leaf_at_offset(&self) -> LeafAtOffset<SyntaxNodeRef<'a>> {\n+        find_leaf_at_offset(self.source_file.syntax(), self.range.start())\n+    }\n+    pub(crate) fn node_at_offset<N: AstNode<'a>>(&self) -> Option<N> {\n+        find_node_at_offset(self.source_file.syntax(), self.range.start())\n+    }\n+    pub(crate) fn covering_node(&self) -> SyntaxNodeRef<'a> {\n+        find_covering_node(self.source_file.syntax(), self.range)\n+    }\n+}\n+\n+impl AssistBuilder {\n+    fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n+        self.edit.replace(range, replace_with.into())\n+    }\n+    #[allow(unused)]\n+    fn delete(&mut self, range: TextRange) {\n+        self.edit.delete(range)\n+    }\n+    fn insert(&mut self, offset: TextUnit, text: impl Into<String>) {\n+        self.edit.insert(offset, text.into())\n+    }\n+    fn set_cursor(&mut self, offset: TextUnit) {\n+        self.cursor_position = Some(offset)\n+    }\n+}\n+\n+#[cfg(test)]\n+fn check_assist(assist: fn(AssistCtx) -> Option<Assist>, before: &str, after: &str) {\n+    crate::test_utils::check_action(before, after, |file, off| {\n+        let range = TextRange::offset_len(off, 0.into());\n+        AssistCtx::new(file, range).apply(assist)\n+    })\n+}\n+\n+#[cfg(test)]\n+fn check_assist_range(assist: fn(AssistCtx) -> Option<Assist>, before: &str, after: &str) {\n+    crate::test_utils::check_action_range(before, after, |file, range| {\n+        AssistCtx::new(file, range).apply(assist)\n+    })\n+}"}, {"sha": "1e2cd4f300787d89b4d5fdbfe0a2fabe532f637f", "filename": "crates/ra_editor/src/assists/add_derive.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_derive.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -1,85 +1,73 @@\n-use ra_text_edit::TextEditBuilder;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n-    SourceFileNode,\n     SyntaxKind::{WHITESPACE, COMMENT},\n     TextUnit,\n };\n \n-use crate::{\n-    find_node_at_offset,\n-    assists::LocalEdit,\n-};\n+use crate::assists::{AssistCtx, Assist};\n \n-pub fn add_derive<'a>(\n-    file: &'a SourceFileNode,\n-    offset: TextUnit,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let nominal = find_node_at_offset::<ast::NominalDef>(file.syntax(), offset)?;\n+pub fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n+    let nominal = ctx.node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(nominal)?;\n-    return Some(move || {\n+    ctx.build(\"add `#[derive]`\", |edit| {\n         let derive_attr = nominal\n             .attrs()\n             .filter_map(|x| x.as_call())\n             .filter(|(name, _arg)| name == \"derive\")\n             .map(|(_name, arg)| arg)\n             .next();\n-        let mut edit = TextEditBuilder::new();\n         let offset = match derive_attr {\n             None => {\n-                edit.insert(node_start, \"#[derive()]\\n\".to_string());\n+                edit.insert(node_start, \"#[derive()]\\n\");\n                 node_start + TextUnit::of_str(\"#[derive(\")\n             }\n             Some(tt) => tt.syntax().range().end() - TextUnit::of_char(')'),\n         };\n-        LocalEdit {\n-            label: \"add `#[derive]`\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: Some(offset),\n-        }\n-    });\n+        edit.set_cursor(offset)\n+    })\n+}\n \n-    // Insert `derive` after doc comments.\n-    fn derive_insertion_offset(nominal: ast::NominalDef) -> Option<TextUnit> {\n-        let non_ws_child = nominal\n-            .syntax()\n-            .children()\n-            .find(|it| it.kind() != COMMENT && it.kind() != WHITESPACE)?;\n-        Some(non_ws_child.range().start())\n-    }\n+// Insert `derive` after doc comments.\n+fn derive_insertion_offset(nominal: ast::NominalDef) -> Option<TextUnit> {\n+    let non_ws_child = nominal\n+        .syntax()\n+        .children()\n+        .find(|it| it.kind() != COMMENT && it.kind() != WHITESPACE)?;\n+    Some(non_ws_child.range().start())\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::test_utils::check_action;\n+    use crate::assists::check_assist;\n \n     #[test]\n     fn add_derive_new() {\n-        check_action(\n+        check_assist(\n+            add_derive,\n             \"struct Foo { a: i32, <|>}\",\n             \"#[derive(<|>)]\\nstruct Foo { a: i32, }\",\n-            |file, off| add_derive(file, off).map(|f| f()),\n         );\n-        check_action(\n+        check_assist(\n+            add_derive,\n             \"struct Foo { <|> a: i32, }\",\n             \"#[derive(<|>)]\\nstruct Foo {  a: i32, }\",\n-            |file, off| add_derive(file, off).map(|f| f()),\n         );\n     }\n \n     #[test]\n     fn add_derive_existing() {\n-        check_action(\n+        check_assist(\n+            add_derive,\n             \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n             \"#[derive(Clone<|>)]\\nstruct Foo { a: i32, }\",\n-            |file, off| add_derive(file, off).map(|f| f()),\n         );\n     }\n \n     #[test]\n     fn add_derive_new_with_doc_comment() {\n-        check_action(\n+        check_assist(\n+            add_derive,\n             \"\n /// `Foo` is a pretty important struct.\n /// It does stuff.\n@@ -91,7 +79,6 @@ struct Foo { a: i32<|>, }\n #[derive(<|>)]\n struct Foo { a: i32, }\n             \",\n-            |file, off| add_derive(file, off).map(|f| f()),\n         );\n     }\n }"}, {"sha": "9353e2717b64faee73dad0b9b23d955682a6adca", "filename": "crates/ra_editor/src/assists/add_impl.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fadd_impl.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -1,23 +1,16 @@\n use join_to_string::join;\n-use ra_text_edit::TextEditBuilder;\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner, TypeParamsOwner},\n-    SourceFileNode,\n     TextUnit,\n };\n \n-use crate::{find_node_at_offset, assists::LocalEdit};\n+use crate::assists::{AssistCtx, Assist};\n \n-pub fn add_impl<'a>(\n-    file: &'a SourceFileNode,\n-    offset: TextUnit,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let nominal = find_node_at_offset::<ast::NominalDef>(file.syntax(), offset)?;\n+pub fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n+    let nominal = ctx.node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n-\n-    Some(move || {\n+    ctx.build(\"add impl\", |edit| {\n         let type_params = nominal.type_param_list();\n-        let mut edit = TextEditBuilder::new();\n         let start_offset = nominal.syntax().range().end();\n         let mut buf = String::new();\n         buf.push_str(\"\\n\\nimpl\");\n@@ -40,38 +33,33 @@ pub fn add_impl<'a>(\n                 .to_buf(&mut buf);\n         }\n         buf.push_str(\" {\\n\");\n-        let offset = start_offset + TextUnit::of_str(&buf);\n+        edit.set_cursor(start_offset + TextUnit::of_str(&buf));\n         buf.push_str(\"\\n}\");\n         edit.insert(start_offset, buf);\n-        LocalEdit {\n-            label: \"add impl\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: Some(offset),\n-        }\n     })\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::test_utils::check_action;\n+    use crate::assists::check_assist;\n \n     #[test]\n     fn test_add_impl() {\n-        check_action(\n+        check_assist(\n+            add_impl,\n             \"struct Foo {<|>}\\n\",\n             \"struct Foo {}\\n\\nimpl Foo {\\n<|>\\n}\\n\",\n-            |file, off| add_impl(file, off).map(|f| f()),\n         );\n-        check_action(\n+        check_assist(\n+            add_impl,\n             \"struct Foo<T: Clone> {<|>}\",\n             \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n<|>\\n}\",\n-            |file, off| add_impl(file, off).map(|f| f()),\n         );\n-        check_action(\n+        check_assist(\n+            add_impl,\n             \"struct Foo<'a, T: Foo<'a>> {<|>}\",\n             \"struct Foo<'a, T: Foo<'a>> {}\\n\\nimpl<'a, T: Foo<'a>> Foo<'a, T> {\\n<|>\\n}\",\n-            |file, off| add_impl(file, off).map(|f| f()),\n         );\n     }\n "}, {"sha": "379e88d3c0db512f36e6424704599fcbffb6810a", "filename": "crates/ra_editor/src/assists/change_visibility.rs", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fchange_visibility.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -1,90 +1,74 @@\n-use ra_text_edit::TextEditBuilder;\n use ra_syntax::{\n-    SourceFileNode,\n-    algo::find_leaf_at_offset,\n     SyntaxKind::{VISIBILITY, FN_KW, MOD_KW, STRUCT_KW, ENUM_KW, TRAIT_KW, FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF},\n-    TextUnit,\n };\n \n-use crate::assists::LocalEdit;\n+use crate::assists::{AssistCtx, Assist};\n \n-pub fn change_visibility<'a>(\n-    file: &'a SourceFileNode,\n-    offset: TextUnit,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let syntax = file.syntax();\n-\n-    let keyword = find_leaf_at_offset(syntax, offset).find(|leaf| match leaf.kind() {\n+pub fn change_visibility(ctx: AssistCtx) -> Option<Assist> {\n+    let keyword = ctx.leaf_at_offset().find(|leaf| match leaf.kind() {\n         FN_KW | MOD_KW | STRUCT_KW | ENUM_KW | TRAIT_KW => true,\n         _ => false,\n     })?;\n     let parent = keyword.parent()?;\n     let def_kws = vec![FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF];\n-    let node_start = parent.range().start();\n-    Some(move || {\n-        let mut edit = TextEditBuilder::new();\n-\n-        if !def_kws.iter().any(|&def_kw| def_kw == parent.kind())\n-            || parent.children().any(|child| child.kind() == VISIBILITY)\n-        {\n-            return LocalEdit {\n-                label: \"make pub crate\".to_string(),\n-                edit: edit.finish(),\n-                cursor_position: Some(offset),\n-            };\n-        }\n+    // Parent is not a definition, can't add visibility\n+    if !def_kws.iter().any(|&def_kw| def_kw == parent.kind()) {\n+        return None;\n+    }\n+    // Already have visibility, do nothing\n+    if parent.children().any(|child| child.kind() == VISIBILITY) {\n+        return None;\n+    }\n \n-        edit.insert(node_start, \"pub(crate) \".to_string());\n-        LocalEdit {\n-            label: \"make pub crate\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: Some(node_start),\n-        }\n+    let node_start = parent.range().start();\n+    ctx.build(\"make pub crate\", |edit| {\n+        edit.insert(node_start, \"pub(crate) \");\n+        edit.set_cursor(node_start);\n     })\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::test_utils::check_action;\n+    use crate::assists::check_assist;\n \n     #[test]\n     fn test_change_visibility() {\n-        check_action(\n+        check_assist(\n+            change_visibility,\n             \"<|>fn foo() {}\",\n             \"<|>pub(crate) fn foo() {}\",\n-            |file, off| change_visibility(file, off).map(|f| f()),\n         );\n-        check_action(\n+        check_assist(\n+            change_visibility,\n             \"f<|>n foo() {}\",\n             \"<|>pub(crate) fn foo() {}\",\n-            |file, off| change_visibility(file, off).map(|f| f()),\n         );\n-        check_action(\n+        check_assist(\n+            change_visibility,\n             \"<|>struct Foo {}\",\n             \"<|>pub(crate) struct Foo {}\",\n-            |file, off| change_visibility(file, off).map(|f| f()),\n         );\n-        check_action(\"<|>mod foo {}\", \"<|>pub(crate) mod foo {}\", |file, off| {\n-            change_visibility(file, off).map(|f| f())\n-        });\n-        check_action(\n+        check_assist(\n+            change_visibility,\n+            \"<|>mod foo {}\",\n+            \"<|>pub(crate) mod foo {}\",\n+        );\n+        check_assist(\n+            change_visibility,\n             \"<|>trait Foo {}\",\n             \"<|>pub(crate) trait Foo {}\",\n-            |file, off| change_visibility(file, off).map(|f| f()),\n         );\n-        check_action(\"m<|>od {}\", \"<|>pub(crate) mod {}\", |file, off| {\n-            change_visibility(file, off).map(|f| f())\n-        });\n-        check_action(\n+        check_assist(change_visibility, \"m<|>od {}\", \"<|>pub(crate) mod {}\");\n+        check_assist(\n+            change_visibility,\n             \"pub(crate) f<|>n foo() {}\",\n             \"pub(crate) f<|>n foo() {}\",\n-            |file, off| change_visibility(file, off).map(|f| f()),\n         );\n-        check_action(\n+        check_assist(\n+            change_visibility,\n             \"unsafe f<|>n foo() {}\",\n             \"<|>pub(crate) unsafe fn foo() {}\",\n-            |file, off| change_visibility(file, off).map(|f| f()),\n         );\n     }\n }"}, {"sha": "a343413cc5789e7e6a89e3e32513a214f3b0e2d0", "filename": "crates/ra_editor/src/assists/flip_comma.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fflip_comma.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -1,45 +1,31 @@\n-use ra_text_edit::TextEditBuilder;\n use ra_syntax::{\n-    algo::find_leaf_at_offset,\n-    Direction, SourceFileNode,\n+    Direction,\n     SyntaxKind::COMMA,\n-    TextUnit,\n };\n \n-use crate::assists::{LocalEdit, non_trivia_sibling};\n+use crate::assists::{non_trivia_sibling, AssistCtx, Assist};\n \n-pub fn flip_comma<'a>(\n-    file: &'a SourceFileNode,\n-    offset: TextUnit,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let syntax = file.syntax();\n-\n-    let comma = find_leaf_at_offset(syntax, offset).find(|leaf| leaf.kind() == COMMA)?;\n+pub fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n+    let comma = ctx.leaf_at_offset().find(|leaf| leaf.kind() == COMMA)?;\n     let prev = non_trivia_sibling(comma, Direction::Prev)?;\n     let next = non_trivia_sibling(comma, Direction::Next)?;\n-    Some(move || {\n-        let mut edit = TextEditBuilder::new();\n-        edit.replace(prev.range(), next.text().to_string());\n-        edit.replace(next.range(), prev.text().to_string());\n-        LocalEdit {\n-            label: \"flip comma\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: None,\n-        }\n+    ctx.build(\"flip comma\", |edit| {\n+        edit.replace(prev.range(), next.text());\n+        edit.replace(next.range(), prev.text());\n     })\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::test_utils::check_action;\n+    use crate::assists::check_assist;\n \n     #[test]\n-    fn test_swap_comma() {\n-        check_action(\n+    fn flip_comma_works_for_function_parameters() {\n+        check_assist(\n+            flip_comma,\n             \"fn foo(x: i32,<|> y: Result<(), ()>) {}\",\n             \"fn foo(y: Result<(), ()>,<|> x: i32) {}\",\n-            |file, off| flip_comma(file, off).map(|f| f()),\n         )\n     }\n }"}, {"sha": "782861023edfd05ebdf5e4d06d857a9006005c63", "filename": "crates/ra_editor/src/assists/introduce_variable.rs", "status": "modified", "additions": 36, "deletions": 48, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fassists%2Fintroduce_variable.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -1,29 +1,22 @@\n-use ra_text_edit::TextEditBuilder;\n use ra_syntax::{\n-    algo::{find_covering_node},\n     ast::{self, AstNode},\n-    SourceFileNode,\n-    SyntaxKind::{WHITESPACE},\n-    SyntaxNodeRef, TextRange, TextUnit,\n+    SyntaxKind::WHITESPACE,\n+    SyntaxNodeRef, TextUnit,\n };\n \n-use crate::assists::LocalEdit;\n+use crate::assists::{AssistCtx, Assist};\n \n-pub fn introduce_variable<'a>(\n-    file: &'a SourceFileNode,\n-    range: TextRange,\n-) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n-    let node = find_covering_node(file.syntax(), range);\n+pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n+    let node = ctx.covering_node();\n     let expr = node.ancestors().filter_map(ast::Expr::cast).next()?;\n \n     let anchor_stmt = anchor_stmt(expr)?;\n     let indent = anchor_stmt.prev_sibling()?;\n     if indent.kind() != WHITESPACE {\n         return None;\n     }\n-    return Some(move || {\n+    ctx.build(\"introduce variable\", move |edit| {\n         let mut buf = String::new();\n-        let mut edit = TextEditBuilder::new();\n \n         buf.push_str(\"let var_name = \");\n         expr.syntax().text().push_to(&mut buf);\n@@ -40,43 +33,39 @@ pub fn introduce_variable<'a>(\n             edit.replace(expr.syntax().range(), \"var_name\".to_string());\n             edit.insert(anchor_stmt.range().start(), buf);\n         }\n-        let cursor_position = anchor_stmt.range().start() + TextUnit::of_str(\"let \");\n-        LocalEdit {\n-            label: \"introduce variable\".to_string(),\n-            edit: edit.finish(),\n-            cursor_position: Some(cursor_position),\n-        }\n-    });\n+        edit.set_cursor(anchor_stmt.range().start() + TextUnit::of_str(\"let \"));\n+    })\n+}\n \n-    /// Statement or last in the block expression, which will follow\n-    /// the freshly introduced var.\n-    fn anchor_stmt(expr: ast::Expr) -> Option<SyntaxNodeRef> {\n-        expr.syntax().ancestors().find(|&node| {\n-            if ast::Stmt::cast(node).is_some() {\n+/// Statement or last in the block expression, which will follow\n+/// the freshly introduced var.\n+fn anchor_stmt(expr: ast::Expr) -> Option<SyntaxNodeRef> {\n+    expr.syntax().ancestors().find(|&node| {\n+        if ast::Stmt::cast(node).is_some() {\n+            return true;\n+        }\n+        if let Some(expr) = node\n+            .parent()\n+            .and_then(ast::Block::cast)\n+            .and_then(|it| it.expr())\n+        {\n+            if expr.syntax() == node {\n                 return true;\n             }\n-            if let Some(expr) = node\n-                .parent()\n-                .and_then(ast::Block::cast)\n-                .and_then(|it| it.expr())\n-            {\n-                if expr.syntax() == node {\n-                    return true;\n-                }\n-            }\n-            false\n-        })\n-    }\n+        }\n+        false\n+    })\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::test_utils::check_action_range;\n+    use crate::assists::check_assist_range;\n \n     #[test]\n     fn test_introduce_var_simple() {\n-        check_action_range(\n+        check_assist_range(\n+            introduce_variable,\n             \"\n fn foo() {\n     foo(<|>1 + 1<|>);\n@@ -86,13 +75,13 @@ fn foo() {\n     let <|>var_name = 1 + 1;\n     foo(var_name);\n }\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n         );\n     }\n \n     #[test]\n     fn test_introduce_var_expr_stmt() {\n-        check_action_range(\n+        check_assist_range(\n+            introduce_variable,\n             \"\n fn foo() {\n     <|>1 + 1<|>;\n@@ -101,13 +90,13 @@ fn foo() {\n fn foo() {\n     let <|>var_name = 1 + 1;\n }\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n         );\n     }\n \n     #[test]\n     fn test_introduce_var_part_of_expr_stmt() {\n-        check_action_range(\n+        check_assist_range(\n+            introduce_variable,\n             \"\n fn foo() {\n     <|>1<|> + 1;\n@@ -117,13 +106,13 @@ fn foo() {\n     let <|>var_name = 1;\n     var_name + 1;\n }\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n         );\n     }\n \n     #[test]\n     fn test_introduce_var_last_expr() {\n-        check_action_range(\n+        check_assist_range(\n+            introduce_variable,\n             \"\n fn foo() {\n     bar(<|>1 + 1<|>)\n@@ -133,13 +122,13 @@ fn foo() {\n     let <|>var_name = 1 + 1;\n     bar(var_name)\n }\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n         );\n     }\n \n     #[test]\n     fn test_introduce_var_last_full_expr() {\n-        check_action_range(\n+        check_assist_range(\n+            introduce_variable,\n             \"\n fn foo() {\n     <|>bar(1 + 1)<|>\n@@ -149,7 +138,6 @@ fn foo() {\n     let <|>var_name = bar(1 + 1);\n     var_name\n }\",\n-            |file, range| introduce_variable(file, range).map(|f| f()),\n         );\n     }\n "}, {"sha": "199b0e502937298dd248dcb1b4f997ea78fbb504", "filename": "crates/ra_editor/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -57,7 +57,7 @@ fn check_unnecessary_braces_in_use_statement(\n             text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n                 .unwrap_or_else(|| {\n                     let to_replace = single_use_tree.syntax().text().to_string();\n-                    let mut edit_builder = TextEditBuilder::new();\n+                    let mut edit_builder = TextEditBuilder::default();\n                     edit_builder.delete(range);\n                     edit_builder.insert(range.start(), to_replace);\n                     edit_builder.finish()\n@@ -93,7 +93,7 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n         let start = use_tree_list_node.prev_sibling()?.range().start();\n         let end = use_tree_list_node.range().end();\n         let range = TextRange::from_to(start, end);\n-        let mut edit_builder = TextEditBuilder::new();\n+        let mut edit_builder = TextEditBuilder::default();\n         edit_builder.delete(range);\n         return Some(edit_builder.finish());\n     }\n@@ -111,7 +111,7 @@ fn check_struct_shorthand_initialization(\n             let field_name = name_ref.syntax().text().to_string();\n             let field_expr = expr.syntax().text().to_string();\n             if field_name == field_expr {\n-                let mut edit_builder = TextEditBuilder::new();\n+                let mut edit_builder = TextEditBuilder::default();\n                 edit_builder.delete(named_field.syntax().range());\n                 edit_builder.insert(named_field.syntax().range().start(), field_name);\n                 let edit = edit_builder.finish();"}, {"sha": "dd3d0f260d7af4c42afdf6ee05e1d47bc1aecd64", "filename": "crates/ra_editor/src/typing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ftyping.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -21,7 +21,7 @@ pub fn join_lines(file: &SourceFileNode, range: TextRange) -> LocalEdit {\n             None => {\n                 return LocalEdit {\n                     label: \"join lines\".to_string(),\n-                    edit: TextEditBuilder::new().finish(),\n+                    edit: TextEditBuilder::default().finish(),\n                     cursor_position: None,\n                 };\n             }\n@@ -33,7 +33,7 @@ pub fn join_lines(file: &SourceFileNode, range: TextRange) -> LocalEdit {\n     };\n \n     let node = find_covering_node(file.syntax(), range);\n-    let mut edit = TextEditBuilder::new();\n+    let mut edit = TextEditBuilder::default();\n     for node in node.descendants() {\n         let text = match node.leaf_text() {\n             Some(text) => text,\n@@ -76,7 +76,7 @@ pub fn on_enter(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit> {\n     let indent = node_indent(file, comment.syntax())?;\n     let inserted = format!(\"\\n{}{} \", indent, prefix);\n     let cursor_position = offset + TextUnit::of_str(&inserted);\n-    let mut edit = TextEditBuilder::new();\n+    let mut edit = TextEditBuilder::default();\n     edit.insert(offset, inserted);\n     Some(LocalEdit {\n         label: \"on enter\".to_string(),\n@@ -127,7 +127,7 @@ pub fn on_eq_typed(file: &SourceFileNode, offset: TextUnit) -> Option<LocalEdit>\n         return None;\n     }\n     let offset = let_stmt.syntax().range().end();\n-    let mut edit = TextEditBuilder::new();\n+    let mut edit = TextEditBuilder::default();\n     edit.insert(offset, \";\".to_string());\n     Some(LocalEdit {\n         label: \"add semicolon\".to_string(),"}, {"sha": "783dca2147555aa324565ed1b4312c8a3ee14530", "filename": "crates/ra_syntax/src/yellow/syntax_text.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -119,3 +119,9 @@ impl SyntaxTextSlice for ops::Range<TextUnit> {\n         TextRange::from_to(self.start, self.end).restrict(range)\n     }\n }\n+\n+impl From<SyntaxText<'_>> for String {\n+    fn from(text: SyntaxText) -> String {\n+        text.to_string()\n+    }\n+}"}, {"sha": "a288a990db8a3a4848363d4407bb1691aa33af88", "filename": "crates/ra_text_edit/src/text_edit.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4635a199bc446bd103aa5821e57dc19b8a15751/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs?ref=a4635a199bc446bd103aa5821e57dc19b8a15751", "patch": "@@ -7,15 +7,12 @@ pub struct TextEdit {\n     atoms: Vec<AtomTextEdit>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Default)]\n pub struct TextEditBuilder {\n     atoms: Vec<AtomTextEdit>,\n }\n \n impl TextEditBuilder {\n-    pub fn new() -> TextEditBuilder {\n-        TextEditBuilder { atoms: Vec::new() }\n-    }\n     pub fn replace(&mut self, range: TextRange, replace_with: String) {\n         self.atoms.push(AtomTextEdit::replace(range, replace_with))\n     }"}]}