{"sha": "f283d3f02cf3ed261a519afe05cde9e23d1d9278", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyODNkM2YwMmNmM2VkMjYxYTUxOWFmZTA1Y2RlOWUyM2QxZDkyNzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-02T00:48:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-02T00:48:41Z"}, "message": "Auto merge of #77436 - JohnTitor:rollup-65dh7rp, r=JohnTitor\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #76851 (Fix 'FIXME' about using NonZeroU32 instead of u32.)\n - #76979 (Improve std::sys::windows::compat)\n - #77111 (Stabilize slice_ptr_range.)\n - #77147 (Split sys_common::Mutex in StaticMutex and MovableMutex.)\n - #77312 (Remove outdated line from `publish_toolstate` hook)\n - #77362 (Fix is_absolute on WASI)\n - #77375 (rustc_metadata: Do not forget to encode inherent impls for foreign types)\n - #77385 (Improve the example for ptr::copy)\n - #77389 (Fix some clippy lints)\n - #77399 (BTreeMap: use Unique::from to avoid a cast where type information exists)\n - #77429 (Link `new` method in `DefautHasher`s doc)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "a7e6921f19e98580b47e0751b7ef50992a49cf5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7e6921f19e98580b47e0751b7ef50992a49cf5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f283d3f02cf3ed261a519afe05cde9e23d1d9278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f283d3f02cf3ed261a519afe05cde9e23d1d9278", "html_url": "https://github.com/rust-lang/rust/commit/f283d3f02cf3ed261a519afe05cde9e23d1d9278", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f283d3f02cf3ed261a519afe05cde9e23d1d9278/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66936de05962e7e90adb265fb102042c34c7cbfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/66936de05962e7e90adb265fb102042c34c7cbfe", "html_url": "https://github.com/rust-lang/rust/commit/66936de05962e7e90adb265fb102042c34c7cbfe"}, {"sha": "5a7218009ec093f03bc0d2eb3ea2444ed4276f23", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7218009ec093f03bc0d2eb3ea2444ed4276f23", "html_url": "https://github.com/rust-lang/rust/commit/5a7218009ec093f03bc0d2eb3ea2444ed4276f23"}], "stats": {"total": 455, "additions": 228, "deletions": 227}, "files": [{"sha": "e2492efb9d79ed4c758787765ff3b3fedb756aa8", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1,6 +1,6 @@\n //! List of the accepted feature gates.\n \n-use super::{Feature, State};\n+use super::{to_nonzero, Feature, State};\n use rustc_span::symbol::sym;\n \n macro_rules! declare_features {\n@@ -14,7 +14,7 @@ macro_rules! declare_features {\n                     state: State::Accepted,\n                     name: sym::$feature,\n                     since: $ver,\n-                    issue: $issue,\n+                    issue: to_nonzero($issue),\n                     edition: None,\n                     description: concat!($($doc,)*),\n                 }"}, {"sha": "060efd270dd5165ef2afd523254db69644bfd62d", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1,6 +1,6 @@\n //! List of the active feature gates.\n \n-use super::{Feature, State};\n+use super::{to_nonzero, Feature, State};\n \n use rustc_span::edition::Edition;\n use rustc_span::symbol::{sym, Symbol};\n@@ -29,7 +29,7 @@ macro_rules! declare_features {\n                     state: State::Active { set: set!($feature) },\n                     name: sym::$feature,\n                     since: $ver,\n-                    issue: $issue,\n+                    issue: to_nonzero($issue),\n                     edition: $edition,\n                     description: concat!($($doc,)*),\n                 }"}, {"sha": "68ac2841fed70a62fafbcc9ae6ea04363c2b6b7b", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -46,17 +46,11 @@ pub struct Feature {\n     pub state: State,\n     pub name: Symbol,\n     pub since: &'static str,\n-    issue: Option<u32>, // FIXME: once #58732 is done make this an Option<NonZeroU32>\n+    issue: Option<NonZeroU32>,\n     pub edition: Option<Edition>,\n     description: &'static str,\n }\n \n-impl Feature {\n-    fn issue(&self) -> Option<NonZeroU32> {\n-        self.issue.and_then(NonZeroU32::new)\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum Stability {\n     Unstable,\n@@ -102,8 +96,8 @@ impl UnstableFeatures {\n fn find_lang_feature_issue(feature: Symbol) -> Option<NonZeroU32> {\n     if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.name == feature) {\n         // FIXME (#28244): enforce that active features have issue numbers\n-        // assert!(info.issue().is_some())\n-        info.issue()\n+        // assert!(info.issue.is_some())\n+        info.issue\n     } else {\n         // search in Accepted, Removed, or Stable Removed features\n         let found = ACCEPTED_FEATURES\n@@ -112,12 +106,21 @@ fn find_lang_feature_issue(feature: Symbol) -> Option<NonZeroU32> {\n             .chain(STABLE_REMOVED_FEATURES)\n             .find(|t| t.name == feature);\n         match found {\n-            Some(found) => found.issue(),\n+            Some(found) => found.issue,\n             None => panic!(\"feature `{}` is not declared anywhere\", feature),\n         }\n     }\n }\n \n+const fn to_nonzero(n: Option<u32>) -> Option<NonZeroU32> {\n+    // Can be replaced with `n.and_then(NonZeroU32::new)` if that is ever usable\n+    // in const context. Requires https://github.com/rust-lang/rfcs/pull/2632.\n+    match n {\n+        None => None,\n+        Some(n) => NonZeroU32::new(n),\n+    }\n+}\n+\n pub enum GateIssue {\n     Language,\n     Library(Option<NonZeroU32>),"}, {"sha": "a480ddc7f34b1f2e41b8004b300272ac6dbe73f6", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1,6 +1,6 @@\n //! List of the removed feature gates.\n \n-use super::{Feature, State};\n+use super::{to_nonzero, Feature, State};\n use rustc_span::symbol::sym;\n \n macro_rules! declare_features {\n@@ -14,7 +14,7 @@ macro_rules! declare_features {\n                     state: State::Removed { reason: $reason },\n                     name: sym::$feature,\n                     since: $ver,\n-                    issue: $issue,\n+                    issue: to_nonzero($issue),\n                     edition: None,\n                     description: concat!($($doc,)*),\n                 }\n@@ -32,7 +32,7 @@ macro_rules! declare_features {\n                     state: State::Stabilized { reason: None },\n                     name: sym::$feature,\n                     since: $ver,\n-                    issue: $issue,\n+                    issue: to_nonzero($issue),\n                     edition: None,\n                     description: concat!($($doc,)*),\n                 }"}, {"sha": "f58a792ef585ee28a3576b3d2b99a619d8b34e8c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1753,6 +1753,7 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n+        self.encode_inherent_implementations(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);"}, {"sha": "ba08f65f903e56847cd4bcfd375b94cc0bc7c81c", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -128,7 +128,7 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     fn from_internal(node: Box<InternalNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Box::into_unique(node).cast() }\n+        BoxedNode { ptr: Unique::from(&mut Box::leak(node).data) }\n     }\n \n     unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {"}, {"sha": "4e4b31c0cb4ced070bc5771d14a013ba8d843cde", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1901,11 +1901,21 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n /// ```\n /// use std::ptr;\n ///\n+/// /// # Safety:\n+/// /// * `ptr` must be correctly aligned for its type and non-zero.\n+/// /// * `ptr` must be valid for reads of `elts` contiguous objects of type `T`.\n+/// /// * Those elements must not be used after calling this function unless `T: Copy`.\n /// # #[allow(dead_code)]\n /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n ///     let mut dst = Vec::with_capacity(elts);\n-///     dst.set_len(elts);\n+///\n+///     // SAFETY: Our precondition ensures the source is aligned and valid,\n+///     // and `Vec::with_capacity` ensures that we have usable space to write them.\n ///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n+///\n+///     // SAFETY: We created it with this much capacity earlier,\n+///     // and the previous `copy` has initialized these elements.\n+///     dst.set_len(elts);\n ///     dst\n /// }\n /// ```"}, {"sha": "b1ca093add581a78e2d6f9a31d43c2f8f9a1fc08", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -458,8 +458,6 @@ impl<T> [T] {\n     /// element of this slice:\n     ///\n     /// ```\n-    /// #![feature(slice_ptr_range)]\n-    ///\n     /// let a = [1, 2, 3];\n     /// let x = &a[1] as *const _;\n     /// let y = &5 as *const _;\n@@ -469,7 +467,7 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// [`as_ptr`]: #method.as_ptr\n-    #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n+    #[stable(feature = \"slice_ptr_range\", since = \"1.48.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n     pub const fn as_ptr_range(&self) -> Range<*const T> {\n@@ -511,7 +509,7 @@ impl<T> [T] {\n     /// common in C++.\n     ///\n     /// [`as_mut_ptr`]: #method.as_mut_ptr\n-    #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n+    #[stable(feature = \"slice_ptr_range\", since = \"1.48.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n     pub const fn as_mut_ptr_range(&mut self) -> Range<*mut T> {"}, {"sha": "4424a4c199226bd7c72de35edec70df85a7804fa", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -2836,11 +2836,10 @@ impl DefaultHasher {\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n impl Default for DefaultHasher {\n-    // FIXME: here should link `new` to [DefaultHasher::new], but it occurs intra-doc link\n-    // resolution failure when re-exporting libstd items. When #56922 fixed,\n-    // link `new` to [DefaultHasher::new] again.\n-    /// Creates a new `DefaultHasher` using `new`.\n+    /// Creates a new `DefaultHasher` using [`new`].\n     /// See its documentation for more.\n+    ///\n+    /// [`new`]: DefaultHasher::new\n     fn default() -> DefaultHasher {\n         DefaultHasher::new()\n     }"}, {"sha": "6fa73042a303f1e434aa67de5661f72644e44b9e", "filename": "library/std/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1838,7 +1838,7 @@ impl Path {\n             // FIXME: Allow Redox prefixes\n             self.has_root() || has_redox_scheme(self.as_u8_slice())\n         } else {\n-            self.has_root() && (cfg!(unix) || self.prefix().is_some())\n+            self.has_root() && (cfg!(any(unix, target_os = \"wasi\")) || self.prefix().is_some())\n         }\n     }\n "}, {"sha": "1376d8ebe8f4a6478f358f1be05dedc890767740", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -553,8 +553,8 @@ impl Condvar {\n         unsafe { self.inner.notify_all() }\n     }\n \n-    fn verify(&self, mutex: &sys_mutex::Mutex) {\n-        let addr = mutex as *const _ as usize;\n+    fn verify(&self, mutex: &sys_mutex::MovableMutex) {\n+        let addr = mutex.raw() as *const _ as usize;\n         match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n             // If we got out 0, then we have successfully bound the mutex to\n             // this cvar."}, {"sha": "e8f5a6f42948601dd831c3304e07a1cbae326453", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -166,12 +166,7 @@ use crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mutex_type\")]\n pub struct Mutex<T: ?Sized> {\n-    // Note that this mutex is in a *box*, not inlined into the struct itself.\n-    // Once a native mutex has been used once, its address can never change (it\n-    // can't be moved). This mutex type can be safely moved at any time, so to\n-    // ensure that the native mutex is used correctly we box the inner mutex to\n-    // give it a constant address.\n-    inner: Box<sys::Mutex>,\n+    inner: sys::MovableMutex,\n     poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n@@ -218,15 +213,11 @@ impl<T> Mutex<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n-        let mut m = Mutex {\n-            inner: box sys::Mutex::new(),\n+        Mutex {\n+            inner: sys::MovableMutex::new(),\n             poison: poison::Flag::new(),\n             data: UnsafeCell::new(t),\n-        };\n-        unsafe {\n-            m.inner.init();\n         }\n-        m\n     }\n }\n \n@@ -378,7 +369,6 @@ impl<T: ?Sized> Mutex<T> {\n                 (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.destroy(); // Keep in sync with the `Drop` impl.\n             drop(inner);\n \n             poison::map_result(poison.borrow(), |_| data.into_inner())\n@@ -411,18 +401,6 @@ impl<T: ?Sized> Mutex<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized> Drop for Mutex<T> {\n-    fn drop(&mut self) {\n-        // This is actually safe b/c we know that there is no further usage of\n-        // this mutex (it's up to the user to arrange for a mutex to get\n-        // dropped, that's not our job)\n-        //\n-        // IMPORTANT: This code must be kept in sync with `Mutex::into_inner`.\n-        unsafe { self.inner.destroy() }\n-    }\n-}\n-\n #[stable(feature = \"mutex_from\", since = \"1.24.0\")]\n impl<T> From<T> for Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n@@ -509,7 +487,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for MutexGuard<'_, T> {\n     }\n }\n \n-pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n+pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::MovableMutex {\n     &guard.lock.inner\n }\n "}, {"sha": "7727293927282b34e8b1afb750ec36faffbd93d1", "filename": "library/std/src/sys/hermit/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -57,11 +57,11 @@ mod imp {\n     use crate::ptr;\n     use crate::sys_common::os_str_bytes::*;\n \n-    use crate::sys_common::mutex::Mutex;\n+    use crate::sys_common::mutex::StaticMutex;\n \n     static mut ARGC: isize = 0;\n     static mut ARGV: *const *const u8 = ptr::null();\n-    static LOCK: Mutex = Mutex::new();\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();"}, {"sha": "f7c3f163718183510d78d904fc4bc3773f3aaf8e", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -80,13 +80,13 @@ mod imp {\n     use crate::ptr;\n     use crate::sync::atomic::{AtomicIsize, AtomicPtr, Ordering};\n \n-    use crate::sys_common::mutex::Mutex;\n+    use crate::sys_common::mutex::StaticMutex;\n \n     static ARGC: AtomicIsize = AtomicIsize::new(0);\n     static ARGV: AtomicPtr<*const u8> = AtomicPtr::new(ptr::null_mut());\n     // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n     // acquire this mutex reentrantly!\n-    static LOCK: Mutex = Mutex::new();\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     unsafe fn really_init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();"}, {"sha": "c9f9ed01e120e259b6cf408bf7e91bd5addc1521", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -21,7 +21,7 @@ use crate::slice;\n use crate::str;\n use crate::sys::cvt;\n use crate::sys::fd;\n-use crate::sys_common::mutex::{Mutex, MutexGuard};\n+use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n use crate::vec;\n \n use libc::{c_char, c_int, c_void};\n@@ -470,10 +470,9 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n-pub unsafe fn env_lock() -> MutexGuard<'static> {\n-    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n-    // acquire this mutex reentrantly!\n-    static ENV_LOCK: Mutex = Mutex::new();\n+pub unsafe fn env_lock() -> StaticMutexGuard<'static> {\n+    // It is UB to attempt to acquire this mutex reentrantly!\n+    static ENV_LOCK: StaticMutex = StaticMutex::new();\n     ENV_LOCK.lock()\n }\n "}, {"sha": "30cf7a707c7af9e08d53ec1e6719d98f837ab357", "filename": "library/std/src/sys/vxworks/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -57,11 +57,11 @@ mod imp {\n     use crate::marker::PhantomData;\n     use crate::ptr;\n \n-    use crate::sys_common::mutex::Mutex;\n+    use crate::sys_common::mutex::StaticMutex;\n \n     static mut ARGC: isize = 0;\n     static mut ARGV: *const *const u8 = ptr::null();\n-    static LOCK: Mutex = Mutex::new();\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();"}, {"sha": "08394a8d29de1c3e024646951c0c51d5443b1341", "filename": "library/std/src/sys/vxworks/os.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -10,7 +10,7 @@ use crate::path::{self, Path, PathBuf};\n use crate::slice;\n use crate::str;\n use crate::sys::cvt;\n-use crate::sys_common::mutex::{Mutex, MutexGuard};\n+use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n use libc::{self, c_char /*,c_void */, c_int};\n /*use sys::fd; this one is probably important */\n use crate::vec;\n@@ -212,10 +212,9 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n-pub unsafe fn env_lock() -> MutexGuard<'static> {\n-    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n-    // acquire this mutex reentrantly!\n-    static ENV_LOCK: Mutex = Mutex::new();\n+pub unsafe fn env_lock() -> StaticMutexGuard<'static> {\n+    // It is UB to attempt to acquire this mutex reentrantly!\n+    static ENV_LOCK: StaticMutex = StaticMutex::new();\n     ENV_LOCK.lock()\n }\n "}, {"sha": "559c4dc9c7cd8fc199f1f6ff38f15073ecd02db4", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1032,7 +1032,7 @@ extern \"system\" {\n // Functions that aren't available on every version of Windows that we support,\n // but we still use them and just provide some form of a fallback implementation.\n compat_fn! {\n-    kernel32:\n+    \"kernel32\":\n \n     pub fn CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n                                _lpTargetFileName: LPCWSTR,"}, {"sha": "3f25f05e1b9a7e479ce7f8cd766af19e9a532cf8", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -12,7 +12,6 @@\n //! function is available but afterwards it's just a load and a jump.\n \n use crate::ffi::CString;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::c;\n \n pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n@@ -28,45 +27,69 @@ pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n     }\n }\n \n-pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str, fallback: usize) -> usize {\n-    let value = lookup(module, symbol).unwrap_or(fallback);\n-    ptr.store(value, Ordering::SeqCst);\n-    value\n-}\n-\n macro_rules! compat_fn {\n-    ($module:ident: $(\n+    ($module:literal: $(\n         $(#[$meta:meta])*\n-        pub fn $symbol:ident($($argname:ident: $argtype:ty),*)\n-                                  -> $rettype:ty {\n-            $($body:expr);*\n-        }\n+        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $body:block\n     )*) => ($(\n-        #[allow(unused_variables)]\n         $(#[$meta])*\n-        pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n+        pub mod $symbol {\n+            use super::*;\n             use crate::sync::atomic::{AtomicUsize, Ordering};\n             use crate::mem;\n+\n             type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n \n             static PTR: AtomicUsize = AtomicUsize::new(0);\n \n+            #[allow(unused_variables)]\n+            unsafe extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $body\n+\n+            /// This address is stored in `PTR` to incidate an unavailable API.\n+            ///\n+            /// This way, call() will end up calling fallback() if it is unavailable.\n+            ///\n+            /// This is a `static` to avoid rustc duplicating `fn fallback()`\n+            /// into both load() and is_available(), which would break\n+            /// is_available()'s comparison. By using the same static variable\n+            /// in both places, they'll refer to the same (copy of the)\n+            /// function.\n+            ///\n+            /// LLVM merging the address of fallback with other functions\n+            /// (because of unnamed_addr) is fine, since it's only compared to\n+            /// an address from GetProcAddress from an external dll.\n+            static FALLBACK: F = fallback;\n+\n+            #[cold]\n             fn load() -> usize {\n-                crate::sys::compat::store_func(&PTR,\n-                                          stringify!($module),\n-                                          stringify!($symbol),\n-                                          fallback as usize)\n+                // There is no locking here. It's okay if this is executed by multiple threads in\n+                // parallel. `lookup` will result in the same value, and it's okay if they overwrite\n+                // eachothers result as long as they do so atomically. We don't need any guarantees\n+                // about memory ordering, as this involves just a single atomic variable which is\n+                // not used to protect or order anything else.\n+                let addr = crate::sys::compat::lookup($module, stringify!($symbol))\n+                    .unwrap_or(FALLBACK as usize);\n+                PTR.store(addr, Ordering::Relaxed);\n+                addr\n             }\n-            unsafe extern \"system\" fn fallback($($argname: $argtype),*)\n-                                               -> $rettype {\n-                $($body);*\n+\n+            fn addr() -> usize {\n+                match PTR.load(Ordering::Relaxed) {\n+                    0 => load(),\n+                    addr => addr,\n+                }\n+            }\n+\n+            #[allow(dead_code)]\n+            pub fn is_available() -> bool {\n+                addr() != FALLBACK as usize\n             }\n \n-            let addr = match PTR.load(Ordering::SeqCst) {\n-                0 => load(),\n-                n => n,\n-            };\n-            mem::transmute::<usize, F>(addr)($($argname),*)\n+            pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n+                mem::transmute::<usize, F>(addr())($($argname),*)\n+            }\n         }\n+\n+        pub use $symbol::call as $symbol;\n     )*)\n }"}, {"sha": "e2aaca59fe2f388b26d54fcf1c8cf5878ad6db26", "filename": "library/std/src/sys/windows/mutex.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -23,7 +23,6 @@ use crate::cell::{Cell, UnsafeCell};\n use crate::mem::{self, MaybeUninit};\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::c;\n-use crate::sys::compat;\n \n pub struct Mutex {\n     // This is either directly an SRWLOCK (if supported), or a Box<Inner> otherwise.\n@@ -40,8 +39,8 @@ struct Inner {\n \n #[derive(Clone, Copy)]\n enum Kind {\n-    SRWLock = 1,\n-    CriticalSection = 2,\n+    SRWLock,\n+    CriticalSection,\n }\n \n #[inline]\n@@ -130,21 +129,7 @@ impl Mutex {\n }\n \n fn kind() -> Kind {\n-    static KIND: AtomicUsize = AtomicUsize::new(0);\n-\n-    let val = KIND.load(Ordering::SeqCst);\n-    if val == Kind::SRWLock as usize {\n-        return Kind::SRWLock;\n-    } else if val == Kind::CriticalSection as usize {\n-        return Kind::CriticalSection;\n-    }\n-\n-    let ret = match compat::lookup(\"kernel32\", \"AcquireSRWLockExclusive\") {\n-        None => Kind::CriticalSection,\n-        Some(..) => Kind::SRWLock,\n-    };\n-    KIND.store(ret as usize, Ordering::SeqCst);\n-    ret\n+    if c::AcquireSRWLockExclusive::is_available() { Kind::SRWLock } else { Kind::CriticalSection }\n }\n \n pub struct ReentrantMutex {"}, {"sha": "90d5d3a78987fe6b289745fbc3490ab77af36a00", "filename": "library/std/src/sys_common/at_exit_imp.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -4,17 +4,16 @@\n \n use crate::mem;\n use crate::ptr;\n-use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n \n type Queue = Vec<Box<dyn FnOnce()>>;\n \n // NB these are specifically not types from `std::sync` as they currently rely\n // on poisoning and this module needs to operate at a lower level than requiring\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n-// We never call `LOCK.init()`, so it is UB to attempt to\n-// acquire this mutex reentrantly!\n-static LOCK: Mutex = Mutex::new();\n+// It is UB to attempt to acquire this mutex reentrantly!\n+static LOCK: StaticMutex = StaticMutex::new();\n static mut QUEUE: *mut Queue = ptr::null_mut();\n \n const DONE: *mut Queue = 1_usize as *mut _;"}, {"sha": "a48d301f8127bbc18731de82b6eafddf2e91fd9d", "filename": "library/std/src/sys_common/condvar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1,5 +1,5 @@\n use crate::sys::condvar as imp;\n-use crate::sys_common::mutex::{self, Mutex};\n+use crate::sys_common::mutex::MovableMutex;\n use crate::time::Duration;\n \n /// An OS-based condition variable.\n@@ -46,8 +46,8 @@ impl Condvar {\n     /// Behavior is also undefined if more than one mutex is used concurrently\n     /// on this condition variable.\n     #[inline]\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        self.0.wait(mutex::raw(mutex))\n+    pub unsafe fn wait(&self, mutex: &MovableMutex) {\n+        self.0.wait(mutex.raw())\n     }\n \n     /// Waits for a signal on the specified mutex with a timeout duration\n@@ -57,8 +57,8 @@ impl Condvar {\n     /// Behavior is also undefined if more than one mutex is used concurrently\n     /// on this condition variable.\n     #[inline]\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        self.0.wait_timeout(mutex::raw(mutex), dur)\n+    pub unsafe fn wait_timeout(&self, mutex: &MovableMutex, dur: Duration) -> bool {\n+        self.0.wait_timeout(mutex.raw(), dur)\n     }\n \n     /// Deallocates all resources associated with this condition variable."}, {"sha": "93ec7d89bc5c7e26152f34d5c316f26217354f83", "filename": "library/std/src/sys_common/mutex.rs", "status": "modified", "additions": 66, "deletions": 61, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1,101 +1,106 @@\n use crate::sys::mutex as imp;\n \n-/// An OS-based mutual exclusion lock.\n+/// An OS-based mutual exclusion lock, meant for use in static variables.\n+///\n+/// This mutex has a const constructor ([`StaticMutex::new`]), does not\n+/// implement `Drop` to cleanup resources, and causes UB when moved or used\n+/// reentrantly.\n+///\n+/// This mutex does not implement poisoning.\n ///\n-/// This is the thinnest cross-platform wrapper around OS mutexes. All usage of\n-/// this mutex is unsafe and it is recommended to instead use the safe wrapper\n-/// at the top level of the crate instead of this type.\n-pub struct Mutex(imp::Mutex);\n+/// This is a wrapper around `imp::Mutex` that does *not* call `init()` and\n+/// `destroy()`.\n+pub struct StaticMutex(imp::Mutex);\n \n-unsafe impl Sync for Mutex {}\n+unsafe impl Sync for StaticMutex {}\n \n-impl Mutex {\n+impl StaticMutex {\n     /// Creates a new mutex for use.\n     ///\n     /// Behavior is undefined if the mutex is moved after it is\n     /// first used with any of the functions below.\n-    /// Also, until `init` is called, behavior is undefined if this\n-    /// mutex is ever used reentrantly, i.e., `raw_lock` or `try_lock`\n-    /// are called by the thread currently holding the lock.\n+    /// Also, the behavior is undefined if this mutex is ever used reentrantly,\n+    /// i.e., `lock` is called by the thread currently holding the lock.\n     #[rustc_const_stable(feature = \"const_sys_mutex_new\", since = \"1.0.0\")]\n-    pub const fn new() -> Mutex {\n-        Mutex(imp::Mutex::new())\n+    pub const fn new() -> Self {\n+        Self(imp::Mutex::new())\n     }\n \n-    /// Prepare the mutex for use.\n+    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n+    /// will be unlocked.\n     ///\n-    /// This should be called once the mutex is at a stable memory address.\n-    /// If called, this must be the very first thing that happens to the mutex.\n-    /// Calling it in parallel with or after any operation (including another\n-    /// `init()`) is undefined behavior.\n+    /// It is undefined behaviour to call this function while locked, or if the\n+    /// mutex has been moved since the last time this was called.\n     #[inline]\n-    pub unsafe fn init(&mut self) {\n-        self.0.init()\n+    pub unsafe fn lock(&self) -> StaticMutexGuard<'_> {\n+        self.0.lock();\n+        StaticMutexGuard(&self.0)\n     }\n+}\n \n-    /// Locks the mutex blocking the current thread until it is available.\n-    ///\n-    /// Behavior is undefined if the mutex has been moved between this and any\n-    /// previous function call.\n+#[must_use]\n+pub struct StaticMutexGuard<'a>(&'a imp::Mutex);\n+\n+impl Drop for StaticMutexGuard<'_> {\n     #[inline]\n-    pub unsafe fn raw_lock(&self) {\n-        self.0.lock()\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.0.unlock();\n+        }\n     }\n+}\n \n-    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n-    /// will be unlocked.\n+/// An OS-based mutual exclusion lock.\n+///\n+/// This mutex does *not* have a const constructor, cleans up its resources in\n+/// its `Drop` implementation, may safely be moved (when not borrowed), and\n+/// does not cause UB when used reentrantly.\n+///\n+/// This mutex does not implement poisoning.\n+///\n+/// This is a wrapper around `Box<imp::Mutex>`, to allow the object to be moved\n+/// without moving the raw mutex.\n+pub struct MovableMutex(Box<imp::Mutex>);\n+\n+unsafe impl Sync for MovableMutex {}\n+\n+impl MovableMutex {\n+    /// Creates a new mutex.\n+    pub fn new() -> Self {\n+        let mut mutex = box imp::Mutex::new();\n+        unsafe { mutex.init() };\n+        Self(mutex)\n+    }\n+\n+    pub(crate) fn raw(&self) -> &imp::Mutex {\n+        &self.0\n+    }\n+\n+    /// Locks the mutex blocking the current thread until it is available.\n     #[inline]\n-    pub unsafe fn lock(&self) -> MutexGuard<'_> {\n-        self.raw_lock();\n-        MutexGuard(&self.0)\n+    pub fn raw_lock(&self) {\n+        unsafe { self.0.lock() }\n     }\n \n     /// Attempts to lock the mutex without blocking, returning whether it was\n     /// successfully acquired or not.\n-    ///\n-    /// Behavior is undefined if the mutex has been moved between this and any\n-    /// previous function call.\n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        self.0.try_lock()\n+    pub fn try_lock(&self) -> bool {\n+        unsafe { self.0.try_lock() }\n     }\n \n     /// Unlocks the mutex.\n     ///\n     /// Behavior is undefined if the current thread does not actually hold the\n     /// mutex.\n-    ///\n-    /// Consider switching from the pair of raw_lock() and raw_unlock() to\n-    /// lock() whenever possible.\n     #[inline]\n     pub unsafe fn raw_unlock(&self) {\n         self.0.unlock()\n     }\n-\n-    /// Deallocates all resources associated with this mutex.\n-    ///\n-    /// Behavior is undefined if there are current or will be future users of\n-    /// this mutex.\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        self.0.destroy()\n-    }\n }\n \n-// not meant to be exported to the outside world, just the containing module\n-pub fn raw(mutex: &Mutex) -> &imp::Mutex {\n-    &mutex.0\n-}\n-\n-#[must_use]\n-/// A simple RAII utility for the above Mutex without the poisoning semantics.\n-pub struct MutexGuard<'a>(&'a imp::Mutex);\n-\n-impl Drop for MutexGuard<'_> {\n-    #[inline]\n+impl Drop for MovableMutex {\n     fn drop(&mut self) {\n-        unsafe {\n-            self.0.unlock();\n-        }\n+        unsafe { self.0.destroy() };\n     }\n }"}, {"sha": "dbcb7b36265f5941c929b6eb2be8df3c823dacc1", "filename": "library/std/src/sys_common/thread_local_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -53,7 +53,7 @@ mod tests;\n \n use crate::sync::atomic::{self, AtomicUsize, Ordering};\n use crate::sys::thread_local_key as imp;\n-use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n \n /// A type for TLS keys that are statically allocated.\n ///\n@@ -157,7 +157,7 @@ impl StaticKey {\n         if imp::requires_synchronized_create() {\n             // We never call `INIT_LOCK.init()`, so it is UB to attempt to\n             // acquire this mutex reentrantly!\n-            static INIT_LOCK: Mutex = Mutex::new();\n+            static INIT_LOCK: StaticMutex = StaticMutex::new();\n             let _guard = INIT_LOCK.lock();\n             let mut key = self.key.load(Ordering::SeqCst);\n             if key == 0 {"}, {"sha": "087175bb92ab3182600e06926a5dd8d64a52b26d", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -972,9 +972,8 @@ pub struct ThreadId(NonZeroU64);\n impl ThreadId {\n     // Generate a new unique thread ID.\n     fn new() -> ThreadId {\n-        // We never call `GUARD.init()`, so it is UB to attempt to\n-        // acquire this mutex reentrantly!\n-        static GUARD: mutex::Mutex = mutex::Mutex::new();\n+        // It is UB to attempt to acquire this mutex reentrantly!\n+        static GUARD: mutex::StaticMutex = mutex::StaticMutex::new();\n         static mut COUNTER: u64 = 1;\n \n         unsafe {"}, {"sha": "e7df38411478d804809c08099af839d170552006", "filename": "library/std/src/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -20,7 +20,7 @@ use crate::error::Error;\n use crate::fmt;\n use crate::ops::{Add, AddAssign, Sub, SubAssign};\n use crate::sys::time;\n-use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::FromInner;\n \n #[stable(feature = \"time\", since = \"1.3.0\")]\n@@ -243,7 +243,7 @@ impl Instant {\n             return Instant(os_now);\n         }\n \n-        static LOCK: Mutex = Mutex::new();\n+        static LOCK: StaticMutex = StaticMutex::new();\n         static mut LAST_NOW: time::Instant = time::Instant::zero();\n         unsafe {\n             let _lock = LOCK.lock();"}, {"sha": "10546de17641ddb17ece871e5dd66b843912c874", "filename": "library/test/src/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fbench.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -159,7 +159,7 @@ where\n             return summ5;\n         }\n \n-        total_run = total_run + loop_run;\n+        total_run += loop_run;\n         // Longest we ever run for is 3s.\n         if total_run > Duration::from_secs(3) {\n             return summ5;"}, {"sha": "8c90b57b3bac3fa420388446c7db57241d3989f3", "filename": "library/test/src/formatters/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -139,7 +139,7 @@ impl<T: Write> PrettyFormatter<T> {\n                 stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n                 stdouts.push_str(&output);\n-                stdouts.push_str(\"\\n\");\n+                stdouts.push('\\n');\n             }\n         }\n         if !stdouts.is_empty() {"}, {"sha": "1ae7846a99e3a1ffee1cb87c2210c3cc34c54199", "filename": "library/test/src/formatters/terse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -114,7 +114,7 @@ impl<T: Write> TerseFormatter<T> {\n                 stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n                 stdouts.push_str(&output);\n-                stdouts.push_str(\"\\n\");\n+                stdouts.push('\\n');\n             }\n         }\n         if !stdouts.is_empty() {\n@@ -140,7 +140,7 @@ impl<T: Write> TerseFormatter<T> {\n                 fail_out.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n                 fail_out.push_str(&output);\n-                fail_out.push_str(\"\\n\");\n+                fail_out.push('\\n');\n             }\n         }\n         if !fail_out.is_empty() {"}, {"sha": "b0b81f85fe08fe12c3a0d0eb4fb624a2fab92ce9", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -237,11 +237,9 @@ where\n     let event = TestEvent::TeFiltered(filtered_descs);\n     notify_about_test_event(event)?;\n \n-    let (filtered_tests, filtered_benchs): (Vec<_>, _) =\n-        filtered_tests.into_iter().partition(|e| match e.testfn {\n-            StaticTestFn(_) | DynTestFn(_) => true,\n-            _ => false,\n-        });\n+    let (filtered_tests, filtered_benchs): (Vec<_>, _) = filtered_tests\n+        .into_iter()\n+        .partition(|e| matches!(e.testfn, StaticTestFn(_) | DynTestFn(_)));\n \n     let concurrency = opts.test_threads.unwrap_or_else(get_concurrency);\n "}, {"sha": "53f3889447453fa810126ed8dd78f1de9e74fca3", "filename": "library/test/src/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/library%2Ftest%2Fsrc%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fstats.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -199,7 +199,7 @@ impl Stats for [f64] {\n             let mut v: f64 = 0.0;\n             for s in self {\n                 let x = *s - mean;\n-                v = v + x * x;\n+                v += x * x;\n             }\n             // N.B., this is _supposed to be_ len-1, not len. If you\n             // change it back to len, you will be calculating a"}, {"sha": "a1efe181843b201a0c7ab1cf6c0ae7e7ed8f6aa1", "filename": "src/test/ui/extern/auxiliary/extern-types-inherent-impl.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftest%2Fui%2Fextern%2Fauxiliary%2Fextern-types-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftest%2Fui%2Fextern%2Fauxiliary%2Fextern-types-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fauxiliary%2Fextern-types-inherent-impl.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -0,0 +1,9 @@\n+#![feature(extern_types)]\n+\n+extern \"C\" {\n+    pub type CrossCrate;\n+}\n+\n+impl CrossCrate {\n+    pub fn foo(&self) {}\n+}"}, {"sha": "3f09ac7b8c38881e52da9cced831cd2cb0366c66", "filename": "src/test/ui/extern/extern-types-inherent-impl.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftest%2Fui%2Fextern%2Fextern-types-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftest%2Fui%2Fextern%2Fextern-types-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-types-inherent-impl.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1,19 +1,26 @@\n-// run-pass\n-#![allow(dead_code)]\n // Test that inherent impls can be defined for extern types.\n \n+// check-pass\n+// aux-build:extern-types-inherent-impl.rs\n+\n #![feature(extern_types)]\n \n-extern {\n-    type A;\n+extern crate extern_types_inherent_impl;\n+use extern_types_inherent_impl::CrossCrate;\n+\n+extern \"C\" {\n+    type Local;\n }\n \n-impl A {\n-    fn foo(&self) { }\n+impl Local {\n+    fn foo(&self) {}\n }\n \n-fn use_foo(x: &A) {\n+fn use_foo(x: &Local, y: &CrossCrate) {\n+    Local::foo(x);\n     x.foo();\n+    CrossCrate::foo(y);\n+    y.foo();\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "093d6601d4e2e6063d7267cfe1abeebff01f6c3a", "filename": "src/test/ui/issues/issue-54062.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftest%2Fui%2Fissues%2Fissue-54062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftest%2Fui%2Fissues%2Fissue-54062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54062.rs?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -7,7 +7,6 @@ struct Test {\n fn main() {}\n \n fn testing(test: Test) {\n-    let _ = test.comps.inner.lock().unwrap();\n+    let _ = test.comps.inner.try_lock();\n     //~^ ERROR: field `inner` of struct `Mutex` is private\n-    //~| ERROR: no method named `unwrap` found\n }"}, {"sha": "5361ee1d3455fdb6ed5a3db964b899127c75225d", "filename": "src/test/ui/issues/issue-54062.stderr", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftest%2Fui%2Fissues%2Fissue-54062.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftest%2Fui%2Fissues%2Fissue-54062.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54062.stderr?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -1,16 +1,9 @@\n error[E0616]: field `inner` of struct `Mutex` is private\n   --> $DIR/issue-54062.rs:10:24\n    |\n-LL |     let _ = test.comps.inner.lock().unwrap();\n+LL |     let _ = test.comps.inner.try_lock();\n    |                        ^^^^^ private field\n \n-error[E0599]: no method named `unwrap` found for struct `std::sys_common::mutex::MutexGuard<'_>` in the current scope\n-  --> $DIR/issue-54062.rs:10:37\n-   |\n-LL |     let _ = test.comps.inner.lock().unwrap();\n-   |                                     ^^^^^^ method not found in `std::sys_common::mutex::MutexGuard<'_>`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0599, E0616.\n-For more information about an error, try `rustc --explain E0599`.\n+For more information about this error, try `rustc --explain E0616`."}, {"sha": "33613e2dc107b07d07c420d803cb74716837c448", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/f283d3f02cf3ed261a519afe05cde9e23d1d9278/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=f283d3f02cf3ed261a519afe05cde9e23d1d9278", "patch": "@@ -157,9 +157,6 @@ def issue(\n \n         cc @{}, do you think you would have time to do the follow-up work?\n         If so, that would be great!\n-\n-        And nominating for compiler team prioritization.\n-\n         ''').format(\n             relevant_pr_number, tool, status_description,\n             REPOS.get(tool), relevant_pr_user"}]}