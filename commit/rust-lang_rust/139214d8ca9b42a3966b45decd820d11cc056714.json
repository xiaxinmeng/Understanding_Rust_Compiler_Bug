{"sha": "139214d8ca9b42a3966b45decd820d11cc056714", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzOTIxNGQ4Y2E5YjQyYTM5NjZiNDVkZWNkODIwZDExY2MwNTY3MTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-14T14:45:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-14T14:45:03Z"}, "message": "Merge #5373\n\n5373: Clenup diagnostics tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "146be3b1949f368d061f0b813564b31c7b619787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/146be3b1949f368d061f0b813564b31c7b619787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/139214d8ca9b42a3966b45decd820d11cc056714", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfDcTvCRBK7hj4Ov3rIwAAdHIIAHlpuucJFwBTzadAUHlLc+73\n7OeNiYz6k+7MY0/fOeWV5XwQHiLDmF1zrR9A1LKJBDL2/FfFphQ3D31dONHV1wRr\nb8vd5uqeEL3yndrwvoZ/avqJDxCFDOEg7OgAgQFJ0VF8X7hNuaL/X2EabGOKanJo\nzpQnWKGtZbCIAUbgoWZRCtodAxFXxVVz1IiZPFdItFtXZYlDFkfxG1x/D763Ygp9\nK+7kh74kYamrq0wwGYMZMJn+WW0FBnVM+iAhqvXaix/rLLEmZkFPhTHAw5KSoZKU\nkqEFn97YVuPP7EqiAgAyGEi2fUFMHMAw+9SrUKz9TEwu95ONwHLeX7m7soBjVgA=\n=OWmM\n-----END PGP SIGNATURE-----\n", "payload": "tree 146be3b1949f368d061f0b813564b31c7b619787\nparent 5a25cc28204c6d02a5108b13568ec71914f096a5\nparent 9244967ddf84b7714d0c2f4168c463ffa4e3b4dc\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594737903 +0000\ncommitter GitHub <noreply@github.com> 1594737903 +0000\n\nMerge #5373\n\n5373: Clenup diagnostics tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/139214d8ca9b42a3966b45decd820d11cc056714", "html_url": "https://github.com/rust-lang/rust/commit/139214d8ca9b42a3966b45decd820d11cc056714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/139214d8ca9b42a3966b45decd820d11cc056714/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a25cc28204c6d02a5108b13568ec71914f096a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a25cc28204c6d02a5108b13568ec71914f096a5", "html_url": "https://github.com/rust-lang/rust/commit/5a25cc28204c6d02a5108b13568ec71914f096a5"}, {"sha": "9244967ddf84b7714d0c2f4168c463ffa4e3b4dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9244967ddf84b7714d0c2f4168c463ffa4e3b4dc", "html_url": "https://github.com/rust-lang/rust/commit/9244967ddf84b7714d0c2f4168c463ffa4e3b4dc"}], "stats": {"total": 764, "additions": 278, "deletions": 486}, "files": [{"sha": "c6e56e8c2652fbabc5b2d2dc8c54fb4700f22107", "filename": "baseline.tst", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a25cc28204c6d02a5108b13568ec71914f096a5/baseline.tst", "raw_url": "https://github.com/rust-lang/rust/raw/5a25cc28204c6d02a5108b13568ec71914f096a5/baseline.tst", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/baseline.tst?ref=5a25cc28204c6d02a5108b13568ec71914f096a5", "patch": "@@ -1,12 +0,0 @@\n-   24ms - SourceRootConfig::partition\n-   24ms - SourceRootConfig::partition\n-   31ms - SourceRootConfig::partition\n-   30ms - SourceRootConfig::partition\n-   35ms - SourceRootConfig::partition\n-   28ms - SourceRootConfig::partition\n-   32ms - SourceRootConfig::partition\n-   26ms - SourceRootConfig::partition\n-   30ms - SourceRootConfig::partition\n-   26ms - SourceRootConfig::partition\n-   32ms - SourceRootConfig::partition\n-   31ms - SourceRootConfig::partition"}, {"sha": "d3ee9cf55609c9168f91101cb25b4bc5a5f7d82b", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 224, "deletions": 16, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=139214d8ca9b42a3966b45decd820d11cc056714", "patch": "@@ -246,25 +246,233 @@ impl AstDiagnostic for MismatchedArgCount {\n }\n \n #[cfg(test)]\n-fn check_diagnostics(ra_fixture: &str) {\n-    use ra_db::{fixture::WithFixture, FileId};\n-    use ra_syntax::TextRange;\n+mod tests {\n+    use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId};\n+    use hir_expand::diagnostics::{Diagnostic, DiagnosticSink};\n+    use ra_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n+    use ra_syntax::{TextRange, TextSize};\n     use rustc_hash::FxHashMap;\n \n-    use crate::test_db::TestDB;\n+    use crate::{diagnostics::validate_body, test_db::TestDB};\n+\n+    impl TestDB {\n+        fn diagnostics<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n+            let crate_graph = self.crate_graph();\n+            for krate in crate_graph.iter() {\n+                let crate_def_map = self.crate_def_map(krate);\n+\n+                let mut fns = Vec::new();\n+                for (module_id, _) in crate_def_map.modules.iter() {\n+                    for decl in crate_def_map[module_id].scope.declarations() {\n+                        if let ModuleDefId::FunctionId(f) = decl {\n+                            fns.push(f)\n+                        }\n+                    }\n+\n+                    for impl_id in crate_def_map[module_id].scope.impls() {\n+                        let impl_data = self.impl_data(impl_id);\n+                        for item in impl_data.items.iter() {\n+                            if let AssocItemId::FunctionId(f) = item {\n+                                fns.push(*f)\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                for f in fns {\n+                    let mut sink = DiagnosticSink::new(&mut cb);\n+                    validate_body(self, f.into(), &mut sink);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn check_diagnostics(ra_fixture: &str) {\n+        let db = TestDB::with_files(ra_fixture);\n+        let annotations = db.extract_annotations();\n+\n+        let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n+        db.diagnostics(|d| {\n+            // FXIME: macros...\n+            let file_id = d.source().file_id.original_file(&db);\n+            let range = d.syntax_node(&db).text_range();\n+            let message = d.message().to_owned();\n+            actual.entry(file_id).or_default().push((range, message));\n+        });\n+\n+        for (file_id, diags) in actual.iter_mut() {\n+            diags.sort_by_key(|it| it.0.start());\n+            let text = db.file_text(*file_id);\n+            // For multiline spans, place them on line start\n+            for (range, content) in diags {\n+                if text[*range].contains('\\n') {\n+                    *range = TextRange::new(range.start(), range.start() + TextSize::from(1));\n+                    *content = format!(\"... {}\", content);\n+                }\n+            }\n+        }\n+\n+        assert_eq!(annotations, actual);\n+    }\n+\n+    #[test]\n+    fn no_such_field_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+impl S {\n+    fn new() -> S {\n+        S {\n+        //^... Missing structure fields:\n+        //|    - bar\n+            foo: 92,\n+            baz: 62,\n+          //^^^^^^^ no such field\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct MyStruct {\n+    my_val: usize,\n+    #[cfg(feature = \"foo\")]\n+    bar: bool,\n+}\n+\n+impl MyStruct {\n+    #[cfg(feature = \"foo\")]\n+    pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n+        Self { my_val, bar }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n+        Self { my_val }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_enum_with_feature_flag_diagnostics() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+enum Foo {\n+    #[cfg(not(feature = \"foo\"))]\n+    Buz,\n+    #[cfg(feature = \"foo\")]\n+    Bar,\n+    Baz\n+}\n+\n+fn test_fn(f: Foo) {\n+    match f {\n+        Foo::Bar => {},\n+        Foo::Baz => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct S {\n+    #[cfg(feature = \"foo\")]\n+    foo: u32,\n+    #[cfg(not(feature = \"foo\"))]\n+    bar: u32,\n+}\n+\n+impl S {\n+    #[cfg(feature = \"foo\")]\n+    fn new(foo: u32) -> Self {\n+        Self { foo }\n+    }\n+    #[cfg(not(feature = \"foo\"))]\n+    fn new(bar: u32) -> Self {\n+        Self { bar }\n+    }\n+    fn new2(bar: u32) -> Self {\n+        #[cfg(feature = \"foo\")]\n+        { Self { foo: bar } }\n+        #[cfg(not(feature = \"foo\"))]\n+        { Self { bar } }\n+    }\n+    fn new2(val: u32) -> Self {\n+        Self {\n+            #[cfg(feature = \"foo\")]\n+            foo: val,\n+            #[cfg(not(feature = \"foo\"))]\n+            bar: val,\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n \n-    let db = TestDB::with_files(ra_fixture);\n-    let annotations = db.extract_annotations();\n+    #[test]\n+    fn no_such_field_with_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type { () => { u32 }; }\n+struct Foo { bar: Type![] }\n \n-    let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n-    db.diag(|d| {\n-        // FXIME: macros...\n-        let file_id = d.source().file_id.original_file(&db);\n-        let range = d.syntax_node(&db).text_range();\n-        let message = d.message().to_owned();\n-        actual.entry(file_id).or_default().push((range, message));\n-    });\n-    actual.values_mut().for_each(|diags| diags.sort_by_key(|it| it.0.start()));\n+impl Foo {\n+    fn new() -> Self {\n+        Foo { bar: 0 }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) {\n+    let S { foo: _ } = s;\n+        //^^^^^^^^^^ Missing structure fields:\n+        //         | - bar\n+}\n+\"#,\n+        );\n+    }\n \n-    assert_eq!(annotations, actual);\n+    #[test]\n+    fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n+        check_diagnostics(\n+            r\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) -> i32 {\n+    match s {\n+        S { foo, .. } => foo,\n+    }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn break_outside_of_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() { break; }\n+         //^^^^^ break outside of loop\n+\"#,\n+        );\n+    }\n }"}, {"sha": "91caedc3df52c6cece4a626af89a1736f2a22618", "filename": "crates/ra_hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=139214d8ca9b42a3966b45decd820d11cc056714", "patch": "@@ -376,7 +376,7 @@ pub fn record_pattern_missing_fields(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::check_diagnostics;\n+    use crate::diagnostics::tests::check_diagnostics;\n \n     #[test]\n     fn simple_free_fn_zero() {"}, {"sha": "507edcb7def8ca3cb8fcc629fb0ba0b260bbb895", "filename": "crates/ra_hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=139214d8ca9b42a3966b45decd820d11cc056714", "patch": "@@ -837,7 +837,7 @@ fn enum_variant_matches(cx: &MatchCheckCtx, pat_id: PatId, enum_variant_id: Enum\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::check_diagnostics;\n+    use crate::diagnostics::tests::check_diagnostics;\n \n     #[test]\n     fn empty_tuple() {"}, {"sha": "9e4ed9a8b7f48161aef29dd9981442b71f8c288a", "filename": "crates/ra_hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=139214d8ca9b42a3966b45decd820d11cc056714", "patch": "@@ -121,3 +121,53 @@ fn walk_unsafe(\n         walk_unsafe(unsafe_exprs, db, infer, body, child, inside_unsafe_block);\n     });\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_raw_ptr() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    unsafe { let y = *x; }\n+    let z = *x;\n+}         //^^ This operation is unsafe and requires an unsafe function or block\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_unsafe_call() {\n+        check_diagnostics(\n+            r#\"\n+struct HasUnsafe;\n+\n+impl HasUnsafe {\n+    unsafe fn unsafe_fn(&self) {\n+        let x = &5 as *const usize;\n+        let y = *x;\n+    }\n+}\n+\n+unsafe fn unsafe_fn() {\n+    let x = &5 as *const usize;\n+    let y = *x;\n+}\n+\n+fn main() {\n+    unsafe_fn();\n+  //^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    HasUnsafe.unsafe_fn();\n+  //^^^^^^^^^^^^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    unsafe {\n+        unsafe_fn();\n+        HasUnsafe.unsafe_fn();\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "a1714ff0fcd7da04b0dc852d47a5cb39f85c7b70", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=139214d8ca9b42a3966b45decd820d11cc056714", "patch": "@@ -5,19 +5,13 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n-use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId, ModuleId};\n-use hir_expand::{\n-    db::AstDatabase,\n-    diagnostics::{Diagnostic, DiagnosticSink},\n-};\n+use hir_def::{db::DefDatabase, ModuleId};\n+use hir_expand::db::AstDatabase;\n use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast};\n use ra_syntax::TextRange;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use stdx::format_to;\n use test_utils::extract_annotations;\n \n-use crate::diagnostics::validate_body;\n-\n #[salsa::database(\n     ra_db::SourceDatabaseExtStorage,\n     ra_db::SourceDatabaseStorage,\n@@ -94,46 +88,6 @@ impl TestDB {\n         panic!(\"Can't find module for file\")\n     }\n \n-    pub(crate) fn diag<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n-        let crate_graph = self.crate_graph();\n-        for krate in crate_graph.iter() {\n-            let crate_def_map = self.crate_def_map(krate);\n-\n-            let mut fns = Vec::new();\n-            for (module_id, _) in crate_def_map.modules.iter() {\n-                for decl in crate_def_map[module_id].scope.declarations() {\n-                    if let ModuleDefId::FunctionId(f) = decl {\n-                        fns.push(f)\n-                    }\n-                }\n-\n-                for impl_id in crate_def_map[module_id].scope.impls() {\n-                    let impl_data = self.impl_data(impl_id);\n-                    for item in impl_data.items.iter() {\n-                        if let AssocItemId::FunctionId(f) = item {\n-                            fns.push(*f)\n-                        }\n-                    }\n-                }\n-            }\n-\n-            for f in fns {\n-                let mut sink = DiagnosticSink::new(&mut cb);\n-                validate_body(self, f.into(), &mut sink);\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn diagnostics(&self) -> (String, u32) {\n-        let mut buf = String::new();\n-        let mut count = 0;\n-        self.diag(|d| {\n-            format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-            count += 1;\n-        });\n-        (buf, count)\n-    }\n-\n     pub(crate) fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n         let mut files = Vec::new();\n         let crate_graph = self.crate_graph();"}, {"sha": "d57b3f288588266cd4dddaeb37821623a1af3067", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 0, "deletions": 408, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/139214d8ca9b42a3966b45decd820d11cc056714/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=139214d8ca9b42a3966b45decd820d11cc056714", "patch": "@@ -20,7 +20,6 @@ use hir_def::{\n     AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n-use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, FileRange, SourceDatabase, SourceDatabaseExt};\n use ra_syntax::{\n     algo,\n@@ -341,410 +340,3 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }\n }\n-\n-#[test]\n-fn no_such_field_diagnostics() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        //- /lib.rs\n-        struct S { foo: i32, bar: () }\n-        impl S {\n-            fn new() -> S {\n-                S {\n-                    foo: 92,\n-                    baz: 62,\n-                }\n-            }\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\n-    \"baz: 62\": no such field\n-    \"{\\n            foo: 92,\\n            baz: 62,\\n        }\": Missing structure fields:\n-    - bar\n-    \"###\n-    );\n-}\n-\n-#[test]\n-fn no_such_field_with_feature_flag_diagnostics() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        struct MyStruct {\n-            my_val: usize,\n-            #[cfg(feature = \"foo\")]\n-            bar: bool,\n-        }\n-\n-        impl MyStruct {\n-            #[cfg(feature = \"foo\")]\n-            pub(crate) fn new(my_val: usize, bar: bool) -> Self {\n-                Self { my_val, bar }\n-            }\n-\n-            #[cfg(not(feature = \"foo\"))]\n-            pub(crate) fn new(my_val: usize, _bar: bool) -> Self {\n-                Self { my_val }\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_enum_with_feature_flag_diagnostics() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        enum Foo {\n-            #[cfg(not(feature = \"foo\"))]\n-            Buz,\n-            #[cfg(feature = \"foo\")]\n-            Bar,\n-            Baz\n-        }\n-\n-        fn test_fn(f: Foo) {\n-            match f {\n-                Foo::Bar => {},\n-                Foo::Baz => {},\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        struct S {\n-            #[cfg(feature = \"foo\")]\n-            foo: u32,\n-            #[cfg(not(feature = \"foo\"))]\n-            bar: u32,\n-        }\n-\n-        impl S {\n-            #[cfg(feature = \"foo\")]\n-            fn new(foo: u32) -> Self {\n-                Self { foo }\n-            }\n-            #[cfg(not(feature = \"foo\"))]\n-            fn new(bar: u32) -> Self {\n-                Self { bar }\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_with_feature_flag_diagnostics_on_block_expr() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        struct S {\n-            #[cfg(feature = \"foo\")]\n-            foo: u32,\n-            #[cfg(not(feature = \"foo\"))]\n-            bar: u32,\n-        }\n-\n-        impl S {\n-            fn new(bar: u32) -> Self {\n-                #[cfg(feature = \"foo\")]\n-                {\n-                Self { foo: bar }\n-                }\n-                #[cfg(not(feature = \"foo\"))]\n-                {\n-                Self { bar }\n-                }\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_with_feature_flag_diagnostics_on_struct_fields() {\n-    let diagnostics = TestDB::with_files(\n-        r#\"\n-        //- /lib.rs crate:foo cfg:feature=foo\n-        struct S {\n-            #[cfg(feature = \"foo\")]\n-            foo: u32,\n-            #[cfg(not(feature = \"foo\"))]\n-            bar: u32,\n-        }\n-\n-        impl S {\n-            fn new(val: u32) -> Self {\n-                Self {\n-                    #[cfg(feature = \"foo\")]\n-                    foo: val,\n-                    #[cfg(not(feature = \"foo\"))]\n-                    bar: val,\n-                }\n-            }\n-        }\n-        \"#,\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn no_such_field_with_type_macro() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        macro_rules! Type {\n-            () => { u32 };\n-        }\n-\n-        struct Foo {\n-            bar: Type![],\n-        }\n-        impl Foo {\n-            fn new() -> Self {\n-                Foo { bar: 0 }\n-            }\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"###);\n-}\n-\n-#[test]\n-fn missing_record_pat_field_diagnostic() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        //- /lib.rs\n-        struct S { foo: i32, bar: () }\n-        fn baz(s: S) {\n-            let S { foo: _ } = s;\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\n-    \"{ foo: _ }\": Missing structure fields:\n-    - bar\n-    \"###\n-    );\n-}\n-\n-#[test]\n-fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        //- /lib.rs\n-        struct S { foo: i32, bar: () }\n-        fn baz(s: S) -> i32 {\n-            match s {\n-                S { foo, .. } => foo,\n-            }\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @\"\");\n-}\n-\n-#[test]\n-fn missing_unsafe_diagnostic_with_raw_ptr() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-//- /lib.rs\n-fn missing_unsafe() {\n-    let x = &5 as *const usize;\n-    let y = *x;\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r#\"\"*x\": This operation is unsafe and requires an unsafe function or block\"#);\n-}\n-\n-#[test]\n-fn missing_unsafe_diagnostic_with_unsafe_call() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-//- /lib.rs\n-unsafe fn unsafe_fn() {\n-    let x = &5 as *const usize;\n-    let y = *x;\n-}\n-\n-fn missing_unsafe() {\n-    unsafe_fn();\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r#\"\"unsafe_fn()\": This operation is unsafe and requires an unsafe function or block\"#);\n-}\n-\n-#[test]\n-fn missing_unsafe_diagnostic_with_unsafe_method_call() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-struct HasUnsafe;\n-\n-impl HasUnsafe {\n-    unsafe fn unsafe_fn(&self) {\n-        let x = &5 as *const usize;\n-        let y = *x;\n-    }\n-}\n-\n-fn missing_unsafe() {\n-    HasUnsafe.unsafe_fn();\n-}\n-\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r#\"\"HasUnsafe.unsafe_fn()\": This operation is unsafe and requires an unsafe function or block\"#);\n-}\n-\n-#[test]\n-fn no_missing_unsafe_diagnostic_with_raw_ptr_in_unsafe_block() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-fn nothing_to_see_move_along() {\n-    let x = &5 as *const usize;\n-    unsafe {\n-        let y = *x;\n-    }\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @\"\");\n-}\n-\n-#[test]\n-fn missing_unsafe_diagnostic_with_raw_ptr_outside_unsafe_block() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-fn nothing_to_see_move_along() {\n-    let x = &5 as *const usize;\n-    unsafe {\n-        let y = *x;\n-    }\n-    let z = *x;\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r#\"\"*x\": This operation is unsafe and requires an unsafe function or block\"#);\n-}\n-\n-#[test]\n-fn no_missing_unsafe_diagnostic_with_unsafe_call_in_unsafe_block() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-unsafe fn unsafe_fn() {\n-    let x = &5 as *const usize;\n-    let y = *x;\n-}\n-\n-fn nothing_to_see_move_along() {\n-    unsafe {\n-        unsafe_fn();\n-    }\n-}\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @\"\");\n-}\n-\n-#[test]\n-fn no_missing_unsafe_diagnostic_with_unsafe_method_call_in_unsafe_block() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-struct HasUnsafe;\n-\n-impl HasUnsafe {\n-    unsafe fn unsafe_fn() {\n-        let x = &5 as *const usize;\n-        let y = *x;\n-    }\n-}\n-\n-fn nothing_to_see_move_along() {\n-    unsafe {\n-        HasUnsafe.unsafe_fn();\n-    }\n-}\n-\n-\",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @\"\");\n-}\n-\n-#[test]\n-fn break_outside_of_loop() {\n-    let diagnostics = TestDB::with_files(\n-        r\"\n-        //- /lib.rs\n-        fn foo() {\n-            break;\n-        }\n-        \",\n-    )\n-    .diagnostics()\n-    .0;\n-\n-    assert_snapshot!(diagnostics, @r###\"\"break\": break outside of loop\n-    \"###\n-    );\n-}"}]}