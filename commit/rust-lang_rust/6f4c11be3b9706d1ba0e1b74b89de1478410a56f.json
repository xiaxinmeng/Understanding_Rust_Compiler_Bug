{"sha": "6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNGMxMWJlM2I5NzA2ZDFiYTBlMWI3NGI4OWRlMTQ3ODQxMGE1NmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-05T20:23:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-05T20:23:10Z"}, "message": "auto merge of #19508 : cmr/rust/rollup-2014_12_03, r=cmr", "tree": {"sha": "8ec0009cba1ab83e76481e216c0dc6b34d13bb82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ec0009cba1ab83e76481e216c0dc6b34d13bb82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "html_url": "https://github.com/rust-lang/rust/commit/6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95d17711397d63425688d18140a58723caddff8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/95d17711397d63425688d18140a58723caddff8e", "html_url": "https://github.com/rust-lang/rust/commit/95d17711397d63425688d18140a58723caddff8e"}, {"sha": "33f34bdb4e67e670b6b6979c690c510eab00c135", "url": "https://api.github.com/repos/rust-lang/rust/commits/33f34bdb4e67e670b6b6979c690c510eab00c135", "html_url": "https://github.com/rust-lang/rust/commit/33f34bdb4e67e670b6b6979c690c510eab00c135"}], "stats": {"total": 7368, "additions": 3710, "deletions": 3658}, "files": [{"sha": "3f3b533bbd59b86840f515a0f284c5cb20ddedd7", "filename": "src/doc/guide.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -140,7 +140,7 @@ $ editor main.rs\n ```\n \n Rust files always end in a `.rs` extension. If you're using more than one word\n-in your file name, use an underscore. `hello_world.rs` rather than\n+in your filename, use an underscore. `hello_world.rs` rather than\n `helloworld.rs`.\n \n Now that you've got your file open, type this in:\n@@ -200,7 +200,7 @@ about this difference. Just know that sometimes, you'll see a `!`, and that\n means that you're calling a macro instead of a normal function. Rust implements\n `println!` as a macro rather than a function for good reasons, but that's a\n very advanced topic. You'll learn more when we talk about macros later. One\n-last thing to mention: Rust's macros are significantly different than C macros,\n+last thing to mention: Rust's macros are significantly different from C macros,\n if you've used those. Don't be scared of using macros. We'll get to the details\n eventually, you'll just have to trust us for now.\n \n@@ -595,8 +595,8 @@ let y = if x == 5i { 10i } else { 15i };\n ```\n \n This reveals two interesting things about Rust: it is an expression-based\n-language, and semicolons are different than in other 'curly brace and\n-semicolon'-based languages. These two things are related.\n+language, and semicolons are different from semicolons in other 'curly brace\n+and semicolon'-based languages. These two things are related.\n \n ## Expressions vs. Statements\n \n@@ -1454,7 +1454,7 @@ Both `continue` and `break` are valid in both kinds of loops.\n # Strings\n \n Strings are an important concept for any programmer to master. Rust's string\n-handling system is a bit different than in other languages, due to its systems\n+handling system is a bit different from other languages, due to its systems\n focus. Any time you have a data structure of variable size, things can get\n tricky, and strings are a re-sizable data structure. That said, Rust's strings\n also work differently than in some other systems languages, such as C.\n@@ -2064,8 +2064,8 @@ Great! Next up: let's compare our guess to the secret guess.\n ## Comparing guesses\n \n If you remember, earlier in the guide, we made a `cmp` function that compared\n-two numbers. Let's add that in, along with a `match` statement to compare the\n-guess to the secret guess:\n+two numbers. Let's add that in, along with a `match` statement to compare our\n+guess to the secret number:\n \n ```{rust,ignore}\n use std::io;\n@@ -2861,7 +2861,7 @@ parts of your library. The six levels are:\n * experimental: This item was only recently introduced or is otherwise in a\n   state of flux. It may change significantly, or even be removed. No guarantee\n   of backwards-compatibility.\n-* unstable: This item is still under development, but requires more testing to\n+* unstable: This item is still under development and requires more testing to\n   be considered stable. No guarantee of backwards-compatibility.\n * stable: This item is considered stable, and will not change significantly.\n   Guarantee of backwards-compatibility.\n@@ -5174,12 +5174,12 @@ processor. Rust's semantics lend themselves very nicely to solving a number of\n issues that programmers have with concurrency. Many concurrency errors that are\n runtime errors in other languages are compile-time errors in Rust.\n \n-Rust's concurrency primitive is called a **task**. Tasks are lightweight, and\n-do not share memory in an unsafe manner, preferring message passing to\n-communicate.  It's worth noting that tasks are implemented as a library, and\n-not part of the language.  This means that in the future, other concurrency\n-libraries can be written for Rust to help in specific scenarios.  Here's an\n-example of creating a task:\n+Rust's concurrency primitive is called a **task**. Tasks are similar to\n+threads, and do not share memory in an unsafe manner, preferring message\n+passing to communicate. It's worth noting that tasks are implemented as a\n+library, and not part of the language. This means that in the future, other\n+concurrency libraries can be written for Rust to help in specific scenarios.\n+Here's an example of creating a task:\n \n ```{rust}\n spawn(proc() {"}, {"sha": "47c25548af0ce5baaad773a22fb66f3a9e6aee85", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -522,7 +522,7 @@ The two values of the boolean type are written `true` and `false`.\n ### Symbols\n \n ```{.ebnf .gram}\n-symbol : \"::\" \"->\"\n+symbol : \"::\" | \"->\"\n        | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n        | ',' | ';' ;\n ```"}, {"sha": "7e5918ea39e1edf6173bb397859f20727e69de57", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -54,21 +54,27 @@ def rust_pretty_printer_lookup_function(val):\n       return RustStructPrinter(val, false)\n \n     if enum_member_count == 1:\n-      if enum_members[0].name == None:\n+      first_variant_name = enum_members[0].name\n+      if first_variant_name == None:\n         # This is a singleton enum\n         return rust_pretty_printer_lookup_function(val[enum_members[0]])\n       else:\n-        assert enum_members[0].name.startswith(\"RUST$ENCODED$ENUM$\")\n+        assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n         # This is a space-optimized enum\n-        last_separator_index = enum_members[0].name.rfind(\"$\")\n+        last_separator_index = first_variant_name.rfind(\"$\")\n         second_last_separator_index = first_variant_name.rfind(\"$\", 0, last_separator_index)\n         disr_field_index = first_variant_name[second_last_separator_index + 1 :\n                                               last_separator_index]\n         disr_field_index = int(disr_field_index)\n \n         sole_variant_val = val[enum_members[0]]\n         disr_field = get_field_at_index(sole_variant_val, disr_field_index)\n-        discriminant = int(sole_variant_val[disr_field])\n+        discriminant = sole_variant_val[disr_field]\n+\n+        # If the discriminant field is a fat pointer we have to consider the\n+        # first word as the true discriminant\n+        if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n+            discriminant = discriminant[get_field_at_index(discriminant, 0)]\n \n         if discriminant == 0:\n           null_variant_name = first_variant_name[last_separator_index + 1:]\n@@ -173,7 +179,7 @@ def to_string(self):\n \n class IdentityPrinter:\n   def __init__(self, string):\n-    self.string\n+    self.string = string\n \n   def to_string(self):\n     return self.string"}, {"sha": "7669df36b041d9282aea7e22d7b0f771d7332e86", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -38,9 +38,8 @@\n     \"rt/isaac/randport.cpp\", # public domain\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n-    \"libstd/sync/mpsc_queue.rs\", # BSD\n-    \"libstd/sync/spsc_queue.rs\", # BSD\n-    \"libstd/sync/mpmc_bounded_queue.rs\", # BSD\n+    \"libstd/comm/mpsc_queue.rs\", # BSD\n+    \"libstd/comm/spsc_queue.rs\", # BSD\n     \"test/bench/shootout-binarytrees.rs\", # BSD\n     \"test/bench/shootout-chameneos-redux.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD"}, {"sha": "f4f1a5121d1957a06862c97efa11f89a4fa25c5d", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -138,9 +138,14 @@ def print_enum_val(val, internal_dict):\n         return \"<invalid enum encoding: %s>\" % first_variant_name\n \n       # Read the discriminant\n-      disr_val = val.GetChildAtIndex(0).GetChildAtIndex(disr_field_index).GetValueAsUnsigned()\n+      disr_val = val.GetChildAtIndex(0).GetChildAtIndex(disr_field_index)\n \n-      if disr_val == 0:\n+      # If the discriminant field is a fat pointer we have to consider the\n+      # first word as the true discriminant\n+      if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n+          disr_val = disr_val.GetChildAtIndex(0)\n+\n+      if disr_val.GetValueAsUnsigned() == 0:\n         # Null case: Print the name of the null-variant\n         null_variant_name = first_variant_name[last_separator_index + 1:]\n         return null_variant_name"}, {"sha": "067c235c9ae493a3c17ac452b00fbd05547c0757", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -123,7 +123,59 @@ const MIN_ALIGN: uint = 8;\n           target_arch = \"x86_64\"))]\n const MIN_ALIGN: uint = 16;\n \n-#[cfg(jemalloc)]\n+#[cfg(external_funcs)]\n+mod imp {\n+    extern {\n+        fn rust_allocate(size: uint, align: uint) -> *mut u8;\n+        fn rust_deallocate(ptr: *mut u8, old_size: uint, align: uint);\n+        fn rust_reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8;\n+        fn rust_reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n+                                   align: uint) -> uint;\n+        fn rust_usable_size(size: uint, align: uint) -> uint;\n+        fn rust_stats_print();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        rust_allocate(size, align)\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n+                                     align: uint) -> uint {\n+        rust_reallocate_inplace(ptr, old_size, size, align)\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n+        rust_deallocate(ptr, old_size, align)\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n+                                     align: uint) -> uint {\n+        rust_reallocate_inplace(ptr, old_size, size, align)\n+    }\n+\n+    #[inline]\n+    pub fn usable_size(size: uint, align: uint) -> uint {\n+        unsafe { rust_usable_size(size, align) }\n+    }\n+\n+    #[inline]\n+    pub fn stats_print() {\n+        unsafe { rust_stats_print() }\n+    }\n+}\n+\n+#[cfg(external_crate)]\n+mod imp {\n+    extern crate external;\n+    pub use self::external::{allocate, deallocate, reallocate_inplace, reallocate};\n+    pub use self::external::{usable_size, stats_print};\n+}\n+\n+#[cfg(all(not(external_funcs), not(external_crate), jemalloc))]\n mod imp {\n     use core::option::{None, Option};\n     use core::ptr::{null_mut, null};\n@@ -199,7 +251,7 @@ mod imp {\n     }\n }\n \n-#[cfg(all(not(jemalloc), unix))]\n+#[cfg(all(not(external_funcs), not(external_crate), not(jemalloc), unix))]\n mod imp {\n     use core::cmp;\n     use core::ptr;\n@@ -260,7 +312,7 @@ mod imp {\n     pub fn stats_print() {}\n }\n \n-#[cfg(all(not(jemalloc), windows))]\n+#[cfg(all(not(external_funcs), not(external_crate), not(jemalloc), windows))]\n mod imp {\n     use libc::{c_void, size_t};\n     use libc;"}, {"sha": "1b3657943da6dbad8765c03a668a7ead9fb2ec54", "filename": "src/libcollections/trie/set.rs", "status": "modified", "additions": 125, "deletions": 1, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // FIXME(conventions): implement bounded iterators\n-// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n // FIXME(conventions): replace each_reverse by making iter DoubleEnded\n // FIXME(conventions): implement iter_mut and into_iter\n \n@@ -463,6 +462,90 @@ impl Extend<uint> for TrieSet {\n     }\n }\n \n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl BitOr<TrieSet, TrieSet> for TrieSet {\n+    /// Returns the union of `self` and `rhs` as a new `TrieSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set: TrieSet = a | b;\n+    /// let v: Vec<uint> = set.iter().collect();\n+    /// assert_eq!(v, vec![1u, 2, 3, 4, 5]);\n+    /// ```\n+    fn bitor(&self, rhs: &TrieSet) -> TrieSet {\n+        self.union(rhs).collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl BitAnd<TrieSet, TrieSet> for TrieSet {\n+    /// Returns the intersection of `self` and `rhs` as a new `TrieSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TrieSet = vec![2, 3, 4].into_iter().collect();\n+    ///\n+    /// let set: TrieSet = a & b;\n+    /// let v: Vec<uint> = set.iter().collect();\n+    /// assert_eq!(v, vec![2u, 3]);\n+    /// ```\n+    fn bitand(&self, rhs: &TrieSet) -> TrieSet {\n+        self.intersection(rhs).collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl BitXor<TrieSet, TrieSet> for TrieSet {\n+    /// Returns the symmetric difference of `self` and `rhs` as a new `TrieSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set: TrieSet = a ^ b;\n+    /// let v: Vec<uint> = set.iter().collect();\n+    /// assert_eq!(v, vec![1u, 2, 4, 5]);\n+    /// ```\n+    fn bitxor(&self, rhs: &TrieSet) -> TrieSet {\n+        self.symmetric_difference(rhs).collect()\n+    }\n+}\n+\n+#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+impl Sub<TrieSet, TrieSet> for TrieSet {\n+    /// Returns the difference of `self` and `rhs` as a new `TrieSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+    /// let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set: TrieSet = a - b;\n+    /// let v: Vec<uint> = set.iter().collect();\n+    /// assert_eq!(v, vec![1u, 2]);\n+    /// ```\n+    fn sub(&self, rhs: &TrieSet) -> TrieSet {\n+        self.difference(rhs).collect()\n+    }\n+}\n+\n /// A forward iterator over a set.\n pub struct SetItems<'a> {\n     iter: Entries<'a, ()>\n@@ -569,6 +652,7 @@ impl<'a> Iterator<uint> for UnionItems<'a> {\n mod test {\n     use std::prelude::*;\n     use std::uint;\n+    use vec::Vec;\n \n     use super::TrieSet;\n \n@@ -738,4 +822,44 @@ mod test {\n                     &[1, 5, 9, 13, 19],\n                     &[1, 3, 5, 9, 11, 13, 16, 19, 24]);\n     }\n+\n+    #[test]\n+    fn test_bit_or() {\n+        let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+        let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n+\n+        let set: TrieSet = a | b;\n+        let v: Vec<uint> = set.iter().collect();\n+        assert_eq!(v, vec![1u, 2, 3, 4, 5]);\n+    }\n+\n+    #[test]\n+    fn test_bit_and() {\n+        let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+        let b: TrieSet = vec![2, 3, 4].into_iter().collect();\n+\n+        let set: TrieSet = a & b;\n+        let v: Vec<uint> = set.iter().collect();\n+        assert_eq!(v, vec![2u, 3]);\n+    }\n+\n+    #[test]\n+    fn test_bit_xor() {\n+        let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+        let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n+\n+        let set: TrieSet = a ^ b;\n+        let v: Vec<uint> = set.iter().collect();\n+        assert_eq!(v, vec![1u, 2, 4, 5]);\n+    }\n+\n+    #[test]\n+    fn test_sub() {\n+        let a: TrieSet = vec![1, 2, 3].into_iter().collect();\n+        let b: TrieSet = vec![3, 4, 5].into_iter().collect();\n+\n+        let set: TrieSet = a - b;\n+        let v: Vec<uint> = set.iter().collect();\n+        assert_eq!(v, vec![1u, 2]);\n+    }\n }"}, {"sha": "986e7ef5bc24e9d7d4e97de79ec32cc4bc511a67", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -115,6 +115,22 @@ impl<V> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n \n+    /// Returns the number of elements the `VecMap` can hold without\n+    /// reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    /// let map: VecMap<String> = VecMap::with_capacity(10);\n+    /// assert!(map.capacity() >= 10);\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn capacity(&self) -> uint {\n+        self.v.capacity()\n+    }\n+\n     /// Returns an iterator visiting all keys in ascending order by the keys.\n     /// The iterator's element type is `uint`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]"}, {"sha": "b44b87bd938075cc169a57c652a34c8aafc1dd43", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -137,6 +137,18 @@ pub enum Cow<'a, T, Sized? B: 'a> where B: ToOwned<T> {\n     Owned(T)\n }\n \n+impl<'a, T, Sized? B> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n+    fn clone(&self) -> Cow<'a, T, B> {\n+        match *self {\n+            Borrowed(b) => Borrowed(b),\n+            Owned(ref o) => {\n+                let b: &B = BorrowFrom::borrow_from(o);\n+                Owned(b.to_owned())\n+            },\n+        }\n+    }\n+}\n+\n impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n     /// Acquire a mutable reference to the owned form of the data.\n     ///"}, {"sha": "ed4df10120272e934d650140a361032726738fab", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 75, "deletions": 43, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -277,12 +277,9 @@ impl<T> RefCell<T> {\n     /// Returns `None` if the value is currently mutably borrowed.\n     #[unstable = \"may be renamed, depending on global conventions\"]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n-        match self.borrow.get() {\n-            WRITING => None,\n-            borrow => {\n-                self.borrow.set(borrow + 1);\n-                Some(Ref { _parent: self })\n-            }\n+        match BorrowRef::new(&self.borrow) {\n+            Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n+            None => None,\n         }\n     }\n \n@@ -310,12 +307,9 @@ impl<T> RefCell<T> {\n     /// Returns `None` if the value is currently borrowed.\n     #[unstable = \"may be renamed, depending on global conventions\"]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n-        match self.borrow.get() {\n-            UNUSED => {\n-                self.borrow.set(WRITING);\n-                Some(RefMut { _parent: self })\n-            },\n-            _ => None\n+        match BorrowRefMut::new(&self.borrow) {\n+            Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n+            None => None,\n         }\n     }\n \n@@ -368,29 +362,56 @@ impl<T: PartialEq> PartialEq for RefCell<T> {\n     }\n }\n \n-/// Wraps a borrowed reference to a value in a `RefCell` box.\n-#[unstable]\n-pub struct Ref<'b, T:'b> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _parent: &'b RefCell<T>\n+struct BorrowRef<'b> {\n+    _borrow: &'b Cell<BorrowFlag>,\n+}\n+\n+impl<'b> BorrowRef<'b> {\n+    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> {\n+        match borrow.get() {\n+            WRITING => None,\n+            b => {\n+                borrow.set(b + 1);\n+                Some(BorrowRef { _borrow: borrow })\n+            },\n+        }\n+    }\n }\n \n #[unsafe_destructor]\n-#[unstable]\n-impl<'b, T> Drop for Ref<'b, T> {\n+impl<'b> Drop for BorrowRef<'b> {\n     fn drop(&mut self) {\n-        let borrow = self._parent.borrow.get();\n+        let borrow = self._borrow.get();\n         debug_assert!(borrow != WRITING && borrow != UNUSED);\n-        self._parent.borrow.set(borrow - 1);\n+        self._borrow.set(borrow - 1);\n     }\n }\n \n+impl<'b> Clone for BorrowRef<'b> {\n+    fn clone(&self) -> BorrowRef<'b> {\n+        // Since this Ref exists, we know the borrow flag\n+        // is not set to WRITING.\n+        let borrow = self._borrow.get();\n+        debug_assert!(borrow != WRITING && borrow != UNUSED);\n+        self._borrow.set(borrow + 1);\n+        BorrowRef { _borrow: self._borrow }\n+    }\n+}\n+\n+/// Wraps a borrowed reference to a value in a `RefCell` box.\n+#[unstable]\n+pub struct Ref<'b, T:'b> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _value: &'b T,\n+    _borrow: BorrowRef<'b>,\n+}\n+\n #[unstable = \"waiting for `Deref` to become stable\"]\n impl<'b, T> Deref<T> for Ref<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*self._parent.value.get() }\n+        self._value\n     }\n }\n \n@@ -401,49 +422,60 @@ impl<'b, T> Deref<T> for Ref<'b, T> {\n /// A `Clone` implementation would interfere with the widespread\n /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n #[experimental = \"likely to be moved to a method, pending language changes\"]\n-pub fn clone_ref<'b, T>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n-    // Since this Ref exists, we know the borrow flag\n-    // is not set to WRITING.\n-    let borrow = orig._parent.borrow.get();\n-    debug_assert!(borrow != WRITING && borrow != UNUSED);\n-    orig._parent.borrow.set(borrow + 1);\n-\n+pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n     Ref {\n-        _parent: orig._parent,\n+        _value: orig._value,\n+        _borrow: orig._borrow.clone(),\n     }\n }\n \n-/// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n-#[unstable]\n-pub struct RefMut<'b, T:'b> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _parent: &'b RefCell<T>\n+struct BorrowRefMut<'b> {\n+    _borrow: &'b Cell<BorrowFlag>,\n }\n \n #[unsafe_destructor]\n-#[unstable]\n-impl<'b, T> Drop for RefMut<'b, T> {\n+impl<'b> Drop for BorrowRefMut<'b> {\n     fn drop(&mut self) {\n-        let borrow = self._parent.borrow.get();\n+        let borrow = self._borrow.get();\n         debug_assert!(borrow == WRITING);\n-        self._parent.borrow.set(UNUSED);\n+        self._borrow.set(UNUSED);\n     }\n }\n \n+impl<'b> BorrowRefMut<'b> {\n+    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> {\n+        match borrow.get() {\n+            UNUSED => {\n+                borrow.set(WRITING);\n+                Some(BorrowRefMut { _borrow: borrow })\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n+#[unstable]\n+pub struct RefMut<'b, T:'b> {\n+    // FIXME #12808: strange name to try to avoid interfering with\n+    // field accesses of the contained type via Deref\n+    _value: &'b mut T,\n+    _borrow: BorrowRefMut<'b>,\n+}\n+\n #[unstable = \"waiting for `Deref` to become stable\"]\n impl<'b, T> Deref<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*self._parent.value.get() }\n+        self._value\n     }\n }\n \n #[unstable = \"waiting for `DerefMut` to become stable\"]\n impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe { &mut *self._parent.value.get() }\n+        self._value\n     }\n }\n "}, {"sha": "7b9dd70c58f023d1ad481c423234f7ea1af949f8", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -34,6 +34,7 @@ mod float;\n pub mod rt;\n \n #[experimental = \"core and I/O reconciliation may alter this definition\"]\n+/// The type returned by formatter methods.\n pub type Result = result::Result<(), Error>;\n \n /// The error type which is returned from formatting a message into a stream."}, {"sha": "ece2ac6975ed155aa0fe91a0bc76c2bab9804dea", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -10,7 +10,7 @@\n \n //! rustc compiler intrinsics.\n //!\n-//! The corresponding definitions are in librustc/middle/trans/foreign.rs.\n+//! The corresponding definitions are in librustc_trans/trans/intrinsic.rs.\n //!\n //! # Volatiles\n //!"}, {"sha": "f137f43058fa6b64c3a66f9bdd63b08e2840ab7a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -2036,18 +2036,49 @@ for Inspect<'a, A, T> {\n     }\n }\n \n-/// An iterator which just modifies the contained state throughout iteration.\n+/// An iterator which passes mutable state to a closure and yields the result.\n+///\n+/// # Example: The Fibonacci Sequence\n+///\n+/// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n+///\n+/// ```rust\n+/// use std::iter::Unfold;\n+/// use std::num::Int; // For `.checked_add()`\n+///\n+/// // This iterator will yield up to the last Fibonacci number before the max value of `u32`.\n+/// // You can simply change `u32` to `u64` in this line if you want higher values than that.\n+/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)), |&(ref mut x2, ref mut x1)| {\n+///     // Attempt to get the next Fibonacci number\n+///     // `x1` will be `None` if previously overflowed.\n+///     let next = match (*x2, *x1) {\n+///         (Some(x2), Some(x1)) => x2.checked_add(x1),\n+///         _ => None,\n+///     };\n+///\n+///     // Shift left: ret <- x2 <- x1 <- next\n+///     let ret = *x2;\n+///     *x2 = *x1;\n+///     *x1 = next;\n+///\n+///     ret\n+/// });\n+///\n+/// for i in fibonacci {\n+///     println!(\"{}\", i);\n+/// }\n+/// ```\n #[experimental]\n pub struct Unfold<'a, A, St> {\n     f: |&mut St|: 'a -> Option<A>,\n-    /// Internal state that will be yielded on the next iteration\n+    /// Internal state that will be passed to the closure on the next iteration\n     pub state: St,\n }\n \n #[experimental]\n impl<'a, A, St> Unfold<'a, A, St> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n-    /// function\" and an initial state to eventually pass to the iterator\n+    /// function\" and an initial state to eventually pass to the closure\n     #[inline]\n     pub fn new<'a>(initial_state: St, f: |&mut St|: 'a -> Option<A>)\n                -> Unfold<'a, A, St> {"}, {"sha": "748e8942a3fea73887a27278db57b42df7ef848f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -284,7 +284,7 @@ pub trait Int\n     /// ```\n     fn checked_add(self, other: Self) -> Option<Self>;\n \n-    /// Checked integer subtraction. Computes `self + other`, returning `None`\n+    /// Checked integer subtraction. Computes `self - other`, returning `None`\n     /// if underflow occurred.\n     ///\n     /// # Example\n@@ -297,7 +297,7 @@ pub trait Int\n     /// ```\n     fn checked_sub(self, other: Self) -> Option<Self>;\n \n-    /// Checked integer multiplication. Computes `self + other`, returning\n+    /// Checked integer multiplication. Computes `self * other`, returning\n     /// `None` if underflow or overflow occurred.\n     ///\n     /// # Example\n@@ -310,8 +310,8 @@ pub trait Int\n     /// ```\n     fn checked_mul(self, other: Self) -> Option<Self>;\n \n-    /// Checked integer division. Computes `self + other` returning `None` if\n-    /// `self == 0` or the operation results in underflow or overflow.\n+    /// Checked integer division. Computes `self / other`, returning `None` if\n+    /// `other == 0` or the operation results in underflow or overflow.\n     ///\n     /// # Example\n     ///"}, {"sha": "fdc8b9e7400f5a6db3b9da737b2d027f4cec88b8", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -787,7 +787,7 @@ impl<'a, Sized? T> Deref<T> for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n-pub trait DerefMut<Sized? Result>: Deref<Result> {\n+pub trait DerefMut<Sized? Result> for Sized? : Deref<Result> {\n     /// The method called to mutably dereference a value\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Result;\n }"}, {"sha": "ce9f551670bb576f9d93703cb8f74d5915163b49", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -1781,12 +1781,13 @@ pub mod bytes {\n \n     /// Copies data from `src` to `dst`\n     ///\n-    /// `src` and `dst` must not overlap. Panics if the length of `dst`\n-    /// is less than the length of `src`.\n+    /// Panics if the length of `dst` is less than the length of `src`.\n     #[inline]\n     pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n         let len_src = src.len();\n         assert!(dst.len() >= len_src);\n+        // `dst` is unaliasable, so we know statically it doesn't overlap\n+        // with `src`.\n         unsafe {\n             ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(),\n                                             src.as_ptr(),"}, {"sha": "03b65b3f71c846de4445f78c0a7f63e824d45119", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -18,6 +18,11 @@\n #![experimental]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n+       html_playground_url = \"http://play.rust-lang.org/\")]\n+\n #![feature(macro_rules, globs, import_shadowing)]\n pub use self::Piece::*;\n pub use self::Position::*;"}, {"sha": "b0ac98c94e748b3f0404369fb027251f461237b6", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -1428,6 +1428,7 @@ impl LintPass for MissingDoc {\n             ast::ItemEnum(..) => \"an enum\",\n             ast::ItemStruct(..) => \"a struct\",\n             ast::ItemTrait(..) => \"a trait\",\n+            ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n         self.check_missing_docs_attrs(cx, Some(it.id), it.attrs.as_slice(),"}, {"sha": "9861d18ce51f0b245f52f5785487c47a0280db36", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -23,7 +23,6 @@ use syntax::ast_util;\n \n use clean;\n use stability_summary::ModuleSummary;\n-use html::item_type;\n use html::item_type::ItemType;\n use html::render;\n use html::render::{cache, CURRENT_LOCATION_KEY};\n@@ -283,7 +282,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n                 url.push_str(\"/\");\n             }\n             match shortty {\n-                item_type::Module => {\n+                ItemType::Module => {\n                     url.push_str(fqp.last().unwrap().as_slice());\n                     url.push_str(\"/index.html\");\n                 }"}, {"sha": "0ad12b957ba8f868793ae5261a5078035325ce2f", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 55, "deletions": 46, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! Item types.\n-pub use self::ItemType::*;\n \n use std::fmt;\n use clean;\n@@ -35,36 +34,70 @@ pub enum ItemType {\n     Method          = 10,\n     StructField     = 11,\n     Variant         = 12,\n-    ForeignFunction = 13,\n-    ForeignStatic   = 14,\n+    // we used to have ForeignFunction and ForeignStatic. they are retired now.\n     Macro           = 15,\n     Primitive       = 16,\n     AssociatedType  = 17,\n     Constant        = 18,\n }\n \n impl ItemType {\n+    pub fn from_item(item: &clean::Item) -> ItemType {\n+        match item.inner {\n+            clean::ModuleItem(..)          => ItemType::Module,\n+            clean::StructItem(..)          => ItemType::Struct,\n+            clean::EnumItem(..)            => ItemType::Enum,\n+            clean::FunctionItem(..)        => ItemType::Function,\n+            clean::TypedefItem(..)         => ItemType::Typedef,\n+            clean::StaticItem(..)          => ItemType::Static,\n+            clean::ConstantItem(..)        => ItemType::Constant,\n+            clean::TraitItem(..)           => ItemType::Trait,\n+            clean::ImplItem(..)            => ItemType::Impl,\n+            clean::ViewItemItem(..)        => ItemType::ViewItem,\n+            clean::TyMethodItem(..)        => ItemType::TyMethod,\n+            clean::MethodItem(..)          => ItemType::Method,\n+            clean::StructFieldItem(..)     => ItemType::StructField,\n+            clean::VariantItem(..)         => ItemType::Variant,\n+            clean::ForeignFunctionItem(..) => ItemType::Function, // no ForeignFunction\n+            clean::ForeignStaticItem(..)   => ItemType::Static, // no ForeignStatic\n+            clean::MacroItem(..)           => ItemType::Macro,\n+            clean::PrimitiveItem(..)       => ItemType::Primitive,\n+            clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n+        }\n+    }\n+\n+    pub fn from_type_kind(kind: clean::TypeKind) -> ItemType {\n+        match kind {\n+            clean::TypeStruct   => ItemType::Struct,\n+            clean::TypeEnum     => ItemType::Enum,\n+            clean::TypeFunction => ItemType::Function,\n+            clean::TypeTrait    => ItemType::Trait,\n+            clean::TypeModule   => ItemType::Module,\n+            clean::TypeStatic   => ItemType::Static,\n+            clean::TypeVariant  => ItemType::Variant,\n+            clean::TypeTypedef  => ItemType::Typedef,\n+        }\n+    }\n+\n     pub fn to_static_str(&self) -> &'static str {\n         match *self {\n-            Module          => \"mod\",\n-            Struct          => \"struct\",\n-            Enum            => \"enum\",\n-            Function        => \"fn\",\n-            Typedef         => \"type\",\n-            Static          => \"static\",\n-            Trait           => \"trait\",\n-            Impl            => \"impl\",\n-            ViewItem        => \"viewitem\",\n-            TyMethod        => \"tymethod\",\n-            Method          => \"method\",\n-            StructField     => \"structfield\",\n-            Variant         => \"variant\",\n-            ForeignFunction => \"ffi\",\n-            ForeignStatic   => \"ffs\",\n-            Macro           => \"macro\",\n-            Primitive       => \"primitive\",\n-            AssociatedType  => \"associatedtype\",\n-            Constant        => \"constant\",\n+            ItemType::Module          => \"mod\",\n+            ItemType::Struct          => \"struct\",\n+            ItemType::Enum            => \"enum\",\n+            ItemType::Function        => \"fn\",\n+            ItemType::Typedef         => \"type\",\n+            ItemType::Static          => \"static\",\n+            ItemType::Trait           => \"trait\",\n+            ItemType::Impl            => \"impl\",\n+            ItemType::ViewItem        => \"viewitem\",\n+            ItemType::TyMethod        => \"tymethod\",\n+            ItemType::Method          => \"method\",\n+            ItemType::StructField     => \"structfield\",\n+            ItemType::Variant         => \"variant\",\n+            ItemType::Macro           => \"macro\",\n+            ItemType::Primitive       => \"primitive\",\n+            ItemType::AssociatedType  => \"associatedtype\",\n+            ItemType::Constant        => \"constant\",\n         }\n     }\n }\n@@ -75,27 +108,3 @@ impl fmt::Show for ItemType {\n     }\n }\n \n-pub fn shortty(item: &clean::Item) -> ItemType {\n-    match item.inner {\n-        clean::ModuleItem(..)          => Module,\n-        clean::StructItem(..)          => Struct,\n-        clean::EnumItem(..)            => Enum,\n-        clean::FunctionItem(..)        => Function,\n-        clean::TypedefItem(..)         => Typedef,\n-        clean::StaticItem(..)          => Static,\n-        clean::ConstantItem(..)        => Constant,\n-        clean::TraitItem(..)           => Trait,\n-        clean::ImplItem(..)            => Impl,\n-        clean::ViewItemItem(..)        => ViewItem,\n-        clean::TyMethodItem(..)        => TyMethod,\n-        clean::MethodItem(..)          => Method,\n-        clean::StructFieldItem(..)     => StructField,\n-        clean::VariantItem(..)         => Variant,\n-        clean::ForeignFunctionItem(..) => ForeignFunction,\n-        clean::ForeignStaticItem(..)   => ForeignStatic,\n-        clean::MacroItem(..)           => Macro,\n-        clean::PrimitiveItem(..)       => Primitive,\n-        clean::AssociatedTypeItem(..)  => AssociatedType,\n-    }\n-}\n-"}, {"sha": "23f31580619ee8b77cad695ecdb37f46a9699fc3", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -160,13 +160,16 @@ r##\"<!DOCTYPE html>\n }\n \n pub fn redirect(dst: &mut io::Writer, url: &str) -> io::IoResult<()> {\n+    // <script> triggers a redirect before refresh, so this is fine.\n     write!(dst,\n r##\"<!DOCTYPE html>\n <html lang=\"en\">\n <head>\n     <meta http-equiv=\"refresh\" content=\"0;URL={url}\">\n </head>\n <body>\n+    <p>Redirecting to <a href=\"{url}\">{url}</a>...</p>\n+    <script>location.replace(\"{url}\" + location.search + location.hash);</script>\n </body>\n </html>\"##,\n     url = url,"}, {"sha": "9eee8e04f0c2bf505d61406d2eaede7f1a3e0ea0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -61,8 +61,7 @@ use fold::DocFolder;\n use html::format::{VisSpace, Method, FnStyleSpace, MutableSpace, Stability};\n use html::format::{ConciseStability, TyParamBounds, WhereClause};\n use html::highlight;\n-use html::item_type::{ItemType, shortty};\n-use html::item_type;\n+use html::item_type::ItemType;\n use html::layout;\n use html::markdown::Markdown;\n use html::markdown;\n@@ -314,19 +313,8 @@ pub fn run(mut krate: clean::Crate,\n     let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take().unwrap();\n-        paths.into_iter().map(|(k, (v, t))| {\n-            (k, (v, match t {\n-                clean::TypeStruct => item_type::Struct,\n-                clean::TypeEnum => item_type::Enum,\n-                clean::TypeFunction => item_type::Function,\n-                clean::TypeTrait => item_type::Trait,\n-                clean::TypeModule => item_type::Module,\n-                clean::TypeStatic => item_type::Static,\n-                clean::TypeVariant => item_type::Variant,\n-                clean::TypeTypedef => item_type::Typedef,\n-            }))\n-        }).collect()\n-    }).unwrap_or(HashMap::new());\n+        paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t)))).collect()\n+      }).unwrap_or(HashMap::new());\n     let mut cache = Cache {\n         impls: HashMap::new(),\n         external_paths: paths.iter().map(|(&k, v)| (k, v.ref0().clone()))\n@@ -359,7 +347,7 @@ pub fn run(mut krate: clean::Crate,\n     for &(n, ref e) in krate.externs.iter() {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n         let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n-        cache.paths.insert(did, (vec![e.name.to_string()], item_type::Module));\n+        cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n \n     // Cache where all known primitives have their documentation located.\n@@ -642,6 +630,11 @@ fn mkdir(path: &Path) -> io::IoResult<()> {\n     }\n }\n \n+/// Returns a documentation-level item type from the item.\n+fn shortty(item: &clean::Item) -> ItemType {\n+    ItemType::from_item(item)\n+}\n+\n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n /// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n /// static HTML tree.\n@@ -855,13 +848,13 @@ impl DocFolder for Cache {\n                         let last = self.parent_stack.last().unwrap();\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n-                            Some(&(_, item_type::Trait)) =>\n+                            Some(&(_, ItemType::Trait)) =>\n                                 Some(self.stack[..self.stack.len() - 1]),\n                             // The current stack not necessarily has correlation for\n                             // where the type was defined. On the other hand,\n                             // `paths` always has the right information if present.\n-                            Some(&(ref fqp, item_type::Struct)) |\n-                            Some(&(ref fqp, item_type::Enum)) =>\n+                            Some(&(ref fqp, ItemType::Struct)) |\n+                            Some(&(ref fqp, ItemType::Enum)) =>\n                                 Some(fqp[..fqp.len() - 1]),\n                             Some(..) => Some(self.stack.as_slice()),\n                             None => None\n@@ -929,7 +922,7 @@ impl DocFolder for Cache {\n             clean::VariantItem(..) if !self.privmod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n-                self.paths.insert(item.def_id, (stack, item_type::Enum));\n+                self.paths.insert(item.def_id, (stack, ItemType::Enum));\n             }\n \n             clean::PrimitiveItem(..) if item.visibility.is_some() => {\n@@ -1251,6 +1244,10 @@ impl Context {\n         for item in m.items.iter() {\n             if self.ignore_private_item(item) { continue }\n \n+            // avoid putting foreign items to the sidebar.\n+            if let &clean::ForeignFunctionItem(..) = &item.inner { continue }\n+            if let &clean::ForeignStaticItem(..) = &item.inner { continue }\n+\n             let short = shortty(item).to_static_str();\n             let myname = match item.name {\n                 None => continue,\n@@ -1435,7 +1432,8 @@ impl<'a> fmt::Show for Item<'a> {\n             clean::TypedefItem(ref t) => item_typedef(fmt, self.item, t),\n             clean::MacroItem(ref m) => item_macro(fmt, self.item, m),\n             clean::PrimitiveItem(ref p) => item_primitive(fmt, self.item, p),\n-            clean::StaticItem(ref i) => item_static(fmt, self.item, i),\n+            clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n+                item_static(fmt, self.item, i),\n             clean::ConstantItem(ref c) => item_constant(fmt, self.item, c),\n             _ => Ok(())\n         }\n@@ -1490,45 +1488,48 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         !cx.ignore_private_item(&items[*i])\n     }).collect::<Vec<uint>>();\n \n+    // the order of item types in the listing\n+    fn reorder(ty: ItemType) -> u8 {\n+        match ty {\n+            ItemType::ViewItem        => 0,\n+            ItemType::Primitive       => 1,\n+            ItemType::Module          => 2,\n+            ItemType::Macro           => 3,\n+            ItemType::Struct          => 4,\n+            ItemType::Enum            => 5,\n+            ItemType::Constant        => 6,\n+            ItemType::Static          => 7,\n+            ItemType::Trait           => 8,\n+            ItemType::Function        => 9,\n+            ItemType::Typedef         => 10,\n+            _                         => 11 + ty as u8,\n+        }\n+    }\n+\n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n-        if shortty(i1) == shortty(i2) {\n+        let ty1 = shortty(i1);\n+        let ty2 = shortty(i2);\n+        if ty1 == ty2 {\n             return i1.name.cmp(&i2.name);\n         }\n-        match (&i1.inner, &i2.inner) {\n-            (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n-                match (&a.inner, &b.inner) {\n-                    (&clean::ExternCrate(..), _) => Less,\n-                    (_, &clean::ExternCrate(..)) => Greater,\n-                    _ => idx1.cmp(&idx2),\n+\n+        let tycmp = reorder(ty1).cmp(&reorder(ty2));\n+        if let Equal = tycmp {\n+            // for reexports, `extern crate` takes precedence.\n+            match (&i1.inner, &i2.inner) {\n+                (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n+                    match (&a.inner, &b.inner) {\n+                        (&clean::ExternCrate(..), _) => return Less,\n+                        (_, &clean::ExternCrate(..)) => return Greater,\n+                        _ => {}\n+                    }\n                 }\n+                (_, _) => {}\n             }\n-            (&clean::ViewItemItem(..), _) => Less,\n-            (_, &clean::ViewItemItem(..)) => Greater,\n-            (&clean::PrimitiveItem(..), _) => Less,\n-            (_, &clean::PrimitiveItem(..)) => Greater,\n-            (&clean::ModuleItem(..), _) => Less,\n-            (_, &clean::ModuleItem(..)) => Greater,\n-            (&clean::MacroItem(..), _) => Less,\n-            (_, &clean::MacroItem(..)) => Greater,\n-            (&clean::StructItem(..), _) => Less,\n-            (_, &clean::StructItem(..)) => Greater,\n-            (&clean::EnumItem(..), _) => Less,\n-            (_, &clean::EnumItem(..)) => Greater,\n-            (&clean::ConstantItem(..), _) => Less,\n-            (_, &clean::ConstantItem(..)) => Greater,\n-            (&clean::StaticItem(..), _) => Less,\n-            (_, &clean::StaticItem(..)) => Greater,\n-            (&clean::ForeignFunctionItem(..), _) => Less,\n-            (_, &clean::ForeignFunctionItem(..)) => Greater,\n-            (&clean::ForeignStaticItem(..), _) => Less,\n-            (_, &clean::ForeignStaticItem(..)) => Greater,\n-            (&clean::TraitItem(..), _) => Less,\n-            (_, &clean::TraitItem(..)) => Greater,\n-            (&clean::FunctionItem(..), _) => Less,\n-            (_, &clean::FunctionItem(..)) => Greater,\n-            (&clean::TypedefItem(..), _) => Less,\n-            (_, &clean::TypedefItem(..)) => Greater,\n-            _ => idx1.cmp(&idx2),\n+\n+            idx1.cmp(&idx2)\n+        } else {\n+            tycmp\n         }\n     }\n \n@@ -1545,26 +1546,24 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 try!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n-            let (short, name) = match myitem.inner {\n-                clean::ModuleItem(..)          => (\"modules\", \"Modules\"),\n-                clean::StructItem(..)          => (\"structs\", \"Structs\"),\n-                clean::EnumItem(..)            => (\"enums\", \"Enums\"),\n-                clean::FunctionItem(..)        => (\"functions\", \"Functions\"),\n-                clean::TypedefItem(..)         => (\"types\", \"Type Definitions\"),\n-                clean::StaticItem(..)          => (\"statics\", \"Statics\"),\n-                clean::ConstantItem(..)        => (\"constants\", \"Constants\"),\n-                clean::TraitItem(..)           => (\"traits\", \"Traits\"),\n-                clean::ImplItem(..)            => (\"impls\", \"Implementations\"),\n-                clean::ViewItemItem(..)        => (\"reexports\", \"Reexports\"),\n-                clean::TyMethodItem(..)        => (\"tymethods\", \"Type Methods\"),\n-                clean::MethodItem(..)          => (\"methods\", \"Methods\"),\n-                clean::StructFieldItem(..)     => (\"fields\", \"Struct Fields\"),\n-                clean::VariantItem(..)         => (\"variants\", \"Variants\"),\n-                clean::ForeignFunctionItem(..) => (\"ffi-fns\", \"Foreign Functions\"),\n-                clean::ForeignStaticItem(..)   => (\"ffi-statics\", \"Foreign Statics\"),\n-                clean::MacroItem(..)           => (\"macros\", \"Macros\"),\n-                clean::PrimitiveItem(..)       => (\"primitives\", \"Primitive Types\"),\n-                clean::AssociatedTypeItem(..)  => (\"associated-types\", \"Associated Types\"),\n+            let (short, name) = match myty.unwrap() {\n+                ItemType::Module          => (\"modules\", \"Modules\"),\n+                ItemType::Struct          => (\"structs\", \"Structs\"),\n+                ItemType::Enum            => (\"enums\", \"Enums\"),\n+                ItemType::Function        => (\"functions\", \"Functions\"),\n+                ItemType::Typedef         => (\"types\", \"Type Definitions\"),\n+                ItemType::Static          => (\"statics\", \"Statics\"),\n+                ItemType::Constant        => (\"constants\", \"Constants\"),\n+                ItemType::Trait           => (\"traits\", \"Traits\"),\n+                ItemType::Impl            => (\"impls\", \"Implementations\"),\n+                ItemType::ViewItem        => (\"reexports\", \"Reexports\"),\n+                ItemType::TyMethod        => (\"tymethods\", \"Type Methods\"),\n+                ItemType::Method          => (\"methods\", \"Methods\"),\n+                ItemType::StructField     => (\"fields\", \"Struct Fields\"),\n+                ItemType::Variant         => (\"variants\", \"Variants\"),\n+                ItemType::Macro           => (\"macros\", \"Macros\"),\n+                ItemType::Primitive       => (\"primitives\", \"Primitive Types\"),\n+                ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n             };\n             try!(write!(w,\n                         \"<h2 id='{id}' class='section-header'>\\"}, {"sha": "978af31cdc6895a00ae3527149fc33796d3ec25a", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -313,7 +313,8 @@\n             for (var i = results.length - 1; i > 0; i -= 1) {\n                 if (results[i].word === results[i - 1].word &&\n                     results[i].item.ty === results[i - 1].item.ty &&\n-                    results[i].item.path === results[i - 1].item.path)\n+                    results[i].item.path === results[i - 1].item.path &&\n+                    (results[i].item.parent || {}).name === (results[i - 1].item.parent || {}).name)\n                 {\n                     results[i].id = -1;\n                 }\n@@ -566,8 +567,8 @@\n                          \"method\",\n                          \"structfield\",\n                          \"variant\",\n-                         \"ffi\",\n-                         \"ffs\",\n+                         \"ffi\", // retained for backward compatibility\n+                         \"ffs\", // retained for backward compatibility\n                          \"macro\",\n                          \"primitive\",\n                          \"associatedtype\",\n@@ -707,8 +708,8 @@\n                 var code = $('<code>').append(structs[j]);\n                 $.each(code.find('a'), function(idx, a) {\n                     var href = $(a).attr('href');\n-                    if (!href.startsWith('http')) {\n-                        $(a).attr('href', rootPath + $(a).attr('href'));\n+                    if (href && !href.startsWith('http')) {\n+                        $(a).attr('href', rootPath + href);\n                     }\n                 });\n                 var li = $('<li>').append(code);"}, {"sha": "66108bea9885c7ff8004c0ffcb433725f3d155d2", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -12,6 +12,10 @@\n #![experimental]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n+       html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n #![feature(globs, if_let, macro_rules, phase, slicing_syntax, tuple_indexing)]"}, {"sha": "d291ed7256743b224a8e4a4806ce5fb3a6871973", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -354,6 +354,8 @@ mod select;\n mod shared;\n mod stream;\n mod sync;\n+mod mpsc_queue;\n+mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n@@ -628,24 +630,26 @@ impl<T: Send> Sender<T> {\n #[unstable]\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n-        let (packet, sleeper) = match *unsafe { self.inner() } {\n+        let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n             Oneshot(ref p) => {\n                 let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n                 unsafe {\n-                    (*a.get()).postinit_lock();\n+                    let guard = (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n-                        oneshot::UpSuccess | oneshot::UpDisconnected => (a, None),\n-                        oneshot::UpWoke(task) => (a, Some(task))\n+                        oneshot::UpSuccess |\n+                        oneshot::UpDisconnected => (a, None, guard),\n+                        oneshot::UpWoke(task) => (a, Some(task), guard)\n                     }\n                 }\n             }\n             Stream(ref p) => {\n                 let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n                 unsafe {\n-                    (*a.get()).postinit_lock();\n+                    let guard = (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n-                        stream::UpSuccess | stream::UpDisconnected => (a, None),\n-                        stream::UpWoke(task) => (a, Some(task)),\n+                        stream::UpSuccess |\n+                        stream::UpDisconnected => (a, None, guard),\n+                        stream::UpWoke(task) => (a, Some(task), guard),\n                     }\n                 }\n             }\n@@ -657,7 +661,7 @@ impl<T: Send> Clone for Sender<T> {\n         };\n \n         unsafe {\n-            (*packet.get()).inherit_blocker(sleeper);\n+            (*packet.get()).inherit_blocker(sleeper, guard);\n \n             let tmp = Sender::new(Shared(packet.clone()));\n             mem::swap(self.inner_mut(), tmp.inner_mut());"}, {"sha": "d4249abc3dda1188715d076f48b409a5c4cff36a", "filename": "src/libstd/comm/mpsc_queue.rs", "status": "renamed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -132,15 +132,6 @@ impl<T: Send> Queue<T> {\n             if self.head.load(Acquire) == tail {Empty} else {Inconsistent}\n         }\n     }\n-\n-    /// Attempts to pop data from this queue, but doesn't attempt too hard. This\n-    /// will canonicalize inconsistent states to a `None` value.\n-    pub fn casual_pop(&self) -> Option<T> {\n-        match self.pop() {\n-            Data(t) => Some(t),\n-            Empty | Inconsistent => None,\n-        }\n-    }\n }\n \n #[unsafe_destructor]", "previous_filename": "src/libstd/sync/mpsc_queue.rs"}, {"sha": "13b5e10fcd3dcd02cbf2ffb3a95a82cc005fb984", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -26,12 +26,11 @@ use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n use rustrt::local::Local;\n-use rustrt::mutex::NativeMutex;\n use rustrt::task::{Task, BlockedTask};\n use rustrt::thread::Thread;\n \n-use sync::atomic;\n-use sync::mpsc_queue as mpsc;\n+use sync::{atomic, Mutex, MutexGuard};\n+use comm::mpsc_queue as mpsc;\n \n const DISCONNECTED: int = int::MIN;\n const FUDGE: int = 1024;\n@@ -56,7 +55,7 @@ pub struct Packet<T> {\n \n     // this lock protects various portions of this implementation during\n     // select()\n-    select_lock: NativeMutex,\n+    select_lock: Mutex<()>,\n }\n \n pub enum Failure {\n@@ -76,7 +75,7 @@ impl<T: Send> Packet<T> {\n             channels: atomic::AtomicInt::new(2),\n             port_dropped: atomic::AtomicBool::new(false),\n             sender_drain: atomic::AtomicInt::new(0),\n-            select_lock: unsafe { NativeMutex::new() },\n+            select_lock: Mutex::new(()),\n         };\n         return p;\n     }\n@@ -86,16 +85,18 @@ impl<T: Send> Packet<T> {\n     // In other case mutex data will be duplicated while cloning\n     // and that could cause problems on platforms where it is\n     // represented by opaque data structure\n-    pub fn postinit_lock(&mut self) {\n-        unsafe { self.select_lock.lock_noguard() }\n+    pub fn postinit_lock(&self) -> MutexGuard<()> {\n+        self.select_lock.lock()\n     }\n \n     // This function is used at the creation of a shared packet to inherit a\n     // previously blocked task. This is done to prevent spurious wakeups of\n     // tasks in select().\n     //\n     // This can only be called at channel-creation time\n-    pub fn inherit_blocker(&mut self, task: Option<BlockedTask>) {\n+    pub fn inherit_blocker(&mut self,\n+                           task: Option<BlockedTask>,\n+                           guard: MutexGuard<()>) {\n         match task {\n             Some(task) => {\n                 assert_eq!(self.cnt.load(atomic::SeqCst), 0);\n@@ -135,7 +136,7 @@ impl<T: Send> Packet<T> {\n         // interfere with this method. After we unlock this lock, we're\n         // signifying that we're done modifying self.cnt and self.to_wake and\n         // the port is ready for the world to continue using it.\n-        unsafe { self.select_lock.unlock_noguard() }\n+        drop(guard);\n     }\n \n     pub fn send(&mut self, t: T) -> Result<(), T> {\n@@ -441,7 +442,7 @@ impl<T: Send> Packet<T> {\n         // done with. Without this bounce, we can race with inherit_blocker\n         // about looking at and dealing with to_wake. Once we have acquired the\n         // lock, we are guaranteed that inherit_blocker is done.\n-        unsafe {\n+        {\n             let _guard = self.select_lock.lock();\n         }\n "}, {"sha": "a6b4ab71bacc1be1acabe6fc15192f63c15146cd", "filename": "src/libstd/comm/spsc_queue.rs", "status": "renamed", "additions": 56, "deletions": 104, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fspsc_queue.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -40,7 +40,6 @@ use core::prelude::*;\n use alloc::boxed::Box;\n use core::mem;\n use core::cell::UnsafeCell;\n-use alloc::arc::Arc;\n \n use sync::atomic::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n \n@@ -74,39 +73,6 @@ pub struct Queue<T> {\n     cache_subtractions: AtomicUint,\n }\n \n-/// A safe abstraction for the consumer in a single-producer single-consumer\n-/// queue.\n-pub struct Consumer<T> {\n-    inner: Arc<Queue<T>>\n-}\n-\n-impl<T: Send> Consumer<T> {\n-    /// Attempts to pop the value from the head of the queue, returning `None`\n-    /// if the queue is empty.\n-    pub fn pop(&mut self) -> Option<T> {\n-        self.inner.pop()\n-    }\n-\n-    /// Attempts to peek at the head of the queue, returning `None` if the queue\n-    /// is empty.\n-    pub fn peek<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.inner.peek()\n-    }\n-}\n-\n-/// A safe abstraction for the producer in a single-producer single-consumer\n-/// queue.\n-pub struct Producer<T> {\n-    inner: Arc<Queue<T>>\n-}\n-\n-impl<T: Send> Producer<T> {\n-    /// Pushes a new value onto the queue.\n-    pub fn push(&mut self, t: T) {\n-        self.inner.push(t)\n-    }\n-}\n-\n impl<T: Send> Node<T> {\n     fn new() -> *mut Node<T> {\n         unsafe {\n@@ -118,30 +84,6 @@ impl<T: Send> Node<T> {\n     }\n }\n \n-/// Creates a new queue with a consumer-producer pair.\n-///\n-/// The producer returned is connected to the consumer to push all data to\n-/// the consumer.\n-///\n-/// # Arguments\n-///\n-///   * `bound` - This queue implementation is implemented with a linked\n-///               list, and this means that a push is always a malloc. In\n-///               order to amortize this cost, an internal cache of nodes is\n-///               maintained to prevent a malloc from always being\n-///               necessary. This bound is the limit on the size of the\n-///               cache (if desired). If the value is 0, then the cache has\n-///               no bound. Otherwise, the cache will never grow larger than\n-///               `bound` (although the queue itself could be much larger.\n-pub fn queue<T: Send>(bound: uint) -> (Consumer<T>, Producer<T>) {\n-    let q = unsafe { Queue::new(bound) };\n-    let arc = Arc::new(q);\n-    let consumer = Consumer { inner: arc.clone() };\n-    let producer = Producer { inner: arc };\n-\n-    (consumer, producer)\n-}\n-\n impl<T: Send> Queue<T> {\n     /// Creates a new queue.\n     ///\n@@ -296,78 +238,88 @@ impl<T: Send> Drop for Queue<T> {\n mod test {\n     use prelude::*;\n \n-    use super::{queue};\n+    use sync::Arc;\n+    use super::Queue;\n \n     #[test]\n     fn smoke() {\n-        let (mut consumer, mut producer) = queue(0);\n-        producer.push(1i);\n-        producer.push(2);\n-        assert_eq!(consumer.pop(), Some(1i));\n-        assert_eq!(consumer.pop(), Some(2));\n-        assert_eq!(consumer.pop(), None);\n-        producer.push(3);\n-        producer.push(4);\n-        assert_eq!(consumer.pop(), Some(3));\n-        assert_eq!(consumer.pop(), Some(4));\n-        assert_eq!(consumer.pop(), None);\n+        unsafe {\n+            let queue = Queue::new(0);\n+            queue.push(1i);\n+            queue.push(2);\n+            assert_eq!(queue.pop(), Some(1i));\n+            assert_eq!(queue.pop(), Some(2));\n+            assert_eq!(queue.pop(), None);\n+            queue.push(3);\n+            queue.push(4);\n+            assert_eq!(queue.pop(), Some(3));\n+            assert_eq!(queue.pop(), Some(4));\n+            assert_eq!(queue.pop(), None);\n+        }\n     }\n \n     #[test]\n     fn peek() {\n-        let (mut consumer, mut producer) = queue(0);\n-        producer.push(vec![1i]);\n+        unsafe {\n+            let queue = Queue::new(0);\n+            queue.push(vec![1i]);\n+\n+            // Ensure the borrowchecker works\n+            match queue.peek() {\n+                Some(vec) => match vec.as_slice() {\n+                    // Note that `pop` is not allowed here due to borrow\n+                    [1] => {}\n+                    _ => return\n+                },\n+                None => unreachable!()\n+            }\n \n-        // Ensure the borrowchecker works\n-        match consumer.peek() {\n-            Some(vec) => match vec.as_slice() {\n-                // Note that `pop` is not allowed here due to borrow\n-                [1] => {}\n-                _ => return\n-            },\n-            None => unreachable!()\n+            queue.pop();\n         }\n-\n-        consumer.pop();\n     }\n \n     #[test]\n     fn drop_full() {\n-        let (_, mut producer) = queue(0);\n-        producer.push(box 1i);\n-        producer.push(box 2i);\n+        unsafe {\n+            let q = Queue::new(0);\n+            q.push(box 1i);\n+            q.push(box 2i);\n+        }\n     }\n \n     #[test]\n     fn smoke_bound() {\n-        let (mut consumer, mut producer) = queue(1);\n-        producer.push(1i);\n-        producer.push(2);\n-        assert_eq!(consumer.pop(), Some(1));\n-        assert_eq!(consumer.pop(), Some(2));\n-        assert_eq!(consumer.pop(), None);\n-        producer.push(3);\n-        producer.push(4);\n-        assert_eq!(consumer.pop(), Some(3));\n-        assert_eq!(consumer.pop(), Some(4));\n-        assert_eq!(consumer.pop(), None);\n+        unsafe {\n+            let q = Queue::new(0);\n+            q.push(1i);\n+            q.push(2);\n+            assert_eq!(q.pop(), Some(1));\n+            assert_eq!(q.pop(), Some(2));\n+            assert_eq!(q.pop(), None);\n+            q.push(3);\n+            q.push(4);\n+            assert_eq!(q.pop(), Some(3));\n+            assert_eq!(q.pop(), Some(4));\n+            assert_eq!(q.pop(), None);\n+        }\n     }\n \n     #[test]\n     fn stress() {\n-        stress_bound(0);\n-        stress_bound(1);\n+        unsafe {\n+            stress_bound(0);\n+            stress_bound(1);\n+        }\n \n-        fn stress_bound(bound: uint) {\n-            let (consumer, mut producer) = queue(bound);\n+        unsafe fn stress_bound(bound: uint) {\n+            let q = Arc::new(Queue::new(bound));\n \n             let (tx, rx) = channel();\n+            let q2 = q.clone();\n             spawn(proc() {\n-                // Move the consumer to a local mutable slot\n-                let mut consumer = consumer;\n                 for _ in range(0u, 100000) {\n                     loop {\n-                        match consumer.pop() {\n+                        match q2.pop() {\n                             Some(1i) => break,\n                             Some(_) => panic!(),\n                             None => {}\n@@ -377,7 +329,7 @@ mod test {\n                 tx.send(());\n             });\n             for _ in range(0i, 100000) {\n-                producer.push(1);\n+                q.push(1);\n             }\n             rx.recv();\n         }", "previous_filename": "src/libstd/sync/spsc_queue.rs"}, {"sha": "06ab4f4427aa664a1e5c8b1edfc7c4bc903bcabf", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -32,7 +32,7 @@ use rustrt::task::{Task, BlockedTask};\n use rustrt::thread::Thread;\n \n use sync::atomic;\n-use sync::spsc_queue as spsc;\n+use comm::spsc_queue as spsc;\n use comm::Receiver;\n \n const DISCONNECTED: int = int::MIN;"}, {"sha": "160365dac361223453acc70d19c9b4790edece75", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -225,8 +225,8 @@ pub mod dl {\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n-        use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        use sync::{StaticMutex, MUTEX_INIT};\n+        static LOCK: StaticMutex = MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence"}, {"sha": "8a329a5d27c08b61e3c5f2e368cc6f0d32394042", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -315,10 +315,10 @@ impl<'a> Seek for BufWriter<'a> {\n /// # #![allow(unused_must_use)]\n /// use std::io::BufReader;\n ///\n-/// let mut buf = [0, 1, 2, 3];\n-/// let mut r = BufReader::new(&mut buf);\n+/// let buf = [0, 1, 2, 3];\n+/// let mut r = BufReader::new(&buf);\n ///\n-/// assert_eq!(r.read_to_end().unwrap(), vec!(0, 1, 2, 3));\n+/// assert_eq!(r.read_to_end().unwrap(), vec![0, 1, 2, 3]);\n /// ```\n pub struct BufReader<'a> {\n     buf: &'a [u8],"}, {"sha": "b2e4fc75cf2387bd7068589bd49bf487cdd6a0aa", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -32,7 +32,7 @@\n //!     ```rust\n //!     use std::io;\n //!\n-//!     for line in io::stdin().lines() {\n+//!     for line in io::stdin().lock().lines() {\n //!         print!(\"{}\", line.unwrap());\n //!     }\n //!     ```\n@@ -1413,10 +1413,10 @@ pub trait Buffer: Reader {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io;\n+    /// use std::io::BufReader;\n     ///\n-    /// let mut reader = io::stdin();\n-    /// let input = reader.read_line().ok().unwrap_or(\"nothing\".to_string());\n+    /// let mut reader = BufReader::new(b\"hello\\nworld\");\n+    /// assert_eq!(\"hello\\n\", &*reader.read_line().unwrap());\n     /// ```\n     ///\n     /// # Error"}, {"sha": "ad5dcf71df737e304ed1a3ef276d030324fbdb24", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 132, "deletions": 20, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -29,22 +29,27 @@ use self::StdSource::*;\n \n use boxed::Box;\n use cell::RefCell;\n+use clone::Clone;\n use failure::LOCAL_STDERR;\n use fmt;\n-use io::{Reader, Writer, IoResult, IoError, OtherIoError,\n+use io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n use kinds::Send;\n use libc;\n use mem;\n use option::{Option, Some, None};\n+use ops::{Deref, DerefMut};\n use result::{Ok, Err};\n use rustrt;\n use rustrt::local::Local;\n use rustrt::task::Task;\n use slice::SlicePrelude;\n use str::StrPrelude;\n+use string::String;\n use sys::{fs, tty};\n+use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};\n use uint;\n+use vec::Vec;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two\n@@ -90,28 +95,135 @@ thread_local!(static LOCAL_STDOUT: RefCell<Option<Box<Writer + Send>>> = {\n     RefCell::new(None)\n })\n \n-/// Creates a new non-blocking handle to the stdin of the current process.\n-///\n-/// The returned handled is buffered by default with a `BufferedReader`. If\n-/// buffered access is not desired, the `stdin_raw` function is provided to\n-/// provided unbuffered access to stdin.\n+/// A synchronized wrapper around a buffered reader from stdin\n+#[deriving(Clone)]\n+pub struct StdinReader {\n+    inner: Arc<Mutex<BufferedReader<StdReader>>>,\n+}\n+\n+/// A guard for exlusive access to `StdinReader`'s internal `BufferedReader`.\n+pub struct StdinReaderGuard<'a> {\n+    inner: MutexGuard<'a, BufferedReader<StdReader>>,\n+}\n+\n+impl<'a> Deref<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n+    fn deref(&self) -> &BufferedReader<StdReader> {\n+        &*self.inner\n+    }\n+}\n+\n+impl<'a> DerefMut<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n+    fn deref_mut(&mut self) -> &mut BufferedReader<StdReader> {\n+        &mut *self.inner\n+    }\n+}\n+\n+impl StdinReader {\n+    /// Locks the `StdinReader`, granting the calling thread exclusive access\n+    /// to the underlying `BufferedReader`.\n+    ///\n+    /// This provides access to methods like `chars` and `lines`.\n+    ///\n+    /// ## Example\n+    ///\n+    /// ```rust\n+    /// use std::io;\n+    ///\n+    /// for line in io::stdin().lock().lines() {\n+    ///     println!(\"{}\", line.unwrap());\n+    /// }\n+    /// ```\n+    pub fn lock<'a>(&'a mut self) -> StdinReaderGuard<'a> {\n+        StdinReaderGuard {\n+            inner: self.inner.lock()\n+        }\n+    }\n+\n+    /// Like `Buffer::read_line`.\n+    ///\n+    /// The read is performed atomically - concurrent read calls in other\n+    /// threads will not interleave with this one.\n+    pub fn read_line(&mut self) -> IoResult<String> {\n+        self.inner.lock().read_line()\n+    }\n+\n+    /// Like `Buffer::read_until`.\n+    ///\n+    /// The read is performed atomically - concurrent read calls in other\n+    /// threads will not interleave with this one.\n+    pub fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n+        self.inner.lock().read_until(byte)\n+    }\n+\n+    /// Like `Buffer::read_char`.\n+    ///\n+    /// The read is performed atomically - concurrent read calls in other\n+    /// threads will not interleave with this one.\n+    pub fn read_char(&mut self) -> IoResult<char> {\n+        self.inner.lock().read_char()\n+    }\n+}\n+\n+impl Reader for StdinReader {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.inner.lock().read(buf)\n+    }\n+\n+    // We have to manually delegate all of these because the default impls call\n+    // read more than once and we don't want those calls to interleave (or\n+    // incur the costs of repeated locking).\n+\n+    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n+        self.inner.lock().read_at_least(min, buf)\n+    }\n+\n+    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+        self.inner.lock().push_at_least(min, len, buf)\n+    }\n+\n+    fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n+        self.inner.lock().read_to_end()\n+    }\n+\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+        self.inner.lock().read_le_uint_n(nbytes)\n+    }\n+\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+        self.inner.lock().read_be_uint_n(nbytes)\n+    }\n+}\n+\n+/// Creates a new handle to the stdin of the current process.\n ///\n-/// Care should be taken when creating multiple handles to the stdin of a\n-/// process. Because this is a buffered reader by default, it's possible for\n-/// pending input to be unconsumed in one reader and unavailable to other\n-/// readers. It is recommended that only one handle at a time is created for the\n-/// stdin of a process.\n+/// The returned handle is a wrapper around a global `BufferedReader` shared\n+/// by all threads. If buffered access is not desired, the `stdin_raw` function\n+/// is provided to provided unbuffered access to stdin.\n ///\n /// See `stdout()` for more notes about this function.\n-pub fn stdin() -> BufferedReader<StdReader> {\n-    // The default buffer capacity is 64k, but apparently windows doesn't like\n-    // 64k reads on stdin. See #13304 for details, but the idea is that on\n-    // windows we use a slightly smaller buffer that's been seen to be\n-    // acceptable.\n-    if cfg!(windows) {\n-        BufferedReader::with_capacity(8 * 1024, stdin_raw())\n-    } else {\n-        BufferedReader::new(stdin_raw())\n+pub fn stdin() -> StdinReader {\n+    // We're following the same strategy as kimundi's lazy_static library\n+    static mut STDIN: *const StdinReader = 0 as *const StdinReader;\n+    static ONCE: Once = ONCE_INIT;\n+\n+    unsafe {\n+        ONCE.doit(|| {\n+            // The default buffer capacity is 64k, but apparently windows doesn't like\n+            // 64k reads on stdin. See #13304 for details, but the idea is that on\n+            // windows we use a slightly smaller buffer that's been seen to be\n+            // acceptable.\n+            let stdin = if cfg!(windows) {\n+                BufferedReader::with_capacity(8 * 1024, stdin_raw())\n+            } else {\n+                BufferedReader::new(stdin_raw())\n+            };\n+            let stdin = StdinReader {\n+                inner: Arc::new(Mutex::new(stdin))\n+            };\n+            STDIN = mem::transmute(box stdin);\n+        });\n+\n+        (*STDIN).clone()\n     }\n }\n "}, {"sha": "d4274d7e4017e2a1b8dd9a461957f57099dc339a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -106,7 +106,7 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, globs, linkage)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n-#![feature(import_shadowing, slicing_syntax)]\n+#![feature(import_shadowing, slicing_syntax, tuple_indexing)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "a8adfec34ed683c48ed07f56e5244e4d14d4bd10", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -209,14 +209,12 @@ Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: || -> T) -> T {\n-    use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use sync::{StaticMutex, MUTEX_INIT};\n \n-    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    static LOCK: StaticMutex = MUTEX_INIT;\n \n-    unsafe {\n-        let _guard = LOCK.lock();\n-        f()\n-    }\n+    let _guard = LOCK.lock();\n+    f()\n }\n \n /// Returns a vector of (variable, value) pairs, for all the environment"}, {"sha": "159fc3080e836aba0adfbcb74a53d15e6c5a8233", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -238,7 +238,7 @@ mod imp {\n     use mem;\n     use option::{Some, None, Option};\n     use result::{Ok, Err};\n-    use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use sync::{StaticMutex, MUTEX_INIT};\n \n     /// As always - iOS on arm uses SjLj exceptions and\n     /// _Unwind_Backtrace is even not available there. Still,\n@@ -264,8 +264,8 @@ mod imp {\n         // while it doesn't requires lock for work as everything is\n         // local, it still displays much nicer backtraces when a\n         // couple of tasks panic simultaneously\n-        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        let _g = unsafe { LOCK.lock() };\n+        static LOCK: StaticMutex = MUTEX_INIT;\n+        let _g = LOCK.lock();\n \n         try!(writeln!(w, \"stack backtrace:\"));\n         // 100 lines should be enough\n@@ -297,8 +297,8 @@ mod imp {\n         // is semi-reasonable in terms of printing anyway, and we know that all\n         // I/O done here is blocking I/O, not green I/O, so we don't have to\n         // worry about this being a native vs green mutex.\n-        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        let _g = unsafe { LOCK.lock() };\n+        static LOCK: StaticMutex = MUTEX_INIT;\n+        let _g = LOCK.lock();\n \n         try!(writeln!(w, \"stack backtrace:\"));\n \n@@ -667,7 +667,7 @@ mod imp {\n     use option::{Some, None};\n     use path::Path;\n     use result::{Ok, Err};\n-    use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use sync::{StaticMutex, MUTEX_INIT};\n     use slice::SlicePrelude;\n     use str::StrPrelude;\n     use dynamic_lib::DynamicLibrary;\n@@ -928,8 +928,8 @@ mod imp {\n     pub fn write(w: &mut Writer) -> IoResult<()> {\n         // According to windows documentation, all dbghelp functions are\n         // single-threaded.\n-        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        let _g = unsafe { LOCK.lock() };\n+        static LOCK: StaticMutex = MUTEX_INIT;\n+        let _g = LOCK.lock();\n \n         // Open up dbghelp.dll, we don't link to it explicitly because it can't\n         // always be found. Additionally, it's nice having fewer dependencies."}, {"sha": "5e6dc6ec650836ebe204a9d90d591ca5b631587c", "filename": "src/libstd/sync/barrier.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sync::{Mutex, Condvar};\n+\n+/// A barrier enables multiple tasks to synchronize the beginning\n+/// of some computation.\n+///\n+/// ```rust\n+/// use std::sync::{Arc, Barrier};\n+///\n+/// let barrier = Arc::new(Barrier::new(10));\n+/// for _ in range(0u, 10) {\n+///     let c = barrier.clone();\n+///     // The same messages will be printed together.\n+///     // You will NOT see any interleaving.\n+///     spawn(proc() {\n+///         println!(\"before wait\");\n+///         c.wait();\n+///         println!(\"after wait\");\n+///     });\n+/// }\n+/// ```\n+pub struct Barrier {\n+    lock: Mutex<BarrierState>,\n+    cvar: Condvar,\n+    num_threads: uint,\n+}\n+\n+// The inner state of a double barrier\n+struct BarrierState {\n+    count: uint,\n+    generation_id: uint,\n+}\n+\n+impl Barrier {\n+    /// Create a new barrier that can block a given number of threads.\n+    ///\n+    /// A barrier will block `n`-1 threads which call `wait` and then wake up\n+    /// all threads at once when the `n`th thread calls `wait`.\n+    pub fn new(n: uint) -> Barrier {\n+        Barrier {\n+            lock: Mutex::new(BarrierState {\n+                count: 0,\n+                generation_id: 0,\n+            }),\n+            cvar: Condvar::new(),\n+            num_threads: n,\n+        }\n+    }\n+\n+    /// Block the current thread until all threads has rendezvoused here.\n+    ///\n+    /// Barriers are re-usable after all threads have rendezvoused once, and can\n+    /// be used continuously.\n+    pub fn wait(&self) {\n+        let mut lock = self.lock.lock();\n+        let local_gen = lock.generation_id;\n+        lock.count += 1;\n+        if lock.count < self.num_threads {\n+            // We need a while loop to guard against spurious wakeups.\n+            // http://en.wikipedia.org/wiki/Spurious_wakeup\n+            while local_gen == lock.generation_id &&\n+                  lock.count < self.num_threads {\n+                self.cvar.wait(&lock);\n+            }\n+        } else {\n+            lock.count = 0;\n+            lock.generation_id += 1;\n+            self.cvar.notify_all();\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+\n+    use sync::{Arc, Barrier};\n+    use comm::Empty;\n+\n+    #[test]\n+    fn test_barrier() {\n+        let barrier = Arc::new(Barrier::new(10));\n+        let (tx, rx) = channel();\n+\n+        for _ in range(0u, 9) {\n+            let c = barrier.clone();\n+            let tx = tx.clone();\n+            spawn(proc() {\n+                c.wait();\n+                tx.send(true);\n+            });\n+        }\n+\n+        // At this point, all spawned tasks should be blocked,\n+        // so we shouldn't get anything from the port\n+        assert!(match rx.try_recv() {\n+            Err(Empty) => true,\n+            _ => false,\n+        });\n+\n+        barrier.wait();\n+        // Now, the barrier is cleared and we should get data.\n+        for _ in range(0u, 9) {\n+            rx.recv();\n+        }\n+    }\n+}"}, {"sha": "0fdd57b27922c50d5e9068eb8a20bc413e1f45cb", "filename": "src/libstd/sync/condvar.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,365 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+use sync::atomic::{mod, AtomicUint};\n+use sync::{mutex, StaticMutexGuard};\n+use sys_common::condvar as sys;\n+use sys_common::mutex as sys_mutex;\n+use time::Duration;\n+\n+/// A Condition Variable\n+///\n+/// Condition variables represent the ability to block a thread such that it\n+/// consumes no CPU time while waiting for an event to occur. Condition\n+/// variables are typically associated with a boolean predicate (a condition)\n+/// and a mutex. The predicate is always verified inside of the mutex before\n+/// determining that thread must block.\n+///\n+/// Functions in this module will block the current **thread** of execution and\n+/// are bindings to system-provided condition variables where possible. Note\n+/// that this module places one additional restriction over the system condition\n+/// variables: each condvar can be used with precisely one mutex at runtime. Any\n+/// attempt to use multiple mutexes on the same condition variable will result\n+/// in a runtime panic. If this is not desired, then the unsafe primitives in\n+/// `sys` do not have this restriction but may result in undefined behavior.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::sync::{Arc, Mutex, Condvar};\n+///\n+/// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+/// let pair2 = pair.clone();\n+///\n+/// // Inside of our lock, spawn a new thread, and then wait for it to start\n+/// spawn(proc() {\n+///     let &(ref lock, ref cvar) = &*pair2;\n+///     let mut started = lock.lock();\n+///     *started = true;\n+///     cvar.notify_one();\n+/// });\n+///\n+/// // wait for the thread to start up\n+/// let &(ref lock, ref cvar) = &*pair;\n+/// let started = lock.lock();\n+/// while !*started {\n+///     cvar.wait(&started);\n+/// }\n+/// ```\n+pub struct Condvar { inner: Box<StaticCondvar> }\n+\n+/// Statically allocated condition variables.\n+///\n+/// This structure is identical to `Condvar` except that it is suitable for use\n+/// in static initializers for other structures.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::sync::{StaticCondvar, CONDVAR_INIT};\n+///\n+/// static CVAR: StaticCondvar = CONDVAR_INIT;\n+/// ```\n+pub struct StaticCondvar {\n+    inner: sys::Condvar,\n+    mutex: AtomicUint,\n+}\n+\n+/// Constant initializer for a statically allocated condition variable.\n+pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n+    inner: sys::CONDVAR_INIT,\n+    mutex: atomic::INIT_ATOMIC_UINT,\n+};\n+\n+/// A trait for vaules which can be passed to the waiting methods of condition\n+/// variables. This is implemented by the mutex guards in this module.\n+///\n+/// Note that this trait should likely not be implemented manually unless you\n+/// really know what you're doing.\n+pub trait AsMutexGuard {\n+    #[allow(missing_docs)]\n+    unsafe fn as_mutex_guard(&self) -> &StaticMutexGuard;\n+}\n+\n+impl Condvar {\n+    /// Creates a new condition variable which is ready to be waited on and\n+    /// notified.\n+    pub fn new() -> Condvar {\n+        Condvar {\n+            inner: box StaticCondvar {\n+                inner: unsafe { sys::Condvar::new() },\n+                mutex: AtomicUint::new(0),\n+            }\n+        }\n+    }\n+\n+    /// Block the current thread until this condition variable receives a\n+    /// notification.\n+    ///\n+    /// This function will atomically unlock the mutex specified (represented by\n+    /// `guard`) and block the current thread. This means that any calls to\n+    /// `notify_*()` which happen logically after the mutex is unlocked are\n+    /// candidates to wake this thread up. When this function call returns, the\n+    /// lock specified will have been re-acquired.\n+    ///\n+    /// Note that this function is susceptible to spurious wakeups. Condition\n+    /// variables normally have a boolean predicate associated with them, and\n+    /// the predicate must always be checked each time this function returns to\n+    /// protect against spurious wakeups.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will `panic!()` if it is used with more than one mutex\n+    /// over time. Each condition variable is dynamically bound to exactly one\n+    /// mutex to ensure defined behavior across platforms. If this functionality\n+    /// is not desired, then unsafe primitives in `sys` are provided.\n+    pub fn wait<T: AsMutexGuard>(&self, mutex_guard: &T) {\n+        unsafe {\n+            let me: &'static Condvar = &*(self as *const _);\n+            me.inner.wait(mutex_guard)\n+        }\n+    }\n+\n+    /// Wait on this condition variable for a notification, timing out after a\n+    /// specified duration.\n+    ///\n+    /// The semantics of this function are equivalent to `wait()` except that\n+    /// the thread will be blocked for roughly no longer than `dur`. This method\n+    /// should not be used for precise timing due to anomalies such as\n+    /// preemption or platform differences that may not cause the maximum amount\n+    /// of time waited to be precisely `dur`.\n+    ///\n+    /// If the wait timed out, then `false` will be returned. Otherwise if a\n+    /// notification was received then `true` will be returned.\n+    ///\n+    /// Like `wait`, the lock specified will be re-acquired when this function\n+    /// returns, regardless of whether the timeout elapsed or not.\n+    // Note that this method is *not* public, and this is quite intentional\n+    // because we're not quite sure about the semantics of relative vs absolute\n+    // durations or how the timing guarantees play into what the system APIs\n+    // provide. There are also additional concerns about the unix-specific\n+    // implementation which may need to be addressed.\n+    #[allow(dead_code)]\n+    fn wait_timeout<T: AsMutexGuard>(&self, mutex_guard: &T,\n+                                     dur: Duration) -> bool {\n+        unsafe {\n+            let me: &'static Condvar = &*(self as *const _);\n+            me.inner.wait_timeout(mutex_guard, dur)\n+        }\n+    }\n+\n+    /// Wake up one blocked thread on this condvar.\n+    ///\n+    /// If there is a blocked thread on this condition variable, then it will\n+    /// be woken up from its call to `wait` or `wait_timeout`. Calls to\n+    /// `notify_one` are not buffered in any way.\n+    ///\n+    /// To wake up all threads, see `notify_one()`.\n+    pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }\n+\n+    /// Wake up all blocked threads on this condvar.\n+    ///\n+    /// This method will ensure that any current waiters on the condition\n+    /// variable are awoken. Calls to `notify_all()` are not buffered in any\n+    /// way.\n+    ///\n+    /// To wake up only one thread, see `notify_one()`.\n+    pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n+}\n+\n+impl Drop for Condvar {\n+    fn drop(&mut self) {\n+        unsafe { self.inner.inner.destroy() }\n+    }\n+}\n+\n+impl StaticCondvar {\n+    /// Block the current thread until this condition variable receives a\n+    /// notification.\n+    ///\n+    /// See `Condvar::wait`.\n+    pub fn wait<T: AsMutexGuard>(&'static self, mutex_guard: &T) {\n+        unsafe {\n+            let lock = mutex_guard.as_mutex_guard();\n+            let sys = mutex::guard_lock(lock);\n+            self.verify(sys);\n+            self.inner.wait(sys);\n+            (*mutex::guard_poison(lock)).check(\"mutex\");\n+        }\n+    }\n+\n+    /// Wait on this condition variable for a notification, timing out after a\n+    /// specified duration.\n+    ///\n+    /// See `Condvar::wait_timeout`.\n+    #[allow(dead_code)] // may want to stabilize this later, see wait_timeout above\n+    fn wait_timeout<T: AsMutexGuard>(&'static self, mutex_guard: &T,\n+                                     dur: Duration) -> bool {\n+        unsafe {\n+            let lock = mutex_guard.as_mutex_guard();\n+            let sys = mutex::guard_lock(lock);\n+            self.verify(sys);\n+            let ret = self.inner.wait_timeout(sys, dur);\n+            (*mutex::guard_poison(lock)).check(\"mutex\");\n+            return ret;\n+        }\n+    }\n+\n+    /// Wake up one blocked thread on this condvar.\n+    ///\n+    /// See `Condvar::notify_one`.\n+    pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n+\n+    /// Wake up all blocked threads on this condvar.\n+    ///\n+    /// See `Condvar::notify_all`.\n+    pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n+\n+    /// Deallocate all resources associated with this static condvar.\n+    ///\n+    /// This method is unsafe to call as there is no guarantee that there are no\n+    /// active users of the condvar, and this also doesn't prevent any future\n+    /// users of the condvar. This method is required to be called to not leak\n+    /// memory on all platforms.\n+    pub unsafe fn destroy(&'static self) {\n+        self.inner.destroy()\n+    }\n+\n+    fn verify(&self, mutex: &sys_mutex::Mutex) {\n+        let addr = mutex as *const _ as uint;\n+        match self.mutex.compare_and_swap(0, addr, atomic::SeqCst) {\n+            // If we got out 0, then we have successfully bound the mutex to\n+            // this cvar.\n+            0 => {}\n+\n+            // If we get out a value that's the same as `addr`, then someone\n+            // already beat us to the punch.\n+            n if n == addr => {}\n+\n+            // Anything else and we're using more than one mutex on this cvar,\n+            // which is currently disallowed.\n+            _ => panic!(\"attempted to use a condition variable with two \\\n+                         mutexes\"),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+\n+    use time::Duration;\n+    use super::{StaticCondvar, CONDVAR_INIT};\n+    use sync::{StaticMutex, MUTEX_INIT, Condvar, Mutex, Arc};\n+\n+    #[test]\n+    fn smoke() {\n+        let c = Condvar::new();\n+        c.notify_one();\n+        c.notify_all();\n+    }\n+\n+    #[test]\n+    fn static_smoke() {\n+        static C: StaticCondvar = CONDVAR_INIT;\n+        C.notify_one();\n+        C.notify_all();\n+        unsafe { C.destroy(); }\n+    }\n+\n+    #[test]\n+    fn notify_one() {\n+        static C: StaticCondvar = CONDVAR_INIT;\n+        static M: StaticMutex = MUTEX_INIT;\n+\n+        let g = M.lock();\n+        spawn(proc() {\n+            let _g = M.lock();\n+            C.notify_one();\n+        });\n+        C.wait(&g);\n+        drop(g);\n+        unsafe { C.destroy(); M.destroy(); }\n+    }\n+\n+    #[test]\n+    fn notify_all() {\n+        const N: uint = 10;\n+\n+        let data = Arc::new((Mutex::new(0), Condvar::new()));\n+        let (tx, rx) = channel();\n+        for _ in range(0, N) {\n+            let data = data.clone();\n+            let tx = tx.clone();\n+            spawn(proc() {\n+                let &(ref lock, ref cond) = &*data;\n+                let mut cnt = lock.lock();\n+                *cnt += 1;\n+                if *cnt == N {\n+                    tx.send(());\n+                }\n+                while *cnt != 0 {\n+                    cond.wait(&cnt);\n+                }\n+                tx.send(());\n+            });\n+        }\n+        drop(tx);\n+\n+        let &(ref lock, ref cond) = &*data;\n+        rx.recv();\n+        let mut cnt = lock.lock();\n+        *cnt = 0;\n+        cond.notify_all();\n+        drop(cnt);\n+\n+        for _ in range(0, N) {\n+            rx.recv();\n+        }\n+    }\n+\n+    #[test]\n+    fn wait_timeout() {\n+        static C: StaticCondvar = CONDVAR_INIT;\n+        static M: StaticMutex = MUTEX_INIT;\n+\n+        let g = M.lock();\n+        assert!(!C.wait_timeout(&g, Duration::nanoseconds(1000)));\n+        spawn(proc() {\n+            let _g = M.lock();\n+            C.notify_one();\n+        });\n+        assert!(C.wait_timeout(&g, Duration::days(1)));\n+        drop(g);\n+        unsafe { C.destroy(); M.destroy(); }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn two_mutexes() {\n+        static M1: StaticMutex = MUTEX_INIT;\n+        static M2: StaticMutex = MUTEX_INIT;\n+        static C: StaticCondvar = CONDVAR_INIT;\n+\n+        let g = M1.lock();\n+        spawn(proc() {\n+            let _g = M1.lock();\n+            C.notify_one();\n+        });\n+        C.wait(&g);\n+        drop(g);\n+\n+        C.wait(&M2.lock());\n+\n+    }\n+}\n+"}, {"sha": "33f6f77eb62a3115f9db537bb5d4e1a98bf1fdfe", "filename": "src/libstd/sync/deque.rs", "status": "removed", "additions": 0, "deletions": 663, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/95d17711397d63425688d18140a58723caddff8e/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d17711397d63425688d18140a58723caddff8e/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=95d17711397d63425688d18140a58723caddff8e", "patch": "@@ -1,663 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A (mostly) lock-free concurrent work-stealing deque\n-//!\n-//! This module contains an implementation of the Chase-Lev work stealing deque\n-//! described in \"Dynamic Circular Work-Stealing Deque\". The implementation is\n-//! heavily based on the pseudocode found in the paper.\n-//!\n-//! This implementation does not want to have the restriction of a garbage\n-//! collector for reclamation of buffers, and instead it uses a shared pool of\n-//! buffers. This shared pool is required for correctness in this\n-//! implementation.\n-//!\n-//! The only lock-synchronized portions of this deque are the buffer allocation\n-//! and deallocation portions. Otherwise all operations are lock-free.\n-//!\n-//! # Example\n-//!\n-//!     use std::sync::deque::BufferPool;\n-//!\n-//!     let mut pool = BufferPool::new();\n-//!     let (mut worker, mut stealer) = pool.deque();\n-//!\n-//!     // Only the worker may push/pop\n-//!     worker.push(1i);\n-//!     worker.pop();\n-//!\n-//!     // Stealers take data from the other end of the deque\n-//!     worker.push(1i);\n-//!     stealer.steal();\n-//!\n-//!     // Stealers can be cloned to have many stealers stealing in parallel\n-//!     worker.push(1i);\n-//!     let mut stealer2 = stealer.clone();\n-//!     stealer2.steal();\n-\n-#![experimental]\n-\n-// NB: the \"buffer pool\" strategy is not done for speed, but rather for\n-//     correctness. For more info, see the comment on `swap_buffer`\n-\n-// FIXME: all atomic operations in this module use a SeqCst ordering. That is\n-//      probably overkill\n-\n-pub use self::Stolen::*;\n-\n-use core::prelude::*;\n-\n-use alloc::arc::Arc;\n-use alloc::heap::{allocate, deallocate};\n-use alloc::boxed::Box;\n-use vec::Vec;\n-use core::kinds::marker;\n-use core::mem::{forget, min_align_of, size_of, transmute};\n-use core::ptr;\n-use rustrt::exclusive::Exclusive;\n-\n-use sync::atomic::{AtomicInt, AtomicPtr, SeqCst};\n-\n-// Once the queue is less than 1/K full, then it will be downsized. Note that\n-// the deque requires that this number be less than 2.\n-static K: int = 4;\n-\n-// Minimum number of bits that a buffer size should be. No buffer will resize to\n-// under this value, and all deques will initially contain a buffer of this\n-// size.\n-//\n-// The size in question is 1 << MIN_BITS\n-static MIN_BITS: uint = 7;\n-\n-struct Deque<T> {\n-    bottom: AtomicInt,\n-    top: AtomicInt,\n-    array: AtomicPtr<Buffer<T>>,\n-    pool: BufferPool<T>,\n-}\n-\n-/// Worker half of the work-stealing deque. This worker has exclusive access to\n-/// one side of the deque, and uses `push` and `pop` method to manipulate it.\n-///\n-/// There may only be one worker per deque.\n-pub struct Worker<T> {\n-    deque: Arc<Deque<T>>,\n-    _noshare: marker::NoSync,\n-}\n-\n-/// The stealing half of the work-stealing deque. Stealers have access to the\n-/// opposite end of the deque from the worker, and they only have access to the\n-/// `steal` method.\n-pub struct Stealer<T> {\n-    deque: Arc<Deque<T>>,\n-    _noshare: marker::NoSync,\n-}\n-\n-/// When stealing some data, this is an enumeration of the possible outcomes.\n-#[deriving(PartialEq, Show)]\n-pub enum Stolen<T> {\n-    /// The deque was empty at the time of stealing\n-    Empty,\n-    /// The stealer lost the race for stealing data, and a retry may return more\n-    /// data.\n-    Abort,\n-    /// The stealer has successfully stolen some data.\n-    Data(T),\n-}\n-\n-/// The allocation pool for buffers used by work-stealing deques. Right now this\n-/// structure is used for reclamation of memory after it is no longer in use by\n-/// deques.\n-///\n-/// This data structure is protected by a mutex, but it is rarely used. Deques\n-/// will only use this structure when allocating a new buffer or deallocating a\n-/// previous one.\n-pub struct BufferPool<T> {\n-    pool: Arc<Exclusive<Vec<Box<Buffer<T>>>>>,\n-}\n-\n-/// An internal buffer used by the chase-lev deque. This structure is actually\n-/// implemented as a circular buffer, and is used as the intermediate storage of\n-/// the data in the deque.\n-///\n-/// This type is implemented with *T instead of Vec<T> for two reasons:\n-///\n-///   1. There is nothing safe about using this buffer. This easily allows the\n-///      same value to be read twice in to rust, and there is nothing to\n-///      prevent this. The usage by the deque must ensure that one of the\n-///      values is forgotten. Furthermore, we only ever want to manually run\n-///      destructors for values in this buffer (on drop) because the bounds\n-///      are defined by the deque it's owned by.\n-///\n-///   2. We can certainly avoid bounds checks using *T instead of Vec<T>, although\n-///      LLVM is probably pretty good at doing this already.\n-struct Buffer<T> {\n-    storage: *const T,\n-    log_size: uint,\n-}\n-\n-impl<T: Send> BufferPool<T> {\n-    /// Allocates a new buffer pool which in turn can be used to allocate new\n-    /// deques.\n-    pub fn new() -> BufferPool<T> {\n-        BufferPool { pool: Arc::new(Exclusive::new(Vec::new())) }\n-    }\n-\n-    /// Allocates a new work-stealing deque which will send/receiving memory to\n-    /// and from this buffer pool.\n-    pub fn deque(&self) -> (Worker<T>, Stealer<T>) {\n-        let a = Arc::new(Deque::new(self.clone()));\n-        let b = a.clone();\n-        (Worker { deque: a, _noshare: marker::NoSync },\n-         Stealer { deque: b, _noshare: marker::NoSync })\n-    }\n-\n-    fn alloc(&mut self, bits: uint) -> Box<Buffer<T>> {\n-        unsafe {\n-            let mut pool = self.pool.lock();\n-            match pool.iter().position(|x| x.size() >= (1 << bits)) {\n-                Some(i) => pool.remove(i).unwrap(),\n-                None => box Buffer::new(bits)\n-            }\n-        }\n-    }\n-\n-    fn free(&self, buf: Box<Buffer<T>>) {\n-        unsafe {\n-            let mut pool = self.pool.lock();\n-            match pool.iter().position(|v| v.size() > buf.size()) {\n-                Some(i) => pool.insert(i, buf),\n-                None => pool.push(buf),\n-            }\n-        }\n-    }\n-}\n-\n-impl<T: Send> Clone for BufferPool<T> {\n-    fn clone(&self) -> BufferPool<T> { BufferPool { pool: self.pool.clone() } }\n-}\n-\n-impl<T: Send> Worker<T> {\n-    /// Pushes data onto the front of this work queue.\n-    pub fn push(&self, t: T) {\n-        unsafe { self.deque.push(t) }\n-    }\n-    /// Pops data off the front of the work queue, returning `None` on an empty\n-    /// queue.\n-    pub fn pop(&self) -> Option<T> {\n-        unsafe { self.deque.pop() }\n-    }\n-\n-    /// Gets access to the buffer pool that this worker is attached to. This can\n-    /// be used to create more deques which share the same buffer pool as this\n-    /// deque.\n-    pub fn pool<'a>(&'a self) -> &'a BufferPool<T> {\n-        &self.deque.pool\n-    }\n-}\n-\n-impl<T: Send> Stealer<T> {\n-    /// Steals work off the end of the queue (opposite of the worker's end)\n-    pub fn steal(&self) -> Stolen<T> {\n-        unsafe { self.deque.steal() }\n-    }\n-\n-    /// Gets access to the buffer pool that this stealer is attached to. This\n-    /// can be used to create more deques which share the same buffer pool as\n-    /// this deque.\n-    pub fn pool<'a>(&'a self) -> &'a BufferPool<T> {\n-        &self.deque.pool\n-    }\n-}\n-\n-impl<T: Send> Clone for Stealer<T> {\n-    fn clone(&self) -> Stealer<T> {\n-        Stealer { deque: self.deque.clone(), _noshare: marker::NoSync }\n-    }\n-}\n-\n-// Almost all of this code can be found directly in the paper so I'm not\n-// personally going to heavily comment what's going on here.\n-\n-impl<T: Send> Deque<T> {\n-    fn new(mut pool: BufferPool<T>) -> Deque<T> {\n-        let buf = pool.alloc(MIN_BITS);\n-        Deque {\n-            bottom: AtomicInt::new(0),\n-            top: AtomicInt::new(0),\n-            array: AtomicPtr::new(unsafe { transmute(buf) }),\n-            pool: pool,\n-        }\n-    }\n-\n-    unsafe fn push(&self, data: T) {\n-        let mut b = self.bottom.load(SeqCst);\n-        let t = self.top.load(SeqCst);\n-        let mut a = self.array.load(SeqCst);\n-        let size = b - t;\n-        if size >= (*a).size() - 1 {\n-            // You won't find this code in the chase-lev deque paper. This is\n-            // alluded to in a small footnote, however. We always free a buffer\n-            // when growing in order to prevent leaks.\n-            a = self.swap_buffer(b, a, (*a).resize(b, t, 1));\n-            b = self.bottom.load(SeqCst);\n-        }\n-        (*a).put(b, data);\n-        self.bottom.store(b + 1, SeqCst);\n-    }\n-\n-    unsafe fn pop(&self) -> Option<T> {\n-        let b = self.bottom.load(SeqCst);\n-        let a = self.array.load(SeqCst);\n-        let b = b - 1;\n-        self.bottom.store(b, SeqCst);\n-        let t = self.top.load(SeqCst);\n-        let size = b - t;\n-        if size < 0 {\n-            self.bottom.store(t, SeqCst);\n-            return None;\n-        }\n-        let data = (*a).get(b);\n-        if size > 0 {\n-            self.maybe_shrink(b, t);\n-            return Some(data);\n-        }\n-        if self.top.compare_and_swap(t, t + 1, SeqCst) == t {\n-            self.bottom.store(t + 1, SeqCst);\n-            return Some(data);\n-        } else {\n-            self.bottom.store(t + 1, SeqCst);\n-            forget(data); // someone else stole this value\n-            return None;\n-        }\n-    }\n-\n-    unsafe fn steal(&self) -> Stolen<T> {\n-        let t = self.top.load(SeqCst);\n-        let old = self.array.load(SeqCst);\n-        let b = self.bottom.load(SeqCst);\n-        let a = self.array.load(SeqCst);\n-        let size = b - t;\n-        if size <= 0 { return Empty }\n-        if size % (*a).size() == 0 {\n-            if a == old && t == self.top.load(SeqCst) {\n-                return Empty\n-            }\n-            return Abort\n-        }\n-        let data = (*a).get(t);\n-        if self.top.compare_and_swap(t, t + 1, SeqCst) == t {\n-            Data(data)\n-        } else {\n-            forget(data); // someone else stole this value\n-            Abort\n-        }\n-    }\n-\n-    unsafe fn maybe_shrink(&self, b: int, t: int) {\n-        let a = self.array.load(SeqCst);\n-        if b - t < (*a).size() / K && b - t > (1 << MIN_BITS) {\n-            self.swap_buffer(b, a, (*a).resize(b, t, -1));\n-        }\n-    }\n-\n-    // Helper routine not mentioned in the paper which is used in growing and\n-    // shrinking buffers to swap in a new buffer into place. As a bit of a\n-    // recap, the whole point that we need a buffer pool rather than just\n-    // calling malloc/free directly is that stealers can continue using buffers\n-    // after this method has called 'free' on it. The continued usage is simply\n-    // a read followed by a forget, but we must make sure that the memory can\n-    // continue to be read after we flag this buffer for reclamation.\n-    unsafe fn swap_buffer(&self, b: int, old: *mut Buffer<T>,\n-                          buf: Buffer<T>) -> *mut Buffer<T> {\n-        let newbuf: *mut Buffer<T> = transmute(box buf);\n-        self.array.store(newbuf, SeqCst);\n-        let ss = (*newbuf).size();\n-        self.bottom.store(b + ss, SeqCst);\n-        let t = self.top.load(SeqCst);\n-        if self.top.compare_and_swap(t, t + ss, SeqCst) != t {\n-            self.bottom.store(b, SeqCst);\n-        }\n-        self.pool.free(transmute(old));\n-        return newbuf;\n-    }\n-}\n-\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for Deque<T> {\n-    fn drop(&mut self) {\n-        let t = self.top.load(SeqCst);\n-        let b = self.bottom.load(SeqCst);\n-        let a = self.array.load(SeqCst);\n-        // Free whatever is leftover in the dequeue, and then move the buffer\n-        // back into the pool.\n-        for i in range(t, b) {\n-            let _: T = unsafe { (*a).get(i) };\n-        }\n-        self.pool.free(unsafe { transmute(a) });\n-    }\n-}\n-\n-#[inline]\n-fn buffer_alloc_size<T>(log_size: uint) -> uint {\n-    (1 << log_size) * size_of::<T>()\n-}\n-\n-impl<T: Send> Buffer<T> {\n-    unsafe fn new(log_size: uint) -> Buffer<T> {\n-        let size = buffer_alloc_size::<T>(log_size);\n-        let buffer = allocate(size, min_align_of::<T>());\n-        if buffer.is_null() { ::alloc::oom() }\n-        Buffer {\n-            storage: buffer as *const T,\n-            log_size: log_size,\n-        }\n-    }\n-\n-    fn size(&self) -> int { 1 << self.log_size }\n-\n-    // Apparently LLVM cannot optimize (foo % (1 << bar)) into this implicitly\n-    fn mask(&self) -> int { (1 << self.log_size) - 1 }\n-\n-    unsafe fn elem(&self, i: int) -> *const T {\n-        self.storage.offset(i & self.mask())\n-    }\n-\n-    // This does not protect against loading duplicate values of the same cell,\n-    // nor does this clear out the contents contained within. Hence, this is a\n-    // very unsafe method which the caller needs to treat specially in case a\n-    // race is lost.\n-    unsafe fn get(&self, i: int) -> T {\n-        ptr::read(self.elem(i))\n-    }\n-\n-    // Unsafe because this unsafely overwrites possibly uninitialized or\n-    // initialized data.\n-    unsafe fn put(&self, i: int, t: T) {\n-        ptr::write(self.elem(i) as *mut T, t);\n-    }\n-\n-    // Again, unsafe because this has incredibly dubious ownership violations.\n-    // It is assumed that this buffer is immediately dropped.\n-    unsafe fn resize(&self, b: int, t: int, delta: int) -> Buffer<T> {\n-        // NB: not entirely obvious, but thanks to 2's complement,\n-        // casting delta to uint and then adding gives the desired\n-        // effect.\n-        let buf = Buffer::new(self.log_size + delta as uint);\n-        for i in range(t, b) {\n-            buf.put(i, self.get(i));\n-        }\n-        return buf;\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for Buffer<T> {\n-    fn drop(&mut self) {\n-        // It is assumed that all buffers are empty on drop.\n-        let size = buffer_alloc_size::<T>(self.log_size);\n-        unsafe { deallocate(self.storage as *mut u8, size, min_align_of::<T>()) }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::{Data, BufferPool, Abort, Empty, Worker, Stealer};\n-\n-    use mem;\n-    use rustrt::thread::Thread;\n-    use rand;\n-    use rand::Rng;\n-    use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, SeqCst,\n-                       AtomicUint, INIT_ATOMIC_UINT};\n-    use vec;\n-\n-    #[test]\n-    fn smoke() {\n-        let pool = BufferPool::new();\n-        let (w, s) = pool.deque();\n-        assert_eq!(w.pop(), None);\n-        assert_eq!(s.steal(), Empty);\n-        w.push(1i);\n-        assert_eq!(w.pop(), Some(1));\n-        w.push(1);\n-        assert_eq!(s.steal(), Data(1));\n-        w.push(1);\n-        assert_eq!(s.clone().steal(), Data(1));\n-    }\n-\n-    #[test]\n-    fn stealpush() {\n-        static AMT: int = 100000;\n-        let pool = BufferPool::<int>::new();\n-        let (w, s) = pool.deque();\n-        let t = Thread::start(proc() {\n-            let mut left = AMT;\n-            while left > 0 {\n-                match s.steal() {\n-                    Data(i) => {\n-                        assert_eq!(i, 1);\n-                        left -= 1;\n-                    }\n-                    Abort | Empty => {}\n-                }\n-            }\n-        });\n-\n-        for _ in range(0, AMT) {\n-            w.push(1);\n-        }\n-\n-        t.join();\n-    }\n-\n-    #[test]\n-    fn stealpush_large() {\n-        static AMT: int = 100000;\n-        let pool = BufferPool::<(int, int)>::new();\n-        let (w, s) = pool.deque();\n-        let t = Thread::start(proc() {\n-            let mut left = AMT;\n-            while left > 0 {\n-                match s.steal() {\n-                    Data((1, 10)) => { left -= 1; }\n-                    Data(..) => panic!(),\n-                    Abort | Empty => {}\n-                }\n-            }\n-        });\n-\n-        for _ in range(0, AMT) {\n-            w.push((1, 10));\n-        }\n-\n-        t.join();\n-    }\n-\n-    fn stampede(w: Worker<Box<int>>, s: Stealer<Box<int>>,\n-                nthreads: int, amt: uint) {\n-        for _ in range(0, amt) {\n-            w.push(box 20);\n-        }\n-        let mut remaining = AtomicUint::new(amt);\n-        let unsafe_remaining: *mut AtomicUint = &mut remaining;\n-\n-        let threads = range(0, nthreads).map(|_| {\n-            let s = s.clone();\n-            Thread::start(proc() {\n-                unsafe {\n-                    while (*unsafe_remaining).load(SeqCst) > 0 {\n-                        match s.steal() {\n-                            Data(box 20) => {\n-                                (*unsafe_remaining).fetch_sub(1, SeqCst);\n-                            }\n-                            Data(..) => panic!(),\n-                            Abort | Empty => {}\n-                        }\n-                    }\n-                }\n-            })\n-        }).collect::<Vec<Thread<()>>>();\n-\n-        while remaining.load(SeqCst) > 0 {\n-            match w.pop() {\n-                Some(box 20) => { remaining.fetch_sub(1, SeqCst); }\n-                Some(..) => panic!(),\n-                None => {}\n-            }\n-        }\n-\n-        for thread in threads.into_iter() {\n-            thread.join();\n-        }\n-    }\n-\n-    #[test]\n-    fn run_stampede() {\n-        let pool = BufferPool::<Box<int>>::new();\n-        let (w, s) = pool.deque();\n-        stampede(w, s, 8, 10000);\n-    }\n-\n-    #[test]\n-    fn many_stampede() {\n-        static AMT: uint = 4;\n-        let pool = BufferPool::<Box<int>>::new();\n-        let threads = range(0, AMT).map(|_| {\n-            let (w, s) = pool.deque();\n-            Thread::start(proc() {\n-                stampede(w, s, 4, 10000);\n-            })\n-        }).collect::<Vec<Thread<()>>>();\n-\n-        for thread in threads.into_iter() {\n-            thread.join();\n-        }\n-    }\n-\n-    #[test]\n-    fn stress() {\n-        static AMT: int = 100000;\n-        static NTHREADS: int = 8;\n-        static DONE: AtomicBool = INIT_ATOMIC_BOOL;\n-        static HITS: AtomicUint = INIT_ATOMIC_UINT;\n-        let pool = BufferPool::<int>::new();\n-        let (w, s) = pool.deque();\n-\n-        let threads = range(0, NTHREADS).map(|_| {\n-            let s = s.clone();\n-            Thread::start(proc() {\n-                loop {\n-                    match s.steal() {\n-                        Data(2) => { HITS.fetch_add(1, SeqCst); }\n-                        Data(..) => panic!(),\n-                        _ if DONE.load(SeqCst) => break,\n-                        _ => {}\n-                    }\n-                }\n-            })\n-        }).collect::<Vec<Thread<()>>>();\n-\n-        let mut rng = rand::task_rng();\n-        let mut expected = 0;\n-        while expected < AMT {\n-            if rng.gen_range(0i, 3) == 2 {\n-                match w.pop() {\n-                    None => {}\n-                    Some(2) => { HITS.fetch_add(1, SeqCst); },\n-                    Some(_) => panic!(),\n-                }\n-            } else {\n-                expected += 1;\n-                w.push(2);\n-            }\n-        }\n-\n-        while HITS.load(SeqCst) < AMT as uint {\n-            match w.pop() {\n-                None => {}\n-                Some(2) => { HITS.fetch_add(1, SeqCst); },\n-                Some(_) => panic!(),\n-            }\n-        }\n-        DONE.store(true, SeqCst);\n-\n-        for thread in threads.into_iter() {\n-            thread.join();\n-        }\n-\n-        assert_eq!(HITS.load(SeqCst), expected as uint);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(windows, ignore)] // apparently windows scheduling is weird?\n-    fn no_starvation() {\n-        static AMT: int = 10000;\n-        static NTHREADS: int = 4;\n-        static DONE: AtomicBool = INIT_ATOMIC_BOOL;\n-        let pool = BufferPool::<(int, uint)>::new();\n-        let (w, s) = pool.deque();\n-\n-        let (threads, hits) = vec::unzip(range(0, NTHREADS).map(|_| {\n-            let s = s.clone();\n-            let unique_box = box AtomicUint::new(0);\n-            let thread_box = unsafe {\n-                *mem::transmute::<&Box<AtomicUint>,\n-                                  *const *mut AtomicUint>(&unique_box)\n-            };\n-            (Thread::start(proc() {\n-                unsafe {\n-                    loop {\n-                        match s.steal() {\n-                            Data((1, 2)) => {\n-                                (*thread_box).fetch_add(1, SeqCst);\n-                            }\n-                            Data(..) => panic!(),\n-                            _ if DONE.load(SeqCst) => break,\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-            }), unique_box)\n-        }));\n-\n-        let mut rng = rand::task_rng();\n-        let mut myhit = false;\n-        'outer: loop {\n-            for _ in range(0, rng.gen_range(0, AMT)) {\n-                if !myhit && rng.gen_range(0i, 3) == 2 {\n-                    match w.pop() {\n-                        None => {}\n-                        Some((1, 2)) => myhit = true,\n-                        Some(_) => panic!(),\n-                    }\n-                } else {\n-                    w.push((1, 2));\n-                }\n-            }\n-\n-            for slot in hits.iter() {\n-                let amt = slot.load(SeqCst);\n-                if amt == 0 { continue 'outer; }\n-            }\n-            if myhit {\n-                break\n-            }\n-        }\n-\n-        DONE.store(true, SeqCst);\n-\n-        for thread in threads.into_iter() {\n-            thread.join();\n-        }\n-    }\n-}"}, {"sha": "79e0d487cadb9b3996ba8c739a1c671015ed384f", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -148,7 +148,7 @@ mod test {\n     use prelude::*;\n     use sync::Future;\n     use task;\n-    use comm::{channel, Sender};\n+    use comm::channel;\n \n     #[test]\n     fn test_from_value() {"}, {"sha": "77f5b01351908c2aa33b123881607c627209654c", "filename": "src/libstd/sync/lock.rs", "status": "removed", "additions": 0, "deletions": 805, "changes": 805, "blob_url": "https://github.com/rust-lang/rust/blob/95d17711397d63425688d18140a58723caddff8e/src%2Flibstd%2Fsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d17711397d63425688d18140a58723caddff8e/src%2Flibstd%2Fsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Flock.rs?ref=95d17711397d63425688d18140a58723caddff8e", "patch": "@@ -1,805 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Wrappers for safe, shared, mutable memory between tasks\n-//!\n-//! The wrappers in this module build on the primitives from `sync::raw` to\n-//! provide safe interfaces around using the primitive locks. These primitives\n-//! implement a technique called \"poisoning\" where when a task panicked with a\n-//! held lock, all future attempts to use the lock will panic.\n-//!\n-//! For example, if two tasks are contending on a mutex and one of them panics\n-//! after grabbing the lock, the second task will immediately panic because the\n-//! lock is now poisoned.\n-\n-use core::prelude::*;\n-\n-use self::Inner::*;\n-\n-use core::cell::UnsafeCell;\n-use rustrt::local::Local;\n-use rustrt::task::Task;\n-\n-use super::raw;\n-\n-// Poisoning helpers\n-\n-struct PoisonOnFail<'a> {\n-    flag: &'a mut bool,\n-    failed: bool,\n-}\n-\n-fn failing() -> bool {\n-    Local::borrow(None::<Task>).unwinder.unwinding()\n-}\n-\n-impl<'a> PoisonOnFail<'a> {\n-    fn check(flag: bool, name: &str) {\n-        if flag {\n-            panic!(\"Poisoned {} - another task failed inside!\", name);\n-        }\n-    }\n-\n-    fn new<'a>(flag: &'a mut bool, name: &str) -> PoisonOnFail<'a> {\n-        PoisonOnFail::check(*flag, name);\n-        PoisonOnFail {\n-            flag: flag,\n-            failed: failing()\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for PoisonOnFail<'a> {\n-    fn drop(&mut self) {\n-        if !self.failed && failing() {\n-            *self.flag = true;\n-        }\n-    }\n-}\n-\n-// Condvar\n-\n-enum Inner<'a> {\n-    InnerMutex(raw::MutexGuard<'a>),\n-    InnerRWLock(raw::RWLockWriteGuard<'a>),\n-}\n-\n-impl<'b> Inner<'b> {\n-    fn cond<'a>(&'a self) -> &'a raw::Condvar<'b> {\n-        match *self {\n-            InnerMutex(ref m) => &m.cond,\n-            InnerRWLock(ref m) => &m.cond,\n-        }\n-    }\n-}\n-\n-/// A condition variable, a mechanism for unlock-and-descheduling and\n-/// signaling, for use with the lock types.\n-pub struct Condvar<'a> {\n-    name: &'static str,\n-    // n.b. Inner must be after PoisonOnFail because we must set the poison flag\n-    //      *inside* the mutex, and struct fields are destroyed top-to-bottom\n-    //      (destroy the lock guard last).\n-    poison: PoisonOnFail<'a>,\n-    inner: Inner<'a>,\n-}\n-\n-impl<'a> Condvar<'a> {\n-    /// Atomically exit the associated lock and block until a signal is sent.\n-    ///\n-    /// wait() is equivalent to wait_on(0).\n-    ///\n-    /// # Panics\n-    ///\n-    /// A task which is killed while waiting on a condition variable will wake\n-    /// up, panic, and unlock the associated lock as it unwinds.\n-    #[inline]\n-    pub fn wait(&self) { self.wait_on(0) }\n-\n-    /// Atomically exit the associated lock and block on a specified condvar\n-    /// until a signal is sent on that same condvar.\n-    ///\n-    /// The associated lock must have been initialised with an appropriate\n-    /// number of condvars. The condvar_id must be between 0 and num_condvars-1\n-    /// or else this call will fail.\n-    #[inline]\n-    pub fn wait_on(&self, condvar_id: uint) {\n-        assert!(!*self.poison.flag);\n-        self.inner.cond().wait_on(condvar_id);\n-        // This is why we need to wrap sync::condvar.\n-        PoisonOnFail::check(*self.poison.flag, self.name);\n-    }\n-\n-    /// Wake up a blocked task. Returns false if there was no blocked task.\n-    #[inline]\n-    pub fn signal(&self) -> bool { self.signal_on(0) }\n-\n-    /// Wake up a blocked task on a specified condvar (as\n-    /// sync::cond.signal_on). Returns false if there was no blocked task.\n-    #[inline]\n-    pub fn signal_on(&self, condvar_id: uint) -> bool {\n-        assert!(!*self.poison.flag);\n-        self.inner.cond().signal_on(condvar_id)\n-    }\n-\n-    /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    #[inline]\n-    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n-\n-    /// Wake up all blocked tasks on a specified condvar (as\n-    /// sync::cond.broadcast_on). Returns the number of tasks woken.\n-    #[inline]\n-    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n-        assert!(!*self.poison.flag);\n-        self.inner.cond().broadcast_on(condvar_id)\n-    }\n-}\n-\n-/// A wrapper type which provides synchronized access to the underlying data, of\n-/// type `T`. A mutex always provides exclusive access, and concurrent requests\n-/// will block while the mutex is already locked.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::sync::{Mutex, Arc};\n-///\n-/// let mutex = Arc::new(Mutex::new(1i));\n-/// let mutex2 = mutex.clone();\n-///\n-/// spawn(proc() {\n-///     let mut val = mutex2.lock();\n-///     *val += 1;\n-///     val.cond.signal();\n-/// });\n-///\n-/// let value = mutex.lock();\n-/// while *value != 2 {\n-///     value.cond.wait();\n-/// }\n-/// ```\n-pub struct Mutex<T> {\n-    lock: raw::Mutex,\n-    failed: UnsafeCell<bool>,\n-    data: UnsafeCell<T>,\n-}\n-\n-/// An guard which is created by locking a mutex. Through this guard the\n-/// underlying data can be accessed.\n-pub struct MutexGuard<'a, T:'a> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _data: &'a mut T,\n-    /// Inner condition variable connected to the locked mutex that this guard\n-    /// was created from. This can be used for atomic-unlock-and-deschedule.\n-    pub cond: Condvar<'a>,\n-}\n-\n-impl<T: Send> Mutex<T> {\n-    /// Creates a new mutex to protect the user-supplied data.\n-    pub fn new(user_data: T) -> Mutex<T> {\n-        Mutex::new_with_condvars(user_data, 1)\n-    }\n-\n-    /// Create a new mutex, with a specified number of associated condvars.\n-    ///\n-    /// This will allow calling wait_on/signal_on/broadcast_on with condvar IDs\n-    /// between 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be\n-    /// allowed but any operations on the condvar will fail.)\n-    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> Mutex<T> {\n-        Mutex {\n-            lock: raw::Mutex::new_with_condvars(num_condvars),\n-            failed: UnsafeCell::new(false),\n-            data: UnsafeCell::new(user_data),\n-        }\n-    }\n-\n-    /// Access the underlying mutable data with mutual exclusion from other\n-    /// tasks. The returned value is an RAII guard which will unlock the mutex\n-    /// when dropped. All concurrent tasks attempting to lock the mutex will\n-    /// block while the returned value is still alive.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panicking while inside the Mutex will unlock the Mutex while unwinding, so\n-    /// that other tasks won't block forever. It will also poison the Mutex:\n-    /// any tasks that subsequently try to access it (including those already\n-    /// blocked on the mutex) will also panic immediately.\n-    #[inline]\n-    pub fn lock<'a>(&'a self) -> MutexGuard<'a, T> {\n-        let guard = self.lock.lock();\n-\n-        // These two accesses are safe because we're guaranteed at this point\n-        // that we have exclusive access to this mutex. We are indeed able to\n-        // promote ourselves from &Mutex to `&mut T`\n-        let poison = unsafe { &mut *self.failed.get() };\n-        let data = unsafe { &mut *self.data.get() };\n-\n-        MutexGuard {\n-            _data: data,\n-            cond: Condvar {\n-                name: \"Mutex\",\n-                poison: PoisonOnFail::new(poison, \"Mutex\"),\n-                inner: InnerMutex(guard),\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a, T: Send> Deref<T> for MutexGuard<'a, T> {\n-    fn deref<'a>(&'a self) -> &'a T { &*self._data }\n-}\n-impl<'a, T: Send> DerefMut<T> for MutexGuard<'a, T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n-}\n-\n-/// A dual-mode reader-writer lock. The data can be accessed mutably or\n-/// immutably, and immutably-accessing tasks may run concurrently.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::sync::{RWLock, Arc};\n-///\n-/// let lock1 = Arc::new(RWLock::new(1i));\n-/// let lock2 = lock1.clone();\n-///\n-/// spawn(proc() {\n-///     let mut val = lock2.write();\n-///     *val = 3;\n-///     let val = val.downgrade();\n-///     println!(\"{}\", *val);\n-/// });\n-///\n-/// let val = lock1.read();\n-/// println!(\"{}\", *val);\n-/// ```\n-pub struct RWLock<T> {\n-    lock: raw::RWLock,\n-    failed: UnsafeCell<bool>,\n-    data: UnsafeCell<T>,\n-}\n-\n-/// A guard which is created by locking an rwlock in write mode. Through this\n-/// guard the underlying data can be accessed.\n-pub struct RWLockWriteGuard<'a, T:'a> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _data: &'a mut T,\n-    /// Inner condition variable that can be used to sleep on the write mode of\n-    /// this rwlock.\n-    pub cond: Condvar<'a>,\n-}\n-\n-/// A guard which is created by locking an rwlock in read mode. Through this\n-/// guard the underlying data can be accessed.\n-pub struct RWLockReadGuard<'a, T:'a> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _data: &'a T,\n-    _guard: raw::RWLockReadGuard<'a>,\n-}\n-\n-impl<T: Send + Sync> RWLock<T> {\n-    /// Create a reader/writer lock with the supplied data.\n-    pub fn new(user_data: T) -> RWLock<T> {\n-        RWLock::new_with_condvars(user_data, 1)\n-    }\n-\n-    /// Create a reader/writer lock with the supplied data and a specified number\n-    /// of condvars (as sync::RWLock::new_with_condvars).\n-    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> RWLock<T> {\n-        RWLock {\n-            lock: raw::RWLock::new_with_condvars(num_condvars),\n-            failed: UnsafeCell::new(false),\n-            data: UnsafeCell::new(user_data),\n-        }\n-    }\n-\n-    /// Access the underlying data mutably. Locks the rwlock in write mode;\n-    /// other readers and writers will block.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panicking while inside the lock will unlock the lock while unwinding, so\n-    /// that other tasks won't block forever. As Mutex.lock, it will also poison\n-    /// the lock, so subsequent readers and writers will both also panic.\n-    #[inline]\n-    pub fn write<'a>(&'a self) -> RWLockWriteGuard<'a, T> {\n-        let guard = self.lock.write();\n-\n-        // These two accesses are safe because we're guaranteed at this point\n-        // that we have exclusive access to this rwlock. We are indeed able to\n-        // promote ourselves from &RWLock to `&mut T`\n-        let poison = unsafe { &mut *self.failed.get() };\n-        let data = unsafe { &mut *self.data.get() };\n-\n-        RWLockWriteGuard {\n-            _data: data,\n-            cond: Condvar {\n-                name: \"RWLock\",\n-                poison: PoisonOnFail::new(poison, \"RWLock\"),\n-                inner: InnerRWLock(guard),\n-            },\n-        }\n-    }\n-\n-    /// Access the underlying data immutably. May run concurrently with other\n-    /// reading tasks.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panicking will unlock the lock while unwinding. However, unlike all other\n-    /// access modes, this will not poison the lock.\n-    pub fn read<'a>(&'a self) -> RWLockReadGuard<'a, T> {\n-        let guard = self.lock.read();\n-        PoisonOnFail::check(unsafe { *self.failed.get() }, \"RWLock\");\n-        RWLockReadGuard {\n-            _guard: guard,\n-            _data: unsafe { &*self.data.get() },\n-        }\n-    }\n-}\n-\n-impl<'a, T: Send + Sync> RWLockWriteGuard<'a, T> {\n-    /// Consumes this write lock token, returning a new read lock token.\n-    ///\n-    /// This will allow pending readers to come into the lock.\n-    pub fn downgrade(self) -> RWLockReadGuard<'a, T> {\n-        let RWLockWriteGuard { _data, cond } = self;\n-        // convert the data to read-only explicitly\n-        let data = &*_data;\n-        let guard = match cond.inner {\n-            InnerMutex(..) => unreachable!(),\n-            InnerRWLock(guard) => guard.downgrade()\n-        };\n-        RWLockReadGuard { _guard: guard, _data: data }\n-    }\n-}\n-\n-impl<'a, T: Send + Sync> Deref<T> for RWLockReadGuard<'a, T> {\n-    fn deref<'a>(&'a self) -> &'a T { self._data }\n-}\n-impl<'a, T: Send + Sync> Deref<T> for RWLockWriteGuard<'a, T> {\n-    fn deref<'a>(&'a self) -> &'a T { &*self._data }\n-}\n-impl<'a, T: Send + Sync> DerefMut<T> for RWLockWriteGuard<'a, T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self._data }\n-}\n-\n-/// A barrier enables multiple tasks to synchronize the beginning\n-/// of some computation.\n-///\n-/// ```rust\n-/// use std::sync::{Arc, Barrier};\n-///\n-/// let barrier = Arc::new(Barrier::new(10));\n-/// for _ in range(0u, 10) {\n-///     let c = barrier.clone();\n-///     // The same messages will be printed together.\n-///     // You will NOT see any interleaving.\n-///     spawn(proc() {\n-///         println!(\"before wait\");\n-///         c.wait();\n-///         println!(\"after wait\");\n-///     });\n-/// }\n-/// ```\n-pub struct Barrier {\n-    lock: Mutex<BarrierState>,\n-    num_tasks: uint,\n-}\n-\n-// The inner state of a double barrier\n-struct BarrierState {\n-    count: uint,\n-    generation_id: uint,\n-}\n-\n-impl Barrier {\n-    /// Create a new barrier that can block a given number of tasks.\n-    pub fn new(num_tasks: uint) -> Barrier {\n-        Barrier {\n-            lock: Mutex::new(BarrierState {\n-                count: 0,\n-                generation_id: 0,\n-            }),\n-            num_tasks: num_tasks,\n-        }\n-    }\n-\n-    /// Block the current task until a certain number of tasks is waiting.\n-    pub fn wait(&self) {\n-        let mut lock = self.lock.lock();\n-        let local_gen = lock.generation_id;\n-        lock.count += 1;\n-        if lock.count < self.num_tasks {\n-            // We need a while loop to guard against spurious wakeups.\n-            // http://en.wikipedia.org/wiki/Spurious_wakeup\n-            while local_gen == lock.generation_id &&\n-                  lock.count < self.num_tasks {\n-                lock.cond.wait();\n-            }\n-        } else {\n-            lock.count = 0;\n-            lock.generation_id += 1;\n-            lock.cond.broadcast();\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use comm::Empty;\n-    use task;\n-    use task::try_future;\n-    use sync::Arc;\n-\n-    use super::{Mutex, Barrier, RWLock};\n-\n-    #[test]\n-    fn test_mutex_arc_condvar() {\n-        let arc = Arc::new(Mutex::new(false));\n-        let arc2 = arc.clone();\n-        let (tx, rx) = channel();\n-        task::spawn(proc() {\n-            // wait until parent gets in\n-            rx.recv();\n-            let mut lock = arc2.lock();\n-            *lock = true;\n-            lock.cond.signal();\n-        });\n-\n-        let lock = arc.lock();\n-        tx.send(());\n-        assert!(!*lock);\n-        while !*lock {\n-            lock.cond.wait();\n-        }\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_arc_condvar_poison() {\n-        let arc = Arc::new(Mutex::new(1i));\n-        let arc2 = arc.clone();\n-        let (tx, rx) = channel();\n-\n-        spawn(proc() {\n-            rx.recv();\n-            let lock = arc2.lock();\n-            lock.cond.signal();\n-            // Parent should fail when it wakes up.\n-            panic!();\n-        });\n-\n-        let lock = arc.lock();\n-        tx.send(());\n-        while *lock == 1 {\n-            lock.cond.wait();\n-        }\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_mutex_arc_poison() {\n-        let arc = Arc::new(Mutex::new(1i));\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            let lock = arc2.lock();\n-            assert_eq!(*lock, 2);\n-        });\n-        let lock = arc.lock();\n-        assert_eq!(*lock, 1);\n-    }\n-\n-    #[test]\n-    fn test_mutex_arc_nested() {\n-        // Tests nested mutexes and access\n-        // to underlying data.\n-        let arc = Arc::new(Mutex::new(1i));\n-        let arc2 = Arc::new(Mutex::new(arc));\n-        task::spawn(proc() {\n-            let lock = arc2.lock();\n-            let lock2 = lock.deref().lock();\n-            assert_eq!(*lock2, 1);\n-        });\n-    }\n-\n-    #[test]\n-    fn test_mutex_arc_access_in_unwind() {\n-        let arc = Arc::new(Mutex::new(1i));\n-        let arc2 = arc.clone();\n-        let _ = task::try::<()>(proc() {\n-            struct Unwinder {\n-                i: Arc<Mutex<int>>,\n-            }\n-            impl Drop for Unwinder {\n-                fn drop(&mut self) {\n-                    let mut lock = self.i.lock();\n-                    *lock += 1;\n-                }\n-            }\n-            let _u = Unwinder { i: arc2 };\n-            panic!();\n-        });\n-        let lock = arc.lock();\n-        assert_eq!(*lock, 2);\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_rw_arc_poison_wr() {\n-        let arc = Arc::new(RWLock::new(1i));\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            let lock = arc2.write();\n-            assert_eq!(*lock, 2);\n-        });\n-        let lock = arc.read();\n-        assert_eq!(*lock, 1);\n-    }\n-    #[test] #[should_fail]\n-    fn test_rw_arc_poison_ww() {\n-        let arc = Arc::new(RWLock::new(1i));\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            let lock = arc2.write();\n-            assert_eq!(*lock, 2);\n-        });\n-        let lock = arc.write();\n-        assert_eq!(*lock, 1);\n-    }\n-    #[test]\n-    fn test_rw_arc_no_poison_rr() {\n-        let arc = Arc::new(RWLock::new(1i));\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            let lock = arc2.read();\n-            assert_eq!(*lock, 2);\n-        });\n-        let lock = arc.read();\n-        assert_eq!(*lock, 1);\n-    }\n-    #[test]\n-    fn test_rw_arc_no_poison_rw() {\n-        let arc = Arc::new(RWLock::new(1i));\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            let lock = arc2.read();\n-            assert_eq!(*lock, 2);\n-        });\n-        let lock = arc.write();\n-        assert_eq!(*lock, 1);\n-    }\n-    #[test]\n-    fn test_rw_arc_no_poison_dr() {\n-        let arc = Arc::new(RWLock::new(1i));\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            let lock = arc2.write().downgrade();\n-            assert_eq!(*lock, 2);\n-        });\n-        let lock = arc.write();\n-        assert_eq!(*lock, 1);\n-    }\n-\n-    #[test]\n-    fn test_rw_arc() {\n-        let arc = Arc::new(RWLock::new(0i));\n-        let arc2 = arc.clone();\n-        let (tx, rx) = channel();\n-\n-        task::spawn(proc() {\n-            let mut lock = arc2.write();\n-            for _ in range(0u, 10) {\n-                let tmp = *lock;\n-                *lock = -1;\n-                task::deschedule();\n-                *lock = tmp + 1;\n-            }\n-            tx.send(());\n-        });\n-\n-        // Readers try to catch the writer in the act\n-        let mut children = Vec::new();\n-        for _ in range(0u, 5) {\n-            let arc3 = arc.clone();\n-            children.push(try_future(proc() {\n-                let lock = arc3.read();\n-                assert!(*lock >= 0);\n-            }));\n-        }\n-\n-        // Wait for children to pass their asserts\n-        for r in children.iter_mut() {\n-            assert!(r.get_ref().is_ok());\n-        }\n-\n-        // Wait for writer to finish\n-        rx.recv();\n-        let lock = arc.read();\n-        assert_eq!(*lock, 10);\n-    }\n-\n-    #[test]\n-    fn test_rw_arc_access_in_unwind() {\n-        let arc = Arc::new(RWLock::new(1i));\n-        let arc2 = arc.clone();\n-        let _ = task::try::<()>(proc() {\n-            struct Unwinder {\n-                i: Arc<RWLock<int>>,\n-            }\n-            impl Drop for Unwinder {\n-                fn drop(&mut self) {\n-                    let mut lock = self.i.write();\n-                    *lock += 1;\n-                }\n-            }\n-            let _u = Unwinder { i: arc2 };\n-            panic!();\n-        });\n-        let lock = arc.read();\n-        assert_eq!(*lock, 2);\n-    }\n-\n-    #[test]\n-    fn test_rw_downgrade() {\n-        // (1) A downgrader gets in write mode and does cond.wait.\n-        // (2) A writer gets in write mode, sets state to 42, and does signal.\n-        // (3) Downgrader wakes, sets state to 31337.\n-        // (4) tells writer and all other readers to contend as it downgrades.\n-        // (5) Writer attempts to set state back to 42, while downgraded task\n-        //     and all reader tasks assert that it's 31337.\n-        let arc = Arc::new(RWLock::new(0i));\n-\n-        // Reader tasks\n-        let mut reader_convos = Vec::new();\n-        for _ in range(0u, 10) {\n-            let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n-            reader_convos.push((tx1, rx2));\n-            let arcn = arc.clone();\n-            task::spawn(proc() {\n-                rx1.recv(); // wait for downgrader to give go-ahead\n-                let lock = arcn.read();\n-                assert_eq!(*lock, 31337);\n-                tx2.send(());\n-            });\n-        }\n-\n-        // Writer task\n-        let arc2 = arc.clone();\n-        let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n-        task::spawn(proc() {\n-            rx1.recv();\n-            {\n-                let mut lock = arc2.write();\n-                assert_eq!(*lock, 0);\n-                *lock = 42;\n-                lock.cond.signal();\n-            }\n-            rx1.recv();\n-            {\n-                let mut lock = arc2.write();\n-                // This shouldn't happen until after the downgrade read\n-                // section, and all other readers, finish.\n-                assert_eq!(*lock, 31337);\n-                *lock = 42;\n-            }\n-            tx2.send(());\n-        });\n-\n-        // Downgrader (us)\n-        let mut lock = arc.write();\n-        tx1.send(()); // send to another writer who will wake us up\n-        while *lock == 0 {\n-            lock.cond.wait();\n-        }\n-        assert_eq!(*lock, 42);\n-        *lock = 31337;\n-        // send to other readers\n-        for &(ref mut rc, _) in reader_convos.iter_mut() {\n-            rc.send(())\n-        }\n-        let lock = lock.downgrade();\n-        // complete handshake with other readers\n-        for &(_, ref mut rp) in reader_convos.iter_mut() {\n-            rp.recv()\n-        }\n-        tx1.send(()); // tell writer to try again\n-        assert_eq!(*lock, 31337);\n-        drop(lock);\n-\n-        rx2.recv(); // complete handshake with writer\n-    }\n-\n-    #[cfg(test)]\n-    fn test_rw_write_cond_downgrade_read_race_helper() {\n-        // Tests that when a downgrader hands off the \"reader cloud\" lock\n-        // because of a contending reader, a writer can't race to get it\n-        // instead, which would result in readers_and_writers. This tests\n-        // the raw module rather than this one, but it's here because an\n-        // rwarc gives us extra shared state to help check for the race.\n-        let x = Arc::new(RWLock::new(true));\n-        let (tx, rx) = channel();\n-\n-        // writer task\n-        let xw = x.clone();\n-        task::spawn(proc() {\n-            let mut lock = xw.write();\n-            tx.send(()); // tell downgrader it's ok to go\n-            lock.cond.wait();\n-            // The core of the test is here: the condvar reacquire path\n-            // must involve order_lock, so that it cannot race with a reader\n-            // trying to receive the \"reader cloud lock hand-off\".\n-            *lock = false;\n-        });\n-\n-        rx.recv(); // wait for writer to get in\n-\n-        let lock = x.write();\n-        assert!(*lock);\n-        // make writer contend in the cond-reacquire path\n-        lock.cond.signal();\n-        // make a reader task to trigger the \"reader cloud lock\" handoff\n-        let xr = x.clone();\n-        let (tx, rx) = channel();\n-        task::spawn(proc() {\n-            tx.send(());\n-            drop(xr.read());\n-        });\n-        rx.recv(); // wait for reader task to exist\n-\n-        let lock = lock.downgrade();\n-        // if writer mistakenly got in, make sure it mutates state\n-        // before we assert on it\n-        for _ in range(0u, 5) { task::deschedule(); }\n-        // make sure writer didn't get in.\n-        assert!(*lock);\n-    }\n-    #[test]\n-    fn test_rw_write_cond_downgrade_read_race() {\n-        // Ideally the above test case would have deschedule statements in it\n-        // that helped to expose the race nearly 100% of the time... but adding\n-        // deschedules in the intuitively-right locations made it even less\n-        // likely, and I wasn't sure why :( . This is a mediocre \"next best\"\n-        // option.\n-        for _ in range(0u, 8) {\n-            test_rw_write_cond_downgrade_read_race_helper();\n-        }\n-    }\n-\n-    #[test]\n-    fn test_barrier() {\n-        let barrier = Arc::new(Barrier::new(10));\n-        let (tx, rx) = channel();\n-\n-        for _ in range(0u, 9) {\n-            let c = barrier.clone();\n-            let tx = tx.clone();\n-            spawn(proc() {\n-                c.wait();\n-                tx.send(true);\n-            });\n-        }\n-\n-        // At this point, all spawned tasks should be blocked,\n-        // so we shouldn't get anything from the port\n-        assert!(match rx.try_recv() {\n-            Err(Empty) => true,\n-            _ => false,\n-        });\n-\n-        barrier.wait();\n-        // Now, the barrier is cleared and we should get data.\n-        for _ in range(0u, 9) {\n-            rx.recv();\n-        }\n-    }\n-}"}, {"sha": "7605a6a96a005d150713a774ff97d2fda90abeff", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -17,41 +17,27 @@\n \n #![experimental]\n \n-pub use self::one::{Once, ONCE_INIT};\n-\n pub use alloc::arc::{Arc, Weak};\n-pub use self::lock::{Mutex, MutexGuard, Condvar, Barrier,\n-                     RWLock, RWLockReadGuard, RWLockWriteGuard};\n \n-// The mutex/rwlock in this module are not meant for reexport\n-pub use self::raw::{Semaphore, SemaphoreGuard};\n+pub use self::mutex::{Mutex, MutexGuard, StaticMutex, StaticMutexGuard, MUTEX_INIT};\n+pub use self::rwlock::{RWLock, StaticRWLock, RWLOCK_INIT};\n+pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n+pub use self::rwlock::{StaticRWLockReadGuard, StaticRWLockWriteGuard};\n+pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT, AsMutexGuard};\n+pub use self::once::{Once, ONCE_INIT};\n+pub use self::semaphore::{Semaphore, SemaphoreGuard};\n+pub use self::barrier::Barrier;\n \n pub use self::future::Future;\n pub use self::task_pool::TaskPool;\n \n-// Core building blocks for all primitives in this crate\n-\n-#[stable]\n pub mod atomic;\n-\n-// Concurrent data structures\n-\n-pub mod spsc_queue;\n-pub mod mpsc_queue;\n-pub mod mpmc_bounded_queue;\n-pub mod deque;\n-\n-// Low-level concurrency primitives\n-\n-mod raw;\n-mod mutex;\n-mod one;\n-\n-// Higher level primitives based on those above\n-\n-mod lock;\n-\n-// Task management\n-\n+mod barrier;\n+mod condvar;\n mod future;\n+mod mutex;\n+mod once;\n+mod poison;\n+mod rwlock;\n+mod semaphore;\n mod task_pool;"}, {"sha": "dca2d4098c6a6152e4b73f2ef0d4b2b820ed739b", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "removed", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/95d17711397d63425688d18140a58723caddff8e/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d17711397d63425688d18140a58723caddff8e/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=95d17711397d63425688d18140a58723caddff8e", "patch": "@@ -1,219 +0,0 @@\n-/* Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- *    1. Redistributions of source code must retain the above copyright notice,\n- *       this list of conditions and the following disclaimer.\n- *\n- *    2. Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY DMITRY VYUKOV \"AS IS\" AND ANY EXPRESS OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n- * SHALL DMITRY VYUKOV OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\n- * The views and conclusions contained in the software and documentation are\n- * those of the authors and should not be interpreted as representing official\n- * policies, either expressed or implied, of Dmitry Vyukov.\n- */\n-\n-#![experimental]\n-#![allow(missing_docs, dead_code)]\n-\n-// http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue\n-\n-use core::prelude::*;\n-\n-use alloc::arc::Arc;\n-use vec::Vec;\n-use core::num::UnsignedInt;\n-use core::cell::UnsafeCell;\n-\n-use sync::atomic::{AtomicUint,Relaxed,Release,Acquire};\n-\n-struct Node<T> {\n-    sequence: AtomicUint,\n-    value: Option<T>,\n-}\n-\n-struct State<T> {\n-    pad0: [u8, ..64],\n-    buffer: Vec<UnsafeCell<Node<T>>>,\n-    mask: uint,\n-    pad1: [u8, ..64],\n-    enqueue_pos: AtomicUint,\n-    pad2: [u8, ..64],\n-    dequeue_pos: AtomicUint,\n-    pad3: [u8, ..64],\n-}\n-\n-pub struct Queue<T> {\n-    state: Arc<State<T>>,\n-}\n-\n-impl<T: Send> State<T> {\n-    fn with_capacity(capacity: uint) -> State<T> {\n-        let capacity = if capacity < 2 || (capacity & (capacity - 1)) != 0 {\n-            if capacity < 2 {\n-                2u\n-            } else {\n-                // use next power of 2 as capacity\n-                capacity.next_power_of_two()\n-            }\n-        } else {\n-            capacity\n-        };\n-        let buffer = Vec::from_fn(capacity, |i| {\n-            UnsafeCell::new(Node { sequence:AtomicUint::new(i), value: None })\n-        });\n-        State{\n-            pad0: [0, ..64],\n-            buffer: buffer,\n-            mask: capacity-1,\n-            pad1: [0, ..64],\n-            enqueue_pos: AtomicUint::new(0),\n-            pad2: [0, ..64],\n-            dequeue_pos: AtomicUint::new(0),\n-            pad3: [0, ..64],\n-        }\n-    }\n-\n-    fn push(&self, value: T) -> bool {\n-        let mask = self.mask;\n-        let mut pos = self.enqueue_pos.load(Relaxed);\n-        loop {\n-            let node = &self.buffer[pos & mask];\n-            let seq = unsafe { (*node.get()).sequence.load(Acquire) };\n-            let diff: int = seq as int - pos as int;\n-\n-            if diff == 0 {\n-                let enqueue_pos = self.enqueue_pos.compare_and_swap(pos, pos+1, Relaxed);\n-                if enqueue_pos == pos {\n-                    unsafe {\n-                        (*node.get()).value = Some(value);\n-                        (*node.get()).sequence.store(pos+1, Release);\n-                    }\n-                    break\n-                } else {\n-                    pos = enqueue_pos;\n-                }\n-            } else if diff < 0 {\n-                return false\n-            } else {\n-                pos = self.enqueue_pos.load(Relaxed);\n-            }\n-        }\n-        true\n-    }\n-\n-    fn pop(&self) -> Option<T> {\n-        let mask = self.mask;\n-        let mut pos = self.dequeue_pos.load(Relaxed);\n-        loop {\n-            let node = &self.buffer[pos & mask];\n-            let seq = unsafe { (*node.get()).sequence.load(Acquire) };\n-            let diff: int = seq as int - (pos + 1) as int;\n-            if diff == 0 {\n-                let dequeue_pos = self.dequeue_pos.compare_and_swap(pos, pos+1, Relaxed);\n-                if dequeue_pos == pos {\n-                    unsafe {\n-                        let value = (*node.get()).value.take();\n-                        (*node.get()).sequence.store(pos + mask + 1, Release);\n-                        return value\n-                    }\n-                } else {\n-                    pos = dequeue_pos;\n-                }\n-            } else if diff < 0 {\n-                return None\n-            } else {\n-                pos = self.dequeue_pos.load(Relaxed);\n-            }\n-        }\n-    }\n-}\n-\n-impl<T: Send> Queue<T> {\n-    pub fn with_capacity(capacity: uint) -> Queue<T> {\n-        Queue{\n-            state: Arc::new(State::with_capacity(capacity))\n-        }\n-    }\n-\n-    pub fn push(&self, value: T) -> bool {\n-        self.state.push(value)\n-    }\n-\n-    pub fn pop(&self) -> Option<T> {\n-        self.state.pop()\n-    }\n-}\n-\n-impl<T: Send> Clone for Queue<T> {\n-    fn clone(&self) -> Queue<T> {\n-        Queue { state: self.state.clone() }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::Queue;\n-\n-    #[test]\n-    fn test() {\n-        let nthreads = 8u;\n-        let nmsgs = 1000u;\n-        let q = Queue::with_capacity(nthreads*nmsgs);\n-        assert_eq!(None, q.pop());\n-        let (tx, rx) = channel();\n-\n-        for _ in range(0, nthreads) {\n-            let q = q.clone();\n-            let tx = tx.clone();\n-            spawn(proc() {\n-                let q = q;\n-                for i in range(0, nmsgs) {\n-                    assert!(q.push(i));\n-                }\n-                tx.send(());\n-            });\n-        }\n-\n-        let mut completion_rxs = vec![];\n-        for _ in range(0, nthreads) {\n-            let (tx, rx) = channel();\n-            completion_rxs.push(rx);\n-            let q = q.clone();\n-            spawn(proc() {\n-                let q = q;\n-                let mut i = 0u;\n-                loop {\n-                    match q.pop() {\n-                        None => {},\n-                        Some(_) => {\n-                            i += 1;\n-                            if i == nmsgs { break }\n-                        }\n-                    }\n-                }\n-                tx.send(i);\n-            });\n-        }\n-\n-        for rx in completion_rxs.iter_mut() {\n-            assert_eq!(nmsgs, rx.recv());\n-        }\n-        for _ in range(0, nthreads) {\n-            rx.recv();\n-        }\n-    }\n-}"}, {"sha": "4e07d54c57e7d6b79b20be42006e4492180b05d1", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 289, "deletions": 75, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,43 +8,68 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A simple native mutex implementation. Warning: this API is likely\n-//! to change soon.\n+use prelude::*;\n \n-#![allow(dead_code)]\n-\n-use core::prelude::*;\n-use alloc::boxed::Box;\n-use rustrt::mutex;\n-\n-pub const LOCKED: uint = 1 << 0;\n-pub const BLOCKED: uint = 1 << 1;\n+use cell::UnsafeCell;\n+use kinds::marker;\n+use sync::{poison, AsMutexGuard};\n+use sys_common::mutex as sys;\n \n /// A mutual exclusion primitive useful for protecting shared data\n ///\n-/// This mutex will properly block tasks waiting for the lock to become\n-/// available. The mutex can also be statically initialized or created via a\n-/// `new` constructor.\n+/// This mutex will block threads waiting for the lock to become available. The\n+/// mutex can also be statically initialized or created via a `new`\n+/// constructor. Each mutex has a type parameter which represents the data that\n+/// it is protecting. The data can only be accessed through the RAII guards\n+/// returned from `lock` and `try_lock`, which guarantees that the data is only\n+/// ever accessed when the mutex is locked.\n+///\n+/// # Poisoning\n+///\n+/// In order to prevent access to otherwise invalid data, each mutex will\n+/// propagate any panics which occur while the lock is held. Once a thread has\n+/// panicked while holding the lock, then all other threads will immediately\n+/// panic as well once they hold the lock.\n ///\n /// # Example\n ///\n-/// ```rust,ignore\n-/// use std::sync::mutex::Mutex;\n+/// ```rust\n+/// use std::sync::{Arc, Mutex};\n+/// const N: uint = 10;\n ///\n-/// let m = Mutex::new();\n-/// let guard = m.lock();\n-/// // do some work\n-/// drop(guard); // unlock the lock\n+/// // Spawn a few threads to increment a shared variable (non-atomically), and\n+/// // let the main thread know once all increments are done.\n+/// //\n+/// // Here we're using an Arc to share memory among tasks, and the data inside\n+/// // the Arc is protected with a mutex.\n+/// let data = Arc::new(Mutex::new(0));\n+///\n+/// let (tx, rx) = channel();\n+/// for _ in range(0u, 10) {\n+///     let (data, tx) = (data.clone(), tx.clone());\n+///     spawn(proc() {\n+///         // The shared static can only be accessed once the lock is held.\n+///         // Our non-atomic increment is safe because we're the only thread\n+///         // which can access the shared state when the lock is held.\n+///         let mut data = data.lock();\n+///         *data += 1;\n+///         if *data == N {\n+///             tx.send(());\n+///         }\n+///         // the lock is unlocked here when `data` goes out of scope.\n+///     });\n+/// }\n+///\n+/// rx.recv();\n /// ```\n-pub struct Mutex {\n+pub struct Mutex<T> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n-    // itself. This is done for memory safety reasons with the usage of a\n-    // StaticNativeMutex inside the static mutex above. Once a native mutex has\n-    // been used once, its address can never change (it can't be moved). This\n-    // mutex type can be safely moved at any time, so to ensure that the native\n-    // mutex is used correctly we box the inner lock to give it a constant\n-    // address.\n-    lock: Box<StaticMutex>,\n+    // itself. Once a native mutex has been used once, its address can never\n+    // change (it can't be moved). This mutex type can be safely moved at any\n+    // time, so to ensure that the native mutex is used correctly we box the\n+    // inner lock to give it a constant address.\n+    inner: Box<StaticMutex>,\n+    data: UnsafeCell<T>,\n }\n \n /// The static mutex type is provided to allow for static allocation of mutexes.\n@@ -57,8 +82,8 @@ pub struct Mutex {\n ///\n /// # Example\n ///\n-/// ```rust,ignore\n-/// use std::sync::mutex::{StaticMutex, MUTEX_INIT};\n+/// ```rust\n+/// use std::sync::{StaticMutex, MUTEX_INIT};\n ///\n /// static LOCK: StaticMutex = MUTEX_INIT;\n ///\n@@ -69,35 +94,113 @@ pub struct Mutex {\n /// // lock is unlocked here.\n /// ```\n pub struct StaticMutex {\n-    lock: mutex::StaticNativeMutex,\n+    lock: sys::Mutex,\n+    poison: UnsafeCell<poison::Flag>,\n }\n \n /// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n /// dropped (falls out of scope), the lock will be unlocked.\n+///\n+/// The data protected by the mutex can be access through this guard via its\n+/// Deref and DerefMut implementations\n #[must_use]\n-pub struct Guard<'a> {\n-    guard: mutex::LockGuard<'a>,\n+pub struct MutexGuard<'a, T: 'a> {\n+    // funny underscores due to how Deref/DerefMut currently work (they\n+    // disregard field privacy).\n+    __lock: &'a Mutex<T>,\n+    __guard: StaticMutexGuard,\n }\n \n-fn lift_guard(guard: mutex::LockGuard) -> Guard {\n-    Guard { guard: guard }\n+/// An RAII implementation of a \"scoped lock\" of a static mutex. When this\n+/// structure is dropped (falls out of scope), the lock will be unlocked.\n+#[must_use]\n+pub struct StaticMutexGuard {\n+    lock: &'static sys::Mutex,\n+    marker: marker::NoSend,\n+    poison: poison::Guard<'static>,\n }\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n pub const MUTEX_INIT: StaticMutex = StaticMutex {\n-    lock: mutex::NATIVE_MUTEX_INIT\n+    lock: sys::MUTEX_INIT,\n+    poison: UnsafeCell { value: poison::Flag { failed: false } },\n };\n \n-impl StaticMutex {\n-    /// Attempts to grab this lock, see `Mutex::try_lock`\n-    pub fn try_lock<'a>(&'a self) -> Option<Guard<'a>> {\n-        unsafe { self.lock.trylock().map(lift_guard) }\n+impl<T: Send> Mutex<T> {\n+    /// Creates a new mutex in an unlocked state ready for use.\n+    pub fn new(t: T) -> Mutex<T> {\n+        Mutex {\n+            inner: box MUTEX_INIT,\n+            data: UnsafeCell::new(t),\n+        }\n+    }\n+\n+    /// Acquires a mutex, blocking the current task until it is able to do so.\n+    ///\n+    /// This function will block the local task until it is available to acquire\n+    /// the mutex. Upon returning, the task is the only task with the mutex\n+    /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n+    /// the guard goes out of scope, the mutex will be unlocked.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If another user of this mutex panicked while holding the mutex, then\n+    /// this call will immediately panic once the mutex is acquired.\n+    pub fn lock(&self) -> MutexGuard<T> {\n+        unsafe {\n+            let lock: &'static StaticMutex = &*(&*self.inner as *const _);\n+            MutexGuard::new(self, lock.lock())\n+        }\n+    }\n+\n+    /// Attempts to acquire this lock.\n+    ///\n+    /// If the lock could not be acquired at this time, then `None` is returned.\n+    /// Otherwise, an RAII guard is returned. The lock will be unlocked when the\n+    /// guard is dropped.\n+    ///\n+    /// This function does not block.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If another user of this mutex panicked while holding the mutex, then\n+    /// this call will immediately panic if the mutex would otherwise be\n+    /// acquired.\n+    pub fn try_lock(&self) -> Option<MutexGuard<T>> {\n+        unsafe {\n+            let lock: &'static StaticMutex = &*(&*self.inner as *const _);\n+            lock.try_lock().map(|guard| {\n+                MutexGuard::new(self, guard)\n+            })\n+        }\n     }\n+}\n \n+#[unsafe_destructor]\n+impl<T: Send> Drop for Mutex<T> {\n+    fn drop(&mut self) {\n+        // This is actually safe b/c we know that there is no further usage of\n+        // this mutex (it's up to the user to arrange for a mutex to get\n+        // dropped, that's not our job)\n+        unsafe { self.inner.lock.destroy() }\n+    }\n+}\n+\n+impl StaticMutex {\n     /// Acquires this lock, see `Mutex::lock`\n-    pub fn lock<'a>(&'a self) -> Guard<'a> {\n-        lift_guard(unsafe { self.lock.lock() })\n+    pub fn lock(&'static self) -> StaticMutexGuard {\n+        unsafe { self.lock.lock() }\n+        StaticMutexGuard::new(self)\n+    }\n+\n+    /// Attempts to grab this lock, see `Mutex::try_lock`\n+    pub fn try_lock(&'static self) -> Option<StaticMutexGuard> {\n+        if unsafe { self.lock.try_lock() } {\n+            Some(StaticMutexGuard::new(self))\n+        } else {\n+            None\n+        }\n     }\n \n     /// Deallocates resources associated with this static mutex.\n@@ -110,58 +213,73 @@ impl StaticMutex {\n     /// *all* platforms. It may be the case that some platforms do not leak\n     /// memory if this method is not called, but this is not guaranteed to be\n     /// true on all platforms.\n-    pub unsafe fn destroy(&self) {\n+    pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()\n     }\n }\n \n-impl Mutex {\n-    /// Creates a new mutex in an unlocked state ready for use.\n-    pub fn new() -> Mutex {\n-        Mutex {\n-            lock: box StaticMutex {\n-                lock: unsafe { mutex::StaticNativeMutex::new() },\n-            }\n-        }\n+impl<'mutex, T> MutexGuard<'mutex, T> {\n+    fn new(lock: &Mutex<T>, guard: StaticMutexGuard) -> MutexGuard<T> {\n+        MutexGuard { __lock: lock, __guard: guard }\n     }\n+}\n \n-    /// Attempts to acquire this lock.\n-    ///\n-    /// If the lock could not be acquired at this time, then `None` is returned.\n-    /// Otherwise, an RAII guard is returned. The lock will be unlocked when the\n-    /// guard is dropped.\n-    ///\n-    /// This function does not block.\n-    pub fn try_lock<'a>(&'a self) -> Option<Guard<'a>> {\n-        self.lock.try_lock()\n+impl<'mutex, T> AsMutexGuard for MutexGuard<'mutex, T> {\n+    unsafe fn as_mutex_guard(&self) -> &StaticMutexGuard { &self.__guard }\n+}\n+\n+impl<'mutex, T> Deref<T> for MutexGuard<'mutex, T> {\n+    fn deref<'a>(&'a self) -> &'a T { unsafe { &*self.__lock.data.get() } }\n+}\n+impl<'mutex, T> DerefMut<T> for MutexGuard<'mutex, T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        unsafe { &mut *self.__lock.data.get() }\n     }\n+}\n \n-    /// Acquires a mutex, blocking the current task until it is able to do so.\n-    ///\n-    /// This function will block the local task until it is available to acquire\n-    /// the mutex. Upon returning, the task is the only task with the mutex\n-    /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n-    /// the guard goes out of scope, the mutex will be unlocked.\n-    pub fn lock<'a>(&'a self) -> Guard<'a> { self.lock.lock() }\n+impl StaticMutexGuard {\n+    fn new(lock: &'static StaticMutex) -> StaticMutexGuard {\n+        unsafe {\n+            let guard = StaticMutexGuard {\n+                lock: &lock.lock,\n+                marker: marker::NoSend,\n+                poison: (*lock.poison.get()).borrow(),\n+            };\n+            guard.poison.check(\"mutex\");\n+            return guard;\n+        }\n+    }\n+}\n+\n+pub fn guard_lock(guard: &StaticMutexGuard) -> &sys::Mutex { guard.lock }\n+pub fn guard_poison(guard: &StaticMutexGuard) -> &poison::Guard {\n+    &guard.poison\n+}\n+\n+impl AsMutexGuard for StaticMutexGuard {\n+    unsafe fn as_mutex_guard(&self) -> &StaticMutexGuard { self }\n }\n \n-impl Drop for Mutex {\n+#[unsafe_destructor]\n+impl Drop for StaticMutexGuard {\n     fn drop(&mut self) {\n-        // This is actually safe b/c we know that there is no further usage of\n-        // this mutex (it's up to the user to arrange for a mutex to get\n-        // dropped, that's not our job)\n-        unsafe { self.lock.destroy() }\n+        unsafe {\n+            self.poison.done();\n+            self.lock.unlock();\n+        }\n     }\n }\n \n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use super::{Mutex, StaticMutex, MUTEX_INIT};\n+\n+    use task;\n+    use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n \n     #[test]\n     fn smoke() {\n-        let m = Mutex::new();\n+        let m = Mutex::new(());\n         drop(m.lock());\n         drop(m.lock());\n     }\n@@ -211,8 +329,104 @@ mod test {\n     }\n \n     #[test]\n-    fn trylock() {\n-        let m = Mutex::new();\n+    fn try_lock() {\n+        let m = Mutex::new(());\n         assert!(m.try_lock().is_some());\n     }\n+\n+    #[test]\n+    fn test_mutex_arc_condvar() {\n+        let arc = Arc::new((Mutex::new(false), Condvar::new()));\n+        let arc2 = arc.clone();\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            // wait until parent gets in\n+            rx.recv();\n+            let &(ref lock, ref cvar) = &*arc2;\n+            let mut lock = lock.lock();\n+            *lock = true;\n+            cvar.notify_one();\n+        });\n+\n+        let &(ref lock, ref cvar) = &*arc;\n+        let lock = lock.lock();\n+        tx.send(());\n+        assert!(!*lock);\n+        while !*lock {\n+            cvar.wait(&lock);\n+        }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_arc_condvar_poison() {\n+        let arc = Arc::new((Mutex::new(1i), Condvar::new()));\n+        let arc2 = arc.clone();\n+        let (tx, rx) = channel();\n+\n+        spawn(proc() {\n+            rx.recv();\n+            let &(ref lock, ref cvar) = &*arc2;\n+            let _g = lock.lock();\n+            cvar.notify_one();\n+            // Parent should fail when it wakes up.\n+            panic!();\n+        });\n+\n+        let &(ref lock, ref cvar) = &*arc;\n+        let lock = lock.lock();\n+        tx.send(());\n+        while *lock == 1 {\n+            cvar.wait(&lock);\n+        }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_mutex_arc_poison() {\n+        let arc = Arc::new(Mutex::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.lock();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.lock();\n+        assert_eq!(*lock, 1);\n+    }\n+\n+    #[test]\n+    fn test_mutex_arc_nested() {\n+        // Tests nested mutexes and access\n+        // to underlying data.\n+        let arc = Arc::new(Mutex::new(1i));\n+        let arc2 = Arc::new(Mutex::new(arc));\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            let lock = arc2.lock();\n+            let lock2 = lock.deref().lock();\n+            assert_eq!(*lock2, 1);\n+            tx.send(());\n+        });\n+        rx.recv();\n+    }\n+\n+    #[test]\n+    fn test_mutex_arc_access_in_unwind() {\n+        let arc = Arc::new(Mutex::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try::<()>(proc() {\n+            struct Unwinder {\n+                i: Arc<Mutex<int>>,\n+            }\n+            impl Drop for Unwinder {\n+                fn drop(&mut self) {\n+                    *self.i.lock() += 1;\n+                }\n+            }\n+            let _u = Unwinder { i: arc2 };\n+            panic!();\n+        });\n+        let lock = arc.lock();\n+        assert_eq!(*lock, 2);\n+    }\n }"}, {"sha": "a75088120f869f73e0db460b0d1f04dd98224aee", "filename": "src/libstd/sync/once.rs", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -13,12 +13,10 @@\n //! This primitive is meant to be used to run one-time initialization. An\n //! example use case would be for initializing an FFI library.\n \n-use core::prelude::*;\n-\n-use core::int;\n-use core::atomic;\n-\n-use super::mutex::{StaticMutex, MUTEX_INIT};\n+use int;\n+use mem::drop;\n+use sync::atomic;\n+use sync::{StaticMutex, MUTEX_INIT};\n \n /// A synchronization primitive which can be used to run a one-time global\n /// initialization. Useful for one-time initialization for FFI or related\n@@ -27,8 +25,8 @@ use super::mutex::{StaticMutex, MUTEX_INIT};\n ///\n /// # Example\n ///\n-/// ```rust,ignore\n-/// use std::sync::one::{Once, ONCE_INIT};\n+/// ```rust\n+/// use std::sync::{Once, ONCE_INIT};\n ///\n /// static START: Once = ONCE_INIT;\n ///\n@@ -59,7 +57,7 @@ impl Once {\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified).\n-    pub fn doit(&self, f: ||) {\n+    pub fn doit(&'static self, f: ||) {\n         // Optimize common path: load is much cheaper than fetch_add.\n         if self.cnt.load(atomic::SeqCst) < 0 {\n             return\n@@ -121,6 +119,7 @@ impl Once {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n+\n     use task;\n     use super::{ONCE_INIT, Once};\n ", "previous_filename": "src/libstd/sync/one.rs"}, {"sha": "eb46fd771477e6df7349f00258478993e077dee4", "filename": "src/libstd/sync/poison.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::None;\n+use rustrt::task::Task;\n+use rustrt::local::Local;\n+\n+pub struct Flag { pub failed: bool }\n+\n+impl Flag {\n+    pub fn borrow(&mut self) -> Guard {\n+        Guard { flag: &mut self.failed, failing: failing() }\n+    }\n+}\n+\n+pub struct Guard<'a> {\n+    flag: &'a mut bool,\n+    failing: bool,\n+}\n+\n+impl<'a> Guard<'a> {\n+    pub fn check(&self, name: &str) {\n+        if *self.flag {\n+            panic!(\"poisoned {} - another task failed inside\", name);\n+        }\n+    }\n+\n+    pub fn done(&mut self) {\n+        if !self.failing && failing() {\n+            *self.flag = true;\n+        }\n+    }\n+}\n+\n+fn failing() -> bool {\n+    if Local::exists(None::<Task>) {\n+        Local::borrow(None::<Task>).unwinder.unwinding()\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "47580a115131bb2e467b3ca2df280992da04b978", "filename": "src/libstd/sync/raw.rs", "status": "removed", "additions": 0, "deletions": 1132, "changes": 1132, "blob_url": "https://github.com/rust-lang/rust/blob/95d17711397d63425688d18140a58723caddff8e/src%2Flibstd%2Fsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d17711397d63425688d18140a58723caddff8e/src%2Flibstd%2Fsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fraw.rs?ref=95d17711397d63425688d18140a58723caddff8e", "patch": "@@ -1,1132 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Raw concurrency primitives you know and love.\n-//!\n-//! These primitives are not recommended for general use, but are provided for\n-//! flavorful use-cases. It is recommended to use the types at the top of the\n-//! `sync` crate which wrap values directly and provide safer abstractions for\n-//! containing data.\n-\n-// A side-effect of merging libsync into libstd; will go away once\n-// libsync rewrite lands\n-#![allow(dead_code)]\n-\n-use core::prelude::*;\n-use self::ReacquireOrderLock::*;\n-\n-use core::atomic;\n-use core::finally::Finally;\n-use core::kinds::marker;\n-use core::mem;\n-use core::cell::UnsafeCell;\n-use vec::Vec;\n-\n-use super::mutex;\n-use comm::{Receiver, Sender, channel};\n-\n-// Each waiting task receives on one of these.\n-type WaitEnd = Receiver<()>;\n-type SignalEnd = Sender<()>;\n-// A doubly-ended queue of waiting tasks.\n-struct WaitQueue {\n-    head: Receiver<SignalEnd>,\n-    tail: Sender<SignalEnd>,\n-}\n-\n-impl WaitQueue {\n-    fn new() -> WaitQueue {\n-        let (block_tail, block_head) = channel();\n-        WaitQueue { head: block_head, tail: block_tail }\n-    }\n-\n-    // Signals one live task from the queue.\n-    fn signal(&self) -> bool {\n-        match self.head.try_recv() {\n-            Ok(ch) => {\n-                // Send a wakeup signal. If the waiter was killed, its port will\n-                // have closed. Keep trying until we get a live task.\n-                if ch.send_opt(()).is_ok() {\n-                    true\n-                } else {\n-                    self.signal()\n-                }\n-            }\n-            _ => false\n-        }\n-    }\n-\n-    fn broadcast(&self) -> uint {\n-        let mut count = 0;\n-        loop {\n-            match self.head.try_recv() {\n-                Ok(ch) => {\n-                    if ch.send_opt(()).is_ok() {\n-                        count += 1;\n-                    }\n-                }\n-                _ => break\n-            }\n-        }\n-        count\n-    }\n-\n-    fn wait_end(&self) -> WaitEnd {\n-        let (signal_end, wait_end) = channel();\n-        self.tail.send(signal_end);\n-        wait_end\n-    }\n-}\n-\n-// The building-block used to make semaphores, mutexes, and rwlocks.\n-struct Sem<Q> {\n-    lock: mutex::Mutex,\n-    // n.b, we need Sem to be `Sync`, but the WaitQueue type is not send/share\n-    //      (for good reason). We have an internal invariant on this semaphore,\n-    //      however, that the queue is never accessed outside of a locked\n-    //      context.\n-    inner: UnsafeCell<SemInner<Q>>\n-}\n-\n-struct SemInner<Q> {\n-    count: int,\n-    waiters: WaitQueue,\n-    // Can be either unit or another waitqueue. Some sems shouldn't come with\n-    // a condition variable attached, others should.\n-    blocked: Q,\n-}\n-\n-#[must_use]\n-struct SemGuard<'a, Q:'a> {\n-    sem: &'a Sem<Q>,\n-}\n-\n-impl<Q: Send> Sem<Q> {\n-    fn new(count: int, q: Q) -> Sem<Q> {\n-        assert!(count >= 0,\n-                \"semaphores cannot be initialized with negative values\");\n-        Sem {\n-            lock: mutex::Mutex::new(),\n-            inner: UnsafeCell::new(SemInner {\n-                waiters: WaitQueue::new(),\n-                count: count,\n-                blocked: q,\n-            })\n-        }\n-    }\n-\n-    unsafe fn with(&self, f: |&mut SemInner<Q>|) {\n-        let _g = self.lock.lock();\n-        // This &mut is safe because, due to the lock, we are the only one who can touch the data\n-        f(&mut *self.inner.get())\n-    }\n-\n-    pub fn acquire(&self) {\n-        unsafe {\n-            let mut waiter_nobe = None;\n-            self.with(|state| {\n-                state.count -= 1;\n-                if state.count < 0 {\n-                    // Create waiter nobe, enqueue ourself, and tell\n-                    // outer scope we need to block.\n-                    waiter_nobe = Some(state.waiters.wait_end());\n-                }\n-            });\n-            // Uncomment if you wish to test for sem races. Not\n-            // valgrind-friendly.\n-            /* for _ in range(0u, 1000) { task::deschedule(); } */\n-            // Need to wait outside the exclusive.\n-            if waiter_nobe.is_some() {\n-                let _ = waiter_nobe.unwrap().recv();\n-            }\n-        }\n-    }\n-\n-    pub fn release(&self) {\n-        unsafe {\n-            self.with(|state| {\n-                state.count += 1;\n-                if state.count <= 0 {\n-                    state.waiters.signal();\n-                }\n-            })\n-        }\n-    }\n-\n-    pub fn access<'a>(&'a self) -> SemGuard<'a, Q> {\n-        self.acquire();\n-        SemGuard { sem: self }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a, Q: Send> Drop for SemGuard<'a, Q> {\n-    fn drop(&mut self) {\n-        self.sem.release();\n-    }\n-}\n-\n-impl Sem<Vec<WaitQueue>> {\n-    fn new_and_signal(count: int, num_condvars: uint) -> Sem<Vec<WaitQueue>> {\n-        let mut queues = Vec::new();\n-        for _ in range(0, num_condvars) { queues.push(WaitQueue::new()); }\n-        Sem::new(count, queues)\n-    }\n-\n-    // The only other places that condvars get built are rwlock.write_cond()\n-    // and rwlock_write_mode.\n-    pub fn access_cond<'a>(&'a self) -> SemCondGuard<'a> {\n-        SemCondGuard {\n-            guard: self.access(),\n-            cvar: Condvar { sem: self, order: Nothing, nocopy: marker::NoCopy },\n-        }\n-    }\n-}\n-\n-// FIXME(#3598): Want to use an Option down below, but we need a custom enum\n-// that's not polymorphic to get around the fact that lifetimes are invariant\n-// inside of type parameters.\n-enum ReacquireOrderLock<'a> {\n-    Nothing, // c.c\n-    Just(&'a Semaphore),\n-}\n-\n-/// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar<'a> {\n-    // The 'Sem' object associated with this condvar. This is the one that's\n-    // atomically-unlocked-and-descheduled upon and reacquired during wakeup.\n-    sem: &'a Sem<Vec<WaitQueue> >,\n-    // This is (can be) an extra semaphore which is held around the reacquire\n-    // operation on the first one. This is only used in cvars associated with\n-    // rwlocks, and is needed to ensure that, when a downgrader is trying to\n-    // hand off the access lock (which would be the first field, here), a 2nd\n-    // writer waking up from a cvar wait can't race with a reader to steal it,\n-    // See the comment in write_cond for more detail.\n-    order: ReacquireOrderLock<'a>,\n-    // Make sure condvars are non-copyable.\n-    nocopy: marker::NoCopy,\n-}\n-\n-impl<'a> Condvar<'a> {\n-    /// Atomically drop the associated lock, and block until a signal is sent.\n-    ///\n-    /// # Panics\n-    ///\n-    /// A task which is killed while waiting on a condition variable will wake\n-    /// up, panic, and unlock the associated lock as it unwinds.\n-    pub fn wait(&self) { self.wait_on(0) }\n-\n-    /// As wait(), but can specify which of multiple condition variables to\n-    /// wait on. Only a signal_on() or broadcast_on() with the same condvar_id\n-    /// will wake this thread.\n-    ///\n-    /// The associated lock must have been initialised with an appropriate\n-    /// number of condvars. The condvar_id must be between 0 and num_condvars-1\n-    /// or else this call will panic.\n-    ///\n-    /// wait() is equivalent to wait_on(0).\n-    pub fn wait_on(&self, condvar_id: uint) {\n-        let mut wait_end = None;\n-        let mut out_of_bounds = None;\n-        // Release lock, 'atomically' enqueuing ourselves in so doing.\n-        unsafe {\n-            self.sem.with(|state| {\n-                if condvar_id < state.blocked.len() {\n-                    // Drop the lock.\n-                    state.count += 1;\n-                    if state.count <= 0 {\n-                        state.waiters.signal();\n-                    }\n-                    // Create waiter nobe, and enqueue ourself to\n-                    // be woken up by a signaller.\n-                    wait_end = Some(state.blocked[condvar_id].wait_end());\n-                } else {\n-                    out_of_bounds = Some(state.blocked.len());\n-                }\n-            })\n-        }\n-\n-        // If deschedule checks start getting inserted anywhere, we can be\n-        // killed before or after enqueueing.\n-        check_cvar_bounds(out_of_bounds, condvar_id, \"cond.wait_on()\", || {\n-            // Unconditionally \"block\". (Might not actually block if a\n-            // signaller already sent -- I mean 'unconditionally' in contrast\n-            // with acquire().)\n-            (|| {\n-                let _ = wait_end.take().unwrap().recv();\n-            }).finally(|| {\n-                // Reacquire the condvar.\n-                match self.order {\n-                    Just(lock) => {\n-                        let _g = lock.access();\n-                        self.sem.acquire();\n-                    }\n-                    Nothing => self.sem.acquire(),\n-                }\n-            })\n-        })\n-    }\n-\n-    /// Wake up a blocked task. Returns false if there was no blocked task.\n-    pub fn signal(&self) -> bool { self.signal_on(0) }\n-\n-    /// As signal, but with a specified condvar_id. See wait_on.\n-    pub fn signal_on(&self, condvar_id: uint) -> bool {\n-        unsafe {\n-            let mut out_of_bounds = None;\n-            let mut result = false;\n-            self.sem.with(|state| {\n-                if condvar_id < state.blocked.len() {\n-                    result = state.blocked[condvar_id].signal();\n-                } else {\n-                    out_of_bounds = Some(state.blocked.len());\n-                }\n-            });\n-            check_cvar_bounds(out_of_bounds,\n-                              condvar_id,\n-                              \"cond.signal_on()\",\n-                              || result)\n-        }\n-    }\n-\n-    /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n-\n-    /// As broadcast, but with a specified condvar_id. See wait_on.\n-    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n-        let mut out_of_bounds = None;\n-        let mut queue = None;\n-        unsafe {\n-            self.sem.with(|state| {\n-                if condvar_id < state.blocked.len() {\n-                    // To avoid :broadcast_heavy, we make a new waitqueue,\n-                    // swap it out with the old one, and broadcast on the\n-                    // old one outside of the little-lock.\n-                    queue = Some(mem::replace(&mut state.blocked[condvar_id],\n-                                              WaitQueue::new()));\n-                } else {\n-                    out_of_bounds = Some(state.blocked.len());\n-                }\n-            });\n-            check_cvar_bounds(out_of_bounds,\n-                              condvar_id,\n-                              \"cond.signal_on()\",\n-                              || {\n-                queue.take().unwrap().broadcast()\n-            })\n-        }\n-    }\n-}\n-\n-// Checks whether a condvar ID was out of bounds, and panics if so, or does\n-// something else next on success.\n-#[inline]\n-fn check_cvar_bounds<U>(\n-                     out_of_bounds: Option<uint>,\n-                     id: uint,\n-                     act: &str,\n-                     blk: || -> U)\n-                     -> U {\n-    match out_of_bounds {\n-        Some(0) =>\n-            panic!(\"{} with illegal ID {} - this lock has no condvars!\", act, id),\n-        Some(length) =>\n-            panic!(\"{} with illegal ID {} - ID must be less than {}\", act, id, length),\n-        None => blk()\n-    }\n-}\n-\n-#[must_use]\n-struct SemCondGuard<'a> {\n-    guard: SemGuard<'a, Vec<WaitQueue>>,\n-    cvar: Condvar<'a>,\n-}\n-\n-/// A counting, blocking, bounded-waiting semaphore.\n-pub struct Semaphore {\n-    sem: Sem<()>,\n-}\n-\n-/// An RAII guard used to represent an acquired resource to a semaphore. When\n-/// dropped, this value will release the resource back to the semaphore.\n-#[must_use]\n-pub struct SemaphoreGuard<'a> {\n-    _guard: SemGuard<'a, ()>,\n-}\n-\n-impl Semaphore {\n-    /// Create a new semaphore with the specified count.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if `count` is negative.\n-    pub fn new(count: int) -> Semaphore {\n-        Semaphore { sem: Sem::new(count, ()) }\n-    }\n-\n-    /// Acquire a resource represented by the semaphore. Blocks if necessary\n-    /// until resource(s) become available.\n-    pub fn acquire(&self) { self.sem.acquire() }\n-\n-    /// Release a held resource represented by the semaphore. Wakes a blocked\n-    /// contending task, if any exist. Won't block the caller.\n-    pub fn release(&self) { self.sem.release() }\n-\n-    /// Acquire a resource of this semaphore, returning an RAII guard which will\n-    /// release the resource when dropped.\n-    pub fn access<'a>(&'a self) -> SemaphoreGuard<'a> {\n-        SemaphoreGuard { _guard: self.sem.access() }\n-    }\n-}\n-\n-/// A blocking, bounded-waiting, mutual exclusion lock with an associated\n-/// FIFO condition variable.\n-///\n-/// # Panics\n-///\n-/// A task which panicks while holding a mutex will unlock the mutex as it\n-/// unwinds.\n-pub struct Mutex {\n-    sem: Sem<Vec<WaitQueue>>,\n-}\n-\n-/// An RAII structure which is used to gain access to a mutex's condition\n-/// variable. Additionally, when a value of this type is dropped, the\n-/// corresponding mutex is also unlocked.\n-#[must_use]\n-pub struct MutexGuard<'a> {\n-    _guard: SemGuard<'a, Vec<WaitQueue>>,\n-    /// Inner condition variable which is connected to the outer mutex, and can\n-    /// be used for atomic-unlock-and-deschedule.\n-    pub cond: Condvar<'a>,\n-}\n-\n-impl Mutex {\n-    /// Create a new mutex, with one associated condvar.\n-    pub fn new() -> Mutex { Mutex::new_with_condvars(1) }\n-\n-    /// Create a new mutex, with a specified number of associated condvars. This\n-    /// will allow calling wait_on/signal_on/broadcast_on with condvar IDs\n-    /// between 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be\n-    /// allowed but any operations on the condvar will panic.)\n-    pub fn new_with_condvars(num_condvars: uint) -> Mutex {\n-        Mutex { sem: Sem::new_and_signal(1, num_condvars) }\n-    }\n-\n-    /// Acquires ownership of this mutex, returning an RAII guard which will\n-    /// unlock the mutex when dropped. The associated condition variable can\n-    /// also be accessed through the returned guard.\n-    pub fn lock<'a>(&'a self) -> MutexGuard<'a> {\n-        let SemCondGuard { guard, cvar } = self.sem.access_cond();\n-        MutexGuard { _guard: guard, cond: cvar }\n-    }\n-}\n-\n-// NB: Wikipedia - Readers-writers_problem#The_third_readers-writers_problem\n-\n-/// A blocking, no-starvation, reader-writer lock with an associated condvar.\n-///\n-/// # Panics\n-///\n-/// A task which panics while holding an rwlock will unlock the rwlock as it\n-/// unwinds.\n-pub struct RWLock {\n-    order_lock:  Semaphore,\n-    access_lock: Sem<Vec<WaitQueue>>,\n-\n-    // The only way the count flag is ever accessed is with xadd. Since it is\n-    // a read-modify-write operation, multiple xadds on different cores will\n-    // always be consistent with respect to each other, so a monotonic/relaxed\n-    // consistency ordering suffices (i.e., no extra barriers are needed).\n-    //\n-    // FIXME(#6598): The atomics module has no relaxed ordering flag, so I use\n-    // acquire/release orderings superfluously. Change these someday.\n-    read_count: atomic::AtomicUint,\n-}\n-\n-/// An RAII helper which is created by acquiring a read lock on an RWLock. When\n-/// dropped, this will unlock the RWLock.\n-#[must_use]\n-pub struct RWLockReadGuard<'a> {\n-    lock: &'a RWLock,\n-}\n-\n-/// An RAII helper which is created by acquiring a write lock on an RWLock. When\n-/// dropped, this will unlock the RWLock.\n-///\n-/// A value of this type can also be consumed to downgrade to a read-only lock.\n-#[must_use]\n-pub struct RWLockWriteGuard<'a> {\n-    lock: &'a RWLock,\n-    /// Inner condition variable that is connected to the write-mode of the\n-    /// outer rwlock.\n-    pub cond: Condvar<'a>,\n-}\n-\n-impl RWLock {\n-    /// Create a new rwlock, with one associated condvar.\n-    pub fn new() -> RWLock { RWLock::new_with_condvars(1) }\n-\n-    /// Create a new rwlock, with a specified number of associated condvars.\n-    /// Similar to mutex_with_condvars.\n-    pub fn new_with_condvars(num_condvars: uint) -> RWLock {\n-        RWLock {\n-            order_lock: Semaphore::new(1),\n-            access_lock: Sem::new_and_signal(1, num_condvars),\n-            read_count: atomic::AtomicUint::new(0),\n-        }\n-    }\n-\n-    /// Acquires a read-lock, returning an RAII guard that will unlock the lock\n-    /// when dropped. Calls to 'read' from other tasks may run concurrently with\n-    /// this one.\n-    pub fn read<'a>(&'a self) -> RWLockReadGuard<'a> {\n-        let _guard = self.order_lock.access();\n-        let old_count = self.read_count.fetch_add(1, atomic::Acquire);\n-        if old_count == 0 {\n-            self.access_lock.acquire();\n-        }\n-        RWLockReadGuard { lock: self }\n-    }\n-\n-    /// Acquire a write-lock, returning an RAII guard that will unlock the lock\n-    /// when dropped. No calls to 'read' or 'write' from other tasks will run\n-    /// concurrently with this one.\n-    ///\n-    /// You can also downgrade a write to a read by calling the `downgrade`\n-    /// method on the returned guard. Additionally, the guard will contain a\n-    /// `Condvar` attached to this lock.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```{rust,ignore}\n-    /// use std::sync::raw::RWLock;\n-    ///\n-    /// let lock = RWLock::new();\n-    /// let write = lock.write();\n-    /// // ... exclusive access ...\n-    /// let read = write.downgrade();\n-    /// // ... shared access ...\n-    /// drop(read);\n-    /// ```\n-    pub fn write<'a>(&'a self) -> RWLockWriteGuard<'a> {\n-        let _g = self.order_lock.access();\n-        self.access_lock.acquire();\n-\n-        // It's important to thread our order lock into the condvar, so that\n-        // when a cond.wait() wakes up, it uses it while reacquiring the\n-        // access lock. If we permitted a waking-up writer to \"cut in line\",\n-        // there could arise a subtle race when a downgrader attempts to hand\n-        // off the reader cloud lock to a waiting reader. This race is tested\n-        // in arc.rs (test_rw_write_cond_downgrade_read_race) and looks like:\n-        // T1 (writer)              T2 (downgrader)             T3 (reader)\n-        // [in cond.wait()]\n-        //                          [locks for writing]\n-        //                          [holds access_lock]\n-        // [is signalled, perhaps by\n-        //  downgrader or a 4th thread]\n-        // tries to lock access(!)\n-        //                                                      lock order_lock\n-        //                                                      xadd read_count[0->1]\n-        //                                                      tries to lock access\n-        //                          [downgrade]\n-        //                          xadd read_count[1->2]\n-        //                          unlock access\n-        // Since T1 contended on the access lock before T3 did, it will steal\n-        // the lock handoff. Adding order_lock in the condvar reacquire path\n-        // solves this because T1 will hold order_lock while waiting on access,\n-        // which will cause T3 to have to wait until T1 finishes its write,\n-        // which can't happen until T2 finishes the downgrade-read entirely.\n-        // The astute reader will also note that making waking writers use the\n-        // order_lock is better for not starving readers.\n-        RWLockWriteGuard {\n-            lock: self,\n-            cond: Condvar {\n-                sem: &self.access_lock,\n-                order: Just(&self.order_lock),\n-                nocopy: marker::NoCopy,\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> RWLockWriteGuard<'a> {\n-    /// Consumes this write lock and converts it into a read lock.\n-    pub fn downgrade(self) -> RWLockReadGuard<'a> {\n-        let lock = self.lock;\n-        // Don't run the destructor of the write guard, we're in charge of\n-        // things from now on\n-        unsafe { mem::forget(self) }\n-\n-        let old_count = lock.read_count.fetch_add(1, atomic::Release);\n-        // If another reader was already blocking, we need to hand-off\n-        // the \"reader cloud\" access lock to them.\n-        if old_count != 0 {\n-            // Guaranteed not to let another writer in, because\n-            // another reader was holding the order_lock. Hence they\n-            // must be the one to get the access_lock (because all\n-            // access_locks are acquired with order_lock held). See\n-            // the comment in write_cond for more justification.\n-            lock.access_lock.release();\n-        }\n-        RWLockReadGuard { lock: lock }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for RWLockWriteGuard<'a> {\n-    fn drop(&mut self) {\n-        self.lock.access_lock.release();\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for RWLockReadGuard<'a> {\n-    fn drop(&mut self) {\n-        let old_count = self.lock.read_count.fetch_sub(1, atomic::Release);\n-        assert!(old_count > 0);\n-        if old_count == 1 {\n-            // Note: this release used to be outside of a locked access\n-            // to exclusive-protected state. If this code is ever\n-            // converted back to such (instead of using atomic ops),\n-            // this access MUST NOT go inside the exclusive access.\n-            self.lock.access_lock.release();\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    pub use self::RWLockMode::*;\n-\n-    use sync::Arc;\n-    use prelude::*;\n-    use super::{Semaphore, Mutex, RWLock, Condvar};\n-\n-    use mem;\n-    use result;\n-    use task;\n-\n-    #[test]\n-    fn test_sem_acquire_release() {\n-        let s = Semaphore::new(1);\n-        s.acquire();\n-        s.release();\n-        s.acquire();\n-    }\n-\n-    #[test]\n-    fn test_sem_basic() {\n-        let s = Semaphore::new(1);\n-        let _g = s.access();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_sem_basic2() {\n-        Semaphore::new(-1);\n-    }\n-\n-    #[test]\n-    fn test_sem_as_mutex() {\n-        let s = Arc::new(Semaphore::new(1));\n-        let s2 = s.clone();\n-        task::spawn(proc() {\n-            let _g = s2.access();\n-            for _ in range(0u, 5) { task::deschedule(); }\n-        });\n-        let _g = s.access();\n-        for _ in range(0u, 5) { task::deschedule(); }\n-    }\n-\n-    #[test]\n-    fn test_sem_as_cvar() {\n-        /* Child waits and parent signals */\n-        let (tx, rx) = channel();\n-        let s = Arc::new(Semaphore::new(0));\n-        let s2 = s.clone();\n-        task::spawn(proc() {\n-            s2.acquire();\n-            tx.send(());\n-        });\n-        for _ in range(0u, 5) { task::deschedule(); }\n-        s.release();\n-        let _ = rx.recv();\n-\n-        /* Parent waits and child signals */\n-        let (tx, rx) = channel();\n-        let s = Arc::new(Semaphore::new(0));\n-        let s2 = s.clone();\n-        task::spawn(proc() {\n-            for _ in range(0u, 5) { task::deschedule(); }\n-            s2.release();\n-            let _ = rx.recv();\n-        });\n-        s.acquire();\n-        tx.send(());\n-    }\n-\n-    #[test]\n-    fn test_sem_multi_resource() {\n-        // Parent and child both get in the critical section at the same\n-        // time, and shake hands.\n-        let s = Arc::new(Semaphore::new(2));\n-        let s2 = s.clone();\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        task::spawn(proc() {\n-            let _g = s2.access();\n-            let _ = rx2.recv();\n-            tx1.send(());\n-        });\n-        let _g = s.access();\n-        tx2.send(());\n-        let _ = rx1.recv();\n-    }\n-\n-    #[test]\n-    fn test_sem_runtime_friendly_blocking() {\n-        // Force the runtime to schedule two threads on the same sched_loop.\n-        // When one blocks, it should schedule the other one.\n-        let s = Arc::new(Semaphore::new(1));\n-        let s2 = s.clone();\n-        let (tx, rx) = channel();\n-        {\n-            let _g = s.access();\n-            task::spawn(proc() {\n-                tx.send(());\n-                drop(s2.access());\n-                tx.send(());\n-            });\n-            rx.recv(); // wait for child to come alive\n-            for _ in range(0u, 5) { task::deschedule(); } // let the child contend\n-        }\n-        rx.recv(); // wait for child to be done\n-    }\n-\n-    #[test]\n-    fn test_mutex_lock() {\n-        // Unsafely achieve shared state, and do the textbook\n-        // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n-        let (tx, rx) = channel();\n-        let m = Arc::new(Mutex::new());\n-        let m2 = m.clone();\n-        let mut sharedstate = box 0;\n-        {\n-            let ptr: *mut int = &mut *sharedstate;\n-            task::spawn(proc() {\n-                access_shared(ptr, &m2, 10);\n-                tx.send(());\n-            });\n-        }\n-        {\n-            access_shared(&mut *sharedstate, &m, 10);\n-            let _ = rx.recv();\n-\n-            assert_eq!(*sharedstate, 20);\n-        }\n-\n-        fn access_shared(sharedstate: *mut int, m: &Arc<Mutex>, n: uint) {\n-            for _ in range(0u, n) {\n-                let _g = m.lock();\n-                let oldval = unsafe { *sharedstate };\n-                task::deschedule();\n-                unsafe { *sharedstate = oldval + 1; }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_mutex_cond_wait() {\n-        let m = Arc::new(Mutex::new());\n-\n-        // Child wakes up parent\n-        {\n-            let lock = m.lock();\n-            let m2 = m.clone();\n-            task::spawn(proc() {\n-                let lock = m2.lock();\n-                let woken = lock.cond.signal();\n-                assert!(woken);\n-            });\n-            lock.cond.wait();\n-        }\n-        // Parent wakes up child\n-        let (tx, rx) = channel();\n-        let m3 = m.clone();\n-        task::spawn(proc() {\n-            let lock = m3.lock();\n-            tx.send(());\n-            lock.cond.wait();\n-            tx.send(());\n-        });\n-        rx.recv(); // Wait until child gets in the mutex\n-        {\n-            let lock = m.lock();\n-            let woken = lock.cond.signal();\n-            assert!(woken);\n-        }\n-        rx.recv(); // Wait until child wakes up\n-    }\n-\n-    fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n-        let m = Arc::new(Mutex::new());\n-        let mut rxs = Vec::new();\n-\n-        for _ in range(0u, num_waiters) {\n-            let mi = m.clone();\n-            let (tx, rx) = channel();\n-            rxs.push(rx);\n-            task::spawn(proc() {\n-                let lock = mi.lock();\n-                tx.send(());\n-                lock.cond.wait();\n-                tx.send(());\n-            });\n-        }\n-\n-        // wait until all children get in the mutex\n-        for rx in rxs.iter_mut() { rx.recv(); }\n-        {\n-            let lock = m.lock();\n-            let num_woken = lock.cond.broadcast();\n-            assert_eq!(num_woken, num_waiters);\n-        }\n-        // wait until all children wake up\n-        for rx in rxs.iter_mut() { rx.recv(); }\n-    }\n-\n-    #[test]\n-    fn test_mutex_cond_broadcast() {\n-        test_mutex_cond_broadcast_helper(12);\n-    }\n-\n-    #[test]\n-    fn test_mutex_cond_broadcast_none() {\n-        test_mutex_cond_broadcast_helper(0);\n-    }\n-\n-    #[test]\n-    fn test_mutex_cond_no_waiter() {\n-        let m = Arc::new(Mutex::new());\n-        let m2 = m.clone();\n-        let _ = task::try(proc() {\n-            drop(m.lock());\n-        });\n-        let lock = m2.lock();\n-        assert!(!lock.cond.signal());\n-    }\n-\n-    #[test]\n-    fn test_mutex_killed_simple() {\n-        use any::Any;\n-\n-        // Mutex must get automatically unlocked if panicked/killed within.\n-        let m = Arc::new(Mutex::new());\n-        let m2 = m.clone();\n-\n-        let result: result::Result<(), Box<Any + Send>> = task::try(proc() {\n-            let _lock = m2.lock();\n-            panic!();\n-        });\n-        assert!(result.is_err());\n-        // child task must have finished by the time try returns\n-        drop(m.lock());\n-    }\n-\n-    #[test]\n-    fn test_mutex_cond_signal_on_0() {\n-        // Tests that signal_on(0) is equivalent to signal().\n-        let m = Arc::new(Mutex::new());\n-        let lock = m.lock();\n-        let m2 = m.clone();\n-        task::spawn(proc() {\n-            let lock = m2.lock();\n-            lock.cond.signal_on(0);\n-        });\n-        lock.cond.wait();\n-    }\n-\n-    #[test]\n-    fn test_mutex_no_condvars() {\n-        let result = task::try(proc() {\n-            let m = Mutex::new_with_condvars(0);\n-            m.lock().cond.wait();\n-        });\n-        assert!(result.is_err());\n-        let result = task::try(proc() {\n-            let m = Mutex::new_with_condvars(0);\n-            m.lock().cond.signal();\n-        });\n-        assert!(result.is_err());\n-        let result = task::try(proc() {\n-            let m = Mutex::new_with_condvars(0);\n-            m.lock().cond.broadcast();\n-        });\n-        assert!(result.is_err());\n-    }\n-\n-    #[cfg(test)]\n-    pub enum RWLockMode { Read, Write, Downgrade, DowngradeRead }\n-\n-    #[cfg(test)]\n-    fn lock_rwlock_in_mode(x: &Arc<RWLock>, mode: RWLockMode, blk: ||) {\n-        match mode {\n-            Read => { let _g = x.read(); blk() }\n-            Write => { let _g = x.write(); blk() }\n-            Downgrade => { let _g = x.write(); blk() }\n-            DowngradeRead => { let _g = x.write().downgrade(); blk() }\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    fn test_rwlock_exclusion(x: Arc<RWLock>,\n-                             mode1: RWLockMode,\n-                             mode2: RWLockMode) {\n-        // Test mutual exclusion between readers and writers. Just like the\n-        // mutex mutual exclusion test, a ways above.\n-        let (tx, rx) = channel();\n-        let x2 = x.clone();\n-        let mut sharedstate = box 0;\n-        {\n-            let ptr: *const int = &*sharedstate;\n-            task::spawn(proc() {\n-                let sharedstate: &mut int =\n-                    unsafe { mem::transmute(ptr) };\n-                access_shared(sharedstate, &x2, mode1, 10);\n-                tx.send(());\n-            });\n-        }\n-        {\n-            access_shared(&mut *sharedstate, &x, mode2, 10);\n-            let _ = rx.recv();\n-\n-            assert_eq!(*sharedstate, 20);\n-        }\n-\n-        fn access_shared(sharedstate: &mut int, x: &Arc<RWLock>,\n-                         mode: RWLockMode, n: uint) {\n-            for _ in range(0u, n) {\n-                lock_rwlock_in_mode(x, mode, || {\n-                    let oldval = *sharedstate;\n-                    task::deschedule();\n-                    *sharedstate = oldval + 1;\n-                })\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rwlock_readers_wont_modify_the_data() {\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), Read, Write);\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Read);\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), Read, Downgrade);\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Read);\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, DowngradeRead);\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), DowngradeRead, Write);\n-    }\n-\n-    #[test]\n-    fn test_rwlock_writers_and_writers() {\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Write);\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Downgrade);\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Write);\n-        test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Downgrade);\n-    }\n-\n-    #[cfg(test)]\n-    fn test_rwlock_handshake(x: Arc<RWLock>,\n-                             mode1: RWLockMode,\n-                             mode2: RWLockMode,\n-                             make_mode2_go_first: bool) {\n-        // Much like sem_multi_resource.\n-        let x2 = x.clone();\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        task::spawn(proc() {\n-            if !make_mode2_go_first {\n-                rx2.recv(); // parent sends to us once it locks, or ...\n-            }\n-            lock_rwlock_in_mode(&x2, mode2, || {\n-                if make_mode2_go_first {\n-                    tx1.send(()); // ... we send to it once we lock\n-                }\n-                rx2.recv();\n-                tx1.send(());\n-            })\n-        });\n-        if make_mode2_go_first {\n-            rx1.recv(); // child sends to us once it locks, or ...\n-        }\n-        lock_rwlock_in_mode(&x, mode1, || {\n-            if !make_mode2_go_first {\n-                tx2.send(()); // ... we send to it once we lock\n-            }\n-            tx2.send(());\n-            rx1.recv();\n-        })\n-    }\n-\n-    #[test]\n-    fn test_rwlock_readers_and_readers() {\n-        test_rwlock_handshake(Arc::new(RWLock::new()), Read, Read, false);\n-        // The downgrader needs to get in before the reader gets in, otherwise\n-        // they cannot end up reading at the same time.\n-        test_rwlock_handshake(Arc::new(RWLock::new()), DowngradeRead, Read, false);\n-        test_rwlock_handshake(Arc::new(RWLock::new()), Read, DowngradeRead, true);\n-        // Two downgrade_reads can never both end up reading at the same time.\n-    }\n-\n-    #[test]\n-    fn test_rwlock_downgrade_unlock() {\n-        // Tests that downgrade can unlock the lock in both modes\n-        let x = Arc::new(RWLock::new());\n-        lock_rwlock_in_mode(&x, Downgrade, || { });\n-        test_rwlock_handshake(x, Read, Read, false);\n-        let y = Arc::new(RWLock::new());\n-        lock_rwlock_in_mode(&y, DowngradeRead, || { });\n-        test_rwlock_exclusion(y, Write, Write);\n-    }\n-\n-    #[test]\n-    fn test_rwlock_read_recursive() {\n-        let x = RWLock::new();\n-        let _g1 = x.read();\n-        let _g2 = x.read();\n-    }\n-\n-    #[test]\n-    fn test_rwlock_cond_wait() {\n-        // As test_mutex_cond_wait above.\n-        let x = Arc::new(RWLock::new());\n-\n-        // Child wakes up parent\n-        {\n-            let lock = x.write();\n-            let x2 = x.clone();\n-            task::spawn(proc() {\n-                let lock = x2.write();\n-                assert!(lock.cond.signal());\n-            });\n-            lock.cond.wait();\n-        }\n-        // Parent wakes up child\n-        let (tx, rx) = channel();\n-        let x3 = x.clone();\n-        task::spawn(proc() {\n-            let lock = x3.write();\n-            tx.send(());\n-            lock.cond.wait();\n-            tx.send(());\n-        });\n-        rx.recv(); // Wait until child gets in the rwlock\n-        drop(x.read()); // Must be able to get in as a reader\n-        {\n-            let x = x.write();\n-            assert!(x.cond.signal());\n-        }\n-        rx.recv(); // Wait until child wakes up\n-        drop(x.read()); // Just for good measure\n-    }\n-\n-    #[cfg(test)]\n-    fn test_rwlock_cond_broadcast_helper(num_waiters: uint) {\n-        // Much like the mutex broadcast test. Downgrade-enabled.\n-        fn lock_cond(x: &Arc<RWLock>, blk: |c: &Condvar|) {\n-            let lock = x.write();\n-            blk(&lock.cond);\n-        }\n-\n-        let x = Arc::new(RWLock::new());\n-        let mut rxs = Vec::new();\n-\n-        for _ in range(0u, num_waiters) {\n-            let xi = x.clone();\n-            let (tx, rx) = channel();\n-            rxs.push(rx);\n-            task::spawn(proc() {\n-                lock_cond(&xi, |cond| {\n-                    tx.send(());\n-                    cond.wait();\n-                    tx.send(());\n-                })\n-            });\n-        }\n-\n-        // wait until all children get in the mutex\n-        for rx in rxs.iter_mut() { let _ = rx.recv(); }\n-        lock_cond(&x, |cond| {\n-            let num_woken = cond.broadcast();\n-            assert_eq!(num_woken, num_waiters);\n-        });\n-        // wait until all children wake up\n-        for rx in rxs.iter_mut() { let _ = rx.recv(); }\n-    }\n-\n-    #[test]\n-    fn test_rwlock_cond_broadcast() {\n-        test_rwlock_cond_broadcast_helper(0);\n-        test_rwlock_cond_broadcast_helper(12);\n-    }\n-\n-    #[cfg(test)]\n-    fn rwlock_kill_helper(mode1: RWLockMode, mode2: RWLockMode) {\n-        use any::Any;\n-\n-        // Mutex must get automatically unlocked if panicked/killed within.\n-        let x = Arc::new(RWLock::new());\n-        let x2 = x.clone();\n-\n-        let result: result::Result<(), Box<Any + Send>> = task::try(proc() {\n-            lock_rwlock_in_mode(&x2, mode1, || {\n-                panic!();\n-            })\n-        });\n-        assert!(result.is_err());\n-        // child task must have finished by the time try returns\n-        lock_rwlock_in_mode(&x, mode2, || { })\n-    }\n-\n-    #[test]\n-    fn test_rwlock_reader_killed_writer() {\n-        rwlock_kill_helper(Read, Write);\n-    }\n-\n-    #[test]\n-    fn test_rwlock_writer_killed_reader() {\n-        rwlock_kill_helper(Write, Read);\n-    }\n-\n-    #[test]\n-    fn test_rwlock_reader_killed_reader() {\n-        rwlock_kill_helper(Read, Read);\n-    }\n-\n-    #[test]\n-    fn test_rwlock_writer_killed_writer() {\n-        rwlock_kill_helper(Write, Write);\n-    }\n-\n-    #[test]\n-    fn test_rwlock_kill_downgrader() {\n-        rwlock_kill_helper(Downgrade, Read);\n-        rwlock_kill_helper(Read, Downgrade);\n-        rwlock_kill_helper(Downgrade, Write);\n-        rwlock_kill_helper(Write, Downgrade);\n-        rwlock_kill_helper(DowngradeRead, Read);\n-        rwlock_kill_helper(Read, DowngradeRead);\n-        rwlock_kill_helper(DowngradeRead, Write);\n-        rwlock_kill_helper(Write, DowngradeRead);\n-        rwlock_kill_helper(DowngradeRead, Downgrade);\n-        rwlock_kill_helper(DowngradeRead, Downgrade);\n-        rwlock_kill_helper(Downgrade, DowngradeRead);\n-        rwlock_kill_helper(Downgrade, DowngradeRead);\n-    }\n-}"}, {"sha": "a4f8b1df6af527a188db0e848c9886fca164e4ec", "filename": "src/libstd/sync/rwlock.rs", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,514 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+use kinds::marker;\n+use cell::UnsafeCell;\n+use sys_common::rwlock as sys;\n+use sync::poison;\n+\n+/// A reader-writer lock\n+///\n+/// This type of lock allows a number of readers or at most one writer at any\n+/// point in time. The write portion of this lock typically allows modification\n+/// of the underlying data (exclusive access) and the read portion of this lock\n+/// typically allows for read-only access (shared access).\n+///\n+/// The type parameter `T` represents the data that this lock protects. It is\n+/// required that `T` satisfies `Send` to be shared across tasks and `Sync` to\n+/// allow concurrent access through readers. The RAII guards returned from the\n+/// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n+/// to allow access to the contained of the lock.\n+///\n+/// RWLocks, like Mutexes, will become poisoned on panics. Note, however, that\n+/// an RWLock may only be poisoned if a panic occurs while it is locked\n+/// exclusively (write mode). If a panic occurs in any reader, then the lock\n+/// will not be poisoned.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::sync::RWLock;\n+///\n+/// let lock = RWLock::new(5i);\n+///\n+/// // many reader locks can be held at once\n+/// {\n+///     let r1 = lock.read();\n+///     let r2 = lock.read();\n+///     assert_eq!(*r1, 5);\n+///     assert_eq!(*r2, 5);\n+/// } // read locks are dropped at this point\n+///\n+/// // only one write lock may be held, however\n+/// {\n+///     let mut w = lock.write();\n+///     *w += 1;\n+///     assert_eq!(*w, 6);\n+/// } // write lock is dropped here\n+/// ```\n+pub struct RWLock<T> {\n+    inner: Box<StaticRWLock>,\n+    data: UnsafeCell<T>,\n+}\n+\n+/// Structure representing a staticaly allocated RWLock.\n+///\n+/// This structure is intended to be used inside of a `static` and will provide\n+/// automatic global access as well as lazy initialization. The internal\n+/// resources of this RWLock, however, must be manually deallocated.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::sync::{StaticRWLock, RWLOCK_INIT};\n+///\n+/// static LOCK: StaticRWLock = RWLOCK_INIT;\n+///\n+/// {\n+///     let _g = LOCK.read();\n+///     // ... shared read access\n+/// }\n+/// {\n+///     let _g = LOCK.write();\n+///     // ... exclusive write access\n+/// }\n+/// unsafe { LOCK.destroy() } // free all resources\n+/// ```\n+pub struct StaticRWLock {\n+    inner: sys::RWLock,\n+    poison: UnsafeCell<poison::Flag>,\n+}\n+\n+/// Constant initialization for a statically-initialized rwlock.\n+pub const RWLOCK_INIT: StaticRWLock = StaticRWLock {\n+    inner: sys::RWLOCK_INIT,\n+    poison: UnsafeCell { value: poison::Flag { failed: false } },\n+};\n+\n+/// RAII structure used to release the shared read access of a lock when\n+/// dropped.\n+#[must_use]\n+pub struct RWLockReadGuard<'a, T: 'a> {\n+    __lock: &'a RWLock<T>,\n+    __guard: StaticRWLockReadGuard,\n+}\n+\n+/// RAII structure used to release the exclusive write access of a lock when\n+/// dropped.\n+#[must_use]\n+pub struct RWLockWriteGuard<'a, T: 'a> {\n+    __lock: &'a RWLock<T>,\n+    __guard: StaticRWLockWriteGuard,\n+}\n+\n+/// RAII structure used to release the shared read access of a lock when\n+/// dropped.\n+#[must_use]\n+pub struct StaticRWLockReadGuard {\n+    lock: &'static sys::RWLock,\n+    marker: marker::NoSend,\n+}\n+\n+/// RAII structure used to release the exclusive write access of a lock when\n+/// dropped.\n+#[must_use]\n+pub struct StaticRWLockWriteGuard {\n+    lock: &'static sys::RWLock,\n+    marker: marker::NoSend,\n+    poison: poison::Guard<'static>,\n+}\n+\n+impl<T: Send + Sync> RWLock<T> {\n+    /// Creates a new instance of an RWLock which is unlocked and read to go.\n+    pub fn new(t: T) -> RWLock<T> {\n+        RWLock { inner: box RWLOCK_INIT, data: UnsafeCell::new(t) }\n+    }\n+\n+    /// Locks this rwlock with shared read access, blocking the current thread\n+    /// until it can be acquired.\n+    ///\n+    /// The calling thread will be blocked until there are no more writers which\n+    /// hold the lock. There may be other readers currently inside the lock when\n+    /// this method returns. This method does not provide any guarantees with\n+    /// respect to the ordering of whether contentious readers or writers will\n+    /// acquire the lock first.\n+    ///\n+    /// Returns an RAII guard which will release this thread's shared access\n+    /// once it is dropped.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the RWLock is poisoned. An RWLock is\n+    /// poisoned whenever a writer panics while holding an exclusive lock. The\n+    /// panic will occur immediately after the lock has been acquired.\n+    #[inline]\n+    pub fn read(&self) -> RWLockReadGuard<T> {\n+        unsafe {\n+            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n+            RWLockReadGuard::new(self, lock.read())\n+        }\n+    }\n+\n+    /// Attempt to acquire this lock with shared read access.\n+    ///\n+    /// This function will never block and will return immediately if `read`\n+    /// would otherwise succeed. Returns `Some` of an RAII guard which will\n+    /// release the shared access of this thread when dropped, or `None` if the\n+    /// access could not be granted. This method does not provide any\n+    /// guarantees with respect to the ordering of whether contentious readers\n+    /// or writers will acquire the lock first.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the RWLock is poisoned. An RWLock is\n+    /// poisoned whenever a writer panics while holding an exclusive lock. A\n+    /// panic will only occur if the lock is acquired.\n+    #[inline]\n+    pub fn try_read(&self) -> Option<RWLockReadGuard<T>> {\n+        unsafe {\n+            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n+            lock.try_read().map(|guard| {\n+                RWLockReadGuard::new(self, guard)\n+            })\n+        }\n+    }\n+\n+    /// Lock this rwlock with exclusive write access, blocking the current\n+    /// thread until it can be acquired.\n+    ///\n+    /// This function will not return while other writers or other readers\n+    /// currently have access to the lock.\n+    ///\n+    /// Returns an RAII guard which will drop the write access of this rwlock\n+    /// when dropped.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the RWLock is poisoned. An RWLock is\n+    /// poisoned whenever a writer panics while holding an exclusive lock. The\n+    /// panic will occur when the lock is acquired.\n+    #[inline]\n+    pub fn write(&self) -> RWLockWriteGuard<T> {\n+        unsafe {\n+            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n+            RWLockWriteGuard::new(self, lock.write())\n+        }\n+    }\n+\n+    /// Attempt to lock this rwlock with exclusive write access.\n+    ///\n+    /// This function does not ever block, and it will return `None` if a call\n+    /// to `write` would otherwise block. If successful, an RAII guard is\n+    /// returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the RWLock is poisoned. An RWLock is\n+    /// poisoned whenever a writer panics while holding an exclusive lock. A\n+    /// panic will only occur if the lock is acquired.\n+    #[inline]\n+    pub fn try_write(&self) -> Option<RWLockWriteGuard<T>> {\n+        unsafe {\n+            let lock: &'static StaticRWLock = &*(&*self.inner as *const _);\n+            lock.try_write().map(|guard| {\n+                RWLockWriteGuard::new(self, guard)\n+            })\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for RWLock<T> {\n+    fn drop(&mut self) {\n+        unsafe { self.inner.inner.destroy() }\n+    }\n+}\n+\n+impl StaticRWLock {\n+    /// Locks this rwlock with shared read access, blocking the current thread\n+    /// until it can be acquired.\n+    ///\n+    /// See `RWLock::read`.\n+    #[inline]\n+    pub fn read(&'static self) -> StaticRWLockReadGuard {\n+        unsafe { self.inner.read() }\n+        StaticRWLockReadGuard::new(self)\n+    }\n+\n+    /// Attempt to acquire this lock with shared read access.\n+    ///\n+    /// See `RWLock::try_read`.\n+    #[inline]\n+    pub fn try_read(&'static self) -> Option<StaticRWLockReadGuard> {\n+        if unsafe { self.inner.try_read() } {\n+            Some(StaticRWLockReadGuard::new(self))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Lock this rwlock with exclusive write access, blocking the current\n+    /// thread until it can be acquired.\n+    ///\n+    /// See `RWLock::write`.\n+    #[inline]\n+    pub fn write(&'static self) -> StaticRWLockWriteGuard {\n+        unsafe { self.inner.write() }\n+        StaticRWLockWriteGuard::new(self)\n+    }\n+\n+    /// Attempt to lock this rwlock with exclusive write access.\n+    ///\n+    /// See `RWLock::try_write`.\n+    #[inline]\n+    pub fn try_write(&'static self) -> Option<StaticRWLockWriteGuard> {\n+        if unsafe { self.inner.try_write() } {\n+            Some(StaticRWLockWriteGuard::new(self))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Deallocate all resources associated with this static lock.\n+    ///\n+    /// This method is unsafe to call as there is no guarantee that there are no\n+    /// active users of the lock, and this also doesn't prevent any future users\n+    /// of this lock. This method is required to be called to not leak memory on\n+    /// all platforms.\n+    pub unsafe fn destroy(&'static self) {\n+        self.inner.destroy()\n+    }\n+}\n+\n+impl<'rwlock, T> RWLockReadGuard<'rwlock, T> {\n+    fn new(lock: &RWLock<T>, guard: StaticRWLockReadGuard)\n+           -> RWLockReadGuard<T> {\n+        RWLockReadGuard { __lock: lock, __guard: guard }\n+    }\n+}\n+impl<'rwlock, T> RWLockWriteGuard<'rwlock, T> {\n+    fn new(lock: &RWLock<T>, guard: StaticRWLockWriteGuard)\n+           -> RWLockWriteGuard<T> {\n+        RWLockWriteGuard { __lock: lock, __guard: guard }\n+    }\n+}\n+\n+impl<'rwlock, T> Deref<T> for RWLockReadGuard<'rwlock, T> {\n+    fn deref(&self) -> &T { unsafe { &*self.__lock.data.get() } }\n+}\n+impl<'rwlock, T> Deref<T> for RWLockWriteGuard<'rwlock, T> {\n+    fn deref(&self) -> &T { unsafe { &*self.__lock.data.get() } }\n+}\n+impl<'rwlock, T> DerefMut<T> for RWLockWriteGuard<'rwlock, T> {\n+    fn deref_mut(&mut self) -> &mut T { unsafe { &mut *self.__lock.data.get() } }\n+}\n+\n+impl StaticRWLockReadGuard {\n+    fn new(lock: &'static StaticRWLock) -> StaticRWLockReadGuard {\n+        let guard = StaticRWLockReadGuard {\n+            lock: &lock.inner,\n+            marker: marker::NoSend,\n+        };\n+        unsafe { (*lock.poison.get()).borrow().check(\"rwlock\"); }\n+        return guard;\n+    }\n+}\n+impl StaticRWLockWriteGuard {\n+    fn new(lock: &'static StaticRWLock) -> StaticRWLockWriteGuard {\n+        unsafe {\n+            let guard = StaticRWLockWriteGuard {\n+                lock: &lock.inner,\n+                marker: marker::NoSend,\n+                poison: (*lock.poison.get()).borrow(),\n+            };\n+            guard.poison.check(\"rwlock\");\n+            return guard;\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl Drop for StaticRWLockReadGuard {\n+    fn drop(&mut self) {\n+        unsafe { self.lock.read_unlock(); }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl Drop for StaticRWLockWriteGuard {\n+    fn drop(&mut self) {\n+        self.poison.done();\n+        unsafe { self.lock.write_unlock(); }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+\n+    use rand::{mod, Rng};\n+    use task;\n+    use sync::{Arc, RWLock, StaticRWLock, RWLOCK_INIT};\n+\n+    #[test]\n+    fn smoke() {\n+        let l = RWLock::new(());\n+        drop(l.read());\n+        drop(l.write());\n+        drop((l.read(), l.read()));\n+        drop(l.write());\n+    }\n+\n+    #[test]\n+    fn static_smoke() {\n+        static R: StaticRWLock = RWLOCK_INIT;\n+        drop(R.read());\n+        drop(R.write());\n+        drop((R.read(), R.read()));\n+        drop(R.write());\n+        unsafe { R.destroy(); }\n+    }\n+\n+    #[test]\n+    fn frob() {\n+        static R: StaticRWLock = RWLOCK_INIT;\n+        static N: uint = 10;\n+        static M: uint = 1000;\n+\n+        let (tx, rx) = channel::<()>();\n+        for _ in range(0, N) {\n+            let tx = tx.clone();\n+            spawn(proc() {\n+                let mut rng = rand::task_rng();\n+                for _ in range(0, M) {\n+                    if rng.gen_weighted_bool(N) {\n+                        drop(R.write());\n+                    } else {\n+                        drop(R.read());\n+                    }\n+                }\n+                drop(tx);\n+            });\n+        }\n+        drop(tx);\n+        let _ = rx.recv_opt();\n+        unsafe { R.destroy(); }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_rw_arc_poison_wr() {\n+        let arc = Arc::new(RWLock::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.write();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.read();\n+        assert_eq!(*lock, 1);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_rw_arc_poison_ww() {\n+        let arc = Arc::new(RWLock::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.write();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.write();\n+        assert_eq!(*lock, 1);\n+    }\n+\n+    #[test]\n+    fn test_rw_arc_no_poison_rr() {\n+        let arc = Arc::new(RWLock::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.read();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.read();\n+        assert_eq!(*lock, 1);\n+    }\n+    #[test]\n+    fn test_rw_arc_no_poison_rw() {\n+        let arc = Arc::new(RWLock::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.read();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.write();\n+        assert_eq!(*lock, 1);\n+    }\n+\n+    #[test]\n+    fn test_rw_arc() {\n+        let arc = Arc::new(RWLock::new(0i));\n+        let arc2 = arc.clone();\n+        let (tx, rx) = channel();\n+\n+        task::spawn(proc() {\n+            let mut lock = arc2.write();\n+            for _ in range(0u, 10) {\n+                let tmp = *lock;\n+                *lock = -1;\n+                task::deschedule();\n+                *lock = tmp + 1;\n+            }\n+            tx.send(());\n+        });\n+\n+        // Readers try to catch the writer in the act\n+        let mut children = Vec::new();\n+        for _ in range(0u, 5) {\n+            let arc3 = arc.clone();\n+            children.push(task::try_future(proc() {\n+                let lock = arc3.read();\n+                assert!(*lock >= 0);\n+            }));\n+        }\n+\n+        // Wait for children to pass their asserts\n+        for r in children.iter_mut() {\n+            assert!(r.get_ref().is_ok());\n+        }\n+\n+        // Wait for writer to finish\n+        rx.recv();\n+        let lock = arc.read();\n+        assert_eq!(*lock, 10);\n+    }\n+\n+    #[test]\n+    fn test_rw_arc_access_in_unwind() {\n+        let arc = Arc::new(RWLock::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try::<()>(proc() {\n+            struct Unwinder {\n+                i: Arc<RWLock<int>>,\n+            }\n+            impl Drop for Unwinder {\n+                fn drop(&mut self) {\n+                    let mut lock = self.i.write();\n+                    *lock += 1;\n+                }\n+            }\n+            let _u = Unwinder { i: arc2 };\n+            panic!();\n+        });\n+        let lock = arc.read();\n+        assert_eq!(*lock, 2);\n+    }\n+}"}, {"sha": "03fb84c38d470889ee04909afb8e758f38c3869b", "filename": "src/libstd/sync/semaphore.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ops::Drop;\n+use sync::{Mutex, Condvar};\n+\n+/// A counting, blocking, semaphore.\n+///\n+/// Semaphores are a form of atomic counter where access is only granted if the\n+/// counter is a positive value. Each acquisition will block the calling thread\n+/// until the counter is positive, and each release will increment the counter\n+/// and unblock any threads if necessary.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::sync::Semaphore;\n+///\n+/// // Create a semaphore that represents 5 resources\n+/// let sem = Semaphore::new(5);\n+///\n+/// // Acquire one of the resources\n+/// sem.acquire();\n+///\n+/// // Acquire one of the resources for a limited period of time\n+/// {\n+///     let _guard = sem.access();\n+///     // ...\n+/// } // resources is released here\n+///\n+/// // Release our initially acquired resource\n+/// sem.release();\n+/// ```\n+pub struct Semaphore {\n+    lock: Mutex<int>,\n+    cvar: Condvar,\n+}\n+\n+/// An RAII guard which will release a resource acquired from a semaphore when\n+/// dropped.\n+pub struct SemaphoreGuard<'a> {\n+    sem: &'a Semaphore,\n+}\n+\n+impl Semaphore {\n+    /// Creates a new semaphore with the initial count specified.\n+    ///\n+    /// The count specified can be thought of as a number of resources, and a\n+    /// call to `acquire` or `access` will block until at least one resource is\n+    /// available. It is valid to initialize a semaphore with a negative count.\n+    pub fn new(count: int) -> Semaphore {\n+        Semaphore {\n+            lock: Mutex::new(count),\n+            cvar: Condvar::new(),\n+        }\n+    }\n+\n+    /// Acquires a resource of this semaphore, blocking the current thread until\n+    /// it can do so.\n+    ///\n+    /// This method will block until the internal count of the semaphore is at\n+    /// least 1.\n+    pub fn acquire(&self) {\n+        let mut count = self.lock.lock();\n+        while *count <= 0 {\n+            self.cvar.wait(&count);\n+        }\n+        *count -= 1;\n+    }\n+\n+    /// Release a resource from this semaphore.\n+    ///\n+    /// This will increment the number of resources in this semaphore by 1 and\n+    /// will notify any pending waiters in `acquire` or `access` if necessary.\n+    pub fn release(&self) {\n+        *self.lock.lock() += 1;\n+        self.cvar.notify_one();\n+    }\n+\n+    /// Acquires a resource of this semaphore, returning an RAII guard to\n+    /// release the semaphore when dropped.\n+    ///\n+    /// This function is semantically equivalent to an `acquire` followed by a\n+    /// `release` when the guard returned is dropped.\n+    pub fn access(&self) -> SemaphoreGuard {\n+        self.acquire();\n+        SemaphoreGuard { sem: self }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for SemaphoreGuard<'a> {\n+    fn drop(&mut self) {\n+        self.sem.release();\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+\n+    use sync::Arc;\n+    use super::Semaphore;\n+\n+    #[test]\n+    fn test_sem_acquire_release() {\n+        let s = Semaphore::new(1);\n+        s.acquire();\n+        s.release();\n+        s.acquire();\n+    }\n+\n+    #[test]\n+    fn test_sem_basic() {\n+        let s = Semaphore::new(1);\n+        let _g = s.access();\n+    }\n+\n+    #[test]\n+    fn test_sem_as_mutex() {\n+        let s = Arc::new(Semaphore::new(1));\n+        let s2 = s.clone();\n+        spawn(proc() {\n+            let _g = s2.access();\n+        });\n+        let _g = s.access();\n+    }\n+\n+    #[test]\n+    fn test_sem_as_cvar() {\n+        /* Child waits and parent signals */\n+        let (tx, rx) = channel();\n+        let s = Arc::new(Semaphore::new(0));\n+        let s2 = s.clone();\n+        spawn(proc() {\n+            s2.acquire();\n+            tx.send(());\n+        });\n+        s.release();\n+        let _ = rx.recv();\n+\n+        /* Parent waits and child signals */\n+        let (tx, rx) = channel();\n+        let s = Arc::new(Semaphore::new(0));\n+        let s2 = s.clone();\n+        spawn(proc() {\n+            s2.release();\n+            let _ = rx.recv();\n+        });\n+        s.acquire();\n+        tx.send(());\n+    }\n+\n+    #[test]\n+    fn test_sem_multi_resource() {\n+        // Parent and child both get in the critical section at the same\n+        // time, and shake hands.\n+        let s = Arc::new(Semaphore::new(2));\n+        let s2 = s.clone();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n+        spawn(proc() {\n+            let _g = s2.access();\n+            let _ = rx2.recv();\n+            tx1.send(());\n+        });\n+        let _g = s.access();\n+        tx2.send(());\n+        let _ = rx1.recv();\n+    }\n+\n+    #[test]\n+    fn test_sem_runtime_friendly_blocking() {\n+        let s = Arc::new(Semaphore::new(1));\n+        let s2 = s.clone();\n+        let (tx, rx) = channel();\n+        {\n+            let _g = s.access();\n+            spawn(proc() {\n+                tx.send(());\n+                drop(s2.access());\n+                tx.send(());\n+            });\n+            rx.recv(); // wait for child to come alive\n+        }\n+        rx.recv(); // wait for child to be done\n+    }\n+}"}, {"sha": "e09d970402966451d3a83f0330b79765072ccd10", "filename": "src/libstd/sys/common/condvar.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use time::Duration;\n+use sys_common::mutex::{mod, Mutex};\n+use sys::condvar as imp;\n+\n+/// An OS-based condition variable.\n+///\n+/// This structure is the lowest layer possible on top of the OS-provided\n+/// condition variables. It is consequently entirely unsafe to use. It is\n+/// recommended to use the safer types at the top level of this crate instead of\n+/// this type.\n+pub struct Condvar(imp::Condvar);\n+\n+/// Static initializer for condition variables.\n+pub const CONDVAR_INIT: Condvar = Condvar(imp::CONDVAR_INIT);\n+\n+impl Condvar {\n+    /// Creates a new condition variable for use.\n+    ///\n+    /// Behavior is undefined if the condition variable is moved after it is\n+    /// first used with any of the functions below.\n+    #[inline]\n+    pub unsafe fn new() -> Condvar { Condvar(imp::Condvar::new()) }\n+\n+    /// Signal one waiter on this condition variable to wake up.\n+    #[inline]\n+    pub unsafe fn notify_one(&self) { self.0.notify_one() }\n+\n+    /// Awaken all current waiters on this condition variable.\n+    #[inline]\n+    pub unsafe fn notify_all(&self) { self.0.notify_all() }\n+\n+    /// Wait for a signal on the specified mutex.\n+    ///\n+    /// Behavior is undefined if the mutex is not locked by the current thread.\n+    /// Behavior is also undefined if more than one mutex is used concurrently\n+    /// on this condition variable.\n+    #[inline]\n+    pub unsafe fn wait(&self, mutex: &Mutex) { self.0.wait(mutex::raw(mutex)) }\n+\n+    /// Wait for a signal on the specified mutex with a timeout duration\n+    /// specified by `dur` (a relative time into the future).\n+    ///\n+    /// Behavior is undefined if the mutex is not locked by the current thread.\n+    /// Behavior is also undefined if more than one mutex is used concurrently\n+    /// on this condition variable.\n+    #[inline]\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        self.0.wait_timeout(mutex::raw(mutex), dur)\n+    }\n+\n+    /// Deallocate all resources associated with this condition variable.\n+    ///\n+    /// Behavior is undefined if there are current or will be future users of\n+    /// this condition variable.\n+    #[inline]\n+    pub unsafe fn destroy(&self) { self.0.destroy() }\n+}"}, {"sha": "c0018c5d970421086eb86d70ad6ef17bf7f6254c", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -20,13 +20,14 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n+use prelude::*;\n+\n+use cell::UnsafeCell;\n use mem;\n use rustrt::bookkeeping;\n-use rustrt::mutex::StaticNativeMutex;\n use rustrt;\n-use cell::UnsafeCell;\n+use sync::{StaticMutex, StaticCondvar};\n use sys::helper_signal;\n-use prelude::*;\n \n use task;\n \n@@ -39,7 +40,8 @@ use task;\n /// is for static initialization.\n pub struct Helper<M> {\n     /// Internal lock which protects the remaining fields\n-    pub lock: StaticNativeMutex,\n+    pub lock: StaticMutex,\n+    pub cond: StaticCondvar,\n \n     // You'll notice that the remaining fields are UnsafeCell<T>, and this is\n     // because all helper thread operations are done through &self, but we need\n@@ -53,6 +55,9 @@ pub struct Helper<M> {\n \n     /// Flag if this helper thread has booted and been initialized yet.\n     pub initialized: UnsafeCell<bool>,\n+\n+    /// Flag if this helper thread has shut down\n+    pub shutdown: UnsafeCell<bool>,\n }\n \n impl<M: Send> Helper<M> {\n@@ -80,7 +85,9 @@ impl<M: Send> Helper<M> {\n                 task::spawn(proc() {\n                     bookkeeping::decrement();\n                     helper(receive, rx, t);\n-                    self.lock.lock().signal()\n+                    let _g = self.lock.lock();\n+                    *self.shutdown.get() = true;\n+                    self.cond.notify_one()\n                 });\n \n                 rustrt::at_exit(proc() { self.shutdown() });\n@@ -119,7 +126,9 @@ impl<M: Send> Helper<M> {\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n \n             // Wait for the child to exit\n-            guard.wait();\n+            while !*self.shutdown.get() {\n+                self.cond.wait(&guard);\n+            }\n             drop(guard);\n \n             // Clean up after ourselves"}, {"sha": "f8861c20464dd50599854aaff6d30eb9578eef3c", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -19,8 +19,11 @@ use num::Int;\n use path::BytesContainer;\n use collections;\n \n-pub mod net;\n+pub mod condvar;\n pub mod helper_thread;\n+pub mod mutex;\n+pub mod net;\n+pub mod rwlock;\n pub mod thread_local;\n \n // common error constructors"}, {"sha": "117d33db32896a7b57c8b6a6fd0de03af8a43deb", "filename": "src/libstd/sys/common/mutex.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use sys::mutex::raw;\n+\n+use sys::mutex as imp;\n+\n+/// An OS-based mutual exclusion lock.\n+///\n+/// This is the thinnest cross-platform wrapper around OS mutexes. All usage of\n+/// this mutex is unsafe and it is recommended to instead use the safe wrapper\n+/// at the top level of the crate instead of this type.\n+pub struct Mutex(imp::Mutex);\n+\n+/// Constant initializer for statically allocated mutexes.\n+pub const MUTEX_INIT: Mutex = Mutex(imp::MUTEX_INIT);\n+\n+impl Mutex {\n+    /// Creates a newly initialized mutex.\n+    ///\n+    /// Behavior is undefined if the mutex is moved after the first method is\n+    /// called on the mutex.\n+    #[inline]\n+    pub unsafe fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n+\n+    /// Lock the mutex blocking the current thread until it is available.\n+    ///\n+    /// Behavior is undefined if the mutex has been moved between this and any\n+    /// previous function call.\n+    #[inline]\n+    pub unsafe fn lock(&self) { self.0.lock() }\n+\n+    /// Attempt to lock the mutex without blocking, returning whether it was\n+    /// successfully acquired or not.\n+    ///\n+    /// Behavior is undefined if the mutex has been moved between this and any\n+    /// previous function call.\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool { self.0.try_lock() }\n+\n+    /// Unlock the mutex.\n+    ///\n+    /// Behavior is undefined if the current thread does not actually hold the\n+    /// mutex.\n+    #[inline]\n+    pub unsafe fn unlock(&self) { self.0.unlock() }\n+\n+    /// Deallocate all resources associated with this mutex.\n+    ///\n+    /// Behavior is undefined if there are current or will be future users of\n+    /// this mutex.\n+    #[inline]\n+    pub unsafe fn destroy(&self) { self.0.destroy() }\n+}\n+\n+// not meant to be exported to the outside world, just the containing module\n+pub fn raw(mutex: &Mutex) -> &imp::Mutex { &mutex.0 }"}, {"sha": "ddc6dd021c30f7b178b2e7623e70639a6dc5b3c3", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -16,13 +16,13 @@ use libc::{mod, c_char, c_int};\n use mem;\n use num::Int;\n use ptr::{mod, null, null_mut};\n-use rustrt::mutex;\n use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n use io::net::addrinfo;\n use io::{IoResult, IoError};\n use sys::{mod, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n           wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n           decode_error_detailed};\n+use sync::{Mutex, MutexGuard};\n use sys_common::{mod, keep_going, short_write, timeout};\n use prelude::*;\n use cmp;\n@@ -557,12 +557,12 @@ struct Inner {\n \n     // Unused on Linux, where this lock is not necessary.\n     #[allow(dead_code)]\n-    lock: mutex::NativeMutex\n+    lock: Mutex<()>,\n }\n \n impl Inner {\n     fn new(fd: sock_t) -> Inner {\n-        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+        Inner { fd: fd, lock: Mutex::new(()) }\n     }\n }\n \n@@ -572,7 +572,7 @@ impl Drop for Inner {\n \n pub struct Guard<'a> {\n     pub fd: sock_t,\n-    pub guard: mutex::LockGuard<'a>,\n+    pub guard: MutexGuard<'a, ()>,\n }\n \n #[unsafe_destructor]\n@@ -666,7 +666,7 @@ impl TcpStream {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: unsafe { self.inner.lock.lock() },\n+            guard: self.inner.lock.lock(),\n         };\n         assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret\n@@ -805,7 +805,7 @@ impl UdpSocket {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: unsafe { self.inner.lock.lock() },\n+            guard: self.inner.lock.lock(),\n         };\n         assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret"}, {"sha": "df016b9e293b7fb44e20aecd4ccdca1acd94429f", "filename": "src/libstd/sys/common/rwlock.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sys::rwlock as imp;\n+\n+/// An OS-based reader-writer lock.\n+///\n+/// This structure is entirely unsafe and serves as the lowest layer of a\n+/// cross-platform binding of system rwlocks. It is recommended to use the\n+/// safer types at the top level of this crate instead of this type.\n+pub struct RWLock(imp::RWLock);\n+\n+/// Constant initializer for static RWLocks.\n+pub const RWLOCK_INIT: RWLock = RWLock(imp::RWLOCK_INIT);\n+\n+impl RWLock {\n+    /// Creates a new instance of an RWLock.\n+    ///\n+    /// Usage of an RWLock is undefined if it is moved after its first use (any\n+    /// function calls below).\n+    #[inline]\n+    pub unsafe fn new() -> RWLock { RWLock(imp::RWLock::new()) }\n+\n+    /// Acquire shared access to the underlying lock, blocking the current\n+    /// thread to do so.\n+    ///\n+    /// Behavior is undefined if the rwlock has been moved between this and any\n+    /// previous methodo call.\n+    #[inline]\n+    pub unsafe fn read(&self) { self.0.read() }\n+\n+    /// Attempt to acquire shared access to this lock, returning whether it\n+    /// succeeded or not.\n+    ///\n+    /// This function does not block the current thread.\n+    ///\n+    /// Behavior is undefined if the rwlock has been moved between this and any\n+    /// previous methodo call.\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool { self.0.try_read() }\n+\n+    /// Acquire write access to the underlying lock, blocking the current thread\n+    /// to do so.\n+    ///\n+    /// Behavior is undefined if the rwlock has been moved between this and any\n+    /// previous methodo call.\n+    #[inline]\n+    pub unsafe fn write(&self) { self.0.write() }\n+\n+    /// Attempt to acquire exclusive access to this lock, returning whether it\n+    /// succeeded or not.\n+    ///\n+    /// This function does not block the current thread.\n+    ///\n+    /// Behavior is undefined if the rwlock has been moved between this and any\n+    /// previous methodo call.\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool { self.0.try_write() }\n+\n+    /// Unlock previously acquired shared access to this lock.\n+    ///\n+    /// Behavior is undefined if the current thread does not have shared access.\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) { self.0.read_unlock() }\n+\n+    /// Unlock previously acquired exclusive access to this lock.\n+    ///\n+    /// Behavior is undefined if the current thread does not currently have\n+    /// exclusive access.\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) { self.0.write_unlock() }\n+\n+    /// Destroy OS-related resources with this RWLock.\n+    ///\n+    /// Behavior is undefined if there are any currently active users of this\n+    /// lock.\n+    #[inline]\n+    pub unsafe fn destroy(&self) { self.0.destroy() }\n+}"}, {"sha": "f64718539ef0c92812b4504c9dcf08ae2e727388", "filename": "src/libstd/sys/unix/condvar.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use libc;\n+use sys::mutex::{mod, Mutex};\n+use sys::sync as ffi;\n+use time::Duration;\n+\n+pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }\n+\n+pub const CONDVAR_INIT: Condvar = Condvar {\n+    inner: UnsafeCell { value: ffi::PTHREAD_COND_INITIALIZER },\n+};\n+\n+impl Condvar {\n+    #[inline]\n+    pub unsafe fn new() -> Condvar {\n+        // Might be moved and address is changing it is better to avoid\n+        // initialization of potentially opaque OS data before it landed\n+        Condvar { inner: UnsafeCell::new(ffi::PTHREAD_COND_INITIALIZER) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_one(&self) {\n+        let r = ffi::pthread_cond_signal(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_all(&self) {\n+        let r = ffi::pthread_cond_broadcast(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        let r = ffi::pthread_cond_wait(self.inner.get(), mutex::raw(mutex));\n+        debug_assert_eq!(r, 0);\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        assert!(dur >= Duration::nanoseconds(0));\n+\n+        // First, figure out what time it currently is\n+        let mut tv = libc::timeval { tv_sec: 0, tv_usec: 0 };\n+        let r = ffi::gettimeofday(&mut tv, 0 as *mut _);\n+        debug_assert_eq!(r, 0);\n+\n+        // Offset that time with the specified duration\n+        let abs = Duration::seconds(tv.tv_sec as i64) +\n+                  Duration::microseconds(tv.tv_usec as i64) +\n+                  dur;\n+        let ns = abs.num_nanoseconds().unwrap() as u64;\n+        let timeout = libc::timespec {\n+            tv_sec: (ns / 1000000000) as libc::time_t,\n+            tv_nsec: (ns % 1000000000) as libc::c_long,\n+        };\n+\n+        // And wait!\n+        let r = ffi::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n+                                            &timeout);\n+        if r != 0 {\n+            debug_assert_eq!(r as int, libc::ETIMEDOUT as int);\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let r = ffi::pthread_cond_destroy(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+}"}, {"sha": "4effedbe3abd83635f0107bc2988572d74b25ee4", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -25,23 +25,29 @@ use sys_common::mkerr_libc;\n \n macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n     static $name: Helper<$m> = Helper {\n-        lock: ::rustrt::mutex::NATIVE_MUTEX_INIT,\n+        lock: ::sync::MUTEX_INIT,\n+        cond: ::sync::CONDVAR_INIT,\n         chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n         signal: ::cell::UnsafeCell { value: 0 },\n         initialized: ::cell::UnsafeCell { value: false },\n+        shutdown: ::cell::UnsafeCell { value: false },\n     };\n ) )\n \n pub mod c;\n pub mod ext;\n+pub mod condvar;\n pub mod fs;\n pub mod helper_signal;\n+pub mod mutex;\n pub mod os;\n pub mod pipe;\n pub mod process;\n+pub mod rwlock;\n+pub mod sync;\n pub mod tcp;\n-pub mod timer;\n pub mod thread_local;\n+pub mod timer;\n pub mod tty;\n pub mod udp;\n "}, {"sha": "2f01c53cb2cf51114323f171a6f7f4af69df009f", "filename": "src/libstd/sys/unix/mutex.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use sys::sync as ffi;\n+use sys_common::mutex;\n+\n+pub struct Mutex { inner: UnsafeCell<ffi::pthread_mutex_t> }\n+\n+#[inline]\n+pub unsafe fn raw(m: &Mutex) -> *mut ffi::pthread_mutex_t {\n+    m.inner.get()\n+}\n+\n+pub const MUTEX_INIT: Mutex = Mutex {\n+    inner: UnsafeCell { value: ffi::PTHREAD_MUTEX_INITIALIZER },\n+};\n+\n+impl Mutex {\n+    #[inline]\n+    pub unsafe fn new() -> Mutex {\n+        // Might be moved and address is changing it is better to avoid\n+        // initialization of potentially opaque OS data before it landed\n+        MUTEX_INIT\n+    }\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let r = ffi::pthread_mutex_lock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        let r = ffi::pthread_mutex_unlock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        ffi::pthread_mutex_trylock(self.inner.get()) == 0\n+    }\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let r = ffi::pthread_mutex_destroy(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+}"}, {"sha": "08e6f7059d8c678c4d843f2faa1a3af3366b6ea0", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -12,8 +12,7 @@ use alloc::arc::Arc;\n use libc;\n use c_str::CString;\n use mem;\n-use rustrt::mutex;\n-use sync::atomic;\n+use sync::{atomic, Mutex};\n use io::{mod, IoResult, IoError};\n use prelude::*;\n \n@@ -60,12 +59,12 @@ struct Inner {\n \n     // Unused on Linux, where this lock is not necessary.\n     #[allow(dead_code)]\n-    lock: mutex::NativeMutex\n+    lock: Mutex<()>,\n }\n \n impl Inner {\n     fn new(fd: fd_t) -> Inner {\n-        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+        Inner { fd: fd, lock: Mutex::new(()) }\n     }\n }\n "}, {"sha": "7dde19a64762ab37dac09a8591d113ce2553a62b", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -11,7 +11,7 @@ use self::Req::*;\n \n use libc::{mod, pid_t, c_void, c_int};\n use c_str::CString;\n-use io::{mod, IoResult, IoError};\n+use io::{mod, IoResult, IoError, EndOfFile};\n use mem;\n use os;\n use ptr;\n@@ -39,6 +39,8 @@ enum Req {\n     NewChild(libc::pid_t, Sender<ProcessExit>, u64),\n }\n \n+const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n impl Process {\n     pub fn id(&self) -> pid_t {\n         self.pid\n@@ -106,18 +108,36 @@ impl Process {\n                 if pid < 0 {\n                     return Err(super::last_error())\n                 } else if pid > 0 {\n+                    #[inline]\n+                    fn combine(arr: &[u8]) -> i32 {\n+                        let a = arr[0] as u32;\n+                        let b = arr[1] as u32;\n+                        let c = arr[2] as u32;\n+                        let d = arr[3] as u32;\n+\n+                        ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+                    }\n+\n+                    let p = Process{ pid: pid };\n                     drop(output);\n-                    let mut bytes = [0, ..4];\n+                    let mut bytes = [0, ..8];\n                     return match input.read(&mut bytes) {\n-                        Ok(4) => {\n-                            let errno = (bytes[0] as i32 << 24) |\n-                                        (bytes[1] as i32 << 16) |\n-                                        (bytes[2] as i32 <<  8) |\n-                                        (bytes[3] as i32 <<  0);\n+                        Ok(8) => {\n+                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(bytes.slice(4, 8)),\n+                                \"Validation on the CLOEXEC pipe failed: {}\", bytes);\n+                            let errno = combine(bytes.slice(0, 4));\n+                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n                             Err(super::decode_error(errno))\n                         }\n-                        Err(..) => Ok(Process { pid: pid }),\n-                        Ok(..) => panic!(\"short read on the cloexec pipe\"),\n+                        Err(ref e) if e.kind == EndOfFile => Ok(p),\n+                        Err(e) => {\n+                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n+                            panic!(\"the CLOEXEC pipe failed: {}\", e)\n+                        },\n+                        Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n+                            panic!(\"short read on the CLOEXEC pipe\")\n+                        }\n                     };\n                 }\n \n@@ -154,13 +174,16 @@ impl Process {\n                 let _ = libc::close(input.fd());\n \n                 fn fail(output: &mut FileDesc) -> ! {\n-                    let errno = sys::os::errno();\n+                    let errno = sys::os::errno() as u32;\n                     let bytes = [\n                         (errno >> 24) as u8,\n                         (errno >> 16) as u8,\n                         (errno >>  8) as u8,\n                         (errno >>  0) as u8,\n+                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n                     ];\n+                    // pipe I/O up to PIPE_BUF bytes should be atomic\n                     assert!(output.write(&bytes).is_ok());\n                     unsafe { libc::_exit(1) }\n                 }"}, {"sha": "0d63ff14ff26b892a3e0f346598dd60f2cd81b61", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use sys::sync as ffi;\n+\n+pub struct RWLock { inner: UnsafeCell<ffi::pthread_rwlock_t> }\n+\n+pub const RWLOCK_INIT: RWLock = RWLock {\n+    inner: UnsafeCell { value: ffi::PTHREAD_RWLOCK_INITIALIZER },\n+};\n+\n+impl RWLock {\n+    #[inline]\n+    pub unsafe fn new() -> RWLock {\n+        // Might be moved and address is changing it is better to avoid\n+        // initialization of potentially opaque OS data before it landed\n+        RWLOCK_INIT\n+    }\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        let r = ffi::pthread_rwlock_rdlock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        ffi::pthread_rwlock_tryrdlock(self.inner.get()) == 0\n+    }\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        let r = ffi::pthread_rwlock_wrlock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        ffi::pthread_rwlock_trywrlock(self.inner.get()) == 0\n+    }\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        let r = ffi::pthread_rwlock_unlock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) { self.read_unlock() }\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let r = ffi::pthread_rwlock_destroy(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+}"}, {"sha": "007826b4b9d58b3f6f40515e1c3b9a26f6387440", "filename": "src/libstd/sys/unix/sync.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fsync.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,208 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(bad_style)]\n+\n+use libc;\n+\n+pub use self::os::{PTHREAD_MUTEX_INITIALIZER, pthread_mutex_t};\n+pub use self::os::{PTHREAD_COND_INITIALIZER, pthread_cond_t};\n+pub use self::os::{PTHREAD_RWLOCK_INITIALIZER, pthread_rwlock_t};\n+\n+extern {\n+    // mutexes\n+    pub fn pthread_mutex_destroy(lock: *mut pthread_mutex_t) -> libc::c_int;\n+    pub fn pthread_mutex_lock(lock: *mut pthread_mutex_t) -> libc::c_int;\n+    pub fn pthread_mutex_trylock(lock: *mut pthread_mutex_t) -> libc::c_int;\n+    pub fn pthread_mutex_unlock(lock: *mut pthread_mutex_t) -> libc::c_int;\n+\n+    // cvars\n+    pub fn pthread_cond_wait(cond: *mut pthread_cond_t,\n+                             lock: *mut pthread_mutex_t) -> libc::c_int;\n+    pub fn pthread_cond_timedwait(cond: *mut pthread_cond_t,\n+                              lock: *mut pthread_mutex_t,\n+                              abstime: *const libc::timespec) -> libc::c_int;\n+    pub fn pthread_cond_signal(cond: *mut pthread_cond_t) -> libc::c_int;\n+    pub fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> libc::c_int;\n+    pub fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> libc::c_int;\n+    pub fn gettimeofday(tp: *mut libc::timeval,\n+                        tz: *mut libc::c_void) -> libc::c_int;\n+\n+    // rwlocks\n+    pub fn pthread_rwlock_destroy(lock: *mut pthread_rwlock_t) -> libc::c_int;\n+    pub fn pthread_rwlock_rdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n+    pub fn pthread_rwlock_tryrdlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n+    pub fn pthread_rwlock_wrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n+    pub fn pthread_rwlock_trywrlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n+    pub fn pthread_rwlock_unlock(lock: *mut pthread_rwlock_t) -> libc::c_int;\n+}\n+\n+#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+mod os {\n+    use libc;\n+\n+    pub type pthread_mutex_t = *mut libc::c_void;\n+    pub type pthread_cond_t = *mut libc::c_void;\n+    pub type pthread_rwlock_t = *mut libc::c_void;\n+\n+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = 0 as *mut _;\n+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = 0 as *mut _;\n+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = 0 as *mut _;\n+}\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+mod os {\n+    use libc;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    const __PTHREAD_MUTEX_SIZE__: uint = 56;\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"arm\"))]\n+    const __PTHREAD_MUTEX_SIZE__: uint = 40;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    const __PTHREAD_COND_SIZE__: uint = 40;\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"arm\"))]\n+    const __PTHREAD_COND_SIZE__: uint = 24;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    const __PTHREAD_RWLOCK_SIZE__: uint = 192;\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"arm\"))]\n+    const __PTHREAD_RWLOCK_SIZE__: uint = 124;\n+\n+    const _PTHREAD_MUTEX_SIG_INIT: libc::c_long = 0x32AAABA7;\n+    const _PTHREAD_COND_SIG_INIT: libc::c_long = 0x3CB0B1BB;\n+    const _PTHREAD_RWLOCK_SIG_INIT: libc::c_long = 0x2DA8B3B4;\n+\n+    #[repr(C)]\n+    pub struct pthread_mutex_t {\n+        __sig: libc::c_long,\n+        __opaque: [u8, ..__PTHREAD_MUTEX_SIZE__],\n+    }\n+    #[repr(C)]\n+    pub struct pthread_cond_t {\n+        __sig: libc::c_long,\n+        __opaque: [u8, ..__PTHREAD_COND_SIZE__],\n+    }\n+    #[repr(C)]\n+    pub struct pthread_rwlock_t {\n+        __sig: libc::c_long,\n+        __opaque: [u8, ..__PTHREAD_RWLOCK_SIZE__],\n+    }\n+\n+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n+        __sig: _PTHREAD_MUTEX_SIG_INIT,\n+        __opaque: [0, ..__PTHREAD_MUTEX_SIZE__],\n+    };\n+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n+        __sig: _PTHREAD_COND_SIG_INIT,\n+        __opaque: [0, ..__PTHREAD_COND_SIZE__],\n+    };\n+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n+        __sig: _PTHREAD_RWLOCK_SIG_INIT,\n+        __opaque: [0, ..__PTHREAD_RWLOCK_SIZE__],\n+    };\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+mod os {\n+    use libc;\n+\n+    // minus 8 because we have an 'align' field\n+    #[cfg(target_arch = \"x86_64\")]\n+    const __SIZEOF_PTHREAD_MUTEX_T: uint = 40 - 8;\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"mipsel\"))]\n+    const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n+\n+    #[cfg(any(target_arch = \"x86_64\",\n+              target_arch = \"x86\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"mipsel\"))]\n+    const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    const __SIZEOF_PTHREAD_RWLOCK_T: uint = 56 - 8;\n+\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"mipsel\"))]\n+    const __SIZEOF_PTHREAD_RWLOCK_T: uint = 32 - 8;\n+\n+    #[repr(C)]\n+    pub struct pthread_mutex_t {\n+        __align: libc::c_longlong,\n+        size: [u8, ..__SIZEOF_PTHREAD_MUTEX_T],\n+    }\n+    #[repr(C)]\n+    pub struct pthread_cond_t {\n+        __align: libc::c_longlong,\n+        size: [u8, ..__SIZEOF_PTHREAD_COND_T],\n+    }\n+    #[repr(C)]\n+    pub struct pthread_rwlock_t {\n+        __align: libc::c_longlong,\n+        size: [u8, ..__SIZEOF_PTHREAD_RWLOCK_T],\n+    }\n+\n+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n+        __align: 0,\n+        size: [0, ..__SIZEOF_PTHREAD_MUTEX_T],\n+    };\n+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n+        __align: 0,\n+        size: [0, ..__SIZEOF_PTHREAD_COND_T],\n+    };\n+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n+        __align: 0,\n+        size: [0, ..__SIZEOF_PTHREAD_RWLOCK_T],\n+    };\n+}\n+#[cfg(target_os = \"android\")]\n+mod os {\n+    use libc;\n+\n+    #[repr(C)]\n+    pub struct pthread_mutex_t { value: libc::c_int }\n+    #[repr(C)]\n+    pub struct pthread_cond_t { value: libc::c_int }\n+    #[repr(C)]\n+    pub struct pthread_rwlock_t {\n+        lock: pthread_mutex_t,\n+        cond: pthread_cond_t,\n+        numLocks: libc::c_int,\n+        writerThreadId: libc::c_int,\n+        pendingReaders: libc::c_int,\n+        pendingWriters: libc::c_int,\n+        reserved: [*mut libc::c_void, ..4],\n+    }\n+\n+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n+        value: 0,\n+    };\n+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n+        value: 0,\n+    };\n+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n+        lock: PTHREAD_MUTEX_INITIALIZER,\n+        cond: PTHREAD_COND_INITIALIZER,\n+        numLocks: 0,\n+        writerThreadId: 0,\n+        pendingReaders: 0,\n+        pendingWriters: 0,\n+        reserved: [0 as *mut _, ..4],\n+    };\n+}"}, {"sha": "3cabf3a63194cceee3f107bf0e2c76150568ea8e", "filename": "src/libstd/sys/windows/condvar.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use libc::{mod, DWORD};\n+use libc;\n+use os;\n+use sys::mutex::{mod, Mutex};\n+use sys::sync as ffi;\n+use time::Duration;\n+\n+pub struct Condvar { inner: UnsafeCell<ffi::CONDITION_VARIABLE> }\n+\n+pub const CONDVAR_INIT: Condvar = Condvar {\n+    inner: UnsafeCell { value: ffi::CONDITION_VARIABLE_INIT }\n+};\n+\n+impl Condvar {\n+    #[inline]\n+    pub unsafe fn new() -> Condvar { CONDVAR_INIT }\n+\n+    #[inline]\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        let r = ffi::SleepConditionVariableCS(self.inner.get(),\n+                                              mutex::raw(mutex),\n+                                              libc::INFINITE);\n+        debug_assert!(r != 0);\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        let r = ffi::SleepConditionVariableCS(self.inner.get(),\n+                                              mutex::raw(mutex),\n+                                              dur.num_milliseconds() as DWORD);\n+        if r == 0 {\n+            const ERROR_TIMEOUT: DWORD = 0x5B4;\n+            debug_assert_eq!(os::errno() as uint, ERROR_TIMEOUT as uint);\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_one(&self) {\n+        ffi::WakeConditionVariable(self.inner.get())\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_all(&self) {\n+        ffi::WakeAllConditionVariable(self.inner.get())\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        // ...\n+    }\n+}"}, {"sha": "9fce308cb9468cad60def633aa6a3825ff412858", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -26,20 +26,26 @@ use sync::{Once, ONCE_INIT};\n \n macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n     static $name: Helper<$m> = Helper {\n-        lock: ::rustrt::mutex::NATIVE_MUTEX_INIT,\n+        lock: ::sync::MUTEX_INIT,\n+        cond: ::sync::CONDVAR_INIT,\n         chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n         signal: ::cell::UnsafeCell { value: 0 },\n         initialized: ::cell::UnsafeCell { value: false },\n+        shutdown: ::cell::UnsafeCell { value: false },\n     };\n ) )\n \n pub mod c;\n pub mod ext;\n+pub mod condvar;\n pub mod fs;\n pub mod helper_signal;\n+pub mod mutex;\n pub mod os;\n pub mod pipe;\n pub mod process;\n+pub mod rwlock;\n+pub mod sync;\n pub mod tcp;\n pub mod thread_local;\n pub mod timer;"}, {"sha": "ddd89070ed53d56ecff1c531f998a4d0022310d5", "filename": "src/libstd/sys/windows/mutex.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+use sync::atomic;\n+use alloc::{mod, heap};\n+\n+use libc::DWORD;\n+use sys::sync as ffi;\n+\n+const SPIN_COUNT: DWORD = 4000;\n+\n+pub struct Mutex { inner: atomic::AtomicUint }\n+\n+pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::INIT_ATOMIC_UINT };\n+\n+#[inline]\n+pub unsafe fn raw(m: &Mutex) -> ffi::LPCRITICAL_SECTION {\n+    m.get()\n+}\n+\n+impl Mutex {\n+    #[inline]\n+    pub unsafe fn new() -> Mutex {\n+        Mutex { inner: atomic::AtomicUint::new(init_lock() as uint) }\n+    }\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        ffi::EnterCriticalSection(self.get())\n+    }\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        ffi::TryEnterCriticalSection(self.get()) != 0\n+    }\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        ffi::LeaveCriticalSection(self.get())\n+    }\n+    pub unsafe fn destroy(&self) {\n+        let lock = self.inner.swap(0, atomic::SeqCst);\n+        if lock != 0 { free_lock(lock as ffi::LPCRITICAL_SECTION) }\n+    }\n+\n+    unsafe fn get(&self) -> ffi::LPCRITICAL_SECTION {\n+        match self.inner.load(atomic::SeqCst) {\n+            0 => {}\n+            n => return n as ffi::LPCRITICAL_SECTION\n+        }\n+        let lock = init_lock();\n+        match self.inner.compare_and_swap(0, lock as uint, atomic::SeqCst) {\n+            0 => return lock as ffi::LPCRITICAL_SECTION,\n+            _ => {}\n+        }\n+        free_lock(lock);\n+        return self.inner.load(atomic::SeqCst) as ffi::LPCRITICAL_SECTION;\n+    }\n+}\n+\n+unsafe fn init_lock() -> ffi::LPCRITICAL_SECTION {\n+    let block = heap::allocate(ffi::CRITICAL_SECTION_SIZE, 8)\n+                        as ffi::LPCRITICAL_SECTION;\n+    if block.is_null() { alloc::oom() }\n+    ffi::InitializeCriticalSectionAndSpinCount(block, SPIN_COUNT);\n+    return block;\n+}\n+\n+unsafe fn free_lock(h: ffi::LPCRITICAL_SECTION) {\n+    ffi::DeleteCriticalSection(h);\n+    heap::deallocate(h as *mut _, ffi::CRITICAL_SECTION_SIZE, 8);\n+}"}, {"sha": "bf658d0efd0290bd15345070f4e2f3cbbbd924b8", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -89,8 +89,7 @@ use libc;\n use c_str::CString;\n use mem;\n use ptr;\n-use sync::atomic;\n-use rustrt::mutex;\n+use sync::{atomic, Mutex};\n use io::{mod, IoError, IoResult};\n use prelude::*;\n \n@@ -126,7 +125,7 @@ impl Drop for Event {\n \n struct Inner {\n     handle: libc::HANDLE,\n-    lock: mutex::NativeMutex,\n+    lock: Mutex<()>,\n     read_closed: atomic::AtomicBool,\n     write_closed: atomic::AtomicBool,\n }\n@@ -135,7 +134,7 @@ impl Inner {\n     fn new(handle: libc::HANDLE) -> Inner {\n         Inner {\n             handle: handle,\n-            lock: unsafe { mutex::NativeMutex::new() },\n+            lock: Mutex::new(()),\n             read_closed: atomic::AtomicBool::new(false),\n             write_closed: atomic::AtomicBool::new(false),\n         }"}, {"sha": "88ce85c39f625f67694fa326be1cd9c487b922b8", "filename": "src/libstd/sys/windows/rwlock.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use sys::sync as ffi;\n+\n+pub struct RWLock { inner: UnsafeCell<ffi::SRWLOCK> }\n+\n+pub const RWLOCK_INIT: RWLock = RWLock {\n+    inner: UnsafeCell { value: ffi::SRWLOCK_INIT }\n+};\n+\n+impl RWLock {\n+    #[inline]\n+    pub unsafe fn new() -> RWLock { RWLOCK_INIT }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        ffi::AcquireSRWLockShared(self.inner.get())\n+    }\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        ffi::TryAcquireSRWLockShared(self.inner.get()) != 0\n+    }\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        ffi::AcquireSRWLockExclusive(self.inner.get())\n+    }\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        ffi::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n+    }\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        ffi::ReleaseSRWLockShared(self.inner.get())\n+    }\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        ffi::ReleaseSRWLockExclusive(self.inner.get())\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        // ...\n+    }\n+}"}, {"sha": "cbca47912b511642ab309ddd1ca451ce7c7496bb", "filename": "src/libstd/sys/windows/sync.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{BOOL, DWORD, c_void, LPVOID};\n+use libc::types::os::arch::extra::BOOLEAN;\n+\n+pub type LPCRITICAL_SECTION = *mut c_void;\n+pub type LPCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n+pub type LPSRWLOCK = *mut SRWLOCK;\n+\n+#[cfg(target_arch = \"x86\")]\n+pub const CRITICAL_SECTION_SIZE: uint = 24;\n+#[cfg(target_arch = \"x86_64\")]\n+pub const CRITICAL_SECTION_SIZE: uint = 40;\n+\n+#[repr(C)]\n+pub struct CONDITION_VARIABLE { pub ptr: LPVOID }\n+#[repr(C)]\n+pub struct SRWLOCK { pub ptr: LPVOID }\n+\n+pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n+    ptr: 0 as *mut _,\n+};\n+pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: 0 as *mut _ };\n+\n+extern \"system\" {\n+    // critical sections\n+    pub fn InitializeCriticalSectionAndSpinCount(\n+                    lpCriticalSection: LPCRITICAL_SECTION,\n+                    dwSpinCount: DWORD) -> BOOL;\n+    pub fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n+    pub fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n+    pub fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n+    pub fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;\n+\n+    // condition variables\n+    pub fn SleepConditionVariableCS(ConditionVariable: LPCONDITION_VARIABLE,\n+                                    CriticalSection: LPCRITICAL_SECTION,\n+                                    dwMilliseconds: DWORD) -> BOOL;\n+    pub fn WakeConditionVariable(ConditionVariable: LPCONDITION_VARIABLE);\n+    pub fn WakeAllConditionVariable(ConditionVariable: LPCONDITION_VARIABLE);\n+\n+    // slim rwlocks\n+    pub fn AcquireSRWLockExclusive(SRWLock: LPSRWLOCK);\n+    pub fn AcquireSRWLockShared(SRWLock: LPSRWLOCK);\n+    pub fn ReleaseSRWLockExclusive(SRWLock: LPSRWLOCK);\n+    pub fn ReleaseSRWLockShared(SRWLock: LPSRWLOCK);\n+    pub fn TryAcquireSRWLockExclusive(SRWLock: LPSRWLOCK) -> BOOLEAN;\n+    pub fn TryAcquireSRWLockShared(SRWLock: LPSRWLOCK) -> BOOLEAN;\n+}\n+"}, {"sha": "45752499ad592711759718d759f164164899d5c6", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -450,9 +450,8 @@ pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[ast::TokenTree])\n                        -> Box<base::MacResult+'static> {\n-    let e_param_colons = cx.expr_lit(sp, ast::LitBool(false));\n     let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n-                                     vec!(e_param_colons), tts);\n+                                     vec![], tts);\n     base::MacExpr::new(expanded)\n }\n "}, {"sha": "11c65d531f6fd07f39625d657ab8273b299ff76f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -32,9 +32,7 @@ use parse::token;\n \n use std::slice;\n \n-/// This is a list of all known features since the beginning of time. This list\n-/// can never shrink, it may only be expanded (in order to prevent old programs\n-/// from failing to compile). The status of each feature may change, however.\n+// if you change this list without updating src/doc/reference.md, @cmr will be sad\n static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"globs\", Active),\n     (\"macro_rules\", Active),\n@@ -65,15 +63,13 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"unboxed_closures\", Active),\n     (\"import_shadowing\", Active),\n     (\"advanced_slice_patterns\", Active),\n-    (\"tuple_indexing\", Active),\n+    (\"tuple_indexing\", Accepted),\n     (\"associated_types\", Active),\n     (\"visible_private_types\", Active),\n     (\"slicing_syntax\", Active),\n \n-    (\"if_let\", Active),\n-    (\"while_let\", Active),\n-\n-    // if you change this list without updating src/doc/reference.md, cmr will be sad\n+    (\"if_let\", Accepted),\n+    (\"while_let\", Accepted),\n \n     // A temporary feature gate used to enable parser extensions needed\n     // to bootstrap fix for #5723.\n@@ -309,24 +305,11 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                                   \"unboxed closures are a work-in-progress \\\n                                    feature with known bugs\");\n             }\n-            ast::ExprTupField(..) => {\n-                self.gate_feature(\"tuple_indexing\",\n-                                  e.span,\n-                                  \"tuple indexing is experimental\");\n-            }\n-            ast::ExprIfLet(..) => {\n-                self.gate_feature(\"if_let\", e.span,\n-                                  \"`if let` syntax is experimental\");\n-            }\n             ast::ExprSlice(..) => {\n                 self.gate_feature(\"slicing_syntax\",\n                                   e.span,\n                                   \"slicing syntax is experimental\");\n             }\n-            ast::ExprWhileLet(..) => {\n-                self.gate_feature(\"while_let\", e.span,\n-                                  \"`while let` syntax is experimental\");\n-            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "41fee1556abff526146a29d1cb3265bc7016d183", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -212,7 +212,7 @@ impl<'a> ParserAttr for Parser<'a> {\n     fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>> {\n         self.parse_seq(&token::OpenDelim(token::Paren),\n                        &token::CloseDelim(token::Paren),\n-                       seq_sep_trailing_disallowed(token::Comma),\n+                       seq_sep_trailing_allowed(token::Comma),\n                        |p| p.parse_meta_item()).node\n     }\n "}, {"sha": "a96bf1ce10b798064b2d2b6fdc24da50190ee412", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -19,18 +19,13 @@ pub struct SeqSep {\n     pub trailing_sep_allowed: bool\n }\n \n-pub fn seq_sep_trailing_disallowed(t: token::Token) -> SeqSep {\n-    SeqSep {\n-        sep: Some(t),\n-        trailing_sep_allowed: false,\n-    }\n-}\n pub fn seq_sep_trailing_allowed(t: token::Token) -> SeqSep {\n     SeqSep {\n         sep: Some(t),\n         trailing_sep_allowed: true,\n     }\n }\n+\n pub fn seq_sep_none() -> SeqSep {\n     SeqSep {\n         sep: None,"}, {"sha": "27b65e0f52798d8aaa6ab71bb23864658e350034", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -764,6 +764,15 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n+    // SNAP c9f6d69\n+    #[allow(unused)]\n+    fn old_escape_warning(&mut self, sp: Span) {\n+        self.span_diagnostic\n+            .span_warn(sp, \"\\\\U00ABCD12 and \\\\uABCD escapes are deprecated\");\n+        self.span_diagnostic\n+            .span_help(sp, \"use \\\\u{ABCD12} escapes instead\");\n+    }\n+\n     /// Scan for a single (possibly escaped) byte or char\n     /// in a byte, (non-raw) byte string, char, or (non-raw) string literal.\n     /// `start` is the position of `first_source_char`, which is already consumed.\n@@ -782,12 +791,24 @@ impl<'a> StringReader<'a> {\n                     Some(e) => {\n                         return match e {\n                             'n' | 'r' | 't' | '\\\\' | '\\'' | '\"' | '0' => true,\n-                            'x' => self.scan_hex_digits(2u, delim, !ascii_only),\n+                            'x' => self.scan_byte_escape(delim, !ascii_only),\n                             'u' if !ascii_only => {\n-                                self.scan_hex_digits(4u, delim, false)\n+                                if self.curr == Some('{') {\n+                                    self.scan_unicode_escape(delim)\n+                                } else {\n+                                    let res = self.scan_hex_digits(4u, delim, false);\n+                                    // SNAP c9f6d69\n+                                    //let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n+                                    //self.old_escape_warning(sp);\n+                                    res\n+                                }\n                             }\n                             'U' if !ascii_only => {\n-                                self.scan_hex_digits(8u, delim, false)\n+                                let res = self.scan_hex_digits(8u, delim, false);\n+                                // SNAP c9f6d69\n+                                //let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n+                                //self.old_escape_warning(sp);\n+                                res\n                             }\n                             '\\n' if delim == '\"' => {\n                                 self.consume_whitespace();\n@@ -848,6 +869,56 @@ impl<'a> StringReader<'a> {\n         true\n     }\n \n+    /// Scan over a \\u{...} escape\n+    ///\n+    /// At this point, we have already seen the \\ and the u, the { is the current character. We\n+    /// will read at least one digit, and up to 6, and pass over the }.\n+    fn scan_unicode_escape(&mut self, delim: char) -> bool {\n+        self.bump(); // past the {\n+        let start_bpos = self.last_pos;\n+        let mut count: uint = 0;\n+        let mut accum_int = 0;\n+\n+        while !self.curr_is('}') && count <= 6 {\n+            let c = match self.curr {\n+                Some(c) => c,\n+                None => {\n+                    self.fatal_span_(start_bpos, self.last_pos,\n+                                     \"unterminated unicode escape (found EOF)\");\n+                }\n+            };\n+            accum_int *= 16;\n+            accum_int += c.to_digit(16).unwrap_or_else(|| {\n+                if c == delim {\n+                    self.fatal_span_(self.last_pos, self.pos,\n+                                     \"unterminated unicode escape (needed a `}`)\");\n+                } else {\n+                    self.fatal_span_char(self.last_pos, self.pos,\n+                                   \"illegal character in unicode escape\", c);\n+                }\n+            }) as u32;\n+            self.bump();\n+            count += 1;\n+        }\n+\n+        if count > 6 {\n+            self.fatal_span_(start_bpos, self.last_pos,\n+                          \"overlong unicode escape (can have at most 6 hex digits)\");\n+        }\n+\n+        self.bump(); // past the ending }\n+\n+        let mut valid = count >= 1 && count <= 6;\n+        if char::from_u32(accum_int).is_none() {\n+            valid = false;\n+        }\n+\n+        if !valid {\n+            self.fatal_span_(start_bpos, self.last_pos, \"illegal unicode character escape\");\n+        }\n+        valid\n+    }\n+\n     /// Scan over a float exponent.\n     fn scan_float_exponent(&mut self) {\n         if self.curr_is('e') || self.curr_is('E') {\n@@ -1273,6 +1344,10 @@ impl<'a> StringReader<'a> {\n         return token::Byte(id);\n     }\n \n+    fn scan_byte_escape(&mut self, delim: char, below_0x7f_only: bool) -> bool {\n+        self.scan_hex_digits(2, delim, below_0x7f_only)\n+    }\n+\n     fn scan_byte_string(&mut self) -> token::Lit {\n         self.bump();\n         let start = self.last_pos;"}, {"sha": "8d0c2de048a5676bb2231a054c0c11ea3cf22783", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -393,16 +393,28 @@ pub fn char_lit(lit: &str) -> (char, int) {\n     let msg = format!(\"lexer should have rejected a bad character escape {}\", lit);\n     let msg2 = msg.as_slice();\n \n-    let esc: |uint| -> Option<(char, int)> = |len|\n+    fn esc(len: uint, lit: &str) -> Option<(char, int)> {\n         num::from_str_radix(lit.slice(2, len), 16)\n         .and_then(char::from_u32)\n-        .map(|x| (x, len as int));\n+        .map(|x| (x, len as int))\n+    }\n+\n+    let unicode_escape: || -> Option<(char, int)> = ||\n+        if lit.as_bytes()[2] == b'{' {\n+            let idx = lit.find('}').expect(msg2);\n+            let subslice = lit.slice(3, idx);\n+            num::from_str_radix(subslice, 16)\n+                .and_then(char::from_u32)\n+                .map(|x| (x, subslice.char_len() as int + 4))\n+        } else {\n+            esc(6, lit)\n+        };\n \n     // Unicode escapes\n     return match lit.as_bytes()[1] as char {\n-        'x' | 'X' => esc(4),\n-        'u' => esc(6),\n-        'U' => esc(10),\n+        'x' | 'X' => esc(4, lit),\n+        'u' => unicode_escape(),\n+        'U' => esc(10, lit),\n         _ => None,\n     }.expect(msg2);\n }"}, {"sha": "bb3d28ce2bb54c315f3a83ab215a813b45f5f53d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 120, "deletions": 68, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -87,6 +87,7 @@ use std::mem;\n use std::num::Float;\n use std::rc::Rc;\n use std::iter;\n+use std::slice;\n \n bitflags! {\n     flags Restrictions: u8 {\n@@ -303,6 +304,22 @@ pub struct Parser<'a> {\n     /// name is not known. This does not change while the parser is descending\n     /// into modules, and sub-parsers have new values for this name.\n     pub root_module_name: Option<String>,\n+    pub expected_tokens: Vec<TokenType>,\n+}\n+\n+#[deriving(PartialEq, Eq, Clone)]\n+pub enum TokenType {\n+    Token(token::Token),\n+    Operator,\n+}\n+\n+impl TokenType {\n+    fn to_string(&self) -> String {\n+        match *self {\n+            TokenType::Token(ref t) => format!(\"`{}`\", Parser::token_to_string(t)),\n+            TokenType::Operator => \"an operator\".into_string(),\n+        }\n+    }\n }\n \n fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n@@ -347,6 +364,7 @@ impl<'a> Parser<'a> {\n             open_braces: Vec::new(),\n             owns_directory: true,\n             root_module_name: None,\n+            expected_tokens: Vec::new(),\n         }\n     }\n \n@@ -375,14 +393,18 @@ impl<'a> Parser<'a> {\n     /// Expect and consume the token t. Signal an error if\n     /// the next token is not t.\n     pub fn expect(&mut self, t: &token::Token) {\n-        if self.token == *t {\n-            self.bump();\n+        if self.expected_tokens.is_empty() {\n+            if self.token == *t {\n+                self.bump();\n+            } else {\n+                let token_str = Parser::token_to_string(t);\n+                let this_token_str = self.this_token_to_string();\n+                self.fatal(format!(\"expected `{}`, found `{}`\",\n+                                   token_str,\n+                                   this_token_str).as_slice())\n+            }\n         } else {\n-            let token_str = Parser::token_to_string(t);\n-            let this_token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `{}`, found `{}`\",\n-                               token_str,\n-                               this_token_str).as_slice())\n+            self.expect_one_of(slice::ref_slice(t), &[]);\n         }\n     }\n \n@@ -392,15 +414,20 @@ impl<'a> Parser<'a> {\n     pub fn expect_one_of(&mut self,\n                          edible: &[token::Token],\n                          inedible: &[token::Token]) {\n-        fn tokens_to_string(tokens: &[token::Token]) -> String {\n+        fn tokens_to_string(tokens: &[TokenType]) -> String {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n             let b = i.next()\n-                     .map_or(\"\".to_string(), |t| Parser::token_to_string(t));\n-            i.fold(b, |b,a| {\n-                let mut b = b;\n-                b.push_str(\"`, `\");\n-                b.push_str(Parser::token_to_string(a).as_slice());\n+                     .map_or(\"\".into_string(), |t| t.to_string());\n+            i.enumerate().fold(b, |mut b, (i, ref a)| {\n+                if tokens.len() > 2 && i == tokens.len() - 2 {\n+                    b.push_str(\", or \");\n+                } else if tokens.len() == 2 && i == tokens.len() - 2 {\n+                    b.push_str(\" or \");\n+                } else {\n+                    b.push_str(\", \");\n+                }\n+                b.push_str(&*a.to_string());\n                 b\n             })\n         }\n@@ -409,17 +436,21 @@ impl<'a> Parser<'a> {\n         } else if inedible.contains(&self.token) {\n             // leave it in the input\n         } else {\n-            let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n-            expected.push_all(inedible);\n+            let mut expected = edible.iter().map(|x| TokenType::Token(x.clone()))\n+                                            .collect::<Vec<_>>();\n+            expected.extend(inedible.iter().map(|x| TokenType::Token(x.clone())));\n+            expected.push_all(&*self.expected_tokens);\n+            expected.sort_by(|a, b| a.to_string().cmp(&b.to_string()));\n+            expected.dedup();\n             let expect = tokens_to_string(expected.as_slice());\n             let actual = self.this_token_to_string();\n             self.fatal(\n                 (if expected.len() != 1 {\n-                    (format!(\"expected one of `{}`, found `{}`\",\n+                    (format!(\"expected one of {}, found `{}`\",\n                              expect,\n                              actual))\n                 } else {\n-                    (format!(\"expected `{}`, found `{}`\",\n+                    (format!(\"expected {}, found `{}`\",\n                              expect,\n                              actual))\n                 }).as_slice()\n@@ -514,10 +545,20 @@ impl<'a> Parser<'a> {\n         spanned(lo, hi, node)\n     }\n \n+    /// Check if the next token is `tok`, and return `true` if so.\n+    ///\n+    /// This method is will automatically add `tok` to `expected_tokens` if `tok` is not\n+    /// encountered.\n+    pub fn check(&mut self, tok: &token::Token) -> bool {\n+        let is_present = self.token == *tok;\n+        if !is_present { self.expected_tokens.push(TokenType::Token(tok.clone())); }\n+        is_present\n+    }\n+\n     /// Consume token 'tok' if it exists. Returns true if the given\n     /// token was present, false otherwise.\n     pub fn eat(&mut self, tok: &token::Token) -> bool {\n-        let is_present = self.token == *tok;\n+        let is_present = self.check(tok);\n         if is_present { self.bump() }\n         is_present\n     }\n@@ -739,7 +780,7 @@ impl<'a> Parser<'a> {\n         // commas in generic parameters, because it can stop either after\n         // parsing a type or after parsing a comma.\n         for i in iter::count(0u, 1) {\n-            if self.token == token::Gt\n+            if self.check(&token::Gt)\n                 || self.token == token::BinOp(token::Shr)\n                 || self.token == token::Ge\n                 || self.token == token::BinOpEq(token::Shr) {\n@@ -798,7 +839,7 @@ impl<'a> Parser<'a> {\n               }\n               _ => ()\n             }\n-            if sep.trailing_sep_allowed && self.token == *ket { break; }\n+            if sep.trailing_sep_allowed && self.check(ket) { break; }\n             v.push(f(self));\n         }\n         return v;\n@@ -881,6 +922,7 @@ impl<'a> Parser<'a> {\n         self.span = next.sp;\n         self.token = next.tok;\n         self.tokens_consumed += 1u;\n+        self.expected_tokens.clear();\n     }\n \n     /// Advance the parser by one token and return the bumped token.\n@@ -999,7 +1041,7 @@ impl<'a> Parser<'a> {\n             self.parse_proc_type(lifetime_defs)\n         } else if self.token_is_bare_fn_keyword() || self.token_is_closure_keyword() {\n             self.parse_ty_bare_fn_or_ty_closure(lifetime_defs)\n-        } else if self.token == token::ModSep ||\n+        } else if self.check(&token::ModSep) ||\n                   self.token.is_ident() ||\n                   self.token.is_path()\n         {\n@@ -1101,7 +1143,7 @@ impl<'a> Parser<'a> {\n     /// Parses an optional unboxed closure kind (`&:`, `&mut:`, or `:`).\n     pub fn parse_optional_unboxed_closure_kind(&mut self)\n                                                -> Option<UnboxedClosureKind> {\n-        if self.token == token::BinOp(token::And) &&\n+        if self.check(&token::BinOp(token::And)) &&\n                 self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n                 self.look_ahead(2, |t| *t == token::Colon) {\n             self.bump();\n@@ -1211,7 +1253,8 @@ impl<'a> Parser<'a> {\n                                   lifetime_defs: Vec<ast::LifetimeDef>)\n                                   -> Vec<ast::LifetimeDef>\n     {\n-        if self.eat(&token::Lt) {\n+        if self.token == token::Lt {\n+            self.bump();\n             if lifetime_defs.is_empty() {\n                 self.warn(\"deprecated syntax; use the `for` keyword now \\\n                             (e.g. change `fn<'a>` to `for<'a> fn`)\");\n@@ -1430,7 +1473,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n \n-        let t = if self.token == token::OpenDelim(token::Paren) {\n+        let t = if self.check(&token::OpenDelim(token::Paren)) {\n             self.bump();\n \n             // (t) is a parenthesized ty\n@@ -1440,7 +1483,7 @@ impl<'a> Parser<'a> {\n             let mut last_comma = false;\n             while self.token != token::CloseDelim(token::Paren) {\n                 ts.push(self.parse_ty_sum());\n-                if self.token == token::Comma {\n+                if self.check(&token::Comma) {\n                     last_comma = true;\n                     self.bump();\n                 } else {\n@@ -1464,11 +1507,11 @@ impl<'a> Parser<'a> {\n                 _ => self.obsolete(last_span, ObsoleteOwnedType)\n             }\n             TyTup(vec![self.parse_ty()])\n-        } else if self.token == token::BinOp(token::Star) {\n+        } else if self.check(&token::BinOp(token::Star)) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n             TyPtr(self.parse_ptr())\n-        } else if self.token == token::OpenDelim(token::Bracket) {\n+        } else if self.check(&token::OpenDelim(token::Bracket)) {\n             // VECTOR\n             self.expect(&token::OpenDelim(token::Bracket));\n             let t = self.parse_ty_sum();\n@@ -1481,7 +1524,7 @@ impl<'a> Parser<'a> {\n             };\n             self.expect(&token::CloseDelim(token::Bracket));\n             t\n-        } else if self.token == token::BinOp(token::And) ||\n+        } else if self.check(&token::BinOp(token::And)) ||\n                   self.token == token::AndAnd {\n             // BORROWED POINTER\n             self.expect_and();\n@@ -1492,7 +1535,7 @@ impl<'a> Parser<'a> {\n                   self.token_is_closure_keyword() {\n             // BARE FUNCTION OR CLOSURE\n             self.parse_ty_bare_fn_or_ty_closure(Vec::new())\n-        } else if self.token == token::BinOp(token::Or) ||\n+        } else if self.check(&token::BinOp(token::Or)) ||\n                   self.token == token::OrOr ||\n                   (self.token == token::Lt &&\n                    self.look_ahead(1, |t| {\n@@ -1509,7 +1552,7 @@ impl<'a> Parser<'a> {\n             TyTypeof(e)\n         } else if self.eat_keyword(keywords::Proc) {\n             self.parse_proc_type(Vec::new())\n-        } else if self.token == token::Lt {\n+        } else if self.check(&token::Lt) {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             self.bump();\n             let self_type = self.parse_ty_sum();\n@@ -1523,7 +1566,7 @@ impl<'a> Parser<'a> {\n                 trait_ref: P(trait_ref),\n                 item_name: item_name,\n             }))\n-        } else if self.token == token::ModSep ||\n+        } else if self.check(&token::ModSep) ||\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n             // NAMED TYPE\n@@ -1532,7 +1575,8 @@ impl<'a> Parser<'a> {\n             // TYPE TO BE INFERRED\n             TyInfer\n         } else {\n-            let msg = format!(\"expected type, found token {}\", self.token);\n+            let this_token_str = self.this_token_to_string();\n+            let msg = format!(\"expected type, found `{}`\", this_token_str);\n             self.fatal(msg.as_slice());\n         };\n \n@@ -1635,7 +1679,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn maybe_parse_fixed_vstore(&mut self) -> Option<P<ast::Expr>> {\n-        if self.token == token::Comma &&\n+        if self.check(&token::Comma) &&\n                 self.look_ahead(1, |t| *t == token::DotDot) {\n             self.bump();\n             self.bump();\n@@ -1959,9 +2003,10 @@ impl<'a> Parser<'a> {\n                 token::Gt => { return res; }\n                 token::BinOp(token::Shr) => { return res; }\n                 _ => {\n+                    let this_token_str = self.this_token_to_string();\n                     let msg = format!(\"expected `,` or `>` after lifetime \\\n-                                      name, got: {}\",\n-                                      self.token);\n+                                      name, found `{}`\",\n+                                      this_token_str);\n                     self.fatal(msg.as_slice());\n                 }\n             }\n@@ -2126,7 +2171,7 @@ impl<'a> Parser<'a> {\n                     es.push(self.parse_expr());\n                     self.commit_expr(&**es.last().unwrap(), &[],\n                                      &[token::Comma, token::CloseDelim(token::Paren)]);\n-                    if self.token == token::Comma {\n+                    if self.check(&token::Comma) {\n                         trailing_comma = true;\n \n                         self.bump();\n@@ -2167,22 +2212,22 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n \n-                if self.token == token::CloseDelim(token::Bracket) {\n+                if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n                     self.bump();\n                     ex = ExprVec(Vec::new());\n                 } else {\n                     // Nonempty vector.\n                     let first_expr = self.parse_expr();\n-                    if self.token == token::Comma &&\n+                    if self.check(&token::Comma) &&\n                         self.look_ahead(1, |t| *t == token::DotDot) {\n                         // Repeating vector syntax: [ 0, ..512 ]\n                         self.bump();\n                         self.bump();\n                         let count = self.parse_expr();\n                         self.expect(&token::CloseDelim(token::Bracket));\n                         ex = ExprRepeat(first_expr, count);\n-                    } else if self.token == token::Comma {\n+                    } else if self.check(&token::Comma) {\n                         // Vector with two or more elements.\n                         self.bump();\n                         let remaining_exprs = self.parse_seq_to_end(\n@@ -2284,15 +2329,15 @@ impl<'a> Parser<'a> {\n                         ex = ExprBreak(None);\n                     }\n                     hi = self.span.hi;\n-                } else if self.token == token::ModSep ||\n+                } else if self.check(&token::ModSep) ||\n                         self.token.is_ident() &&\n                         !self.token.is_keyword(keywords::True) &&\n                         !self.token.is_keyword(keywords::False) {\n                     let pth =\n                         self.parse_path(LifetimeAndTypesWithColons);\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n-                    if self.token == token::Not {\n+                    if self.check(&token::Not) {\n                         // MACRO INVOCATION expression\n                         self.bump();\n \n@@ -2309,7 +2354,7 @@ impl<'a> Parser<'a> {\n                                                            tts,\n                                                            EMPTY_CTXT));\n                     }\n-                    if self.token == token::OpenDelim(token::Brace) {\n+                    if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n                         if !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL) {\n@@ -2840,6 +2885,7 @@ impl<'a> Parser<'a> {\n             self.restrictions.contains(RESTRICTION_NO_BAR_OP) {\n             return lhs;\n         }\n+        self.expected_tokens.push(TokenType::Operator);\n \n         let cur_opt = self.token.to_binop();\n         match cur_opt {\n@@ -3079,7 +3125,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse the RHS of a local variable declaration (e.g. '= 14;')\n     fn parse_initializer(&mut self) -> Option<P<Expr>> {\n-        if self.token == token::Eq {\n+        if self.check(&token::Eq) {\n             self.bump();\n             Some(self.parse_expr())\n         } else {\n@@ -3092,7 +3138,7 @@ impl<'a> Parser<'a> {\n         let mut pats = Vec::new();\n         loop {\n             pats.push(self.parse_pat());\n-            if self.token == token::BinOp(token::Or) { self.bump(); }\n+            if self.check(&token::BinOp(token::Or)) { self.bump(); }\n             else { return pats; }\n         };\n     }\n@@ -3111,14 +3157,19 @@ impl<'a> Parser<'a> {\n                 first = false;\n             } else {\n                 self.expect(&token::Comma);\n+\n+                if self.token == token::CloseDelim(token::Bracket)\n+                        && (before_slice || after.len() != 0) {\n+                    break\n+                }\n             }\n \n             if before_slice {\n-                if self.token == token::DotDot {\n+                if self.check(&token::DotDot) {\n                     self.bump();\n \n-                    if self.token == token::Comma ||\n-                            self.token == token::CloseDelim(token::Bracket) {\n+                    if self.check(&token::Comma) ||\n+                            self.check(&token::CloseDelim(token::Bracket)) {\n                         slice = Some(P(ast::Pat {\n                             id: ast::DUMMY_NODE_ID,\n                             node: PatWild(PatWildMulti),\n@@ -3135,7 +3186,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let subpat = self.parse_pat();\n-            if before_slice && self.token == token::DotDot {\n+            if before_slice && self.check(&token::DotDot) {\n                 self.bump();\n                 slice = Some(subpat);\n                 before_slice = false;\n@@ -3160,13 +3211,13 @@ impl<'a> Parser<'a> {\n             } else {\n                 self.expect(&token::Comma);\n                 // accept trailing commas\n-                if self.token == token::CloseDelim(token::Brace) { break }\n+                if self.check(&token::CloseDelim(token::Brace)) { break }\n             }\n \n             let lo = self.span.lo;\n             let hi;\n \n-            if self.token == token::DotDot {\n+            if self.check(&token::DotDot) {\n                 self.bump();\n                 if self.token != token::CloseDelim(token::Brace) {\n                     let token_str = self.this_token_to_string();\n@@ -3187,7 +3238,7 @@ impl<'a> Parser<'a> {\n \n             let fieldname = self.parse_ident();\n \n-            let (subpat, is_shorthand) = if self.token == token::Colon {\n+            let (subpat, is_shorthand) = if self.check(&token::Colon) {\n                 match bind_type {\n                     BindByRef(..) | BindByValue(MutMutable) => {\n                         let token_str = self.this_token_to_string();\n@@ -3267,15 +3318,15 @@ impl<'a> Parser<'a> {\n           token::OpenDelim(token::Paren) => {\n             // parse (pat,pat,pat,...) as tuple\n             self.bump();\n-            if self.token == token::CloseDelim(token::Paren) {\n+            if self.check(&token::CloseDelim(token::Paren)) {\n                 self.bump();\n                 pat = PatTup(vec![]);\n             } else {\n                 let mut fields = vec!(self.parse_pat());\n                 if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n-                    while self.token == token::Comma {\n+                    while self.check(&token::Comma) {\n                         self.bump();\n-                        if self.token == token::CloseDelim(token::Paren) { break; }\n+                        if self.check(&token::CloseDelim(token::Paren)) { break; }\n                         fields.push(self.parse_pat());\n                     }\n                 }\n@@ -3318,7 +3369,7 @@ impl<'a> Parser<'a> {\n             // These expressions are limited to literals (possibly\n             // preceded by unary-minus) or identifiers.\n             let val = self.parse_literal_maybe_minus();\n-            if (self.token == token::DotDotDot) &&\n+            if (self.check(&token::DotDotDot)) &&\n                     self.look_ahead(1, |t| {\n                         *t != token::Comma && *t != token::CloseDelim(token::Bracket)\n                     }) {\n@@ -3621,7 +3672,7 @@ impl<'a> Parser<'a> {\n             let hi = self.span.hi;\n \n             if id.name == token::special_idents::invalid.name {\n-                if self.token == token::Dot {\n+                if self.check(&token::Dot) {\n                     let span = self.span;\n                     let token_string = self.this_token_to_string();\n                     self.span_err(span,\n@@ -3934,7 +3985,7 @@ impl<'a> Parser<'a> {\n \n         let bounds = self.parse_colon_then_ty_param_bounds();\n \n-        let default = if self.token == token::Eq {\n+        let default = if self.check(&token::Eq) {\n             self.bump();\n             Some(self.parse_ty_sum())\n         }\n@@ -4334,7 +4385,7 @@ impl<'a> Parser<'a> {\n                 (optional_unboxed_closure_kind, args)\n             }\n         };\n-        let output = if self.token == token::RArrow {\n+        let output = if self.check(&token::RArrow) {\n             self.parse_ret_ty()\n         } else {\n             Return(P(Ty {\n@@ -4359,7 +4410,7 @@ impl<'a> Parser<'a> {\n                                      seq_sep_trailing_allowed(token::Comma),\n                                      |p| p.parse_fn_block_arg());\n \n-        let output = if self.token == token::RArrow {\n+        let output = if self.check(&token::RArrow) {\n             self.parse_ret_ty()\n         } else {\n             Return(P(Ty {\n@@ -4616,7 +4667,7 @@ impl<'a> Parser<'a> {\n                                    token::get_ident(class_name)).as_slice());\n             }\n             self.bump();\n-        } else if self.token == token::OpenDelim(token::Paren) {\n+        } else if self.check(&token::OpenDelim(token::Paren)) {\n             // It's a tuple-like struct.\n             is_tuple_like = true;\n             fields = self.parse_unspanned_seq(\n@@ -4801,7 +4852,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> ItemInfo {\n         let id_span = self.span;\n         let id = self.parse_ident();\n-        if self.token == token::Semi {\n+        if self.check(&token::Semi) {\n             self.bump();\n             // This mod is in an external file. Let's go get it!\n             let (m, attrs) = self.eval_src_mod(id, outer_attrs, id_span);\n@@ -5044,7 +5095,8 @@ impl<'a> Parser<'a> {\n         let (maybe_path, ident) = match self.token {\n             token::Ident(..) => {\n                 let the_ident = self.parse_ident();\n-                let path = if self.eat(&token::Eq) {\n+                let path = if self.token == token::Eq {\n+                    self.bump();\n                     let path = self.parse_str();\n                     let span = self.span;\n                     self.obsolete(span, ObsoleteExternCrateRenaming);\n@@ -5184,7 +5236,7 @@ impl<'a> Parser<'a> {\n                                 token::get_ident(ident)).as_slice());\n                 }\n                 kind = StructVariantKind(struct_def);\n-            } else if self.token == token::OpenDelim(token::Paren) {\n+            } else if self.check(&token::OpenDelim(token::Paren)) {\n                 all_nullary = false;\n                 let arg_tys = self.parse_enum_variant_seq(\n                     &token::OpenDelim(token::Paren),\n@@ -5348,7 +5400,7 @@ impl<'a> Parser<'a> {\n                                         visibility,\n                                         maybe_append(attrs, extra_attrs));\n                 return IoviItem(item);\n-            } else if self.token == token::OpenDelim(token::Brace) {\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n                 return self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs);\n             }\n \n@@ -5629,7 +5681,7 @@ impl<'a> Parser<'a> {\n     fn parse_view_path(&mut self) -> P<ViewPath> {\n         let lo = self.span.lo;\n \n-        if self.token == token::OpenDelim(token::Brace) {\n+        if self.check(&token::OpenDelim(token::Brace)) {\n             // use {foo,bar}\n             let idents = self.parse_unspanned_seq(\n                 &token::OpenDelim(token::Brace),\n@@ -5653,7 +5705,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let path_lo = self.span.lo;\n             path = vec!(self.parse_ident());\n-            while self.token == token::ModSep {\n+            while self.check(&token::ModSep) {\n                 self.bump();\n                 let id = self.parse_ident();\n                 path.push(id);\n@@ -5677,7 +5729,7 @@ impl<'a> Parser<'a> {\n \n           token::ModSep => {\n             // foo::bar or foo::{a,b,c} or foo::*\n-            while self.token == token::ModSep {\n+            while self.check(&token::ModSep) {\n                 self.bump();\n \n                 match self.token {\n@@ -5846,7 +5898,7 @@ impl<'a> Parser<'a> {\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {\n                 IoviNone(returned_attrs) => {\n-                    if self.token == token::CloseDelim(token::Brace) {\n+                    if self.check(&token::CloseDelim(token::Brace)) {\n                         attrs = returned_attrs;\n                         break\n                     }"}, {"sha": "c943d8706e55b71cf96dc8018294bb25908bc559", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -51,8 +51,7 @@ use std::collections::TreeMap;\n use stats::Stats;\n use getopts::{OptGroup, optflag, optopt};\n use regex::Regex;\n-use serialize::{json, Decodable};\n-use serialize::json::{Json, ToJson};\n+use serialize::{json, Decodable, Encodable};\n use term::Terminal;\n use term::color::{Color, RED, YELLOW, GREEN, CYAN};\n \n@@ -1159,17 +1158,6 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n     }\n }\n \n-\n-impl ToJson for Metric {\n-    fn to_json(&self) -> json::Json {\n-        let mut map = TreeMap::new();\n-        map.insert(\"value\".to_string(), json::Json::F64(self.value));\n-        map.insert(\"noise\".to_string(), json::Json::F64(self.noise));\n-        json::Json::Object(map)\n-    }\n-}\n-\n-\n impl MetricMap {\n \n     pub fn new() -> MetricMap {\n@@ -1197,14 +1185,8 @@ impl MetricMap {\n     pub fn save(&self, p: &Path) -> io::IoResult<()> {\n         let mut file = try!(File::create(p));\n         let MetricMap(ref map) = *self;\n-\n-        // FIXME(pcwalton): Yuck.\n-        let mut new_map = TreeMap::new();\n-        for (ref key, ref value) in map.iter() {\n-            new_map.insert(key.to_string(), (*value).clone());\n-        }\n-\n-        new_map.to_json().to_pretty_writer(&mut file)\n+        let mut enc = json::PrettyEncoder::new(&mut file);\n+        map.encode(&mut enc)\n     }\n \n     /// Compare against another MetricMap. Optionally compare all"}, {"sha": "863c3c879a7c108009e14604233c2dddfd962168", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -19,28 +19,30 @@\n // ignore-lexer-test FIXME #15679\n \n use std::os;\n-use std::sync::{Arc, Future, Mutex};\n+use std::sync::{Arc, Future, Mutex, Condvar};\n use std::time::Duration;\n use std::uint;\n \n // A poor man's pipe.\n-type pipe = Arc<Mutex<Vec<uint>>>;\n+type pipe = Arc<(Mutex<Vec<uint>>, Condvar)>;\n \n fn send(p: &pipe, msg: uint) {\n-    let mut arr = p.lock();\n+    let &(ref lock, ref cond) = &**p;\n+    let mut arr = lock.lock();\n     arr.push(msg);\n-    arr.cond.signal();\n+    cond.notify_one();\n }\n fn recv(p: &pipe) -> uint {\n-    let mut arr = p.lock();\n+    let &(ref lock, ref cond) = &**p;\n+    let mut arr = lock.lock();\n     while arr.is_empty() {\n-        arr.cond.wait();\n+        cond.wait(&arr);\n     }\n     arr.pop().unwrap()\n }\n \n fn init() -> (pipe,pipe) {\n-    let m = Arc::new(Mutex::new(Vec::new()));\n+    let m = Arc::new((Mutex::new(Vec::new()), Condvar::new()));\n     ((&m).clone(), m)\n }\n "}, {"sha": "03066d40512f3cec8b91fb6af081ec0f870cd039", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/95d17711397d63425688d18140a58723caddff8e/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95d17711397d63425688d18140a58723caddff8e/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=95d17711397d63425688d18140a58723caddff8e", "patch": "@@ -1,113 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This test creates a bunch of tasks that simultaneously send to each\n-// other in a ring. The messages should all be basically\n-// independent.\n-// This is like msgsend-ring-pipes but adapted to use Arcs.\n-\n-// This also serves as a pipes test, because Arcs are implemented with pipes.\n-\n-// no-pretty-expanded FIXME #15189\n-// ignore-lexer-test FIXME #15679\n-\n-use std::os;\n-use std::sync::{RWLock, Arc, Future};\n-use std::time::Duration;\n-use std::uint;\n-\n-// A poor man's pipe.\n-type pipe = Arc<RWLock<Vec<uint>>>;\n-\n-fn send(p: &pipe, msg: uint) {\n-    let mut arr = p.write();\n-    arr.push(msg);\n-    arr.cond.signal();\n-}\n-fn recv(p: &pipe) -> uint {\n-    let mut arr = p.write();\n-    while arr.is_empty() {\n-        arr.cond.wait();\n-    }\n-    arr.pop().unwrap()\n-}\n-\n-fn init() -> (pipe,pipe) {\n-    let x = Arc::new(RWLock::new(Vec::new()));\n-    ((&x).clone(), x)\n-}\n-\n-\n-fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n-    let mut num_chan = Some(num_chan);\n-    let mut num_port = Some(num_port);\n-    // Send/Receive lots of messages.\n-    for j in range(0u, count) {\n-        //println!(\"task %?, iter %?\", i, j);\n-        let num_chan2 = num_chan.take().unwrap();\n-        let num_port2 = num_port.take().unwrap();\n-        send(&num_chan2, i * j);\n-        num_chan = Some(num_chan2);\n-        let _n = recv(&num_port2);\n-        //log(error, _n);\n-        num_port = Some(num_port2);\n-    };\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"100\".to_string(), \"10000\".to_string())\n-    } else if args.len() <= 1u {\n-        vec!(\"\".to_string(), \"10\".to_string(), \"100\".to_string())\n-    } else {\n-        args.clone().into_iter().collect()\n-    };\n-\n-    let num_tasks = from_str::<uint>(args[1].as_slice()).unwrap();\n-    let msg_per_task = from_str::<uint>(args[2].as_slice()).unwrap();\n-\n-    let (mut num_chan, num_port) = init();\n-\n-    let mut p = Some((num_chan, num_port));\n-    let dur = Duration::span(|| {\n-        let (mut num_chan, num_port) = p.take().unwrap();\n-\n-        // create the ring\n-        let mut futures = Vec::new();\n-\n-        for i in range(1u, num_tasks) {\n-            //println!(\"spawning %?\", i);\n-            let (new_chan, num_port) = init();\n-            let num_chan_2 = num_chan.clone();\n-            let new_future = Future::spawn(proc() {\n-                thread_ring(i, msg_per_task, num_chan_2, num_port)\n-            });\n-            futures.push(new_future);\n-            num_chan = new_chan;\n-        };\n-\n-        // do our iteration\n-        thread_ring(0, msg_per_task, num_chan, num_port);\n-\n-        // synchronize\n-        for f in futures.iter_mut() {\n-            let _ = f.get();\n-        }\n-    });\n-\n-    // all done, report stats.\n-    let num_msgs = num_tasks * msg_per_task;\n-    let rate = (num_msgs as f64) / (dur.num_milliseconds() as f64);\n-\n-    println!(\"Sent {} messages in {} ms\", num_msgs, dur.num_milliseconds());\n-    println!(\"  {} messages / second\", rate / 1000.0);\n-    println!(\"  {} \u03bcs / message\", 1000000. / rate / 1000.0);\n-}"}, {"sha": "8ed041513c47c45a2ef7006660ecba830c17832f", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -295,7 +295,7 @@ fn main() {\n         let fd = std::io::File::open(&Path::new(\"shootout-k-nucleotide.data\"));\n         get_sequence(&mut std::io::BufferedReader::new(fd), \">THREE\")\n     } else {\n-        get_sequence(&mut std::io::stdin(), \">THREE\")\n+        get_sequence(&mut *std::io::stdin().lock(), \">THREE\")\n     };\n     let input = Arc::new(input);\n "}, {"sha": "c55f85f40e8b628b180c101af342108698e8214c", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -65,7 +65,7 @@ impl Sudoku {\n         return true;\n     }\n \n-    pub fn read(mut reader: BufferedReader<StdReader>) -> Sudoku {\n+    pub fn read(mut reader: &mut BufferedReader<StdReader>) -> Sudoku {\n         /* assert first line is exactly \"9,9\" */\n         assert!(reader.read_line().unwrap() == \"9,9\".to_string());\n \n@@ -284,7 +284,7 @@ fn main() {\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&DEFAULT_SUDOKU)\n     } else {\n-        Sudoku::read(io::stdin())\n+        Sudoku::read(&mut *io::stdin().lock())\n     };\n     sudoku.solve();\n     sudoku.write(&mut io::stdout());"}, {"sha": "489f892726a3b4895ac8b03592dfb65a08b3b609", "filename": "src/test/compile-fail/better-expected.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: [int ..3]; //~ ERROR expected one of `(`, `+`, `,`, `::`, or `]`, found `..`\n+}"}, {"sha": "1d09143c24d1d42f83913e0697bad8f2714008d0", "filename": "src/test/compile-fail/borrow-tuple-fields.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fborrow-tuple-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fborrow-tuple-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrow-tuple-fields.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tuple_indexing)]\n-\n struct Foo(Box<int>, int);\n \n struct Bar(int, int);"}, {"sha": "daad1afedaaeae10308c5e52b1c4c24956d7c9d3", "filename": "src/test/compile-fail/cannot-mutate-captured-non-mut-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     //~^ ERROR: cannot assign to immutable captured outer variable in a proc `x`\n \n     let s = std::io::stdin();\n-    proc() { s.lines(); };\n+    proc() { s.read_to_end(); };\n     //~^ ERROR: cannot borrow immutable captured outer variable in a proc `s` as mutable\n }"}, {"sha": "621b480fe77d37b5fb2f35357c831a6ae43f26b3", "filename": "src/test/compile-fail/column-offset-1-based.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fcolumn-offset-1-based.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fcolumn-offset-1-based.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcolumn-offset-1-based.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-# //~ ERROR 11:1: 11:2 error: expected `[`, found `<eof>`\n+# //~ ERROR 11:1: 11:2 error: expected one of `!` or `[`, found `<eof>`"}, {"sha": "a598252f1b65e99c20e45a23594c19aa44283862", "filename": "src/test/compile-fail/empty-impl-semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fempty-impl-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fempty-impl-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-impl-semicolon.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-impl Foo; //~ ERROR expected `{`, found `;`\n+impl Foo; //~ ERROR expected one of `(`, `+`, `::`, or `{`, found `;`"}, {"sha": "88b6854bb1d2c3a59df2e43e03f082c2c0a99136", "filename": "src/test/compile-fail/if-let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fif-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fif-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-let.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules,if_let)]\n+#![feature(macro_rules)]\n \n fn macros() {\n     macro_rules! foo{"}, {"sha": "a8704f7545f06a25311c942ab2573e8d0f83fa58", "filename": "src/test/compile-fail/issue-1655.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-1655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-1655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1655.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:expected `[`, found `vec`\n+// error-pattern:expected one of `!` or `[`, found `vec`\n mod blade_runner {\n     #vec[doc(\n         brief = \"Blade Runner is probably the best movie ever\","}, {"sha": "f64d8fee2d8b3948ab742cf2782ee6ca0d3e7628", "filename": "src/test/compile-fail/issue-18566.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-18566.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-18566.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18566.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tuple_indexing)]\n-\n struct MyPtr<'a>(&'a mut uint);\n impl<'a> Deref<uint> for MyPtr<'a> {\n     fn deref<'b>(&'b self) -> &'b uint { self.0 }"}, {"sha": "6b67814aab33f930291a278e118bc392f894041f", "filename": "src/test/compile-fail/issue-19096.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-19096.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-19096.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19096.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let t = (42i, 42i);\n-    t.0::<int>; //~ ERROR expected one of `;`, `}`, found `::`\n+    t.0::<int>; //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `::`\n }"}, {"sha": "7ca83f21305f15842f9cb4a2e831fd3e4b35c946", "filename": "src/test/compile-fail/issue-19244-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tuple_indexing)]\n-\n const TUP: (uint,) = (42,);\n \n fn main() {"}, {"sha": "16834f491659bdedb7ce6a04c5bcbfa4f15c8411", "filename": "src/test/compile-fail/issue-3036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-3036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fissue-3036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3036.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -13,4 +13,4 @@\n fn main()\n {\n     let x = 3\n-} //~ ERROR: expected `;`, found `}`\n+} //~ ERROR: expected one of `.`, `;`, or an operator, found `}`"}, {"sha": "8d4ecde692d72358ead90e3ad5cf25d8cd18b38d", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -17,6 +17,9 @@\n //! Some garbage docs for the crate here\n #![doc=\"More garbage\"]\n \n+type Typedef = String;\n+pub type PubTypedef = String; //~ ERROR: missing documentation\n+\n struct Foo {\n     a: int,\n     b: int,"}, {"sha": "b71effa6f861be1f4d779668fe1c37b8ccc0cdb7", "filename": "src/test/compile-fail/lint-unnecessary-parens.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![deny(unused_parens)]\n-#![feature(if_let,while_let)]\n \n #[deriving(Eq, PartialEq)]\n struct X { y: bool }"}, {"sha": "3e073d34f3261914fa34010a811ea6fc420cc98a", "filename": "src/test/compile-fail/match-vec-invalid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmatch-vec-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmatch-vec-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-invalid.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let a = Vec::new();\n     match a {\n-        [1, tail.., tail..] => {}, //~ ERROR: expected `,`, found `..`\n+        [1, tail.., tail..] => {}, //~ ERROR: expected one of `!`, `,`, or `@`, found `..`\n         _ => ()\n     }\n }"}, {"sha": "e45862a7fc6e451d8fca5563e72420e785db3f29", "filename": "src/test/compile-fail/move-fragments-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tuple_indexing)]\n-\n // Test that we correctly compute the move fragments for a fn.\n //\n // Note that the code below is not actually incorrect; the"}, {"sha": "7fcb54e04672dd520165dd28a0f4294d8a93f0a0", "filename": "src/test/compile-fail/move-out-of-tuple-field.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmove-out-of-tuple-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmove-out-of-tuple-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-out-of-tuple-field.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tuple_indexing)]\n-\n struct Foo(Box<int>);\n \n fn main() {"}, {"sha": "7add747fbfa53055c01f98e9eb2c9c79c2a19d0e", "filename": "src/test/compile-fail/multitrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultitrait.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -12,7 +12,7 @@ struct S {\n  y: int\n }\n \n-impl Cmp, ToString for S { //~ ERROR: expected `{`, found `,`\n+impl Cmp, ToString for S { //~ ERROR: expected one of `(`, `+`, `::`, or `{`, found `,`\n   fn eq(&&other: S) { false }\n   fn to_string(&self) -> String { \"hi\".to_string() }\n }"}, {"sha": "a78e82bb73ca457d3c623afe0c32f1f631be29cd", "filename": "src/test/compile-fail/mut-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmut-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fmut-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-patterns.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -12,5 +12,5 @@\n \n pub fn main() {\n     struct Foo { x: int }\n-    let mut Foo { x: x } = Foo { x: 3 }; //~ ERROR: expected `;`, found `{`\n+    let mut Foo { x: x } = Foo { x: 3 }; //~ ERROR: expected one of `:`, `;`, `=`, or `@`, found `{`\n }"}, {"sha": "f2422830a21cc6251329a452af6e8aa611df6fc3", "filename": "src/test/compile-fail/new-unicode-escapes-1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-1.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let s = \"\\u{2603\"; //~ ERROR unterminated unicode escape (needed a `}`)\n+}"}, {"sha": "5da8674c37ea556ce17e7214cf3f872a50238953", "filename": "src/test/compile-fail/new-unicode-escapes-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-2.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let s = \"\\u{260311111111}\"; //~ ERROR overlong unicode escape (can have at most 6 hex digits)\n+}"}, {"sha": "7c64d02efd7465f803b408c76ef655989086a537", "filename": "src/test/compile-fail/new-unicode-escapes-3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-3.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let s = \"\\u{d805}\"; //~ ERROR illegal unicode character escape\n+}"}, {"sha": "ffc2b11e0c13caba1ff7f9e639349528f706ff23", "filename": "src/test/compile-fail/new-unicode-escapes-4.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnew-unicode-escapes-4.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let s = \"\\u{lol}\"; //~ ERROR illegal character in unicode escape\n+}"}, {"sha": "729b45df8b430823377fed370fd455d23c6def1e", "filename": "src/test/compile-fail/omitted-arg-in-item-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fomitted-arg-in-item-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fomitted-arg-in-item-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fomitted-arg-in-item-fn.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(x) { //~ ERROR expected `:`, found `)`\n+fn foo(x) { //~ ERROR expected one of `!`, `:`, or `@`, found `)`\n }"}, {"sha": "7fe073a4c3d69360475d619033946fd58df3e71d", "filename": "src/test/compile-fail/pat-range-bad-dots.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fpat-range-bad-dots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fpat-range-bad-dots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-range-bad-dots.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     match 22i {\n-        0 .. 3 => {} //~ ERROR expected `=>`, found `..`\n+        0 .. 3 => {} //~ ERROR expected one of `...`, `=>`, or `|`, found `..`\n         _ => {}\n     }\n }"}, {"sha": "3403b28fdc9c065b47eba8600cba5fd6d83c50b6", "filename": "src/test/compile-fail/raw-str-unbalanced.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fraw-str-unbalanced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fraw-str-unbalanced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fraw-str-unbalanced.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -10,5 +10,5 @@\n \n static s: &'static str =\n     r#\"\n-      \"## //~ ERROR expected `;`, found `#`\n+      \"## //~ ERROR expected one of `.`, `;`, or an operator, found `#`\n ;"}, {"sha": "a07832d5bb7614e3e5de56a819a2b297dac55989", "filename": "src/test/compile-fail/removed-syntax-closure-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-closure-lifetime.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type closure = Box<lt/fn()>; //~ ERROR expected `,`, found `/`\n+type closure = Box<lt/fn()>; //~ ERROR expected one of `(`, `+`, `,`, `::`, or `>`, found `/`"}, {"sha": "ba1b5a616df9da414c04b5c011d2914d53bb9952", "filename": "src/test/compile-fail/removed-syntax-enum-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-enum-newtype.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum e = int; //~ ERROR expected `{`, found `=`\n+enum e = int; //~ ERROR expected one of `<` or `{`, found `=`"}, {"sha": "fe49d1f4a8d853187911b8ba6d1eddf409dc32c2", "filename": "src/test/compile-fail/removed-syntax-fixed-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type v = [int * 3]; //~ ERROR expected `]`, found `*`\n+type v = [int * 3]; //~ ERROR expected one of `(`, `+`, `,`, `::`, or `]`, found `*`"}, {"sha": "1474cc9dd396d268f6321bb4fb6b6355939d20e0", "filename": "src/test/compile-fail/removed-syntax-larrow-init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-init.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -11,5 +11,5 @@\n fn removed_moves() {\n     let mut x = 0;\n     let y <- x;\n-    //~^ ERROR expected `;`, found `<-`\n+    //~^ ERROR expected one of `!`, `:`, `;`, `=`, or `@`, found `<-`\n }"}, {"sha": "552c9f2efa2de0366e6e1e957c340d079e58b06c", "filename": "src/test/compile-fail/removed-syntax-larrow-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-larrow-move.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -12,5 +12,5 @@ fn removed_moves() {\n     let mut x = 0;\n     let y = 0;\n     y <- x;\n-    //~^ ERROR expected one of `;`, `}`, found `<-`\n+    //~^ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `<-`\n }"}, {"sha": "437f871f8eabdde0023ed63f61522e76aa6fc7c7", "filename": "src/test/compile-fail/removed-syntax-mut-vec-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -11,5 +11,5 @@\n fn f() {\n     let v = [mut 1, 2, 3, 4];\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected `]`, found `1`\n+    //~^^ ERROR expected one of `!`, `,`, `.`, `::`, `]`, `{`, or an operator, found `1`\n }"}, {"sha": "af469fadf986d34b828006a85a17b90a73837b46", "filename": "src/test/compile-fail/removed-syntax-mut-vec-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -10,4 +10,4 @@\n \n type v = [mut int];\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected `]`, found `int`\n+    //~^^ ERROR expected one of `(`, `+`, `,`, `::`, or `]`, found `int`"}, {"sha": "1a1c4c9b40a159bcb15ae051e688602d9b2e9f5c", "filename": "src/test/compile-fail/removed-syntax-ptr-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-ptr-lifetime.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type bptr = &lifetime/int; //~ ERROR expected `;`, found `/`\n+type bptr = &lifetime/int; //~ ERROR expected one of `(`, `+`, `::`, or `;`, found `/`"}, {"sha": "ae5a68575f72f1bec9c5693a6e6270003360dcd1", "filename": "src/test/compile-fail/removed-syntax-record.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-record.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type t = { f: () }; //~ ERROR expected type, found token OpenDelim(Brace)\n+type t = { f: () }; //~ ERROR expected type, found `{`"}, {"sha": "c5559c4ea9621f5aac6e93e4c9d5c326291fa680", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -11,5 +11,5 @@\n fn f() {\n     let a_box = box mut 42;\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected `;`, found `42`\n+    //~^^ ERROR expected one of `!`, `.`, `::`, `;`, `{`, or an operator, found `42`\n }"}, {"sha": "8c3db89bad236a14ca2f39896ff9c993684a2fab", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -10,4 +10,4 @@\n \n type mut_box = Box<mut int>;\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected `,`, found `int`\n+    //~^^ ERROR expected one of `(`, `+`, `,`, `::`, or `>`, found `int`"}, {"sha": "c7f31045cb6a2a60ae4d843c8260b51579d94a72", "filename": "src/test/compile-fail/removed-syntax-with-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-with-1.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -16,5 +16,5 @@ fn removed_with() {\n \n     let a = S { foo: (), bar: () };\n     let b = S { foo: () with a };\n-    //~^ ERROR expected one of `,`, `}`, found `with`\n+    //~^ ERROR expected one of `,`, `.`, `}`, or an operator, found `with`\n }"}, {"sha": "a37197b889de80dec1437bae8d69a307bcd075f0", "filename": "src/test/compile-fail/struct-literal-in-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-for.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -20,7 +20,7 @@ impl Foo {\n \n fn main() {\n     for x in Foo {\n-        x: 3    //~ ERROR expected one of `;`, `}`\n+        x: 3    //~ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `:`\n     }.hi() {\n         println!(\"yo\");\n     }"}, {"sha": "9759e4f7bdaa991745a61f4d5a7e06344a2e4238", "filename": "src/test/compile-fail/struct-literal-in-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-if.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -20,7 +20,7 @@ impl Foo {\n \n fn main() {\n     if Foo {\n-        x: 3    //~ ERROR expected one of `;`, `}`\n+        x: 3    //~ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `:`\n     }.hi() {\n         println!(\"yo\");\n     }"}, {"sha": "297d3f7347f48bdd5779fe19cf1066a59b9485ca", "filename": "src/test/compile-fail/struct-literal-in-match-discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-match-discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-match-discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-match-discriminant.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -14,7 +14,7 @@ struct Foo {\n \n fn main() {\n     match Foo {\n-        x: 3    //~ ERROR expected `=>`\n+        x: 3    //~ ERROR expected one of `!`, `=>`, `@`, or `|`, found `:`\n     } {\n         Foo {\n             x: x"}, {"sha": "5b1679cf9a142c4272b3c61a9cf7acca5d03fc3d", "filename": "src/test/compile-fail/struct-literal-in-while.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-literal-in-while.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -20,7 +20,7 @@ impl Foo {\n \n fn main() {\n     while Foo {\n-        x: 3    //~ ERROR expected one of `;`, `}`\n+        x: 3    //~ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `:`\n     }.hi() {\n         println!(\"yo\");\n     }"}, {"sha": "dadd6571583844fda90af29b30c29c13c04444bf", "filename": "src/test/compile-fail/trailing-comma-array-repeat.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Ftrailing-comma-array-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Ftrailing-comma-array-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrailing-comma-array-repeat.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern {\n-    const FOO: uint; //~ ERROR: unexpected token: `const`\n+fn main() {\n+    let [_, ..,] = [(), ()]; //~ ERROR unexpected token: `]`\n }\n-\n-fn main() {}", "previous_filename": "src/test/compile-fail/issue-17718-extern-const.rs"}, {"sha": "33aeebb36916679b6e03f784a1209aaa378734d8", "filename": "src/test/compile-fail/tuple-index-not-tuple.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Ftuple-index-not-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Ftuple-index-not-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-index-not-tuple.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tuple_indexing)]\n-\n struct Point { x: int, y: int }\n struct Empty;\n "}, {"sha": "609e34f2274b763e034b22e47c04653f0209b726", "filename": "src/test/compile-fail/tuple-index-out-of-bounds.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Ftuple-index-out-of-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Ftuple-index-out-of-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-index-out-of-bounds.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tuple_indexing)]\n-\n struct Point(int, int);\n \n fn main() {"}, {"sha": "ccf3d2dd75076ab781cb5dbaf61293fc27300856", "filename": "src/test/compile-fail/while-let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fcompile-fail%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-let.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules,while_let)]\n+#![feature(macro_rules)]\n \n fn macros() {\n     macro_rules! foo{"}, {"sha": "76cf3c1149dd552e8665965cabeb1d2b0e3f921b", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -58,11 +58,17 @@\n // gdb-command: print none\n // gdb-check:$12 = None\n \n+// gdb-command: print some_fat\n+// gdb-check:$13 = Some = {\"abc\"}\n+\n+// gdb-command: print none_fat\n+// gdb-check:$14 = None\n+\n // gdb-command: print nested_variant1\n-// gdb-check:$13 = NestedVariant1 = {NestedStruct = {regular_struct = RegularStruct = {the_first_field = 111, the_second_field = 112.5, the_third_field = true, the_fourth_field = \"NestedStructString1\"}, tuple_struct = TupleStruct = {113.5, 114}, empty_struct = EmptyStruct, c_style_enum = CStyleEnumVar2, mixed_enum = MixedEnumTupleVar = {115, 116, false}}}\n+// gdb-check:$15 = NestedVariant1 = {NestedStruct = {regular_struct = RegularStruct = {the_first_field = 111, the_second_field = 112.5, the_third_field = true, the_fourth_field = \"NestedStructString1\"}, tuple_struct = TupleStruct = {113.5, 114}, empty_struct = EmptyStruct, c_style_enum = CStyleEnumVar2, mixed_enum = MixedEnumTupleVar = {115, 116, false}}}\n \n // gdb-command: print nested_variant2\n-// gdb-check:$14 = NestedVariant2 = {abc = NestedStruct = {regular_struct = RegularStruct = {the_first_field = 117, the_second_field = 118.5, the_third_field = false, the_fourth_field = \"NestedStructString10\"}, tuple_struct = TupleStruct = {119.5, 120}, empty_struct = EmptyStruct, c_style_enum = CStyleEnumVar3, mixed_enum = MixedEnumStructVar = {field1 = 121.5, field2 = -122}}}\n+// gdb-check:$16 = NestedVariant2 = {abc = NestedStruct = {regular_struct = RegularStruct = {the_first_field = 117, the_second_field = 118.5, the_third_field = false, the_fourth_field = \"NestedStructString10\"}, tuple_struct = TupleStruct = {119.5, 120}, empty_struct = EmptyStruct, c_style_enum = CStyleEnumVar3, mixed_enum = MixedEnumStructVar = {field1 = 121.5, field2 = -122}}}\n \n use self::CStyleEnum::{CStyleEnumVar1, CStyleEnumVar2, CStyleEnumVar3};\n use self::MixedEnum::{MixedEnumCStyleVar, MixedEnumTupleVar, MixedEnumStructVar};\n@@ -129,6 +135,8 @@ fn main() {\n \n     let some = Some(110u);\n     let none: Option<int> = None;\n+    let some_fat = Some(\"abc\");\n+    let none_fat: Option<&'static str> = None;\n \n     let nested_variant1 = NestedVariant1(\n         NestedStruct {"}, {"sha": "333a430e3511130c47567d22939ec712869f2aa4", "filename": "src/test/debuginfo/option-like-enum.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -61,6 +61,12 @@\n // lldb-command:print void_droid\n // lldb-check:[...]$5 = Void\n \n+// lldb-command:print some_str\n+// lldb-check:[...]$6 = Some(&str { data_ptr: [...], length: 3 })\n+\n+// lldb-command:print none_str\n+// lldb-check:[...]$7 = None\n+\n \n // If a struct has exactly two variants, one of them is empty, and the other one\n // contains a non-nullable pointer, then this value is used as the discriminator.\n@@ -96,6 +102,9 @@ struct NamedFieldsRepr<'a> {\n \n fn main() {\n \n+    let some_str: Option<&'static str> = Some(\"abc\");\n+    let none_str: Option<&'static str> = None;\n+\n     let some: Option<&u32> = Some(unsafe { std::mem::transmute(0x12345678u) });\n     let none: Option<&u32> = None;\n "}, {"sha": "11003c6fc524de50a71f2e39331bef3168328261", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -37,7 +37,7 @@ fn parent() {\n }\n \n fn child() {\n-    for line in io::stdin().lines() {\n+    for line in io::stdin().lock().lines() {\n         println!(\"{}\", line.unwrap());\n     }\n }"}, {"sha": "f5fdf8704ed25ca888d624599e6379802c4228f6", "filename": "src/test/run-pass/issue-14456.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14456.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -27,7 +27,7 @@ fn main() {\n fn child() {\n     io::stdout().write_line(\"foo\").unwrap();\n     io::stderr().write_line(\"bar\").unwrap();\n-    assert_eq!(io::stdin().read_line().err().unwrap().kind, io::EndOfFile);\n+    assert_eq!(io::stdin().lock().read_line().err().unwrap().kind, io::EndOfFile);\n }\n \n fn test() {"}, {"sha": "27a97e1f172e36bd561713266b997edb5e4733dc", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -19,6 +19,6 @@\n pub fn main() {\n     let mut stdin = std::io::stdin();\n     spawn(proc() {\n-        let _ = stdin.lines();\n+        let _ = stdin.read_to_end();\n     });\n }"}, {"sha": "2888389bcceabfb4cce2b5f03b500e0f6baecf95", "filename": "src/test/run-pass/new-unicode-escapes.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fnew-unicode-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fnew-unicode-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-unicode-escapes.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let s = \"\\u{2603}\";\n+    assert_eq!(s, \"\u2603\");\n+\n+    let s = \"\\u{2a10}\\u{2A01}\\u{2Aa0}\";\n+    assert_eq!(s, \"\u2a10\u2a01\u2aa0\");\n+\n+    let s = \"\\\\{20}\";\n+    let mut correct_s = String::from_str(\"\\\\\");\n+    correct_s.push_str(\"{20}\");\n+    assert_eq!(s, correct_s.as_slice());\n+}"}, {"sha": "00e050640805b318ed06dbf68a248fa20d66a8fa", "filename": "src/test/run-pass/trailing-comma.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Ftrailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Ftrailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrailing-comma.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(advanced_slice_patterns,)]\n+\n fn f<T,>(_: T,) {}\n \n struct Foo<T,>;\n@@ -24,9 +26,13 @@ enum Baz {\n     Qux(int,),\n }\n \n+#[allow(unused,)]\n pub fn main() {\n     f::<int,>(0i,);\n     let (_, _,) = (1i, 1i,);\n+    let [_, _,] = [1i, 1,];\n+    let [_, _, .., _,] = [1i, 1, 1, 1,];\n+    let [_, _, _.., _,] = [1i, 1, 1, 1,];\n \n     let x: Foo<int,> = Foo::<int,>;\n "}, {"sha": "17dfb9e331945ef0c93009334c9f5f73dbc46e93", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f4c11be3b9706d1ba0e1b74b89de1478410a56f/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=6f4c11be3b9706d1ba0e1b74b89de1478410a56f", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+extern crate libc;\n+\n+use std::io::process::Command;\n+use std::iter::IteratorExt;\n+\n+use libc::funcs::posix88::unistd;\n+\n+\n+// \"ps -A -o pid,sid,command\" with GNU ps should output something like this:\n+//   PID   SID COMMAND\n+//     1     1 /sbin/init\n+//     2     0 [kthreadd]\n+//     3     0 [ksoftirqd/0]\n+// ...\n+// 12562  9237 ./spawn-failure\n+// 12563  9237 [spawn-failure] <defunct>\n+// 12564  9237 [spawn-failure] <defunct>\n+// ...\n+// 12592  9237 [spawn-failure] <defunct>\n+// 12593  9237 ps -A -o pid,sid,command\n+// 12884 12884 /bin/zsh\n+// 12922 12922 /bin/zsh\n+// ...\n+\n+#[cfg(unix)]\n+fn find_zombies() {\n+    // http://man.freebsd.org/ps(1)\n+    // http://man7.org/linux/man-pages/man1/ps.1.html\n+    #[cfg(not(target_os = \"macos\"))]\n+    const FIELDS: &'static str = \"pid,sid,command\";\n+\n+    // https://developer.apple.com/library/mac/documentation/Darwin/\n+    // Reference/ManPages/man1/ps.1.html\n+    #[cfg(target_os = \"macos\")]\n+    const FIELDS: &'static str = \"pid,sess,command\";\n+\n+    let my_sid = unsafe { unistd::getsid(0) };\n+\n+    let ps_cmd_output = Command::new(\"ps\").args(&[\"-A\", \"-o\", FIELDS]).output().unwrap();\n+    let ps_output = String::from_utf8_lossy(ps_cmd_output.output.as_slice());\n+\n+    let found = ps_output.split('\\n').enumerate().any(|(line_no, line)|\n+        0 < line_no && 0 < line.len() &&\n+        my_sid == from_str(line.split(' ').filter(|w| 0 < w.len()).nth(1)\n+            .expect(\"1st column should be Session ID\")\n+            ).expect(\"Session ID string into integer\") &&\n+        line.contains(\"defunct\") && {\n+            println!(\"Zombie child {}\", line);\n+            true\n+        }\n+    );\n+\n+    assert!( ! found, \"Found at least one zombie child\");\n+}\n+\n+#[cfg(windows)]\n+fn find_zombies() { }\n+\n+fn main() {\n+    let too_long = format!(\"/NoSuchCommand{:0300}\", 0u8);\n+\n+    for _ in range(0u32, 100) {\n+        let invalid = Command::new(too_long.as_slice()).spawn();\n+        assert!(invalid.is_err());\n+    }\n+\n+    find_zombies();\n+}"}]}