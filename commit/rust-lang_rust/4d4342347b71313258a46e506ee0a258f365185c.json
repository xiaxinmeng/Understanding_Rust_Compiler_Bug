{"sha": "4d4342347b71313258a46e506ee0a258f365185c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNDM0MjM0N2I3MTMxMzI1OGE0NmU1MDZlZTBhMjU4ZjM2NTE4NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-07T15:28:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-07T15:28:07Z"}, "message": "Auto merge of #74821 - oli-obk:const_eval_read_uninit_fast_path, r=wesleywiser\n\nCheck whether locals are too large instead of whether accesses into them are too large\n\nEssentially this stops const prop from attempting to optimize\n\n```rust\nlet mut x = [0_u8; 5000];\nx[42] = 3;\n```\n\nI don't expect this to be a perf improvement without #73656 (which is also where the lack of this PR will be a perf regression).\n\nr? @wesleywiser", "tree": {"sha": "0212ce1a45182b9047ddb73e9c83e0758af7fcd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0212ce1a45182b9047ddb73e9c83e0758af7fcd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d4342347b71313258a46e506ee0a258f365185c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d4342347b71313258a46e506ee0a258f365185c", "html_url": "https://github.com/rust-lang/rust/commit/4d4342347b71313258a46e506ee0a258f365185c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d4342347b71313258a46e506ee0a258f365185c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64f99b4cfbf01c8fda1d4fe16e9b37b11096b7c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/64f99b4cfbf01c8fda1d4fe16e9b37b11096b7c3", "html_url": "https://github.com/rust-lang/rust/commit/64f99b4cfbf01c8fda1d4fe16e9b37b11096b7c3"}, {"sha": "1864a973b3a0a5a6c5a7c71d7d7cd052732e5c02", "url": "https://api.github.com/repos/rust-lang/rust/commits/1864a973b3a0a5a6c5a7c71d7d7cd052732e5c02", "html_url": "https://github.com/rust-lang/rust/commit/1864a973b3a0a5a6c5a7c71d7d7cd052732e5c02"}], "stats": {"total": 356, "additions": 266, "deletions": 90}, "files": [{"sha": "db0b0415728aec2d699d617e22e092d6bf6b245d", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 70, "deletions": 60, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4d4342347b71313258a46e506ee0a258f365185c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4342347b71313258a46e506ee0a258f365185c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=4d4342347b71313258a46e506ee0a258f365185c", "patch": "@@ -34,7 +34,9 @@ use crate::interpret::{\n };\n use crate::transform::{MirPass, MirSource};\n \n-/// The maximum number of bytes that we'll allocate space for a return value.\n+/// The maximum number of bytes that we'll allocate space for a local or the return value.\n+/// Needed for #66397, because otherwise we eval into large places and that can cause OOM or just\n+/// Severely regress performance.\n const MAX_ALLOC_LIMIT: u64 = 1024;\n \n /// Macro for machine-specific `InterpError` without allocation.\n@@ -155,14 +157,19 @@ struct ConstPropMachine<'mir, 'tcx> {\n     written_only_inside_own_block_locals: FxHashSet<Local>,\n     /// Locals that need to be cleared after every block terminates.\n     only_propagate_inside_block_locals: BitSet<Local>,\n+    can_const_prop: IndexVec<Local, ConstPropMode>,\n }\n \n impl<'mir, 'tcx> ConstPropMachine<'mir, 'tcx> {\n-    fn new(only_propagate_inside_block_locals: BitSet<Local>) -> Self {\n+    fn new(\n+        only_propagate_inside_block_locals: BitSet<Local>,\n+        can_const_prop: IndexVec<Local, ConstPropMode>,\n+    ) -> Self {\n         Self {\n             stack: Vec::new(),\n             written_only_inside_own_block_locals: Default::default(),\n             only_propagate_inside_block_locals,\n+            can_const_prop,\n         }\n     }\n }\n@@ -241,6 +248,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         local: Local,\n     ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n     {\n+        if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n+            throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n+        }\n         if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n             ecx.machine.written_only_inside_own_block_locals.insert(local);\n         }\n@@ -285,7 +295,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n     param_env: ParamEnv<'tcx>,\n     // FIXME(eddyb) avoid cloning these two fields more than once,\n     // by accessing them through `ecx` instead.\n@@ -331,7 +340,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n         let span = tcx.def_span(def_id);\n-        let can_const_prop = CanConstProp::check(body);\n+        // FIXME: `CanConstProp::check` computes the layout of all locals, return those layouts\n+        // so we can write them to `ecx.frame_mut().locals.layout, reducing the duplication in\n+        // `layout_of` query invocations.\n+        let can_const_prop = CanConstProp::check(tcx, param_env, body);\n         let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n         for (l, mode) in can_const_prop.iter_enumerated() {\n             if *mode == ConstPropMode::OnlyInsideOwnBlock {\n@@ -342,7 +354,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             tcx,\n             span,\n             param_env,\n-            ConstPropMachine::new(only_propagate_inside_block_locals),\n+            ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n             (),\n         );\n \n@@ -368,7 +380,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             ecx,\n             tcx,\n             param_env,\n-            can_const_prop,\n             // FIXME(eddyb) avoid cloning these two fields more than once,\n             // by accessing them through `ecx` instead.\n             source_scopes: body.source_scopes.clone(),\n@@ -612,15 +623,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn const_prop(\n         &mut self,\n         rvalue: &Rvalue<'tcx>,\n-        place_layout: TyAndLayout<'tcx>,\n         source_info: SourceInfo,\n         place: Place<'tcx>,\n     ) -> Option<()> {\n-        // #66397: Don't try to eval into large places as that can cause an OOM\n-        if place_layout.size >= Size::from_bytes(MAX_ALLOC_LIMIT) {\n-            return None;\n-        }\n-\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -893,7 +898,11 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// Returns true if `local` can be propagated\n-    fn check(body: &Body<'_>) -> IndexVec<Local, ConstPropMode> {\n+    fn check(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        body: &Body<'tcx>,\n+    ) -> IndexVec<Local, ConstPropMode> {\n         let mut cpv = CanConstProp {\n             can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n             found_assignment: BitSet::new_empty(body.local_decls.len()),\n@@ -903,6 +912,16 @@ impl CanConstProp {\n             ),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n+            let ty = body.local_decls[local].ty;\n+            match tcx.layout_of(param_env.and(ty)) {\n+                Ok(layout) if layout.size < Size::from_bytes(MAX_ALLOC_LIMIT) => {}\n+                // Either the layout fails to compute, then we can't use this local anyway\n+                // or the local is too large, then we don't want to.\n+                _ => {\n+                    *val = ConstPropMode::NoPropagation;\n+                    continue;\n+                }\n+            }\n             // Cannot use args at all\n             // Cannot use locals because if x < y { y - x } else { x - y } would\n             //        lint for x != y\n@@ -1018,61 +1037,52 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n-            let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n-            if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n-                let can_const_prop = self.can_const_prop[place.local];\n-                if let Some(()) = self.const_prop(rval, place_layout, source_info, place) {\n-                    // This will return None if the above `const_prop` invocation only \"wrote\" a\n-                    // type whose creation requires no write. E.g. a generator whose initial state\n-                    // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                    if let Some(value) = self.get_const(place) {\n-                        if self.should_const_prop(value) {\n-                            trace!(\"replacing {:?} with {:?}\", rval, value);\n-                            self.replace_with_const(rval, value, source_info);\n-                            if can_const_prop == ConstPropMode::FullConstProp\n-                                || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                            {\n-                                trace!(\"propagated into {:?}\", place);\n-                            }\n+            let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n+            if let Some(()) = self.const_prop(rval, source_info, place) {\n+                // This will return None if the above `const_prop` invocation only \"wrote\" a\n+                // type whose creation requires no write. E.g. a generator whose initial state\n+                // consists solely of uninitialized memory (so it doesn't capture any locals).\n+                if let Some(value) = self.get_const(place) {\n+                    if self.should_const_prop(value) {\n+                        trace!(\"replacing {:?} with {:?}\", rval, value);\n+                        self.replace_with_const(rval, value, source_info);\n+                        if can_const_prop == ConstPropMode::FullConstProp\n+                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n+                        {\n+                            trace!(\"propagated into {:?}\", place);\n                         }\n                     }\n-                    match can_const_prop {\n-                        ConstPropMode::OnlyInsideOwnBlock => {\n-                            trace!(\n-                                \"found local restricted to its block. \\\n+                }\n+                match can_const_prop {\n+                    ConstPropMode::OnlyInsideOwnBlock => {\n+                        trace!(\n+                            \"found local restricted to its block. \\\n                                 Will remove it from const-prop after block is finished. Local: {:?}\",\n-                                place.local\n-                            );\n-                        }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            trace!(\"can't propagate into {:?}\", place);\n-                            if place.local != RETURN_PLACE {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n+                            place.local\n+                        );\n+                    }\n+                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                        trace!(\"can't propagate into {:?}\", place);\n+                        if place.local != RETURN_PLACE {\n+                            Self::remove_const(&mut self.ecx, place.local);\n                         }\n-                        ConstPropMode::FullConstProp => {}\n                     }\n-                } else {\n-                    // Const prop failed, so erase the destination, ensuring that whatever happens\n-                    // from here on, does not know about the previous value.\n-                    // This is important in case we have\n-                    // ```rust\n-                    // let mut x = 42;\n-                    // x = SOME_MUTABLE_STATIC;\n-                    // // x must now be undefined\n-                    // ```\n-                    // FIXME: we overzealously erase the entire local, because that's easier to\n-                    // implement.\n-                    trace!(\n-                        \"propagation into {:?} failed.\n-                        Nuking the entire site from orbit, it's the only way to be sure\",\n-                        place,\n-                    );\n-                    Self::remove_const(&mut self.ecx, place.local);\n+                    ConstPropMode::FullConstProp => {}\n                 }\n             } else {\n+                // Const prop failed, so erase the destination, ensuring that whatever happens\n+                // from here on, does not know about the previous value.\n+                // This is important in case we have\n+                // ```rust\n+                // let mut x = 42;\n+                // x = SOME_MUTABLE_STATIC;\n+                // // x must now be undefined\n+                // ```\n+                // FIXME: we overzealously erase the entire local, because that's easier to\n+                // implement.\n                 trace!(\n-                    \"cannot propagate into {:?}, because the type of the local is generic.\",\n+                    \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n                     place,\n                 );\n                 Self::remove_const(&mut self.ecx, place.local);"}, {"sha": "721766f9849710050ef7685f85478765cf600ea9", "filename": "src/test/mir-opt/const_prop/large_array_index.main.ConstProp.diff.32bit", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.32bit", "raw_url": "https://github.com/rust-lang/rust/raw/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.32bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.32bit?ref=4d4342347b71313258a46e506ee0a258f365185c", "patch": "@@ -0,0 +1,85 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/large_array_index.rs:4:11: 4:11\n+      let _1: u8;                          // in scope 0 at $DIR/large_array_index.rs:6:9: 6:10\n+      let mut _2: [u8; 5000];              // in scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+      let _3: usize;                       // in scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+      let mut _4: usize;                   // in scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+      let mut _5: bool;                    // in scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/large_array_index.rs:6:9: 6:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/large_array_index.rs:6:9: 6:10\n+          StorageLive(_2);                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+          _2 = [const 0_u8; 5000];         // scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+                                           // ty::Const\n+                                           // + ty: u8\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:18: 6:22\n+                                           // + literal: Const { ty: u8, val: Value(Scalar(0x00)) }\n+          StorageLive(_3);                 // scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+          _3 = const 2_usize;              // scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x00000002))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:30: 6:31\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x00000002)) }\n+          _4 = const 5000_usize;           // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x00001388))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:17: 6:32\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x00001388)) }\n+-         _5 = Lt(_3, _4);                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+-         assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> bb1; // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++         _5 = const true;                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n++         assert(const true, \"index out of bounds: the len is {} but the index is {}\", const 5000_usize, const 2_usize) -> bb1; // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x00001388))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00001388)) }\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x00000002))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000002)) }\n+      }\n+  \n+      bb1: {\n+          _1 = _2[_3];                     // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+          StorageDead(_3);                 // scope 0 at $DIR/large_array_index.rs:6:32: 6:33\n+          StorageDead(_2);                 // scope 0 at $DIR/large_array_index.rs:6:32: 6:33\n+          _0 = const ();                   // scope 0 at $DIR/large_array_index.rs:4:11: 7:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:4:11: 7:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_1);                 // scope 0 at $DIR/large_array_index.rs:7:1: 7:2\n+          return;                          // scope 0 at $DIR/large_array_index.rs:7:2: 7:2\n+      }\n+  }\n+  "}, {"sha": "eae2ce6671cc15b5ee7283ac1e32686ffdd1e2cf", "filename": "src/test/mir-opt/const_prop/large_array_index.main.ConstProp.diff.64bit", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.64bit", "raw_url": "https://github.com/rust-lang/rust/raw/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.64bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.64bit?ref=4d4342347b71313258a46e506ee0a258f365185c", "patch": "@@ -0,0 +1,85 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/large_array_index.rs:4:11: 4:11\n+      let _1: u8;                          // in scope 0 at $DIR/large_array_index.rs:6:9: 6:10\n+      let mut _2: [u8; 5000];              // in scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+      let _3: usize;                       // in scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+      let mut _4: usize;                   // in scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+      let mut _5: bool;                    // in scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/large_array_index.rs:6:9: 6:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/large_array_index.rs:6:9: 6:10\n+          StorageLive(_2);                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+          _2 = [const 0_u8; 5000];         // scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+                                           // ty::Const\n+                                           // + ty: u8\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:18: 6:22\n+                                           // + literal: Const { ty: u8, val: Value(Scalar(0x00)) }\n+          StorageLive(_3);                 // scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+          _3 = const 2_usize;              // scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x0000000000000002))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:30: 6:31\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000002)) }\n+          _4 = const 5000_usize;           // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x0000000000001388))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:17: 6:32\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000001388)) }\n+-         _5 = Lt(_3, _4);                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+-         assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> bb1; // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++         _5 = const true;                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n++         assert(const true, \"index out of bounds: the len is {} but the index is {}\", const 5000_usize, const 2_usize) -> bb1; // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x0000000000001388))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000001388)) }\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x0000000000000002))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000002)) }\n+      }\n+  \n+      bb1: {\n+          _1 = _2[_3];                     // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+          StorageDead(_3);                 // scope 0 at $DIR/large_array_index.rs:6:32: 6:33\n+          StorageDead(_2);                 // scope 0 at $DIR/large_array_index.rs:6:32: 6:33\n+          _0 = const ();                   // scope 0 at $DIR/large_array_index.rs:4:11: 7:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:4:11: 7:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_1);                 // scope 0 at $DIR/large_array_index.rs:7:1: 7:2\n+          return;                          // scope 0 at $DIR/large_array_index.rs:7:2: 7:2\n+      }\n+  }\n+  "}, {"sha": "48d134376db62653edb63f3d55a29b59bb7657ca", "filename": "src/test/mir-opt/const_prop/large_array_index.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.rs?ref=4d4342347b71313258a46e506ee0a258f365185c", "patch": "@@ -0,0 +1,7 @@\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+\n+// EMIT_MIR large_array_index.main.ConstProp.diff\n+fn main() {\n+    // check that we don't propagate this, because it's too large\n+    let x: u8 = [0_u8; 5000][2];\n+}"}, {"sha": "6e2ee0957ab332bd88a5f7f7b270221067eacab8", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate_mut_ref.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.main.ConstProp.diff?ref=4d4342347b71313258a46e506ee0a258f365185c", "patch": "@@ -23,15 +23,13 @@\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000002a))\n                                            // mir::Constant\n--                                          // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:18: 5:20\n-+                                          // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:17: 5:25\n+                                           // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:18: 5:20\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000002b))\n                                            // mir::Constant\n--                                          // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:22: 5:24\n-+                                          // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:17: 5:25\n+                                           // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:22: 5:24\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000002b)) }\n           StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:6:9: 6:10\n           _2 = &mut _1;                    // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:6:13: 6:19"}, {"sha": "7f197a238e5a0f2466d9c857d23bd06154350ddf", "filename": "src/test/ui/recursion/issue-26548-recursion-via-normalize.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr?ref=4d4342347b71313258a46e506ee0a258f365185c", "patch": "@@ -1,7 +1,7 @@\n-error[E0391]: cycle detected when computing layout of `std::option::Option<S>`\n+error[E0391]: cycle detected when computing layout of `S`\n    |\n-   = note: ...which requires computing layout of `S`...\n-   = note: ...which again requires computing layout of `std::option::Option<S>`, completing the cycle\n+   = note: ...which requires computing layout of `std::option::Option<S>`...\n+   = note: ...which again requires computing layout of `S`, completing the cycle\n note: cycle used when optimizing MIR for `main`\n   --> $DIR/issue-26548-recursion-via-normalize.rs:15:1\n    |"}, {"sha": "2b3f9be2dfb9b030da728450f37fc3fac103268d", "filename": "src/tools/clippy/tests/ui/indexing_slicing_index.stderr", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Findexing_slicing_index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Findexing_slicing_index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Findexing_slicing_index.stderr?ref=4d4342347b71313258a46e506ee0a258f365185c", "patch": "@@ -1,23 +1,3 @@\n-error: this operation will panic at runtime\n-  --> $DIR/indexing_slicing_index.rs:11:5\n-   |\n-LL |     x[4]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n-   |     ^^^^ index out of bounds: the len is 4 but the index is 4\n-   |\n-   = note: `#[deny(unconditional_panic)]` on by default\n-\n-error: this operation will panic at runtime\n-  --> $DIR/indexing_slicing_index.rs:12:5\n-   |\n-LL |     x[1 << 3]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n-   |     ^^^^^^^^^ index out of bounds: the len is 4 but the index is 8\n-\n-error: this operation will panic at runtime\n-  --> $DIR/indexing_slicing_index.rs:27:5\n-   |\n-LL |     x[N]; // Ok, let rustc's `const_err` lint handle `usize` indexing on arrays.\n-   |     ^^^^ index out of bounds: the len is 4 but the index is 15\n-\n error: indexing may panic.\n   --> $DIR/indexing_slicing_index.rs:10:5\n    |\n@@ -75,5 +55,5 @@ LL |     v[M];\n    |\n    = help: Consider using `.get(n)` or `.get_mut(n)` instead\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "7f49cb913b125244db5fbe4de6e1c479210e4cd5", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d4342347b71313258a46e506ee0a258f365185c/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=4d4342347b71313258a46e506ee0a258f365185c", "patch": "@@ -3247,8 +3247,19 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn diff_mir_files(&self, before: PathBuf, after: PathBuf) -> String {\n-        let before = self.get_mir_dump_dir().join(before);\n-        let after = self.get_mir_dump_dir().join(after);\n+        let to_full_path = |path: PathBuf| {\n+            let full = self.get_mir_dump_dir().join(&path);\n+            if !full.exists() {\n+                panic!(\n+                    \"the mir dump file for {} does not exist (requested in {})\",\n+                    path.display(),\n+                    self.testpaths.file.display(),\n+                );\n+            }\n+            full\n+        };\n+        let before = to_full_path(before);\n+        let after = to_full_path(after);\n         debug!(\"comparing the contents of: {} with {}\", before.display(), after.display());\n         let before = fs::read_to_string(before).unwrap();\n         let after = fs::read_to_string(after).unwrap();"}]}