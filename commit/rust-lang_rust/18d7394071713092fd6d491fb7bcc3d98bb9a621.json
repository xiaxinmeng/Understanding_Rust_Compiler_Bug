{"sha": "18d7394071713092fd6d491fb7bcc3d98bb9a621", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZDczOTQwNzE3MTMwOTJmZDZkNDkxZmI3YmNjM2Q5OGJiOWE2MjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-15T15:12:48Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-17T08:02:31Z"}, "message": "more compile-fail ptr equality tests, to rule out any non-determinism; and fix ptr equality to fail all of them.\n\nAt least these are the cases I can think of right now.", "tree": {"sha": "8539bedd8210ffdbfeec7242a4b0345379c9aa57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8539bedd8210ffdbfeec7242a4b0345379c9aa57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18d7394071713092fd6d491fb7bcc3d98bb9a621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18d7394071713092fd6d491fb7bcc3d98bb9a621", "html_url": "https://github.com/rust-lang/rust/commit/18d7394071713092fd6d491fb7bcc3d98bb9a621", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18d7394071713092fd6d491fb7bcc3d98bb9a621/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd138bcd0b30b7af40fe0c13ce4f71f49cb59d3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd138bcd0b30b7af40fe0c13ce4f71f49cb59d3c", "html_url": "https://github.com/rust-lang/rust/commit/cd138bcd0b30b7af40fe0c13ce4f71f49cb59d3c"}], "stats": {"total": 116, "additions": 102, "deletions": 14}, "files": [{"sha": "4e0fcd4f511ffcfec52716a911840842cb01ca23", "filename": "src/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18d7394071713092fd6d491fb7bcc3d98bb9a621/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d7394071713092fd6d491fb7bcc3d98bb9a621/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=18d7394071713092fd6d491fb7bcc3d98bb9a621", "patch": "@@ -46,7 +46,7 @@ pub enum MemoryKind {\n     C,\n     /// Part of env var emulation\n     Env,\n-    // mutable statics\n+    /// mutable statics\n     MutStatic,\n }\n "}, {"sha": "cf416c44c11fd41507621f8ae603a047a8488b53", "filename": "src/operator.rs", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/18d7394071713092fd6d491fb7bcc3d98bb9a621/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d7394071713092fd6d491fb7bcc3d98bb9a621/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=18d7394071713092fd6d491fb7bcc3d98bb9a621", "patch": "@@ -152,18 +152,50 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             (Scalar::Ptr(ptr), Scalar::Bits { bits, size }) |\n             (Scalar::Bits { bits, size }, Scalar::Ptr(ptr)) => {\n                 assert_eq!(size as u64, self.pointer_size().bytes());\n+                let bits = bits as u64;\n+                let (alloc_size, alloc_align) = self.memory.get_size_and_align(ptr.alloc_id)?;\n \n+                // Case I: Comparing with NULL\n                 if bits == 0 {\n-                    // Nothing equals 0, not even dangling pointers. Ideally we would\n-                    // require them to be in-bounds of their (possilby dead) allocation,\n-                    // but with the allocation gonew e cannot check that.\n-                    false\n-                } else {\n-                    // Live pointers cannot equal an integer, but again do not\n-                    // allow comparing dead pointers.\n-                    self.memory.check_bounds(ptr, false)?;\n-                    false\n+                    // Test if the ptr is in-bounds. Then it cannot be NULL.\n+                    if ptr.offset <= alloc_size {\n+                        return Ok(false);\n+                    }\n+                }\n+                // Case II: Alignment gives it away\n+                if ptr.offset.bytes() % alloc_align.abi() == 0 {\n+                    // The offset maintains the allocation alignment, so we know `base+offset`\n+                    // is aligned by `alloc_align`.\n+                    // FIXME: We could be even more general, e.g. offset 2 into a 4-aligned\n+                    // allocation cannot equal 3.\n+                    if bits % alloc_align.abi() != 0 {\n+                        // The integer is *not* aligned. So they cannot be equal.\n+                        return Ok(false);\n+                    }\n                 }\n+                // Case III: The integer is too big, and the allocation goes on a bit\n+                // without wrapping around the address space.\n+                {\n+                    // Compute the highest address at which this allocation could live.\n+                    // Substract one more, because it must be possible to add the size\n+                    // to the base address without overflowing -- IOW, the very last address\n+                    // of the address space is never dereferencable (but it can be in-bounds, i.e.,\n+                    // one-past-the-end).\n+                    let max_base_addr =\n+                        ((1u128 << self.pointer_size().bits())\n+                         - u128::from(alloc_size.bytes())\n+                         - 1\n+                        ) as u64;\n+                    if let Some(max_addr) = max_base_addr.checked_add(ptr.offset.bytes()) {\n+                        if bits > max_addr {\n+                            // The integer is too big, this cannot possibly be equal\n+                            return Ok(false)\n+                        }\n+                    }\n+                }\n+\n+                // None of the supported cases.\n+                return err!(InvalidPointerMath);\n             }\n         })\n     }"}, {"sha": "d05996a13d562fa26aa7977516b73c202031ec01", "filename": "tests/compile-fail/ptr_eq_dangling.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Fcompile-fail%2Fptr_eq_dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Fcompile-fail%2Fptr_eq_dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_dangling.rs?ref=18d7394071713092fd6d491fb7bcc3d98bb9a621", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    let b = Box::new(0);\n+    let x = &*b as *const i32; // soon-to-be dangling\n+    drop(b);\n+    let b = Box::new(0);\n+    let y = &*b as *const i32; // different allocation\n+    // We cannot compare these even though both are inbounds -- they *could* be\n+    // equal if memory was reused.\n+    assert!(x != y); //~ ERROR dangling pointer\n+}"}, {"sha": "10d5fbd517a3c7e8c7384e55dcf3dec26b8801d1", "filename": "tests/compile-fail/ptr_eq_integer.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Fcompile-fail%2Fptr_eq_integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Fcompile-fail%2Fptr_eq_integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_integer.rs?ref=18d7394071713092fd6d491fb7bcc3d98bb9a621", "patch": "@@ -0,0 +1,8 @@\n+use std::mem;\n+\n+fn main() {\n+    let b = Box::new(0);\n+    let x = &*b as *const i32;\n+    // We cannot compare this with a non-NULL integer. After all, these *could* be equal (with the right base address).\n+    assert!(x != mem::align_of::<i32>() as *const i32); //~ ERROR invalid arithmetic on pointers\n+}"}, {"sha": "af4eed8d4e32ddb1acfa43e1e8e1305a7109504b", "filename": "tests/compile-fail/ptr_eq_out_of_bounds.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds.rs?ref=18d7394071713092fd6d491fb7bcc3d98bb9a621", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let b = Box::new(0);\n+    let x = (&*b as *const i32).wrapping_sub(0x800); // out-of-bounds\n+    let b = Box::new(0);\n+    let y = &*b as *const i32; // different allocation\n+    // We cannot compare these even though both allocations are live -- they *could* be\n+    // equal (with the right base addresses).\n+    assert!(x != y); //~ ERROR outside bounds\n+}"}, {"sha": "3b7b51fc19954f50394f787b587b6b01836b88bb", "filename": "tests/compile-fail/ptr_eq_out_of_bounds_null.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds_null.rs?ref=18d7394071713092fd6d491fb7bcc3d98bb9a621", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let b = Box::new(0);\n+    let x = (&*b as *const i32).wrapping_sub(0x800); // out-of-bounds\n+    // We cannot compare this with NULL. After all, this *could* be NULL (with the right base address).\n+    assert!(x != std::ptr::null()); //~ ERROR invalid arithmetic on pointers\n+}"}, {"sha": "ab79a64b56e2aa409accb767863eab6ba4e5ce9e", "filename": "tests/run-pass-fullmir/loop-break-value.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Frun-pass-fullmir%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Frun-pass-fullmir%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Floop-break-value.rs?ref=18d7394071713092fd6d491fb7bcc3d98bb9a621", "patch": "@@ -61,7 +61,9 @@ pub fn main() {\n             break Default::default()\n         };\n     };\n-    assert_eq!(trait_unified_2, [\"\"]);\n+    // compare lengths; ptr comparison is not deterministic\n+    assert_eq!(trait_unified_2.len(), 1);\n+    assert_eq!(trait_unified_2[0].len(), 0);\n \n     let trait_unified_3 = loop {\n         break if false {"}, {"sha": "2b26791328df611b04961851144db368422b2df3", "filename": "tests/run-pass/pointers.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Frun-pass%2Fpointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d7394071713092fd6d491fb7bcc3d98bb9a621/tests%2Frun-pass%2Fpointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpointers.rs?ref=18d7394071713092fd6d491fb7bcc3d98bb9a621", "patch": "@@ -1,3 +1,5 @@\n+use std::usize;\n+\n fn one_line_ref() -> i16 {\n     *&1\n }\n@@ -44,8 +46,8 @@ fn match_ref_mut() -> i8 {\n }\n \n fn dangling_pointer() -> *const i32 {\n-    let b = Box::new(42);\n-    &*b as *const i32\n+    let b = Box::new((42, 42)); // make it bigger than the alignment, so that there is some \"room\" after this pointer\n+    &b.0 as *const i32\n }\n \n fn main() {\n@@ -56,10 +58,29 @@ fn main() {\n     assert_eq!(tuple_ref_mut(), (10, 22));\n     assert_eq!(match_ref_mut(), 42);\n \n-    // Compare even dangling pointers with NULL, and with others in the same allocation.\n+    // Compare even dangling pointers with NULL, and with others in the same allocation, including\n+    // out-of-bounds.\n     assert!(dangling_pointer() != std::ptr::null());\n     assert!(match dangling_pointer() as usize { 0 => false, _ => true });\n     let dangling = dangling_pointer();\n     assert!(dangling == dangling);\n     assert!(dangling.wrapping_add(1) != dangling);\n+    assert!(dangling.wrapping_sub(1) != dangling);\n+\n+    // Compare pointer with BIG integers\n+    let dangling = dangling as usize;\n+    assert!(dangling != usize::MAX);\n+    assert!(dangling != usize::MAX - 1);\n+    assert!(dangling != usize::MAX - 2);\n+    assert!(dangling != usize::MAX - 3); // this is even 4-aligned, but it still cannot be equal because of the extra \"room\" after this pointer\n+    assert_eq!((usize::MAX - 3) % 4, 0); // just to be sure we got this right\n+\n+    // Compare pointer with unaligned integers\n+    assert!(dangling != 1usize);\n+    assert!(dangling != 2usize);\n+    assert!(dangling != 3usize);\n+    // 4 is a possible choice! So we cannot compare with that.\n+    assert!(dangling != 5usize);\n+    assert!(dangling != 6usize);\n+    assert!(dangling != 7usize);\n }"}]}