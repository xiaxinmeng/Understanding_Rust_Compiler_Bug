{"sha": "19c31b6b1afef7cad83275b2e73d27e5c44ed2a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YzMxYjZiMWFmZWY3Y2FkODMyNzViMmU3M2QyN2U1YzQ0ZWQyYTE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-11T01:37:33Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-11T01:37:33Z"}, "message": "extra: implement .norm(), and Polar conversion functions for complex numbers.\n\nAlso, convert complex to use Clone, rather than Copy.\n\nFixes #5734 and #5735.", "tree": {"sha": "8c50cb5c69252027a5553385fd34ea9e4f10b56e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c50cb5c69252027a5553385fd34ea9e4f10b56e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c31b6b1afef7cad83275b2e73d27e5c44ed2a1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c31b6b1afef7cad83275b2e73d27e5c44ed2a1", "html_url": "https://github.com/rust-lang/rust/commit/19c31b6b1afef7cad83275b2e73d27e5c44ed2a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c31b6b1afef7cad83275b2e73d27e5c44ed2a1/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e6a5940cbe9a1ff8c12566a972dc5c54c85ef5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e6a5940cbe9a1ff8c12566a972dc5c54c85ef5e", "html_url": "https://github.com/rust-lang/rust/commit/7e6a5940cbe9a1ff8c12566a972dc5c54c85ef5e"}], "stats": {"total": 77, "additions": 63, "deletions": 14}, "files": [{"sha": "1bb364f3a1c3fee5762bddeb92655cd5d1f117c9", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/19c31b6b1afef7cad83275b2e73d27e5c44ed2a1/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c31b6b1afef7cad83275b2e73d27e5c44ed2a1/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=19c31b6b1afef7cad83275b2e73d27e5c44ed2a1", "patch": "@@ -35,7 +35,7 @@ pub type Complex = Cmplx<float>;\n pub type Complex32 = Cmplx<f32>;\n pub type Complex64 = Cmplx<f64>;\n \n-impl<T: Copy + Num> Cmplx<T> {\n+impl<T: Clone + Num> Cmplx<T> {\n     /// Create a new Cmplx\n     #[inline]\n     pub fn new(re: T, im: T) -> Cmplx<T> {\n@@ -55,7 +55,7 @@ impl<T: Copy + Num> Cmplx<T> {\n     /// Returns the complex conjugate. i.e. `re - i im`\n     #[inline]\n     pub fn conj(&self) -> Cmplx<T> {\n-        Cmplx::new(self.re, -self.im)\n+        Cmplx::new(self.re.clone(), -self.im)\n     }\n \n \n@@ -80,62 +80,91 @@ impl<T: Copy + Num> Cmplx<T> {\n     }\n }\n \n+#[cfg(not(stage0))] // Fixed by #4228\n+impl<T: Clone + Algebraic + Num> Cmplx<T> {\n+    /// Calculate |self|\n+    #[inline(always)]\n+    pub fn norm(&self) -> T {\n+        self.re.hypot(&self.im)\n+    }\n+}\n+\n+#[cfg(not(stage0))] // Fixed by #4228\n+impl<T: Clone + Trigonometric + Algebraic + Num> Cmplx<T> {\n+    /// Calculate the principal Arg of self.\n+    #[inline(always)]\n+    pub fn arg(&self) -> T {\n+        self.im.atan2(&self.re)\n+    }\n+    /// Convert to polar form (r, theta), such that `self = r * exp(i\n+    /// * theta)`\n+    #[inline]\n+    pub fn to_polar(&self) -> (T, T) {\n+        (self.norm(), self.arg())\n+    }\n+    /// Convert a polar representation into a complex number.\n+    #[inline]\n+    pub fn from_polar(r: &T, theta: &T) -> Cmplx<T> {\n+        Cmplx::new(r * theta.cos(), r * theta.sin())\n+    }\n+}\n+\n /* arithmetic */\n // (a + i b) + (c + i d) == (a + c) + i (b + d)\n-impl<T: Copy + Num> Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn add(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re + other.re, self.im + other.im)\n     }\n }\n // (a + i b) - (c + i d) == (a - c) + i (b - d)\n-impl<T: Copy + Num> Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn sub(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re - other.re, self.im - other.im)\n     }\n }\n // (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)\n-impl<T: Copy + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn mul(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         Cmplx::new(self.re*other.re - self.im*other.im,\n-                     self.re*other.im + self.im*other.re)\n+                   self.re*other.im + self.im*other.re)\n     }\n }\n \n // (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n //   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n-impl<T: Copy + Num> Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn div(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         let norm_sqr = other.norm_sqr();\n         Cmplx::new((self.re*other.re + self.im*other.im) / norm_sqr,\n-                     (self.im*other.re - self.re*other.im) / norm_sqr)\n+                   (self.im*other.re - self.re*other.im) / norm_sqr)\n     }\n }\n \n-impl<T: Copy + Num> Neg<Cmplx<T>> for Cmplx<T> {\n+impl<T: Clone + Num> Neg<Cmplx<T>> for Cmplx<T> {\n     #[inline]\n     fn neg(&self) -> Cmplx<T> {\n         Cmplx::new(-self.re, -self.im)\n     }\n }\n \n /* constants */\n-impl<T: Copy + Num> Zero for Cmplx<T> {\n+impl<T: Clone + Num> Zero for Cmplx<T> {\n     #[inline]\n     fn zero() -> Cmplx<T> {\n         Cmplx::new(Zero::zero(), Zero::zero())\n     }\n \n     #[inline]\n     fn is_zero(&self) -> bool {\n-        *self == Zero::zero()\n+        self.re.is_zero() && self.im.is_zero()\n     }\n }\n \n-impl<T: Copy + Num> One for Cmplx<T> {\n+impl<T: Clone + Num> One for Cmplx<T> {\n     #[inline]\n     fn one() -> Cmplx<T> {\n         Cmplx::new(One::one(), Zero::zero())\n@@ -166,7 +195,7 @@ impl<T: ToStrRadix + Num + Ord> ToStrRadix for Cmplx<T> {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use core::num::{Zero,One};\n+    use core::num::{Zero,One,Real};\n \n     pub static _0_0i : Complex = Cmplx { re: 0f, im: 0f };\n     pub static _1_0i : Complex = Cmplx { re: 1f, im: 0f };\n@@ -193,9 +222,10 @@ mod test {\n     }\n \n     #[test]\n-    fn test_norm_sqr() {\n+    fn test_norm() {\n         fn test(c: Complex, ns: float) {\n             assert_eq!(c.norm_sqr(), ns);\n+            assert_eq!(c.norm(), ns.sqrt())\n         }\n         test(_0_0i, 0f);\n         test(_1_0i, 1f);\n@@ -235,6 +265,25 @@ mod test {\n         _0_0i.inv();\n     }\n \n+    #[test]\n+    fn test_arg() {\n+        fn test(c: Complex, arg: float) {\n+            assert!(c.arg().approx_eq(&arg))\n+        }\n+        test(_1_0i, 0f);\n+        test(_1_1i, 0.25f * Real::pi());\n+        test(_neg1_1i, 0.75f * Real::pi());\n+        test(_05_05i, 0.25f * Real::pi());\n+    }\n+\n+    #[test]\n+    fn test_polar_conv() {\n+        fn test(c: Complex) {\n+            let (r, theta) = c.to_polar();\n+            assert!((c - Cmplx::from_polar(&r, &theta)).norm() < 1e-6);\n+        }\n+        for all_consts.each |&c| { test(c); }\n+    }\n \n     mod arith {\n         use super::*;"}]}