{"sha": "6ddab3e078bc25bd101d6885427b8a1032f8f60c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZGFiM2UwNzhiYzI1YmQxMDFkNjg4NTQyN2I4YTEwMzJmOGY2MGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-03T10:49:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-03T10:49:27Z"}, "message": "Auto merge of #54720 - davidtwco:issue-51191, r=nikomatsakis\n\nNLL fails to suggest \"try removing `&mut` here\"\n\nFixes #51191.\n\nThis PR adds ``try removing `&mut` here`` suggestions to functions where a mutable borrow is being taken of a `&mut self` or a `self: &mut Self`. This PR also enables the suggestion for adding a `mut` pattern to by-value implicit self arguments without `mut` patterns already.\n\nr? @nikomatsakis", "tree": {"sha": "9fb5b39c159053a9855c82b818fe5a474f7f1d0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb5b39c159053a9855c82b818fe5a474f7f1d0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ddab3e078bc25bd101d6885427b8a1032f8f60c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ddab3e078bc25bd101d6885427b8a1032f8f60c", "html_url": "https://github.com/rust-lang/rust/commit/6ddab3e078bc25bd101d6885427b8a1032f8f60c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ddab3e078bc25bd101d6885427b8a1032f8f60c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cf11765dc98536c6eedf33f2df7f72f6e161263", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf11765dc98536c6eedf33f2df7f72f6e161263", "html_url": "https://github.com/rust-lang/rust/commit/4cf11765dc98536c6eedf33f2df7f72f6e161263"}, {"sha": "2be306939dae233ae641ebd692ef45840bb419cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2be306939dae233ae641ebd692ef45840bb419cb", "html_url": "https://github.com/rust-lang/rust/commit/2be306939dae233ae641ebd692ef45840bb419cb"}], "stats": {"total": 262, "additions": 232, "deletions": 30}, "files": [{"sha": "cd2e34ec78b10ec6e4b4dc11c4cb491c3b0197ca", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -2044,11 +2044,31 @@ impl<'a> LoweringContext<'a> {\n             inputs,\n             output,\n             variadic: decl.variadic,\n-            has_implicit_self: decl.inputs.get(0).map_or(false, |arg| match arg.ty.node {\n-                TyKind::ImplicitSelf => true,\n-                TyKind::Rptr(_, ref mt) => mt.ty.node.is_implicit_self(),\n-                _ => false,\n-            }),\n+            implicit_self: decl.inputs.get(0).map_or(\n+                hir::ImplicitSelfKind::None,\n+                |arg| {\n+                    let is_mutable_pat = match arg.pat.node {\n+                        PatKind::Ident(BindingMode::ByValue(mt), _, _) |\n+                        PatKind::Ident(BindingMode::ByRef(mt), _, _) =>\n+                            mt == Mutability::Mutable,\n+                        _ => false,\n+                    };\n+\n+                    match arg.ty.node {\n+                        TyKind::ImplicitSelf if is_mutable_pat => hir::ImplicitSelfKind::Mut,\n+                        TyKind::ImplicitSelf => hir::ImplicitSelfKind::Imm,\n+                        // Given we are only considering `ImplicitSelf` types, we needn't consider\n+                        // the case where we have a mutable pattern to a reference as that would\n+                        // no longer be an `ImplicitSelf`.\n+                        TyKind::Rptr(_, ref mt) if mt.ty.node.is_implicit_self() &&\n+                            mt.mutbl == ast::Mutability::Mutable =>\n+                                hir::ImplicitSelfKind::MutRef,\n+                        TyKind::Rptr(_, ref mt) if mt.ty.node.is_implicit_self() =>\n+                            hir::ImplicitSelfKind::ImmRef,\n+                        _ => hir::ImplicitSelfKind::None,\n+                    }\n+                },\n+            ),\n         })\n     }\n "}, {"sha": "f06a09e706f28101cf6500c9c9559e87b7a6ef2f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -1782,9 +1782,34 @@ pub struct FnDecl {\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n-    /// True if this function has an `self`, `&self` or `&mut self` receiver\n-    /// (but not a `self: Xxx` one).\n-    pub has_implicit_self: bool,\n+    /// Does the function have an implicit self?\n+    pub implicit_self: ImplicitSelfKind,\n+}\n+\n+/// Represents what type of implicit self a function has, if any.\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub enum ImplicitSelfKind {\n+    /// Represents a `fn x(self);`.\n+    Imm,\n+    /// Represents a `fn x(mut self);`.\n+    Mut,\n+    /// Represents a `fn x(&self);`.\n+    ImmRef,\n+    /// Represents a `fn x(&mut self);`.\n+    MutRef,\n+    /// Represents when a function does not have a self argument or\n+    /// when a function has a `self: X` argument.\n+    None\n+}\n+\n+impl ImplicitSelfKind {\n+    /// Does this represent an implicit self?\n+    pub fn has_implicit_self(&self) -> bool {\n+        match *self {\n+            ImplicitSelfKind::None => false,\n+            _ => true,\n+        }\n+    }\n }\n \n /// Is the trait definition an auto trait?"}, {"sha": "23533b7a4c3901f9f38587d7b36d2dd7e410af67", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -355,14 +355,22 @@ impl_stable_hash_for!(struct hir::FnDecl {\n     inputs,\n     output,\n     variadic,\n-    has_implicit_self\n+    implicit_self\n });\n \n impl_stable_hash_for!(enum hir::FunctionRetTy {\n     DefaultReturn(span),\n     Return(t)\n });\n \n+impl_stable_hash_for!(enum hir::ImplicitSelfKind {\n+    Imm,\n+    Mut,\n+    ImmRef,\n+    MutRef,\n+    None\n+});\n+\n impl_stable_hash_for!(struct hir::TraitRef {\n     // Don't hash the ref_id. It is tracked via the thing it is used to access\n     ref_id -> _,"}, {"sha": "27ef01b93cda1df96c40cf1bc6d950191041ed93", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -583,11 +583,27 @@ pub enum BindingForm<'tcx> {\n     /// This is a binding for a non-`self` binding, or a `self` that has an explicit type.\n     Var(VarBindingForm<'tcx>),\n     /// Binding for a `self`/`&self`/`&mut self` binding where the type is implicit.\n-    ImplicitSelf,\n+    ImplicitSelf(ImplicitSelfKind),\n     /// Reference used in a guard expression to ensure immutability.\n     RefForGuard,\n }\n \n+/// Represents what type of implicit self a function has, if any.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub enum ImplicitSelfKind {\n+    /// Represents a `fn x(self);`.\n+    Imm,\n+    /// Represents a `fn x(mut self);`.\n+    Mut,\n+    /// Represents a `fn x(&self);`.\n+    ImmRef,\n+    /// Represents a `fn x(&mut self);`.\n+    MutRef,\n+    /// Represents when a function does not have a self argument or\n+    /// when a function has a `self: X` argument.\n+    None\n+}\n+\n CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n \n impl_stable_hash_for!(struct self::VarBindingForm<'tcx> {\n@@ -597,6 +613,14 @@ impl_stable_hash_for!(struct self::VarBindingForm<'tcx> {\n     pat_span\n });\n \n+impl_stable_hash_for!(enum self::ImplicitSelfKind {\n+    Imm,\n+    Mut,\n+    ImmRef,\n+    MutRef,\n+    None\n+});\n+\n mod binding_form_impl {\n     use ich::StableHashingContext;\n     use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n@@ -612,7 +636,7 @@ mod binding_form_impl {\n \n             match self {\n                 Var(binding) => binding.hash_stable(hcx, hasher),\n-                ImplicitSelf => (),\n+                ImplicitSelf(kind) => kind.hash_stable(hcx, hasher),\n                 RefForGuard => (),\n             }\n         }\n@@ -775,10 +799,9 @@ impl<'tcx> LocalDecl<'tcx> {\n                 pat_span: _,\n             }))) => true,\n \n-            // FIXME: might be able to thread the distinction between\n-            // `self`/`mut self`/`&self`/`&mut self` into the\n-            // `BindingForm::ImplicitSelf` variant, (and then return\n-            // true here for solely the first case).\n+            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm)))\n+                => true,\n+\n             _ => false,\n         }\n     }\n@@ -795,7 +818,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 pat_span: _,\n             }))) => true,\n \n-            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf)) => true,\n+            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_))) => true,\n \n             _ => false,\n         }"}, {"sha": "321257aefdb5aff6d9a80e989cd89531e80de99e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -1221,7 +1221,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             if let Some(i) = arg_pos {\n                 // The argument's `Ty`\n                 (Some(&fn_like.decl().inputs[i]),\n-                 i == 0 && fn_like.decl().has_implicit_self)\n+                 i == 0 && fn_like.decl().implicit_self.has_implicit_self())\n             } else {\n                 (None, false)\n             }"}, {"sha": "ba625fb08c82c6865d9103cc000c06f9f40c2e45", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -16,6 +16,7 @@ use rustc::mir::TerminatorKind;\n use rustc::ty::{self, Const, DefIdTree, TyS, TyKind, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n+use syntax_pos::symbol::keywords;\n \n use dataflow::move_paths::InitLocation;\n use borrow_check::MirBorrowckCtxt;\n@@ -217,6 +218,40 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"report_mutability_error: act={:?}, acted_on={:?}\", act, acted_on);\n \n         match the_place_err {\n+            // Suggest removing a `&mut` from the use of a mutable reference.\n+            Place::Local(local)\n+                if {\n+                    self.mir.local_decls.get(*local).map(|local_decl| {\n+                        if let ClearCrossCrate::Set(\n+                            mir::BindingForm::ImplicitSelf(kind)\n+                        ) = local_decl.is_user_variable.as_ref().unwrap() {\n+                            // Check if the user variable is a `&mut self` and we can therefore\n+                            // suggest removing the `&mut`.\n+                            //\n+                            // Deliberately fall into this case for all implicit self types,\n+                            // so that we don't fall in to the next case with them.\n+                            *kind == mir::ImplicitSelfKind::MutRef\n+                        } else if Some(keywords::SelfValue.name()) == local_decl.name {\n+                            // Otherwise, check if the name is the self kewyord - in which case\n+                            // we have an explicit self. Do the same thing in this case and check\n+                            // for a `self: &mut Self` to suggest removing the `&mut`.\n+                            if let ty::TyKind::Ref(\n+                                _, _, hir::Mutability::MutMutable\n+                            ) = local_decl.ty.sty {\n+                                true\n+                            } else {\n+                                false\n+                            }\n+                        } else {\n+                            false\n+                        }\n+                    }).unwrap_or(false)\n+                } =>\n+            {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, \"try removing `&mut` here\");\n+            },\n+\n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n             Place::Local(local) if self.mir.local_decls[*local].can_be_made_mutable() => {\n@@ -316,7 +351,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             {\n                 let local_decl = &self.mir.local_decls[*local];\n                 let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n-                    ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf) => {\n+                    ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_)) => {\n                         Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n                     }\n "}, {"sha": "3dbd3bbb41573b8834aa03ec6567c8c93d39a7c2", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -125,8 +125,14 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n                             let ty_span = tcx.hir.span(tcx.hir.hir_to_node_id(ty_hir_id));\n                             opt_ty_info = Some(ty_span);\n-                            self_arg = if index == 0 && fn_decl.has_implicit_self {\n-                                Some(ImplicitSelfBinding)\n+                            self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n+                                match fn_decl.implicit_self {\n+                                    hir::ImplicitSelfKind::Imm => Some(ImplicitSelfKind::Imm),\n+                                    hir::ImplicitSelfKind::Mut => Some(ImplicitSelfKind::Mut),\n+                                    hir::ImplicitSelfKind::ImmRef => Some(ImplicitSelfKind::ImmRef),\n+                                    hir::ImplicitSelfKind::MutRef => Some(ImplicitSelfKind::MutRef),\n+                                    _ => None,\n+                                }\n                             } else {\n                                 None\n                             };\n@@ -508,12 +514,10 @@ fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ImplicitSelfBinding;\n-\n struct ArgInfo<'gcx>(Ty<'gcx>,\n                      Option<Span>,\n                      Option<&'gcx hir::Pat>,\n-                     Option<ImplicitSelfBinding>);\n+                     Option<ImplicitSelfKind>);\n \n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    fn_id: ast::NodeId,\n@@ -797,8 +801,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     PatternKind::Binding { mutability, var, mode: BindingMode::ByValue, .. } => {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].is_user_variable =\n-                            if let Some(ImplicitSelfBinding) = self_binding {\n-                                Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf))\n+                            if let Some(kind) = self_binding {\n+                                Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind)))\n                             } else {\n                                 let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n                                 Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {"}, {"sha": "e7d25d07d12058b49007a47be8ab30d6ada81efa", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -270,7 +270,7 @@ trait TraitChangeModeSelfOwnToMut: Sized {\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n trait TraitChangeModeSelfOwnToMut: Sized {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]"}, {"sha": "15139e4e8ae36a986fe131be1bf80895df3d9ca0", "filename": "src/test/ui/did_you_mean/issue-31424.nll.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -2,15 +2,19 @@ error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n   --> $DIR/issue-31424.rs:17:9\n    |\n LL |         (&mut self).bar(); //~ ERROR cannot borrow\n-   |         ^^^^^^^^^^^ cannot borrow as mutable\n+   |         ^^^^^^^^^^^\n+   |         |\n+   |         cannot borrow as mutable\n+   |         try removing `&mut` here\n \n error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n   --> $DIR/issue-31424.rs:23:9\n    |\n-LL |     fn bar(self: &mut Self) {\n-   |            ---- help: consider changing this to be mutable: `mut self`\n LL |         (&mut self).bar(); //~ ERROR cannot borrow\n-   |         ^^^^^^^^^^^ cannot borrow as mutable\n+   |         ^^^^^^^^^^^\n+   |         |\n+   |         cannot borrow as mutable\n+   |         try removing `&mut` here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "87ec3e5df0b81b7b9ade8464a296934d28559158", "filename": "src/test/ui/nll/issue-51191.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Ftest%2Fui%2Fnll%2Fissue-51191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Ftest%2Fui%2Fnll%2Fissue-51191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51191.rs?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+struct Struct;\n+\n+impl Struct {\n+    fn bar(self: &mut Self) {\n+        (&mut self).bar();\n+        //~^ ERROR cannot borrow `self` as mutable, as it is not declared as mutable [E0596]\n+    }\n+\n+    fn imm(self) {\n+        (&mut self).bar();\n+        //~^ ERROR cannot borrow `self` as mutable, as it is not declared as mutable [E0596]\n+    }\n+\n+    fn mtbl(mut self) {\n+        (&mut self).bar();\n+    }\n+\n+    fn immref(&self) {\n+        (&mut self).bar();\n+        //~^ ERROR cannot borrow `self` as mutable, as it is not declared as mutable [E0596]\n+        //~^^ ERROR cannot borrow data in a `&` reference as mutable [E0596]\n+    }\n+\n+    fn mtblref(&mut self) {\n+        (&mut self).bar();\n+        //~^ ERROR cannot borrow `self` as mutable, as it is not declared as mutable [E0596]\n+    }\n+}\n+\n+fn main () {}"}, {"sha": "c5b5218f173ac1634eb365698f88558c23c710fb", "filename": "src/test/ui/nll/issue-51191.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Ftest%2Fui%2Fnll%2Fissue-51191.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ddab3e078bc25bd101d6885427b8a1032f8f60c/src%2Ftest%2Fui%2Fnll%2Fissue-51191.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51191.stderr?ref=6ddab3e078bc25bd101d6885427b8a1032f8f60c", "patch": "@@ -0,0 +1,41 @@\n+error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-51191.rs:17:9\n+   |\n+LL |         (&mut self).bar();\n+   |         ^^^^^^^^^^^\n+   |         |\n+   |         cannot borrow as mutable\n+   |         try removing `&mut` here\n+\n+error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-51191.rs:22:9\n+   |\n+LL |     fn imm(self) {\n+   |            ---- help: consider changing this to be mutable: `mut self`\n+LL |         (&mut self).bar();\n+   |         ^^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-51191.rs:31:9\n+   |\n+LL |         (&mut self).bar();\n+   |         ^^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow data in a `&` reference as mutable\n+  --> $DIR/issue-51191.rs:31:9\n+   |\n+LL |         (&mut self).bar();\n+   |         ^^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-51191.rs:37:9\n+   |\n+LL |         (&mut self).bar();\n+   |         ^^^^^^^^^^^\n+   |         |\n+   |         cannot borrow as mutable\n+   |         try removing `&mut` here\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0596`."}]}