{"sha": "f632f466148c7e5571393bb2a24cd628703a60fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MzJmNDY2MTQ4YzdlNTU3MTM5M2JiMmEyNGNkNjI4NzAzYTYwZmE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T11:03:16Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:55Z"}, "message": "std: convert str::trim* to methods.", "tree": {"sha": "6a5fa9687b4df16bf4fe0e6ff564c15f61c4a452", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a5fa9687b4df16bf4fe0e6ff564c15f61c4a452"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f632f466148c7e5571393bb2a24cd628703a60fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f632f466148c7e5571393bb2a24cd628703a60fa", "html_url": "https://github.com/rust-lang/rust/commit/f632f466148c7e5571393bb2a24cd628703a60fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f632f466148c7e5571393bb2a24cd628703a60fa/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1553874149c3c37b94d75e9122092b131ba74c77", "url": "https://api.github.com/repos/rust-lang/rust/commits/1553874149c3c37b94d75e9122092b131ba74c77", "html_url": "https://github.com/rust-lang/rust/commit/1553874149c3c37b94d75e9122092b131ba74c77"}], "stats": {"total": 208, "additions": 94, "deletions": 114}, "files": [{"sha": "0294b595cfd93e6f16197ac8f53b68067addb8b2", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=f632f466148c7e5571393bb2a24cd628703a60fa", "patch": "@@ -524,7 +524,7 @@ impl ToStrRadix for BigUint {\n                 let s = uint::to_str_radix(*n as uint, radix);\n                 str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n             }));\n-            str::trim_left_chars(s, ['0']).to_owned()\n+            s.trim_left_chars(['0']).to_owned()\n         }\n     }\n }"}, {"sha": "36eb5e77ad6510a5211b8907e32ba9aab1fcdb8f", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=f632f466148c7e5571393bb2a24cd628703a60fa", "patch": "@@ -152,7 +152,7 @@ pub fn pandoc_header_id(header: &str) -> ~str {\n         // Collapse sequences of whitespace to a single dash\n         // XXX: Hacky implementation here that only covers\n         // one or two spaces.\n-        let s = str::trim(s);\n+        let s = s.trim();\n         let s = str::replace(s, \"  \", \"-\");\n         let s = str::replace(s, \" \", \"-\");\n         return s;"}, {"sha": "1f7a71e0fd8963fbecf7c90fb807ff5bb552ed0b", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=f632f466148c7e5571393bb2a24cd628703a60fa", "patch": "@@ -157,7 +157,7 @@ mod test {\n             let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n             let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n-            (mk_pass(~\"\", |s| str::trim(s).to_owned() ).f)(srv.clone(), doc)\n+            (mk_pass(~\"\", |s| s.trim().to_owned() ).f)(srv.clone(), doc)\n         }\n     }\n "}, {"sha": "17caaf6bf7d24a40866a286841354aca26e8f4b8", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=f632f466148c7e5571393bb2a24cd628703a60fa", "patch": "@@ -318,7 +318,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                 match get_line(use_rl, \"rusti| \") {\n                     None => fail!(\"unterminated multiline command :{ .. :}\"),\n                     Some(line) => {\n-                        if str::trim(line) == \":}\" {\n+                        if line.trim() == \":}\" {\n                             end_multiline = true;\n                         } else {\n                             multiline_cmd += line + \"\\n\";"}, {"sha": "605a11032a10907f09cae344ea903f1cdb10edd0", "filename": "src/libstd/str.rs", "status": "modified", "additions": 90, "deletions": 110, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f632f466148c7e5571393bb2a24cd628703a60fa/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=f632f466148c7e5571393bb2a24cd628703a60fa", "patch": "@@ -413,80 +413,6 @@ pub fn unshift_char(s: &mut ~str, ch: char) {\n     *s = new_str;\n }\n \n-/**\n- * Returns a string with leading `chars_to_trim` removed.\n- *\n- * # Arguments\n- *\n- * * s - A string\n- * * chars_to_trim - A vector of chars\n- *\n- */\n-pub fn trim_left_chars<'a>(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n-    if chars_to_trim.is_empty() { return s; }\n-\n-    match s.find(|c| !chars_to_trim.contains(&c)) {\n-      None => \"\",\n-      Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n-    }\n-}\n-\n-/**\n- * Returns a string with trailing `chars_to_trim` removed.\n- *\n- * # Arguments\n- *\n- * * s - A string\n- * * chars_to_trim - A vector of chars\n- *\n- */\n-pub fn trim_right_chars<'a>(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n-    if chars_to_trim.is_empty() { return s; }\n-\n-    match s.rfind(|c| !chars_to_trim.contains(&c)) {\n-      None => \"\",\n-      Some(last) => {\n-        let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_bytes(s, 0u, next) }\n-      }\n-    }\n-}\n-\n-/**\n- * Returns a string with leading and trailing `chars_to_trim` removed.\n- *\n- * # Arguments\n- *\n- * * s - A string\n- * * chars_to_trim - A vector of chars\n- *\n- */\n-pub fn trim_chars<'a>(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n-    trim_left_chars(trim_right_chars(s, chars_to_trim), chars_to_trim)\n-}\n-\n-/// Returns a string with leading whitespace removed\n-pub fn trim_left<'a>(s: &'a str) -> &'a str {\n-    match s.find(|c| !char::is_whitespace(c)) {\n-      None => \"\",\n-      Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n-    }\n-}\n-\n-/// Returns a string with trailing whitespace removed\n-pub fn trim_right<'a>(s: &'a str) -> &'a str {\n-    match s.rfind(|c| !char::is_whitespace(c)) {\n-      None => \"\",\n-      Some(last) => {\n-        let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_bytes(s, 0u, next) }\n-      }\n-    }\n-}\n-\n-/// Returns a string with leading and trailing whitespace removed\n-pub fn trim<'a>(s: &'a str) -> &'a str { trim_left(trim_right(s)) }\n-\n /*\n Section: Transforming strings\n */\n@@ -2024,25 +1950,79 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    fn trim(&self) -> &'self str { trim(*self) }\n+    fn trim(&self) -> &'self str {\n+        self.trim_left().trim_right()\n+    }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    fn trim_left(&self) -> &'self str { trim_left(*self) }\n+    fn trim_left(&self) -> &'self str {\n+        match self.find(|c| !char::is_whitespace(c)) {\n+            None => \"\",\n+            Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n+        }\n+    }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    fn trim_right(&self) -> &'self str { trim_right(*self) }\n+    fn trim_right(&self) -> &'self str {\n+        match self.rfind(|c| !char::is_whitespace(c)) {\n+            None => \"\",\n+            Some(last) => {\n+                let next = char_range_at(*self, last).next;\n+                unsafe { raw::slice_bytes(*self, 0u, next) }\n+            }\n+        }\n+    }\n \n+    /**\n+     * Returns a string with leading and trailing `chars_to_trim` removed.\n+     *\n+     * # Arguments\n+     *\n+     * * chars_to_trim - A vector of chars\n+     *\n+     */\n     #[inline]\n     fn trim_chars(&self, chars_to_trim: &[char]) -> &'self str {\n-        trim_chars(*self, chars_to_trim)\n+        self.trim_left_chars(chars_to_trim).trim_right_chars(chars_to_trim)\n     }\n+    /**\n+     * Returns a string with leading `chars_to_trim` removed.\n+     *\n+     * # Arguments\n+     *\n+     * * s - A string\n+     * * chars_to_trim - A vector of chars\n+     *\n+     */\n     #[inline]\n     fn trim_left_chars(&self, chars_to_trim: &[char]) -> &'self str {\n-        trim_left_chars(*self, chars_to_trim)\n+        if chars_to_trim.is_empty() { return *self; }\n+\n+        match self.find(|c| !chars_to_trim.contains(&c)) {\n+            None => \"\",\n+            Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n+        }\n     }\n+    /**\n+     * Returns a string with trailing `chars_to_trim` removed.\n+     *\n+     * # Arguments\n+     *\n+     * * s - A string\n+     * * chars_to_trim - A vector of chars\n+     *\n+     */\n     #[inline]\n     fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str {\n-        trim_right_chars(*self, chars_to_trim)\n+        if chars_to_trim.is_empty() { return *self; }\n+\n+        match self.rfind(|c| !chars_to_trim.contains(&c)) {\n+            None => \"\",\n+            Some(last) => {\n+                let next = char_range_at(self, last).next;\n+                unsafe { raw::slice_bytes(self, 0u, next) }\n+            }\n+        }\n     }\n \n \n@@ -2754,56 +2734,56 @@ mod tests {\n \n     #[test]\n     fn test_trim_left_chars() {\n-        assert!(trim_left_chars(\" *** foo *** \", []) == \" *** foo *** \");\n-        assert!(trim_left_chars(\" *** foo *** \", ['*', ' ']) == \"foo *** \");\n-        assert_eq!(trim_left_chars(\" ***  *** \", ['*', ' ']), \"\");\n-        assert!(trim_left_chars(\"foo *** \", ['*', ' ']) == \"foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_chars([]), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_chars(['*', ' ']), \"foo *** \");\n+        assert_eq!(\" ***  *** \".trim_left_chars(['*', ' ']), \"\");\n+        assert_eq!(\"foo *** \".trim_left_chars(['*', ' ']), \"foo *** \");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n-        assert!(trim_right_chars(\" *** foo *** \", []) == \" *** foo *** \");\n-        assert!(trim_right_chars(\" *** foo *** \", ['*', ' ']) == \" *** foo\");\n-        assert_eq!(trim_right_chars(\" ***  *** \", ['*', ' ']), \"\");\n-        assert!(trim_right_chars(\" *** foo\", ['*', ' ']) == \" *** foo\");\n+        assert_eq!(\" *** foo *** \".trim_right_chars([]), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_right_chars(['*', ' ']), \" *** foo\");\n+        assert_eq!(\" ***  *** \".trim_right_chars(['*', ' ']), \"\");\n+        assert_eq!(\" *** foo\".trim_right_chars(['*', ' ']), \" *** foo\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n-        assert_eq!(trim_chars(\" *** foo *** \", []), \" *** foo *** \");\n-        assert_eq!(trim_chars(\" *** foo *** \", ['*', ' ']), \"foo\");\n-        assert_eq!(trim_chars(\" ***  *** \", ['*', ' ']), \"\");\n-        assert_eq!(trim_chars(\"foo\", ['*', ' ']), \"foo\");\n+        assert_eq!(\" *** foo *** \".trim_chars([]), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_chars(['*', ' ']), \"foo\");\n+        assert_eq!(\" ***  *** \".trim_chars(['*', ' ']), \"\");\n+        assert_eq!(\"foo\".trim_chars(['*', ' ']), \"foo\");\n     }\n \n     #[test]\n     fn test_trim_left() {\n-        assert_eq!(trim_left(\"\"), \"\");\n-        assert_eq!(trim_left(\"a\"), \"a\");\n-        assert_eq!(trim_left(\"    \"), \"\");\n-        assert_eq!(trim_left(\"     blah\"), \"blah\");\n-        assert_eq!(trim_left(\"   \\u3000  wut\"), \"wut\");\n-        assert_eq!(trim_left(\"hey \"), \"hey \");\n+        assert_eq!(\"\".trim_left(), \"\");\n+        assert_eq!(\"a\".trim_left(), \"a\");\n+        assert_eq!(\"    \".trim_left(), \"\");\n+        assert_eq!(\"     blah\".trim_left(), \"blah\");\n+        assert_eq!(\"   \\u3000  wut\".trim_left(), \"wut\");\n+        assert_eq!(\"hey \".trim_left(), \"hey \");\n     }\n \n     #[test]\n     fn test_trim_right() {\n-        assert_eq!(trim_right(\"\"), \"\");\n-        assert_eq!(trim_right(\"a\"), \"a\");\n-        assert_eq!(trim_right(\"    \"), \"\");\n-        assert_eq!(trim_right(\"blah     \"), \"blah\");\n-        assert_eq!(trim_right(\"wut   \\u3000  \"), \"wut\");\n-        assert_eq!(trim_right(\" hey\"), \" hey\");\n+        assert_eq!(\"\".trim_right(), \"\");\n+        assert_eq!(\"a\".trim_right(), \"a\");\n+        assert_eq!(\"    \".trim_right(), \"\");\n+        assert_eq!(\"blah     \".trim_right(), \"blah\");\n+        assert_eq!(\"wut   \\u3000  \".trim_right(), \"wut\");\n+        assert_eq!(\" hey\".trim_right(), \" hey\");\n     }\n \n     #[test]\n     fn test_trim() {\n-        assert_eq!(trim(\"\"), \"\");\n-        assert_eq!(trim(\"a\"), \"a\");\n-        assert_eq!(trim(\"    \"), \"\");\n-        assert_eq!(trim(\"    blah     \"), \"blah\");\n-        assert_eq!(trim(\"\\nwut   \\u3000  \"), \"wut\");\n-        assert_eq!(trim(\" hey dude \"), \"hey dude\");\n+        assert_eq!(\"\".trim(), \"\");\n+        assert_eq!(\"a\".trim(), \"a\");\n+        assert_eq!(\"    \".trim(), \"\");\n+        assert_eq!(\"    blah     \".trim(), \"blah\");\n+        assert_eq!(\"\\nwut   \\u3000  \".trim(), \"wut\");\n+        assert_eq!(\" hey dude \".trim(), \"hey dude\");\n     }\n \n     #[test]"}]}