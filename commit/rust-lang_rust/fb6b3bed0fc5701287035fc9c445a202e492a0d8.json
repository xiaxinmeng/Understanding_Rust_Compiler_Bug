{"sha": "fb6b3bed0fc5701287035fc9c445a202e492a0d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNmIzYmVkMGZjNTcwMTI4NzAzNWZjOWM0NDVhMjAyZTQ5MmEwZDg=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-18T12:10:13Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-18T12:10:26Z"}, "message": "Add utility functions to check for trait impl", "tree": {"sha": "4fc2e79424c37347efbf8867dc65c12f33d50303", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fc2e79424c37347efbf8867dc65c12f33d50303"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb6b3bed0fc5701287035fc9c445a202e492a0d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb6b3bed0fc5701287035fc9c445a202e492a0d8", "html_url": "https://github.com/rust-lang/rust/commit/fb6b3bed0fc5701287035fc9c445a202e492a0d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb6b3bed0fc5701287035fc9c445a202e492a0d8/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90cbc858e983e302d97f2bd72be7af9a94def51a", "url": "https://api.github.com/repos/rust-lang/rust/commits/90cbc858e983e302d97f2bd72be7af9a94def51a", "html_url": "https://github.com/rust-lang/rust/commit/90cbc858e983e302d97f2bd72be7af9a94def51a"}], "stats": {"total": 88, "additions": 78, "deletions": 10}, "files": [{"sha": "c41c0a8681beb806c6a12e565324e8019381e43b", "filename": "src/utils.rs", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fb6b3bed0fc5701287035fc9c445a202e492a0d8/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb6b3bed0fc5701287035fc9c445a202e492a0d8/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=fb6b3bed0fc5701287035fc9c445a202e492a0d8", "patch": "@@ -1,20 +1,20 @@\n-use rustc::lint::*;\n-use rustc_front::hir::*;\n+use consts::constant;\n use reexport::*;\n-use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use rustc::front::map::Node::*;\n+use rustc::lint::*;\n use rustc::middle::def_id::DefId;\n-use rustc::middle::ty;\n+use rustc::middle::{cstore, def, infer, ty, traits};\n+use rustc::session::Session;\n+use rustc_front::hir::*;\n use std::borrow::Cow;\n+use std::mem;\n+use std::ops::{Deref, DerefMut};\n+use std::str::FromStr;\n use syntax::ast::Lit_::*;\n use syntax::ast;\n+use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n-use consts::constant;\n-\n-use rustc::session::Session;\n-use std::str::FromStr;\n-use std::ops::{Deref, DerefMut};\n \n pub type MethodArgs = HirVec<P<Expr>>;\n \n@@ -23,6 +23,7 @@ pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n pub const BTREEMAP_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n pub const CLONE_PATH: [&'static str; 2] = [\"Clone\", \"clone\"];\n pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n+pub const DEFAULT_TRAIT_PATH: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n@@ -132,7 +133,7 @@ pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     }\n }\n \n-/// Check if the method call given in `expr` belongs to given trait.\n+/// Check if the method call given in `expr` belongs to given type.\n pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n \n@@ -186,6 +187,73 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n }\n \n+/// Get the definition associated to a path.\n+/// TODO: investigate if there is something more efficient for that.\n+pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<cstore::DefLike> {\n+    let cstore = &cx.tcx.sess.cstore;\n+\n+    let crates = cstore.crates();\n+    let krate = crates.iter().find(|&&krate| cstore.crate_name(krate) == path[0]);\n+    if let Some(krate) = krate {\n+        let mut items = cstore.crate_top_level_items(*krate);\n+        let mut path_it = path.iter().skip(1).peekable();\n+\n+        loop {\n+            let segment = match path_it.next() {\n+                Some(segment) => segment,\n+                None => return None\n+            };\n+\n+            for item in &mem::replace(&mut items, vec![]) {\n+                if item.name.as_str() == *segment {\n+                    if path_it.peek().is_none() {\n+                        return Some(item.def);\n+                    }\n+\n+                    let def_id = match item.def {\n+                        cstore::DefLike::DlDef(def) => def.def_id(),\n+                        cstore::DefLike::DlImpl(def_id) => def_id,\n+                        _ => panic!(\"Unexpected {:?}\", item.def),\n+                    };\n+\n+                    items = cstore.item_children(def_id);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    else {\n+        None\n+    }\n+}\n+\n+/// Convenience function to get the `DefId` of a trait by path.\n+pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n+    let def = match path_to_def(cx, path) {\n+        Some(def) => def,\n+        None => return None,\n+    };\n+\n+    match def {\n+        cstore::DlDef(def::DefTrait(trait_id)) => Some(trait_id),\n+        _ => None,\n+    }\n+}\n+\n+/// Check whether a type implements a trait.\n+/// See also `get_trait_def_id`.\n+pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, trait_id: DefId) -> bool {\n+    cx.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n+\n+    let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, None, true);\n+    let obligation = traits::predicate_for_trait_def(cx.tcx,\n+                                                     traits::ObligationCause::dummy(),\n+                                                     trait_id, 0, ty,\n+                                                     vec![]);\n+\n+    traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n+}\n+\n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n ///\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,"}]}