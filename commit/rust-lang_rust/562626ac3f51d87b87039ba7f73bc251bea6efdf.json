{"sha": "562626ac3f51d87b87039ba7f73bc251bea6efdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MjYyNmFjM2Y1MWQ4N2I4NzAzOWJhN2Y3M2JjMjUxYmVhNmVmZGY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-02-25T07:54:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-25T07:54:41Z"}, "message": "Rollup merge of #48115 - Centril:feature/iterator_flatten, r=alexcrichton\n\nAdd Iterator::flatten\n\nThis adds the trait method `.flatten()` on `Iterator` which flattens one level of nesting from an iterator or (into)iterators. The method `.flat_fmap(f)` is then redefined as `.map(f).flatten()`. The implementation of `Flatten` is essentially that of what it was for `FlatMap` but removing the call to `f` at various places.\n\nHopefully the type alias approach should be OK as was indicated / alluded to by @bluss and @eddyb in https://github.com/rust-lang/rfcs/pull/2306#issuecomment-361391370.\n\ncc @scottmcm", "tree": {"sha": "bc6e4474ca7b46f1a128fecd7d5ba9e61cf8631c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc6e4474ca7b46f1a128fecd7d5ba9e61cf8631c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/562626ac3f51d87b87039ba7f73bc251bea6efdf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJakmvBCRBK7hj4Ov3rIwAAdHIIAK+7+hoj3RpvXS60B988LNhm\nTbFu9wvWxgYpSkABHLQlpAmtKEtZIIDeRVc8uidBcxRwl/fgbCZVIJ/pfq5xQTiM\ntgU87w9APQy09QwioNVVgwAO8e23iJcV7u4sYKbZ0zMPdWXGR9mAYtJPHMYV6bKi\noRyKtDu7O0ZQyewa7ogvfzkcAB2uov9wNQjonUIrXGyPwATkmRTmuVK9WHkV2yUb\nSPrBcHKVM9GiUkgTtKpABrjd8rBqe2Bf2su07GJeypmQBxN+Ct7LtgrTJu0z1UjU\nwtxTzFpQRh82Y3Py1iHzuaO5KULgecADl4HgZcaJR9CXfxyZa0VHtuDpK/ntqlo=\n=zKQb\n-----END PGP SIGNATURE-----\n", "payload": "tree bc6e4474ca7b46f1a128fecd7d5ba9e61cf8631c\nparent 725856d67fafcb19901dfa033d52f38d1994dc17\nparent 819d57abc94d162e0d6f58fcbed757849f8305b4\nauthor kennytm <kennytm@gmail.com> 1519545281 +0800\ncommitter GitHub <noreply@github.com> 1519545281 +0800\n\nRollup merge of #48115 - Centril:feature/iterator_flatten, r=alexcrichton\n\nAdd Iterator::flatten\n\nThis adds the trait method `.flatten()` on `Iterator` which flattens one level of nesting from an iterator or (into)iterators. The method `.flat_fmap(f)` is then redefined as `.map(f).flatten()`. The implementation of `Flatten` is essentially that of what it was for `FlatMap` but removing the call to `f` at various places.\n\nHopefully the type alias approach should be OK as was indicated / alluded to by @bluss and @eddyb in https://github.com/rust-lang/rfcs/pull/2306#issuecomment-361391370.\n\ncc @scottmcm\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/562626ac3f51d87b87039ba7f73bc251bea6efdf", "html_url": "https://github.com/rust-lang/rust/commit/562626ac3f51d87b87039ba7f73bc251bea6efdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/562626ac3f51d87b87039ba7f73bc251bea6efdf/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "725856d67fafcb19901dfa033d52f38d1994dc17", "url": "https://api.github.com/repos/rust-lang/rust/commits/725856d67fafcb19901dfa033d52f38d1994dc17", "html_url": "https://github.com/rust-lang/rust/commit/725856d67fafcb19901dfa033d52f38d1994dc17"}, {"sha": "819d57abc94d162e0d6f58fcbed757849f8305b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/819d57abc94d162e0d6f58fcbed757849f8305b4", "html_url": "https://github.com/rust-lang/rust/commit/819d57abc94d162e0d6f58fcbed757849f8305b4"}], "stats": {"total": 403, "additions": 367, "deletions": 36}, "files": [{"sha": "9d8a71250f88ad508c561d08d05d9e45ea1079e5", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=562626ac3f51d87b87039ba7f73bc251bea6efdf", "patch": "@@ -12,7 +12,8 @@ use cmp::Ordering;\n use ops::Try;\n \n use super::{AlwaysOk, LoopState};\n-use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse};\n+use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, Fuse};\n+use super::{Flatten, FlatMap, flatten_compat};\n use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n use super::{Zip, Sum, Product};\n use super::{ChainState, FromIterator, ZipImpl};\n@@ -997,11 +998,15 @@ pub trait Iterator {\n     /// an extra layer of indirection. `flat_map()` will remove this extra layer\n     /// on its own.\n     ///\n+    /// You can think of [`flat_map(f)`][flat_map] as the semantic equivalent\n+    /// of [`map`]ping, and then [`flatten`]ing as in `map(f).flatten()`.\n+    ///\n     /// Another way of thinking about `flat_map()`: [`map`]'s closure returns\n     /// one item for each element, and `flat_map()`'s closure returns an\n     /// iterator for each element.\n     ///\n     /// [`map`]: #method.map\n+    /// [`flatten`]: #method.flatten\n     ///\n     /// # Examples\n     ///\n@@ -1021,7 +1026,79 @@ pub trait Iterator {\n     fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n         where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -> U,\n     {\n-        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n+        FlatMap { inner: flatten_compat(self.map(f)) }\n+    }\n+\n+    /// Creates an iterator that flattens nested structure.\n+    ///\n+    /// This is useful when you have an iterator of iterators or an iterator of\n+    /// things that can be turned into iterators and you want to remove one\n+    /// level of indirection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_flatten)]\n+    ///\n+    /// let data = vec![vec![1, 2, 3, 4], vec![5, 6]];\n+    /// let flattened = data.into_iter().flatten().collect::<Vec<u8>>();\n+    /// assert_eq!(flattened, &[1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    ///\n+    /// Mapping and then flattening:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_flatten)]\n+    ///\n+    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n+    /// let merged: String = words.iter()\n+    ///                           .map(|s| s.chars())\n+    ///                           .flatten()\n+    ///                           .collect();\n+    /// assert_eq!(merged, \"alphabetagamma\");\n+    /// ```\n+    ///\n+    /// You can also rewrite this in terms of [`flat_map()`] which is preferable\n+    /// in this case since that conveys intent clearer:\n+    ///\n+    /// ```\n+    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n+    /// let merged: String = words.iter()\n+    ///                           .flat_map(|s| s.chars())\n+    ///                           .collect();\n+    /// assert_eq!(merged, \"alphabetagamma\");\n+    /// ```\n+    ///\n+    /// Flattening once only removes one level of nesting:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_flatten)]\n+    ///\n+    /// let d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];\n+    ///\n+    /// let d2 = d3.iter().flatten().collect::<Vec<_>>();\n+    /// assert_eq!(d2, [&[1, 2], &[3, 4], &[5, 6], &[7, 8]]);\n+    ///\n+    /// let d1 = d3.iter().flatten().flatten().collect::<Vec<_>>();\n+    /// assert_eq!(d1, [&1, &2, &3, &4, &5, &6, &7, &8]);\n+    /// ```\n+    ///\n+    /// Here we see that `flatten()` does not perform a \"deep\" flatten.\n+    /// Instead, only one level of nesting is removed. That is, if you\n+    /// `flatten()` a three-dimensional array the result will be\n+    /// two-dimensional and not one-dimensional. To get a one-dimensional\n+    /// structure, you have to `flatten()` again.\n+    #[inline]\n+    #[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+    fn flatten(self) -> Flatten<Self>\n+    where Self: Sized, Self::Item: IntoIterator {\n+        Flatten { inner: flatten_compat(self) }\n     }\n \n     /// Creates an iterator which ends after the first [`None`]."}, {"sha": "623cad754dd7274221efea7a9a7a22c4a9b314ba", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 179, "deletions": 34, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=562626ac3f51d87b87039ba7f73bc251bea6efdf", "patch": "@@ -2410,24 +2410,23 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n /// [`Iterator`]: trait.Iterator.html\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n pub struct FlatMap<I, U: IntoIterator, F> {\n-    iter: I,\n-    f: F,\n-    frontiter: Option<U::IntoIter>,\n-    backiter: Option<U::IntoIter>,\n+    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n+    where <U as IntoIterator>::IntoIter: Clone\n+{\n+    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n     where U::IntoIter: fmt::Debug\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FlatMap\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"frontiter\", &self.frontiter)\n-            .field(\"backiter\", &self.backiter)\n-            .finish()\n+        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n     }\n }\n \n@@ -2437,17 +2436,173 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n {\n     type Item = U::Item;\n \n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+          U: IntoIterator,\n+          U::IntoIter: DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n+    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n+\n+/// An iterator that flattens one level of nesting in an iterator of things\n+/// that can be turned into iterators.\n+///\n+/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flatten`]: trait.Iterator.html#method.flatten\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+pub struct Flatten<I: Iterator>\n+where I::Item: IntoIterator {\n+    inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> fmt::Debug for Flatten<I>\n+    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> Clone for Flatten<I>\n+    where I: Iterator + Clone, U: Iterator + Clone,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> Iterator for Flatten<I>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"48213\")]\n+impl<I, U> DoubleEndedIterator for Flatten<I>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<I, U> FusedIterator for Flatten<I>\n+    where I: FusedIterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n+\n+/// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n+fn flatten_compat<I, U>(iter: I) -> FlattenCompat<I, U> {\n+    FlattenCompat { iter, frontiter: None, backiter: None }\n+}\n+\n+/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n+/// this type.\n+#[derive(Clone, Debug)]\n+struct FlattenCompat<I, U> {\n+    iter: I,\n+    frontiter: Option<U>,\n+    backiter: Option<U>,\n+}\n+\n+impl<I, U> Iterator for FlattenCompat<I, U>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n     #[inline]\n     fn next(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.frontiter {\n-                if let Some(x) = inner.by_ref().next() {\n-                    return Some(x)\n-                }\n+                if let elt@Some(_) = inner.next() { return elt }\n             }\n-            match self.iter.next().map(&mut self.f) {\n+            match self.iter.next() {\n                 None => return self.backiter.as_mut().and_then(|it| it.next()),\n-                next => self.frontiter = next.map(IntoIterator::into_iter),\n+                Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n     }\n@@ -2473,10 +2628,9 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n         self.frontiter = None;\n \n         {\n-            let f = &mut self.f;\n             let frontiter = &mut self.frontiter;\n             init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = f(x).into_iter();\n+                let mut mid = x.into_iter();\n                 let r = mid.try_fold(acc, &mut fold);\n                 *frontiter = Some(mid);\n                 r\n@@ -2497,27 +2651,23 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.frontiter.into_iter()\n-            .chain(self.iter.map(self.f).map(U::into_iter))\n+            .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> where\n-    F: FnMut(I::Item) -> U,\n-    U: IntoIterator,\n-    U::IntoIter: DoubleEndedIterator\n+impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.backiter {\n-                if let Some(y) = inner.next_back() {\n-                    return Some(y)\n-                }\n+                if let elt@Some(_) = inner.next_back() { return elt }\n             }\n-            match self.iter.next_back().map(&mut self.f) {\n+            match self.iter.next_back() {\n                 None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n                 next => self.backiter = next.map(IntoIterator::into_iter),\n             }\n@@ -2534,10 +2684,9 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n         self.backiter = None;\n \n         {\n-            let f = &mut self.f;\n             let backiter = &mut self.backiter;\n             init = self.iter.try_rfold(init, |acc, x| {\n-                let mut mid = f(x).into_iter();\n+                let mut mid = x.into_iter();\n                 let r = mid.try_rfold(acc, &mut fold);\n                 *backiter = Some(mid);\n                 r\n@@ -2558,16 +2707,12 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.frontiter.into_iter()\n-            .chain(self.iter.map(self.f).map(U::into_iter))\n+            .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n-    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n-\n /// An iterator that yields `None` forever after the underlying iterator\n /// yields `None` once.\n ///"}, {"sha": "3dd30ee1c69e235a5ba2ac9685cf4751d0825fa3", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=562626ac3f51d87b87039ba7f73bc251bea6efdf", "patch": "@@ -93,6 +93,7 @@\n #![feature(doc_spotlight)]\n #![feature(rustc_const_unstable)]\n #![feature(iterator_repeat_with)]\n+#![feature(iterator_flatten)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "edd75f7795ed7cf18ec33575b142feff40070367", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=562626ac3f51d87b87039ba7f73bc251bea6efdf", "patch": "@@ -874,6 +874,44 @@ fn test_iterator_flat_map_fold() {\n     assert_eq!(i, 0);\n }\n \n+#[test]\n+fn test_iterator_flatten() {\n+    let xs = [0, 3, 6];\n+    let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let it = xs.iter().map(|&x| (x..).step_by(1).take(3)).flatten();\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+/// Test `Flatten::fold` with items already picked off the front and back,\n+/// to make sure all parts of the `Flatten` are folded correctly.\n+#[test]\n+fn test_iterator_flatten_fold() {\n+    let xs = [0, 3, 6];\n+    let ys = [1, 2, 3, 4, 5, 6, 7];\n+    let mut it = xs.iter().map(|&x| x..x+3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().map(|&x| x..x+3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_inspect() {\n     let xs = [1, 2, 3, 4];\n@@ -1287,6 +1325,23 @@ fn test_double_ended_flat_map() {\n     assert_eq!(it.next_back(), None);\n }\n \n+#[test]\n+fn test_double_ended_flatten() {\n+    let u = [0,1];\n+    let v = [5,6,7,8];\n+    let mut it = u.iter().map(|x| &v[*x..v.len()]).flatten();\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &6);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(),      None);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n #[test]\n fn test_double_ended_range() {\n     assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n@@ -1978,3 +2033,54 @@ fn test_flat_map_try_folds() {\n     assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n     assert_eq!(iter.next_back(), Some(35));\n }\n+\n+#[test]\n+fn test_flatten_try_folds() {\n+    let f = &|acc, x| i32::checked_add(acc*2/3, x);\n+    let mr = &|x| (5*x)..(5*x + 5);\n+    assert_eq!((0..10).map(mr).flatten().try_fold(7, f), (0..50).try_fold(7, f));\n+    assert_eq!((0..10).map(mr).flatten().try_rfold(7, f), (0..50).try_rfold(7, f));\n+    let mut iter = (0..10).map(mr).flatten();\n+    iter.next(); iter.next_back(); // have front and back iters in progress\n+    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n+\n+    let mut iter = (0..10).map(|x| (4*x)..(4*x + 4)).flatten();\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(17));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(35));\n+}\n+\n+#[test]\n+fn test_functor_laws() {\n+    // identity:\n+    fn identity<T>(x: T) -> T { x }\n+    assert_eq!((0..10).map(identity).sum::<usize>(), (0..10).sum());\n+\n+    // composition:\n+    fn f(x: usize) -> usize { x + 3 }\n+    fn g(x: usize) -> usize { x * 2 }\n+    fn h(x: usize) -> usize { g(f(x)) }\n+    assert_eq!((0..10).map(f).map(g).sum::<usize>(), (0..10).map(h).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_left_identity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> {\n+        (0..10).map(move |y| x * y)\n+    }\n+    assert_eq!(once(42).flat_map(f.clone()).sum::<usize>(), f(42).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_right_identity() {\n+    assert_eq!((0..10).flat_map(|x| once(x)).sum::<usize>(), (0..10).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_associativity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> { 0..x }\n+    fn g(x: usize) -> impl Iterator<Item = usize> { (0..x).rev() }\n+    assert_eq!((0..10).flat_map(f).flat_map(g).sum::<usize>(),\n+                (0..10).flat_map(|x| f(x).flat_map(g)).sum::<usize>());\n+}"}, {"sha": "7954d52f6b1e368f64b4a309fe08b4baea5f6d15", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562626ac3f51d87b87039ba7f73bc251bea6efdf/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=562626ac3f51d87b87039ba7f73bc251bea6efdf", "patch": "@@ -25,6 +25,8 @@\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![feature(iterator_try_fold)]\n+#![feature(iterator_flatten)]\n+#![feature(conservative_impl_trait)]\n #![feature(iter_rfind)]\n #![feature(iter_rfold)]\n #![feature(iterator_repeat_with)]"}]}