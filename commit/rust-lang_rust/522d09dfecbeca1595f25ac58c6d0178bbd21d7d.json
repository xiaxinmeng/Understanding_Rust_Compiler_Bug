{"sha": "522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMmQwOWRmZWNiZWNhMTU5NWYyNWFjNThjNmQwMTc4YmJkMjFkN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-19T18:36:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-19T18:36:59Z"}, "message": "Auto merge of #22541 - Manishearth:rollup, r=Gankro\n\nContinued from #22520", "tree": {"sha": "cc0252dd3413e5f890d0ebcfdaa096e5b002be0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc0252dd3413e5f890d0ebcfdaa096e5b002be0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "html_url": "https://github.com/rust-lang/rust/commit/522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b664bb8436f2cfda7f13a6f302ab486f332816f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b664bb8436f2cfda7f13a6f302ab486f332816f", "html_url": "https://github.com/rust-lang/rust/commit/0b664bb8436f2cfda7f13a6f302ab486f332816f"}, {"sha": "49771bafa5fca16486bfd06741dac3de2c587adf", "url": "https://api.github.com/repos/rust-lang/rust/commits/49771bafa5fca16486bfd06741dac3de2c587adf", "html_url": "https://github.com/rust-lang/rust/commit/49771bafa5fca16486bfd06741dac3de2c587adf"}], "stats": {"total": 16923, "additions": 12327, "deletions": 4596}, "files": [{"sha": "b6a73730d351cc9f37c39a0fdc8d49bb59e75aca", "filename": "README.md", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -1,14 +1,16 @@\n # The Rust Programming Language\n \n This is a compiler for Rust, including standard libraries, tools and\n-documentation.\n+documentation. Rust is a systems programming language that is fast,\n+memory safe and multithreaded, but does not employ a garbage collector\n+or otherwise impose significant runtime overhead.\n \n ## Quick Start\n \n-Read [\"Installing Rust\"][install] from [The Book][trpl].\n+Read [\"Installing Rust\"] from [The Book].\n \n-[install]: http://doc.rust-lang.org/book/installing-rust.html\n-[trpl]: http://doc.rust-lang.org/book/index.html\n+[\"Installing Rust\"]: http://doc.rust-lang.org/book/installing-rust.html\n+[The Book]: http://doc.rust-lang.org/book/index.html\n \n ## Building from Source\n \n@@ -19,22 +21,14 @@ Read [\"Installing Rust\"][install] from [The Book][trpl].\n     * `curl`\n     * `git`\n \n-2. Download and build Rust:\n-\n-    You can either download a [tarball] or build directly from the [repo].\n-\n-    To build from the [tarball] do:\n-\n-        $ curl -O https://static.rust-lang.org/dist/rustc-nightly-src.tar.gz\n-        $ tar -xzf rustc-nightly-src.tar.gz\n-        $ cd rustc-nightly\n-\n-    Or to build from the [repo] do:\n+2. Clone the [source] with `git`:\n \n         $ git clone https://github.com/rust-lang/rust.git\n         $ cd rust\n \n-    Now that you have Rust's source code, you can configure and build it:\n+[source]: https://github.com/rust-lang/rust\n+\n+3. Build and install:\n \n         $ ./configure\n         $ make && make install\n@@ -46,7 +40,10 @@ Read [\"Installing Rust\"][install] from [The Book][trpl].\n \n     When complete, `make install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n-    API-documentation tool.\n+    API-documentation tool. This install does not include [Cargo],\n+    Rust's package manager, which you may also want to build.\n+\n+[Cargo]: https://github.com/rust-lang/cargo\n \n ### Building on Windows\n \n@@ -72,9 +69,6 @@ $ pacman -S base-devel\n         $ ./configure\n         $ make && make install\n \n-[repo]: https://github.com/rust-lang/rust\n-[tarball]: https://static.rust-lang.org/dist/rustc-nightly-src.tar.gz\n-\n ## Notes\n \n Since the Rust compiler is written in Rust, it must be built by a\n@@ -94,9 +88,9 @@ supported build environments that are most likely to work.\n Rust currently needs about 1.5 GiB of RAM to build without swapping; if it hits\n swap, it will take a very long time to build.\n \n-There is a lot more documentation in the [wiki].\n+There is more advice about hacking on Rust in [CONTRIBUTING.md].\n \n-[wiki]: https://github.com/rust-lang/rust/wiki\n+[CONTRIBUTING.md]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md\n \n ## Getting help\n \n@@ -114,6 +108,14 @@ The Rust community congregates in a few places:\n \n To contribute to Rust, please see [CONTRIBUTING.md](CONTRIBUTING.md).\n \n+Rust has an [IRC] culture and most real-time collaboration happens in a\n+variety of channels on Mozilla's IRC network, irc.mozilla.org. The\n+most popular channel is [#rust], a venue for general discussion about\n+Rust, and a good place to ask for help,\n+\n+[IRC]: https://en.wikipedia.org/wiki/Internet_Relay_Chat\n+[#rust]: irc://irc.mozilla.org/rust\n+\n ## License\n \n Rust is primarily distributed under the terms of both the MIT license"}, {"sha": "d1b27a96f93b9caf7da8a4fbb9ac0b9e06a24a63", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/configure", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -1056,6 +1056,7 @@ do\n     make_dir $h/test/run-pass-fulldeps\n     make_dir $h/test/run-fail\n     make_dir $h/test/compile-fail\n+    make_dir $h/test/parse-fail\n     make_dir $h/test/compile-fail-fulldeps\n     make_dir $h/test/bench\n     make_dir $h/test/perf"}, {"sha": "692d28bfad3d56c5e5cba49ea9489b7268bb45b1", "filename": "mk/tests.mk", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -174,12 +174,12 @@ check-notidy: cleantmptestlogs cleantestlibs all check-stage2\n check-lite: cleantestlibs cleantmptestlogs \\\n \t$(foreach crate,$(TEST_TARGET_CRATES),check-stage2-$(crate)) \\\n \tcheck-stage2-rpass check-stage2-rpass-valgrind \\\n-\tcheck-stage2-rfail check-stage2-cfail check-stage2-rmake\n+\tcheck-stage2-rfail check-stage2-cfail check-stage2-pfail check-stage2-rmake\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n \n # Only check the 'reference' tests: rpass/cfail/rfail/rmake.\n check-ref: cleantestlibs cleantmptestlogs check-stage2-rpass check-stage2-rpass-valgrind \\\n-\tcheck-stage2-rfail check-stage2-cfail check-stage2-rmake\n+\tcheck-stage2-rfail check-stage2-cfail check-stage2-pfail check-stage2-rmake\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n \n # Only check the docs.\n@@ -291,6 +291,7 @@ check-stage$(1)-T-$(2)-H-$(3)-exec: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rpass-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rfail-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-cfail-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-pfail-exec \\\n     check-stage$(1)-T-$(2)-H-$(3)-rpass-valgrind-exec \\\n     check-stage$(1)-T-$(2)-H-$(3)-rpass-full-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-cfail-full-exec \\\n@@ -470,7 +471,8 @@ RPASS_VALGRIND_TESTS := $(RPASS_VALGRIND_RS)\n RPASS_FULL_TESTS := $(RPASS_FULL_RS)\n CFAIL_FULL_TESTS := $(CFAIL_FULL_RS)\n RFAIL_TESTS := $(RFAIL_RS)\n-CFAIL_TESTS := $(CFAIL_RS) $(PFAIL_RS)\n+CFAIL_TESTS := $(CFAIL_RS)\n+PFAIL_TESTS := $(PFAIL_RS)\n BENCH_TESTS := $(BENCH_RS)\n PERF_TESTS := $(PERF_RS)\n PRETTY_TESTS := $(PRETTY_RS)\n@@ -508,6 +510,11 @@ CTEST_BUILD_BASE_cfail = compile-fail\n CTEST_MODE_cfail = compile-fail\n CTEST_RUNTOOL_cfail = $(CTEST_RUNTOOL)\n \n+CTEST_SRC_BASE_pfail = parse-fail\n+CTEST_BUILD_BASE_pfail = parse-fail\n+CTEST_MODE_pfail = parse-fail\n+CTEST_RUNTOOL_pfail = $(CTEST_RUNTOOL)\n+\n CTEST_SRC_BASE_bench = bench\n CTEST_BUILD_BASE_bench = bench\n CTEST_MODE_bench = run-pass\n@@ -630,6 +637,7 @@ CTEST_DEPS_rpass-full_$(1)-T-$(2)-H-$(3) = $$(RPASS_FULL_TESTS) $$(CSREQ$(1)_T_$\n CTEST_DEPS_cfail-full_$(1)-T-$(2)-H-$(3) = $$(CFAIL_FULL_TESTS) $$(CSREQ$(1)_T_$(3)_H_$(3)) $$(SREQ$(1)_T_$(2)_H_$(3))\n CTEST_DEPS_rfail_$(1)-T-$(2)-H-$(3) = $$(RFAIL_TESTS)\n CTEST_DEPS_cfail_$(1)-T-$(2)-H-$(3) = $$(CFAIL_TESTS)\n+CTEST_DEPS_pfail_$(1)-T-$(2)-H-$(3) = $$(PFAIL_TESTS)\n CTEST_DEPS_bench_$(1)-T-$(2)-H-$(3) = $$(BENCH_TESTS)\n CTEST_DEPS_perf_$(1)-T-$(2)-H-$(3) = $$(PERF_TESTS)\n CTEST_DEPS_debuginfo-gdb_$(1)-T-$(2)-H-$(3) = $$(DEBUGINFO_GDB_TESTS)\n@@ -698,7 +706,7 @@ endif\n \n endef\n \n-CTEST_NAMES = rpass rpass-valgrind rpass-full cfail-full rfail cfail bench perf debuginfo-gdb debuginfo-lldb codegen\n+CTEST_NAMES = rpass rpass-valgrind rpass-full cfail-full rfail cfail pfail bench perf debuginfo-gdb debuginfo-lldb codegen\n \n $(foreach host,$(CFG_HOST), \\\n  $(eval $(foreach target,$(CFG_TARGET), \\\n@@ -857,6 +865,7 @@ TEST_GROUPS = \\\n \tcfail-full \\\n \trfail \\\n \tcfail \\\n+\tpfail \\\n \tbench \\\n \tperf \\\n \trmake \\"}, {"sha": "2c046d252799ee02338b399fb4e38a1b1cae75e4", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -15,6 +15,7 @@ use std::str::FromStr;\n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Mode {\n     CompileFail,\n+    ParseFail,\n     RunFail,\n     RunPass,\n     RunPassValgrind,\n@@ -29,6 +30,7 @@ impl FromStr for Mode {\n     fn from_str(s: &str) -> Result<Mode, ()> {\n         match s {\n           \"compile-fail\" => Ok(CompileFail),\n+          \"parse-fail\" => Ok(ParseFail),\n           \"run-fail\" => Ok(RunFail),\n           \"run-pass\" => Ok(RunPass),\n           \"run-pass-valgrind\" => Ok(RunPassValgrind),\n@@ -45,6 +47,7 @@ impl fmt::Display for Mode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(match *self {\n             CompileFail => \"compile-fail\",\n+            ParseFail => \"parse-fail\",\n             RunFail => \"run-fail\",\n             RunPass => \"run-pass\",\n             RunPassValgrind => \"run-pass-valgrind\","}, {"sha": "278ce5565d9fc38d8ce9bec899e5fcf3109d0ab1", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -21,6 +21,7 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(env)]\n+#![feature(core)]\n \n #![deny(warnings)]\n \n@@ -72,7 +73,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           reqopt(\"\", \"aux-base\", \"directory to find auxiliary test files\", \"PATH\"),\n           reqopt(\"\", \"stage-id\", \"the target-stage identifier\", \"stageN-TARGET\"),\n           reqopt(\"\", \"mode\", \"which sort of compile tests to run\",\n-                 \"(compile-fail|run-fail|run-pass|run-pass-valgrind|pretty|debug-info)\"),\n+                 \"(compile-fail|parse-fail|run-fail|run-pass|run-pass-valgrind|pretty|debug-info)\"),\n           optflag(\"\", \"ignored\", \"run tests marked as ignored\"),\n           optopt(\"\", \"runtool\", \"supervisor program to run tests under \\\n                                  (eg. emulator, valgrind)\", \"PROGRAM\"),"}, {"sha": "1cbb8742bbc5ae511b89c812ecd115d869501c5b", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -11,7 +11,7 @@\n use self::TargetLocation::*;\n \n use common::Config;\n-use common::{CompileFail, Pretty, RunFail, RunPass, RunPassValgrind, DebugInfoGdb};\n+use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind, DebugInfoGdb};\n use common::{Codegen, DebugInfoLldb};\n use errors;\n use header::TestProps;\n@@ -66,6 +66,7 @@ pub fn run_metrics(config: Config, testfile: String, mm: &mut MetricMap) {\n     debug!(\"loaded props\");\n     match config.mode {\n       CompileFail => run_cfail_test(&config, &props, &testfile),\n+      ParseFail => run_cfail_test(&config, &props, &testfile),\n       RunFail => run_rfail_test(&config, &props, &testfile),\n       RunPass => run_rpass_test(&config, &props, &testfile),\n       RunPassValgrind => run_valgrind_test(&config, &props, &testfile),\n@@ -88,7 +89,7 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = compile_test(config, props, testfile);\n \n     if proc_res.status.success() {\n-        fatal_proc_rec(\"compile-fail test compiled successfully!\",\n+        fatal_proc_rec(&format!(\"{} test compiled successfully!\", config.mode)[],\n                       &proc_res);\n     }\n \n@@ -688,7 +689,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                                                .unwrap()\n                                                .to_string();\n \n-    script_str.push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[])[]);\n+    script_str.push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[..])[]);\n     script_str.push_str(\"type summary add --no-value \");\n     script_str.push_str(\"--python-function lldb_rust_formatters.print_val \");\n     script_str.push_str(\"-x \\\".*\\\" --category Rust\\n\");\n@@ -1133,7 +1134,7 @@ fn compile_test_(config: &Config, props: &TestProps,\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let mut link_args = vec!(\"-L\".to_string(),\n                              aux_dir.as_str().unwrap().to_string());\n-    link_args.extend(extra_args.iter().map(|s| s.clone()));\n+    link_args.extend(extra_args.iter().cloned());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,"}, {"sha": "db940947040d48f41c4811bb46c4aca7e8ae1244", "filename": "src/doc/reference.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -572,7 +572,7 @@ the final namespace qualifier is omitted.\n Two examples of paths with type arguments:\n \n ```\n-# struct HashMap<K, V>;\n+# struct HashMap<K, V>(K,V);\n # fn f() {\n # fn id<T>(t: T) -> T { t }\n type T = HashMap<i32,String>; // Type arguments used in a type expression\n@@ -1599,7 +1599,7 @@ pointer values (pointing to a type for which an implementation of the given\n trait is in scope) to pointers to the trait name, used as a type.\n \n ```\n-# trait Shape { }\n+# trait Shape { fn dummy(&self) { } }\n # impl Shape for i32 { }\n # let mycircle = 0i32;\n let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n@@ -1630,8 +1630,8 @@ let x: f64 = Num::from_i32(42);\n Traits may inherit from other traits. For example, in\n \n ```\n-trait Shape { fn area() -> f64; }\n-trait Circle : Shape { fn radius() -> f64; }\n+trait Shape { fn area(&self) -> f64; }\n+trait Circle : Shape { fn radius(&self) -> f64; }\n ```\n \n the syntax `Circle : Shape` means that types that implement `Circle` must also\n@@ -1725,7 +1725,7 @@ type parameters taken by the trait it implements. Implementation parameters\n are written after the `impl` keyword.\n \n ```\n-# trait Seq<T> { }\n+# trait Seq<T> { fn dummy(&self, _: T) { } }\n impl<T> Seq<T> for Vec<T> {\n    /* ... */\n }\n@@ -3583,7 +3583,7 @@ An example of each kind:\n ```{rust}\n let vec: Vec<i32> = vec![1, 2, 3];\n let arr: [i32; 3] = [1, 2, 3];\n-let s: &[i32] = &vec[];\n+let s: &[i32] = &vec[..];\n ```\n \n As you can see, the `vec!` macro allows you to create a `Vec<T>` easily. The"}, {"sha": "97e826579fd9bbc473c13c6d2d0bd4c7db0e0ead", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -435,8 +435,8 @@ extern {\n }\n \n fn main() {\n-    let prompt = CString::from_slice(b\"[my-awesome-shell] $\");\n-    unsafe { \n+    let prompt = CString::new(\"[my-awesome-shell] $\").unwrap();\n+    unsafe {\n         rl_prompt = prompt.as_ptr();\n \n         println!(\"{:?}\", rl_prompt);\n@@ -541,6 +541,6 @@ pub extern fn hello_rust() -> *const u8 {\n \n The `extern` makes this function adhere to the C calling convention, as\n discussed above in \"[Foreign Calling\n-Conventions](guide-ffi.html#foreign-calling-conventions)\". The `no_mangle`\n+Conventions](ffi.html#foreign-calling-conventions)\". The `no_mangle`\n attribute turns off Rust's name mangling, so that it is easier to link to.\n "}, {"sha": "9e82e48fd18b7f1fe829d33e7e1eb1b799226f3c", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -180,7 +180,7 @@ If you want to match against a slice or array, you can use `&`:\n fn main() {\n     let v = vec![\"match_this\", \"1\"];\n \n-    match &v[] {\n+    match &v[..] {\n         [\"match_this\", second] => println!(\"The second element is {}\", second),\n         _ => {},\n     }"}, {"sha": "934e6ab2159166bd9823779a88670684997731ae", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -73,7 +73,6 @@ use core::prelude::*;\n \n use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n-use core::borrow::BorrowFrom;\n use core::fmt;\n use core::cmp::{Ordering};\n use core::default::Default;\n@@ -244,12 +243,6 @@ impl<T> Clone for Arc<T> {\n     }\n }\n \n-impl<T> BorrowFrom<Arc<T>> for T {\n-    fn borrow_from(owned: &Arc<T>) -> &T {\n-        &**owned\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Arc<T> {\n     type Target = T;\n@@ -605,11 +598,19 @@ impl<T: Default + Sync + Send> Default for Arc<T> {\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n \n+#[cfg(stage0)]\n impl<H: Hasher, T: Hash<H>> Hash<H> for Arc<T> {\n     fn hash(&self, state: &mut H) {\n         (**self).hash(state)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Hash> Hash for Arc<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (**self).hash(state)\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "a3516bd667b7a18cb6e9f0653481511bc5f04779", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -10,13 +10,14 @@\n \n //! A pointer type for heap allocation.\n //!\n-//! `Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in\n-//! Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of\n-//! scope.\n+//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n+//! heap allocation in Rust. Boxes provide ownership for this allocation, and\n+//! drop their contents when they go out of scope.\n //!\n-//! Boxes are useful in two situations: recursive data structures, and occasionally when returning\n-//! data. [The Pointer chapter of the Book](../../../book/pointers.html#best-practices-1) explains\n-//! these cases in detail.\n+//! Boxes are useful in two situations: recursive data structures, and\n+//! occasionally when returning data. [The Pointer chapter of the\n+//! Book](../../../book/pointers.html#best-practices-1) explains these cases in\n+//! detail.\n //!\n //! # Examples\n //!\n@@ -58,8 +59,8 @@ use core::ops::{Deref, DerefMut};\n use core::ptr::Unique;\n use core::raw::TraitObject;\n \n-/// A value that represents the heap. This is the default place that the `box` keyword allocates\n-/// into when no place is supplied.\n+/// A value that represents the heap. This is the default place that the `box`\n+/// keyword allocates into when no place is supplied.\n ///\n /// The following two examples are equivalent:\n ///\n@@ -219,12 +220,20 @@ impl<T: ?Sized + Ord> Ord for Box<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n+#[cfg(stage0)]\n impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + Hash> Hash for Box<T> {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        (**self).hash(state);\n+    }\n+}\n \n /// Extension methods for an owning `Any` trait object.\n #[unstable(feature = \"alloc\","}, {"sha": "bc349ebebdeed0a317a30943c9aefa6142a096ff", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -73,7 +73,6 @@\n #![feature(unboxed_closures)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(core)]\n-#![feature(hash)]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n             feature(libc))]\n "}, {"sha": "9d39511543188736cd20c9935d80a9f0d3469e78", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -144,13 +144,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::borrow::BorrowFrom;\n use core::cell::Cell;\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n-use core::hash::{self, Hash};\n+use core::hash::{Hasher, Hash};\n use core::marker;\n use core::mem::{transmute, min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n@@ -349,12 +348,6 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n-impl<T> BorrowFrom<Rc<T>> for T {\n-    fn borrow_from(owned: &Rc<T>) -> &T {\n-        &**owned\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Deref for Rc<T> {\n     type Target = T;\n@@ -599,12 +592,20 @@ impl<T: Ord> Ord for Rc<T> {\n }\n \n // FIXME (#18248) Make `T` `Sized?`\n-impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n+#[cfg(stage0)]\n+impl<S: Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Hash> Hash for Rc<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (**self).hash(state);\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display> fmt::Display for Rc<T> {"}, {"sha": "b43f9adfb26d92ed9c8f8f4ee8df7bc634c0cb46", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -96,7 +96,7 @@ pub struct Arena<'longer_than_self> {\n     head: RefCell<Chunk>,\n     copy_head: RefCell<Chunk>,\n     chunks: RefCell<Vec<Chunk>>,\n-    _invariant: marker::InvariantLifetime<'longer_than_self>,\n+    _marker: marker::PhantomData<*mut &'longer_than_self()>,\n }\n \n impl<'a> Arena<'a> {\n@@ -111,7 +111,7 @@ impl<'a> Arena<'a> {\n             head: RefCell::new(chunk(initial_size, false)),\n             copy_head: RefCell::new(chunk(initial_size, true)),\n             chunks: RefCell::new(Vec::new()),\n-            _invariant: marker::InvariantLifetime,\n+            _marker: marker::PhantomData,\n         }\n     }\n }\n@@ -361,6 +361,8 @@ pub struct TypedArena<T> {\n }\n \n struct TypedArenaChunk<T> {\n+    marker: marker::PhantomData<T>,\n+\n     /// Pointer to the next arena segment.\n     next: *mut TypedArenaChunk<T>,\n "}, {"sha": "9f549fd7237711dce941f7ef0d37e0eec9e8db73", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -650,8 +650,8 @@ impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n-    fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BinaryHeap<T> {\n-        BinaryHeap::from_vec(iter.collect())\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> BinaryHeap<T> {\n+        BinaryHeap::from_vec(iter.into_iter().collect())\n     }\n }\n \n@@ -677,7 +677,8 @@ impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n-    fn extend<Iter: Iterator<Item=T>>(&mut self, iter: Iter) {\n+    fn extend<I: IntoIterator<Item=T>>(&mut self, iterable: I) {\n+        let iter = iterable.into_iter();\n         let (lower, _) = iter.size_hint();\n \n         self.reserve(lower);"}, {"sha": "11c576eab152551c274b9036b4ac99a5ee30ae39", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 554, "deletions": 524, "changes": 1078, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for\n-// maintenance), they should be in separate files/modules, with BitvSet only\n-// using Bitv's public API. This will be hard for performance though, because\n-// `Bitv` will not want to leak its internal representation while its internal\n+// FIXME(Gankro): BitVec and BitSet are very tightly coupled. Ideally (for\n+// maintenance), they should be in separate files/modules, with BitSet only\n+// using BitVec's public API. This will be hard for performance though, because\n+// `BitVec` will not want to leak its internal representation while its internal\n // representation as `u32`s must be assumed for best performance.\n \n-// FIXME(tbu-): `Bitv`'s methods shouldn't be `union`, `intersection`, but\n+// FIXME(tbu-): `BitVec`'s methods shouldn't be `union`, `intersection`, but\n // rather `or` and `and`.\n \n // (1) Be careful, most things can overflow here because the amount of bits in\n@@ -25,8 +25,8 @@\n //     methods rely on it (for *CORRECTNESS*).\n // (3) Make sure that the unused bits in the last word are zeroed out, again\n //     other methods rely on it for *CORRECTNESS*.\n-// (4) `BitvSet` is tightly coupled with `Bitv`, so any changes you make in\n-// `Bitv` will need to be reflected in `BitvSet`.\n+// (4) `BitSet` is tightly coupled with `BitVec`, so any changes you make in\n+// `BitVec` will need to be reflected in `BitSet`.\n \n //! Collections implemented with bit vectors.\n //!\n@@ -38,17 +38,17 @@\n //! [sieve]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n //!\n //! ```\n-//! use std::collections::{BitvSet, Bitv};\n+//! use std::collections::{BitSet, BitVec};\n //! use std::num::Float;\n //! use std::iter;\n //!\n //! let max_prime = 10000;\n //!\n-//! // Store the primes as a BitvSet\n+//! // Store the primes as a BitSet\n //! let primes = {\n //!     // Assume all numbers are prime to begin, and then we\n //!     // cross off non-primes progressively\n-//!     let mut bv = Bitv::from_elem(max_prime, true);\n+//!     let mut bv = BitVec::from_elem(max_prime, true);\n //!\n //!     // Neither 0 nor 1 are prime\n //!     bv.set(0, false);\n@@ -62,7 +62,7 @@\n //!             for j in iter::range_step(i * i, max_prime, i) { bv.set(j, false) }\n //!         }\n //!     }\n-//!     BitvSet::from_bitv(bv)\n+//!     BitSet::from_bit_vec(bv)\n //! };\n //!\n //! // Simple primality tests below our max bound\n@@ -75,7 +75,7 @@\n //! }\n //! println!(\"\");\n //!\n-//! // We can manipulate the internal Bitv\n+//! // We can manipulate the internal BitVec\n //! let num_primes = primes.get_ref().iter().filter(|x| *x).count();\n //! println!(\"There are {} primes below {}\", num_primes, max_prime);\n //! ```\n@@ -94,7 +94,7 @@ use core::num::Int;\n use core::ops::Index;\n use core::slice;\n use core::{u8, u32, usize};\n-use bitv_set; //so meta\n+use bit_set; //so meta\n \n use Vec;\n \n@@ -112,7 +112,7 @@ fn reverse_bits(byte: u8) -> u8 {\n \n // Take two BitV's, and return iterators of their words, where the shorter one\n // has been padded with 0's\n-fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<'b>) {\n+fn match_words <'a,'b>(a: &'a BitVec, b: &'b BitVec) -> (MatchWords<'a>, MatchWords<'b>) {\n     let a_len = a.storage.len();\n     let b_len = b.storage.len();\n \n@@ -134,9 +134,9 @@ static FALSE: bool = false;\n /// # Examples\n ///\n /// ```rust\n-/// use std::collections::Bitv;\n+/// use std::collections::BitVec;\n ///\n-/// let mut bv = Bitv::from_elem(10, false);\n+/// let mut bv = BitVec::from_elem(10, false);\n ///\n /// // insert all primes less than 10\n /// bv.set(2, true);\n@@ -158,15 +158,15 @@ static FALSE: bool = false;\n /// ```\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub struct Bitv {\n+pub struct BitVec {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n     /// The number of valid bits in the internal representation\n     nbits: usize\n }\n \n // FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n-impl Index<usize> for Bitv {\n+impl Index<usize> for BitVec {\n     type Output = bool;\n \n     #[inline]\n@@ -202,12 +202,12 @@ fn mask_for_bits(bits: usize) -> u32 {\n     !0u32 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n \n-impl Bitv {\n+impl BitVec {\n     /// Applies the given operation to the blocks of self and other, and sets\n     /// self to be the result. This relies on the caller not to corrupt the\n     /// last word.\n     #[inline]\n-    fn process<F>(&mut self, other: &Bitv, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n+    fn process<F>(&mut self, other: &BitVec, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n         assert_eq!(self.len(), other.len());\n         // This could theoretically be a `debug_assert!`.\n         assert_eq!(self.storage.len(), other.storage.len());\n@@ -235,7 +235,7 @@ impl Bitv {\n     }\n \n     /// An operation might screw up the unused bits in the last block of the\n-    /// `Bitv`. As per (3), it's assumed to be all 0s. This method fixes it up.\n+    /// `BitVec`. As per (3), it's assumed to be all 0s. This method fixes it up.\n     fn fix_last_block(&mut self) {\n         let extra_bits = self.len() % u32::BITS;\n         if extra_bits > 0 {\n@@ -245,83 +245,83 @@ impl Bitv {\n         }\n     }\n \n-    /// Creates an empty `Bitv`.\n+    /// Creates an empty `BitVec`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n-    /// let mut bv = Bitv::new();\n+    /// use std::collections::BitVec;\n+    /// let mut bv = BitVec::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> Bitv {\n-        Bitv { storage: Vec::new(), nbits: 0 }\n+    pub fn new() -> BitVec {\n+        BitVec { storage: Vec::new(), nbits: 0 }\n     }\n \n-    /// Creates a `Bitv` that holds `nbits` elements, setting each element\n+    /// Creates a `BitVec` that holds `nbits` elements, setting each element\n     /// to `bit`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(10, false);\n+    /// let mut bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.len(), 10);\n     /// for x in bv.iter() {\n     ///     assert_eq!(x, false);\n     /// }\n     /// ```\n-    pub fn from_elem(nbits: usize, bit: bool) -> Bitv {\n+    pub fn from_elem(nbits: usize, bit: bool) -> BitVec {\n         let nblocks = blocks_for_bits(nbits);\n-        let mut bitv = Bitv {\n+        let mut bit_vec = BitVec {\n             storage: repeat(if bit { !0u32 } else { 0u32 }).take(nblocks).collect(),\n             nbits: nbits\n         };\n-        bitv.fix_last_block();\n-        bitv\n+        bit_vec.fix_last_block();\n+        bit_vec\n     }\n \n-    /// Constructs a new, empty `Bitv` with the specified capacity.\n+    /// Constructs a new, empty `BitVec` with the specified capacity.\n     ///\n     /// The bitvector will be able to hold at least `capacity` bits without\n     /// reallocating. If `capacity` is 0, it will not allocate.\n     ///\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: usize) -> Bitv {\n-        Bitv {\n+    pub fn with_capacity(nbits: usize) -> BitVec {\n+        BitVec {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n             nbits: 0,\n         }\n     }\n \n-    /// Transforms a byte-vector into a `Bitv`. Each byte becomes eight bits,\n+    /// Transforms a byte-vector into a `BitVec`. Each byte becomes eight bits,\n     /// with the most significant bits of each byte coming first. Each\n     /// bit becomes `true` if equal to 1 or `false` if equal to 0.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b10100000, 0b00010010]);\n+    /// let bv = BitVec::from_bytes(&[0b10100000, 0b00010010]);\n     /// assert!(bv.eq_vec(&[true, false, true, false,\n     ///                     false, false, false, false,\n     ///                     false, false, false, true,\n     ///                     false, false, true, false]));\n     /// ```\n-    pub fn from_bytes(bytes: &[u8]) -> Bitv {\n+    pub fn from_bytes(bytes: &[u8]) -> BitVec {\n         let len = bytes.len().checked_mul(u8::BITS).expect(\"capacity overflow\");\n-        let mut bitv = Bitv::with_capacity(len);\n+        let mut bit_vec = BitVec::with_capacity(len);\n         let complete_words = bytes.len() / 4;\n         let extra_bytes = bytes.len() % 4;\n \n-        bitv.nbits = len;\n+        bit_vec.nbits = len;\n \n         for i in 0..complete_words {\n-            bitv.storage.push(\n+            bit_vec.storage.push(\n                 ((reverse_bits(bytes[i * 4 + 0]) as u32) << 0) |\n                 ((reverse_bits(bytes[i * 4 + 1]) as u32) << 8) |\n                 ((reverse_bits(bytes[i * 4 + 2]) as u32) << 16) |\n@@ -334,39 +334,39 @@ impl Bitv {\n             for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n                 last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n-            bitv.storage.push(last_word);\n+            bit_vec.storage.push(last_word);\n         }\n \n-        bitv\n+        bit_vec\n     }\n \n-    /// Creates a `Bitv` of the specified length where the value at each index\n+    /// Creates a `BitVec` of the specified length where the value at each index\n     /// is `f(index)`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_fn(5, |i| { i % 2 == 0 });\n+    /// let bv = BitVec::from_fn(5, |i| { i % 2 == 0 });\n     /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n     /// ```\n-    pub fn from_fn<F>(len: usize, mut f: F) -> Bitv where F: FnMut(usize) -> bool {\n-        let mut bitv = Bitv::from_elem(len, false);\n+    pub fn from_fn<F>(len: usize, mut f: F) -> BitVec where F: FnMut(usize) -> bool {\n+        let mut bit_vec = BitVec::from_elem(len, false);\n         for i in 0..len {\n-            bitv.set(i, f(i));\n+            bit_vec.set(i, f(i));\n         }\n-        bitv\n+        bit_vec\n     }\n \n     /// Retrieves the value at index `i`, or `None` if the index is out of bounds.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b01100000]);\n+    /// let bv = BitVec::from_bytes(&[0b01100000]);\n     /// assert_eq!(bv.get(0), Some(false));\n     /// assert_eq!(bv.get(1), Some(true));\n     /// assert_eq!(bv.get(100), None);\n@@ -396,9 +396,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(5, false);\n+    /// let mut bv = BitVec::from_elem(5, false);\n     /// bv.set(3, true);\n     /// assert_eq!(bv[3], true);\n     /// ```\n@@ -420,14 +420,14 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b11111111;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[before]);\n+    /// let mut bv = BitVec::from_bytes(&[before]);\n     /// bv.set_all();\n-    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, BitVec::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n@@ -440,14 +440,14 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b10011111;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[before]);\n+    /// let mut bv = BitVec::from_bytes(&[before]);\n     /// bv.negate();\n-    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, BitVec::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n@@ -468,20 +468,20 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01111110;\n     ///\n-    /// let mut a = Bitv::from_bytes(&[a]);\n-    /// let b = Bitv::from_bytes(&[b]);\n+    /// let mut a = BitVec::from_bytes(&[a]);\n+    /// let b = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(a.union(&b));\n-    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, BitVec::from_bytes(&[res]));\n     /// ```\n     #[inline]\n-    pub fn union(&mut self, other: &Bitv) -> bool {\n+    pub fn union(&mut self, other: &BitVec) -> bool {\n         self.process(other, |w1, w2| w1 | w2)\n     }\n \n@@ -498,20 +498,20 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01000000;\n     ///\n-    /// let mut a = Bitv::from_bytes(&[a]);\n-    /// let b = Bitv::from_bytes(&[b]);\n+    /// let mut a = BitVec::from_bytes(&[a]);\n+    /// let b = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(a.intersect(&b));\n-    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, BitVec::from_bytes(&[res]));\n     /// ```\n     #[inline]\n-    pub fn intersect(&mut self, other: &Bitv) -> bool {\n+    pub fn intersect(&mut self, other: &BitVec) -> bool {\n         self.process(other, |w1, w2| w1 & w2)\n     }\n \n@@ -528,27 +528,27 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let a_b = 0b00100100; // a - b\n     /// let b_a = 0b00011010; // b - a\n     ///\n-    /// let mut bva = Bitv::from_bytes(&[a]);\n-    /// let bvb = Bitv::from_bytes(&[b]);\n+    /// let mut bva = BitVec::from_bytes(&[a]);\n+    /// let bvb = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(bva.difference(&bvb));\n-    /// assert_eq!(bva, Bitv::from_bytes(&[a_b]));\n+    /// assert_eq!(bva, BitVec::from_bytes(&[a_b]));\n     ///\n-    /// let bva = Bitv::from_bytes(&[a]);\n-    /// let mut bvb = Bitv::from_bytes(&[b]);\n+    /// let bva = BitVec::from_bytes(&[a]);\n+    /// let mut bvb = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(bvb.difference(&bva));\n-    /// assert_eq!(bvb, Bitv::from_bytes(&[b_a]));\n+    /// assert_eq!(bvb, BitVec::from_bytes(&[b_a]));\n     /// ```\n     #[inline]\n-    pub fn difference(&mut self, other: &Bitv) -> bool {\n+    pub fn difference(&mut self, other: &BitVec) -> bool {\n         self.process(other, |w1, w2| w1 & !w2)\n     }\n \n@@ -557,9 +557,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(5, true);\n+    /// let mut bv = BitVec::from_elem(5, true);\n     /// assert_eq!(bv.all(), true);\n     ///\n     /// bv.set(1, false);\n@@ -581,25 +581,25 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b01110100, 0b10010010]);\n+    /// let bv = BitVec::from_bytes(&[0b01110100, 0b10010010]);\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n-        Iter { bitv: self, next_idx: 0, end_idx: self.nbits }\n+        Iter { bit_vec: self, next_idx: 0, end_idx: self.nbits }\n     }\n \n     /// Returns `true` if all bits are 0.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(10, false);\n+    /// let mut bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.none(), true);\n     ///\n     /// bv.set(3, true);\n@@ -614,9 +614,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(10, false);\n+    /// let mut bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.any(), false);\n     ///\n     /// bv.set(3, true);\n@@ -628,33 +628,33 @@ impl Bitv {\n     }\n \n     /// Organises the bits into bytes, such that the first bit in the\n-    /// `Bitv` becomes the high-order bit of the first byte. If the\n-    /// size of the `Bitv` is not a multiple of eight then trailing bits\n+    /// `BitVec` becomes the high-order bit of the first byte. If the\n+    /// size of the `BitVec` is not a multiple of eight then trailing bits\n     /// will be filled-in with `false`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(3, true);\n+    /// let mut bv = BitVec::from_elem(3, true);\n     /// bv.set(1, false);\n     ///\n     /// assert_eq!(bv.to_bytes(), vec!(0b10100000));\n     ///\n-    /// let mut bv = Bitv::from_elem(9, false);\n+    /// let mut bv = BitVec::from_elem(9, false);\n     /// bv.set(2, true);\n     /// bv.set(8, true);\n     ///\n     /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n     /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n-        fn bit(bitv: &Bitv, byte: usize, bit: usize) -> u8 {\n+        fn bit(bit_vec: &BitVec, byte: usize, bit: usize) -> u8 {\n             let offset = byte * 8 + bit;\n-            if offset >= bitv.nbits {\n+            if offset >= bit_vec.nbits {\n                 0\n             } else {\n-                (bitv[offset] as u8) << (7 - bit)\n+                (bit_vec[offset] as u8) << (7 - bit)\n             }\n         }\n \n@@ -672,19 +672,19 @@ impl Bitv {\n         ).collect()\n     }\n \n-    /// Compares a `Bitv` to a slice of `bool`s.\n-    /// Both the `Bitv` and slice must have the same length.\n+    /// Compares a `BitVec` to a slice of `bool`s.\n+    /// Both the `BitVec` and slice must have the same length.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the `Bitv` and slice are of different length.\n+    /// Panics if the `BitVec` and slice are of different length.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b10100000]);\n+    /// let bv = BitVec::from_bytes(&[0b10100000]);\n     ///\n     /// assert!(bv.eq_vec(&[true, false, true, false,\n     ///                     false, false, false, false]));\n@@ -694,17 +694,17 @@ impl Bitv {\n         iter::order::eq(self.iter(), v.iter().cloned())\n     }\n \n-    /// Shortens a `Bitv`, dropping excess elements.\n+    /// Shortens a `BitVec`, dropping excess elements.\n     ///\n     /// If `len` is greater than the vector's current length, this has no\n     /// effect.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n@@ -719,7 +719,7 @@ impl Bitv {\n     }\n \n     /// Reserves capacity for at least `additional` more bits to be inserted in the given\n-    /// `Bitv`. The collection may reserve more space to avoid frequent reallocations.\n+    /// `BitVec`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -728,9 +728,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(3, false);\n+    /// let mut bv = BitVec::from_elem(3, false);\n     /// bv.reserve(10);\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n@@ -745,7 +745,7 @@ impl Bitv {\n     }\n \n     /// Reserves the minimum capacity for exactly `additional` more bits to be inserted in the\n-    /// given `Bitv`. Does nothing if the capacity is already sufficient.\n+    /// given `BitVec`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n     /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n@@ -758,9 +758,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(3, false);\n+    /// let mut bv = BitVec::from_elem(3, false);\n     /// bv.reserve(10);\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n@@ -780,9 +780,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::new();\n+    /// let mut bv = BitVec::new();\n     /// bv.reserve(10);\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n@@ -792,7 +792,7 @@ impl Bitv {\n         self.storage.capacity().checked_mul(u32::BITS).unwrap_or(usize::MAX)\n     }\n \n-    /// Grows the `Bitv` in-place, adding `n` copies of `value` to the `Bitv`.\n+    /// Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.\n     ///\n     /// # Panics\n     ///\n@@ -801,9 +801,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n     /// bv.grow(2, true);\n     /// assert_eq!(bv.len(), 10);\n     /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n@@ -846,14 +846,14 @@ impl Bitv {\n         self.fix_last_block();\n     }\n \n-    /// Removes the last bit from the Bitv, and returns it. Returns None if the Bitv is empty.\n+    /// Removes the last bit from the BitVec, and returns it. Returns None if the BitVec is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[0b01001001]);\n+    /// let mut bv = BitVec::from_bytes(&[0b01001001]);\n     /// assert_eq!(bv.pop(), Some(true));\n     /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n@@ -881,9 +881,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::new();\n+    /// let mut bv = BitVec::new();\n     /// bv.push(true);\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n@@ -917,24 +917,25 @@ impl Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for Bitv {\n+impl Default for BitVec {\n     #[inline]\n-    fn default() -> Bitv { Bitv::new() }\n+    fn default() -> BitVec { BitVec::new() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<bool> for Bitv {\n-    fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> Bitv {\n-        let mut ret = Bitv::new();\n-        ret.extend(iterator);\n+impl FromIterator<bool> for BitVec {\n+    fn from_iter<I: IntoIterator<Item=bool>>(iter: I) -> BitVec {\n+        let mut ret = BitVec::new();\n+        ret.extend(iter);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<bool> for Bitv {\n+impl Extend<bool> for BitVec {\n     #[inline]\n-    fn extend<I: Iterator<Item=bool>>(&mut self, iterator: I) {\n+    fn extend<I: IntoIterator<Item=bool>>(&mut self, iterable: I) {\n+        let iterator = iterable.into_iter();\n         let (min, _) = iterator.size_hint();\n         self.reserve(min);\n         for element in iterator {\n@@ -944,37 +945,37 @@ impl Extend<bool> for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for Bitv {\n+impl Clone for BitVec {\n     #[inline]\n-    fn clone(&self) -> Bitv {\n-        Bitv { storage: self.storage.clone(), nbits: self.nbits }\n+    fn clone(&self) -> BitVec {\n+        BitVec { storage: self.storage.clone(), nbits: self.nbits }\n     }\n \n     #[inline]\n-    fn clone_from(&mut self, source: &Bitv) {\n+    fn clone_from(&mut self, source: &BitVec) {\n         self.nbits = source.nbits;\n         self.storage.clone_from(&source.storage);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for Bitv {\n+impl PartialOrd for BitVec {\n     #[inline]\n-    fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &BitVec) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for Bitv {\n+impl Ord for BitVec {\n     #[inline]\n-    fn cmp(&self, other: &Bitv) -> Ordering {\n+    fn cmp(&self, other: &BitVec) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Bitv {\n+impl fmt::Debug for BitVec {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self {\n             try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n@@ -984,19 +985,30 @@ impl fmt::Debug for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n+#[cfg(stage0)]\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitVec {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n         for elem in self.blocks() {\n             elem.hash(state);\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl hash::Hash for BitVec {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.nbits.hash(state);\n+        for elem in self.blocks() {\n+            elem.hash(state);\n+        }\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for Bitv {\n+impl cmp::PartialEq for BitVec {\n     #[inline]\n-    fn eq(&self, other: &Bitv) -> bool {\n+    fn eq(&self, other: &BitVec) -> bool {\n         if self.nbits != other.nbits {\n             return false;\n         }\n@@ -1005,13 +1017,13 @@ impl cmp::PartialEq for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for Bitv {}\n+impl cmp::Eq for BitVec {}\n \n-/// An iterator for `Bitv`.\n+/// An iterator for `BitVec`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Iter<'a> {\n-    bitv: &'a Bitv,\n+    bit_vec: &'a BitVec,\n     next_idx: usize,\n     end_idx: usize,\n }\n@@ -1025,7 +1037,7 @@ impl<'a> Iterator for Iter<'a> {\n         if self.next_idx != self.end_idx {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n-            Some(self.bitv[idx])\n+            Some(self.bit_vec[idx])\n         } else {\n             None\n         }\n@@ -1043,7 +1055,7 @@ impl<'a> DoubleEndedIterator for Iter<'a> {\n     fn next_back(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n             self.end_idx -= 1;\n-            Some(self.bitv[self.end_idx])\n+            Some(self.bit_vec[self.end_idx])\n         } else {\n             None\n         }\n@@ -1065,13 +1077,13 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n         if index >= self.indexable() {\n             None\n         } else {\n-            Some(self.bitv[index])\n+            Some(self.bit_vec[index])\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> IntoIterator for &'a Bitv {\n+impl<'a> IntoIterator for &'a BitVec {\n     type Item = bool;\n     type IntoIter = Iter<'a>;\n \n@@ -1090,10 +1102,10 @@ impl<'a> IntoIterator for &'a Bitv {\n /// # Examples\n ///\n /// ```\n-/// use std::collections::{BitvSet, Bitv};\n+/// use std::collections::{BitSet, BitVec};\n ///\n /// // It's a regular set\n-/// let mut s = BitvSet::new();\n+/// let mut s = BitSet::new();\n /// s.insert(0);\n /// s.insert(3);\n /// s.insert(7);\n@@ -1104,8 +1116,8 @@ impl<'a> IntoIterator for &'a Bitv {\n ///     println!(\"There is no 7\");\n /// }\n ///\n-/// // Can initialize from a `Bitv`\n-/// let other = BitvSet::from_bitv(Bitv::from_bytes(&[0b11010000]));\n+/// // Can initialize from a `BitVec`\n+/// let other = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11010000]));\n ///\n /// s.union_with(&other);\n ///\n@@ -1114,124 +1126,132 @@ impl<'a> IntoIterator for &'a Bitv {\n ///     println!(\"{}\", x);\n /// }\n ///\n-/// // Can convert back to a `Bitv`\n-/// let bv: Bitv = s.into_bitv();\n+/// // Can convert back to a `BitVec`\n+/// let bv: BitVec = s.into_bit_vec();\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub struct BitvSet {\n-    bitv: Bitv,\n+pub struct BitSet {\n+    bit_vec: BitVec,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for BitvSet {\n+impl Default for BitSet {\n     #[inline]\n-    fn default() -> BitvSet { BitvSet::new() }\n+    fn default() -> BitSet { BitSet::new() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<usize> for BitvSet {\n-    fn from_iter<I:Iterator<Item=usize>>(iterator: I) -> BitvSet {\n-        let mut ret = BitvSet::new();\n-        ret.extend(iterator);\n+impl FromIterator<usize> for BitSet {\n+    fn from_iter<I: IntoIterator<Item=usize>>(iter: I) -> BitSet {\n+        let mut ret = BitSet::new();\n+        ret.extend(iter);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<usize> for BitvSet {\n+impl Extend<usize> for BitSet {\n     #[inline]\n-    fn extend<I: Iterator<Item=usize>>(&mut self, iterator: I) {\n-        for i in iterator {\n+    fn extend<I: IntoIterator<Item=usize>>(&mut self, iter: I) {\n+        for i in iter {\n             self.insert(i);\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for BitvSet {\n+impl PartialOrd for BitSet {\n     #[inline]\n-    fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &BitSet) -> Option<Ordering> {\n         let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n         iter::order::partial_cmp(a_iter, b_iter)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for BitvSet {\n+impl Ord for BitSet {\n     #[inline]\n-    fn cmp(&self, other: &BitvSet) -> Ordering {\n+    fn cmp(&self, other: &BitSet) -> Ordering {\n         let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n         iter::order::cmp(a_iter, b_iter)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for BitvSet {\n+impl cmp::PartialEq for BitSet {\n     #[inline]\n-    fn eq(&self, other: &BitvSet) -> bool {\n+    fn eq(&self, other: &BitSet) -> bool {\n         let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n         iter::order::eq(a_iter, b_iter)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for BitvSet {}\n+impl cmp::Eq for BitSet {}\n \n-impl BitvSet {\n-    /// Creates a new empty `BitvSet`.\n+impl BitSet {\n+    /// Creates a new empty `BitSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BitvSet {\n-        BitvSet { bitv: Bitv::new() }\n+    pub fn new() -> BitSet {\n+        BitSet { bit_vec: BitVec::new() }\n     }\n \n-    /// Creates a new `BitvSet` with initially no contents, able to\n+    /// Creates a new `BitSet` with initially no contents, able to\n     /// hold `nbits` elements without resizing.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::with_capacity(100);\n+    /// let mut s = BitSet::with_capacity(100);\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: usize) -> BitvSet {\n-        let bitv = Bitv::from_elem(nbits, false);\n-        BitvSet::from_bitv(bitv)\n+    pub fn with_capacity(nbits: usize) -> BitSet {\n+        let bit_vec = BitVec::from_elem(nbits, false);\n+        BitSet::from_bit_vec(bit_vec)\n     }\n \n-    /// Creates a new `BitvSet` from the given bit vector.\n+    /// Creates a new `BitSet` from the given bit vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b01100000]);\n-    /// let s = BitvSet::from_bitv(bv);\n+    /// let bv = BitVec::from_bytes(&[0b01100000]);\n+    /// let s = BitSet::from_bit_vec(bv);\n     ///\n     /// // Print 1, 2 in arbitrary order\n     /// for x in s.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n     #[inline]\n-    pub fn from_bitv(bitv: Bitv) -> BitvSet {\n-        BitvSet { bitv: bitv }\n+    pub fn from_bit_vec(bit_vec: BitVec) -> BitSet {\n+        BitSet { bit_vec: bit_vec }\n+    }\n+\n+    /// Deprecated: use `from_bit_vec`.\n+    #[inline]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to from_bit_vec\")]\n+    #[unstable(feature = \"collections\")]\n+    pub fn from_bitv(bit_vec: BitVec) -> BitSet {\n+        BitSet { bit_vec: bit_vec }\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n@@ -1240,19 +1260,19 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::with_capacity(100);\n+    /// let mut s = BitSet::with_capacity(100);\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.bitv.capacity()\n+        self.bit_vec.capacity()\n     }\n \n-    /// Reserves capacity for the given `BitvSet` to contain `len` distinct elements. In the case\n-    /// of `BitvSet` this means reallocations will not occur as long as all inserted elements\n+    /// Reserves capacity for the given `BitSet` to contain `len` distinct elements. In the case\n+    /// of `BitSet` this means reallocations will not occur as long as all inserted elements\n     /// are less than `len`.\n     ///\n     /// The collection may reserve more space to avoid frequent reallocations.\n@@ -1261,22 +1281,22 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.reserve_len(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: usize) {\n-        let cur_len = self.bitv.len();\n+        let cur_len = self.bit_vec.len();\n         if len >= cur_len {\n-            self.bitv.reserve(len - cur_len);\n+            self.bit_vec.reserve(len - cur_len);\n         }\n     }\n \n-    /// Reserves the minimum capacity for the given `BitvSet` to contain `len` distinct elements.\n-    /// In the case of `BitvSet` this means reallocations will not occur as long as all inserted\n+    /// Reserves the minimum capacity for the given `BitSet` to contain `len` distinct elements.\n+    /// In the case of `BitSet` this means reallocations will not occur as long as all inserted\n     /// elements are less than `len`.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n@@ -1287,17 +1307,17 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.reserve_len_exact(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: usize) {\n-        let cur_len = self.bitv.len();\n+        let cur_len = self.bit_vec.len();\n         if len >= cur_len {\n-            self.bitv.reserve_exact(len - cur_len);\n+            self.bit_vec.reserve_exact(len - cur_len);\n         }\n     }\n \n@@ -1307,64 +1327,64 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.insert(0);\n     /// s.insert(3);\n     ///\n-    /// let bv = s.into_bitv();\n+    /// let bv = s.into_bit_vec();\n     /// assert!(bv[0]);\n     /// assert!(bv[3]);\n     /// ```\n     #[inline]\n-    pub fn into_bitv(self) -> Bitv {\n-        self.bitv\n+    pub fn into_bit_vec(self) -> BitVec {\n+        self.bit_vec\n     }\n \n     /// Returns a reference to the underlying bit vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.insert(0);\n     ///\n     /// let bv = s.get_ref();\n     /// assert_eq!(bv[0], true);\n     /// ```\n     #[inline]\n-    pub fn get_ref(&self) -> &Bitv {\n-        &self.bitv\n+    pub fn get_ref(&self) -> &BitVec {\n+        &self.bit_vec\n     }\n \n     #[inline]\n-    fn other_op<F>(&mut self, other: &BitvSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n-        // Unwrap Bitvs\n-        let self_bitv = &mut self.bitv;\n-        let other_bitv = &other.bitv;\n+    fn other_op<F>(&mut self, other: &BitSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n+        // Unwrap BitVecs\n+        let self_bit_vec = &mut self.bit_vec;\n+        let other_bit_vec = &other.bit_vec;\n \n-        let self_len = self_bitv.len();\n-        let other_len = other_bitv.len();\n+        let self_len = self_bit_vec.len();\n+        let other_len = other_bit_vec.len();\n \n         // Expand the vector if necessary\n         if self_len < other_len {\n-            self_bitv.grow(other_len - self_len, false);\n+            self_bit_vec.grow(other_len - self_len, false);\n         }\n \n         // virtually pad other with 0's for equal lengths\n         let other_words = {\n-            let (_, result) = match_words(self_bitv, other_bitv);\n+            let (_, result) = match_words(self_bit_vec, other_bit_vec);\n             result\n         };\n \n         // Apply values found in other\n         for (i, w) in other_words {\n-            let old = self_bitv.storage[i];\n+            let old = self_bit_vec.storage[i];\n             let new = f(old, w);\n-            self_bitv.storage[i] = new;\n+            self_bit_vec.storage[i] = new;\n         }\n     }\n \n@@ -1373,9 +1393,9 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.insert(32183231);\n     /// s.remove(&32183231);\n     ///\n@@ -1389,25 +1409,25 @@ impl BitvSet {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        let bitv = &mut self.bitv;\n+        let bit_vec = &mut self.bit_vec;\n         // Obtain original length\n-        let old_len = bitv.storage.len();\n+        let old_len = bit_vec.storage.len();\n         // Obtain coarse trailing zero length\n-        let n = bitv.storage.iter().rev().take_while(|&&n| n == 0).count();\n+        let n = bit_vec.storage.iter().rev().take_while(|&&n| n == 0).count();\n         // Truncate\n         let trunc_len = cmp::max(old_len - n, 1);\n-        bitv.storage.truncate(trunc_len);\n-        bitv.nbits = trunc_len * u32::BITS;\n+        bit_vec.storage.truncate(trunc_len);\n+        bit_vec.nbits = trunc_len * u32::BITS;\n     }\n \n-    /// Iterator over each u32 stored in the `BitvSet`.\n+    /// Iterator over each u32 stored in the `BitSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let s = BitvSet::from_bitv(Bitv::from_bytes(&[0b01001010]));\n+    /// let s = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01001010]));\n     ///\n     /// // Print 1, 4, 6 in arbitrary order\n     /// for x in s.iter() {\n@@ -1416,7 +1436,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> bitv_set::Iter {\n+    pub fn iter(&self) -> bit_set::Iter {\n         SetIter {set: self, next_idx: 0}\n     }\n \n@@ -1426,10 +1446,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 2, 4 in arbitrary order\n     /// for x in a.union(&b) {\n@@ -1438,7 +1458,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a BitvSet) -> Union<'a> {\n+    pub fn union<'a>(&'a self, other: &'a BitSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n         Union(TwoBitPositions {\n@@ -1456,10 +1476,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 2\n     /// for x in a.intersection(&b) {\n@@ -1468,9 +1488,9 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Intersection<'a> {\n+    pub fn intersection<'a>(&'a self, other: &'a BitSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n-        let min = cmp::min(self.bitv.len(), other.bitv.len());\n+        let min = cmp::min(self.bit_vec.len(), other.bit_vec.len());\n         Intersection(TwoBitPositions {\n             set: self,\n             other: other,\n@@ -1486,10 +1506,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 1, 4 in arbitrary order\n     /// for x in a.difference(&b) {\n@@ -1505,7 +1525,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> Difference<'a> {\n+    pub fn difference<'a>(&'a self, other: &'a BitSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n         Difference(TwoBitPositions {\n@@ -1524,10 +1544,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 4 in arbitrary order\n     /// for x in a.symmetric_difference(&b) {\n@@ -1536,7 +1556,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> SymmetricDifference<'a> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BitSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n         SymmetricDifference(TwoBitPositions {\n@@ -1553,21 +1573,21 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11101000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n+    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n     ///\n     /// a.union_with(&b);\n     /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n-    pub fn union_with(&mut self, other: &BitvSet) {\n+    pub fn union_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 | w2);\n     }\n \n@@ -1576,21 +1596,21 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b00100000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n+    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n     ///\n     /// a.intersect_with(&b);\n     /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n-    pub fn intersect_with(&mut self, other: &BitvSet) {\n+    pub fn intersect_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 & w2);\n     }\n \n@@ -1600,29 +1620,29 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let a_b = 0b01001000; // a - b\n     /// let b_a = 0b10000000; // b - a\n     ///\n-    /// let mut bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let bva_b = BitvSet::from_bitv(Bitv::from_bytes(&[a_b]));\n-    /// let bvb_a = BitvSet::from_bitv(Bitv::from_bytes(&[b_a]));\n+    /// let mut bva = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let bvb = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let bva_b = BitSet::from_bit_vec(BitVec::from_bytes(&[a_b]));\n+    /// let bvb_a = BitSet::from_bit_vec(BitVec::from_bytes(&[b_a]));\n     ///\n     /// bva.difference_with(&bvb);\n     /// assert_eq!(bva, bva_b);\n     ///\n-    /// let bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let mut bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let bva = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let mut bvb = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n     ///\n     /// bvb.difference_with(&bva);\n     /// assert_eq!(bvb, bvb_a);\n     /// ```\n     #[inline]\n-    pub fn difference_with(&mut self, other: &BitvSet) {\n+    pub fn difference_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 & !w2);\n     }\n \n@@ -1632,79 +1652,79 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11001000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n+    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n     ///\n     /// a.symmetric_difference_with(&b);\n     /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n-    pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n+    pub fn symmetric_difference_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n     /// Return the number of set bits in this set.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize  {\n-        self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n+        self.bit_vec.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.bitv.none()\n+        self.bit_vec.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        self.bitv.clear();\n+        self.bit_vec.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains(&self, value: &usize) -> bool {\n-        let bitv = &self.bitv;\n-        *value < bitv.nbits && bitv[*value]\n+        let bit_vec = &self.bit_vec;\n+        *value < bit_vec.nbits && bit_vec[*value]\n     }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n+    pub fn is_disjoint(&self, other: &BitSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &BitvSet) -> bool {\n-        let self_bitv = &self.bitv;\n-        let other_bitv = &other.bitv;\n-        let other_blocks = blocks_for_bits(other_bitv.len());\n+    pub fn is_subset(&self, other: &BitSet) -> bool {\n+        let self_bit_vec = &self.bit_vec;\n+        let other_bit_vec = &other.bit_vec;\n+        let other_blocks = blocks_for_bits(other_bit_vec.len());\n \n         // Check that `self` intersect `other` is self\n-        self_bitv.blocks().zip(other_bitv.blocks()).all(|(w1, w2)| w1 & w2 == w1) &&\n+        self_bit_vec.blocks().zip(other_bit_vec.blocks()).all(|(w1, w2)| w1 & w2 == w1) &&\n         // Make sure if `self` has any more blocks than `other`, they're all 0\n-        self_bitv.blocks().skip(other_blocks).all(|w| w == 0)\n+        self_bit_vec.blocks().skip(other_blocks).all(|w| w == 0)\n     }\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &BitvSet) -> bool {\n+    pub fn is_superset(&self, other: &BitSet) -> bool {\n         other.is_subset(self)\n     }\n \n@@ -1717,12 +1737,12 @@ impl BitvSet {\n         }\n \n         // Ensure we have enough space to hold the new element\n-        let len = self.bitv.len();\n+        let len = self.bit_vec.len();\n         if value >= len {\n-            self.bitv.grow(value - len + 1, false)\n+            self.bit_vec.grow(value - len + 1, false)\n         }\n \n-        self.bitv.set(value, true);\n+        self.bit_vec.set(value, true);\n         return true;\n     }\n \n@@ -1734,16 +1754,16 @@ impl BitvSet {\n             return false;\n         }\n \n-        self.bitv.set(*value, false);\n+        self.bit_vec.set(*value, false);\n \n         return true;\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for BitvSet {\n+impl fmt::Debug for BitSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"BitvSet {{\"));\n+        try!(write!(fmt, \"BitSet {{\"));\n         let mut first = true;\n         for n in self {\n             if !first {\n@@ -1756,27 +1776,37 @@ impl fmt::Debug for BitvSet {\n     }\n }\n \n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n+#[cfg(stage0)]\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitSet {\n     fn hash(&self, state: &mut S) {\n         for pos in self {\n             pos.hash(state);\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl hash::Hash for BitSet {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        for pos in self {\n+            pos.hash(state);\n+        }\n+    }\n+}\n \n-/// An iterator for `BitvSet`.\n+/// An iterator for `BitSet`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SetIter<'a> {\n-    set: &'a BitvSet,\n+    set: &'a BitSet,\n     next_idx: usize\n }\n \n-/// An iterator combining two `BitvSet` iterators.\n+/// An iterator combining two `BitSet` iterators.\n #[derive(Clone)]\n struct TwoBitPositions<'a> {\n-    set: &'a BitvSet,\n-    other: &'a BitvSet,\n+    set: &'a BitSet,\n+    other: &'a BitSet,\n     merge: fn(u32, u32) -> u32,\n     current_word: u32,\n     next_idx: usize\n@@ -1796,7 +1826,7 @@ impl<'a> Iterator for SetIter<'a> {\n     type Item = usize;\n \n     fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bitv.len() {\n+        while self.next_idx < self.set.bit_vec.len() {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n \n@@ -1810,7 +1840,7 @@ impl<'a> Iterator for SetIter<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.set.bitv.len() - self.next_idx))\n+        (0, Some(self.set.bit_vec.len() - self.next_idx))\n     }\n }\n \n@@ -1819,20 +1849,20 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     type Item = usize;\n \n     fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bitv.len() ||\n-              self.next_idx < self.other.bitv.len() {\n+        while self.next_idx < self.set.bit_vec.len() ||\n+              self.next_idx < self.other.bit_vec.len() {\n             let bit_idx = self.next_idx % u32::BITS;\n             if bit_idx == 0 {\n-                let s_bitv = &self.set.bitv;\n-                let o_bitv = &self.other.bitv;\n+                let s_bit_vec = &self.set.bit_vec;\n+                let o_bit_vec = &self.other.bit_vec;\n                 // Merging the two words is a bit of an awkward dance since\n-                // one Bitv might be longer than the other\n+                // one BitVec might be longer than the other\n                 let word_idx = self.next_idx / u32::BITS;\n-                let w1 = if word_idx < s_bitv.storage.len() {\n-                             s_bitv.storage[word_idx]\n+                let w1 = if word_idx < s_bit_vec.storage.len() {\n+                             s_bit_vec.storage[word_idx]\n                          } else { 0 };\n-                let w2 = if word_idx < o_bitv.storage.len() {\n-                             o_bitv.storage[word_idx]\n+                let w2 = if word_idx < o_bit_vec.storage.len() {\n+                             o_bit_vec.storage[word_idx]\n                          } else { 0 };\n                 self.current_word = (self.merge)(w1, w2);\n             }\n@@ -1847,7 +1877,7 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let cap = cmp::max(self.set.bitv.len(), self.other.bitv.len());\n+        let cap = cmp::max(self.set.bit_vec.len(), self.other.bit_vec.len());\n         (0, Some(cap - self.next_idx))\n     }\n }\n@@ -1885,7 +1915,7 @@ impl<'a> Iterator for SymmetricDifference<'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> IntoIterator for &'a BitvSet {\n+impl<'a> IntoIterator for &'a BitSet {\n     type Item = usize;\n     type IntoIter = SetIter<'a>;\n \n@@ -1899,38 +1929,38 @@ mod tests {\n     use prelude::*;\n     use core::u32;\n \n-    use super::Bitv;\n+    use super::BitVec;\n \n     #[test]\n     fn test_to_str() {\n-        let zerolen = Bitv::new();\n+        let zerolen = BitVec::new();\n         assert_eq!(format!(\"{:?}\", zerolen), \"\");\n \n-        let eightbits = Bitv::from_elem(8, false);\n+        let eightbits = BitVec::from_elem(8, false);\n         assert_eq!(format!(\"{:?}\", eightbits), \"00000000\")\n     }\n \n     #[test]\n     fn test_0_elements() {\n-        let act = Bitv::new();\n+        let act = BitVec::new();\n         let exp = Vec::new();\n         assert!(act.eq_vec(&exp));\n         assert!(act.none() && act.all());\n     }\n \n     #[test]\n     fn test_1_element() {\n-        let mut act = Bitv::from_elem(1, false);\n+        let mut act = BitVec::from_elem(1, false);\n         assert!(act.eq_vec(&[false]));\n         assert!(act.none() && !act.all());\n-        act = Bitv::from_elem(1, true);\n+        act = BitVec::from_elem(1, true);\n         assert!(act.eq_vec(&[true]));\n         assert!(!act.none() && act.all());\n     }\n \n     #[test]\n     fn test_2_elements() {\n-        let mut b = Bitv::from_elem(2, false);\n+        let mut b = BitVec::from_elem(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert_eq!(format!(\"{:?}\", b), \"10\");\n@@ -1942,18 +1972,18 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         assert!((act.eq_vec(\n                     &[false, false, false, false, false, false, false, false, false, false])));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(10, true);\n+        act = BitVec::from_elem(10, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -1963,7 +1993,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         act.set(5, true);\n         act.set(6, true);\n         act.set(7, true);\n@@ -1973,7 +2003,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         act.set(0, true);\n         act.set(3, true);\n         act.set(6, true);\n@@ -1987,23 +2017,23 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(31, true);\n+        act = BitVec::from_elem(31, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -2019,7 +2049,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(16, true);\n         act.set(17, true);\n         act.set(18, true);\n@@ -2035,7 +2065,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(24, true);\n         act.set(25, true);\n         act.set(26, true);\n@@ -2050,7 +2080,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(3, true);\n         act.set(17, true);\n         act.set(30, true);\n@@ -2066,23 +2096,23 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(32, true);\n+        act = BitVec::from_elem(32, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -2098,7 +2128,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(16, true);\n         act.set(17, true);\n         act.set(18, true);\n@@ -2114,7 +2144,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(24, true);\n         act.set(25, true);\n         act.set(26, true);\n@@ -2130,7 +2160,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(3, true);\n         act.set(17, true);\n         act.set(30, true);\n@@ -2147,23 +2177,23 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(33, true);\n+        act = BitVec::from_elem(33, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -2179,7 +2209,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(16, true);\n         act.set(17, true);\n         act.set(18, true);\n@@ -2195,7 +2225,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(24, true);\n         act.set(25, true);\n         act.set(26, true);\n@@ -2211,7 +2241,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(3, true);\n         act.set(17, true);\n         act.set(30, true);\n@@ -2226,37 +2256,37 @@ mod tests {\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = Bitv::from_elem(10, false);\n-        let v1 = Bitv::from_elem(11, false);\n+        let v0 = BitVec::from_elem(10, false);\n+        let v1 = BitVec::from_elem(11, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv::from_elem(10, false);\n-        let v1 = Bitv::from_elem(110, false);\n+        let v0 = BitVec::from_elem(10, false);\n+        let v1 = BitVec::from_elem(110, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_sneaky_small() {\n-        let mut a = Bitv::from_elem(1, false);\n+        let mut a = BitVec::from_elem(1, false);\n         a.set(0, true);\n \n-        let mut b = Bitv::from_elem(1, true);\n+        let mut b = BitVec::from_elem(1, true);\n         b.set(0, true);\n \n         assert_eq!(a, b);\n     }\n \n     #[test]\n     fn test_equal_sneaky_big() {\n-        let mut a = Bitv::from_elem(100, false);\n+        let mut a = BitVec::from_elem(100, false);\n         for i in 0..100 {\n             a.set(i, true);\n         }\n \n-        let mut b = Bitv::from_elem(100, true);\n+        let mut b = BitVec::from_elem(100, true);\n         for i in 0..100 {\n             b.set(i, true);\n         }\n@@ -2266,18 +2296,18 @@ mod tests {\n \n     #[test]\n     fn test_from_bytes() {\n-        let bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n         let str = concat!(\"10110110\", \"00000000\", \"11111111\");\n-        assert_eq!(format!(\"{:?}\", bitv), str);\n+        assert_eq!(format!(\"{:?}\", bit_vec), str);\n     }\n \n     #[test]\n     fn test_to_bytes() {\n-        let mut bv = Bitv::from_elem(3, true);\n+        let mut bv = BitVec::from_elem(3, true);\n         bv.set(1, false);\n         assert_eq!(bv.to_bytes(), vec!(0b10100000));\n \n-        let mut bv = Bitv::from_elem(9, false);\n+        let mut bv = BitVec::from_elem(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n         assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n@@ -2286,32 +2316,32 @@ mod tests {\n     #[test]\n     fn test_from_bools() {\n         let bools = vec![true, false, true, true];\n-        let bitv: Bitv = bools.iter().map(|n| *n).collect();\n-        assert_eq!(format!(\"{:?}\", bitv), \"1011\");\n+        let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n+        assert_eq!(format!(\"{:?}\", bit_vec), \"1011\");\n     }\n \n     #[test]\n     fn test_to_bools() {\n         let bools = vec![false, false, true, false, false, true, true, false];\n-        assert_eq!(Bitv::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n+        assert_eq!(BitVec::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n     }\n \n     #[test]\n-    fn test_bitv_iterator() {\n+    fn test_bit_vec_iterator() {\n         let bools = vec![true, false, true, true];\n-        let bitv: Bitv = bools.iter().map(|n| *n).collect();\n+        let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n \n-        assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools);\n+        assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), bools);\n \n         let long: Vec<_> = (0i32..10000).map(|i| i % 2 == 0).collect();\n-        let bitv: Bitv = long.iter().map(|n| *n).collect();\n-        assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n+        let bit_vec: BitVec = long.iter().map(|n| *n).collect();\n+        assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), long)\n     }\n \n     #[test]\n     fn test_small_difference() {\n-        let mut b1 = Bitv::from_elem(3, false);\n-        let mut b2 = Bitv::from_elem(3, false);\n+        let mut b1 = BitVec::from_elem(3, false);\n+        let mut b2 = BitVec::from_elem(3, false);\n         b1.set(0, true);\n         b1.set(1, true);\n         b2.set(1, true);\n@@ -2324,8 +2354,8 @@ mod tests {\n \n     #[test]\n     fn test_big_difference() {\n-        let mut b1 = Bitv::from_elem(100, false);\n-        let mut b2 = Bitv::from_elem(100, false);\n+        let mut b1 = BitVec::from_elem(100, false);\n+        let mut b2 = BitVec::from_elem(100, false);\n         b1.set(0, true);\n         b1.set(40, true);\n         b2.set(40, true);\n@@ -2338,24 +2368,24 @@ mod tests {\n \n     #[test]\n     fn test_small_clear() {\n-        let mut b = Bitv::from_elem(14, true);\n+        let mut b = BitVec::from_elem(14, true);\n         assert!(!b.none() && b.all());\n         b.clear();\n         assert!(b.none() && !b.all());\n     }\n \n     #[test]\n     fn test_big_clear() {\n-        let mut b = Bitv::from_elem(140, true);\n+        let mut b = BitVec::from_elem(140, true);\n         assert!(!b.none() && b.all());\n         b.clear();\n         assert!(b.none() && !b.all());\n     }\n \n     #[test]\n-    fn test_bitv_lt() {\n-        let mut a = Bitv::from_elem(5, false);\n-        let mut b = Bitv::from_elem(5, false);\n+    fn test_bit_vec_lt() {\n+        let mut a = BitVec::from_elem(5, false);\n+        let mut b = BitVec::from_elem(5, false);\n \n         assert!(!(a < b) && !(b < a));\n         b.set(2, true);\n@@ -2370,8 +2400,8 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let mut a = Bitv::from_elem(5, false);\n-        let mut b = Bitv::from_elem(5, false);\n+        let mut a = BitVec::from_elem(5, false);\n+        let mut b = BitVec::from_elem(5, false);\n \n         assert!(a <= b && a >= b);\n         a.set(1, true);\n@@ -2385,42 +2415,42 @@ mod tests {\n \n \n     #[test]\n-    fn test_small_bitv_tests() {\n-        let v = Bitv::from_bytes(&[0]);\n+    fn test_small_bit_vec_tests() {\n+        let v = BitVec::from_bytes(&[0]);\n         assert!(!v.all());\n         assert!(!v.any());\n         assert!(v.none());\n \n-        let v = Bitv::from_bytes(&[0b00010100]);\n+        let v = BitVec::from_bytes(&[0b00010100]);\n         assert!(!v.all());\n         assert!(v.any());\n         assert!(!v.none());\n \n-        let v = Bitv::from_bytes(&[0xFF]);\n+        let v = BitVec::from_bytes(&[0xFF]);\n         assert!(v.all());\n         assert!(v.any());\n         assert!(!v.none());\n     }\n \n     #[test]\n-    fn test_big_bitv_tests() {\n-        let v = Bitv::from_bytes(&[ // 88 bits\n+    fn test_big_bit_vec_tests() {\n+        let v = BitVec::from_bytes(&[ // 88 bits\n             0, 0, 0, 0,\n             0, 0, 0, 0,\n             0, 0, 0]);\n         assert!(!v.all());\n         assert!(!v.any());\n         assert!(v.none());\n \n-        let v = Bitv::from_bytes(&[ // 88 bits\n+        let v = BitVec::from_bytes(&[ // 88 bits\n             0, 0, 0b00010100, 0,\n             0, 0, 0, 0b00110100,\n             0, 0, 0]);\n         assert!(!v.all());\n         assert!(v.any());\n         assert!(!v.none());\n \n-        let v = Bitv::from_bytes(&[ // 88 bits\n+        let v = BitVec::from_bytes(&[ // 88 bits\n             0xFF, 0xFF, 0xFF, 0xFF,\n             0xFF, 0xFF, 0xFF, 0xFF,\n             0xFF, 0xFF, 0xFF]);\n@@ -2430,8 +2460,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitv_push_pop() {\n-        let mut s = Bitv::from_elem(5 * u32::BITS - 2, false);\n+    fn test_bit_vec_push_pop() {\n+        let mut s = BitVec::from_elem(5 * u32::BITS - 2, false);\n         assert_eq!(s.len(), 5 * u32::BITS - 2);\n         assert_eq!(s[5 * u32::BITS - 3], false);\n         s.push(true);\n@@ -2453,29 +2483,29 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitv_truncate() {\n-        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+    fn test_bit_vec_truncate() {\n+        let mut s = BitVec::from_elem(5 * u32::BITS, true);\n \n-        assert_eq!(s, Bitv::from_elem(5 * u32::BITS, true));\n+        assert_eq!(s, BitVec::from_elem(5 * u32::BITS, true));\n         assert_eq!(s.len(), 5 * u32::BITS);\n         s.truncate(4 * u32::BITS);\n-        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n         assert_eq!(s.len(), 4 * u32::BITS);\n         // Truncating to a size > s.len() should be a noop\n         s.truncate(5 * u32::BITS);\n-        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n         assert_eq!(s.len(), 4 * u32::BITS);\n         s.truncate(3 * u32::BITS - 10);\n-        assert_eq!(s, Bitv::from_elem(3 * u32::BITS - 10, true));\n+        assert_eq!(s, BitVec::from_elem(3 * u32::BITS - 10, true));\n         assert_eq!(s.len(), 3 * u32::BITS - 10);\n         s.truncate(0);\n-        assert_eq!(s, Bitv::from_elem(0, true));\n+        assert_eq!(s, BitVec::from_elem(0, true));\n         assert_eq!(s.len(), 0);\n     }\n \n     #[test]\n-    fn test_bitv_reserve() {\n-        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+    fn test_bit_vec_reserve() {\n+        let mut s = BitVec::from_elem(5 * u32::BITS, true);\n         // Check capacity\n         assert!(s.capacity() >= 5 * u32::BITS);\n         s.reserve(2 * u32::BITS);\n@@ -2498,25 +2528,25 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitv_grow() {\n-        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n-        bitv.grow(32, true);\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+    fn test_bit_vec_grow() {\n+        let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n+        bit_vec.grow(32, true);\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF]));\n-        bitv.grow(64, false);\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+        bit_vec.grow(64, false);\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n-        bitv.grow(16, true);\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+        bit_vec.grow(16, true);\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n     }\n \n     #[test]\n-    fn test_bitv_extend() {\n-        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n-        let ext = Bitv::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n-        bitv.extend(ext.iter());\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n+    fn test_bit_vec_extend() {\n+        let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let ext = BitVec::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n+        bit_vec.extend(ext.iter());\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n                                      0b01001001, 0b10010010, 0b10111101]));\n     }\n }\n@@ -2525,14 +2555,14 @@ mod tests {\n \n \n #[cfg(test)]\n-mod bitv_bench {\n+mod bit_vec_bench {\n     use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;\n     use test::{Bencher, black_box};\n \n-    use super::Bitv;\n+    use super::BitVec;\n \n     static BENCH_BITS : usize = 1 << 14;\n \n@@ -2544,67 +2574,67 @@ mod bitv_bench {\n     #[bench]\n     fn bench_usize_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = 0 as usize;\n+        let mut bit_vec = 0 as usize;\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv |= 1 << ((r.next_u32() as usize) % u32::BITS);\n+                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_set_big_fixed(b: &mut Bencher) {\n+    fn bench_bit_set_big_fixed(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.set((r.next_u32() as usize) % BENCH_BITS, true);\n+                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, true);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_set_big_variable(b: &mut Bencher) {\n+    fn bench_bit_set_big_variable(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n+                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_set_small(b: &mut Bencher) {\n+    fn bench_bit_set_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::from_elem(u32::BITS, false);\n+        let mut bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.set((r.next_u32() as usize) % u32::BITS, true);\n+                bit_vec.set((r.next_u32() as usize) % u32::BITS, true);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_big_union(b: &mut Bencher) {\n-        let mut b1 = Bitv::from_elem(BENCH_BITS, false);\n-        let b2 = Bitv::from_elem(BENCH_BITS, false);\n+    fn bench_bit_vec_big_union(b: &mut Bencher) {\n+        let mut b1 = BitVec::from_elem(BENCH_BITS, false);\n+        let b2 = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             b1.union(&b2)\n         })\n     }\n \n     #[bench]\n-    fn bench_bitv_small_iter(b: &mut Bencher) {\n-        let bitv = Bitv::from_elem(u32::BITS, false);\n+    fn bench_bit_vec_small_iter(b: &mut Bencher) {\n+        let bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             let mut sum = 0;\n             for _ in 0..10 {\n-                for pres in &bitv {\n+                for pres in &bit_vec {\n                     sum += pres as usize;\n                 }\n             }\n@@ -2613,11 +2643,11 @@ mod bitv_bench {\n     }\n \n     #[bench]\n-    fn bench_bitv_big_iter(b: &mut Bencher) {\n-        let bitv = Bitv::from_elem(BENCH_BITS, false);\n+    fn bench_bit_vec_big_iter(b: &mut Bencher) {\n+        let bit_vec = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             let mut sum = 0;\n-            for pres in &bitv {\n+            for pres in &bit_vec {\n                 sum += pres as usize;\n             }\n             sum\n@@ -2632,55 +2662,55 @@ mod bitv_bench {\n \n \n #[cfg(test)]\n-mod bitv_set_test {\n+mod bit_set_test {\n     use prelude::*;\n     use std::iter::range_step;\n \n-    use super::{Bitv, BitvSet};\n+    use super::{BitVec, BitSet};\n \n     #[test]\n-    fn test_bitv_set_show() {\n-        let mut s = BitvSet::new();\n+    fn test_bit_set_show() {\n+        let mut s = BitSet::new();\n         s.insert(1);\n         s.insert(10);\n         s.insert(50);\n         s.insert(2);\n-        assert_eq!(\"BitvSet {1, 2, 10, 50}\", format!(\"{:?}\", s));\n+        assert_eq!(\"BitSet {1, 2, 10, 50}\", format!(\"{:?}\", s));\n     }\n \n     #[test]\n-    fn test_bitv_set_from_usizes() {\n+    fn test_bit_set_from_usizes() {\n         let usizes = vec![0, 2, 2, 3];\n-        let a: BitvSet = usizes.into_iter().collect();\n-        let mut b = BitvSet::new();\n+        let a: BitSet = usizes.into_iter().collect();\n+        let mut b = BitSet::new();\n         b.insert(0);\n         b.insert(2);\n         b.insert(3);\n         assert_eq!(a, b);\n     }\n \n     #[test]\n-    fn test_bitv_set_iterator() {\n+    fn test_bit_set_iterator() {\n         let usizes = vec![0, 2, 2, 3];\n-        let bitv: BitvSet = usizes.into_iter().collect();\n+        let bit_vec: BitSet = usizes.into_iter().collect();\n \n-        let idxs: Vec<_> = bitv.iter().collect();\n+        let idxs: Vec<_> = bit_vec.iter().collect();\n         assert_eq!(idxs, vec![0, 2, 3]);\n \n-        let long: BitvSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n+        let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n         let real: Vec<_> = range_step(0, 10000, 2).collect();\n \n         let idxs: Vec<_> = long.iter().collect();\n         assert_eq!(idxs, real);\n     }\n \n     #[test]\n-    fn test_bitv_set_frombitv_init() {\n+    fn test_bit_set_frombit_vec_init() {\n         let bools = [true, false];\n         let lengths = [10, 64, 100];\n         for &b in &bools {\n             for &l in &lengths {\n-                let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n+                let bitset = BitSet::from_bit_vec(BitVec::from_elem(l, b));\n                 assert_eq!(bitset.contains(&1), b);\n                 assert_eq!(bitset.contains(&(l-1)), b);\n                 assert!(!bitset.contains(&l));\n@@ -2689,9 +2719,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_masking() {\n-        let b = Bitv::from_elem(140, true);\n-        let mut bs = BitvSet::from_bitv(b);\n+    fn test_bit_vec_masking() {\n+        let b = BitVec::from_elem(140, true);\n+        let mut bs = BitSet::from_bit_vec(b);\n         assert!(bs.contains(&139));\n         assert!(!bs.contains(&140));\n         assert!(bs.insert(150));\n@@ -2702,8 +2732,8 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_basic() {\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_basic() {\n+        let mut b = BitSet::new();\n         assert!(b.insert(3));\n         assert!(!b.insert(3));\n         assert!(b.contains(&3));\n@@ -2717,9 +2747,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_intersection() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_intersection() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n \n         assert!(a.insert(11));\n         assert!(a.insert(1));\n@@ -2740,9 +2770,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_difference() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_difference() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));\n@@ -2759,9 +2789,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_symmetric_difference() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_symmetric_difference() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));\n@@ -2780,9 +2810,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_union() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_union() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n         assert!(a.insert(1));\n         assert!(a.insert(3));\n         assert!(a.insert(5));\n@@ -2805,9 +2835,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_subset() {\n-        let mut set1 = BitvSet::new();\n-        let mut set2 = BitvSet::new();\n+    fn test_bit_set_subset() {\n+        let mut set1 = BitSet::new();\n+        let mut set2 = BitSet::new();\n \n         assert!(set1.is_subset(&set2)); //  {}  {}\n         set2.insert(100);\n@@ -2831,11 +2861,11 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_is_disjoint() {\n-        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01000000]));\n-        let c = BitvSet::new();\n-        let d = BitvSet::from_bitv(Bitv::from_bytes(&[0b00110000]));\n+    fn test_bit_set_is_disjoint() {\n+        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01000000]));\n+        let c = BitSet::new();\n+        let d = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00110000]));\n \n         assert!(!a.is_disjoint(&d));\n         assert!(!d.is_disjoint(&a));\n@@ -2849,19 +2879,19 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_union_with() {\n+    fn test_bit_set_union_with() {\n         //a should grow to include larger elements\n-        let mut a = BitvSet::new();\n+        let mut a = BitSet::new();\n         a.insert(0);\n-        let mut b = BitvSet::new();\n+        let mut b = BitSet::new();\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n+        let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n         a.union_with(&b);\n         assert_eq!(a, expected);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.union_with(&b);\n         b.union_with(&c);\n@@ -2870,28 +2900,28 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_intersect_with() {\n+    fn test_bit_set_intersect_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n         assert!(a.is_empty());\n         assert!(b.is_empty());\n \n         // Uninitialized bits should behave like 0's\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::new();\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::new();\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n         assert!(a.is_empty());\n         assert!(b.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n@@ -2900,22 +2930,22 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_difference_with() {\n+    fn test_bit_set_difference_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Uninitialized bits should behave like 0's\n-        let mut a = BitvSet::new();\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b11111111]));\n+        let mut a = BitSet::new();\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11111111]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.difference_with(&b);\n         b.difference_with(&c);\n@@ -2924,27 +2954,27 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_symmetric_difference_with() {\n+    fn test_bit_set_symmetric_difference_with() {\n         //a should grow to include larger elements\n-        let mut a = BitvSet::new();\n+        let mut a = BitSet::new();\n         a.insert(0);\n         a.insert(1);\n-        let mut b = BitvSet::new();\n+        let mut b = BitSet::new();\n         b.insert(1);\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n+        let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, expected);\n \n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::new();\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::new();\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, c);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b11100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101010]));\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         b.symmetric_difference_with(&c);\n@@ -2953,10 +2983,10 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_eq() {\n-        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n-        let c = BitvSet::new();\n+    fn test_bit_set_eq() {\n+        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+        let c = BitSet::new();\n \n         assert!(a == a);\n         assert!(a != b);\n@@ -2967,10 +2997,10 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_cmp() {\n-        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n-        let c = BitvSet::new();\n+    fn test_bit_set_cmp() {\n+        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+        let c = BitSet::new();\n \n         assert_eq!(a.cmp(&b), Greater);\n         assert_eq!(a.cmp(&c), Greater);\n@@ -2981,8 +3011,8 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_remove() {\n-        let mut a = BitvSet::new();\n+    fn test_bit_vec_remove() {\n+        let mut a = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.remove(&1));\n@@ -2996,8 +3026,8 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_clone() {\n-        let mut a = BitvSet::new();\n+    fn test_bit_vec_clone() {\n+        let mut a = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(100));\n@@ -3020,14 +3050,14 @@ mod bitv_set_test {\n \n \n #[cfg(test)]\n-mod bitv_set_bench {\n+mod bit_set_bench {\n     use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;\n     use test::{Bencher, black_box};\n \n-    use super::{Bitv, BitvSet};\n+    use super::{BitVec, BitSet};\n \n     static BENCH_BITS : usize = 1 << 14;\n \n@@ -3037,36 +3067,36 @@ mod bitv_set_bench {\n     }\n \n     #[bench]\n-    fn bench_bitvset_small(b: &mut Bencher) {\n+    fn bench_bit_vecset_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = BitvSet::new();\n+        let mut bit_vec = BitSet::new();\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.insert((r.next_u32() as usize) % u32::BITS);\n+                bit_vec.insert((r.next_u32() as usize) % u32::BITS);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitvset_big(b: &mut Bencher) {\n+    fn bench_bit_vecset_big(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = BitvSet::new();\n+        let mut bit_vec = BitSet::new();\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.insert((r.next_u32() as usize) % BENCH_BITS);\n+                bit_vec.insert((r.next_u32() as usize) % BENCH_BITS);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitvset_iter(b: &mut Bencher) {\n-        let bitv = BitvSet::from_bitv(Bitv::from_fn(BENCH_BITS,\n+    fn bench_bit_vecset_iter(b: &mut Bencher) {\n+        let bit_vec = BitSet::from_bit_vec(BitVec::from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n             let mut sum = 0;\n-            for idx in &bitv {\n+            for idx in &bit_vec {\n                 sum += idx as usize;\n             }\n             sum"}, {"sha": "901d7a73b51ed27bbc051ccc09a261fc3b5e3353", "filename": "src/libcollections/borrow.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -0,0 +1,316 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A module for working with borrowed data.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use core::clone::Clone;\n+use core::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n+use core::hash::{Hash, Hasher};\n+use core::marker::Sized;\n+use core::ops::Deref;\n+use core::option::Option;\n+\n+use fmt;\n+use alloc::{rc, arc};\n+\n+use self::Cow::*;\n+\n+/// A trait for borrowing data.\n+///\n+/// In general, there may be several ways to \"borrow\" a piece of data.  The\n+/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n+/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n+/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+///\n+/// When writing generic code, it is often desirable to abstract over all ways\n+/// of borrowing data from a given type. That is the role of the `Borrow`\n+/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n+/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n+/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Borrow<Borrowed: ?Sized> {\n+    /// Immutably borrow from an owned value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow(&self) -> &Borrowed;\n+}\n+\n+/// A trait for mutably borrowing data.\n+///\n+/// Similar to `Borrow`, but for mutable borrows.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n+    /// Mutably borrow from an owned value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow_mut(&mut self) -> &mut Borrowed;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Borrow<T> for T {\n+    fn borrow(&self) -> &T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> BorrowMut<T> for T {\n+    fn borrow_mut(&mut self) -> &mut T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a mut T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n+    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n+}\n+\n+impl<T> Borrow<T> for rc::Rc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+impl<T> Borrow<T> for arc::Arc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n+    fn borrow(&self) -> &B {\n+        &**self\n+    }\n+}\n+\n+/// A generalization of Clone to borrowed data.\n+///\n+/// Some types make it possible to go from borrowed to owned, usually by\n+/// implementing the `Clone` trait. But `Clone` works only for going from `&T`\n+/// to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n+/// from any borrow of a given type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ToOwned {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Owned: Borrow<Self>;\n+\n+    /// Create owned data from borrowed data, usually by copying.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_owned(&self) -> Self::Owned;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ToOwned for T where T: Clone {\n+    type Owned = T;\n+    fn to_owned(&self) -> T { self.clone() }\n+}\n+\n+/// A clone-on-write smart pointer.\n+///\n+/// The type `Cow` is a smart pointer providing clone-on-write functionality: it\n+/// can enclose and provide immutable access to borrowed data, and clone the\n+/// data lazily when mutation or ownership is required. The type is designed to\n+/// work with general borrowed data via the `Borrow` trait.\n+///\n+/// `Cow` implements both `Deref`, which means that you can call\n+/// non-mutating methods directly on the data it encloses. If mutation\n+/// is desired, `to_mut` will obtain a mutable references to an owned\n+/// value, cloning if necessary.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::borrow::Cow;\n+///\n+/// fn abs_all(input: &mut Cow<[int]>) {\n+///     for i in 0..input.len() {\n+///         let v = input[i];\n+///         if v < 0 {\n+///             // clones into a vector the first time (if not already owned)\n+///             input.to_mut()[i] = -v;\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Cow<'a, B: ?Sized + 'a> where B: ToOwned {\n+    /// Borrowed data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Borrowed(&'a B),\n+\n+    /// Owned data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Owned(<B as ToOwned>::Owned)\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n+    fn clone(&self) -> Cow<'a, B> {\n+        match *self {\n+            Borrowed(b) => Borrowed(b),\n+            Owned(ref o) => {\n+                let b: &B = o.borrow();\n+                Owned(b.to_owned())\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n+    /// Acquire a mutable reference to the owned form of the data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn to_mut(&mut self) -> &mut <B as ToOwned>::Owned {\n+        match *self {\n+            Borrowed(borrowed) => {\n+                *self = Owned(borrowed.to_owned());\n+                self.to_mut()\n+            }\n+            Owned(ref mut owned) => owned\n+        }\n+    }\n+\n+    /// Extract the owned data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_owned(self) -> <B as ToOwned>::Owned {\n+        match self {\n+            Borrowed(borrowed) => borrowed.to_owned(),\n+            Owned(owned) => owned\n+        }\n+    }\n+\n+    /// Returns true if this `Cow` wraps a borrowed value\n+    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_borrowed(&self) -> bool {\n+        match *self {\n+            Borrowed(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this `Cow` wraps an owned value\n+    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_owned(&self) -> bool {\n+        match *self {\n+            Owned(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Deref for Cow<'a, B> where B: ToOwned {\n+    type Target = B;\n+\n+    fn deref(&self) -> &B {\n+        match *self {\n+            Borrowed(borrowed) => borrowed,\n+            Owned(ref owned) => owned.borrow()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Eq for Cow<'a, B> where B: Eq + ToOwned {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Ord for Cow<'a, B> where B: Ord + ToOwned {\n+    #[inline]\n+    fn cmp(&self, other: &Cow<'a, B>) -> Ordering {\n+        Ord::cmp(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n+    B: PartialEq<C> + ToOwned, C: ToOwned,\n+{\n+    #[inline]\n+    fn eq(&self, other: &Cow<'b, C>) -> bool {\n+        PartialEq::eq(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where B: PartialOrd + ToOwned,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n+    B: fmt::Debug + ToOwned,\n+    <B as ToOwned>::Owned: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n+            Owned(ref o) => fmt::Debug::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n+    B: fmt::Display + ToOwned,\n+    <B as ToOwned>::Owned: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Display::fmt(b, f),\n+            Owned(ref o) => fmt::Display::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n+impl<'a, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, B> where B: Hash<S> + ToOwned\n+{\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        Hash::hash(&**self, state)\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n+{\n+    #[inline]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        Hash::hash(&**self, state)\n+    }\n+}\n+\n+/// Trait for moving into a `Cow`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n+    /// Moves `self` into `Cow`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_cow(self) -> Cow<'a, B>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n+    fn into_cow(self) -> Cow<'a, B> {\n+        self\n+    }\n+}"}, {"sha": "c1d74b16ce6bcacff795ef172f31283a17ec04fb", "filename": "src/libcollections/borrow_stage0.rs", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fborrow_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fborrow_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow_stage0.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -0,0 +1,313 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A module for working with borrowed data.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use core::clone::Clone;\n+use core::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n+use core::hash::{Hash, Hasher};\n+use core::marker::Sized;\n+use core::ops::Deref;\n+use core::option::Option;\n+\n+use fmt;\n+use alloc::{rc, arc};\n+\n+use self::Cow::*;\n+\n+/// A trait for borrowing data.\n+///\n+/// In general, there may be several ways to \"borrow\" a piece of data.  The\n+/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n+/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n+/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+///\n+/// When writing generic code, it is often desirable to abstract over all ways\n+/// of borrowing data from a given type. That is the role of the `Borrow`\n+/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n+/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n+/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Borrow<Borrowed: ?Sized> {\n+    /// Immutably borrow from an owned value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow(&self) -> &Borrowed;\n+}\n+\n+/// A trait for mutably borrowing data.\n+///\n+/// Similar to `Borrow`, but for mutable borrows.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n+    /// Mutably borrow from an owned value.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow_mut(&mut self) -> &mut Borrowed;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Borrow<T> for T {\n+    fn borrow(&self) -> &T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> BorrowMut<T> for T {\n+    fn borrow_mut(&mut self) -> &mut T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a mut T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n+    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n+}\n+\n+impl<T> Borrow<T> for rc::Rc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+impl<T> Borrow<T> for arc::Arc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n+    fn borrow(&self) -> &B {\n+        &**self\n+    }\n+}\n+\n+/// A generalization of Clone to borrowed data.\n+///\n+/// Some types make it possible to go from borrowed to owned, usually by\n+/// implementing the `Clone` trait. But `Clone` works only for going from `&T`\n+/// to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n+/// from any borrow of a given type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ToOwned {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Owned: Borrow<Self>;\n+\n+    /// Create owned data from borrowed data, usually by copying.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_owned(&self) -> Self::Owned;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ToOwned for T where T: Clone {\n+    type Owned = T;\n+    fn to_owned(&self) -> T { self.clone() }\n+}\n+\n+/// A clone-on-write smart pointer.\n+///\n+/// The type `Cow` is a smart pointer providing clone-on-write functionality: it\n+/// can enclose and provide immutable access to borrowed data, and clone the\n+/// data lazily when mutation or ownership is required. The type is designed to\n+/// work with general borrowed data via the `Borrow` trait.\n+///\n+/// `Cow` implements both `Deref`, which means that you can call\n+/// non-mutating methods directly on the data it encloses. If mutation\n+/// is desired, `to_mut` will obtain a mutable references to an owned\n+/// value, cloning if necessary.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::borrow::Cow;\n+///\n+/// fn abs_all(input: &mut Cow<[int]>) {\n+///     for i in 0..input.len() {\n+///         let v = input[i];\n+///         if v < 0 {\n+///             // clones into a vector the first time (if not already owned)\n+///             input.to_mut()[i] = -v;\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Cow<'a, B: ?Sized + 'a> where B: ToOwned {\n+    /// Borrowed data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Borrowed(&'a B),\n+\n+    /// Owned data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Owned(<B as ToOwned>::Owned)\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n+    fn clone(&self) -> Cow<'a, B> {\n+        match *self {\n+            Borrowed(b) => Borrowed(b),\n+            Owned(ref o) => {\n+                let b: &B = o.borrow();\n+                Owned(b.to_owned())\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n+    /// Acquire a mutable reference to the owned form of the data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn to_mut(&mut self) -> &mut <B as ToOwned>::Owned where <B as ToOwned>::Owned: 'a {\n+        match *self {\n+            Borrowed(borrowed) => {\n+                *self = Owned(borrowed.to_owned());\n+                self.to_mut()\n+            }\n+            Owned(ref mut owned) => owned\n+        }\n+    }\n+\n+    /// Extract the owned data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_owned(self) -> <B as ToOwned>::Owned {\n+        match self {\n+            Borrowed(borrowed) => borrowed.to_owned(),\n+            Owned(owned) => owned\n+        }\n+    }\n+\n+    /// Returns true if this `Cow` wraps a borrowed value\n+    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_borrowed(&self) -> bool {\n+        match *self {\n+            Borrowed(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this `Cow` wraps an owned value\n+    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n+    #[unstable(feature = \"std_misc\")]\n+    pub fn is_owned(&self) -> bool {\n+        match *self {\n+            Owned(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Deref for Cow<'a, B> where\n+    B: ToOwned, <B as ToOwned>::Owned: 'a\n+{\n+    type Target = B;\n+\n+    fn deref(&self) -> &B {\n+        match *self {\n+            Borrowed(borrowed) => borrowed,\n+            Owned(ref owned) => owned.borrow()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Eq for Cow<'a, B> where B: Eq + ToOwned, <B as ToOwned>::Owned: 'a {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> Ord for Cow<'a, B> where\n+    B: Ord + ToOwned, <B as ToOwned>::Owned: 'a\n+{\n+    #[inline]\n+    fn cmp(&self, other: &Cow<'a, B>) -> Ordering {\n+        Ord::cmp(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n+    B: PartialEq<C> + ToOwned, C: ToOwned,\n+    <B as ToOwned>::Owned: 'a, <C as ToOwned>::Owned: 'b,\n+{\n+    #[inline]\n+    fn eq(&self, other: &Cow<'b, C>) -> bool {\n+        PartialEq::eq(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where\n+    B: PartialOrd + ToOwned, <B as ToOwned>::Owned: 'a\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&**self, &**other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n+    B: fmt::Debug + ToOwned,\n+    <B as ToOwned>::Owned: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n+            Owned(ref o) => fmt::Debug::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n+    B: fmt::Display + ToOwned,\n+    <B as ToOwned>::Owned: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Display::fmt(b, f),\n+            Owned(ref o) => fmt::Display::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, B> where\n+    B: Hash<S> + ToOwned, <B as ToOwned>::Owned: 'a\n+{\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        Hash::hash(&**self, state)\n+    }\n+}\n+\n+/// Trait for moving into a `Cow`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n+    /// Moves `self` into `Cow`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_cow(self) -> Cow<'a, B>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n+    fn into_cow(self) -> Cow<'a, B> {\n+        self\n+    }\n+}"}, {"sha": "7823f536c7a213a8f5f3b2b8e0c7a6a6fad81c73", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -19,7 +19,6 @@ use self::Entry::*;\n \n use core::prelude::*;\n \n-use core::borrow::BorrowFrom;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Debug;\n@@ -29,7 +28,8 @@ use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n use Bound::{self, Included, Excluded, Unbounded};\n \n-use ring_buf::RingBuf;\n+use borrow::Borrow;\n+use vec_deque::VecDeque;\n \n use self::Continuation::{Continue, Finished};\n use self::StackOp::*;\n@@ -75,7 +75,7 @@ pub struct BTreeMap<K, V> {\n \n /// An abstract base over-which all other BTree iterators are built.\n struct AbsIter<T> {\n-    traversals: RingBuf<T>,\n+    traversals: VecDeque<T>,\n     size: usize,\n }\n \n@@ -208,7 +208,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: Ord {\n         let mut cur_node = &self.root;\n         loop {\n             match Node::search(cur_node, key) {\n@@ -240,7 +240,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where K: Borrow<Q>, Q: Ord {\n         self.get(key).is_some()\n     }\n \n@@ -264,7 +264,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where K: Borrow<Q>, Q: Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -434,7 +434,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where K: Borrow<Q>, Q: Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -512,13 +512,22 @@ mod stack {\n     use super::super::node::handle;\n     use vec::Vec;\n \n+    struct InvariantLifetime<'id>(\n+        marker::PhantomData<::core::cell::Cell<&'id ()>>);\n+\n+    impl<'id> InvariantLifetime<'id> {\n+        fn new() -> InvariantLifetime<'id> {\n+            InvariantLifetime(marker::PhantomData)\n+        }\n+    }\n+\n     /// A generic mutable reference, identical to `&mut` except for the fact that its lifetime\n     /// parameter is invariant. This means that wherever an `IdRef` is expected, only an `IdRef`\n     /// with the exact requested lifetime can be used. This is in contrast to normal references,\n     /// where `&'static` can be used in any function expecting any lifetime reference.\n     pub struct IdRef<'id, T: 'id> {\n         inner: &'id mut T,\n-        marker: marker::InvariantLifetime<'id>\n+        _marker: InvariantLifetime<'id>,\n     }\n \n     impl<'id, T> Deref for IdRef<'id, T> {\n@@ -560,7 +569,7 @@ mod stack {\n     pub struct Pusher<'id, 'a, K:'a, V:'a> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n-        marker: marker::InvariantLifetime<'id>\n+        _marker: InvariantLifetime<'id>,\n     }\n \n     impl<'a, K, V> PartialSearchStack<'a, K, V> {\n@@ -595,11 +604,11 @@ mod stack {\n             let pusher = Pusher {\n                 map: self.map,\n                 stack: self.stack,\n-                marker: marker::InvariantLifetime\n+                _marker: InvariantLifetime::new(),\n             };\n             let node = IdRef {\n                 inner: unsafe { &mut *self.next },\n-                marker: marker::InvariantLifetime\n+                _marker: InvariantLifetime::new(),\n             };\n \n             closure(pusher, node)\n@@ -826,7 +835,7 @@ mod stack {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n-    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n+    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n         map.extend(iter);\n         map\n@@ -836,13 +845,14 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n-    fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n@@ -851,6 +861,15 @@ impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        for elt in self {\n+            elt.hash(state);\n+        }\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Default for BTreeMap<K, V> {\n@@ -903,7 +922,7 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n-    where Q: BorrowFrom<K> + Ord\n+    where K: Borrow<Q>, Q: Ord\n {\n     type Output = V;\n \n@@ -914,7 +933,7 @@ impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n-    where Q: BorrowFrom<K> + Ord\n+    where K: Borrow<Q>, Q: Ord\n {\n     fn index_mut(&mut self, key: &Q) -> &mut V {\n         self.get_mut(key).expect(\"no entry found for key\")\n@@ -1189,7 +1208,7 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n         let len = self.len();\n         // NB. The initial capacity for ringbuf is large enough to avoid reallocs in many cases.\n-        let mut lca = RingBuf::new();\n+        let mut lca = VecDeque::new();\n         lca.push_back(Traverse::traverse(&self.root));\n         Iter {\n             inner: AbsIter {\n@@ -1221,7 +1240,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         let len = self.len();\n-        let mut lca = RingBuf::new();\n+        let mut lca = VecDeque::new();\n         lca.push_back(Traverse::traverse(&mut self.root));\n         IterMut {\n             inner: AbsIter {\n@@ -1250,7 +1269,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n-        let mut lca = RingBuf::new();\n+        let mut lca = VecDeque::new();\n         lca.push_back(Traverse::traverse(self.root));\n         IntoIter {\n             inner: AbsIter {\n@@ -1342,7 +1361,7 @@ macro_rules! range_impl {\n             // A deque that encodes two search paths containing (left-to-right):\n             // a series of truncated-from-the-left iterators, the LCA's doubly-truncated iterator,\n             // and a series of truncated-from-the-right iterators.\n-            let mut traversals = RingBuf::new();\n+            let mut traversals = VecDeque::new();\n             let (root, min, max) = ($root, $min, $max);\n \n             let mut leftmost = None;"}, {"sha": "f0fc12da7275e000d814d796db75a0f58c2a48f2", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 57, "deletions": 36, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -18,13 +18,15 @@ pub use self::TraversalItem::*;\n \n use core::prelude::*;\n \n-use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{Greater, Less, Equal};\n use core::iter::Zip;\n+use core::marker::PhantomData;\n use core::ops::{Deref, DerefMut, Index, IndexMut};\n use core::ptr::Unique;\n use core::{slice, mem, ptr, cmp, num, raw};\n-use alloc::heap;\n+use alloc::heap::{self, EMPTY};\n+\n+use borrow::Borrow;\n \n /// Represents the result of an Insertion: either the item fit, or the node had to split\n pub enum InsertionResult<K, V> {\n@@ -57,8 +59,8 @@ pub struct Node<K, V> {\n     keys: Unique<K>,\n     vals: Unique<V>,\n \n-    // In leaf nodes, this will be null, and no space will be allocated for edges.\n-    edges: Unique<Node<K, V>>,\n+    // In leaf nodes, this will be None, and no space will be allocated for edges.\n+    edges: Option<Unique<Node<K, V>>>,\n \n     // At any given time, there will be `_len` keys, `_len` values, and (in an internal node)\n     // `_len + 1` edges. In a leaf node, there will never be any edges.\n@@ -278,8 +280,11 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.ptr.is_null() {\n-            // We have already cleaned up this node.\n+        if self.keys.is_null() {\n+            // Since we have #[unsafe_no_drop_flag], we have to watch\n+            // out for a null value being stored in self.keys. (Using\n+            // null is technically a violation of the `Unique`\n+            // requirements, though.)\n             return;\n         }\n \n@@ -292,7 +297,7 @@ impl<K, V> Drop for Node<K, V> {\n             self.destroy();\n         }\n \n-        self.keys.ptr = ptr::null_mut();\n+        self.keys = unsafe { Unique::new(0 as *mut K) };\n     }\n }\n \n@@ -308,9 +313,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n \n         Node {\n-            keys: Unique(buffer as *mut K),\n-            vals: Unique(buffer.offset(vals_offset as isize) as *mut V),\n-            edges: Unique(buffer.offset(edges_offset as isize) as *mut Node<K, V>),\n+            keys: Unique::new(buffer as *mut K),\n+            vals: Unique::new(buffer.offset(vals_offset as isize) as *mut V),\n+            edges: Some(Unique::new(buffer.offset(edges_offset as isize) as *mut Node<K, V>)),\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -326,9 +331,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n \n         Node {\n-            keys: Unique(buffer as *mut K),\n-            vals: Unique(unsafe { buffer.offset(vals_offset as isize) as *mut V }),\n-            edges: Unique(ptr::null_mut()),\n+            keys: unsafe { Unique::new(buffer as *mut K) },\n+            vals: unsafe { Unique::new(buffer.offset(vals_offset as isize) as *mut V) },\n+            edges: None,\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -337,18 +342,18 @@ impl<K, V> Node<K, V> {\n     unsafe fn destroy(&mut self) {\n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n-        heap::deallocate(self.keys.ptr as *mut u8, size, alignment);\n+        heap::deallocate(*self.keys as *mut u8, size, alignment);\n     }\n \n     #[inline]\n     pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n         unsafe {(\n             mem::transmute(raw::Slice {\n-                data: self.keys.ptr,\n+                data: *self.keys as *const K,\n                 len: self.len()\n             }),\n             mem::transmute(raw::Slice {\n-                data: self.vals.ptr,\n+                data: *self.vals as *const V,\n                 len: self.len()\n             })\n         )}\n@@ -367,8 +372,12 @@ impl<K, V> Node<K, V> {\n             &[]\n         } else {\n             unsafe {\n+                let data = match self.edges {\n+                    None => heap::EMPTY as *const Node<K,V>,\n+                    Some(ref p) => **p as *const Node<K,V>,\n+                };\n                 mem::transmute(raw::Slice {\n-                    data: self.edges.ptr,\n+                    data: data,\n                     len: self.len() + 1\n                 })\n             }\n@@ -524,7 +533,8 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n #[derive(Copy)]\n pub struct Handle<NodeRef, Type, NodeType> {\n     node: NodeRef,\n-    index: usize\n+    index: usize,\n+    marker: PhantomData<(Type, NodeType)>,\n }\n \n pub mod handle {\n@@ -543,13 +553,13 @@ impl<K: Ord, V> Node<K, V> {\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n     pub fn search<Q: ?Sized, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n-                  -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n+                  -> SearchResult<NodeRef> where K: Borrow<Q>, Q: Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for usizes.\n         match node.as_slices_internal().search_linear(key) {\n-            (index, true) => Found(Handle { node: node, index: index }),\n-            (index, false) => GoDown(Handle { node: node, index: index }),\n+            (index, true) => Found(Handle { node: node, index: index, marker: PhantomData }),\n+            (index, false) => GoDown(Handle { node: node, index: index, marker: PhantomData }),\n         }\n     }\n }\n@@ -586,7 +596,7 @@ impl <K, V> Node<K, V> {\n \n     /// If the node has any children\n     pub fn is_leaf(&self) -> bool {\n-        self.edges.ptr.is_null()\n+        self.edges.is_none()\n     }\n \n     /// if the node has too few elements\n@@ -618,7 +628,8 @@ impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType> where\n     pub fn as_raw(&mut self) -> Handle<*mut Node<K, V>, Type, NodeType> {\n         Handle {\n             node: &mut *self.node as *mut _,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -630,7 +641,8 @@ impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n     pub unsafe fn from_raw<'a>(&'a self) -> Handle<&'a Node<K, V>, Type, NodeType> {\n         Handle {\n             node: &*self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -640,7 +652,8 @@ impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n     pub unsafe fn from_raw_mut<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Type, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -688,12 +701,14 @@ impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type> Handle<NodeRef, Type, handle\n         if self.node.is_leaf() {\n             Leaf(Handle {\n                 node: self.node,\n-                index: self.index\n+                index: self.index,\n+                marker: PhantomData,\n             })\n         } else {\n             Internal(Handle {\n                 node: self.node,\n-                index: self.index\n+                index: self.index,\n+                marker: PhantomData,\n             })\n         }\n     }\n@@ -826,7 +841,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n     unsafe fn left_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index - 1\n+            index: self.index - 1,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -836,7 +852,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n     unsafe fn right_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -876,7 +893,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n     pub fn into_left_edge(self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -926,7 +944,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n     pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index\n+            index: self.index,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -935,7 +954,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n     pub fn right_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n-            index: self.index + 1\n+            index: self.index + 1,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -1044,7 +1064,8 @@ impl<K, V> Node<K, V> {\n         debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n         Handle {\n             node: self,\n-            index: index\n+            index: index,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -1064,7 +1085,7 @@ impl<K, V> Node<K, V> {\n                     vals: RawItems::from_slice(self.vals()),\n                     edges: RawItems::from_slice(self.edges()),\n \n-                    ptr: self.keys.ptr as *mut u8,\n+                    ptr: *self.keys as *mut u8,\n                     capacity: self.capacity(),\n                     is_leaf: self.is_leaf()\n                 },\n@@ -1491,9 +1512,9 @@ macro_rules! node_slice_impl {\n         impl<'a, K: Ord + 'a, V: 'a> $NodeSlice<'a, K, V> {\n             /// Performs linear search in a slice. Returns a tuple of (index, is_exact_match).\n             fn search_linear<Q: ?Sized>(&self, key: &Q) -> (usize, bool)\n-                    where Q: BorrowFrom<K> + Ord {\n+                    where K: Borrow<Q>, Q: Ord {\n                 for (i, k) in self.keys.iter().enumerate() {\n-                    match key.cmp(BorrowFrom::borrow_from(k)) {\n+                    match key.cmp(k.borrow()) {\n                         Greater => {},\n                         Equal => return (i, true),\n                         Less => return (i, false),"}, {"sha": "929b2f58043035105097de82e38a1702575f2477", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -13,14 +13,14 @@\n \n use core::prelude::*;\n \n-use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n use core::default::Default;\n use core::fmt::Debug;\n use core::fmt;\n use core::iter::{Peekable, Map, FromIterator, IntoIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n+use borrow::Borrow;\n use btree_map::{BTreeMap, Keys};\n use Bound;\n \n@@ -336,7 +336,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where T: Borrow<Q>, Q: Ord {\n         self.map.contains_key(value)\n     }\n \n@@ -466,14 +466,14 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where T: Borrow<Q>, Q: Ord {\n         self.map.remove(value).is_some()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n-    fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BTreeSet<T> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n         set.extend(iter);\n         set\n@@ -503,7 +503,7 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n-    fn extend<Iter: Iterator<Item=T>>(&mut self, iter: Iter) {\n+    fn extend<Iter: IntoIterator<Item=T>>(&mut self, iter: Iter) {\n         for elem in iter {\n             self.insert(elem);\n         }"}, {"sha": "0c95742606083fbe33402ca667d840ed620c406c", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -14,6 +14,7 @@\n //! representation to hold C-like enum variants.\n \n use core::prelude::*;\n+use core::marker;\n use core::fmt;\n use core::num::Int;\n use core::iter::{FromIterator, IntoIterator};\n@@ -26,7 +27,8 @@ use core::ops::{Sub, BitOr, BitAnd, BitXor};\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n-    bits: usize\n+    bits: usize,\n+    marker: marker::PhantomData<E>,\n }\n \n impl<E> Copy for EnumSet<E> {}\n@@ -86,7 +88,7 @@ impl<E:CLike> EnumSet<E> {\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn new() -> EnumSet<E> {\n-        EnumSet {bits: 0}\n+        EnumSet {bits: 0, marker: marker::PhantomData}\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n@@ -130,12 +132,14 @@ impl<E:CLike> EnumSet<E> {\n \n     /// Returns the union of both `EnumSets`.\n     pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits}\n+        EnumSet {bits: self.bits | e.bits,\n+                 marker: marker::PhantomData}\n     }\n \n     /// Returns the intersection of both `EnumSets`.\n     pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits}\n+        EnumSet {bits: self.bits & e.bits,\n+                 marker: marker::PhantomData}\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n@@ -175,38 +179,39 @@ impl<E:CLike> Sub for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & !e.bits}\n+        EnumSet {bits: self.bits & !e.bits, marker: marker::PhantomData}\n     }\n }\n \n impl<E:CLike> BitOr for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits}\n+        EnumSet {bits: self.bits | e.bits, marker: marker::PhantomData}\n     }\n }\n \n impl<E:CLike> BitAnd for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits}\n+        EnumSet {bits: self.bits & e.bits, marker: marker::PhantomData}\n     }\n }\n \n impl<E:CLike> BitXor for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits ^ e.bits}\n+        EnumSet {bits: self.bits ^ e.bits, marker: marker::PhantomData}\n     }\n }\n \n /// An iterator over an EnumSet\n pub struct Iter<E> {\n     index: usize,\n     bits: usize,\n+    marker: marker::PhantomData<E>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -215,13 +220,14 @@ impl<E> Clone for Iter<E> {\n         Iter {\n             index: self.index,\n             bits: self.bits,\n+            marker: marker::PhantomData,\n         }\n     }\n }\n \n impl<E:CLike> Iter<E> {\n     fn new(bits: usize) -> Iter<E> {\n-        Iter { index: 0, bits: bits }\n+        Iter { index: 0, bits: bits, marker: marker::PhantomData }\n     }\n }\n \n@@ -250,9 +256,9 @@ impl<E:CLike> Iterator for Iter<E> {\n }\n \n impl<E:CLike> FromIterator<E> for EnumSet<E> {\n-    fn from_iter<I:Iterator<Item=E>>(iterator: I) -> EnumSet<E> {\n+    fn from_iter<I: IntoIterator<Item=E>>(iter: I) -> EnumSet<E> {\n         let mut ret = EnumSet::new();\n-        ret.extend(iterator);\n+        ret.extend(iter);\n         ret\n     }\n }\n@@ -268,8 +274,8 @@ impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n }\n \n impl<E:CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: Iterator<Item=E>>(&mut self, iterator: I) {\n-        for element in iterator {\n+    fn extend<I: IntoIterator<Item=E>>(&mut self, iter: I) {\n+        for element in iter {\n             self.insert(element);\n         }\n     }"}, {"sha": "6569ab9c05acd768f56d4d4d5d9b9ddd32c65943", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -26,7 +26,6 @@\n #![feature(box_syntax)]\n #![feature(box_patterns)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n@@ -49,17 +48,33 @@ extern crate alloc;\n #[cfg(test)] #[macro_use] extern crate log;\n \n pub use binary_heap::BinaryHeap;\n-pub use bitv::Bitv;\n-pub use bitv_set::BitvSet;\n+pub use bit_vec::BitVec;\n+pub use bit_set::BitSet;\n pub use btree_map::BTreeMap;\n pub use btree_set::BTreeSet;\n-pub use dlist::DList;\n+pub use linked_list::LinkedList;\n pub use enum_set::EnumSet;\n-pub use ring_buf::RingBuf;\n+pub use vec_deque::VecDeque;\n pub use string::String;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n+#[deprecated(since = \"1.0.0\", reason = \"renamed to vec_deque\")]\n+#[unstable(feature = \"collections\")]\n+pub use vec_deque as ring_buf;\n+\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to linked_list\")]\n+#[unstable(feature = \"collections\")]\n+pub use linked_list as dlist;\n+\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_vec\")]\n+#[unstable(feature = \"collections\")]\n+pub use bit_vec as bitv;\n+\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_set\")]\n+#[unstable(feature = \"collections\")]\n+pub use bit_set as bitv_set;\n+\n // Needed for the vec! macro\n pub use alloc::boxed;\n \n@@ -71,27 +86,42 @@ mod macros;\n pub mod binary_heap;\n mod bit;\n mod btree;\n-pub mod dlist;\n+pub mod linked_list;\n pub mod enum_set;\n pub mod fmt;\n-pub mod ring_buf;\n+pub mod vec_deque;\n pub mod slice;\n pub mod str;\n pub mod string;\n pub mod vec;\n pub mod vec_map;\n \n+#[cfg(stage0)]\n+#[path = \"borrow_stage0.rs\"]\n+pub mod borrow;\n+\n+#[cfg(not(stage0))]\n+pub mod borrow;\n+\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub mod bitv {\n-    pub use bit::{Bitv, Iter};\n+pub mod bit_vec {\n+    pub use bit::{BitVec, Iter};\n+\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitVec\")]\n+    #[unstable(feature = \"collections\")]\n+    pub use bit::BitVec as Bitv;\n }\n \n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub mod bitv_set {\n-    pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n+pub mod bit_set {\n+    pub use bit::{BitSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n+\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitSet\")]\n+    #[unstable(feature = \"collections\")]\n+    pub use bit::BitSet as BitvSet;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -117,7 +147,6 @@ mod std {\n #[cfg(test)]\n mod prelude {\n     // from core.\n-    pub use core::borrow::IntoCow;\n     pub use core::clone::Clone;\n     pub use core::cmp::{PartialEq, Eq, PartialOrd, Ord};\n     pub use core::cmp::Ordering::{Less, Equal, Greater};\n@@ -143,6 +172,7 @@ mod prelude {\n     pub use unicode::char::CharExt;\n \n     // from collections.\n+    pub use borrow::IntoCow;\n     pub use slice::SliceConcatExt;\n     pub use string::{String, ToString};\n     pub use vec::Vec;"}, {"sha": "c142819a5189671bf8400aed0fe5c0fe357a48c6", "filename": "src/libcollections/linked_list.rs", "status": "renamed", "additions": 137, "deletions": 120, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -10,13 +10,13 @@\n \n //! A doubly-linked list with owned nodes.\n //!\n-//! The `DList` allows pushing and popping elements at either end and is thus\n+//! The `LinkedList` allows pushing and popping elements at either end and is thus\n //! efficiently usable as a double-ended queue.\n \n-// DList is constructed like a singly-linked list over the field `next`.\n+// LinkedList is constructed like a singly-linked list over the field `next`.\n // including the last link being None; each Node owns its `next` field.\n //\n-// Backlinks over DList::prev are raw pointers that form a full chain in\n+// Backlinks over LinkedList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -27,14 +27,20 @@ use alloc::boxed::Box;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::hash::{Writer, Hasher, Hash};\n+use core::hash::{Hasher, Hash};\n+#[cfg(stage0)]\n+use core::hash::Writer;\n use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n \n+#[deprecated(since = \"1.0.0\", reason = \"renamed to LinkedList\")]\n+#[unstable(feature = \"collections\")]\n+pub use LinkedList as DList;\n+\n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct DList<T> {\n+pub struct LinkedList<T> {\n     length: usize,\n     list_head: Link<T>,\n     list_tail: Rawlink<Node<T>>,\n@@ -56,7 +62,7 @@ struct Node<T> {\n     value: T,\n }\n \n-/// An iterator over references to the items of a `DList`.\n+/// An iterator over references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n@@ -76,20 +82,20 @@ impl<'a, T> Clone for Iter<'a, T> {\n     }\n }\n \n-/// An iterator over mutable references to the items of a `DList`.\n+/// An iterator over mutable references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n-    list: &'a mut DList<T>,\n+    list: &'a mut LinkedList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n     nelem: usize,\n }\n \n-/// An iterator over mutable references to the items of a `DList`.\n+/// An iterator over mutable references to the items of a `LinkedList`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    list: DList<T>\n+    list: LinkedList<T>\n }\n \n /// Rawlink is a type like Option<T> but for holding a raw pointer\n@@ -147,7 +153,7 @@ fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)\n }\n \n // private methods\n-impl<T> DList<T> {\n+impl<T> LinkedList<T> {\n     /// Add a Node first in the list\n     #[inline]\n     fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {\n@@ -207,18 +213,18 @@ impl<T> DList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Default for DList<T> {\n+impl<T> Default for LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> DList<T> { DList::new() }\n+    fn default() -> LinkedList<T> { LinkedList::new() }\n }\n \n-impl<T> DList<T> {\n-    /// Creates an empty `DList`.\n+impl<T> LinkedList<T> {\n+    /// Creates an empty `LinkedList`.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> DList<T> {\n-        DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n+    pub fn new() -> LinkedList<T> {\n+        LinkedList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n     /// Moves all elements from `other` to the end of the list.\n@@ -231,10 +237,10 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut a = DList::new();\n-    /// let mut b = DList::new();\n+    /// let mut a = LinkedList::new();\n+    /// let mut b = LinkedList::new();\n     /// a.push_back(1);\n     /// a.push_back(2);\n     /// b.push_back(3);\n@@ -247,7 +253,7 @@ impl<T> DList<T> {\n     /// }\n     /// println!(\"{}\", b.len()); // prints 0\n     /// ```\n-    pub fn append(&mut self, other: &mut DList<T>) {\n+    pub fn append(&mut self, other: &mut LinkedList<T>) {\n         match self.list_tail.resolve() {\n             None => {\n                 self.length = other.length;\n@@ -301,16 +307,16 @@ impl<T> DList<T> {\n         IntoIter{list: self}\n     }\n \n-    /// Returns `true` if the `DList` is empty.\n+    /// Returns `true` if the `LinkedList` is empty.\n     ///\n     /// This operation should compute in O(1) time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert!(dl.is_empty());\n     ///\n     /// dl.push_front(\"foo\");\n@@ -322,16 +328,16 @@ impl<T> DList<T> {\n         self.list_head.is_none()\n     }\n \n-    /// Returns the length of the `DList`.\n+    /// Returns the length of the `LinkedList`.\n     ///\n     /// This operation should compute in O(1) time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     ///\n     /// dl.push_front(2);\n     /// assert_eq!(dl.len(), 1);\n@@ -349,16 +355,16 @@ impl<T> DList<T> {\n         self.length\n     }\n \n-    /// Removes all elements from the `DList`.\n+    /// Removes all elements from the `LinkedList`.\n     ///\n     /// This operation should compute in O(n) time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     ///\n     /// dl.push_front(2);\n     /// dl.push_front(1);\n@@ -373,7 +379,7 @@ impl<T> DList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        *self = DList::new()\n+        *self = LinkedList::new()\n     }\n \n     /// Provides a reference to the front element, or `None` if the list is\n@@ -382,9 +388,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.front(), None);\n     ///\n     /// dl.push_front(1);\n@@ -403,9 +409,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.front(), None);\n     ///\n     /// dl.push_front(1);\n@@ -430,9 +436,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.back(), None);\n     ///\n     /// dl.push_back(1);\n@@ -451,9 +457,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.back(), None);\n     ///\n     /// dl.push_back(1);\n@@ -479,9 +485,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     ///\n     /// dl.push_front(2);\n     /// assert_eq!(dl.front().unwrap(), &2);\n@@ -503,9 +509,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     /// assert_eq!(d.pop_front(), None);\n     ///\n     /// d.push_front(1);\n@@ -526,9 +532,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     /// d.push_back(1);\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n@@ -544,9 +550,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     /// assert_eq!(d.pop_back(), None);\n     /// d.push_back(1);\n     /// d.push_back(3);\n@@ -569,9 +575,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     ///\n     /// d.push_front(1);\n     /// d.push_front(2);\n@@ -583,13 +589,13 @@ impl<T> DList<T> {\n     /// assert_eq!(splitted.pop_front(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn split_off(&mut self, at: usize) -> DList<T> {\n+    pub fn split_off(&mut self, at: usize) -> LinkedList<T> {\n         let len = self.len();\n         assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n-            return mem::replace(self, DList::new());\n+            return mem::replace(self, LinkedList::new());\n         } else if at == len {\n-            return DList::new();\n+            return LinkedList::new();\n         }\n \n         // Below, we iterate towards the `i-1`th node, either from the start or the end,\n@@ -612,7 +618,7 @@ impl<T> DList<T> {\n             iter.tail\n         };\n \n-        let mut splitted_list = DList {\n+        let mut splitted_list = LinkedList {\n             list_head: None,\n             list_tail: self.list_tail,\n             length: len - at\n@@ -628,9 +634,9 @@ impl<T> DList<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for DList<T> {\n+impl<T> Drop for LinkedList<T> {\n     fn drop(&mut self) {\n-        // Dissolve the dlist in backwards direction\n+        // Dissolve the linked_list in backwards direction\n         // Just dropping the list_head can lead to stack exhaustion\n         // when length is >> 1_000_000\n         let mut tail = self.list_tail;\n@@ -761,9 +767,9 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut list: DList<_> = vec![1, 3, 4].into_iter().collect();\n+    /// let mut list: LinkedList<_> = vec![1, 3, 4].into_iter().collect();\n     ///\n     /// {\n     ///     let mut it = list.iter_mut();\n@@ -788,9 +794,9 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut list: DList<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let mut list: LinkedList<_> = vec![1, 2, 3].into_iter().collect();\n     ///\n     /// let mut it = list.iter_mut();\n     /// assert_eq!(it.next().unwrap(), &1);\n@@ -829,16 +835,16 @@ impl<A> DoubleEndedIterator for IntoIter<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for DList<A> {\n-    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> DList<A> {\n+impl<A> FromIterator<A> for LinkedList<A> {\n+    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> LinkedList<A> {\n         let mut ret = DList::new();\n-        ret.extend(iterator);\n+        ret.extend(iter);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for DList<T> {\n+impl<T> IntoIterator for LinkedList<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -848,7 +854,7 @@ impl<T> IntoIterator for DList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a DList<T> {\n+impl<'a, T> IntoIterator for &'a LinkedList<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -857,7 +863,7 @@ impl<'a, T> IntoIterator for &'a DList<T> {\n     }\n }\n \n-impl<'a, T> IntoIterator for &'a mut DList<T> {\n+impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n@@ -867,54 +873,54 @@ impl<'a, T> IntoIterator for &'a mut DList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for DList<A> {\n-    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n-        for elt in iterator { self.push_back(elt); }\n+impl<A> Extend<A> for LinkedList<A> {\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T) {\n+        for elt in iter { self.push_back(elt); }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for DList<A> {\n-    fn eq(&self, other: &DList<A>) -> bool {\n+impl<A: PartialEq> PartialEq for LinkedList<A> {\n+    fn eq(&self, other: &LinkedList<A>) -> bool {\n         self.len() == other.len() &&\n             iter::order::eq(self.iter(), other.iter())\n     }\n \n-    fn ne(&self, other: &DList<A>) -> bool {\n+    fn ne(&self, other: &LinkedList<A>) -> bool {\n         self.len() != other.len() ||\n             iter::order::ne(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for DList<A> {}\n+impl<A: Eq> Eq for LinkedList<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for DList<A> {\n-    fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n+impl<A: PartialOrd> PartialOrd for LinkedList<A> {\n+    fn partial_cmp(&self, other: &LinkedList<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for DList<A> {\n+impl<A: Ord> Ord for LinkedList<A> {\n     #[inline]\n-    fn cmp(&self, other: &DList<A>) -> Ordering {\n+    fn cmp(&self, other: &LinkedList<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> Clone for DList<A> {\n-    fn clone(&self) -> DList<A> {\n-        self.iter().map(|x| x.clone()).collect()\n+impl<A: Clone> Clone for LinkedList<A> {\n+    fn clone(&self) -> LinkedList<A> {\n+        self.iter().cloned().collect()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: fmt::Debug> fmt::Debug for DList<A> {\n+impl<A: fmt::Debug> fmt::Debug for LinkedList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"DList [\"));\n+        try!(write!(f, \"LinkedList [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -926,14 +932,25 @@ impl<A: fmt::Debug> fmt::Debug for DList<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n+#[cfg(stage0)]\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for LinkedList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self {\n             elt.hash(state);\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<A: Hash> Hash for LinkedList<A> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.len().hash(state);\n+        for elt in self {\n+            elt.hash(state);\n+        }\n+    }\n+}\n \n #[cfg(test)]\n mod tests {\n@@ -944,9 +961,9 @@ mod tests {\n     use test::Bencher;\n     use test;\n \n-    use super::{DList, Node};\n+    use super::{LinkedList, Node};\n \n-    pub fn check_links<T>(list: &DList<T>) {\n+    pub fn check_links<T>(list: &LinkedList<T>) {\n         let mut len = 0;\n         let mut last_ptr: Option<&Node<T>> = None;\n         let mut node_ptr: &Node<T>;\n@@ -980,7 +997,7 @@ mod tests {\n \n     #[test]\n     fn test_basic() {\n-        let mut m = DList::new();\n+        let mut m = LinkedList::new();\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n@@ -999,7 +1016,7 @@ mod tests {\n         m.push_back(box 7);\n         assert_eq!(m.pop_front(), Some(box 1));\n \n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         n.push_front(2);\n         n.push_front(3);\n         {\n@@ -1019,30 +1036,30 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn generate_test() -> DList<i32> {\n+    fn generate_test() -> LinkedList<i32> {\n         list_from(&[0,1,2,3,4,5,6])\n     }\n \n     #[cfg(test)]\n-    fn list_from<T: Clone>(v: &[T]) -> DList<T> {\n-        v.iter().map(|x| (*x).clone()).collect()\n+    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n+        v.iter().cloned().collect()\n     }\n \n     #[test]\n     fn test_append() {\n         // Empty to empty\n         {\n-            let mut m = DList::<i32>::new();\n-            let mut n = DList::new();\n+            let mut m = LinkedList::<i32>::new();\n+            let mut n = LinkedList::new();\n             m.append(&mut n);\n             check_links(&m);\n             assert_eq!(m.len(), 0);\n             assert_eq!(n.len(), 0);\n         }\n         // Non-empty to empty\n         {\n-            let mut m = DList::new();\n-            let mut n = DList::new();\n+            let mut m = LinkedList::new();\n+            let mut n = LinkedList::new();\n             n.push_back(2);\n             m.append(&mut n);\n             check_links(&m);\n@@ -1053,8 +1070,8 @@ mod tests {\n         }\n         // Empty to non-empty\n         {\n-            let mut m = DList::new();\n-            let mut n = DList::new();\n+            let mut m = LinkedList::new();\n+            let mut n = LinkedList::new();\n             m.push_back(2);\n             m.append(&mut n);\n             check_links(&m);\n@@ -1089,7 +1106,7 @@ mod tests {\n     fn test_split_off() {\n         // singleton\n         {\n-            let mut m = DList::new();\n+            let mut m = LinkedList::new();\n             m.push_back(1);\n \n             let p = m.split_off(0);\n@@ -1130,7 +1147,7 @@ mod tests {\n \n         // no-op on the last index\n         {\n-            let mut m = DList::new();\n+            let mut m = LinkedList::new();\n             m.push_back(1);\n \n             let p = m.split_off(1);\n@@ -1148,7 +1165,7 @@ mod tests {\n         for (i, elt) in m.iter().enumerate() {\n             assert_eq!(i as i32, *elt);\n         }\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert_eq!(n.iter().next(), None);\n         n.push_front(4);\n         let mut it = n.iter();\n@@ -1160,7 +1177,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_clone() {\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         n.push_back(2);\n         n.push_back(3);\n         n.push_back(4);\n@@ -1174,7 +1191,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_double_end() {\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert_eq!(n.iter().next(), None);\n         n.push_front(4);\n         n.push_front(5);\n@@ -1196,7 +1213,7 @@ mod tests {\n         for (i, elt) in m.iter().rev().enumerate() {\n             assert_eq!((6 - i) as i32, *elt);\n         }\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert_eq!(n.iter().rev().next(), None);\n         n.push_front(4);\n         let mut it = n.iter().rev();\n@@ -1215,7 +1232,7 @@ mod tests {\n             len -= 1;\n         }\n         assert_eq!(len, 0);\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert!(n.iter_mut().next().is_none());\n         n.push_front(4);\n         n.push_back(5);\n@@ -1229,7 +1246,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_mut_double_end() {\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert!(n.iter_mut().next_back().is_none());\n         n.push_front(4);\n         n.push_front(5);\n@@ -1278,7 +1295,7 @@ mod tests {\n         for (i, elt) in m.iter_mut().rev().enumerate() {\n             assert_eq!((6 - i) as i32, *elt);\n         }\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert!(n.iter_mut().rev().next().is_none());\n         n.push_front(4);\n         let mut it = n.iter_mut().rev();\n@@ -1313,8 +1330,8 @@ mod tests {\n \n     #[test]\n     fn test_hash() {\n-      let mut x = DList::new();\n-      let mut y = DList::new();\n+      let mut x = LinkedList::new();\n+      let mut y = LinkedList::new();\n \n       assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n \n@@ -1382,16 +1399,16 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let list: DList<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        let list: LinkedList<_> = (0..10).collect();\n+        assert_eq!(format!(\"{:?}\", list), \"LinkedList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let list: DList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-        assert_eq!(format!(\"{:?}\", list), \"DList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+        let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n+        assert_eq!(format!(\"{:?}\", list), \"LinkedList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[cfg(test)]\n     fn fuzz_test(sz: i32) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         let mut v = vec![];\n         for i in 0..sz {\n             check_links(&m);\n@@ -1432,29 +1449,29 @@ mod tests {\n     fn bench_collect_into(b: &mut test::Bencher) {\n         let v = &[0; 64];\n         b.iter(|| {\n-            let _: DList<_> = v.iter().cloned().collect();\n+            let _: LinkedList<_> = v.iter().cloned().collect();\n         })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_front(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_back(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_back(0);\n             m.pop_back();\n@@ -1463,7 +1480,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_pop_front(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_front(0);\n             m.pop_front();\n@@ -1473,31 +1490,31 @@ mod tests {\n     #[bench]\n     fn bench_iter(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<_> = v.iter().cloned().collect();\n+        let m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<_> = v.iter().cloned().collect();\n+        let mut m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<_> = v.iter().cloned().collect();\n+        let m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().rev().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<_> = v.iter().cloned().collect();\n+        let mut m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().rev().count() == 128);\n         })", "previous_filename": "src/libcollections/dlist.rs"}, {"sha": "776b8b3af147c262b31fafccd74c9b376f070279", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -88,7 +88,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n-use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n use core::clone::Clone;\n use core::cmp::Ordering::{self, Greater, Less};\n use core::cmp::{self, Ord, PartialEq};\n@@ -105,6 +104,7 @@ use core::result::Result;\n use core::slice as core_slice;\n use self::Direction::*;\n \n+use borrow::{Borrow, BorrowMut, ToOwned};\n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, Windows};\n@@ -1175,18 +1175,19 @@ impl ElementSwaps {\n // Standard trait implementations for slices\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl<T> BorrowFrom<Vec<T>> for [T] {\n-    fn borrow_from(owned: &Vec<T>) -> &[T] { &owned[] }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Borrow<[T]> for Vec<T> {\n+    fn borrow(&self) -> &[T] { &self[..] }\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { &mut owned[] }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> BorrowMut<[T]> for Vec<T> {\n+    fn borrow_mut(&mut self) -> &mut [T] { &mut self[..] }\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl<T: Clone> ToOwned<Vec<T>> for [T] {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Clone> ToOwned for [T] {\n+    type Owned = Vec<T>;\n     fn to_owned(&self) -> Vec<T> { self.to_vec() }\n }\n \n@@ -1743,7 +1744,7 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(&vec[], vec);\n+        assert_eq!(&vec[..], vec);\n         let b: &[_] = &[3, 4];\n         assert_eq!(&vec[2..], b);\n         let b: &[_] = &[];\n@@ -2264,15 +2265,15 @@ mod tests {\n     #[test]\n     fn test_total_ord() {\n         let c = &[1, 2, 3];\n-        [1, 2, 3, 4][].cmp(c) == Greater;\n+        [1, 2, 3, 4][..].cmp(c) == Greater;\n         let c = &[1, 2, 3, 4];\n-        [1, 2, 3][].cmp(c) == Less;\n+        [1, 2, 3][..].cmp(c) == Less;\n         let c = &[1, 2, 3, 6];\n-        [1, 2, 3, 4][].cmp(c) == Equal;\n+        [1, 2, 3, 4][..].cmp(c) == Equal;\n         let c = &[1, 2, 3, 4, 5, 6];\n-        [1, 2, 3, 4, 5, 5, 5, 5][].cmp(c) == Less;\n+        [1, 2, 3, 4, 5, 5, 5, 5][..].cmp(c) == Less;\n         let c = &[1, 2, 3, 4];\n-        [2, 2][].cmp(c) == Greater;\n+        [2, 2][..].cmp(c) == Greater;\n     }\n \n     #[test]"}, {"sha": "ec0a487acdc77c734c2ae207624c869e95708e25", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -55,7 +55,6 @@\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n \n-use core::borrow::{BorrowFrom, ToOwned};\n use core::char::CharExt;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n@@ -68,7 +67,8 @@ use core::slice::AsSlice;\n use core::str as core_str;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n-use ring_buf::RingBuf;\n+use vec_deque::VecDeque;\n+use borrow::{Borrow, ToOwned};\n use slice::SliceExt;\n use string::String;\n use unicode;\n@@ -261,7 +261,7 @@ enum RecompositionState {\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n-    buffer: RingBuf<char>,\n+    buffer: VecDeque<char>,\n     composee: Option<char>,\n     last_ccc: Option<u8>\n }\n@@ -386,13 +386,14 @@ macro_rules! utf8_acc_cont_byte {\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl BorrowFrom<String> for str {\n-    fn borrow_from(owned: &String) -> &str { &owned[] }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Borrow<str> for String {\n+    fn borrow(&self) -> &str { &self[..] }\n }\n \n-#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n-impl ToOwned<String> for str {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToOwned for str {\n+    type Owned = String;\n     fn to_owned(&self) -> String {\n         unsafe {\n             String::from_utf8_unchecked(self.as_bytes().to_owned())\n@@ -466,7 +467,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n                reason = \"this functionality may be moved to libunicode\")]\n     fn nfd_chars(&self) -> Decompositions {\n         Decompositions {\n-            iter: self[].chars(),\n+            iter: self[..].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Canonical\n@@ -480,7 +481,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n                reason = \"this functionality may be moved to libunicode\")]\n     fn nfkd_chars(&self) -> Decompositions {\n         Decompositions {\n-            iter: self[].chars(),\n+            iter: self[..].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Compatible\n@@ -496,7 +497,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         Recompositions {\n             iter: self.nfd_chars(),\n             state: Composing,\n-            buffer: RingBuf::new(),\n+            buffer: VecDeque::new(),\n             composee: None,\n             last_ccc: None\n         }\n@@ -511,7 +512,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         Recompositions {\n             iter: self.nfkd_chars(),\n             state: Composing,\n-            buffer: RingBuf::new(),\n+            buffer: VecDeque::new(),\n             composee: None,\n             last_ccc: None\n         }\n@@ -530,7 +531,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, pat: &str) -> bool {\n-        core_str::StrExt::contains(&self[], pat)\n+        core_str::StrExt::contains(&self[..], pat)\n     }\n \n     /// Returns true if a string contains a char pattern.\n@@ -547,7 +548,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in favour of a more generic contains()\")]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n-        core_str::StrExt::contains_char(&self[], pat)\n+        core_str::StrExt::contains_char(&self[..], pat)\n     }\n \n     /// An iterator over the characters of `self`. Note, this iterates\n@@ -561,7 +562,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(&self[])\n+        core_str::StrExt::chars(&self[..])\n     }\n \n     /// An iterator over the bytes of `self`\n@@ -574,13 +575,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(&self[])\n+        core_str::StrExt::bytes(&self[..])\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(&self[])\n+        core_str::StrExt::char_indices(&self[..])\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -603,7 +604,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n-        core_str::StrExt::split(&self[], pat)\n+        core_str::StrExt::split(&self[..], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -630,7 +631,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n-        core_str::StrExt::splitn(&self[], count, pat)\n+        core_str::StrExt::splitn(&self[..], count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -659,7 +660,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\", reason = \"might get removed\")]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n-        core_str::StrExt::split_terminator(&self[], pat)\n+        core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -680,7 +681,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n-        core_str::StrExt::rsplitn(&self[], count, pat)\n+        core_str::StrExt::rsplitn(&self[..], count, pat)\n     }\n \n     /// An iterator over the start and end indices of the disjoint\n@@ -706,7 +707,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n-        core_str::StrExt::match_indices(&self[], pat)\n+        core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n     /// An iterator over the substrings of `self` separated by the pattern `sep`.\n@@ -723,7 +724,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in the future in favor of a more generic split()\")]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n-        core_str::StrExt::split_str(&self[], pat)\n+        core_str::StrExt::split_str(&self[..], pat)\n     }\n \n     /// An iterator over the lines of a string (subsequences separated\n@@ -739,7 +740,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(&self[])\n+        core_str::StrExt::lines(&self[..])\n     }\n \n     /// An iterator over the lines of a string, separated by either\n@@ -755,7 +756,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(&self[])\n+        core_str::StrExt::lines_any(&self[..])\n     }\n \n     /// Deprecated: use `s[a .. b]` instead.\n@@ -802,7 +803,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"may have yet to prove its worth\")]\n     fn slice_chars(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_chars(&self[], begin, end)\n+        core_str::StrExt::slice_chars(&self[..], begin, end)\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -813,7 +814,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// the entire slice as well.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_unchecked(&self[], begin, end)\n+        core_str::StrExt::slice_unchecked(&self[..], begin, end)\n     }\n \n     /// Returns true if the pattern `pat` is a prefix of the string.\n@@ -825,7 +826,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::starts_with(&self[], pat)\n+        core_str::StrExt::starts_with(&self[..], pat)\n     }\n \n     /// Returns true if the pattern `pat` is a suffix of the string.\n@@ -837,7 +838,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ends_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::ends_with(&self[], pat)\n+        core_str::StrExt::ends_with(&self[..], pat)\n     }\n \n     /// Returns a string with all pre- and suffixes that match\n@@ -857,7 +858,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_matches(&self[], pat)\n+        core_str::StrExt::trim_matches(&self[..], pat)\n     }\n \n     /// Returns a string with all prefixes that match\n@@ -877,7 +878,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_left_matches(&self[], pat)\n+        core_str::StrExt::trim_left_matches(&self[..], pat)\n     }\n \n     /// Returns a string with all suffixes that match\n@@ -897,7 +898,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_right_matches(&self[], pat)\n+        core_str::StrExt::trim_right_matches(&self[..], pat)\n     }\n \n     /// Check that `index`-th byte lies at the start and/or end of a\n@@ -926,7 +927,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn is_char_boundary(&self, index: usize) -> bool {\n-        core_str::StrExt::is_char_boundary(&self[], index)\n+        core_str::StrExt::is_char_boundary(&self[..], index)\n     }\n \n     /// Pluck a character out of a string and return the index of the next\n@@ -985,7 +986,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at(&self[], start)\n+        core_str::StrExt::char_range_at(&self[..], start)\n     }\n \n     /// Given a byte position and a str, return the previous char and its position.\n@@ -1001,7 +1002,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at_reverse(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at_reverse(&self[], start)\n+        core_str::StrExt::char_range_at_reverse(&self[..], start)\n     }\n \n     /// Plucks the character starting at the `i`th byte of a string.\n@@ -1022,7 +1023,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at(&self, i: usize) -> char {\n-        core_str::StrExt::char_at(&self[], i)\n+        core_str::StrExt::char_at(&self[..], i)\n     }\n \n     /// Plucks the character ending at the `i`th byte of a string.\n@@ -1034,7 +1035,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at_reverse(&self, i: usize) -> char {\n-        core_str::StrExt::char_at_reverse(&self[], i)\n+        core_str::StrExt::char_at_reverse(&self[..], i)\n     }\n \n     /// Work with the byte buffer of a string as a byte slice.\n@@ -1046,7 +1047,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(&self[])\n+        core_str::StrExt::as_bytes(&self[..])\n     }\n \n     /// Returns the byte index of the first character of `self` that\n@@ -1074,7 +1075,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P: CharEq>(&self, pat: P) -> Option<usize> {\n-        core_str::StrExt::find(&self[], pat)\n+        core_str::StrExt::find(&self[..], pat)\n     }\n \n     /// Returns the byte index of the last character of `self` that\n@@ -1102,7 +1103,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<usize> {\n-        core_str::StrExt::rfind(&self[], pat)\n+        core_str::StrExt::rfind(&self[..], pat)\n     }\n \n     /// Returns the byte index of the first matching substring\n@@ -1127,7 +1128,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in favor of a more generic find in the future\")]\n     fn find_str(&self, needle: &str) -> Option<usize> {\n-        core_str::StrExt::find_str(&self[], needle)\n+        core_str::StrExt::find_str(&self[..], needle)\n     }\n \n     /// Retrieves the first character from a string slice and returns\n@@ -1151,7 +1152,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"awaiting conventions about shifting and slices\")]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        core_str::StrExt::slice_shift_char(&self[])\n+        core_str::StrExt::slice_shift_char(&self[..])\n     }\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n@@ -1171,7 +1172,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"awaiting convention about comparability of arbitrary slices\")]\n     fn subslice_offset(&self, inner: &str) -> usize {\n-        core_str::StrExt::subslice_offset(&self[], inner)\n+        core_str::StrExt::subslice_offset(&self[..], inner)\n     }\n \n     /// Return an unsafe pointer to the strings buffer.\n@@ -1182,14 +1183,14 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(&self[])\n+        core_str::StrExt::as_ptr(&self[..])\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn utf16_units(&self) -> Utf16Units {\n-        Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n+        Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n     }\n \n     /// Return the number of bytes in this string\n@@ -1203,7 +1204,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn len(&self) -> usize {\n-        core_str::StrExt::len(&self[])\n+        core_str::StrExt::len(&self[..])\n     }\n \n     /// Returns true if this slice contains no bytes\n@@ -1216,7 +1217,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(&self[])\n+        core_str::StrExt::is_empty(&self[..])\n     }\n \n     /// Parse this string into the specified type.\n@@ -1230,7 +1231,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n-        core_str::StrExt::parse(&self[])\n+        core_str::StrExt::parse(&self[..])\n     }\n \n     /// Returns an iterator over the\n@@ -1255,7 +1256,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        UnicodeStr::graphemes(&self[], is_extended)\n+        UnicodeStr::graphemes(&self[..], is_extended)\n     }\n \n     /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n@@ -1271,7 +1272,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        UnicodeStr::grapheme_indices(&self[], is_extended)\n+        UnicodeStr::grapheme_indices(&self[..], is_extended)\n     }\n \n     /// An iterator over the words of a string (subsequences separated\n@@ -1288,7 +1289,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"str_words\",\n                reason = \"the precise algorithm to use is unclear\")]\n     fn words(&self) -> Words {\n-        UnicodeStr::words(&self[])\n+        UnicodeStr::words(&self[..])\n     }\n \n     /// Returns a string's displayed width in columns, treating control\n@@ -1303,25 +1304,25 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn width(&self, is_cjk: bool) -> usize {\n-        UnicodeStr::width(&self[], is_cjk)\n+        UnicodeStr::width(&self[..], is_cjk)\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim(&self) -> &str {\n-        UnicodeStr::trim(&self[])\n+        UnicodeStr::trim(&self[..])\n     }\n \n     /// Returns a string with leading whitespace removed.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(&self[])\n+        UnicodeStr::trim_left(&self[..])\n     }\n \n     /// Returns a string with trailing whitespace removed.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(&self[])\n+        UnicodeStr::trim_right(&self[..])\n     }\n }\n \n@@ -2704,7 +2705,7 @@ mod tests {\n             &[\"\\u{378}\\u{308}\\u{903}\"], &[\"\\u{378}\\u{308}\", \"\\u{903}\"]),\n         ];\n \n-        for &(s, g) in &test_same[] {\n+        for &(s, g) in &test_same[..] {\n             // test forward iterator\n             assert!(order::equals(s.graphemes(true), g.iter().cloned()));\n             assert!(order::equals(s.graphemes(false), g.iter().cloned()));"}, {"sha": "3b179d0b94c97cccddcdef0ddd6c7c070270cfc1", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -16,19 +16,19 @@\n \n use core::prelude::*;\n \n-use core::borrow::{Cow, IntoCow};\n use core::default::Default;\n use core::error::Error;\n use core::fmt;\n use core::hash;\n-use core::iter::FromIterator;\n+use core::iter::{IntoIterator, FromIterator};\n use core::mem;\n use core::ops::{self, Deref, Add, Index};\n use core::ptr;\n use core::raw::Slice as RawSlice;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n+use borrow::{Cow, IntoCow};\n use str::{self, CharRange, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n@@ -142,7 +142,7 @@ impl String {\n     /// assert_eq!(output.as_slice(), \"Hello \\u{FFFD}World\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n+    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n         let mut i = 0;\n         match str::from_utf8(v) {\n             Ok(s) => return Cow::Borrowed(s),\n@@ -709,26 +709,27 @@ impl Error for FromUtf16Error {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n-    fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String {\n+    fn from_iter<I: IntoIterator<Item=char>>(iter: I) -> String {\n         let mut buf = String::new();\n-        buf.extend(iterator);\n+        buf.extend(iter);\n         buf\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n-    fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String {\n+    fn from_iter<I: IntoIterator<Item=&'a str>>(iter: I) -> String {\n         let mut buf = String::new();\n-        buf.extend(iterator);\n+        buf.extend(iter);\n         buf\n     }\n }\n \n #[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl Extend<char> for String {\n-    fn extend<I:Iterator<Item=char>>(&mut self, iterator: I) {\n+    fn extend<I: IntoIterator<Item=char>>(&mut self, iterable: I) {\n+        let iterator = iterable.into_iter();\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n         for ch in iterator {\n@@ -740,7 +741,8 @@ impl Extend<char> for String {\n #[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl<'a> Extend<&'a str> for String {\n-    fn extend<I: Iterator<Item=&'a str>>(&mut self, iterator: I) {\n+    fn extend<I: IntoIterator<Item=&'a str>>(&mut self, iterable: I) {\n+        let iterator = iterable.into_iter();\n         // A guess that at least one byte per iterator element will be needed.\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n@@ -780,22 +782,22 @@ macro_rules! impl_eq {\n }\n \n impl_eq! { String, &'a str }\n-impl_eq! { CowString<'a>, String }\n+impl_eq! { Cow<'a, str>, String }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n+impl<'a, 'b> PartialEq<&'b str> for Cow<'a, str> {\n     #[inline]\n     fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n+impl<'a, 'b> PartialEq<Cow<'a, str>> for &'b str {\n     #[inline]\n-    fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n+    fn eq(&self, other: &Cow<'a, str>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n-    fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n+    fn ne(&self, other: &Cow<'a, str>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n #[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n@@ -833,12 +835,21 @@ impl fmt::Debug for String {\n }\n \n #[unstable(feature = \"collections\", reason = \"waiting on Hash stabilization\")]\n+#[cfg(stage0)]\n impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         (**self).hash(hasher)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl hash::Hash for String {\n+    #[inline]\n+    fn hash<H: hash::Hasher>(&self, hasher: &mut H) {\n+        (**self).hash(hasher)\n+    }\n+}\n \n #[unstable(feature = \"collections\",\n            reason = \"recent addition, needs more experience\")]\n@@ -857,23 +868,23 @@ impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &str {\n-        &self[][*index]\n+        &self[..][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeTo<usize>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n-        &self[][*index]\n+        &self[..][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFrom<usize>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n-        &self[][*index]\n+        &self[..][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -891,7 +902,7 @@ impl ops::Deref for String {\n \n     #[inline]\n     fn deref(&self) -> &str {\n-        unsafe { mem::transmute(&self.vec[]) }\n+        unsafe { mem::transmute(&self.vec[..]) }\n     }\n }\n \n@@ -958,31 +969,34 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n     }\n }\n \n-impl IntoCow<'static, String, str> for String {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl IntoCow<'static, str> for String {\n     #[inline]\n-    fn into_cow(self) -> CowString<'static> {\n+    fn into_cow(self) -> Cow<'static, str> {\n         Cow::Owned(self)\n     }\n }\n \n-impl<'a> IntoCow<'a, String, str> for &'a str {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> IntoCow<'a, str> for &'a str {\n     #[inline]\n-    fn into_cow(self) -> CowString<'a> {\n+    fn into_cow(self) -> Cow<'a, str> {\n         Cow::Borrowed(self)\n     }\n }\n \n-/// A clone-on-write string\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub type CowString<'a> = Cow<'a, String, str>;\n-\n-impl<'a> Str for CowString<'a> {\n+impl<'a> Str for Cow<'a, str> {\n     #[inline]\n     fn as_slice<'b>(&'b self) -> &'b str {\n         &**self\n     }\n }\n \n+/// A clone-on-write string\n+#[deprecated(since = \"1.0.0\", reason = \"use Cow<'a, str> instead\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type CowString<'a> = Cow<'a, str>;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]\n@@ -1287,7 +1301,7 @@ mod tests {\n     #[test]\n     fn test_slicing() {\n         let s = \"foobar\".to_string();\n-        assert_eq!(\"foobar\", &s[]);\n+        assert_eq!(\"foobar\", &s[..]);\n         assert_eq!(\"foo\", &s[..3]);\n         assert_eq!(\"bar\", &s[3..]);\n         assert_eq!(\"oob\", &s[1..4]);"}, {"sha": "1cc2a5235abec1a1af6a5cfe6a7361a758d7910c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 61, "deletions": 45, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -50,24 +50,26 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n-use core::borrow::{Cow, IntoCow};\n use core::cmp::max;\n use core::cmp::{Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n+use core::intrinsics::assume;\n use core::iter::{repeat, FromIterator, IntoIterator};\n-use core::marker::{self, ContravariantLifetime, InvariantType};\n+use core::marker::PhantomData;\n use core::mem;\n-use core::nonzero::NonZero;\n use core::num::{Int, UnsignedInt};\n use core::ops::{Index, IndexMut, Deref, Add};\n use core::ops;\n use core::ptr;\n+use core::ptr::Unique;\n use core::raw::Slice as RawSlice;\n use core::slice;\n use core::usize;\n \n+use borrow::{Cow, IntoCow};\n+\n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n /// # Examples\n@@ -137,10 +139,9 @@ use core::usize;\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n-    ptr: NonZero<*mut T>,\n+    ptr: Unique<T>,\n     len: usize,\n     cap: usize,\n-    _own: marker::PhantomData<T>,\n }\n \n unsafe impl<T: Send> Send for Vec<T> { }\n@@ -249,10 +250,9 @@ impl<T> Vec<T> {\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: usize,\n                                  capacity: usize) -> Vec<T> {\n         Vec {\n-            ptr: NonZero::new(ptr),\n+            ptr: Unique::new(ptr),\n             len: length,\n             cap: capacity,\n-            _own: marker::PhantomData,\n         }\n     }\n \n@@ -373,7 +373,7 @@ impl<T> Vec<T> {\n                                      self.len * mem::size_of::<T>(),\n                                      mem::min_align_of::<T>()) as *mut T;\n                 if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n+                self.ptr = Unique::new(ptr);\n             }\n             self.cap = self.len;\n         }\n@@ -655,7 +655,7 @@ impl<T> Vec<T> {\n             unsafe {\n                 let ptr = alloc_or_realloc(*self.ptr, old_size, size);\n                 if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n+                self.ptr = Unique::new(ptr);\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }\n@@ -756,7 +756,7 @@ impl<T> Vec<T> {\n             Drain {\n                 ptr: begin,\n                 end: end,\n-                marker: ContravariantLifetime,\n+                marker: PhantomData,\n             }\n         }\n     }\n@@ -871,6 +871,8 @@ impl<T> Vec<T> {\n                 end_t: unsafe { start.offset(offset) },\n                 start_u: start as *mut U,\n                 end_u: start as *mut U,\n+\n+                _marker: PhantomData,\n             };\n             //  start_t\n             //  start_u\n@@ -967,8 +969,7 @@ impl<T> Vec<T> {\n             let mut pv = PartialVecZeroSized::<T,U> {\n                 num_t: vec.len(),\n                 num_u: 0,\n-                marker_t: InvariantType,\n-                marker_u: InvariantType,\n+                marker: PhantomData,\n             };\n             unsafe { mem::forget(vec); }\n \n@@ -1226,7 +1227,7 @@ impl<T> Vec<T> {\n             unsafe {\n                 let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n                 if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = NonZero::new(ptr);\n+                self.ptr = Unique::new(ptr);\n             }\n             self.cap = capacity;\n         }\n@@ -1302,12 +1303,21 @@ impl<T:Clone> Clone for Vec<T> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         Hash::hash(&**self, state)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<T: Hash> Hash for Vec<T> {\n+    #[inline]\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        Hash::hash(&**self, state)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Index<usize> for Vec<T> {\n@@ -1407,7 +1417,8 @@ impl<T> ops::DerefMut for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n-    fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iterable: I) -> Vec<T> {\n+        let mut iterator = iterable.into_iter();\n         let (lower, _) = iterator.size_hint();\n         let mut vector = Vec::with_capacity(lower);\n \n@@ -1480,7 +1491,8 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n #[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n-    fn extend<I: Iterator<Item=T>>(&mut self, iterator: I) {\n+    fn extend<I: IntoIterator<Item=T>>(&mut self, iterable: I) {\n+        let iterator = iterable.into_iter();\n         let (lower, _) = iterator.size_hint();\n         self.reserve(lower);\n         for element in iterator {\n@@ -1517,54 +1529,53 @@ macro_rules! impl_eq {\n impl_eq! { Vec<A>, &'b [B] }\n impl_eq! { Vec<A>, &'b mut [B] }\n \n-impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+impl<'a, A, B> PartialEq<Vec<B>> for Cow<'a, [A]> where A: PartialEq<B> + Clone {\n     #[inline]\n     fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n+impl<'a, A, B> PartialEq<Cow<'a, [A]>> for Vec<B> where A: Clone, B: PartialEq<A> {\n     #[inline]\n-    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+    fn eq(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n-    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+    fn ne(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n macro_rules! impl_eq_for_cowvec {\n     ($rhs:ty) => {\n-        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+        impl<'a, 'b, A, B> PartialEq<$rhs> for Cow<'a, [A]> where A: PartialEq<B> + Clone {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n             fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n \n-        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n+        impl<'a, 'b, A, B> PartialEq<Cow<'a, [A]>> for $rhs where A: Clone, B: PartialEq<A> {\n             #[inline]\n-            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+            fn eq(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::eq(&**self, &**other) }\n             #[inline]\n-            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+            fn ne(&self, other: &Cow<'a, [A]>) -> bool { PartialEq::ne(&**self, &**other) }\n         }\n     }\n }\n \n impl_eq_for_cowvec! { &'b [B] }\n impl_eq_for_cowvec! { &'b mut [B] }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"waiting on PartialOrd stability\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Eq stability\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Eq> Eq for Vec<T> {}\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Ord stability\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n@@ -1587,8 +1598,12 @@ impl<T> AsSlice<T> for Vec<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice(&self) -> &[T] {\n         unsafe {\n+            let p = *self.ptr;\n+            if cfg!(not(stage0)) { // NOTE remove cfg after next snapshot\n+                assume(p != 0 as *mut T);\n+            }\n             mem::transmute(RawSlice {\n-                data: *self.ptr,\n+                data: p,\n                 len: self.len\n             })\n         }\n@@ -1643,26 +1658,26 @@ impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"collections\",\n-           reason = \"unclear how valuable this alias is\")]\n /// A clone-on-write vector\n-pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n+#[deprecated(since = \"1.0.0\", reason = \"use Cow<'a, [T]> instead\")]\n+#[unstable(feature = \"collections\")]\n+pub type CowVec<'a, T> = Cow<'a, [T]>;\n \n #[unstable(feature = \"collections\")]\n-impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n-    fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> {\n+impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n+    fn from_iter<I: IntoIterator<Item=T>>(it: I) -> Cow<'a, [T]> {\n         Cow::Owned(FromIterator::from_iter(it))\n     }\n }\n \n-impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n+impl<'a, T: 'a> IntoCow<'a, [T]> for Vec<T> where T: Clone {\n+    fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Owned(self)\n     }\n }\n \n-impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n-    fn into_cow(self) -> CowVec<'a, T> {\n+impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n+    fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Borrowed(self)\n     }\n }\n@@ -1779,10 +1794,10 @@ impl<T> Drop for IntoIter<T> {\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"collections\",\n            reason = \"recently added as part of collections reform 2\")]\n-pub struct Drain<'a, T> {\n+pub struct Drain<'a, T:'a> {\n     ptr: *const T,\n     end: *const T,\n-    marker: ContravariantLifetime<'a>,\n+    marker: PhantomData<&'a T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1867,9 +1882,9 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n #[unstable(feature = \"collections\")]\n-pub struct DerefVec<'a, T> {\n+pub struct DerefVec<'a, T:'a> {\n     x: Vec<T>,\n-    l: ContravariantLifetime<'a>\n+    l: PhantomData<&'a T>,\n }\n \n #[unstable(feature = \"collections\")]\n@@ -1897,7 +1912,7 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {\n             x: Vec::from_raw_parts(x.as_ptr() as *mut T, x.len(), x.len()),\n-            l: ContravariantLifetime::<'a>\n+            l: PhantomData,\n         }\n     }\n }\n@@ -1921,6 +1936,8 @@ struct PartialVecNonZeroSized<T,U> {\n     end_u: *mut U,\n     start_t: *mut T,\n     end_t: *mut T,\n+\n+    _marker: PhantomData<U>,\n }\n \n /// An owned, partially type-converted vector of zero-sized elements.\n@@ -1930,8 +1947,7 @@ struct PartialVecNonZeroSized<T,U> {\n struct PartialVecZeroSized<T,U> {\n     num_t: usize,\n     num_u: usize,\n-    marker_t: InvariantType<T>,\n-    marker_u: InvariantType<U>,\n+    marker: PhantomData<::core::cell::Cell<(T,U)>>,\n }\n \n #[unsafe_destructor]\n@@ -2589,7 +2605,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst = src.clone()[].to_vec();\n+            let dst = src.clone()[..].to_vec();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });"}, {"sha": "3ba22a41ff74097d73626b926a0bcda8b971486e", "filename": "src/libcollections/vec_deque.rs", "status": "renamed", "additions": 233, "deletions": 213, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! RingBuf is a double-ended queue, which is implemented with the help of a\n-//! growing circular buffer.\n+//! VecDeque is a double-ended queue, which is implemented with the help of a\n+//! growing ring buffer.\n //!\n //! This queue has `O(1)` amortized inserts and removals from both ends of the\n //! container. It also has `O(1)` indexing like a vector. The contained elements\n@@ -28,20 +28,26 @@ use core::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n use core::ops::{Index, IndexMut};\n-use core::ptr;\n+use core::ptr::{self, Unique};\n use core::raw::Slice as RawSlice;\n \n-use core::hash::{Writer, Hash, Hasher};\n+use core::hash::{Hash, Hasher};\n+#[cfg(stage0)] use core::hash::Writer;\n use core::cmp;\n \n use alloc::heap;\n \n+#[deprecated(since = \"1.0.0\", reason = \"renamed to VecDeque\")]\n+#[unstable(feature = \"collections\")]\n+pub use VecDeque as RingBuf;\n+\n static INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n static MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n-/// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n+/// `VecDeque` is a growable ring buffer, which can be used as a\n+/// double-ended queue efficiently.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RingBuf<T> {\n+pub struct VecDeque<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n     // to where data should be written.\n@@ -51,30 +57,30 @@ pub struct RingBuf<T> {\n     tail: usize,\n     head: usize,\n     cap: usize,\n-    ptr: *mut T\n+    ptr: Unique<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for RingBuf<T> {}\n+unsafe impl<T: Send> Send for VecDeque<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for RingBuf<T> {}\n+unsafe impl<T: Sync> Sync for VecDeque<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for RingBuf<T> {\n-    fn clone(&self) -> RingBuf<T> {\n+impl<T: Clone> Clone for VecDeque<T> {\n+    fn clone(&self) -> VecDeque<T> {\n         self.iter().cloned().collect()\n     }\n }\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for RingBuf<T> {\n+impl<T> Drop for VecDeque<T> {\n     fn drop(&mut self) {\n         self.clear();\n         unsafe {\n             if mem::size_of::<T>() != 0 {\n-                heap::deallocate(self.ptr as *mut u8,\n+                heap::deallocate(*self.ptr as *mut u8,\n                                  self.cap * mem::size_of::<T>(),\n                                  mem::min_align_of::<T>())\n             }\n@@ -83,22 +89,22 @@ impl<T> Drop for RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Default for RingBuf<T> {\n+impl<T> Default for VecDeque<T> {\n     #[inline]\n-    fn default() -> RingBuf<T> { RingBuf::new() }\n+    fn default() -> VecDeque<T> { VecDeque::new() }\n }\n \n-impl<T> RingBuf<T> {\n+impl<T> VecDeque<T> {\n     /// Turn ptr into a slice\n     #[inline]\n     unsafe fn buffer_as_slice(&self) -> &[T] {\n-        mem::transmute(RawSlice { data: self.ptr, len: self.cap })\n+        mem::transmute(RawSlice { data: *self.ptr as *const T, len: self.cap })\n     }\n \n     /// Turn ptr into a mut slice\n     #[inline]\n     unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n-        mem::transmute(RawSlice { data: self.ptr, len: self.cap })\n+        mem::transmute(RawSlice { data: *self.ptr as *const T, len: self.cap })\n     }\n \n     /// Moves an element out of the buffer\n@@ -149,48 +155,48 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-impl<T> RingBuf<T> {\n-    /// Creates an empty `RingBuf`.\n+impl<T> VecDeque<T> {\n+    /// Creates an empty `VecDeque`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> RingBuf<T> {\n-        RingBuf::with_capacity(INITIAL_CAPACITY)\n+    pub fn new() -> VecDeque<T> {\n+        VecDeque::with_capacity(INITIAL_CAPACITY)\n     }\n \n-    /// Creates an empty `RingBuf` with space for at least `n` elements.\n+    /// Creates an empty `VecDeque` with space for at least `n` elements.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(n: usize) -> RingBuf<T> {\n+    pub fn with_capacity(n: usize) -> VecDeque<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n         assert!(cap > n, \"capacity overflow\");\n         let size = cap.checked_mul(mem::size_of::<T>())\n                       .expect(\"capacity overflow\");\n \n-        let ptr = if mem::size_of::<T>() != 0 {\n-            unsafe {\n+        let ptr = unsafe {\n+            if mem::size_of::<T>() != 0 {\n                 let ptr = heap::allocate(size, mem::min_align_of::<T>())  as *mut T;;\n                 if ptr.is_null() { ::alloc::oom() }\n-                ptr\n+                Unique::new(ptr)\n+            } else {\n+                Unique::new(heap::EMPTY as *mut T)\n             }\n-        } else {\n-            heap::EMPTY as *mut T\n         };\n \n-        RingBuf {\n+        VecDeque {\n             tail: 0,\n             head: 0,\n             cap: cap,\n-            ptr: ptr\n+            ptr: ptr,\n         }\n     }\n \n-    /// Retrieves an element in the `RingBuf` by index.\n+    /// Retrieves an element in the `VecDeque` by index.\n     ///\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n@@ -206,14 +212,14 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Retrieves an element in the `RingBuf` mutably by index.\n+    /// Retrieves an element in the `VecDeque` mutably by index.\n     ///\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n@@ -245,9 +251,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n@@ -266,23 +272,23 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Returns the number of elements the `RingBuf` can hold without\n+    /// Returns the number of elements the `VecDeque` can hold without\n     /// reallocating.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let buf: RingBuf<i32> = RingBuf::with_capacity(10);\n+    /// let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n     /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `RingBuf`. Does nothing if the capacity is already sufficient.\n+    /// given `VecDeque`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n     /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n@@ -295,9 +301,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<i32> = vec![1].into_iter().collect();\n+    /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -316,9 +322,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<i32> = vec![1].into_iter().collect();\n+    /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -335,11 +341,12 @@ impl<T> RingBuf<T> {\n                 let new = count.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n                 unsafe {\n-                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n-                                                old,\n-                                                new,\n-                                                mem::min_align_of::<T>()) as *mut T;\n-                    if self.ptr.is_null() { ::alloc::oom() }\n+                    let ptr = heap::reallocate(*self.ptr as *mut u8,\n+                                               old,\n+                                               new,\n+                                               mem::min_align_of::<T>()) as *mut T;\n+                    if ptr.is_null() { ::alloc::oom() }\n+                    self.ptr = Unique::new(ptr);\n                 }\n             }\n \n@@ -390,9 +397,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::with_capacity(15);\n+    /// let mut buf = VecDeque::with_capacity(15);\n     /// buf.extend(0..4);\n     /// assert_eq!(buf.capacity(), 15);\n     /// buf.shrink_to_fit();\n@@ -453,11 +460,12 @@ impl<T> RingBuf<T> {\n                 let old = self.cap * mem::size_of::<T>();\n                 let new_size = target_cap * mem::size_of::<T>();\n                 unsafe {\n-                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n-                                                old,\n-                                                new_size,\n-                                                mem::min_align_of::<T>()) as *mut T;\n-                    if self.ptr.is_null() { ::alloc::oom() }\n+                    let ptr = heap::reallocate(*self.ptr as *mut u8,\n+                                               old,\n+                                               new_size,\n+                                               mem::min_align_of::<T>()) as *mut T;\n+                    if ptr.is_null() { ::alloc::oom() }\n+                    self.ptr = Unique::new(ptr);\n                 }\n             }\n             self.cap = target_cap;\n@@ -475,9 +483,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n@@ -498,9 +506,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n@@ -521,9 +529,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n@@ -539,8 +547,8 @@ impl<T> RingBuf<T> {\n             tail: self.tail,\n             head: self.head,\n             cap: self.cap,\n-            ptr: self.ptr,\n-            marker: marker::ContravariantLifetime,\n+            ptr: *self.ptr,\n+            marker: marker::PhantomData,\n         }\n     }\n \n@@ -553,7 +561,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n-    /// `RingBuf`.\n+    /// `VecDeque`.\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -573,7 +581,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n-    /// `RingBuf`.\n+    /// `VecDeque`.\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -596,14 +604,14 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Returns the number of elements in the `RingBuf`.\n+    /// Returns the number of elements in the `VecDeque`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// assert_eq!(v.len(), 0);\n     /// v.push_back(1);\n     /// assert_eq!(v.len(), 1);\n@@ -616,25 +624,25 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// assert!(v.is_empty());\n     /// v.push_front(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Creates a draining iterator that clears the `RingBuf` and iterates over\n+    /// Creates a draining iterator that clears the `VecDeque` and iterates over\n     /// the removed items from start to end.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// v.push_back(1);\n     /// assert_eq!(v.drain().next(), Some(1));\n     /// assert!(v.is_empty());\n@@ -653,9 +661,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// v.push_back(1);\n     /// v.clear();\n     /// assert!(v.is_empty());\n@@ -672,9 +680,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.front(), None);\n     ///\n     /// d.push_back(1);\n@@ -692,9 +700,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.front_mut(), None);\n     ///\n     /// d.push_back(1);\n@@ -716,9 +724,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.back(), None);\n     ///\n     /// d.push_back(1);\n@@ -736,9 +744,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.back(), None);\n     ///\n     /// d.push_back(1);\n@@ -761,9 +769,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// d.push_back(1);\n     /// d.push_back(2);\n     ///\n@@ -787,9 +795,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// d.push_front(1);\n     /// d.push_front(2);\n     /// assert_eq!(d.front(), Some(&2));\n@@ -811,9 +819,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(1);\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n@@ -836,9 +844,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// assert_eq!(buf.pop_back(), None);\n     /// buf.push_back(1);\n     /// buf.push_back(3);\n@@ -870,9 +878,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// assert_eq!(buf.swap_back_remove(0), None);\n     /// buf.push_back(5);\n     /// buf.push_back(99);\n@@ -903,9 +911,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// assert_eq!(buf.swap_front_remove(0), None);\n     /// buf.push_back(15);\n     /// buf.push_back(5);\n@@ -936,9 +944,9 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Examples\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(10);\n     /// buf.push_back(12);\n     /// buf.insert(1,11);\n@@ -1138,9 +1146,9 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Examples\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(12);\n@@ -1309,9 +1317,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<_> = vec![1,2,3].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = vec![1,2,3].into_iter().collect();\n     /// let buf2 = buf.split_off(1);\n     /// // buf = [1], buf2 = [2, 3]\n     /// assert_eq!(buf.len(), 1);\n@@ -1325,7 +1333,7 @@ impl<T> RingBuf<T> {\n         assert!(at <= len, \"`at` out of bounds\");\n \n         let other_len = len - at;\n-        let mut other = RingBuf::with_capacity(other_len);\n+        let mut other = VecDeque::with_capacity(other_len);\n \n         unsafe {\n             let (first_half, second_half) = self.as_slices();\n@@ -1336,7 +1344,7 @@ impl<T> RingBuf<T> {\n                 // `at` lies in the first half.\n                 let amount_in_first = first_len - at;\n \n-                ptr::copy_nonoverlapping_memory(other.ptr,\n+                ptr::copy_nonoverlapping_memory(*other.ptr,\n                                                 first_half.as_ptr().offset(at as isize),\n                                                 amount_in_first);\n \n@@ -1349,7 +1357,7 @@ impl<T> RingBuf<T> {\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n-                ptr::copy_nonoverlapping_memory(other.ptr,\n+                ptr::copy_nonoverlapping_memory(*other.ptr,\n                                                 second_half.as_ptr().offset(offset as isize),\n                                                 amount_in_second);\n             }\n@@ -1371,10 +1379,10 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let mut buf2: RingBuf<_> = vec![4, 5, 6].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let mut buf2: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n     /// buf.append(&mut buf2);\n     /// assert_eq!(buf.len(), 6);\n     /// assert_eq!(buf2.len(), 0);\n@@ -1388,16 +1396,16 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-impl<T: Clone> RingBuf<T> {\n+impl<T: Clone> VecDeque<T> {\n     /// Modifies the ringbuf in-place so that `len()` is equal to new_len,\n     /// either by removing excess elements or by appending copies of a value to the back.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n@@ -1434,7 +1442,7 @@ fn count(tail: usize, head: usize, size: usize) -> usize {\n     (head - tail) & (size - 1)\n }\n \n-/// `RingBuf` iterator.\n+/// `VecDeque` iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n@@ -1511,14 +1519,14 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n // FIXME This was implemented differently from Iter because of a problem\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n-/// `RingBuf` mutable iterator.\n+/// `VecDeque` mutable iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n     tail: usize,\n     head: usize,\n     cap: usize,\n-    marker: marker::ContravariantLifetime<'a>,\n+    marker: marker::PhantomData<&'a mut T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1563,10 +1571,10 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n-/// A by-value RingBuf iterator\n+/// A by-value VecDeque iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    inner: RingBuf<T>,\n+    inner: VecDeque<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1596,11 +1604,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n-/// A draining RingBuf iterator\n+/// A draining VecDeque iterator\n #[unstable(feature = \"collections\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, T: 'a> {\n-    inner: &'a mut RingBuf<T>,\n+    inner: &'a mut VecDeque<T>,\n }\n \n #[unsafe_destructor]\n@@ -1641,43 +1649,54 @@ impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for RingBuf<A> {\n-    fn eq(&self, other: &RingBuf<A>) -> bool {\n+impl<A: PartialEq> PartialEq for VecDeque<A> {\n+    fn eq(&self, other: &VecDeque<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for RingBuf<A> {}\n+impl<A: Eq> Eq for VecDeque<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for RingBuf<A> {\n-    fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> {\n+impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n+    fn partial_cmp(&self, other: &VecDeque<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for RingBuf<A> {\n+impl<A: Ord> Ord for VecDeque<A> {\n     #[inline]\n-    fn cmp(&self, other: &RingBuf<A>) -> Ordering {\n+    fn cmp(&self, other: &VecDeque<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n+#[cfg(stage0)]\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for VecDeque<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self {\n             elt.hash(state);\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<A: Hash> Hash for VecDeque<A> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.len().hash(state);\n+        for elt in self {\n+            elt.hash(state);\n+        }\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Index<usize> for RingBuf<A> {\n+impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n     #[inline]\n@@ -1687,25 +1706,26 @@ impl<A> Index<usize> for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> IndexMut<usize> for RingBuf<A> {\n+impl<A> IndexMut<usize> for VecDeque<A> {\n     #[inline]\n     fn index_mut(&mut self, i: &usize) -> &mut A {\n         self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for RingBuf<A> {\n-    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> RingBuf<A> {\n+impl<A> FromIterator<A> for VecDeque<A> {\n+    fn from_iter<T: IntoIterator<Item=A>>(iterable: T) -> VecDeque<A> {\n+        let iterator = iterable.into_iter();\n         let (lower, _) = iterator.size_hint();\n-        let mut deq = RingBuf::with_capacity(lower);\n+        let mut deq = VecDeque::with_capacity(lower);\n         deq.extend(iterator);\n         deq\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for RingBuf<T> {\n+impl<T> IntoIterator for VecDeque<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -1715,7 +1735,7 @@ impl<T> IntoIterator for RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a RingBuf<T> {\n+impl<'a, T> IntoIterator for &'a VecDeque<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -1725,7 +1745,7 @@ impl<'a, T> IntoIterator for &'a RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n+impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n@@ -1735,18 +1755,18 @@ impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for RingBuf<A> {\n-    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n-        for elt in iterator {\n+impl<A> Extend<A> for VecDeque<A> {\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T) {\n+        for elt in iter {\n             self.push_back(elt);\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for RingBuf<T> {\n+impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"RingBuf [\"));\n+        try!(write!(f, \"VecDeque [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -1768,12 +1788,12 @@ mod tests {\n     use test::Bencher;\n     use test;\n \n-    use super::RingBuf;\n+    use super::VecDeque;\n \n     #[test]\n     #[allow(deprecated)]\n     fn test_simple() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert_eq!(d.len(), 0);\n         d.push_front(17);\n         d.push_front(42);\n@@ -1812,7 +1832,7 @@ mod tests {\n \n     #[cfg(test)]\n     fn test_parameterized<T:Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         assert_eq!(deq.len(), 0);\n         deq.push_front(a.clone());\n         deq.push_front(b.clone());\n@@ -1843,7 +1863,7 @@ mod tests {\n \n     #[test]\n     fn test_push_front_grow() {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 0..66 {\n             deq.push_front(i);\n         }\n@@ -1853,7 +1873,7 @@ mod tests {\n             assert_eq!(deq[i], 65 - i);\n         }\n \n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 0..66 {\n             deq.push_back(i);\n         }\n@@ -1865,7 +1885,7 @@ mod tests {\n \n     #[test]\n     fn test_index() {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 1..4 {\n             deq.push_front(i);\n         }\n@@ -1875,7 +1895,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_index_out_of_bounds() {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 1..4 {\n             deq.push_front(i);\n         }\n@@ -1885,14 +1905,14 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut test::Bencher) {\n         b.iter(|| {\n-            let ring: RingBuf<i32> = RingBuf::new();\n+            let ring: VecDeque<i32> = VecDeque::new();\n             test::black_box(ring);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_100(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::with_capacity(101);\n+        let mut deq = VecDeque::with_capacity(101);\n         b.iter(|| {\n             for i in 0..100 {\n                 deq.push_back(i);\n@@ -1904,7 +1924,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_100(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::with_capacity(101);\n+        let mut deq = VecDeque::with_capacity(101);\n         b.iter(|| {\n             for i in 0..100 {\n                 deq.push_front(i);\n@@ -1916,7 +1936,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq= RingBuf::<i32>::with_capacity(101);\n+        let mut deq= VecDeque::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1929,7 +1949,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::<i32>::with_capacity(101);\n+        let mut deq = VecDeque::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1943,7 +1963,7 @@ mod tests {\n     #[bench]\n     fn bench_grow_1025(b: &mut test::Bencher) {\n         b.iter(|| {\n-            let mut deq = RingBuf::new();\n+            let mut deq = VecDeque::new();\n             for i in 0..1025 {\n                 deq.push_front(i);\n             }\n@@ -1953,7 +1973,7 @@ mod tests {\n \n     #[bench]\n     fn bench_iter_1000(b: &mut test::Bencher) {\n-        let ring: RingBuf<_> = (0..1000).collect();\n+        let ring: VecDeque<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1966,7 +1986,7 @@ mod tests {\n \n     #[bench]\n     fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-        let mut ring: RingBuf<_> = (0..1000).collect();\n+        let mut ring: VecDeque<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1986,9 +2006,9 @@ mod tests {\n \n     #[derive(Clone, PartialEq, Debug)]\n     enum Taggypar<T> {\n-        Onepar(i32),\n-        Twopar(i32, i32),\n-        Threepar(i32, i32, i32),\n+        Onepar(T),\n+        Twopar(T, T),\n+        Threepar(T, T, T),\n     }\n \n     #[derive(Clone, PartialEq, Debug)]\n@@ -2027,17 +2047,17 @@ mod tests {\n \n     #[test]\n     fn test_with_capacity() {\n-        let mut d = RingBuf::with_capacity(0);\n+        let mut d = VecDeque::with_capacity(0);\n         d.push_back(1);\n         assert_eq!(d.len(), 1);\n-        let mut d = RingBuf::with_capacity(50);\n+        let mut d = VecDeque::with_capacity(50);\n         d.push_back(1);\n         assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n     fn test_with_capacity_non_power_two() {\n-        let mut d3 = RingBuf::with_capacity(3);\n+        let mut d3 = VecDeque::with_capacity(3);\n         d3.push_back(1);\n \n         // X = None, | = lo\n@@ -2062,7 +2082,7 @@ mod tests {\n \n         d3.push_back(15);\n         // There used to be a bug here about how the\n-        // RingBuf made growth assumptions about the\n+        // VecDeque made growth assumptions about the\n         // underlying Vec which didn't hold and lead\n         // to corruption.\n         // (Vec grows to next power of two)\n@@ -2078,31 +2098,31 @@ mod tests {\n \n     #[test]\n     fn test_reserve_exact() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         d.push_back(0);\n         d.reserve_exact(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_reserve() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         d.push_back(0);\n         d.reserve(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_swap() {\n-        let mut d: RingBuf<_> = (0..5).collect();\n+        let mut d: VecDeque<_> = (0..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n         assert_eq!(d.iter().cloned().collect::<Vec<_>>(), vec!(4, 2, 3, 1));\n     }\n \n     #[test]\n     fn test_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert_eq!(d.iter().next(), None);\n         assert_eq!(d.iter().size_hint(), (0, Some(0)));\n \n@@ -2134,7 +2154,7 @@ mod tests {\n \n     #[test]\n     fn test_rev_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert_eq!(d.iter().rev().next(), None);\n \n         for i in 0..5 {\n@@ -2154,7 +2174,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iter_wrap() {\n-        let mut d = RingBuf::with_capacity(3);\n+        let mut d = VecDeque::with_capacity(3);\n         assert!(d.iter_mut().rev().next().is_none());\n \n         d.push_back(1);\n@@ -2169,7 +2189,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert!(d.iter_mut().next().is_none());\n \n         for i in 0..3 {\n@@ -2192,7 +2212,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert!(d.iter_mut().rev().next().is_none());\n \n         for i in 0..3 {\n@@ -2218,7 +2238,7 @@ mod tests {\n \n         // Empty iter\n         {\n-            let d: RingBuf<i32> = RingBuf::new();\n+            let d: VecDeque<i32> = VecDeque::new();\n             let mut iter = d.into_iter();\n \n             assert_eq!(iter.size_hint(), (0, Some(0)));\n@@ -2228,7 +2248,7 @@ mod tests {\n \n         // simple iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2239,7 +2259,7 @@ mod tests {\n \n         // wrapped iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2253,7 +2273,7 @@ mod tests {\n \n         // partially used\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2277,7 +2297,7 @@ mod tests {\n \n         // Empty iter\n         {\n-            let mut d: RingBuf<i32> = RingBuf::new();\n+            let mut d: VecDeque<i32> = VecDeque::new();\n \n             {\n                 let mut iter = d.drain();\n@@ -2292,7 +2312,7 @@ mod tests {\n \n         // simple iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2303,7 +2323,7 @@ mod tests {\n \n         // wrapped iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2317,7 +2337,7 @@ mod tests {\n \n         // partially used\n         {\n-            let mut d: RingBuf<_> = RingBuf::new();\n+            let mut d: VecDeque<_> = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2343,12 +2363,12 @@ mod tests {\n     fn test_from_iter() {\n         use core::iter;\n         let v = vec!(1,2,3,4,5,6,7);\n-        let deq: RingBuf<_> = v.iter().cloned().collect();\n+        let deq: VecDeque<_> = v.iter().cloned().collect();\n         let u: Vec<_> = deq.iter().cloned().collect();\n         assert_eq!(u, v);\n \n         let seq = iter::count(0, 2).take(256);\n-        let deq: RingBuf<_> = seq.collect();\n+        let deq: VecDeque<_> = seq.collect();\n         for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);\n         }\n@@ -2357,7 +2377,7 @@ mod tests {\n \n     #[test]\n     fn test_clone() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n@@ -2374,13 +2394,13 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        let mut d = RingBuf::new();\n-        assert!(d == RingBuf::with_capacity(0));\n+        let mut d = VecDeque::new();\n+        assert!(d == VecDeque::with_capacity(0));\n         d.push_front(137);\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n-        let mut e = RingBuf::with_capacity(0);\n+        let mut e = VecDeque::with_capacity(0);\n         e.push_back(42);\n         e.push_back(17);\n         e.push_back(137);\n@@ -2390,13 +2410,13 @@ mod tests {\n         e.push_back(0);\n         assert!(e != d);\n         e.clear();\n-        assert!(e == RingBuf::new());\n+        assert!(e == VecDeque::new());\n     }\n \n     #[test]\n     fn test_hash() {\n-      let mut x = RingBuf::new();\n-      let mut y = RingBuf::new();\n+      let mut x = VecDeque::new();\n+      let mut y = VecDeque::new();\n \n       x.push_back(1);\n       x.push_back(2);\n@@ -2413,8 +2433,8 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let x = RingBuf::new();\n-        let mut y = RingBuf::new();\n+        let x = VecDeque::new();\n+        let mut y = VecDeque::new();\n         y.push_back(1);\n         y.push_back(2);\n         y.push_back(3);\n@@ -2426,13 +2446,13 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let ringbuf: RingBuf<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        let ringbuf: VecDeque<_> = (0..10).collect();\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"VecDeque [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let ringbuf: RingBuf<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n+        let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .cloned()\n                                                                         .collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"VecDeque [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[test]\n@@ -2445,7 +2465,7 @@ mod tests {\n             }\n         }\n \n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(Elem);\n         ring.push_front(Elem);\n         ring.push_back(Elem);\n@@ -2465,7 +2485,7 @@ mod tests {\n             }\n         }\n \n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(Elem);\n         ring.push_front(Elem);\n         ring.push_back(Elem);\n@@ -2489,7 +2509,7 @@ mod tests {\n             }\n         }\n \n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(Elem);\n         ring.push_front(Elem);\n         ring.push_back(Elem);\n@@ -2505,7 +2525,7 @@ mod tests {\n     fn test_reserve_grow() {\n         // test growth path A\n         // [T o o H] -> [T o o H . . . . ]\n-        let mut ring = RingBuf::with_capacity(4);\n+        let mut ring = VecDeque::with_capacity(4);\n         for i in 0..3 {\n             ring.push_back(i);\n         }\n@@ -2516,7 +2536,7 @@ mod tests {\n \n         // test growth path B\n         // [H T o o] -> [. T o o H . . . ]\n-        let mut ring = RingBuf::with_capacity(4);\n+        let mut ring = VecDeque::with_capacity(4);\n         for i in 0..1 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n@@ -2531,7 +2551,7 @@ mod tests {\n \n         // test growth path C\n         // [o o H T] -> [o o H . . . . T ]\n-        let mut ring = RingBuf::with_capacity(4);\n+        let mut ring = VecDeque::with_capacity(4);\n         for i in 0..3 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n@@ -2547,7 +2567,7 @@ mod tests {\n \n     #[test]\n     fn test_get() {\n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(0);\n         assert_eq!(ring.get(0), Some(&0));\n         assert_eq!(ring.get(1), None);\n@@ -2579,7 +2599,7 @@ mod tests {\n \n     #[test]\n     fn test_get_mut() {\n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         for i in 0..3 {\n             ring.push_back(i);\n         }\n@@ -2605,7 +2625,7 @@ mod tests {\n         fn test(back: bool) {\n             // This test checks that every single combination of tail position and length is tested.\n             // Capacity 15 should be large enough to cover every case.\n-            let mut tester = RingBuf::with_capacity(15);\n+            let mut tester = VecDeque::with_capacity(15);\n             let usable_cap = tester.capacity();\n             let final_len = usable_cap / 2;\n \n@@ -2649,7 +2669,7 @@ mod tests {\n         // This test checks that every single combination of tail position, length, and\n         // insertion position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2683,7 +2703,7 @@ mod tests {\n         // This test checks that every single combination of tail position, length, and\n         // removal position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2720,7 +2740,7 @@ mod tests {\n         // This test checks that every single combination of head and tail position,\n         // is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2749,7 +2769,7 @@ mod tests {\n \n     #[test]\n     fn test_front() {\n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(10);\n         ring.push_back(20);\n         assert_eq!(ring.front(), Some(&10));\n@@ -2761,7 +2781,7 @@ mod tests {\n \n     #[test]\n     fn test_as_slices() {\n-        let mut ring: RingBuf<i32> = RingBuf::with_capacity(127);\n+        let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n         let cap = ring.capacity() as i32;\n         let first = cap/2;\n         let last  = cap - first;\n@@ -2789,7 +2809,7 @@ mod tests {\n \n     #[test]\n     fn test_as_mut_slices() {\n-        let mut ring: RingBuf<i32> = RingBuf::with_capacity(127);\n+        let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n         let cap = ring.capacity() as i32;\n         let first = cap/2;\n         let last  = cap - first;\n@@ -2820,7 +2840,7 @@ mod tests {\n         // This test checks that every single combination of tail position, length, and\n         // split position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2855,8 +2875,8 @@ mod tests {\n \n     #[test]\n     fn test_append() {\n-        let mut a: RingBuf<_> = vec![1, 2, 3].into_iter().collect();\n-        let mut b: RingBuf<_> = vec![4, 5, 6].into_iter().collect();\n+        let mut a: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+        let mut b: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n \n         // normal append\n         a.append(&mut b);", "previous_filename": "src/libcollections/ring_buf.rs"}, {"sha": "54589a3142345833b443956f65a17227b35fe915", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -20,7 +20,8 @@ use core::prelude::*;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::hash::{Hash, Writer, Hasher};\n+use core::hash::{Hash, Hasher};\n+#[cfg(stage0)] use core::hash::Writer;\n use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n use core::iter;\n use core::mem::replace;\n@@ -99,6 +100,7 @@ impl<V> Default for VecMap<V> {\n     fn default() -> VecMap<V> { VecMap::new() }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V:Clone> Clone for VecMap<V> {\n     #[inline]\n     fn clone(&self) -> VecMap<V> {\n@@ -111,6 +113,7 @@ impl<V:Clone> Clone for VecMap<V> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n     fn hash(&self, state: &mut S) {\n         // In order to not traverse the `VecMap` twice, count the elements\n@@ -123,6 +126,20 @@ impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n         count.hash(state);\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<V: Hash> Hash for VecMap<V> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        // In order to not traverse the `VecMap` twice, count the elements\n+        // during iteration.\n+        let mut count: usize = 0;\n+        for elt in self {\n+            elt.hash(state);\n+            count += 1;\n+        }\n+        count.hash(state);\n+    }\n+}\n \n impl<V> VecMap<V> {\n     /// Creates an empty `VecMap`.\n@@ -661,7 +678,7 @@ impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> FromIterator<(usize, V)> for VecMap<V> {\n-    fn from_iter<Iter: Iterator<Item=(usize, V)>>(iter: Iter) -> VecMap<V> {\n+    fn from_iter<I: IntoIterator<Item=(usize, V)>>(iter: I) -> VecMap<V> {\n         let mut map = VecMap::new();\n         map.extend(iter);\n         map\n@@ -700,7 +717,7 @@ impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Extend<(usize, V)> for VecMap<V> {\n-    fn extend<Iter: Iterator<Item=(usize, V)>>(&mut self, iter: Iter) {\n+    fn extend<I: IntoIterator<Item=(usize, V)>>(&mut self, iter: I) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -859,7 +876,7 @@ pub struct IntoIter<V> {\n }\n \n #[unstable(feature = \"collections\")]\n-pub struct Drain<'a, V> {\n+pub struct Drain<'a, V:'a> {\n     iter: FilterMap<\n     Enumerate<vec::Drain<'a, Option<V>>>,\n     fn((usize, Option<V>)) -> Option<(usize, V)>>"}, {"sha": "afb5d95c9f8d79219b122a529749d35a35ceafab", "filename": "src/libcore/array.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -17,7 +17,7 @@\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n-use hash::{Hash, Hasher, self};\n+use hash::{Hash, self};\n use iter::IntoIterator;\n use marker::Copy;\n use ops::Deref;\n@@ -35,16 +35,24 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            impl<S: hash::Writer + Hasher, T: Hash<S>> Hash<S> for [T; $N] {\n+            #[cfg(stage0)]\n+            impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for [T; $N] {\n                 fn hash(&self, state: &mut S) {\n-                    Hash::hash(&self[], state)\n+                    Hash::hash(&self[..], state)\n+                }\n+            }\n+            #[cfg(not(stage0))]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<T: Hash> Hash for [T; $N] {\n+                fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+                    Hash::hash(&self[..], state)\n                 }\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: fmt::Debug> fmt::Debug for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    fmt::Debug::fmt(&&self[], f)\n+                    fmt::Debug::fmt(&&self[..], f)\n                 }\n             }\n \n@@ -72,11 +80,11 @@ macro_rules! array_impls {\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    &self[] == &other[]\n+                    &self[..] == &other[..]\n                 }\n                 #[inline]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    &self[] != &other[]\n+                    &self[..] != &other[..]\n                 }\n             }\n \n@@ -87,11 +95,11 @@ macro_rules! array_impls {\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &Rhs) -> bool {\n-                    PartialEq::eq(&self[], &**other)\n+                    PartialEq::eq(&self[..], &**other)\n                 }\n                 #[inline(always)]\n                 fn ne(&self, other: &Rhs) -> bool {\n-                    PartialEq::ne(&self[], &**other)\n+                    PartialEq::ne(&self[..], &**other)\n                 }\n             }\n \n@@ -102,11 +110,11 @@ macro_rules! array_impls {\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::eq(&**self, &other[])\n+                    PartialEq::eq(&**self, &other[..])\n                 }\n                 #[inline(always)]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::ne(&**self, &other[])\n+                    PartialEq::ne(&**self, &other[..])\n                 }\n             }\n \n@@ -117,31 +125,31 @@ macro_rules! array_impls {\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n-                    PartialOrd::partial_cmp(&&self[], &&other[])\n+                    PartialOrd::partial_cmp(&&self[..], &&other[..])\n                 }\n                 #[inline]\n                 fn lt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::lt(&&self[], &&other[])\n+                    PartialOrd::lt(&&self[..], &&other[..])\n                 }\n                 #[inline]\n                 fn le(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::le(&&self[], &&other[])\n+                    PartialOrd::le(&&self[..], &&other[..])\n                 }\n                 #[inline]\n                 fn ge(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::ge(&&self[], &&other[])\n+                    PartialOrd::ge(&&self[..], &&other[..])\n                 }\n                 #[inline]\n                 fn gt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::gt(&&self[], &&other[])\n+                    PartialOrd::gt(&&self[..], &&other[..])\n                 }\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {\n-                    Ord::cmp(&&self[], &&other[])\n+                    Ord::cmp(&&self[..], &&other[..])\n                 }\n             }\n         )+"}, {"sha": "6afe5b2257d279736daa4db1799d48a679f3e53b", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -76,6 +76,7 @@ use marker::Sync;\n \n use intrinsics;\n use cell::UnsafeCell;\n+use marker::PhantomData;\n \n /// A boolean type which can be safely shared between threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -105,6 +106,7 @@ unsafe impl Sync for AtomicUsize {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicPtr<T> {\n     p: UnsafeCell<usize>,\n+    _marker: PhantomData<*mut T>,\n }\n \n unsafe impl<T> Sync for AtomicPtr<T> {}\n@@ -791,7 +793,8 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: UnsafeCell::new(p as usize) }\n+        AtomicPtr { p: UnsafeCell::new(p as usize),\n+                    _marker: PhantomData }\n     }\n \n     /// Loads a value from the pointer."}, {"sha": "035443e9c3f35466a189e7b45bddb9a2092055cf", "filename": "src/libcore/borrow.rs", "status": "removed", "additions": 0, "deletions": 265, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/0b664bb8436f2cfda7f13a6f302ab486f332816f/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b664bb8436f2cfda7f13a6f302ab486f332816f/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=0b664bb8436f2cfda7f13a6f302ab486f332816f", "patch": "@@ -1,265 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A module for working with borrowed data.\n-//!\n-//! # The `BorrowFrom` traits\n-//!\n-//! In general, there may be several ways to \"borrow\" a piece of data.  The\n-//! typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n-//! (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n-//! borrows: the borrowed slices `&[T]` and `&mut [T]`.\n-//!\n-//! When writing generic code, it is often desirable to abstract over all ways\n-//! of borrowing data from a given type. That is the role of the `BorrowFrom`\n-//! trait: if `T: BorrowFrom<U>`, then `&T` can be borrowed from `&U`.  A given\n-//! type can be borrowed as multiple different types. In particular, `Vec<T>:\n-//! BorrowFrom<Vec<T>>` and `[T]: BorrowFrom<Vec<T>>`.\n-//!\n-//! # The `ToOwned` trait\n-//!\n-//! Some types make it possible to go from borrowed to owned, usually by\n-//! implementing the `Clone` trait. But `Clone` works only for going from `&T`\n-//! to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n-//! from any borrow of a given type.\n-//!\n-//! # The `Cow` (clone-on-write) type\n-//!\n-//! The type `Cow` is a smart pointer providing clone-on-write functionality: it\n-//! can enclose and provide immutable access to borrowed data, and clone the\n-//! data lazily when mutation or ownership is required. The type is designed to\n-//! work with general borrowed data via the `BorrowFrom` trait.\n-//!\n-//! `Cow` implements both `Deref`, which means that you can call\n-//! non-mutating methods directly on the data it encloses. If mutation\n-//! is desired, `to_mut` will obtain a mutable references to an owned\n-//! value, cloning if necessary.\n-\n-#![unstable(feature = \"core\",\n-            reason = \"recently added as part of collections reform\")]\n-\n-use clone::Clone;\n-use cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n-use fmt;\n-use marker::Sized;\n-use ops::Deref;\n-use option::Option;\n-use self::Cow::*;\n-\n-/// A trait for borrowing data.\n-#[old_orphan_check]\n-pub trait BorrowFrom<Owned: ?Sized> {\n-    /// Immutably borrow from an owned value.\n-    fn borrow_from(owned: &Owned) -> &Self;\n-}\n-\n-/// A trait for mutably borrowing data.\n-#[old_orphan_check]\n-pub trait BorrowFromMut<Owned: ?Sized> : BorrowFrom<Owned> {\n-    /// Mutably borrow from an owned value.\n-    fn borrow_from_mut(owned: &mut Owned) -> &mut Self;\n-}\n-\n-impl<T: ?Sized> BorrowFrom<T> for T {\n-    fn borrow_from(owned: &T) -> &T { owned }\n-}\n-\n-impl<T: ?Sized> BorrowFromMut<T> for T {\n-    fn borrow_from_mut(owned: &mut T) -> &mut T { owned }\n-}\n-\n-impl<'a, T: ?Sized> BorrowFrom<&'a T> for T {\n-    fn borrow_from<'b>(owned: &'b &'a T) -> &'b T { &**owned }\n-}\n-\n-impl<'a, T: ?Sized> BorrowFrom<&'a mut T> for T {\n-    fn borrow_from<'b>(owned: &'b &'a mut T) -> &'b T { &**owned }\n-}\n-\n-impl<'a, T: ?Sized> BorrowFromMut<&'a mut T> for T {\n-    fn borrow_from_mut<'b>(owned: &'b mut &'a mut T) -> &'b mut T { &mut **owned }\n-}\n-\n-impl<'a, T, B: ?Sized> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n-    fn borrow_from<'b>(owned: &'b Cow<'a, T, B>) -> &'b B {\n-        &**owned\n-    }\n-}\n-\n-/// Trait for moving into a `Cow`\n-#[old_orphan_check]\n-pub trait IntoCow<'a, T, B: ?Sized> {\n-    /// Moves `self` into `Cow`\n-    fn into_cow(self) -> Cow<'a, T, B>;\n-}\n-\n-impl<'a, T, B: ?Sized> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> {\n-    fn into_cow(self) -> Cow<'a, T, B> {\n-        self\n-    }\n-}\n-\n-/// A generalization of Clone to borrowed data.\n-#[old_orphan_check]\n-pub trait ToOwned<Owned>: BorrowFrom<Owned> {\n-    /// Create owned data from borrowed data, usually by copying.\n-    fn to_owned(&self) -> Owned;\n-}\n-\n-impl<T> ToOwned<T> for T where T: Clone {\n-    fn to_owned(&self) -> T { self.clone() }\n-}\n-\n-/// A clone-on-write smart pointer.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::borrow::Cow;\n-///\n-/// fn abs_all(input: &mut Cow<Vec<int>, [int]>) {\n-///     for i in 0..input.len() {\n-///         let v = input[i];\n-///         if v < 0 {\n-///             // clones into a vector the first time (if not already owned)\n-///             input.to_mut()[i] = -v;\n-///         }\n-///     }\n-/// }\n-/// ```\n-pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n-    /// Borrowed data.\n-    Borrowed(&'a B),\n-\n-    /// Owned data.\n-    Owned(T)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n-    fn clone(&self) -> Cow<'a, T, B> {\n-        match *self {\n-            Borrowed(b) => Borrowed(b),\n-            Owned(ref o) => {\n-                let b: &B = BorrowFrom::borrow_from(o);\n-                Owned(b.to_owned())\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> {\n-    /// Acquire a mutable reference to the owned form of the data.\n-    ///\n-    /// Copies the data if it is not already owned.\n-    pub fn to_mut(&mut self) -> &mut T {\n-        match *self {\n-            Borrowed(borrowed) => {\n-                *self = Owned(borrowed.to_owned());\n-                self.to_mut()\n-            }\n-            Owned(ref mut owned) => owned\n-        }\n-    }\n-\n-    /// Extract the owned data.\n-    ///\n-    /// Copies the data if it is not already owned.\n-    pub fn into_owned(self) -> T {\n-        match self {\n-            Borrowed(borrowed) => borrowed.to_owned(),\n-            Owned(owned) => owned\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps a borrowed value\n-    pub fn is_borrowed(&self) -> bool {\n-        match *self {\n-            Borrowed(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps an owned value\n-    pub fn is_owned(&self) -> bool {\n-        match *self {\n-            Owned(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n-    type Target = B;\n-\n-    fn deref(&self) -> &B {\n-        match *self {\n-            Borrowed(borrowed) => borrowed,\n-            Owned(ref owned) => BorrowFrom::borrow_from(owned)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n-        Ord::cmp(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n-    B: PartialEq<C> + ToOwned<T>,\n-    C: ToOwned<U>,\n-{\n-    #[inline]\n-    fn eq(&self, other: &Cow<'b, U, C>) -> bool {\n-        PartialEq::eq(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n-        PartialOrd::partial_cmp(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> fmt::Debug for Cow<'a, T, B> where\n-    B: fmt::Debug + ToOwned<T>,\n-    T: fmt::Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n-            Owned(ref o) => fmt::Debug::fmt(o, f),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, B: ?Sized> fmt::Display for Cow<'a, T, B> where\n-    B: fmt::Display + ToOwned<T>,\n-    T: fmt::Display,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Borrowed(ref b) => fmt::Display::fmt(b, f),\n-            Owned(ref o) => fmt::Display::fmt(o, f),\n-        }\n-    }\n-}"}, {"sha": "b37bad5f7546c21094828cf36e6c54e70593d210", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -215,7 +215,7 @@ impl Ord for Ordering {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n-        (*self as int).cmp(&(*other as int))\n+        (*self as i32).cmp(&(*other as i32))\n     }\n }\n \n@@ -224,7 +224,7 @@ impl PartialOrd for Ordering {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n-        (*self as int).partial_cmp(&(*other as int))\n+        (*self as i32).partial_cmp(&(*other as i32))\n     }\n }\n \n@@ -482,7 +482,7 @@ mod impls {\n     }\n \n     partial_eq_impl! {\n-        bool char uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64\n+        bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64\n     }\n \n     macro_rules! eq_impl {\n@@ -492,7 +492,7 @@ mod impls {\n         )*)\n     }\n \n-    eq_impl! { () bool char uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+    eq_impl! { () bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n@@ -535,7 +535,7 @@ mod impls {\n         }\n     }\n \n-    partial_ord_impl! { char uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n+    partial_ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n@@ -565,7 +565,7 @@ mod impls {\n         }\n     }\n \n-    ord_impl! { char uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+    ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n     // & pointers\n "}, {"sha": "7f46d9cbe5021d3da0308e397e8c3418ba8a82c5", "filename": "src/libcore/default.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -16,7 +16,7 @@\n //!\n //! ```\n //! struct SomeOptions {\n-//!     foo: int,\n+//!     foo: i32,\n //!     bar: f32,\n //! }\n //! ```\n@@ -28,7 +28,7 @@\n //!\n //! #[derive(Default)]\n //! struct SomeOptions {\n-//!     foo: int,\n+//!     foo: i32,\n //!     bar: f32,\n //! }\n //!\n@@ -56,7 +56,7 @@\n //!\n //! #[derive(Default)]\n //! struct SomeOptions {\n-//!     foo: int,\n+//!     foo: i32,\n //!     bar: f32,\n //!     baz: Kind,\n //! }\n@@ -73,7 +73,7 @@\n //! # use std::default::Default;\n //! # #[derive(Default)]\n //! # struct SomeOptions {\n-//! #     foo: int,\n+//! #     foo: i32,\n //! #     bar: f32,\n //! # }\n //! fn main() {\n@@ -93,7 +93,7 @@\n /// ```\n /// #[derive(Default)]\n /// struct SomeOptions {\n-///     foo: int,\n+///     foo: i32,\n ///     bar: f32,\n /// }\n /// ```\n@@ -113,7 +113,7 @@ pub trait Default {\n     ///\n     /// let i: i8 = Default::default();\n     /// let (x, y): (Option<String>, f64) = Default::default();\n-    /// let (a, b, (c, d)): (int, uint, (bool, bool)) = Default::default();\n+    /// let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();\n     /// ```\n     ///\n     /// Making your own:\n@@ -150,13 +150,13 @@ default_impl! { (), () }\n default_impl! { bool, false }\n default_impl! { char, '\\x00' }\n \n-default_impl! { uint, 0 }\n+default_impl! { usize, 0 }\n default_impl! { u8, 0 }\n default_impl! { u16, 0 }\n default_impl! { u32, 0 }\n default_impl! { u64, 0 }\n \n-default_impl! { int, 0 }\n+default_impl! { isize, 0 }\n default_impl! { i8, 0 }\n default_impl! { i16, 0 }\n default_impl! { i32, 0 }"}, {"sha": "a2c1bbc03317e9da08451e0b2b2d6194d385568b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -16,7 +16,7 @@ use any;\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n use char::CharExt;\n use iter::{Iterator, IteratorExt};\n-use marker::{Copy, Sized};\n+use marker::{Copy, PhantomData, Sized};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n@@ -914,6 +914,11 @@ impl Debug for () {\n         f.pad(\"()\")\n     }\n }\n+impl<T> Debug for PhantomData<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(\"PhantomData\")\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Copy + Debug> Debug for Cell<T> {"}, {"sha": "2e83334b93732378c960019def28bbef57e2ee77", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 357, "deletions": 114, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -35,16 +35,16 @@\n //! the trait `Hash`:\n //!\n //! ```rust\n-//! use std::hash::{hash, Hash, Hasher, Writer, SipHasher};\n+//! use std::hash::{hash, Hash, Hasher, SipHasher};\n //!\n //! struct Person {\n //!     id: uint,\n //!     name: String,\n //!     phone: u64,\n //! }\n //!\n-//! impl<H: Hasher + Writer> Hash<H> for Person {\n-//!     fn hash(&self, state: &mut H) {\n+//! impl Hash for Person {\n+//!     fn hash<H: Hasher>(&self, state: &mut H) {\n //!         self.id.hash(state);\n //!         self.phone.hash(state);\n //!     }\n@@ -56,15 +56,12 @@\n //! assert_eq!(hash::<_, SipHasher>(&person1), hash::<_, SipHasher>(&person2));\n //! ```\n \n-#![unstable(feature = \"hash\",\n-            reason = \"module was recently redesigned\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use prelude::*;\n \n-use borrow::{Cow, ToOwned};\n use default::Default;\n use mem;\n-use num::Int;\n \n pub use self::sip::SipHasher;\n \n@@ -76,29 +73,131 @@ mod sip;\n /// to compute the hash. Specific implementations of this trait may specialize\n /// for particular instances of `H` in order to be able to optimize the hashing\n /// behavior.\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Hash {\n+    /// Feeds this value into the state given, updating the hasher as necessary.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn hash<H: Hasher>(&self, state: &mut H);\n+\n+    /// Feeds a slice of this type into the state provided.\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) where Self: Sized {\n+        for piece in data {\n+            piece.hash(state);\n+        }\n+    }\n+}\n+\n+/// A hashable type.\n+///\n+/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n+/// to compute the hash. Specific implementations of this trait may specialize\n+/// for particular instances of `H` in order to be able to optimize the hashing\n+/// behavior.\n+#[cfg(stage0)]\n pub trait Hash<H: Hasher> {\n     /// Feeds this value into the state given, updating the hasher as necessary.\n     fn hash(&self, state: &mut H);\n }\n \n /// A trait which represents the ability to hash an arbitrary stream of bytes.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hasher {\n     /// Result type of one run of hashing generated by this hasher.\n+    #[cfg(stage0)]\n     type Output;\n \n     /// Resets this hasher back to its initial state (as if it were just\n     /// created).\n+    #[cfg(stage0)]\n     fn reset(&mut self);\n \n     /// Completes a round of hashing, producing the output hash generated.\n+    #[cfg(stage0)]\n     fn finish(&self) -> Self::Output;\n+\n+    /// Completes a round of hashing, producing the output hash generated.\n+    #[cfg(not(stage0))]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn finish(&self) -> u64;\n+\n+    /// Writes some data into this `Hasher`\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn write(&mut self, bytes: &[u8]);\n+\n+    /// Write a single `u8` into this hasher\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_u8(&mut self, i: u8) { self.write(&[i]) }\n+    /// Write a single `u16` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_u16(&mut self, i: u16) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i) })\n+    }\n+    /// Write a single `u32` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_u32(&mut self, i: u32) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i) })\n+    }\n+    /// Write a single `u64` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_u64(&mut self, i: u64) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n+    }\n+    /// Write a single `usize` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_usize(&mut self, i: usize) {\n+        if cfg!(target_pointer_width = \"32\") {\n+            self.write_u32(i as u32)\n+        } else {\n+            self.write_u64(i as u64)\n+        }\n+    }\n+\n+    /// Write a single `i8` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }\n+    /// Write a single `i16` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }\n+    /// Write a single `i32` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }\n+    /// Write a single `i64` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }\n+    /// Write a single `isize` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n }\n \n /// A common bound on the `Hasher` parameter to `Hash` implementations in order\n /// to generically hash an aggregate.\n #[unstable(feature = \"hash\",\n            reason = \"this trait will likely be replaced by io::Writer\")]\n #[allow(missing_docs)]\n+#[cfg(stage0)]\n pub trait Writer {\n     fn write(&mut self, bytes: &[u8]);\n }\n@@ -107,148 +206,292 @@ pub trait Writer {\n ///\n /// The specified value will be hashed with this hasher and then the resulting\n /// hash will be returned.\n+#[cfg(stage0)]\n pub fn hash<T: Hash<H>, H: Hasher + Default>(value: &T) -> H::Output {\n     let mut h: H = Default::default();\n     value.hash(&mut h);\n     h.finish()\n }\n \n+/// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n+///\n+/// The specified value will be hashed with this hasher and then the resulting\n+/// hash will be returned.\n+#[cfg(not(stage0))]\n+#[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n+    let mut h: H = Default::default();\n+    value.hash(&mut h);\n+    h.finish()\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n \n-macro_rules! impl_hash {\n-    ($ty:ident, $uty:ident) => {\n-        impl<S: Writer + Hasher> Hash<S> for $ty {\n-            #[inline]\n-            fn hash(&self, state: &mut S) {\n-                let a: [u8; ::$ty::BYTES] = unsafe {\n-                    mem::transmute((*self as $uty).to_le() as $ty)\n-                };\n-                state.write(&a)\n+#[cfg(stage0)]\n+mod impls {\n+    use prelude::*;\n+\n+    use mem;\n+    use num::Int;\n+    use super::*;\n+\n+    macro_rules! impl_hash {\n+        ($ty:ident, $uty:ident) => {\n+            impl<S: Writer + Hasher> Hash<S> for $ty {\n+                #[inline]\n+                fn hash(&self, state: &mut S) {\n+                    let a: [u8; ::$ty::BYTES] = unsafe {\n+                        mem::transmute(*self)\n+                    };\n+                    state.write(&a)\n+                }\n             }\n         }\n     }\n-}\n \n-impl_hash! { u8, u8 }\n-impl_hash! { u16, u16 }\n-impl_hash! { u32, u32 }\n-impl_hash! { u64, u64 }\n-impl_hash! { uint, uint }\n-impl_hash! { i8, u8 }\n-impl_hash! { i16, u16 }\n-impl_hash! { i32, u32 }\n-impl_hash! { i64, u64 }\n-impl_hash! { int, uint }\n-\n-impl<S: Writer + Hasher> Hash<S> for bool {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u8).hash(state);\n+    impl_hash! { u8, u8 }\n+    impl_hash! { u16, u16 }\n+    impl_hash! { u32, u32 }\n+    impl_hash! { u64, u64 }\n+    impl_hash! { uint, uint }\n+    impl_hash! { i8, u8 }\n+    impl_hash! { i16, u16 }\n+    impl_hash! { i32, u32 }\n+    impl_hash! { i64, u64 }\n+    impl_hash! { int, uint }\n+\n+    impl<S: Writer + Hasher> Hash<S> for bool {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u8).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer + Hasher> Hash<S> for char {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u32).hash(state);\n+    impl<S: Writer + Hasher> Hash<S> for char {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u32).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer + Hasher> Hash<S> for str {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        state.write(self.as_bytes());\n-        0xffu8.hash(state)\n+    impl<S: Writer + Hasher> Hash<S> for str {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            state.write(self.as_bytes());\n+            0xffu8.hash(state)\n+        }\n     }\n-}\n \n-macro_rules! impl_hash_tuple {\n-    () => (\n-        impl<S: Hasher> Hash<S> for () {\n-            #[inline]\n-            fn hash(&self, _state: &mut S) {}\n-        }\n-    );\n-\n-    ( $($name:ident)+) => (\n-        impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n-            #[inline]\n-            #[allow(non_snake_case)]\n-            fn hash(&self, state: &mut S) {\n-                match *self {\n-                    ($(ref $name,)*) => {\n-                        $(\n-                            $name.hash(state);\n-                        )*\n+    macro_rules! impl_hash_tuple {\n+        () => (\n+            impl<S: Hasher> Hash<S> for () {\n+                #[inline]\n+                fn hash(&self, _state: &mut S) {}\n+            }\n+        );\n+\n+        ( $($name:ident)+) => (\n+            impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n+                #[inline]\n+                #[allow(non_snake_case)]\n+                fn hash(&self, state: &mut S) {\n+                    match *self {\n+                        ($(ref $name,)*) => {\n+                            $(\n+                                $name.hash(state);\n+                            )*\n+                        }\n                     }\n                 }\n             }\n+        );\n+    }\n+\n+    impl_hash_tuple! {}\n+    impl_hash_tuple! { A }\n+    impl_hash_tuple! { A B }\n+    impl_hash_tuple! { A B C }\n+    impl_hash_tuple! { A B C D }\n+    impl_hash_tuple! { A B C D E }\n+    impl_hash_tuple! { A B C D E F }\n+    impl_hash_tuple! { A B C D E F G }\n+    impl_hash_tuple! { A B C D E F G H }\n+    impl_hash_tuple! { A B C D E F G H I }\n+    impl_hash_tuple! { A B C D E F G H I J }\n+    impl_hash_tuple! { A B C D E F G H I J K }\n+    impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+    impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.len().hash(state);\n+            for elt in self {\n+                elt.hash(state);\n+            }\n         }\n-    );\n-}\n+    }\n \n-impl_hash_tuple! {}\n-impl_hash_tuple! { A }\n-impl_hash_tuple! { A B }\n-impl_hash_tuple! { A B C }\n-impl_hash_tuple! { A B C D }\n-impl_hash_tuple! { A B C D E }\n-impl_hash_tuple! { A B C D E F }\n-impl_hash_tuple! { A B C D E F G }\n-impl_hash_tuple! { A B C D E F G H }\n-impl_hash_tuple! { A B C D E F G H I }\n-impl_hash_tuple! { A B C D E F G H I J }\n-impl_hash_tuple! { A B C D E F G H I J K }\n-impl_hash_tuple! { A B C D E F G H I J K L }\n-\n-impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.len().hash(state);\n-        for elt in self {\n-            elt.hash(state);\n+\n+    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n         }\n     }\n-}\n \n+    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n+        }\n+    }\n \n-impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n+    impl<S: Writer + Hasher, T> Hash<S> for *const T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n     }\n-}\n \n-impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n+    impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n     }\n }\n \n-impl<S: Writer + Hasher, T> Hash<S> for *const T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n+#[cfg(not(stage0))]\n+mod impls {\n+    use prelude::*;\n+\n+    use slice;\n+    use super::*;\n+\n+    macro_rules! impl_write {\n+        ($(($ty:ident, $meth:ident),)*) => {$(\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl Hash for $ty {\n+                fn hash<H: Hasher>(&self, state: &mut H) {\n+                    state.$meth(*self)\n+                }\n+\n+                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n+                    let newlen = data.len() * ::$ty::BYTES;\n+                    let ptr = data.as_ptr() as *const u8;\n+                    state.write(unsafe { slice::from_raw_parts(ptr, newlen) })\n+                }\n+            }\n+        )*}\n     }\n-}\n \n-impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n+    impl_write! {\n+        (u8, write_u8),\n+        (u16, write_u16),\n+        (u32, write_u32),\n+        (u64, write_u64),\n+        (usize, write_usize),\n+        (i8, write_i8),\n+        (i16, write_i16),\n+        (i32, write_i32),\n+        (i64, write_i64),\n+        (isize, write_isize),\n     }\n-}\n \n-impl<'a, T, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, T, B>\n-    where B: Hash<S> + ToOwned<T>\n-{\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Hash for bool {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_u8(*self as u8)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Hash for char {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_u32(*self as u32)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Hash for str {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write(self.as_bytes());\n+            state.write_u8(0xff)\n+        }\n+    }\n+\n+    macro_rules! impl_hash_tuple {\n+        () => (\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl Hash for () {\n+                fn hash<H: Hasher>(&self, _state: &mut H) {}\n+            }\n+        );\n+\n+        ( $($name:ident)+) => (\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($name: Hash),*> Hash for ($($name,)*) {\n+                #[allow(non_snake_case)]\n+                fn hash<S: Hasher>(&self, state: &mut S) {\n+                    let ($(ref $name,)*) = *self;\n+                    $($name.hash(state);)*\n+                }\n+            }\n+        );\n+    }\n+\n+    impl_hash_tuple! {}\n+    impl_hash_tuple! { A }\n+    impl_hash_tuple! { A B }\n+    impl_hash_tuple! { A B C }\n+    impl_hash_tuple! { A B C D }\n+    impl_hash_tuple! { A B C D E }\n+    impl_hash_tuple! { A B C D E F }\n+    impl_hash_tuple! { A B C D E F G }\n+    impl_hash_tuple! { A B C D E F G H }\n+    impl_hash_tuple! { A B C D E F G H I }\n+    impl_hash_tuple! { A B C D E F G H I J }\n+    impl_hash_tuple! { A B C D E F G H I J K }\n+    impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: Hash> Hash for [T] {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            self.len().hash(state);\n+            Hash::hash_slice(self, state)\n+        }\n+    }\n+\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized + Hash> Hash for &'a T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            (**self).hash(state);\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized + Hash> Hash for &'a mut T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            (**self).hash(state);\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T> Hash for *const T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_usize(*self as usize)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T> Hash for *mut T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_usize(*self as usize)\n+        }\n     }\n }"}, {"sha": "ce8917cc20589a93b0edddccc6ede9ed5fe7e329", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -15,7 +15,9 @@\n use prelude::*;\n use default::Default;\n \n-use super::{Hasher, Writer};\n+use super::Hasher;\n+#[cfg(stage0)]\n+use super::Writer;\n \n /// An implementation of SipHash 2-4.\n ///\n@@ -30,6 +32,7 @@ use super::{Hasher, Writer};\n /// strong, this implementation has not been reviewed for such purposes.\n /// As such, all cryptographic uses of this implementation are strongly\n /// discouraged.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SipHasher {\n     k0: u64,\n     k1: u64,\n@@ -88,12 +91,14 @@ macro_rules! compress {\n impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         let mut state = SipHasher {\n             k0: key0,\n@@ -114,10 +119,16 @@ impl SipHasher {\n     #[unstable(feature = \"hash\")]\n     #[deprecated(since = \"1.0.0\", reason = \"renamed to finish\")]\n     pub fn result(&self) -> u64 { self.finish() }\n-}\n \n-impl Writer for SipHasher {\n-    #[inline]\n+    fn reset(&mut self) {\n+        self.length = 0;\n+        self.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.v3 = self.k1 ^ 0x7465646279746573;\n+        self.ntail = 0;\n+    }\n+\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n         self.length += length;\n@@ -164,16 +175,28 @@ impl Writer for SipHasher {\n     }\n }\n \n+#[cfg(stage0)]\n+impl Writer for SipHasher {\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {\n+        self.write(msg)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Hasher for SipHasher {\n+    #[cfg(stage0)]\n     type Output = u64;\n \n+    #[cfg(stage0)]\n     fn reset(&mut self) {\n-        self.length = 0;\n-        self.v0 = self.k0 ^ 0x736f6d6570736575;\n-        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n-        self.v2 = self.k0 ^ 0x6c7967656e657261;\n-        self.v3 = self.k1 ^ 0x7465646279746573;\n-        self.ntail = 0;\n+        self.reset();\n+    }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn write(&mut self, msg: &[u8]) {\n+        self.write(msg)\n     }\n \n     fn finish(&self) -> u64 {\n@@ -199,6 +222,7 @@ impl Hasher for SipHasher {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for SipHasher {\n     #[inline]\n     fn clone(&self) -> SipHasher {\n@@ -216,6 +240,7 @@ impl Clone for SipHasher {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for SipHasher {\n     fn default() -> SipHasher {\n         SipHasher::new()"}, {"sha": "b2ee95963878edb13af4a4b99c9cf529377b13f4", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -50,10 +50,10 @@ pub type GlueFn = extern \"Rust\" fn(*const i8);\n #[derive(Copy)]\n pub struct TyDesc {\n     // sizeof(T)\n-    pub size: uint,\n+    pub size: usize,\n \n     // alignof(T)\n-    pub align: uint,\n+    pub align: usize,\n \n     // Called when a value of type `T` is no longer needed\n     pub drop_glue: GlueFn,\n@@ -186,15 +186,15 @@ extern \"rust-intrinsic\" {\n     /// would *exactly* overwrite a value. When laid out in vectors\n     /// and structures there may be additional padding between\n     /// elements.\n-    pub fn size_of<T>() -> uint;\n+    pub fn size_of<T>() -> usize;\n \n     /// Move a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination.\n     pub fn move_val_init<T>(dst: &mut T, src: T);\n \n-    pub fn min_align_of<T>() -> uint;\n-    pub fn pref_align_of<T>() -> uint;\n+    pub fn min_align_of<T>() -> usize;\n+    pub fn pref_align_of<T>() -> usize;\n \n     /// Get a static pointer to a type descriptor.\n     pub fn get_tydesc<T: ?Sized>() -> *const TyDesc;\n@@ -253,7 +253,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This is implemented as an intrinsic to avoid converting to and from an\n     /// integer, since the conversion would throw away aliasing information.\n-    pub fn offset<T>(dst: *const T, offset: int) -> *const T;\n+    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may *not* overlap.\n@@ -294,7 +294,7 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[unstable(feature = \"core\")]\n-    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n+    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n@@ -324,33 +324,33 @@ extern \"rust-intrinsic\" {\n     /// ```\n     ///\n     #[unstable(feature = \"core\")]\n-    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n+    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n     #[unstable(feature = \"core\",\n                reason = \"uncertain about naming and semantics\")]\n-    pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);\n+    pub fn set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter parameter is set to `true`, so it will not be optimized out.\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,\n-                                                  count: uint);\n+                                                  count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter parameter is set to `true`, so it will not be optimized out.\n-    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n+    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`.\n     ///\n     /// The volatile parameter parameter is set to `true`, so it will not be optimized out.\n-    pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: uint);\n+    pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Perform a volatile load from the `src` pointer.\n     pub fn volatile_load<T>(src: *const T) -> T;"}, {"sha": "8fb10b5b2dc2a53ca3d40709ce7c2abcd46b6e66", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -62,6 +62,7 @@ use clone::Clone;\n use cmp;\n use cmp::Ord;\n use default::Default;\n+use marker;\n use mem;\n use num::{ToPrimitive, Int};\n use ops::{Add, Deref, FnMut};\n@@ -113,9 +114,9 @@ impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n                           built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n-    /// Build a container with elements from an external iterator.\n+    /// Build a container with elements from something iterable.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n+    fn from_iter<T: IntoIterator<Item=A>>(iterator: T) -> Self;\n }\n \n /// Conversion into an `Iterator`\n@@ -147,7 +148,7 @@ impl<I: Iterator> IntoIterator for I {\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n+    fn extend<T: IntoIterator<Item=A>>(&mut self, iterable: T);\n }\n \n /// An extension trait providing numerous methods applicable to all iterators.\n@@ -332,7 +333,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// ```\n     /// let xs = [100, 200, 300];\n-    /// let mut it = xs.iter().map(|x| *x).peekable();\n+    /// let mut it = xs.iter().cloned().peekable();\n     /// assert_eq!(*it.peek().unwrap(), 100);\n     /// assert_eq!(it.next().unwrap(), 100);\n     /// assert_eq!(it.next().unwrap(), 200);\n@@ -522,11 +523,11 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// let a = [1, 4, 2, 3, 8, 9, 6];\n     /// let sum = a.iter()\n-    ///             .map(|&x| x)\n-    ///             .inspect(|&x| println!(\"filtering {}\", x))\n-    ///             .filter(|&x| x % 2 == 0)\n-    ///             .inspect(|&x| println!(\"{} made it through\", x))\n-    ///             .sum();\n+    ///            .map(|x| *x)\n+    ///            .inspect(|&x| println!(\"filtering {}\", x))\n+    ///            .filter(|&x| x % 2 == 0)\n+    ///            .inspect(|&x| println!(\"{} made it through\", x))\n+    ///            .sum();\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n@@ -561,7 +562,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n-    /// let b: Vec<_> = a.iter().map(|&x| x).collect();\n+    /// let b: Vec<_> = a.iter().cloned().collect();\n     /// assert_eq!(a, b);\n     /// ```\n     #[inline]\n@@ -937,7 +938,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// ```\n     /// let a = [(1, 2), (3, 4)];\n-    /// let (left, right): (Vec<_>, Vec<_>) = a.iter().map(|&x| x).unzip();\n+    /// let (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n     /// assert_eq!([1, 3], left);\n     /// assert_eq!([2, 4], right);\n     /// ```\n@@ -947,7 +948,7 @@ pub trait IteratorExt: Iterator + Sized {\n         FromB: Default + Extend<B>,\n         Self: Iterator<Item=(A, B)>,\n     {\n-        struct SizeHint<A>(usize, Option<usize>);\n+        struct SizeHint<A>(usize, Option<usize>, marker::PhantomData<A>);\n         impl<A> Iterator for SizeHint<A> {\n             type Item = A;\n \n@@ -961,8 +962,8 @@ pub trait IteratorExt: Iterator + Sized {\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        ts.extend(SizeHint(lo, hi));\n-        us.extend(SizeHint(lo, hi));\n+        ts.extend(SizeHint(lo, hi, marker::PhantomData));\n+        us.extend(SizeHint(lo, hi, marker::PhantomData));\n \n         for (t, u) in self {\n             ts.extend(Some(t).into_iter());\n@@ -1142,7 +1143,7 @@ pub trait AdditiveIterator<A> {\n     /// use std::iter::AdditiveIterator;\n     ///\n     /// let a = [1i32, 2, 3, 4, 5];\n-    /// let mut it = a.iter().map(|&x| x);\n+    /// let mut it = a.iter().cloned();\n     /// assert!(it.sum() == 15);\n     /// ```\n     fn sum(self) -> A;\n@@ -1305,6 +1306,23 @@ impl<T, D, I> ExactSizeIterator for Cloned<I> where\n     I: ExactSizeIterator<Item=D>,\n {}\n \n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+impl<T, D, I> RandomAccessIterator for Cloned<I> where\n+    T: Clone,\n+    D: Deref<Target=T>,\n+    I: RandomAccessIterator<Item=D>\n+{\n+    #[inline]\n+    fn indexable(&self) -> usize {\n+        self.it.indexable()\n+    }\n+\n+    #[inline]\n+    fn idx(&mut self, index: usize) -> Option<T> {\n+        self.it.idx(index).cloned()\n+    }\n+}\n+\n /// An iterator that repeats endlessly\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -2047,8 +2065,8 @@ pub struct Scan<I, St, F> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, St, F> Iterator for Scan<I, St, F> where\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n+impl<A, B, I: Iterator<Item=A>, St, F> Iterator for Scan<I, St, F> where\n+    F: FnMut(&mut St, A) -> Option<B>,\n {\n     type Item = B;\n "}, {"sha": "3c58480ff0cfa1d70275b9f04bf6931782575468", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -126,7 +126,6 @@ pub mod default;\n \n pub mod any;\n pub mod atomic;\n-pub mod borrow;\n pub mod cell;\n pub mod char;\n pub mod panicking;"}, {"sha": "d284eb341792b4d363c3cd6896346b7db581a32d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 188, "deletions": 205, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -26,6 +26,10 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use clone::Clone;\n+use cmp;\n+use option::Option;\n+use hash::Hash;\n+use hash::Hasher;\n \n /// Types able to be transferred across thread boundaries.\n #[unstable(feature = \"core\",\n@@ -37,20 +41,19 @@ pub unsafe trait Send: 'static {\n     // empty.\n }\n /// Types able to be transferred across thread boundaries.\n-#[unstable(feature = \"core\",\n-           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n #[cfg(not(stage0))]\n-pub unsafe trait Send {\n+pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n-pub trait Sized {\n+pub trait Sized : MarkerTrait {\n     // Empty.\n }\n \n@@ -155,7 +158,7 @@ pub trait Sized {\n /// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"copy\"]\n-pub trait Copy {\n+pub trait Copy : MarkerTrait {\n     // Empty.\n }\n \n@@ -204,236 +207,179 @@ pub trait Copy {\n /// around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n-#[unstable(feature = \"core\",\n-           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n-pub unsafe trait Sync {\n+pub unsafe trait Sync : MarkerTrait {\n     // Empty\n }\n \n-/// A marker type that indicates to the compiler that the instances\n-/// of the type itself owns instances of the type parameter `T`.\n-///\n-/// This is used to indicate that one or more instances of the type\n-/// `T` could be dropped when instances of the type itself is dropped,\n-/// though that may not be apparent from the other structure of the\n-/// type itself. For example, the type may hold a `*mut T`, which the\n-/// compiler does not automatically treat as owned.\n+/// A type which is considered \"not POD\", meaning that it is not\n+/// implicitly copyable. This is typically embedded in other types to\n+/// ensure that they are never copied, even if they lack a destructor.\n #[unstable(feature = \"core\",\n-           reason = \"Newly added to deal with scoping and destructor changes\")]\n-#[lang=\"phantom_data\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct PhantomData<T: ?Sized>;\n+           reason = \"likely to change with new variance strategy\")]\n+#[lang=\"no_copy_bound\"]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct NoCopy;\n \n-impl<T: ?Sized> Copy for PhantomData<T> {}\n-impl<T: ?Sized> Clone for PhantomData<T> {\n-    fn clone(&self) -> PhantomData<T> { *self }\n+/// A type which is considered managed by the GC. This is typically\n+/// embedded in other types.\n+#[unstable(feature = \"core\",\n+           reason = \"likely to change with new variance strategy\")]\n+#[lang=\"managed_bound\"]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Managed;\n+\n+macro_rules! impls{\n+    ($t: ident) => (\n+        #[cfg(stage0)]\n+        impl<T:?Sized, S: Hasher> Hash<S> for $t<T> {\n+            #[inline]\n+            fn hash(&self, _: &mut S) {\n+            }\n+        }\n+        #[cfg(not(stage0))]\n+        impl<T:?Sized> Hash for $t<T> {\n+            #[inline]\n+            fn hash<H: Hasher>(&self, _: &mut H) {\n+            }\n+        }\n+\n+        impl<T:?Sized> cmp::PartialEq for $t<T> {\n+            fn eq(&self, _other: &$t<T>) -> bool {\n+                true\n+            }\n+        }\n+\n+        impl<T:?Sized> cmp::Eq for $t<T> {\n+        }\n+\n+        impl<T:?Sized> cmp::PartialOrd for $t<T> {\n+            fn partial_cmp(&self, _other: &$t<T>) -> Option<cmp::Ordering> {\n+                Option::Some(cmp::Ordering::Equal)\n+            }\n+        }\n+\n+        impl<T:?Sized> cmp::Ord for $t<T> {\n+            fn cmp(&self, _other: &$t<T>) -> cmp::Ordering {\n+                cmp::Ordering::Equal\n+            }\n+        }\n+\n+        impl<T:?Sized> Copy for $t<T> { }\n+\n+        impl<T:?Sized> Clone for $t<T> {\n+            fn clone(&self) -> $t<T> {\n+                $t\n+            }\n+        }\n+        )\n }\n \n-/// A marker type whose type parameter `T` is considered to be\n-/// covariant with respect to the type itself. This is (typically)\n-/// used to indicate that an instance of the type `T` is being stored\n-/// into memory and read from, even though that may not be apparent.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-///\n-/// *Note:* It is very unusual to have to add a covariant constraint.\n-/// If you are not sure, you probably want to use `InvariantType`.\n+/// `MarkerTrait` is intended to be used as the supertrait for traits\n+/// that don't have any methods but instead serve just to designate\n+/// categories of types. An example would be the `Send` trait, which\n+/// indicates types that are sendable: `Send` does not itself offer\n+/// any methods, but instead is used to gate access to data.\n+///\n+/// FIXME. Better documentation needed here!\n+pub trait MarkerTrait : PhantomFn<Self> { }\n+impl<T:?Sized> MarkerTrait for T { }\n+\n+/// `PhantomFn` is a marker trait for use with traits that contain\n+/// type or lifetime parameters that do not appear in any of their\n+/// methods. In that case, you can either remove those parameters, or\n+/// add a `PhantomFn` supertrait that reflects the signature of\n+/// methods that compiler should \"pretend\" exists. This most commonly\n+/// occurs for traits with no methods: in that particular case, you\n+/// can extend `MarkerTrait`, which is equivalent to\n+/// `PhantomFn<Self>`.\n ///\n /// # Example\n ///\n-/// Given a struct `S` that includes a type parameter `T`\n-/// but does not actually *reference* that type parameter:\n+/// As an example, consider a trait with no methods like `Even`, meant\n+/// to represent types that are \"even\":\n ///\n-/// ```ignore\n-/// use std::mem;\n-///\n-/// struct S<T> { x: *() }\n-/// fn get<T>(s: &S<T>) -> T {\n-///    unsafe {\n-///        let x: *T = mem::transmute(s.x);\n-///        *x\n-///    }\n-/// }\n+/// ```rust,ignore\n+/// trait Even { }\n /// ```\n ///\n-/// The type system would currently infer that the value of\n-/// the type parameter `T` is irrelevant, and hence a `S<int>` is\n-/// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n-/// any `U`). But this is incorrect because `get()` converts the\n-/// `*()` into a `*T` and reads from it. Therefore, we should include the\n-/// a marker field `CovariantType<T>` to inform the type checker that\n-/// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n-/// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n-/// for some lifetime `'a`, but not the other way around).\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"covariant_type\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct CovariantType<T: ?Sized>;\n-\n-impl<T: ?Sized> Copy for CovariantType<T> {}\n-impl<T: ?Sized> Clone for CovariantType<T> {\n-    fn clone(&self) -> CovariantType<T> { *self }\n-}\n-\n-/// A marker type whose type parameter `T` is considered to be\n-/// contravariant with respect to the type itself. This is (typically)\n-/// used to indicate that an instance of the type `T` will be consumed\n-/// (but not read from), even though that may not be apparent.\n+/// In this case, because the implicit parameter `Self` is unused, the\n+/// compiler will issue an error. The only purpose of this trait is to\n+/// categorize types (and hence instances of those types) as \"even\" or\n+/// not, so if we *were* going to have a method, it might look like:\n ///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+/// ```rust,ignore\n+/// trait Even {\n+///     fn is_even(self) -> bool { true }\n+/// }\n+/// ```\n ///\n-/// *Note:* It is very unusual to have to add a contravariant constraint.\n-/// If you are not sure, you probably want to use `InvariantType`.\n+/// Therefore, we can model a method like this as follows:\n ///\n-/// # Example\n+/// ```rust\n+/// use std::marker::PhantomFn;\n+/// trait Even : PhantomFn<Self> { }\n+/// ```\n ///\n-/// Given a struct `S` that includes a type parameter `T`\n-/// but does not actually *reference* that type parameter:\n+/// Another equivalent, but clearer, option would be to use\n+/// `MarkerTrait`:\n ///\n+/// ```rust\n+/// use std::marker::MarkerTrait;\n+/// trait Even : MarkerTrait { }\n /// ```\n-/// use std::mem;\n-///\n-/// struct S<T> { x: *const () }\n-/// fn get<T>(s: &S<T>, v: T) {\n-///    unsafe {\n-///        let x: fn(T) = mem::transmute(s.x);\n-///        x(v)\n-///    }\n-/// }\n-/// ```\n-///\n-/// The type system would currently infer that the value of\n-/// the type parameter `T` is irrelevant, and hence a `S<int>` is\n-/// a subtype of `S<Box<int>>` (or, for that matter, `S<U>` for\n-/// any `U`). But this is incorrect because `get()` converts the\n-/// `*()` into a `fn(T)` and then passes a value of type `T` to it.\n-///\n-/// Supplying a `ContravariantType` marker would correct the\n-/// problem, because it would mark `S` so that `S<T>` is only a\n-/// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n-/// function requires arguments of type `T`, it must also accept\n-/// arguments of type `U`, hence such a conversion is safe.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"contravariant_type\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct ContravariantType<T: ?Sized>;\n-\n-impl<T: ?Sized> Copy for ContravariantType<T> {}\n-impl<T: ?Sized> Clone for ContravariantType<T> {\n-    fn clone(&self) -> ContravariantType<T> { *self }\n-}\n-\n-/// A marker type whose type parameter `T` is considered to be\n-/// invariant with respect to the type itself. This is (typically)\n-/// used to indicate that instances of the type `T` may be read or\n-/// written, even though that may not be apparent.\n ///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+/// # Parameters\n ///\n-/// # Example\n+/// - `A` represents the type of the method's argument. You can use a\n+///   tuple to represent \"multiple\" arguments. Any types appearing here\n+///   will be considered \"contravariant\".\n+/// - `R`, if supplied, represents the method's return type. This defaults\n+///   to `()` as it is rarely needed.\n ///\n-/// The Cell type is an example of an `InvariantType` which uses unsafe\n-/// code to achieve \"interior\" mutability:\n+/// # Additional reading\n ///\n-/// ```\n-/// struct Cell<T> { value: T }\n-/// ```\n+/// More details and background can be found in [RFC 738][738].\n ///\n-/// The type system would infer that `value` is only read here\n-/// and never written, but in fact `Cell` uses unsafe code to achieve\n-/// interior mutability. In order to get correct behavior, the\n-/// `InvariantType` marker must be applied.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"invariant_type\"]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub struct InvariantType<T: ?Sized>;\n-\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-impl<T: ?Sized> Copy for InvariantType<T> {}\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-impl<T: ?Sized> Clone for InvariantType<T> {\n-    fn clone(&self) -> InvariantType<T> { *self }\n-}\n-\n-/// As `CovariantType`, but for lifetime parameters. Using\n-/// `CovariantLifetime<'a>` indicates that it is ok to substitute\n-/// a *longer* lifetime for `'a` than the one you originally\n-/// started with (e.g., you could convert any lifetime `'foo` to\n-/// `'static`). You almost certainly want `ContravariantLifetime`\n-/// instead, or possibly `InvariantLifetime`. The only case where\n-/// it would be appropriate is that you have a (type-casted, and\n-/// hence hidden from the type system) function pointer with a\n-/// signature like `fn(&'a T)` (and no other uses of `'a`). In\n-/// this case, it is ok to substitute a larger lifetime for `'a`\n-/// (e.g., `fn(&'static T)`), because the function is only\n-/// becoming more selective in terms of what it accepts as\n-/// argument.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"covariant_lifetime\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct CovariantLifetime<'a>;\n+/// [738]: https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\n+#[lang=\"phantom_fn\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n \n-/// As `ContravariantType`, but for lifetime parameters. Using\n-/// `ContravariantLifetime<'a>` indicates that it is ok to\n-/// substitute a *shorter* lifetime for `'a` than the one you\n-/// originally started with (e.g., you could convert `'static` to\n-/// any lifetime `'foo`). This is appropriate for cases where you\n-/// have an unsafe pointer that is actually a pointer into some\n-/// memory with lifetime `'a`, and thus you want to limit the\n-/// lifetime of your data structure to `'a`. An example of where\n-/// this is used is the iterator for vectors.\n-///\n-/// For more information about variance, refer to this Wikipedia\n-/// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"contravariant_lifetime\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct ContravariantLifetime<'a>;\n+#[cfg(stage0)] // built into the trait matching system after stage0\n+impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n \n-/// As `InvariantType`, but for lifetime parameters. Using\n-/// `InvariantLifetime<'a>` indicates that it is not ok to\n-/// substitute any other lifetime for `'a` besides its original\n-/// value. This is appropriate for cases where you have an unsafe\n-/// pointer that is actually a pointer into memory with lifetime `'a`,\n-/// and this pointer is itself stored in an inherently mutable\n-/// location (such as a `Cell`).\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"invariant_lifetime\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct InvariantLifetime<'a>;\n+/// Specific to stage0. You should not be seeing these docs!\n+#[cfg(stage0)]\n+#[lang=\"covariant_type\"] // only relevant to stage0\n+pub struct PhantomData<T:?Sized>;\n \n-/// A type which is considered \"not POD\", meaning that it is not\n-/// implicitly copyable. This is typically embedded in other types to\n-/// ensure that they are never copied, even if they lack a destructor.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"no_copy_bound\"]\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct NoCopy;\n+/// `PhantomData` is a way to tell the compiler about fake fields.\n+/// Phantom data is required whenever type parameters are not used.\n+/// The idea is that if the compiler encounters a `PhantomData<T>`\n+/// instance, it will behave *as if* an instance of the type `T` were\n+/// present for the purpose of various automatic analyses.\n+///\n+/// For example, embedding a `PhantomData<T>` will inform the compiler\n+/// that one or more instances of the type `T` could be dropped when\n+/// instances of the type itself is dropped, though that may not be\n+/// apparent from the other structure of the type itself. This is\n+/// commonly necessary if the structure is using an unsafe pointer\n+/// like `*mut T` whose referent may be dropped when the type is\n+/// dropped, as a `*mut T` is otherwise not treated as owned.\n+///\n+/// FIXME. Better documentation and examples of common patterns needed\n+/// here! For now, please see [RFC 738][738] for more information.\n+///\n+/// [738]: https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\n+#[cfg(not(stage0))]\n+#[lang=\"phantom_data\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct PhantomData<T:?Sized>;\n \n-/// A type which is considered managed by the GC. This is typically\n-/// embedded in other types.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"managed_bound\"]\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct Managed;\n+impls! { PhantomData }\n \n #[cfg(not(stage0))]\n mod impls {\n@@ -442,3 +388,40 @@ mod impls {\n     unsafe impl<'a, T: Sync + ?Sized> Send for &'a T {}\n     unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}\n }\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<&'a ()>`\")]\n+#[lang=\"contravariant_lifetime\"]\n+pub struct ContravariantLifetime<'a>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<fn(&'a ())>`\")]\n+#[lang=\"covariant_lifetime\"]\n+pub struct CovariantLifetime<'a>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<&'a ()>>`\")]\n+#[lang=\"invariant_lifetime\"]\n+pub struct InvariantLifetime<'a>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<fn(T)>`\")]\n+#[lang=\"contravariant_type\"]\n+pub struct ContravariantType<T>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<T>`\")]\n+#[lang=\"covariant_type\"]\n+#[cfg(not(stage0))]\n+pub struct CovariantType<T>;\n+\n+/// Old-style marker trait. Deprecated.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<T>>`\")]\n+#[lang=\"invariant_type\"]\n+pub struct InvariantType<T>;"}, {"sha": "230587b726fd1e022748df5e76ab48899237be7f", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -10,15 +10,14 @@\n \n //! Exposes the NonZero lang item which provides optimization hints.\n \n+use marker::{Sized, MarkerTrait};\n use ops::Deref;\n-use ptr::Unique;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n-pub unsafe trait Zeroable {}\n+pub unsafe trait Zeroable : MarkerTrait {}\n \n-unsafe impl<T> Zeroable for *const T {}\n-unsafe impl<T> Zeroable for *mut T {}\n-unsafe impl<T> Zeroable for Unique<T> { }\n+unsafe impl<T:?Sized> Zeroable for *const T {}\n+unsafe impl<T:?Sized> Zeroable for *mut T {}\n unsafe impl Zeroable for isize {}\n unsafe impl Zeroable for usize {}\n unsafe impl Zeroable for i8 {}"}, {"sha": "abfef72a5dbc33b735a67416a191f2e1b093600c", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -149,7 +149,7 @@ use clone::Clone;\n use cmp::{Eq, Ord};\n use default::Default;\n use iter::{ExactSizeIterator};\n-use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator};\n+use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, IntoIterator};\n use mem;\n use ops::{Deref, FnOnce};\n use result::Result::{Ok, Err};\n@@ -909,7 +909,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_iter<I: Iterator<Item=Option<A>>>(iter: I) -> Option<V> {\n+    fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n@@ -934,7 +934,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n             }\n         }\n \n-        let mut adapter = Adapter { iter: iter, found_none: false };\n+        let mut adapter = Adapter { iter: iter.into_iter(), found_none: false };\n         let v: V = FromIterator::from_iter(adapter.by_ref());\n \n         if adapter.found_none {"}, {"sha": "16b84dcf18e24aed5952b17cfbf1b7f45b1648c0", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -91,8 +91,10 @@\n use mem;\n use clone::Clone;\n use intrinsics;\n+use ops::Deref;\n use option::Option::{self, Some, None};\n-use marker::{self, Send, Sized, Sync};\n+use marker::{PhantomData, Send, Sized, Sync};\n+use nonzero::NonZero;\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd};\n use cmp::Ordering::{self, Less, Equal, Greater};\n@@ -303,7 +305,7 @@ impl<T> PtrExt for *const T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_null(self) -> bool { self as usize == 0 }\n+    fn is_null(self) -> bool { self == 0 as *const T }\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -330,7 +332,7 @@ impl<T> PtrExt for *mut T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_null(self) -> bool { self as usize == 0 }\n+    fn is_null(self) -> bool { self == 0 as *mut T }\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -517,15 +519,16 @@ impl<T> PartialOrd for *mut T {\n \n /// A wrapper around a raw `*mut T` that indicates that the possessor\n /// of this wrapper owns the referent. This in turn implies that the\n-/// `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a\n-/// raw `*mut T` (which conveys no particular ownership semantics).\n-/// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n+/// `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a raw\n+/// `*mut T` (which conveys no particular ownership semantics).  It\n+/// also implies that the referent of the pointer should not be\n+/// modified without a unique path to the `Unique` reference. Useful\n+/// for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n #[unstable(feature = \"core\", reason = \"recently added to this module\")]\n-pub struct Unique<T: ?Sized> {\n-    /// The wrapped `*mut T`.\n-    pub ptr: *mut T,\n-    _own: marker::PhantomData<T>,\n+pub struct Unique<T:?Sized> {\n+    pointer: NonZero<*const T>,\n+    _marker: PhantomData<T>,\n }\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n@@ -542,25 +545,34 @@ unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n #[unstable(feature = \"core\", reason = \"recently added to this module\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n-impl<T> Unique<T> {\n-    /// Returns a null Unique.\n+impl<T:?Sized> Unique<T> {\n+    /// Create a new `Unique`.\n     #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n-    pub fn null() -> Unique<T> {\n-        Unique(null_mut())\n+    pub unsafe fn new(ptr: *mut T) -> Unique<T> {\n+        Unique { pointer: NonZero::new(ptr as *const T), _marker: PhantomData }\n     }\n \n-    /// Return an (unsafe) pointer into the memory owned by `self`.\n+    /// Dereference the content.\n     #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n-    pub unsafe fn offset(self, offset: isize) -> *mut T {\n-        self.ptr.offset(offset)\n+    pub unsafe fn get(&self) -> &T {\n+        &**self.pointer\n+    }\n+\n+    /// Mutably dereference the content.\n+    #[unstable(feature = \"core\",\n+               reason = \"recently added to this module\")]\n+    pub unsafe fn get_mut(&mut self) -> &mut T {\n+        &mut ***self\n     }\n }\n \n-/// Creates a `Unique` wrapped around `ptr`, taking ownership of the\n-/// data referenced by `ptr`.\n-#[allow(non_snake_case)]\n-pub fn Unique<T: ?Sized>(ptr: *mut T) -> Unique<T> {\n-    Unique { ptr: ptr, _own: marker::PhantomData }\n+impl<T:?Sized> Deref for Unique<T> {\n+    type Target = *mut T;\n+\n+    #[inline]\n+    fn deref<'a>(&'a self) -> &'a *mut T {\n+        unsafe { mem::transmute(&*self.pointer) }\n+    }\n }"}, {"sha": "23e936a75d7097e04f972a3da25796a285090711", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -230,7 +230,8 @@ use self::Result::{Ok, Err};\n \n use clone::Clone;\n use fmt;\n-use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, ExactSizeIterator};\n+use iter::{Iterator, IteratorExt, DoubleEndedIterator,\n+           FromIterator, ExactSizeIterator, IntoIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n use slice::AsSlice;\n@@ -906,7 +907,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// assert!(res == Ok(vec!(2, 3)));\n     /// ```\n     #[inline]\n-    fn from_iter<I: Iterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n+    fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n@@ -931,7 +932,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n             }\n         }\n \n-        let mut adapter = Adapter { iter: iter, err: None };\n+        let mut adapter = Adapter { iter: iter.into_iter(), err: None };\n         let v: V = FromIterator::from_iter(adapter.by_ref());\n \n         match adapter.err {"}, {"sha": "a86da53b372a9bfc2b14969f445fc7ad1be40465", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -140,11 +140,11 @@ impl<T> SliceExt for [T] {\n             if mem::size_of::<T>() == 0 {\n                 Iter {ptr: p,\n                       end: (p as usize + self.len()) as *const T,\n-                      marker: marker::ContravariantLifetime::<'a>}\n+                      _marker: marker::PhantomData}\n             } else {\n                 Iter {ptr: p,\n                       end: p.offset(self.len() as isize),\n-                      marker: marker::ContravariantLifetime::<'a>}\n+                      _marker: marker::PhantomData}\n             }\n         }\n     }\n@@ -279,11 +279,11 @@ impl<T> SliceExt for [T] {\n             if mem::size_of::<T>() == 0 {\n                 IterMut {ptr: p,\n                          end: (p as usize + self.len()) as *mut T,\n-                         marker: marker::ContravariantLifetime::<'a>}\n+                         _marker: marker::PhantomData}\n             } else {\n                 IterMut {ptr: p,\n                          end: p.offset(self.len() as isize),\n-                         marker: marker::ContravariantLifetime::<'a>}\n+                         _marker: marker::PhantomData}\n             }\n         }\n     }\n@@ -733,7 +733,7 @@ macro_rules! make_slice {\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n-    marker: marker::ContravariantLifetime<'a>\n+    _marker: marker::PhantomData<&'a T>,\n }\n \n #[unstable(feature = \"core\")]\n@@ -790,7 +790,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n-    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, marker: self.marker } }\n+    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n@@ -823,7 +823,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n     end: *mut T,\n-    marker: marker::ContravariantLifetime<'a>,\n+    _marker: marker::PhantomData<&'a mut T>,\n }\n \n "}, {"sha": "eec997b9f10fc76f3090ae58a4d59b5655c1f2b5", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -1280,7 +1280,7 @@ mod traits {\n /// Any string that can be represented as a slice\n #[unstable(feature = \"core\",\n            reason = \"Instead of taking this bound generically, this trait will be \\\n-                     replaced with one of slicing syntax (&foo[]), deref coercions, or \\\n+                     replaced with one of slicing syntax (&foo[..]), deref coercions, or \\\n                      a more generic conversion trait\")]\n pub trait Str {\n     /// Work with `self` as a slice."}, {"sha": "9b6af182f729c291751d2db896acfbc4e5c74200", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::mem;\n-use std::hash::{Hash, Hasher, Writer};\n+use std::hash::{Hash, Hasher};\n use std::default::Default;\n \n struct MyHasher {\n@@ -22,25 +22,19 @@ impl Default for MyHasher {\n     }\n }\n \n-impl Writer for MyHasher {\n-    // Most things we'll just add up the bytes.\n+impl Hasher for MyHasher {\n     fn write(&mut self, buf: &[u8]) {\n         for byte in buf {\n             self.hash += *byte as u64;\n         }\n     }\n-}\n-\n-impl Hasher for MyHasher {\n-    type Output = u64;\n-    fn reset(&mut self) { self.hash = 0; }\n     fn finish(&self) -> u64 { self.hash }\n }\n \n \n #[test]\n fn test_writer_hasher() {\n-    fn hash<T: Hash<MyHasher>>(t: &T) -> u64 {\n+    fn hash<T: Hash>(t: &T) -> u64 {\n         ::std::hash::hash::<_, MyHasher>(t)\n     }\n \n@@ -90,9 +84,9 @@ struct Custom { hash: u64 }\n struct CustomHasher { output: u64 }\n \n impl Hasher for CustomHasher {\n-    type Output = u64;\n-    fn reset(&mut self) { self.output = 0; }\n     fn finish(&self) -> u64 { self.output }\n+    fn write(&mut self, data: &[u8]) { panic!() }\n+    fn write_u64(&mut self, data: u64) { self.output = data; }\n }\n \n impl Default for CustomHasher {\n@@ -101,15 +95,15 @@ impl Default for CustomHasher {\n     }\n }\n \n-impl Hash<CustomHasher> for Custom {\n-    fn hash(&self, state: &mut CustomHasher) {\n-        state.output = self.hash;\n+impl Hash for Custom {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        state.write_u64(self.hash);\n     }\n }\n \n #[test]\n fn test_custom_state() {\n-    fn hash<T: Hash<CustomHasher>>(t: &T) -> u64 {\n+    fn hash<T: Hash>(t: &T) -> u64 {\n         ::std::hash::hash::<_, CustomHasher>(t)\n     }\n "}, {"sha": "39a590c73074332d91a6de9319df3a52e2e70546", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -91,7 +91,7 @@ fn test_iterator_chain() {\n     assert_eq!(i, expected.len());\n \n     let ys = count(30, 10).take(4);\n-    let mut it = xs.iter().map(|&x| x).chain(ys);\n+    let mut it = xs.iter().cloned().chain(ys);\n     let mut i = 0;\n     for x in it {\n         assert_eq!(x, expected[i]);\n@@ -119,7 +119,7 @@ fn test_iterator_enumerate() {\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];\n-    let mut it = xs.iter().map(|&x|x).peekable();\n+    let mut it = xs.iter().cloned().peekable();\n \n     assert_eq!(it.len(), 6);\n     assert_eq!(it.peek().unwrap(), &0);\n@@ -259,12 +259,12 @@ fn test_inspect() {\n     let mut n = 0;\n \n     let ys = xs.iter()\n-               .map(|&x| x)\n+               .cloned()\n                .inspect(|_| n += 1)\n                .collect::<Vec<uint>>();\n \n     assert_eq!(n, xs.len());\n-    assert_eq!(&xs[], &ys[]);\n+    assert_eq!(&xs[..], &ys[..]);\n }\n \n #[test]\n@@ -329,33 +329,33 @@ fn test_iterator_len() {\n #[test]\n fn test_iterator_sum() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[..4].iter().map(|&x| x).sum(), 6);\n-    assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-    assert_eq!(v[..0].iter().map(|&x| x).sum(), 0);\n+    assert_eq!(v[..4].iter().cloned().sum(), 6);\n+    assert_eq!(v.iter().cloned().sum(), 55);\n+    assert_eq!(v[..0].iter().cloned().sum(), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[..4].iter().map(|&x| x).product(), 0);\n-    assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n-    assert_eq!(v[..0].iter().map(|&x| x).product(), 1);\n+    assert_eq!(v[..4].iter().cloned().product(), 0);\n+    assert_eq!(v[1..5].iter().cloned().product(), 24);\n+    assert_eq!(v[..0].iter().cloned().product(), 1);\n }\n \n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[..4].iter().map(|&x| x).max(), Some(3));\n-    assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-    assert_eq!(v[..0].iter().map(|&x| x).max(), None);\n+    assert_eq!(v[..4].iter().cloned().max(), Some(3));\n+    assert_eq!(v.iter().cloned().max(), Some(10));\n+    assert_eq!(v[..0].iter().cloned().max(), None);\n }\n \n #[test]\n fn test_iterator_min() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[..4].iter().map(|&x| x).min(), Some(0));\n-    assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-    assert_eq!(v[..0].iter().map(|&x| x).min(), None);\n+    assert_eq!(v[..4].iter().cloned().min(), Some(0));\n+    assert_eq!(v.iter().cloned().min(), Some(0));\n+    assert_eq!(v[..0].iter().cloned().min(), None);\n }\n \n #[test]\n@@ -373,7 +373,7 @@ fn test_iterator_size_hint() {\n     assert_eq!(c.clone().take_while(|_| false).size_hint(), (0, None));\n     assert_eq!(c.clone().skip_while(|_| false).size_hint(), (0, None));\n     assert_eq!(c.clone().enumerate().size_hint(), (uint::MAX, None));\n-    assert_eq!(c.clone().chain(vi.clone().map(|&i| i)).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.clone().chain(vi.clone().cloned()).size_hint(), (uint::MAX, None));\n     assert_eq!(c.clone().zip(vi.clone()).size_hint(), (10, Some(10)));\n     assert_eq!(c.clone().scan(0, |_,_| Some(0)).size_hint(), (0, None));\n     assert_eq!(c.clone().filter(|_| false).size_hint(), (0, None));\n@@ -398,7 +398,7 @@ fn test_iterator_size_hint() {\n #[test]\n fn test_collect() {\n     let a = vec![1, 2, 3, 4, 5];\n-    let b: Vec<int> = a.iter().map(|&x| x).collect();\n+    let b: Vec<int> = a.iter().cloned().collect();\n     assert!(a == b);\n }\n \n@@ -471,7 +471,7 @@ fn test_rev() {\n     let mut it = xs.iter();\n     it.next();\n     it.next();\n-    assert!(it.rev().map(|&x| x).collect::<Vec<int>>() ==\n+    assert!(it.rev().cloned().collect::<Vec<int>>() ==\n             vec![16, 14, 12, 10, 8, 6]);\n }\n \n@@ -508,7 +508,7 @@ fn test_double_ended_map() {\n #[test]\n fn test_double_ended_enumerate() {\n     let xs = [1, 2, 3, 4, 5, 6];\n-    let mut it = xs.iter().map(|&x| x).enumerate();\n+    let mut it = xs.iter().cloned().enumerate();\n     assert_eq!(it.next(), Some((0, 1)));\n     assert_eq!(it.next(), Some((1, 2)));\n     assert_eq!(it.next_back(), Some((5, 6)));\n@@ -522,8 +522,8 @@ fn test_double_ended_enumerate() {\n fn test_double_ended_zip() {\n     let xs = [1, 2, 3, 4, 5, 6];\n     let ys = [1, 2, 3, 7];\n-    let a = xs.iter().map(|&x| x);\n-    let b = ys.iter().map(|&x| x);\n+    let a = xs.iter().cloned();\n+    let b = ys.iter().cloned();\n     let mut it = a.zip(b);\n     assert_eq!(it.next(), Some((1, 1)));\n     assert_eq!(it.next(), Some((2, 2)));\n@@ -713,7 +713,7 @@ fn test_random_access_inspect() {\n fn test_random_access_map() {\n     let xs = [1, 2, 3, 4, 5];\n \n-    let mut it = xs.iter().map(|x| *x);\n+    let mut it = xs.iter().cloned();\n     assert_eq!(xs.len(), it.indexable());\n     for (i, elt) in xs.iter().enumerate() {\n         assert_eq!(Some(*elt), it.idx(i));"}, {"sha": "5aeb330b78b54023ac388d83d22f5eeff636b319", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -92,7 +92,7 @@ fn test_transmute_copy() {\n \n #[test]\n fn test_transmute() {\n-    trait Foo {}\n+    trait Foo { fn dummy(&self) { } }\n     impl Foo for int {}\n \n     let a = box 100 as Box<Foo>;"}, {"sha": "57456bfb1a79ba04ce4b68c77999d37c2b507a90", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -171,8 +171,8 @@ fn test_set_memory() {\n #[test]\n fn test_unsized_unique() {\n     let xs: &mut [_] = &mut [1, 2, 3];\n-    let ptr = Unique(xs as *mut [_]);\n-    let ys = unsafe { &mut *ptr.ptr };\n+    let ptr = unsafe { Unique::new(xs as *mut [_]) };\n+    let ys = unsafe { &mut **ptr };\n     let zs: &mut [_] = &mut [1, 2, 3];\n     assert!(ys == zs);\n }"}, {"sha": "46c7730cc6470aeb852892cb2f1cf3f31506dcb3", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -43,31 +43,31 @@ fn iterator_to_slice() {\n \n             {\n                 let mut iter = data.iter();\n-                assert_eq!(&iter[], &other_data[]);\n+                assert_eq!(&iter[..], &other_data[..]);\n \n                 iter.next();\n-                assert_eq!(&iter[], &other_data[1..]);\n+                assert_eq!(&iter[..], &other_data[1..]);\n \n                 iter.next_back();\n-                assert_eq!(&iter[], &other_data[1..2]);\n+                assert_eq!(&iter[..], &other_data[1..2]);\n \n                 let s = iter.as_slice();\n                 iter.next();\n                 assert_eq!(s, &other_data[1..2]);\n             }\n             {\n                 let mut iter = data.iter_mut();\n-                assert_eq!(&iter[], &other_data[]);\n+                assert_eq!(&iter[..], &other_data[..]);\n                 // mutability:\n                 assert!(&mut iter[] == other_data);\n \n                 iter.next();\n-                assert_eq!(&iter[], &other_data[1..]);\n+                assert_eq!(&iter[..], &other_data[1..]);\n                 assert!(&mut iter[] == &mut other_data[1..]);\n \n                 iter.next_back();\n \n-                assert_eq!(&iter[], &other_data[1..2]);\n+                assert_eq!(&iter[..], &other_data[1..2]);\n                 assert!(&mut iter[] == &mut other_data[1..2]);\n \n                 let s = iter.into_slice();"}, {"sha": "24660b3f396c105031903ceb43822ff6b690cb66", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -45,13 +45,13 @@ pub struct Bytes {\n impl Deref for Bytes {\n     type Target = [u8];\n     fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts_mut(self.ptr.ptr, self.len) }\n+        unsafe { slice::from_raw_parts(*self.ptr, self.len) }\n     }\n }\n \n impl Drop for Bytes {\n     fn drop(&mut self) {\n-        unsafe { libc::free(self.ptr.ptr as *mut _); }\n+        unsafe { libc::free(*self.ptr as *mut _); }\n     }\n }\n \n@@ -84,7 +84,7 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n                                              &mut outsz,\n                                              flags);\n         if !res.is_null() {\n-            let res = Unique(res as *mut u8);\n+            let res = Unique::new(res as *mut u8);\n             Some(Bytes { ptr: res, len: outsz as uint })\n         } else {\n             None\n@@ -110,7 +110,7 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n                                                &mut outsz,\n                                                flags);\n         if !res.is_null() {\n-            let res = Unique(res as *mut u8);\n+            let res = Unique::new(res as *mut u8);\n             Some(Bytes { ptr: res, len: outsz as uint })\n         } else {\n             None"}, {"sha": "be77622ac1db7c52335525cefd8753423177258f", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -215,11 +215,11 @@ impl<'a> Parser<'a> {\n             }\n             Some((_, other)) => {\n                 self.err(&format!(\"expected `{:?}`, found `{:?}`\", c,\n-                                  other)[]);\n+                                  other));\n             }\n             None => {\n                 self.err(&format!(\"expected `{:?}` but string was terminated\",\n-                                  c)[]);\n+                                  c));\n             }\n         }\n     }"}, {"sha": "fdd7f7395c2b7af5955aa3f52f7cecd52e9cff74", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -287,7 +287,7 @@ impl OptGroup {\n \n impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(&self.opts[], Name::from_str(nm)) {\n+        match find_opt(&self.opts[..], Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n             None => panic!(\"No option '{}' defined\", nm)\n         }\n@@ -326,7 +326,7 @@ impl Matches {\n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names {\n-            match self.opt_val(&nm[]) {\n+            match self.opt_val(&nm[..]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -593,7 +593,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(&cur[]) {\n+        if !is_arg(&cur[..]) {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n@@ -667,7 +667,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                         v.push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(&args[i + 1][]) {\n+                            is_arg(&args[i + 1][..]) {\n                         let v = &mut vals[optid];\n                         v.push(Given);\n                     } else {\n@@ -730,7 +730,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             1 => {\n                 row.push('-');\n-                row.push_str(&short_name[]);\n+                row.push_str(&short_name[..]);\n                 row.push(' ');\n             }\n             _ => panic!(\"the short name should only be 1 ascii char long\"),\n@@ -741,18 +741,18 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(&long_name[]);\n+                row.push_str(&long_name[..]);\n                 row.push(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(&hint[]),\n+            Yes => row.push_str(&hint[..]),\n             Maybe => {\n                 row.push('[');\n-                row.push_str(&hint[]);\n+                row.push_str(&hint[..]);\n                 row.push(']');\n             }\n         }\n@@ -765,7 +765,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                 row.push(' ');\n             }\n         } else {\n-            row.push_str(&desc_sep[]);\n+            row.push_str(&desc_sep[..]);\n         }\n \n         // Normalize desc to contain words separated by one space character\n@@ -777,14 +777,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n-        each_split_within(&desc_normalized_whitespace[], 54, |substr| {\n+        each_split_within(&desc_normalized_whitespace[..], 54, |substr| {\n             desc_rows.push(substr.to_string());\n             true\n         });\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(&desc_rows.connect(&desc_sep[])[]);\n+        row.push_str(&desc_rows.connect(&desc_sep[..])[]);\n \n         row\n     });\n@@ -803,18 +803,18 @@ fn format_option(opt: &OptGroup) -> String {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push('-');\n-        line.push_str(&opt.short_name[]);\n+        line.push_str(&opt.short_name[..]);\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(&opt.long_name[]);\n+        line.push_str(&opt.long_name[..]);\n     }\n \n     if opt.hasarg != No {\n         line.push(' ');\n         if opt.hasarg == Maybe {\n             line.push('[');\n         }\n-        line.push_str(&opt.hint[]);\n+        line.push_str(&opt.hint[..]);\n         if opt.hasarg == Maybe {\n             line.push(']');\n         }\n@@ -836,7 +836,7 @@ pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     line.push_str(&opts.iter()\n                        .map(format_option)\n                        .collect::<Vec<String>>()\n-                       .connect(\" \")[]);\n+                       .connect(\" \")[..]);\n     line\n }\n "}, {"sha": "acd52c752e8aa1b29e79505937f332cc2f311dcb", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -275,23 +275,20 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(int_uint)]\n #![feature(collections)]\n-#![feature(core)]\n #![feature(old_io)]\n \n use self::LabelText::*;\n \n-use std::borrow::IntoCow;\n+use std::borrow::{IntoCow, Cow};\n use std::old_io;\n-use std::string::CowString;\n-use std::vec::CowVec;\n \n /// The text for a graphviz label on a node or edge.\n pub enum LabelText<'a> {\n     /// This kind of label preserves the text directly as is.\n     ///\n     /// Occurrences of backslashes (`\\`) are escaped, and thus appear\n     /// as backslashes in the rendered label.\n-    LabelStr(CowString<'a>),\n+    LabelStr(Cow<'a, str>),\n \n     /// This kind of label uses the graphviz label escString type:\n     /// http://www.graphviz.org/content/attrs#kescString\n@@ -303,7 +300,7 @@ pub enum LabelText<'a> {\n     /// to break a line (centering the line preceding the `\\n`), there\n     /// are also the escape sequences `\\l` which left-justifies the\n     /// preceding line and `\\r` which right-justifies it.\n-    EscStr(CowString<'a>),\n+    EscStr(Cow<'a, str>),\n }\n \n // There is a tension in the design of the labelling API.\n@@ -340,7 +337,7 @@ pub enum LabelText<'a> {\n \n /// `Id` is a Graphviz `ID`.\n pub struct Id<'a> {\n-    name: CowString<'a>,\n+    name: Cow<'a, str>,\n }\n \n impl<'a> Id<'a> {\n@@ -358,7 +355,7 @@ impl<'a> Id<'a> {\n     ///\n     /// Passing an invalid string (containing spaces, brackets,\n     /// quotes, ...) will return an empty `Err` value.\n-    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Result<Id<'a>, ()> {\n+    pub fn new<Name: IntoCow<'a, str>>(name: Name) -> Result<Id<'a>, ()> {\n         let name = name.into_cow();\n         {\n             let mut chars = name.chars();\n@@ -387,7 +384,7 @@ impl<'a> Id<'a> {\n         &*self.name\n     }\n \n-    pub fn name(self) -> CowString<'a> {\n+    pub fn name(self) -> Cow<'a, str> {\n         self.name\n     }\n }\n@@ -427,11 +424,11 @@ pub trait Labeller<'a,N,E> {\n }\n \n impl<'a> LabelText<'a> {\n-    pub fn label<S:IntoCow<'a, String, str>>(s: S) -> LabelText<'a> {\n+    pub fn label<S:IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n         LabelStr(s.into_cow())\n     }\n \n-    pub fn escaped<S:IntoCow<'a, String, str>>(s: S) -> LabelText<'a> {\n+    pub fn escaped<S:IntoCow<'a, str>>(s: S) -> LabelText<'a> {\n         EscStr(s.into_cow())\n     }\n \n@@ -455,15 +452,15 @@ impl<'a> LabelText<'a> {\n     pub fn escape(&self) -> String {\n         match self {\n             &LabelStr(ref s) => s.escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(&s[]),\n+            &EscStr(ref s) => LabelText::escape_str(&s[..]),\n         }\n     }\n \n     /// Decomposes content into string suitable for making EscStr that\n     /// yields same content as self.  The result obeys the law\n     /// render(`lt`) == render(`EscStr(lt.pre_escaped_content())`) for\n     /// all `lt: LabelText`.\n-    fn pre_escaped_content(self) -> CowString<'a> {\n+    fn pre_escaped_content(self) -> Cow<'a, str> {\n         match self {\n             EscStr(s) => s,\n             LabelStr(s) => if s.contains_char('\\\\') {\n@@ -484,13 +481,13 @@ impl<'a> LabelText<'a> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n-        prefix.push_str(&suffix[]);\n+        prefix.push_str(&suffix[..]);\n         EscStr(prefix.into_cow())\n     }\n }\n \n-pub type Nodes<'a,N> = CowVec<'a,N>;\n-pub type Edges<'a,E> = CowVec<'a,E>;\n+pub type Nodes<'a,N> = Cow<'a,[N]>;\n+pub type Edges<'a,E> = Cow<'a,[E]>;\n \n // (The type parameters in GraphWalk should be associated items,\n // when/if Rust supports such.)\n@@ -678,7 +675,7 @@ mod tests {\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(&self.name[]).unwrap()\n+            Id::new(&self.name[..]).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)"}, {"sha": "c2c7f20ce9cdfcff7ead7cf1f79caaf23ff2962e", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -287,7 +287,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !args.to_string().contains(&filter[]) => return,\n+        Some(filter) if !args.to_string().contains(&filter[..]) => return,\n         _ => {}\n     }\n \n@@ -382,7 +382,7 @@ fn enabled(level: u32,\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(&name[]) => {},\n+            Some(ref name) if !module.starts_with(&name[..]) => {},\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -397,7 +397,7 @@ fn enabled(level: u32,\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n     let (mut directives, filter) = match env::var(\"RUST_LOG\") {\n-        Ok(spec) => directive::parse_logging_spec(&spec[]),\n+        Ok(spec) => directive::parse_logging_spec(&spec[..]),\n         Err(..) => (Vec::new(), None),\n     };\n "}, {"sha": "5a85552dc384eb10536faa8520621827fe5416cd", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -21,6 +21,7 @@\n \n use core::prelude::*;\n use core::num::{Float, Int};\n+use core::marker::PhantomData;\n \n use {Rng, Rand};\n \n@@ -56,7 +57,13 @@ pub trait IndependentSample<Support>: Sample<Support> {\n \n /// A wrapper for generating types that implement `Rand` via the\n /// `Sample` & `IndependentSample` traits.\n-pub struct RandSample<Sup>;\n+pub struct RandSample<Sup> { _marker: PhantomData<Sup> }\n+\n+impl<Sup> RandSample<Sup> {\n+    pub fn new() -> RandSample<Sup> {\n+        RandSample { _marker: PhantomData }\n+    }\n+}\n \n impl<Sup: Rand> Sample<Sup> for RandSample<Sup> {\n     fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }\n@@ -285,7 +292,7 @@ mod tests {\n \n     #[test]\n     fn test_rand_sample() {\n-        let mut rand_sample = RandSample::<ConstRand>;\n+        let mut rand_sample = RandSample::<ConstRand>::new();\n \n         assert_eq!(rand_sample.sample(&mut ::test::rng()), ConstRand(0));\n         assert_eq!(rand_sample.ind_sample(&mut ::test::rng()), ConstRand(0));"}, {"sha": "701749ff3443f6e0280ad1308001854ea645cfe2", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -215,7 +215,7 @@ impl<'a> SeedableRng<&'a [u32]> for IsaacRng {\n     fn reseed(&mut self, seed: &'a [u32]) {\n         // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n         // - 1], 0, 0, ...], to fill rng.rsl.\n-        let seed_iter = seed.iter().map(|&x| x).chain(repeat(0u32));\n+        let seed_iter = seed.iter().cloned().chain(repeat(0u32));\n \n         for (rsl_elem, seed_elem) in self.rsl.iter_mut().zip(seed_iter) {\n             *rsl_elem = seed_elem;\n@@ -458,7 +458,7 @@ impl<'a> SeedableRng<&'a [u64]> for Isaac64Rng {\n     fn reseed(&mut self, seed: &'a [u64]) {\n         // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n         // - 1], 0, 0, ...], to fill rng.rsl.\n-        let seed_iter = seed.iter().map(|&x| x).chain(repeat(0u64));\n+        let seed_iter = seed.iter().cloned().chain(repeat(0u64));\n \n         for (rsl_elem, seed_elem) in self.rsl.iter_mut().zip(seed_iter) {\n             *rsl_elem = seed_elem;"}, {"sha": "7588bf7c5158e7f27114784bbe2d025ec8dbfdbe", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -41,6 +41,7 @@ extern crate core;\n #[cfg(test)] #[macro_use] extern crate log;\n \n use core::prelude::*;\n+use core::marker::PhantomData;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n pub use chacha::ChaChaRng;\n@@ -206,7 +207,7 @@ pub trait Rng : Sized {\n     ///                     .collect::<Vec<(f64, bool)>>());\n     /// ```\n     fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self> {\n-        Generator { rng: self }\n+        Generator { rng: self, _marker: PhantomData }\n     }\n \n     /// Generate a random value in the range [`low`, `high`).\n@@ -317,6 +318,7 @@ pub trait Rng : Sized {\n /// This iterator is created via the `gen_iter` method on `Rng`.\n pub struct Generator<'a, T, R:'a> {\n     rng: &'a mut R,\n+    _marker: PhantomData<T>\n }\n \n impl<'a, T: Rand, R: Rng> Iterator for Generator<'a, T, R> {"}, {"sha": "dc81e89902bb4c093b42d8c65386c7707777510f", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -37,7 +37,7 @@ use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n use lint::{Level, Context, LintPass, LintArray, Lint};\n \n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n use std::{cmp, slice};\n@@ -508,7 +508,7 @@ impl BoxPointers {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(BOX_POINTERS, span, &m[]);\n+            cx.span_lint(BOX_POINTERS, span, &m[..]);\n         }\n     }\n }\n@@ -736,7 +736,7 @@ impl LintPass for UnusedResults {\n                     }\n                 } else {\n                     let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n-                    warned |= check_must_use(cx, &attrs[], s.span);\n+                    warned |= check_must_use(cx, &attrs[..], s.span);\n                 }\n             }\n             _ => {}\n@@ -803,7 +803,7 @@ impl NonCamelCaseTypes {\n             } else {\n                 format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n             };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[]);\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n         }\n     }\n }\n@@ -950,7 +950,7 @@ impl NonSnakeCase {\n \n         if !is_snake_case(ident) {\n             let sc = NonSnakeCase::to_snake_case(&s);\n-            if sc != &s[] {\n+            if sc != &s[..] {\n                 cx.span_lint(NON_SNAKE_CASE, span,\n                     &*format!(\"{} `{}` should have a snake case name such as `{}`\",\n                             sort, s, sc));\n@@ -1033,7 +1033,7 @@ impl NonUpperCaseGlobals {\n         if s.chars().any(|c| c.is_lowercase()) {\n             let uc: String = NonSnakeCase::to_snake_case(&s).chars()\n                                            .map(|c| c.to_uppercase()).collect();\n-            if uc != &s[] {\n+            if uc != &s[..] {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n                     &format!(\"{} `{}` should have an upper case name such as `{}`\",\n                              sort, s, uc));\n@@ -1196,7 +1196,7 @@ impl LintPass for UnusedImportBraces {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     &token::get_ident(*name));\n                                     cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n-                                                 &m[]);\n+                                                 &m[..]);\n                                 },\n                                 _ => ()\n                             }\n@@ -1474,7 +1474,7 @@ impl LintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(&l[], \"hidden\"),\n+                Some(l) => attr::contains_name(&l[..], \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -1702,7 +1702,7 @@ impl Stability {\n                 _ => format!(\"use of {} item\", label)\n             };\n \n-            cx.span_lint(lint, span, &msg[]);\n+            cx.span_lint(lint, span, &msg[..]);\n         }\n     }\n }\n@@ -1791,7 +1791,7 @@ impl LintPass for UnconditionalRecursion {\n         let mut work_queue = vec![cfg.entry];\n         let mut reached_exit_without_self_call = false;\n         let mut self_call_spans = vec![];\n-        let mut visited = BitvSet::new();\n+        let mut visited = BitSet::new();\n \n         while let Some(idx) = work_queue.pop() {\n             let cfg_id = idx.node_id();"}, {"sha": "068c179d3431fe7c18087fd92dd1dc7a9a475f54", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -125,11 +125,11 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(&msg[]),\n-                    (Some(sess), false) => sess.bug(&msg[]),\n+                    (None, _) => early_error(&msg[..]),\n+                    (Some(sess), false) => sess.bug(&msg[..]),\n \n                     // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(&msg[]),\n+                    (Some(sess), true)  => sess.err(&msg[..]),\n                 }\n             }\n \n@@ -150,11 +150,11 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(&msg[]),\n-                (Some(sess), false) => sess.bug(&msg[]),\n+                (None, _) => early_error(&msg[..]),\n+                (Some(sess), false) => sess.bug(&msg[..]),\n \n                 // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(&msg[]),\n+                (Some(sess), true)  => sess.err(&msg[..]),\n             }\n         }\n     }\n@@ -251,8 +251,8 @@ impl LintStore {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n                                       lint_name, new_name);\n                 match span {\n-                    Some(span) => sess.span_warn(span, &warning[]),\n-                    None => sess.warn(&warning[]),\n+                    Some(span) => sess.span_warn(span, &warning[..]),\n+                    None => sess.warn(&warning[..]),\n                 };\n                 Some(lint_id)\n             }\n@@ -262,13 +262,13 @@ impl LintStore {\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            match self.find_lint(&lint_name[], sess, None) {\n+            match self.find_lint(&lint_name[..], sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .get(&lint_name[]) {\n+                                                 .get(&lint_name[..]) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n@@ -411,15 +411,15 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     if level == Forbid { level = Deny; }\n \n     match (level, span) {\n-        (Warn, Some(sp)) => sess.span_warn(sp, &msg[]),\n-        (Warn, None)     => sess.warn(&msg[]),\n-        (Deny, Some(sp)) => sess.span_err(sp, &msg[]),\n-        (Deny, None)     => sess.err(&msg[]),\n+        (Warn, Some(sp)) => sess.span_warn(sp, &msg[..]),\n+        (Warn, None)     => sess.warn(&msg[..]),\n+        (Deny, Some(sp)) => sess.span_err(sp, &msg[..]),\n+        (Deny, None)     => sess.err(&msg[..]),\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n     if let Some(note) = note {\n-        sess.note(&note[]);\n+        sess.note(&note[..]);\n     }\n \n     if let Some(span) = def {\n@@ -503,7 +503,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     match self.lints.find_lint(&lint_name, &self.tcx.sess, Some(span)) {\n                         Some(lint_id) => vec![(lint_id, level, span)],\n                         None => {\n-                            match self.lints.lint_groups.get(&lint_name[]) {\n+                            match self.lints.lint_groups.get(&lint_name[..]) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n@@ -729,7 +729,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints {\n-                    self.span_lint(lint_id.lint, span, &msg[])\n+                    self.span_lint(lint_id.lint, span, &msg[..])\n                 }\n             }\n         }"}, {"sha": "bdcc10ebceca061899bf93a64540a42c37de4253", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -185,12 +185,20 @@ impl PartialEq for LintId {\n \n impl Eq for LintId { }\n \n+#[cfg(stage0)]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for LintId {\n     fn hash(&self, state: &mut S) {\n         let ptr = self.lint as *const Lint;\n         ptr.hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+impl hash::Hash for LintId {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        let ptr = self.lint as *const Lint;\n+        ptr.hash(state);\n+    }\n+}\n \n impl LintId {\n     /// Get the `LintId` for a `Lint`."}, {"sha": "d48a404176ace37d2727925a3fd958ea309f32c4", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -183,7 +183,7 @@ impl<'a> CrateReader<'a> {\n                 let name = match *path_opt {\n                     Some((ref path_str, _)) => {\n                         let name = path_str.to_string();\n-                        validate_crate_name(Some(self.sess), &name[],\n+                        validate_crate_name(Some(self.sess), &name[..],\n                                             Some(i.span));\n                         name\n                     }\n@@ -321,7 +321,7 @@ impl<'a> CrateReader<'a> {\n             let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n             if let Some(locs) = self.sess.opts.externs.get(name) {\n                 let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(&l[])).ok();\n+                    let l = fs::realpath(&Path::new(&l[..])).ok();\n                     source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n                     source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n                 });\n@@ -459,8 +459,8 @@ impl<'a> CrateReader<'a> {\n         let mut load_ctxt = loader::Context {\n             sess: self.sess,\n             span: span,\n-            ident: &ident[],\n-            crate_name: &name[],\n+            ident: &ident[..],\n+            crate_name: &name[..],\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n@@ -562,7 +562,7 @@ impl<'a> CrateReader<'a> {\n                                   name,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(span, &message[]);\n+            self.sess.span_err(span, &message[..]);\n             self.sess.abort_if_errors();\n         }\n \n@@ -575,7 +575,7 @@ impl<'a> CrateReader<'a> {\n                 let message = format!(\"plugin `{}` only found in rlib format, \\\n                                        but must be available in dylib format\",\n                                        name);\n-                self.sess.span_err(span, &message[]);\n+                self.sess.span_err(span, &message[..]);\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None"}, {"sha": "a3f7d57da67486b39a976a8289743612960ef5b4", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -139,8 +139,7 @@ impl CStore {\n     pub fn get_used_crate_source(&self, cnum: ast::CrateNum)\n                                      -> Option<CrateSource> {\n         self.used_crate_sources.borrow_mut()\n-            .iter().find(|source| source.cnum == cnum)\n-            .map(|source| source.clone())\n+            .iter().find(|source| source.cnum == cnum).cloned()\n     }\n \n     pub fn reset(&self) {\n@@ -218,7 +217,7 @@ impl CStore {\n \n     pub fn find_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId)\n                                      -> Option<ast::CrateNum> {\n-        self.extern_mod_crate_map.borrow().get(&emod_id).map(|x| *x)\n+        self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n }\n "}, {"sha": "42a70cec5dfee08903c604b672a124e0e4aef4da", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -163,7 +163,7 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(&s[]);\n+    rbml_w.wr_str(&s[..]);\n     rbml_w.end_tag();\n }\n \n@@ -353,9 +353,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n-                                                 &fields[],\n+                                                 &fields[..],\n                                                  index);\n-                encode_struct_fields(rbml_w, &fields[], def_id);\n+                encode_struct_fields(rbml_w, &fields[..], def_id);\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n@@ -1158,7 +1158,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          rbml_w,\n-                                         &fields[],\n+                                         &fields[..],\n                                          index);\n \n         /* Index the class*/\n@@ -1181,7 +1181,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, &fields[], def_id);\n+        encode_struct_fields(rbml_w, &fields[..], def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n \n@@ -1588,6 +1588,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n // Path and definition ID indexing\n \n+#[cfg(stage0)]\n fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n     F: FnMut(&mut SeekableMemWriter, &T),\n     T: Hash<SipHasher>,\n@@ -1628,6 +1629,47 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n+#[cfg(not(stage0))]\n+fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n+    F: FnMut(&mut SeekableMemWriter, &T),\n+    T: Hash,\n+{\n+    let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n+    for elt in index {\n+        let mut s = SipHasher::new();\n+        elt.val.hash(&mut s);\n+        let h = s.finish() as uint;\n+        (&mut buckets[h % 256]).push(elt);\n+    }\n+\n+    rbml_w.start_tag(tag_index);\n+    let mut bucket_locs = Vec::new();\n+    rbml_w.start_tag(tag_index_buckets);\n+    for bucket in &buckets {\n+        bucket_locs.push(rbml_w.writer.tell().unwrap());\n+        rbml_w.start_tag(tag_index_buckets_bucket);\n+        for elt in bucket {\n+            rbml_w.start_tag(tag_index_buckets_bucket_elt);\n+            assert!(elt.pos < 0xffff_ffff);\n+            {\n+                let wr: &mut SeekableMemWriter = rbml_w.writer;\n+                wr.write_be_u32(elt.pos as u32);\n+            }\n+            write_fn(rbml_w.writer, &elt.val);\n+            rbml_w.end_tag();\n+        }\n+        rbml_w.end_tag();\n+    }\n+    rbml_w.end_tag();\n+    rbml_w.start_tag(tag_index_table);\n+    for pos in &bucket_locs {\n+        assert!(*pos < 0xffff_ffff);\n+        let wr: &mut SeekableMemWriter = rbml_w.writer;\n+        wr.write_be_u32(*pos as u32);\n+    }\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n+}\n \n fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n     let wr: &mut SeekableMemWriter = writer;"}, {"sha": "01d1f4e7011f8586c7196884fc851e35ee039d1c", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -322,7 +322,7 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\"{} which `{}` depends on\",\n                                     message, r.ident)\n         };\n-        self.sess.span_err(self.span, &message[]);\n+        self.sess.span_err(self.span, &message[..]);\n \n         if self.rejected_via_triple.len() > 0 {\n             let mismatches = self.rejected_via_triple.iter();\n@@ -404,7 +404,7 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(&rlib_prefix[]) &&\n+            let (hash, rlib) = if file.starts_with(&rlib_prefix[..]) &&\n                                   file.ends_with(\".rlib\") {\n                 (&file[(rlib_prefix.len()) .. (file.len() - \".rlib\".len())],\n                  true)\n@@ -413,7 +413,7 @@ impl<'a> Context<'a> {\n                 (&file[(dylib_prefix.len()) .. (file.len() - dypair.1.len())],\n                  false)\n             } else {\n-                if file.starts_with(&staticlib_prefix[]) &&\n+                if file.starts_with(&staticlib_prefix[..]) &&\n                    file.ends_with(\".a\") {\n                     staticlibs.push(CrateMismatch {\n                         path: path.clone(),\n@@ -627,7 +627,7 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashMap::new();\n         let mut dylibs = HashMap::new();\n         {\n-            let locs = locs.iter().map(|l| Path::new(&l[])).filter(|loc| {\n+            let locs = locs.iter().map(|l| Path::new(&l[..])).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n                                      self.crate_name, loc.display())[]);\n@@ -645,8 +645,8 @@ impl<'a> Context<'a> {\n                     return true\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(&prefix[]) &&\n-                       file.ends_with(&suffix[]) {\n+                    if file.starts_with(&prefix[..]) &&\n+                       file.ends_with(&suffix[..]) {\n                         return true\n                     }\n                 }\n@@ -744,7 +744,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n         }\n     }\n     unsafe {\n-        let buf = CString::from_slice(filename.as_vec());\n+        let buf = CString::new(filename.as_vec()).unwrap();\n         let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n         if mb as int == 0 {\n             return Err(format!(\"error reading library: '{}'\","}, {"sha": "5805725a8fc8b7cb6ad2f37651f437f33278182b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -641,7 +641,7 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n         let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(&abi_str[]).expect(abi_str)\n+        abi::lookup(&abi_str[..]).expect(abi_str)\n     })\n }\n "}, {"sha": "ae10eb686b010244ed71bcdf07de52c2d93616e6", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -134,7 +134,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             // Do an Option dance to use the path after it is moved below.\n             let s = ast_map::path_to_string(path.iter().cloned());\n             path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| &x[])\n+            path_as_str.as_ref().map(|x| &x[..])\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();"}, {"sha": "46b4a51c9d6fee7b00295727dbd71d600698cf47", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = replace_newline_with_backslash_l(s);\n             label.push_str(&format!(\"exiting scope_{} {}\",\n                                    i,\n-                                   &s[])[]);\n+                                   &s[..])[]);\n         }\n         dot::LabelText::EscStr(label.into_cow())\n     }"}, {"sha": "86c59b24e3e933663ed2100f3d5ede07fe3dc82a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -25,7 +25,7 @@ use middle::ty::*;\n use middle::ty;\n use std::cmp::Ordering;\n use std::fmt;\n-use std::iter::{range_inclusive, AdditiveIterator, FromIterator, repeat};\n+use std::iter::{range_inclusive, AdditiveIterator, FromIterator, IntoIterator, repeat};\n use std::num::Float;\n use std::slice;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId, Pat};\n@@ -76,7 +76,7 @@ impl<'a> fmt::Debug for Matrix<'a> {\n             pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n         }).collect();\n \n-        let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n+        let total_width = column_widths.iter().cloned().sum() + column_count * 3 + 1;\n         let br = repeat('+').take(total_width).collect::<String>();\n         try!(write!(f, \"{}\\n\", br));\n         for row in pretty_printed_matrix {\n@@ -94,8 +94,8 @@ impl<'a> fmt::Debug for Matrix<'a> {\n }\n \n impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n-    fn from_iter<T: Iterator<Item=Vec<&'a Pat>>>(iterator: T) -> Matrix<'a> {\n-        Matrix(iterator.collect())\n+    fn from_iter<T: IntoIterator<Item=Vec<&'a Pat>>>(iter: T) -> Matrix<'a> {\n+        Matrix(iter.into_iter().collect())\n     }\n }\n \n@@ -200,7 +200,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, &inlined_arms[], source);\n+            check_arms(cx, &inlined_arms[..], source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -291,7 +291,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n         for pat in pats {\n             let v = vec![&**pat];\n \n-            match is_useful(cx, &seen, &v[], LeaveOutWitness) {\n+            match is_useful(cx, &seen, &v[..], LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n                         ast::MatchSource::IfLetDesugar { .. } => {\n@@ -351,7 +351,7 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast::MatchSource) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let witness = match &pats[] {\n+            let witness = match &pats[..] {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n@@ -360,7 +360,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast:\n                 ast::MatchSource::ForLoopDesugar => {\n                     // `witness` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witness.node {\n-                        ast::PatEnum(_, Some(ref pats)) => match &pats[] {\n+                        ast::PatEnum(_, Some(ref pats)) => match &pats[..] {\n                             [ref pat] => &**pat,\n                             _ => unreachable!(),\n                         },\n@@ -664,7 +664,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n-                                let pat_slice = &pats[];\n+                                let pat_slice = &pats[..];\n                                 let subpats: Vec<_> = (0..arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 }).collect();\n@@ -711,10 +711,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, &r[], &ctor, 0, arity)\n+        specialize(cx, &r[..], &ctor, 0, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0, arity) {\n-        Some(v) => is_useful(cx, &matrix, &v[], witness),\n+        Some(v) => is_useful(cx, &matrix, &v[..], witness),\n         None => NotUseful\n     }\n }"}, {"sha": "5bf7422dbc0d41ce7051d5a801238c4d4a28b12f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -62,7 +62,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n-                    variant_expr(&variants[], variant_def.node)\n+                    variant_expr(&variants[..], variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -83,7 +83,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n-                    variant_expr(&variants[], variant_def.node).map(|e| e.id)\n+                    variant_expr(&variants[..], variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n@@ -209,7 +209,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e, None) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, &s[])\n+        Err(s) => tcx.sess.span_fatal(e.span, &s[..])\n     }\n }\n \n@@ -501,7 +501,7 @@ fn lit_to_const(lit: &ast::Lit, ty_hint: Option<Ty>) -> const_val {\n     match lit.node {\n         ast::LitStr(ref s, _) => const_str((*s).clone()),\n         ast::LitBinary(ref data) => {\n-            const_binary(Rc::new(data.iter().map(|x| *x).collect()))\n+            const_binary(data.clone())\n         }\n         ast::LitByte(n) => const_uint(n as u64),\n         ast::LitChar(n) => const_uint(n as u64),\n@@ -552,14 +552,14 @@ pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let a = match eval_const_expr_partial(tcx, a, ty_hint) {\n         Ok(a) => a,\n         Err(s) => {\n-            tcx.sess.span_err(a.span, &s[]);\n+            tcx.sess.span_err(a.span, &s[..]);\n             return None;\n         }\n     };\n     let b = match eval_const_expr_partial(tcx, b, ty_hint) {\n         Ok(b) => b,\n         Err(s) => {\n-            tcx.sess.span_err(b.span, &s[]);\n+            tcx.sess.span_err(b.span, &s[..]);\n             return None;\n         }\n     };"}, {"sha": "085d5cbc347e5b015801586b7756c1f2acce7b67", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -89,7 +89,7 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n }\n \n fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n-    let opt_cfgindex = index.get(&id).map(|&i|i);\n+    let opt_cfgindex = index.get(&id).cloned();\n     opt_cfgindex.unwrap_or_else(|| {\n         panic!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n     })\n@@ -312,7 +312,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let mut t = on_entry.to_vec();\n                 self.apply_gen_kill(cfgidx, &mut t);\n                 temp_bits = t;\n-                &temp_bits[]\n+                &temp_bits[..]\n             }\n         };\n         debug!(\"{} each_bit_for_node({:?}, cfgidx={:?}) bits={}\",\n@@ -400,7 +400,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n             let mut changed = false;\n             for &node_id in &edge.data.exiting_scopes {\n-                let opt_cfg_idx = self.nodeid_to_index.get(&node_id).map(|&i|i);\n+                let opt_cfg_idx = self.nodeid_to_index.get(&node_id).cloned();\n                 match opt_cfg_idx {\n                     Some(cfg_idx) => {\n                         let (start, end) = self.compute_id_range(cfg_idx);\n@@ -421,7 +421,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let bits = &mut self.kills[start.. end];\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.clone_from_slice(&orig_kills[]);\n+                bits.clone_from_slice(&orig_kills[..]);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }"}, {"sha": "ff78deb8d12ea6ba945531b6c34f0762b38a2ee6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -321,7 +321,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     for attr in lint::gather_attrs(attrs) {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n-                if &name[] == dead_code => return true,\n+                if &name[..] == dead_code => return true,\n             _ => (),\n         }\n     }"}, {"sha": "ad9f4eade5c90d25538240080640f300aace049a", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -158,7 +158,7 @@ fn calculate_type(sess: &session::Session,\n \n     // Collect what we've got so far in the return vector.\n     let mut ret = (1..sess.cstore.next_crate_num()).map(|i| {\n-        match formats.get(&i).map(|v| *v) {\n+        match formats.get(&i).cloned() {\n             v @ Some(cstore::RequireDynamic) => v,\n             _ => None,\n         }"}, {"sha": "e99d214742a0b668b40becf51bccafc8c387022b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -29,7 +29,6 @@ use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::ty::{MethodStatic, MethodStaticClosure};\n use util::ppaux::Repr;\n \n-use std::marker;\n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n use syntax::codemap::Span;\n@@ -128,16 +127,14 @@ pub enum MatchMode {\n     MovingMatch,\n }\n \n-#[derive(PartialEq,Debug)]\n-enum TrackMatchMode<T> {\n+#[derive(Copy, PartialEq, Debug)]\n+enum TrackMatchMode {\n     Unknown,\n     Definite(MatchMode),\n     Conflicting,\n }\n \n-impl<T> marker::Copy for TrackMatchMode<T> {}\n-\n-impl<T> TrackMatchMode<T> {\n+impl TrackMatchMode {\n     // Builds up the whole match mode for a pattern from its constituent\n     // parts.  The lattice looks like this:\n     //\n@@ -931,7 +928,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         return true;\n     }\n \n-    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) -> TrackMatchMode<Span> {\n+    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) -> TrackMatchMode {\n         let mut mode = Unknown;\n         for pat in &arm.pats {\n             self.determine_pat_move_mode(discr_cmt.clone(), &**pat, &mut mode);\n@@ -966,7 +963,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn determine_pat_move_mode(&mut self,\n                                cmt_discr: mc::cmt<'tcx>,\n                                pat: &ast::Pat,\n-                               mode: &mut TrackMatchMode<Span>) {\n+                               mode: &mut TrackMatchMode) {\n         debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n@@ -1166,7 +1163,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                 let msg = format!(\"Pattern has unexpected def: {:?} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n-                                tcx.sess.span_bug(pat.span, &msg[])\n+                                tcx.sess.span_bug(pat.span, &msg[..])\n                             }\n                         }\n                     }"}, {"sha": "436f04fc9e9cf9744f7d484757c9022146e47883", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -34,7 +34,7 @@\n \n use std::fmt::{Formatter, Error, Debug};\n use std::usize;\n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n \n pub struct Graph<N,E> {\n     nodes: Vec<Node<N>> ,\n@@ -292,15 +292,15 @@ impl<N,E> Graph<N,E> {\n         DepthFirstTraversal {\n             graph: self,\n             stack: vec![start],\n-            visited: BitvSet::new()\n+            visited: BitSet::new()\n         }\n     }\n }\n \n pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitvSet\n+    visited: BitSet\n }\n \n impl<'g, N, E> Iterator for DepthFirstTraversal<'g, N, E> {"}, {"sha": "93c80fb754f71f8d83db96d9c1b058b326926d22", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Applies the \"bivariance relationship\" to two types and/or regions.\n+//! If (A,B) are bivariant then either A <: B or B <: A. It occurs\n+//! when type/lifetime parameters are unconstrained. Usually this is\n+//! an error, but we permit it in the specific case where a type\n+//! parameter is constrained in a where-clause via an associated type.\n+//!\n+//! There are several ways one could implement bivariance. You could\n+//! just do nothing at all, for example, or you could fully verify\n+//! that one of the two subtyping relationships hold. We choose to\n+//! thread a middle line: we relate types up to regions, but ignore\n+//! all region relationships.\n+//!\n+//! At one point, handling bivariance in this fashion was necessary\n+//! for inference, but I'm actually not sure if that is true anymore.\n+//! In particular, it might be enough to say (A,B) are bivariant for\n+//! all (A,B).\n+\n+use middle::ty::{BuiltinBounds};\n+use middle::ty::{self, Ty};\n+use middle::ty::TyVar;\n+use middle::infer::combine::*;\n+use middle::infer::{cres};\n+use middle::infer::type_variable::{BiTo};\n+use util::ppaux::{Repr};\n+\n+use syntax::ast::{Unsafety};\n+\n+pub struct Bivariate<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn Bivariate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Bivariate<'f, 'tcx> {\n+    Bivariate { fields: cf }\n+}\n+\n+impl<'f, 'tcx> Combine<'tcx> for Bivariate<'f, 'tcx> {\n+    fn tag(&self) -> String { \"Bivariate\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Contravariant => self.tys(a, b),\n+            ty::Bivariant => self.tys(a, b),\n+        }\n+    }\n+\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Contravariant => self.regions(a, b),\n+            ty::Bivariant => self.regions(a, b),\n+        }\n+    }\n+\n+    fn regions(&self, a: ty::Region, _: ty::Region) -> cres<'tcx, ty::Region> {\n+        Ok(a)\n+    }\n+\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n+        debug!(\"mts({} <: {})\",\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+\n+        if a.mutbl != b.mutbl { return Err(ty::terr_mutability); }\n+        let t = try!(self.tys(a.ty, b.ty));\n+        Ok(ty::mt { mutbl: a.mutbl, ty: t })\n+    }\n+\n+    fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n+        if a != b {\n+            Err(ty::terr_unsafety_mismatch(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn builtin_bounds(&self,\n+                      a: BuiltinBounds,\n+                      b: BuiltinBounds)\n+                      -> cres<'tcx, BuiltinBounds>\n+    {\n+        if a != b {\n+            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({}, {})\", self.tag(),\n+               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+        if a == b { return Ok(a); }\n+\n+        let infcx = self.fields.infcx;\n+        let a = infcx.type_variables.borrow().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow().replace_if_possible(b);\n+        match (&a.sty, &b.sty) {\n+            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n+                infcx.type_variables.borrow_mut().relate_vars(a_id, BiTo, b_id);\n+                Ok(a)\n+            }\n+\n+            (&ty::ty_infer(TyVar(a_id)), _) => {\n+                try!(self.fields.instantiate(b, BiTo, a_id));\n+                Ok(a)\n+            }\n+\n+            (_, &ty::ty_infer(TyVar(b_id))) => {\n+                try!(self.fields.instantiate(a, BiTo, b_id));\n+                Ok(a)\n+            }\n+\n+            _ => {\n+                super_tys(self, a, b)\n+            }\n+        }\n+    }\n+\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n+        let a1 = ty::erase_late_bound_regions(self.tcx(), a);\n+        let b1 = ty::erase_late_bound_regions(self.tcx(), b);\n+        let c = try!(Combineable::combine(self, &a1, &b1));\n+        Ok(ty::Binder(c))\n+    }\n+}"}, {"sha": "0eeafb767d8a625d2792a3c393f4888aec8cf68c", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 76, "deletions": 70, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -32,14 +32,15 @@\n // is also useful to track which value is the \"expected\" value in\n // terms of error reporting.\n \n+use super::bivariate::Bivariate;\n use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n use super::{InferCtxt, cres};\n use super::{MiscVariable, TypeTrace};\n-use super::type_variable::{RelationDir, EqTo, SubtypeOf, SupertypeOf};\n+use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n use middle::subst;\n use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n@@ -48,7 +49,7 @@ use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n use middle::ty_fold;\n-use middle::ty_fold::{TypeFoldable};\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n@@ -58,48 +59,44 @@ use syntax::abi;\n use syntax::codemap::Span;\n \n pub trait Combine<'tcx> : Sized {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n     fn tag(&self) -> String;\n-    fn a_is_expected(&self) -> bool;\n-    fn trace(&self) -> TypeTrace<'tcx>;\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx>;\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx>;\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx>;\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx>;\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx>;\n+\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields().infcx }\n+    fn a_is_expected(&self) -> bool { self.fields().a_is_expected }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields().trace.clone() }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { self.fields().equate() }\n+    fn bivariate<'a>(&'a self) -> Bivariate<'a, 'tcx> { self.fields().bivariate() }\n+\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { self.fields().sub() }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields().clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields().clone()) }\n \n     fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>>;\n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n+\n+    fn tys_with_variance(&self, variance: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>;\n+\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n \n-    fn tps(&self,\n-           _: subst::ParamSpace,\n-           as_: &[Ty<'tcx>],\n-           bs: &[Ty<'tcx>])\n-           -> cres<'tcx, Vec<Ty<'tcx>>> {\n-        // FIXME -- In general, we treat variance a bit wrong\n-        // here. For historical reasons, we treat tps and Self\n-        // as invariant. This is overly conservative.\n-\n-        if as_.len() != bs.len() {\n-            return Err(ty::terr_ty_param_size(expected_found(self,\n-                                                             as_.len(),\n-                                                             bs.len())));\n-        }\n+    fn regions_with_variance(&self, variance: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>;\n \n-        try!(as_.iter().zip(bs.iter())\n-                .map(|(a, b)| self.equate().tys(*a, *b))\n-                .collect::<cres<Vec<Ty>>>());\n-        Ok(as_.to_vec())\n-    }\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n \n     fn substs(&self,\n               item_def_id: ast::DefId,\n               a_subst: &subst::Substs<'tcx>,\n               b_subst: &subst::Substs<'tcx>)\n               -> cres<'tcx, subst::Substs<'tcx>>\n     {\n+        debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n+               item_def_id.repr(self.infcx().tcx),\n+               a_subst.repr(self.infcx().tcx),\n+               b_subst.repr(self.infcx().tcx));\n+\n         let variances = if self.infcx().tcx.variance_computed.get() {\n             Some(ty::item_variances(self.infcx().tcx, item_def_id))\n         } else {\n@@ -119,7 +116,8 @@ pub trait Combine<'tcx> : Sized {\n         for &space in &subst::ParamSpace::all() {\n             let a_tps = a_subst.types.get_slice(space);\n             let b_tps = b_subst.types.get_slice(space);\n-            let tps = try!(self.tps(space, a_tps, b_tps));\n+            let t_variances = variances.map(|v| v.types.get_slice(space));\n+            let tps = try!(relate_type_params(self, t_variances, a_tps, b_tps));\n             substs.types.replace(space, tps);\n         }\n \n@@ -132,20 +130,7 @@ pub trait Combine<'tcx> : Sized {\n                 for &space in &subst::ParamSpace::all() {\n                     let a_regions = a.get_slice(space);\n                     let b_regions = b.get_slice(space);\n-\n-                    let mut invariance = Vec::new();\n-                    let r_variances = match variances {\n-                        Some(variances) => {\n-                            variances.regions.get_slice(space)\n-                        }\n-                        None => {\n-                            for _ in a_regions {\n-                                invariance.push(ty::Invariant);\n-                            }\n-                            &invariance[]\n-                        }\n-                    };\n-\n+                    let r_variances = variances.map(|v| v.regions.get_slice(space));\n                     let regions = try!(relate_region_params(self,\n                                                             r_variances,\n                                                             a_regions,\n@@ -157,13 +142,34 @@ pub trait Combine<'tcx> : Sized {\n \n         return Ok(substs);\n \n+        fn relate_type_params<'tcx, C: Combine<'tcx>>(this: &C,\n+                                                      variances: Option<&[ty::Variance]>,\n+                                                      a_tys: &[Ty<'tcx>],\n+                                                      b_tys: &[Ty<'tcx>])\n+                                                      -> cres<'tcx, Vec<Ty<'tcx>>>\n+        {\n+            if a_tys.len() != b_tys.len() {\n+                return Err(ty::terr_ty_param_size(expected_found(this,\n+                                                                 a_tys.len(),\n+                                                                 b_tys.len())));\n+            }\n+\n+            range(0, a_tys.len()).map(|i| {\n+                let a_ty = a_tys[i];\n+                let b_ty = b_tys[i];\n+                let v = variances.map_or(ty::Invariant, |v| v[i]);\n+                this.tys_with_variance(v, a_ty, b_ty)\n+            }).collect()\n+        }\n+\n         fn relate_region_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                        variances: &[ty::Variance],\n+                                                        variances: Option<&[ty::Variance]>,\n                                                         a_rs: &[ty::Region],\n                                                         b_rs: &[ty::Region])\n-                                                        -> cres<'tcx, Vec<ty::Region>> {\n+                                                        -> cres<'tcx, Vec<ty::Region>>\n+        {\n             let tcx = this.infcx().tcx;\n-            let num_region_params = variances.len();\n+            let num_region_params = a_rs.len();\n \n             debug!(\"relate_region_params(\\\n                    a_rs={}, \\\n@@ -173,22 +179,18 @@ pub trait Combine<'tcx> : Sized {\n                    b_rs.repr(tcx),\n                    variances.repr(tcx));\n \n-            assert_eq!(num_region_params, a_rs.len());\n+            assert_eq!(num_region_params,\n+                       variances.map_or(num_region_params,\n+                                        |v| v.len()));\n+\n             assert_eq!(num_region_params, b_rs.len());\n-            let mut rs = vec!();\n-            for i in 0..num_region_params {\n+\n+            (0..a_rs.len()).map(|i| {\n                 let a_r = a_rs[i];\n                 let b_r = b_rs[i];\n-                let variance = variances[i];\n-                let r = match variance {\n-                    ty::Invariant => this.equate().regions(a_r, b_r),\n-                    ty::Covariant => this.regions(a_r, b_r),\n-                    ty::Contravariant => this.contraregions(a_r, b_r),\n-                    ty::Bivariant => Ok(a_r),\n-                };\n-                rs.push(try!(r));\n-            }\n-            Ok(rs)\n+                let variance = variances.map_or(ty::Invariant, |v| v[i]);\n+                this.regions_with_variance(variance, a_r, b_r)\n+            }).collect()\n         }\n     }\n \n@@ -241,7 +243,7 @@ pub trait Combine<'tcx> : Sized {\n     }\n \n     fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.contratys(a, b).and_then(|t| Ok(t))\n+        self.tys_with_variance(ty::Contravariant, a, b).and_then(|t| Ok(t))\n     }\n \n     fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety>;\n@@ -309,7 +311,7 @@ pub trait Combine<'tcx> : Sized {\n                           b: &ty::ExistentialBounds<'tcx>)\n                           -> cres<'tcx, ty::ExistentialBounds<'tcx>>\n     {\n-        let r = try!(self.contraregions(a.region_bound, b.region_bound));\n+        let r = try!(self.regions_with_variance(ty::Contravariant, a.region_bound, b.region_bound));\n         let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n         let pb = try!(self.projection_bounds(&a.projection_bounds, &b.projection_bounds));\n         Ok(ty::ExistentialBounds { region_bound: r,\n@@ -322,11 +324,6 @@ pub trait Combine<'tcx> : Sized {\n                       b: ty::BuiltinBounds)\n                       -> cres<'tcx, ty::BuiltinBounds>;\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                  -> cres<'tcx, ty::Region>;\n-\n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n-\n     fn trait_refs(&self,\n                   a: &ty::TraitRef<'tcx>,\n                   b: &ty::TraitRef<'tcx>)\n@@ -540,7 +537,8 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = try!(this.contraregions(*a_r, *b_r));\n+            let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n+\n             // FIXME(14985)  If we have mutable references to trait objects, we\n             // used to use covariant subtyping. I have preserved this behaviour,\n             // even though it is probably incorrect. So don't go down the usual\n@@ -644,6 +642,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n         Equate((*self).clone())\n     }\n \n+    fn bivariate(&self) -> Bivariate<'f, 'tcx> {\n+        Bivariate((*self).clone())\n+    }\n+\n     fn sub(&self) -> Sub<'f, 'tcx> {\n         Sub((*self).clone())\n     }\n@@ -697,7 +699,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                         EqTo => {\n                             self.generalize(a_ty, b_vid, false)\n                         }\n-                        SupertypeOf | SubtypeOf => {\n+                        BiTo | SupertypeOf | SubtypeOf => {\n                             self.generalize(a_ty, b_vid, true)\n                         }\n                     });\n@@ -721,6 +723,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n             match dir {\n+                BiTo => {\n+                    try!(self.bivariate().tys(a_ty, b_ty));\n+                }\n+\n                 EqTo => {\n                     try!(self.equate().tys(a_ty, b_ty));\n                 }\n@@ -730,7 +736,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                 }\n \n                 SupertypeOf => {\n-                    try!(self.sub().contratys(a_ty, b_ty));\n+                    try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty));\n                 }\n             }\n         }"}, {"sha": "7194e20b0cf655224c08530e4f569c158d197cab", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -13,11 +13,7 @@ use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n use middle::infer::combine::*;\n use middle::infer::{cres};\n-use middle::infer::glb::Glb;\n-use middle::infer::InferCtxt;\n-use middle::infer::lub::Lub;\n-use middle::infer::sub::Sub;\n-use middle::infer::{TypeTrace, Subtype};\n+use middle::infer::{Subtype};\n use middle::infer::type_variable::{EqTo};\n use util::ppaux::{Repr};\n \n@@ -33,21 +29,20 @@ pub fn Equate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Equate<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"eq\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n+    fn tag(&self) -> String { \"Equate\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n-\n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+    fn tys_with_variance(&self, _: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        // Once we're equating, it doesn't matter what the variance is.\n         self.tys(a, b)\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n+    fn regions_with_variance(&self, _: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        // Once we're equating, it doesn't matter what the variance is.\n         self.regions(a, b)\n     }\n "}, {"sha": "53032f9b9ac64ac512d673d0faece23d2bee32a9", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -200,9 +200,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ref trace_origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(&var_origins[],\n-                                                     &trace_origins[],\n-                                                     &same_regions[]);\n+                        self.report_processed_errors(&var_origins[..],\n+                                                     &trace_origins[..],\n+                                                     &same_regions[..]);\n                     }\n                 }\n             }\n@@ -675,6 +675,17 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     sup,\n                     \"\");\n             }\n+            infer::Operand(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of operand does not outlive \\\n+                     the operation\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the operand is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n             infer::AddrOf(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -824,7 +835,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let parent = self.tcx.map.get_parent(scope_id);\n         let parent_node = self.tcx.map.find(parent);\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(&taken[]);\n+        let life_giver = LifeGiver::with_taken(&taken[..]);\n         let node_inner = match parent_node {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n@@ -924,7 +935,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n     fn rebuild(&self)\n                -> (ast::FnDecl, Option<ast::ExplicitSelf_>, ast::Generics) {\n-        let mut expl_self_opt = self.expl_self_opt.map(|x| x.clone());\n+        let mut expl_self_opt = self.expl_self_opt.cloned();\n         let mut inputs = self.fn_decl.inputs.clone();\n         let mut output = self.fn_decl.output.clone();\n         let mut ty_params = self.generics.ty_params.clone();\n@@ -942,7 +953,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n             expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n                                                    &anon_nums, &region_names);\n-            inputs = self.rebuild_args_ty(&inputs[], lifetime,\n+            inputs = self.rebuild_args_ty(&inputs[..], lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n@@ -1426,7 +1437,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_help(span, &msg[]);\n+        self.tcx.sess.span_help(span, &msg[..]);\n     }\n \n     fn report_inference_failure(&self,\n@@ -1593,6 +1604,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"...so that return value is valid for the call\");\n             }\n+            infer::Operand(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"...so that operand is valid for operation\");\n+            }\n             infer::AddrOf(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n@@ -1771,7 +1787,7 @@ impl LifeGiver {\n             s.push_str(&num_to_string(self.counter.get())[]);\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n-                                    token::str_to_ident(&s[]).name);\n+                                    token::str_to_ident(&s[..]).name);\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "33303808e84910ebb7062c4bf9147451ee7aaecd", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -10,12 +10,9 @@\n \n use super::combine::*;\n use super::lattice::*;\n-use super::equate::Equate;\n use super::higher_ranked::HigherRankedRelations;\n-use super::lub::Lub;\n-use super::sub::Sub;\n-use super::{cres, InferCtxt};\n-use super::{TypeTrace, Subtype};\n+use super::{cres};\n+use super::Subtype;\n \n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n@@ -34,15 +31,30 @@ pub fn Glb<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Glb<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"glb\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n+    fn tag(&self) -> String { \"Glb\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Bivariant => self.bivariate().tys(a, b),\n+            ty::Contravariant => self.lub().tys(a, b),\n+        }\n+    }\n+\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Bivariant => self.bivariate().regions(a, b),\n+            ty::Contravariant => self.lub().regions(a, b),\n+        }\n+    }\n \n     fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.fields.infcx.tcx;\n@@ -75,10 +87,6 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.lub().tys(a, b)\n-    }\n-\n     fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n         match (a, b) {\n           (Unsafety::Normal, _) | (_, Unsafety::Normal) => Ok(Unsafety::Normal),\n@@ -104,11 +112,6 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         Ok(self.fields.infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<'tcx, ty::Region> {\n-        self.lub().regions(a, b)\n-    }\n-\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         super_lattice_tys(self, a, b)\n     }"}, {"sha": "a729156c88b3588e3d85e442d6878b6c526fcd15", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -31,7 +31,7 @@ pub trait HigherRankedRelations<'tcx> {\n         where T : Combineable<'tcx>;\n }\n \n-trait InferCtxtExt<'tcx> {\n+trait InferCtxtExt {\n     fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region>;\n \n     fn region_vars_confined_to_snapshot(&self,\n@@ -371,7 +371,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n     }))\n }\n \n-impl<'a,'tcx> InferCtxtExt<'tcx> for InferCtxt<'a,'tcx> {\n+impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n     fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n     }"}, {"sha": "3570effa9fa709ff2de3c304db15f75f6dd4d428", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -9,13 +9,10 @@\n // except according to those terms.\n \n use super::combine::*;\n-use super::equate::Equate;\n-use super::glb::Glb;\n use super::higher_ranked::HigherRankedRelations;\n use super::lattice::*;\n-use super::sub::Sub;\n-use super::{cres, InferCtxt};\n-use super::{TypeTrace, Subtype};\n+use super::{cres};\n+use super::{Subtype};\n \n use middle::ty::{BuiltinBounds};\n use middle::ty::{self, Ty};\n@@ -34,15 +31,30 @@ pub fn Lub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Lub<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"lub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n+    fn tag(&self) -> String { \"Lub\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n \n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Bivariant => self.bivariate().tys(a, b),\n+            ty::Contravariant => self.glb().tys(a, b),\n+        }\n+    }\n+\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Bivariant => self.bivariate().regions(a, b),\n+            ty::Contravariant => self.glb().regions(a, b),\n+        }\n+    }\n \n     fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.tcx();\n@@ -70,10 +82,6 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.glb().tys(a, b)\n-    }\n-\n     fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n         match (a, b) {\n           (Unsafety::Unsafe, _) | (_, Unsafety::Unsafe) => Ok(Unsafety::Unsafe),\n@@ -90,11 +98,6 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         Ok(a.intersection(b))\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<'tcx, ty::Region> {\n-        self.glb().regions(a, b)\n-    }\n-\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),"}, {"sha": "b0576ff55ff7390605b889c93df55b3b10aa6b2f", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -45,6 +45,7 @@ use self::lub::Lub;\n use self::unify::{UnificationTable, InferCtxtMethodsForSimplyUnifiableTypes};\n use self::error_reporting::ErrorReporting;\n \n+pub mod bivariate;\n pub mod combine;\n pub mod equate;\n pub mod error_reporting;\n@@ -209,6 +210,9 @@ pub enum SubregionOrigin<'tcx> {\n     // Region in return type of invoked fn must enclose call\n     CallReturn(Span),\n \n+    // Operands must be in scope\n+    Operand(Span),\n+\n     // Region resulting from a `&` expr must enclose the `&` expr\n     AddrOf(Span),\n \n@@ -1194,6 +1198,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             CallRcvr(a) => a,\n             CallArg(a) => a,\n             CallReturn(a) => a,\n+            Operand(a) => a,\n             AddrOf(a) => a,\n             AutoBorrow(a) => a,\n             SafeDestructor(a) => a,\n@@ -1257,6 +1262,7 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n             CallRcvr(a) => format!(\"CallRcvr({})\", a.repr(tcx)),\n             CallArg(a) => format!(\"CallArg({})\", a.repr(tcx)),\n             CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n+            Operand(a) => format!(\"Operand({})\", a.repr(tcx)),\n             AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n             AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n             SafeDestructor(a) => format!(\"SafeDestructor({})\", a.repr(tcx)),"}, {"sha": "b4fd34f206fa728d258a40241a13fafa32a84a80", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -977,7 +977,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.expansion(&mut var_data);\n         self.contraction(&mut var_data);\n         let values =\n-            self.extract_values_and_collect_conflicts(&var_data[],\n+            self.extract_values_and_collect_conflicts(&var_data[..],\n                                                       errors);\n         self.collect_concrete_region_errors(&values, errors);\n         values"}, {"sha": "33da3092b2a256f8d4c8232f9eb50827603a87c8", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -10,12 +10,8 @@\n \n use super::combine::*;\n use super::{cres, CresCompare};\n-use super::equate::Equate;\n-use super::glb::Glb;\n use super::higher_ranked::HigherRankedRelations;\n-use super::InferCtxt;\n-use super::lub::Lub;\n-use super::{TypeTrace, Subtype};\n+use super::{Subtype};\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use middle::ty::{BuiltinBounds};\n@@ -37,28 +33,30 @@ pub fn Sub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Sub<'f, 'tcx> {\n }\n \n impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n-    fn tag(&self) -> String { \"sub\".to_string() }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n-\n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n-\n-    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        Sub(self.fields.switch_expected()).tys(b, a)\n+    fn tag(&self) -> String { \"Sub\".to_string() }\n+    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+\n+    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n+                         -> cres<'tcx, Ty<'tcx>>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().tys(a, b),\n+            ty::Covariant => self.tys(a, b),\n+            ty::Bivariant => self.bivariate().tys(a, b),\n+            ty::Contravariant => Sub(self.fields.switch_expected()).tys(b, a),\n+        }\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                     -> cres<'tcx, ty::Region> {\n-                         let opp = CombineFields {\n-                             a_is_expected: !self.fields.a_is_expected,\n-                             ..self.fields.clone()\n-                         };\n-                         Sub(opp).regions(b, a)\n-                     }\n+    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n+                             -> cres<'tcx, ty::Region>\n+    {\n+        match v {\n+            ty::Invariant => self.equate().regions(a, b),\n+            ty::Covariant => self.regions(a, b),\n+            ty::Bivariant => self.bivariate().regions(a, b),\n+            ty::Contravariant => Sub(self.fields.switch_expected()).regions(b, a),\n+        }\n+    }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\","}, {"sha": "a856137af090a706c68461ad0beac834086e1aa5", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -14,6 +14,7 @@ use self::UndoEntry::*;\n \n use middle::ty::{self, Ty};\n use std::cmp::min;\n+use std::marker::PhantomData;\n use std::mem;\n use std::u32;\n use util::snapshot_vec as sv;\n@@ -42,28 +43,29 @@ enum UndoEntry {\n     Relate(ty::TyVid, ty::TyVid),\n }\n \n-struct Delegate<'tcx>;\n+struct Delegate<'tcx>(PhantomData<&'tcx ()>);\n \n type Relation = (RelationDir, ty::TyVid);\n \n #[derive(Copy, PartialEq, Debug)]\n pub enum RelationDir {\n-    SubtypeOf, SupertypeOf, EqTo\n+    SubtypeOf, SupertypeOf, EqTo, BiTo\n }\n \n impl RelationDir {\n     fn opposite(self) -> RelationDir {\n         match self {\n             SubtypeOf => SupertypeOf,\n             SupertypeOf => SubtypeOf,\n-            EqTo => EqTo\n+            EqTo => EqTo,\n+            BiTo => BiTo,\n         }\n     }\n }\n \n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n-        TypeVariableTable { values: sv::SnapshotVec::new(Delegate) }\n+        TypeVariableTable { values: sv::SnapshotVec::new(Delegate(PhantomData)) }\n     }\n \n     fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {"}, {"sha": "0675cec6f69b5d61a0dac228d73d24f8c3108cf3", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -18,6 +18,7 @@ use middle::infer::{uok, ures};\n use middle::infer::InferCtxt;\n use std::cell::RefCell;\n use std::fmt::Debug;\n+use std::marker::PhantomData;\n use syntax::ast;\n use util::snapshot_vec as sv;\n \n@@ -79,7 +80,7 @@ pub struct UnificationTable<K:UnifyKey> {\n /// made during the snapshot may either be *committed* or *rolled back*.\n pub struct Snapshot<K:UnifyKey> {\n     // Link snapshot to the key type `K` of the table.\n-    marker: marker::CovariantType<K>,\n+    marker: marker::PhantomData<K>,\n     snapshot: sv::Snapshot,\n }\n \n@@ -92,7 +93,7 @@ pub struct Node<K:UnifyKey> {\n }\n \n #[derive(Copy)]\n-pub struct Delegate<K>;\n+pub struct Delegate<K>(PhantomData<K>);\n \n // We can't use V:LatticeValue, much as I would like to,\n // because frequently the pattern is that V=Option<U> for some\n@@ -102,14 +103,14 @@ pub struct Delegate<K>;\n impl<K:UnifyKey> UnificationTable<K> {\n     pub fn new() -> UnificationTable<K> {\n         UnificationTable {\n-            values: sv::SnapshotVec::new(Delegate),\n+            values: sv::SnapshotVec::new(Delegate(PhantomData)),\n         }\n     }\n \n     /// Starts a new snapshot. Each snapshot must be either\n     /// rolled back or committed in a \"LIFO\" (stack) order.\n     pub fn snapshot(&mut self) -> Snapshot<K> {\n-        Snapshot { marker: marker::CovariantType::<K>,\n+        Snapshot { marker: marker::PhantomData::<K>,\n                    snapshot: self.values.start_snapshot() }\n     }\n "}, {"sha": "56c5928a132b14cd56ac92d19588bc227c912c55", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -147,18 +147,12 @@ struct LanguageItemCollector<'a> {\n \n impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        match extract(&item.attrs) {\n-            Some(value) => {\n-                let item_index = self.item_refs.get(&value[]).map(|x| *x);\n-\n-                match item_index {\n-                    Some(item_index) => {\n-                        self.collect_item(item_index, local_def(item.id), item.span)\n-                    }\n-                    None => {}\n-                }\n+        if let Some(value) = extract(&item.attrs) {\n+            let item_index = self.item_refs.get(&value[..]).cloned();\n+\n+            if let Some(item_index) = item_index {\n+                self.collect_item(item_index, local_def(item.id), item.span)\n             }\n-            None => {}\n         }\n \n         visit::walk_item(self, item);\n@@ -312,12 +306,13 @@ lets_do_this! {\n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     OwnedBoxLangItem,                \"owned_box\",               owned_box;\n \n+    PhantomFnItem,                   \"phantom_fn\",              phantom_fn;\n     PhantomDataItem,                 \"phantom_data\",            phantom_data;\n \n+    // Deprecated:\n     CovariantTypeItem,               \"covariant_type\",          covariant_type;\n     ContravariantTypeItem,           \"contravariant_type\",      contravariant_type;\n     InvariantTypeItem,               \"invariant_type\",          invariant_type;\n-\n     CovariantLifetimeItem,           \"covariant_lifetime\",      covariant_lifetime;\n     ContravariantLifetimeItem,       \"contravariant_lifetime\",  contravariant_lifetime;\n     InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;"}, {"sha": "e58136fb3f4e454e18c6269b16ebd57f0dea5642", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -1119,7 +1119,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           ast::ExprVec(ref exprs) => {\n-            self.propagate_through_exprs(&exprs[], succ)\n+            self.propagate_through_exprs(&exprs[..], succ)\n           }\n \n           ast::ExprRepeat(ref element, ref count) => {\n@@ -1143,7 +1143,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(&args[], succ);\n+            let succ = self.propagate_through_exprs(&args[..], succ);\n             self.propagate_through_expr(&**f, succ)\n           }\n \n@@ -1156,11 +1156,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(&args[], succ)\n+            self.propagate_through_exprs(&args[..], succ)\n           }\n \n           ast::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(&exprs[], succ)\n+            self.propagate_through_exprs(&exprs[..], succ)\n           }\n \n           ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {"}, {"sha": "e539f6ae6cb9382898b2167093e91fe5b288e3db", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -407,7 +407,7 @@ impl RegionMaps {\n \n     pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map.borrow().get(&id).map(|x| *x)\n+        self.scope_map.borrow().get(&id).cloned()\n     }\n \n     #[allow(dead_code)] // used in middle::cfg"}, {"sha": "3ba08c1032031075224aaa0dddcd1ac67902f5d4", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -562,7 +562,7 @@ pub fn early_bound_lifetimes<'a>(generics: &'a ast::Generics) -> Vec<ast::Lifeti\n \n     generics.lifetimes.iter()\n         .filter(|l| referenced_idents.iter().any(|&i| i == l.lifetime.name))\n-        .map(|l| (*l).clone())\n+        .cloned()\n         .collect()\n }\n "}, {"sha": "04fd03ab34224a3af51bfeed5ab69aad2c355bf4", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -113,7 +113,7 @@ impl<'tcx> Substs<'tcx> {\n     }\n \n     pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n-        self.types.get_self().map(|&t| t)\n+        self.types.get_self().cloned()\n     }\n \n     pub fn with_self_ty(&self, self_ty: Ty<'tcx>) -> Substs<'tcx> {"}, {"sha": "e199a60c370e30cf732f0dbb2d3a300f9276e3f8", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 72, "deletions": 29, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -10,53 +10,96 @@\n \n //! See `doc.rs` for high-level documentation\n \n+use super::Normalized;\n use super::SelectionContext;\n-use super::{Obligation, ObligationCause};\n+use super::{ObligationCause};\n+use super::PredicateObligation;\n use super::project;\n use super::util;\n \n use middle::subst::{Subst, TypeSpace};\n-use middle::ty::{self, Ty};\n-use middle::infer::InferCtxt;\n+use middle::ty::{self, ToPolyTraitRef, Ty};\n+use middle::infer::{self, InferCtxt};\n use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n use util::ppaux::Repr;\n \n-pub fn impl_can_satisfy(infcx: &InferCtxt,\n-                        impl1_def_id: ast::DefId,\n-                        impl2_def_id: ast::DefId)\n-                        -> bool\n+/// True if there exist types that satisfy both of the two given impls.\n+pub fn overlapping_impls(infcx: &InferCtxt,\n+                         impl1_def_id: ast::DefId,\n+                         impl2_def_id: ast::DefId)\n+                         -> bool\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={}, \\\n            impl2_def_id={})\",\n            impl1_def_id.repr(infcx.tcx),\n            impl2_def_id.repr(infcx.tcx));\n \n-    let param_env = ty::empty_parameter_environment(infcx.tcx);\n-    let mut selcx = SelectionContext::intercrate(infcx, &param_env);\n-    let cause = ObligationCause::dummy();\n-\n-    // `impl1` provides an implementation of `Foo<X,Y> for Z`.\n-    let impl1_substs =\n-        util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n-    let impl1_trait_ref =\n-        (*ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()).subst(infcx.tcx, &impl1_substs);\n-    let impl1_trait_ref =\n-        project::normalize(&mut selcx, cause.clone(), &impl1_trait_ref);\n-\n-    // Determine whether `impl2` can provide an implementation for those\n-    // same types.\n-    let obligation = Obligation::new(cause,\n-                                     ty::Binder(ty::TraitPredicate {\n-                                         trait_ref: Rc::new(impl1_trait_ref.value),\n-                                     }));\n-    debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n-    selcx.evaluate_impl(impl2_def_id, &obligation) &&\n-        impl1_trait_ref.obligations.iter().all(\n-            |o| selcx.evaluate_obligation(o))\n+    let param_env = &ty::empty_parameter_environment(infcx.tcx);\n+    let selcx = &mut SelectionContext::intercrate(infcx, param_env);\n+    infcx.probe(|_| {\n+        overlap(selcx, impl1_def_id, impl2_def_id) || overlap(selcx, impl2_def_id, impl1_def_id)\n+    })\n+}\n+\n+/// Can the types from impl `a` be used to satisfy impl `b`?\n+/// (Including all conditions)\n+fn overlap(selcx: &mut SelectionContext,\n+           a_def_id: ast::DefId,\n+           b_def_id: ast::DefId)\n+           -> bool\n+{\n+    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx, a_def_id);\n+    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx, b_def_id);\n+\n+    // Does `a <: b` hold? If not, no overlap.\n+    if let Err(_) = infer::mk_sub_poly_trait_refs(selcx.infcx(),\n+                                                  true,\n+                                                  infer::Misc(DUMMY_SP),\n+                                                  a_trait_ref.to_poly_trait_ref(),\n+                                                  b_trait_ref.to_poly_trait_ref()) {\n+        return false;\n+    }\n+\n+    // Are any of the obligations unsatisfiable? If so, no overlap.\n+    a_obligations.iter()\n+                 .chain(b_obligations.iter())\n+                 .all(|o| selcx.evaluate_obligation(o))\n+}\n+\n+/// Instantiate fresh variables for all bound parameters of the impl\n+/// and return the impl trait ref with those variables substituted.\n+fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                                     impl_def_id: ast::DefId)\n+                                     -> (Rc<ty::TraitRef<'tcx>>,\n+                                         Vec<PredicateObligation<'tcx>>)\n+{\n+    let impl_substs =\n+        &util::fresh_substs_for_impl(selcx.infcx(), DUMMY_SP, impl_def_id);\n+    let impl_trait_ref =\n+        ty::impl_trait_ref(selcx.tcx(), impl_def_id).unwrap();\n+    let impl_trait_ref =\n+        impl_trait_ref.subst(selcx.tcx(), impl_substs);\n+    let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n+        project::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n+\n+    let predicates = ty::lookup_predicates(selcx.tcx(), impl_def_id);\n+    let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n+    let Normalized { value: predicates, obligations: normalization_obligations2 } =\n+        project::normalize(selcx, ObligationCause::dummy(), &predicates);\n+    let impl_obligations =\n+        util::predicates_for_generics(selcx.tcx(), ObligationCause::dummy(), 0, &predicates);\n+\n+    let impl_obligations: Vec<_> =\n+        impl_obligations.into_iter()\n+        .chain(normalization_obligations1.into_iter())\n+        .chain(normalization_obligations2.into_iter())\n+        .collect();\n+\n+    (impl_trait_ref, impl_obligations)\n }\n \n pub enum OrphanCheckErr<'tcx> {"}, {"sha": "a63dcfc24a10ec6d76314be312d3e0d81a671433", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -28,6 +28,7 @@ use util::ppaux::{Repr, UserString};\n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n+pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n@@ -270,16 +271,6 @@ pub struct VtableObjectData<'tcx> {\n     pub object_ty: Ty<'tcx>,\n }\n \n-/// True if there exist types that satisfy both of the two given impls.\n-pub fn overlapping_impls(infcx: &InferCtxt,\n-                         impl1_def_id: ast::DefId,\n-                         impl2_def_id: ast::DefId)\n-                         -> bool\n-{\n-    coherence::impl_can_satisfy(infcx, impl1_def_id, impl2_def_id) &&\n-    coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n-}\n-\n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,"}, {"sha": "f10f7eb3951c7a0468a3a5e86367e9d4c024060f", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -20,7 +20,7 @@\n use super::supertraits;\n use super::elaborate_predicates;\n \n-use middle::subst::{self, SelfSpace};\n+use middle::subst::{self, SelfSpace, TypeSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n use std::rc::Rc;\n@@ -31,6 +31,10 @@ pub enum ObjectSafetyViolation<'tcx> {\n     /// Self : Sized declared on the trait\n     SizedSelf,\n \n+    /// Supertrait reference references `Self` an in illegal location\n+    /// (e.g. `trait Foo : Bar<Self>`)\n+    SupertraitSelf,\n+\n     /// Method has something illegal\n     Method(Rc<ty::Method<'tcx>>, MethodViolationCode),\n }\n@@ -57,7 +61,7 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     // Because we query yes/no results frequently, we keep a cache:\n     let cached_result =\n-        tcx.object_safety_cache.borrow().get(&trait_ref.def_id()).map(|&r| r);\n+        tcx.object_safety_cache.borrow().get(&trait_ref.def_id()).cloned();\n \n     let result =\n         cached_result.unwrap_or_else(|| {\n@@ -110,6 +114,9 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if trait_has_sized_self(tcx, trait_def_id) {\n         violations.push(ObjectSafetyViolation::SizedSelf);\n     }\n+    if supertraits_reference_self(tcx, trait_def_id) {\n+        violations.push(ObjectSafetyViolation::SupertraitSelf);\n+    }\n \n     debug!(\"object_safety_violations_for_trait(trait_def_id={}) = {}\",\n            trait_def_id.repr(tcx),\n@@ -118,6 +125,35 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n     violations\n }\n \n+fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    trait_def_id: ast::DefId)\n+                                    -> bool\n+{\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let trait_ref = trait_def.trait_ref.clone();\n+    let predicates = ty::predicates_for_trait_ref(tcx, &ty::Binder(trait_ref));\n+    predicates\n+        .into_iter()\n+        .any(|predicate| {\n+            match predicate {\n+                ty::Predicate::Trait(ref data) => {\n+                    // In the case of a trait predicate, we can skip the \"self\" type.\n+                    Some(data.def_id()) != tcx.lang_items.phantom_fn() &&\n+                        data.0.trait_ref.substs.types.get_slice(TypeSpace)\n+                                                     .iter()\n+                                                     .cloned()\n+                                                     .any(is_self)\n+                }\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::RegionOutlives(..) |\n+                ty::Predicate::Equate(..) => {\n+                    false\n+                }\n+            }\n+        })\n+}\n+\n fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               trait_def_id: ast::DefId)\n                               -> bool\n@@ -138,11 +174,7 @@ fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .any(|predicate| {\n             match predicate {\n                 ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                    let self_ty = trait_pred.0.self_ty();\n-                    match self_ty.sty {\n-                        ty::ty_param(ref data) => data.space == subst::SelfSpace,\n-                        _ => false,\n-                    }\n+                    is_self(trait_pred.0.self_ty())\n                 }\n                 ty::Predicate::Projection(..) |\n                 ty::Predicate::Trait(..) |\n@@ -295,8 +327,17 @@ impl<'tcx> Repr<'tcx> for ObjectSafetyViolation<'tcx> {\n         match *self {\n             ObjectSafetyViolation::SizedSelf =>\n                 format!(\"SizedSelf\"),\n+            ObjectSafetyViolation::SupertraitSelf =>\n+                format!(\"SupertraitSelf\"),\n             ObjectSafetyViolation::Method(ref m, code) =>\n                 format!(\"Method({},{:?})\", m.repr(tcx), code),\n         }\n     }\n }\n+\n+fn is_self<'tcx>(ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        ty::ty_param(ref data) => data.space == subst::SelfSpace,\n+        _ => false,\n+    }\n+}"}, {"sha": "0e29892084175d180047412a39c9a2e936c750a7", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -132,6 +132,7 @@ pub enum MethodMatchedData {\n /// parameters) that would have to be inferred from the impl.\n #[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n+    PhantomFnCandidate,\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(ast::DefId),\n@@ -736,7 +737,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         let cache = self.pick_candidate_cache();\n         let hashmap = cache.hashmap.borrow();\n-        hashmap.get(&cache_fresh_trait_pred.0.trait_ref).map(|c| (*c).clone())\n+        hashmap.get(&cache_fresh_trait_pred.0.trait_ref).cloned()\n     }\n \n     fn insert_candidate_cache(&mut self,\n@@ -793,15 +794,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                stack: &TraitObligationStack<'o, 'tcx>)\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n-        // Check for overflow.\n-\n         let TraitObligationStack { obligation, .. } = *stack;\n \n         let mut candidates = SelectionCandidateSet {\n             vec: Vec::new(),\n             ambiguous: false\n         };\n \n+        // Check for the `PhantomFn` trait. This is really just a\n+        // special annotation that is *always* considered to match, no\n+        // matter what the type parameters are etc.\n+        if self.tcx().lang_items.phantom_fn() == Some(obligation.predicate.def_id()) {\n+            candidates.vec.push(PhantomFnCandidate);\n+            return Ok(candidates);\n+        }\n+\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n@@ -996,7 +1003,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let all_bounds =\n             util::transitive_bounds(\n-                self.tcx(), &caller_trait_refs[]);\n+                self.tcx(), &caller_trait_refs[..]);\n \n         let matching_bounds =\n             all_bounds.filter(\n@@ -1521,7 +1528,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::substd_enum_variants(self.tcx(), def_id, substs)\n                     .iter()\n                     .flat_map(|variant| variant.args.iter())\n-                    .map(|&ty| ty)\n+                    .cloned()\n                     .collect();\n                 nominal(self, bound, def_id, types)\n             }\n@@ -1629,6 +1636,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     try!(self.confirm_builtin_candidate(obligation, builtin_bound))))\n             }\n \n+            PhantomFnCandidate |\n             ErrorCandidate => {\n                 Ok(VtableBuiltin(VtableBuiltinData { nested: VecPerParamSpace::empty() }))\n             }\n@@ -2295,6 +2303,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n+            PhantomFnCandidate => format!(\"PhantomFnCandidate\"),\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),"}, {"sha": "e9908397f970387782fb097c4d478013d92c480a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 74, "deletions": 18, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -68,15 +68,16 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FnvHashMap};\n \n use arena::TypedArena;\n-use std::borrow::{BorrowFrom, Cow};\n+use std::borrow::{Borrow, Cow};\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt;\n-use std::hash::{Hash, Writer, SipHasher, Hasher};\n+use std::hash::{Hash, SipHasher, Hasher};\n+#[cfg(stage0)] use std::hash::Writer;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n-use std::vec::CowVec;\n+use std::vec::{CowVec, IntoIter};\n use collections::enum_set::{EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n use syntax::abi;\n@@ -958,11 +959,18 @@ impl<'tcx> PartialEq for TyS<'tcx> {\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n \n+#[cfg(stage0)]\n impl<'tcx, S: Writer + Hasher> Hash<S> for TyS<'tcx> {\n     fn hash(&self, s: &mut S) {\n         (self as *const _).hash(s)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'tcx> Hash for TyS<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self as *const _).hash(s)\n+    }\n+}\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n@@ -980,15 +988,22 @@ impl<'tcx> PartialEq for InternedTy<'tcx> {\n \n impl<'tcx> Eq for InternedTy<'tcx> {}\n \n+#[cfg(stage0)]\n impl<'tcx, S: Writer + Hasher> Hash<S> for InternedTy<'tcx> {\n     fn hash(&self, s: &mut S) {\n         self.ty.sty.hash(s)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'tcx> Hash for InternedTy<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.ty.sty.hash(s)\n+    }\n+}\n \n-impl<'tcx> BorrowFrom<InternedTy<'tcx>> for sty<'tcx> {\n-    fn borrow_from<'a>(ty: &'a InternedTy<'tcx>) -> &'a sty<'tcx> {\n-        &ty.ty.sty\n+impl<'tcx> Borrow<sty<'tcx>> for InternedTy<'tcx> {\n+    fn borrow<'a>(&'a self) -> &'a sty<'tcx> {\n+        &self.ty.sty\n     }\n }\n \n@@ -2004,6 +2019,40 @@ impl<'tcx> AsPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n }\n \n impl<'tcx> Predicate<'tcx> {\n+    /// Iterates over the types in this predicate. Note that in all\n+    /// cases this is skipping over a binder, so late-bound regions\n+    /// with depth 0 are bound by the predicate.\n+    pub fn walk_tys(&self) -> IntoIter<Ty<'tcx>> {\n+        let vec: Vec<_> = match *self {\n+            ty::Predicate::Trait(ref data) => {\n+                data.0.trait_ref.substs.types.as_slice().to_vec()\n+            }\n+            ty::Predicate::Equate(ty::Binder(ref data)) => {\n+                vec![data.0, data.1]\n+            }\n+            ty::Predicate::TypeOutlives(ty::Binder(ref data)) => {\n+                vec![data.0]\n+            }\n+            ty::Predicate::RegionOutlives(..) => {\n+                vec![]\n+            }\n+            ty::Predicate::Projection(ref data) => {\n+                let trait_inputs = data.0.projection_ty.trait_ref.substs.types.as_slice();\n+                trait_inputs.iter()\n+                            .cloned()\n+                            .chain(Some(data.0.ty).into_iter())\n+                            .collect()\n+            }\n+        };\n+\n+        // The only reason to collect into a vector here is that I was\n+        // too lazy to make the full (somewhat complicated) iterator\n+        // type that would be needed here. But I wanted this fn to\n+        // return an iterator conceptually, rather than a `Vec`, so as\n+        // to be closer to `Ty::walk`.\n+        vec.into_iter()\n+    }\n+\n     pub fn has_escaping_regions(&self) -> bool {\n         match *self {\n             Predicate::Trait(ref trait_ref) => trait_ref.has_escaping_regions(),\n@@ -2331,7 +2380,7 @@ impl ClosureKind {\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(&err[]),\n+            Err(err) => cx.sess.fatal(&err[..]),\n         }\n     }\n }\n@@ -2665,7 +2714,7 @@ impl FlagComputation {\n             }\n \n             &ty_tup(ref ts) => {\n-                self.add_tys(&ts[]);\n+                self.add_tys(&ts[..]);\n             }\n \n             &ty_bare_fn(_, ref f) => {\n@@ -2836,7 +2885,7 @@ pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n                         def_id: ast::DefId,\n                         input_tys: &[Ty<'tcx>],\n                         output: Ty<'tcx>) -> Ty<'tcx> {\n-    let input_args = input_tys.iter().map(|ty| *ty).collect();\n+    let input_args = input_tys.iter().cloned().collect();\n     mk_bare_fn(cx,\n                Some(def_id),\n                cx.mk_bare_fn(BareFnTy {\n@@ -2959,6 +3008,13 @@ impl<'tcx> TyS<'tcx> {\n         assert_eq!(r, Some(self));\n         walker\n     }\n+\n+    pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n+        match self.sty {\n+            ty::ty_param(ref d) => Some(d.clone()),\n+            _ => None,\n+        }\n+    }\n }\n \n pub fn walk_ty<'tcx, F>(ty_root: Ty<'tcx>, mut f: F)\n@@ -3451,7 +3507,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_struct(did, substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(&flds[],\n+                    TypeContents::union(&flds[..],\n                                         |f| tc_mt(cx, f.mt, cache));\n \n                 if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n@@ -3474,14 +3530,14 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(&tys[],\n+                TypeContents::union(&tys[..],\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(&variants[], |variant| {\n+                    TypeContents::union(&variants[..], |variant| {\n                         TypeContents::union(&variant.args[],\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n@@ -3805,7 +3861,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                                        -> Representability {\n         match ty.sty {\n             ty_tup(ref ts) => {\n-                find_nonrepresentable(cx, sp, seen, ts.iter().map(|ty| *ty))\n+                find_nonrepresentable(cx, sp, seen, ts.iter().cloned())\n             }\n             // Fixed-length vectors.\n             // FIXME(#11924) Behavior undecided for zero-length vectors.\n@@ -4112,7 +4168,7 @@ pub fn positional_element_ty<'tcx>(cx: &ctxt<'tcx>,\n                                    variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n \n     match (&ty.sty, variant) {\n-        (&ty_tup(ref v), None) => v.get(i).map(|&t| t),\n+        (&ty_tup(ref v), None) => v.get(i).cloned(),\n \n \n         (&ty_struct(def_id, substs), None) => lookup_struct_fields(cx, def_id)\n@@ -4933,7 +4989,7 @@ pub fn note_and_explain_type_err(cx: &ctxt, err: &type_err) {\n }\n \n pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n-    cx.provided_method_sources.borrow().get(&id).map(|x| *x)\n+    cx.provided_method_sources.borrow().get(&id).cloned()\n }\n \n pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n@@ -4944,7 +5000,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n                         let (_, p) =\n-                            ast_util::split_trait_methods(&ms[]);\n+                            ast_util::split_trait_methods(&ms[..]);\n                         p.iter()\n                          .map(|m| {\n                             match impl_or_trait_item(\n@@ -6600,7 +6656,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n }\n \n /// A free variable referred to in a function.\n-#[derive(Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Freevar {\n     /// The variable being accessed free.\n     pub def: def::Def,\n@@ -6625,7 +6681,7 @@ pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n {\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n-        Some(d) => f(&d[])\n+        Some(d) => f(&d[..])\n     }\n }\n "}, {"sha": "60a9ffc7d2e13b80a6e1824a55efdb6e02315504", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -55,7 +55,7 @@ pub fn check_crate(krate: &ast::Crate,\n \n pub fn link_name(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     lang_items::extract(attrs).and_then(|name| {\n-        $(if &name[] == stringify!($name) {\n+        $(if &name[..] == stringify!($name) {\n             Some(InternedString::new(stringify!($sym)))\n         } else)* {\n             None"}, {"sha": "b3bc898748fdc00ba3637c5efde0d0bc473255cd", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -111,19 +111,19 @@ impl<'a> PluginLoader<'a> {\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n             Err(err) => {\n-                self.sess.span_fatal(span, &err[])\n+                self.sess.span_fatal(span, &err[..])\n             }\n         };\n \n         unsafe {\n             let registrar =\n-                match lib.symbol(&symbol[]) {\n+                match lib.symbol(&symbol[..]) {\n                     Ok(registrar) => {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n                     Err(err) => {\n-                        self.sess.span_fatal(span, &err[])\n+                        self.sess.span_fatal(span, &err[..])\n                     }\n                 };\n "}, {"sha": "93a25de0491fe018ab8fef7d7e11435c80c211e4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -629,7 +629,7 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n     let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.push_all(&default_cfg[]);\n+    v.push_all(&default_cfg[..]);\n     v\n }\n \n@@ -824,7 +824,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(&e[]));\n+        .unwrap_or_else(|e| early_error(&e[..]));\n \n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n@@ -923,7 +923,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut search_paths = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        search_paths.add_path(&s[]);\n+        search_paths.add_path(&s[..]);\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n@@ -981,7 +981,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     --debuginfo\");\n     }\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[]) {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,\n         Some(\"never\")  => Never,\n@@ -1119,7 +1119,7 @@ mod test {\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n-        assert!((attr::contains_name(&cfg[], \"test\")));\n+        assert!((attr::contains_name(&cfg[..], \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add"}, {"sha": "c1c5518887577d83462db5a07e032c48012f497e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -75,13 +75,13 @@ impl Session {\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err(sp, &msg[]),\n+            Some(msg) => self.diagnostic().span_err(sp, &msg[..]),\n             None => self.diagnostic().span_err(sp, msg)\n         }\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n         match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[], code),\n+            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[..], code),\n             None => self.diagnostic().span_err_with_code(sp, msg, code)\n         }\n     }"}, {"sha": "c9d50b9cecf84ff005f033b439c589b5202a61fa", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 91, "deletions": 2, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -13,7 +13,8 @@\n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::fmt::Debug;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n+#[cfg(stage0)] use std::hash::Hasher;\n use std::iter::repeat;\n use std::time::Duration;\n use std::collections::hash_state::HashState;\n@@ -144,11 +145,54 @@ pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -\n /// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n /// very small graphs. If the graphs become larger, a more efficient graph representation and\n /// algorithm would probably be advised.\n+#[cfg(stage0)]\n pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n                        destination: T) -> bool\n     where S: HashState,\n           <S as HashState>::Hasher: Hasher<Output=u64>,\n-          T: Hash< <S as HashState>::Hasher> + Eq + Clone,\n+          T: Hash<<S as HashState>::Hasher> + Eq + Clone,\n+{\n+    if source == destination {\n+        return true;\n+    }\n+\n+    // Do a little breadth-first-search here.  The `queue` list\n+    // doubles as a way to detect if we've seen a particular FR\n+    // before.  Note that we expect this graph to be an *extremely\n+    // shallow* tree.\n+    let mut queue = vec!(source);\n+    let mut i = 0;\n+    while i < queue.len() {\n+        match edges_map.get(&queue[i]) {\n+            Some(edges) => {\n+                for target in edges {\n+                    if *target == destination {\n+                        return true;\n+                    }\n+\n+                    if !queue.iter().any(|x| x == target) {\n+                        queue.push((*target).clone());\n+                    }\n+                }\n+            }\n+            None => {}\n+        }\n+        i += 1;\n+    }\n+    return false;\n+}\n+/// K: Eq + Hash<S>, V, S, H: Hasher<S>\n+///\n+/// Determines whether there exists a path from `source` to `destination`.  The graph is defined by\n+/// the `edges_map`, which maps from a node `S` to a list of its adjacent nodes `T`.\n+///\n+/// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n+/// very small graphs. If the graphs become larger, a more efficient graph representation and\n+/// algorithm would probably be advised.\n+#[cfg(not(stage0))]\n+pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n+                       destination: T) -> bool\n+    where S: HashState, T: Hash + Eq + Clone,\n {\n     if source == destination {\n         return true;\n@@ -206,12 +250,57 @@ pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n /// }\n /// ```\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n     where T: Clone + Hash<<S as HashState>::Hasher> + Eq,\n           U: Clone,\n           S: HashState,\n           <S as HashState>::Hasher: Hasher<Output=u64>,\n           F: FnOnce(T) -> U,\n+{\n+    let key = arg.clone();\n+    let result = cache.borrow().get(&key).cloned();\n+    match result {\n+        Some(result) => result,\n+        None => {\n+            let result = f(arg);\n+            cache.borrow_mut().insert(key, result.clone());\n+            result\n+        }\n+    }\n+}\n+/// Memoizes a one-argument closure using the given RefCell containing\n+/// a type implementing MutableMap to serve as a cache.\n+///\n+/// In the future the signature of this function is expected to be:\n+/// ```\n+/// pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n+///    cache: &RefCell<M>,\n+///    f: &|T| -> U\n+/// ) -> impl |T| -> U {\n+/// ```\n+/// but currently it is not possible.\n+///\n+/// # Example\n+/// ```\n+/// struct Context {\n+///    cache: RefCell<HashMap<uint, uint>>\n+/// }\n+///\n+/// fn factorial(ctxt: &Context, n: uint) -> uint {\n+///     memoized(&ctxt.cache, n, |n| match n {\n+///         0 | 1 => n,\n+///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)\n+///     })\n+/// }\n+/// ```\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n+    where T: Clone + Hash + Eq,\n+          U: Clone,\n+          S: HashState,\n+          F: FnOnce(T) -> U,\n {\n     let key = arg.clone();\n     let result = cache.borrow().get(&key).map(|result| result.clone());"}, {"sha": "10a7b2abea80bb389e3213ec3895b27661ded2d8", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -48,7 +48,7 @@ fn test_lev_distance() {\n     for c in (0u32..MAX as u32)\n              .filter_map(|i| from_u32(i))\n              .map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(&c[], &c[]), 0);\n+        assert_eq!(lev_distance(&c[..], &c[..]), 0);\n     }\n \n     let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";"}, {"sha": "1b07ce789e77c8e7713c3ff2f2831fde021fc818", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -15,7 +15,8 @@\n use std::collections::hash_state::{DefaultState};\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n-use std::hash::{Hasher, Writer, Hash};\n+use std::hash::{Hasher, Hash};\n+#[cfg(stage0)] use std::hash::Writer;\n use syntax::ast;\n \n pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n@@ -27,12 +28,22 @@ pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n pub type NodeSet = FnvHashSet<ast::NodeId>;\n pub type DefIdSet = FnvHashSet<ast::DefId>;\n \n+#[cfg(stage0)]\n pub fn FnvHashMap<K: Hash<FnvHasher> + Eq, V>() -> FnvHashMap<K, V> {\n     Default::default()\n }\n+#[cfg(stage0)]\n pub fn FnvHashSet<V: Hash<FnvHasher> + Eq>() -> FnvHashSet<V> {\n     Default::default()\n }\n+#[cfg(not(stage0))]\n+pub fn FnvHashMap<K: Hash + Eq, V>() -> FnvHashMap<K, V> {\n+    Default::default()\n+}\n+#[cfg(not(stage0))]\n+pub fn FnvHashSet<V: Hash + Eq>() -> FnvHashSet<V> {\n+    Default::default()\n+}\n \n pub fn NodeMap<T>() -> NodeMap<T> { FnvHashMap() }\n pub fn DefIdMap<T>() -> DefIdMap<T> { FnvHashMap() }\n@@ -52,12 +63,14 @@ impl Default for FnvHasher {\n     fn default() -> FnvHasher { FnvHasher(0xcbf29ce484222325) }\n }\n \n+#[cfg(stage0)]\n impl Hasher for FnvHasher {\n     type Output = u64;\n     fn reset(&mut self) { *self = Default::default(); }\n     fn finish(&self) -> u64 { self.0 }\n }\n \n+#[cfg(stage0)]\n impl Writer for FnvHasher {\n     fn write(&mut self, bytes: &[u8]) {\n         let FnvHasher(mut hash) = *self;\n@@ -68,3 +81,16 @@ impl Writer for FnvHasher {\n         *self = FnvHasher(hash);\n     }\n }\n+\n+#[cfg(not(stage0))]\n+impl Hasher for FnvHasher {\n+    fn write(&mut self, bytes: &[u8]) {\n+        let FnvHasher(mut hash) = *self;\n+        for byte in bytes {\n+            hash = hash ^ (*byte as u64);\n+            hash = hash * 0x100000001b3;\n+        }\n+        *self = FnvHasher(hash);\n+    }\n+    fn finish(&self) -> u64 { self.0 }\n+}"}, {"sha": "1d46c011bb32e7298334fa4a1ea5318b1565feb4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -28,7 +28,8 @@ use middle::ty_fold::TypeFoldable;\n \n use std::collections::HashMap;\n use std::collections::hash_state::HashState;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n+#[cfg(stage0)] use std::hash::Hasher;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast_map;\n@@ -292,7 +293,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             Some(def_id) => {\n                 s.push_str(\" {\");\n                 let path_str = ty::item_path_str(cx, def_id);\n-                s.push_str(&path_str[]);\n+                s.push_str(&path_str[..]);\n                 s.push_str(\"}\");\n             }\n             None => { }\n@@ -376,7 +377,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 .iter()\n                 .map(|elem| ty_to_string(cx, *elem))\n                 .collect::<Vec<_>>();\n-            match &strs[] {\n+            match &strs[..] {\n                 [ref string] => format!(\"({},)\", string),\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n@@ -508,13 +509,26 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n     // avoid those ICEs.\n     let generics = get_generics();\n \n+    let has_self = substs.self_ty().is_some();\n     let tps = substs.types.get_slice(subst::TypeSpace);\n     let ty_params = generics.types.get_slice(subst::TypeSpace);\n     let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n     let num_defaults = if has_defaults {\n         ty_params.iter().zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n             match def.default {\n-                Some(default) => default.subst(cx, substs) == actual,\n+                Some(default) => {\n+                    if !has_self && ty::type_has_self(default) {\n+                        // In an object type, there is no `Self`, and\n+                        // thus if the default value references Self,\n+                        // the user will be required to give an\n+                        // explicit value. We can't even do the\n+                        // substitution below to check without causing\n+                        // an ICE. (#18956).\n+                        false\n+                    } else {\n+                        default.subst(cx, substs) == actual\n+                    }\n+                }\n                 None => false\n             }\n         }).count()\n@@ -625,15 +639,15 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, &self[])\n+        repr_vec(tcx, &self[..])\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, &self[])\n+        repr_vec(tcx, &self[..])\n     }\n }\n \n@@ -673,7 +687,7 @@ impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n                       &base,\n                       trait_ref.substs,\n                       trait_ref.def_id,\n-                      &projection_bounds[],\n+                      &projection_bounds[..],\n                       || ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n     }\n }\n@@ -1259,7 +1273,7 @@ impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n                 }\n             })\n         });\n-        let names: Vec<_> = names.iter().map(|s| &s[]).collect();\n+        let names: Vec<_> = names.iter().map(|s| &s[..]).collect();\n \n         let value_str = unbound_value.user_string(tcx);\n         if names.len() == 0 {\n@@ -1420,6 +1434,7 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n     where K: Hash<<S as HashState>::Hasher> + Eq + Repr<'tcx>,\n           V: Repr<'tcx>,\n@@ -1435,6 +1450,21 @@ impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n+    where K: Hash + Eq + Repr<'tcx>,\n+          V: Repr<'tcx>,\n+          S: HashState,\n+{\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"HashMap({})\",\n+                self.iter()\n+                    .map(|(k,v)| format!(\"{} => {}\", k.repr(tcx), v.repr(tcx)))\n+                    .collect::<Vec<String>>()\n+                    .connect(\", \"))\n+    }\n+}\n+\n impl<'tcx, T, U> Repr<'tcx> for ty::OutlivesPredicate<T,U>\n     where T : Repr<'tcx> + TypeFoldable<'tcx>,\n           U : Repr<'tcx> + TypeFoldable<'tcx>,"}, {"sha": "c45ee258342ec1be9c24a8f83d03f2bdae694488", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -53,7 +53,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n     let ar = match *maybe_ar_prog {\n-        Some(ref ar) => &ar[],\n+        Some(ref ar) => &ar[..],\n         None => \"ar\"\n     };\n     let mut cmd = Command::new(ar);\n@@ -84,7 +84,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n             o\n         },\n         Err(e) => {\n-            handler.err(&format!(\"could not exec `{}`: {}\", &ar[],\n+            handler.err(&format!(\"could not exec `{}`: {}\", &ar[..],\n                              e)[]);\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n@@ -101,10 +101,10 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n \n     for path in search_paths {\n         debug!(\"looking for {} inside {:?}\", name, path.display());\n-        let test = path.join(&oslibname[]);\n+        let test = path.join(&oslibname[..]);\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n-            let test = path.join(&unixlibname[]);\n+            let test = path.join(&unixlibname[..]);\n             if test.exists() { return test }\n         }\n     }\n@@ -192,12 +192,12 @@ impl<'a> ArchiveBuilder<'a> {\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n         let obj_start = format!(\"{}\", name);\n-        let obj_start = &obj_start[];\n+        let obj_start = &obj_start[..];\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n \n-        self.add_archive(rlib, &name[], |fname: &str| {\n+        self.add_archive(rlib, &name[..], |fname: &str| {\n             let skip_obj = lto && fname.starts_with(obj_start)\n                 && fname.ends_with(\".o\");\n             skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n@@ -234,7 +234,7 @@ impl<'a> ArchiveBuilder<'a> {\n             // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), &args[]);\n+                       \"s\", Some(self.work_dir.path()), &args[..]);\n             }\n             return self.archive;\n         }\n@@ -254,7 +254,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 // Add the archive members seen so far, without updating the\n                 // symbol table (`S`).\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), &args[]);\n+                       \"cruS\", Some(self.work_dir.path()), &args[..]);\n \n                 args.clear();\n                 args.push(&abs_dst);\n@@ -269,7 +269,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // necessary.\n         let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), &args[]);\n+               flags, Some(self.work_dir.path()), &args[..]);\n \n         self.archive\n     }\n@@ -312,7 +312,7 @@ impl<'a> ArchiveBuilder<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = self.work_dir.path().join(&filename[]);\n+            let new_filename = self.work_dir.path().join(&filename[..]);\n             try!(fs::rename(file, &new_filename));\n             self.members.push(Path::new(filename));\n         }"}, {"sha": "e7419d4bec30747717d0bf68c88a3a26db383d7b", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -40,12 +40,9 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n-    let libs = libs.into_iter().filter_map(|(_, l)| {\n-        l.map(|p| p.clone())\n-    }).collect::<Vec<_>>();\n-\n-    let rpaths = get_rpaths(config, &libs[]);\n-    flags.push_all(&rpaths_to_flags(&rpaths[])[]);\n+    let libs = libs.into_iter().filter_map(|(_, l)| l).collect::<Vec<_>>();\n+    let rpaths = get_rpaths(config, &libs[..]);\n+    flags.push_all(&rpaths_to_flags(&rpaths[..]));\n     flags\n }\n \n@@ -82,14 +79,14 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n         }\n     }\n \n-    log_rpaths(\"relative\", &rel_rpaths[]);\n-    log_rpaths(\"fallback\", &fallback_rpaths[]);\n+    log_rpaths(\"relative\", &rel_rpaths[..]);\n+    log_rpaths(\"fallback\", &fallback_rpaths[..]);\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(&fallback_rpaths[]);\n+    rpaths.push_all(&fallback_rpaths[..]);\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(&rpaths[]);\n+    let rpaths = minimize_rpaths(&rpaths[..]);\n     return rpaths;\n }\n \n@@ -139,7 +136,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths {\n-        if set.insert(&rpath[]) {\n+        if set.insert(&rpath[..]) {\n             minimized.push(rpath.clone());\n         }\n     }"}, {"sha": "01a5f0d6e20f881c481ad0e62f8153fdc21d3ece", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -254,18 +254,18 @@ impl Target {\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[]).map(|o| o.as_string()\n+                obj.find(&name[..]).map(|o| o.as_string()\n                                     .map(|s| base.options.$key_name = s.to_string()));\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[])\n+                obj.find(&name[..])\n                     .map(|o| o.as_boolean()\n                          .map(|s| base.options.$key_name = s));\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[]).map(|o| o.as_array()\n+                obj.find(&name[..]).map(|o| o.as_array()\n                     .map(|v| base.options.$key_name = v.iter()\n                         .map(|a| a.as_string().unwrap().to_string()).collect()\n                         )"}, {"sha": "abe01d193b4929b308f04dc3051b7cff761ccec5", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -656,7 +656,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                 &self.bccx.loan_path_to_string(move_path)[])\n                 };\n \n-                self.bccx.span_err(span, &err_message[]);\n+                self.bccx.span_err(span, &err_message[..]);\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\","}, {"sha": "c873831cb0f657b6faa3fb81a16641b55211ce5c", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -38,7 +38,7 @@ enum Fragment {\n     // This represents the collection of all but one of the elements\n     // from an array at the path described by the move path index.\n     // Note that attached MovePathIndex should have mem_categorization\n-    // of InteriorElement (i.e. array dereference `&foo[]`).\n+    // of InteriorElement (i.e. array dereference `&foo[..]`).\n     AllButOneFrom(MovePathIndex),\n }\n \n@@ -198,11 +198,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved[]));\n+    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved[..]));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned[]));\n+    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned[..]));\n \n     // Second, build parents from the moved and assigned.\n     for m in &moved {\n@@ -222,14 +222,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents[]));\n+    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents[..]));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, &parents[]));\n-    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved[]));\n+    moved.retain(|f| non_member(*f, &parents[..]));\n+    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved[..]));\n \n-    assigned.retain(|f| non_member(*f, &parents[]));\n-    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned[]));\n+    assigned.retain(|f| non_member(*f, &parents[..]));\n+    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned[..]));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in &moved {\n@@ -247,16 +247,16 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved[]));\n+    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved[..]));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n         AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, &parents[]) &&\n-            non_member(mpi, &moved[]) &&\n-            non_member(mpi, &assigned[])\n+        Just(mpi) => non_member(mpi, &parents[..]) &&\n+            non_member(mpi, &moved[..]) &&\n+            non_member(mpi, &assigned[..])\n     });\n-    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved[]));\n+    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved[..]));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;\n@@ -437,7 +437,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let msg = format!(\"type {} ({:?}) is not fragmentable\",\n                               parent_ty.repr(tcx), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            tcx.sess.opt_span_bug(opt_span, &msg[])\n+            tcx.sess.opt_span_bug(opt_span, &msg[..])\n         }\n     }\n }"}, {"sha": "518e4bc472ca4aa6c117c8db26f9e0796ad5ce93", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -137,7 +137,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     check_loans::check_loans(this,\n                              &loan_dfcx,\n                              flowed_moves,\n-                             &all_loans[],\n+                             &all_loans[..],\n                              id,\n                              decl,\n                              body);"}, {"sha": "39c9d9ba6ad24ae5f067b893c66627c6d4e209a8", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                 set.push_str(\", \");\n             }\n             let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n-            set.push_str(&loan_str[]);\n+            set.push_str(&loan_str[..]);\n             saw_some = true;\n             true\n         });"}, {"sha": "b7cfda280925701495074fcb68d1955b03b3a058", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -20,7 +20,6 @@\n #![allow(non_camel_case_types)]\n \n #![feature(core)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "a260997f605940da7ac8d8fd6b83c9e93232af1b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -85,7 +85,7 @@ pub fn compile_input(sess: Session,\n             let expanded_crate\n                 = match phase_2_configure_and_expand(&sess,\n                                                      krate,\n-                                                     &id[],\n+                                                     &id[..],\n                                                      addl_plugins) {\n                     None => return,\n                     Some(k) => k\n@@ -99,20 +99,20 @@ pub fn compile_input(sess: Session,\n                                                                  &sess,\n                                                                  outdir,\n                                                                  &expanded_crate,\n-                                                                 &id[]));\n+                                                                 &id[..]));\n \n         let mut forest = ast_map::Forest::new(expanded_crate);\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n-        write_out_deps(&sess, input, &outputs, &id[]);\n+        write_out_deps(&sess, input, &outputs, &id[..]);\n \n         controller_entry_point!(after_write_deps,\n                                 CompileState::state_after_write_deps(input,\n                                                                      &sess,\n                                                                      outdir,\n                                                                      &ast_map,\n-                                                                     &id[]));\n+                                                                     &id[..]));\n \n         let analysis = phase_3_run_analysis_passes(sess,\n                                                    ast_map,"}, {"sha": "2550432c8101adde411a3828936cb1a031eecaa0", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -272,7 +272,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                       -> Compilation {\n         match matches.opt_str(\"explain\") {\n             Some(ref code) => {\n-                match descriptions.find_description(&code[]) {\n+                match descriptions.find_description(&code[..]) {\n                     Some(ref description) => {\n                         println!(\"{}\", description);\n                     }\n@@ -582,7 +582,7 @@ Available lint options:\n         for lint in lints {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(&name[]), lint.default_level.as_str(), lint.desc);\n+                     padded(&name[..]), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -612,7 +612,7 @@ Available lint options:\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n-                     padded(&name[]), desc);\n+                     padded(&name[..]), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -678,7 +678,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     let matches =\n-        match getopts::getopts(&args[], &config::optgroups()[]) {\n+        match getopts::getopts(&args[..], &config::optgroups()[]) {\n             Ok(m) => m,\n             Err(f_stable_attempt) => {\n                 // redo option parsing, including unstable options this time,\n@@ -803,7 +803,7 @@ pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in &xs {\n-                    emitter.emit(None, &note[], None, diagnostic::Note)\n+                    emitter.emit(None, &note[..], None, diagnostic::Note)\n                 }\n \n                 match r.read_to_string() {"}, {"sha": "0fbfa5fd89dd7f3fdc1216ccb271332640b6fff2", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -383,7 +383,7 @@ impl UserIdentifiedItem {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(&parts[])),\n+                NodesMatchingSuffix(map.nodes_matching_suffix(&parts[..])),\n         }\n     }\n \n@@ -395,7 +395,7 @@ impl UserIdentifiedItem {\n                         user_option,\n                         self.reconstructed_input(),\n                         is_wrong_because);\n-            sess.fatal(&message[])\n+            sess.fatal(&message[..])\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n@@ -522,7 +522,7 @@ pub fn pretty_print_input(sess: Session,\n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, krate, &id[], None) {\n+        match driver::phase_2_configure_and_expand(&sess, krate, &id[..], None) {\n             None => return,\n             Some(k) => k\n         }\n@@ -541,7 +541,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = sess.codemap().get_filemap(&src_name[])\n+    let src = sess.codemap().get_filemap(&src_name[..])\n                             .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n@@ -632,8 +632,8 @@ pub fn pretty_print_input(sess: Session,\n                     // point to what was found, if there's an\n                     // accessible span.\n                     match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, &message[]),\n-                        None => sess.fatal(&message[])\n+                        Some(sp) => sess.span_fatal(sp, &message[..]),\n+                        None => sess.fatal(&message[..])\n                     }\n                 }\n             }"}, {"sha": "fbbd72e2c76be6efd75fe6182759d3d578997c0a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                 output_ty: Ty<'tcx>)\n                 -> Ty<'tcx>\n     {\n-        let input_args = input_tys.iter().map(|ty| *ty).collect();\n+        let input_args = input_tys.iter().cloned().collect();\n         ty::mk_bare_fn(self.infcx.tcx,\n                        None,\n                        self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n@@ -278,7 +278,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        ty::mk_param(self.infcx.tcx, space, index, token::intern(&name[]))\n+        ty::mk_param(self.infcx.tcx, space, index, token::intern(&name[..]))\n     }\n \n     pub fn re_early_bound(&self,"}, {"sha": "14a99026aac8ac18c8e06b377e68981ca534f52b", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -30,7 +30,7 @@ impl ArchiveRO {\n     /// raised.\n     pub fn open(dst: &Path) -> Option<ArchiveRO> {\n         unsafe {\n-            let s = CString::from_slice(dst.as_vec());\n+            let s = CString::new(dst.as_vec()).unwrap();\n             let ar = ::LLVMRustOpenArchive(s.as_ptr());\n             if ar.is_null() {\n                 None\n@@ -44,7 +44,7 @@ impl ArchiveRO {\n     pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n         unsafe {\n             let mut size = 0 as libc::size_t;\n-            let file = CString::from_slice(file.as_bytes());\n+            let file = CString::new(file).unwrap();\n             let ptr = ::LLVMRustArchiveReadSection(self.ptr, file.as_ptr(),\n                                                    &mut size);\n             if ptr.is_null() {"}, {"sha": "09a187befb2130ec01ccb05fb84f16265d300e86", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -25,7 +25,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(libc)]\n #![feature(link_args)]\n@@ -2149,7 +2148,7 @@ impl Drop for TargetData {\n }\n \n pub fn mk_target_data(string_rep: &str) -> TargetData {\n-    let string_rep = CString::from_slice(string_rep.as_bytes());\n+    let string_rep = CString::new(string_rep).unwrap();\n     TargetData {\n         lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) }\n     }"}, {"sha": "5662a74a53d34d087f06eae47370427c8e01d1e0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -585,10 +585,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, &msg[]);\n+                self.tcx.sess.span_err(span, &msg[..]);\n                 match note {\n                     Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, &msg[])\n+                        self.tcx.sess.span_note(span, &msg[..])\n                     }\n                     None => {},\n                 }\n@@ -690,7 +690,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n-        self.tcx.sess.span_err(span, &msg[]);\n+        self.tcx.sess.span_err(span, &msg[..]);\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope."}, {"sha": "333d32d76b6d5fc85c8f63ea874eec047c5a46e5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -20,7 +20,6 @@\n #![feature(alloc)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -1072,7 +1071,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                           &import_directive.module_path[],\n                                           import_directive.subclass),\n                                       help);\n-                    self.resolve_error(span, &msg[]);\n+                    self.resolve_error(span, &msg[..]);\n                 }\n                 Indeterminate => break, // Bail out. We'll come around next time.\n                 Success(()) => () // Good. Continue.\n@@ -1102,7 +1101,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         .iter()\n                                         .map(|seg| seg.identifier.name)\n                                         .collect();\n-        self.names_to_string(&names[])\n+        self.names_to_string(&names[..])\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n@@ -1166,7 +1165,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module_path = &import_directive.module_path;\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               self.names_to_string(&module_path[]),\n+               self.names_to_string(&module_path[..]),\n                self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -1175,7 +1174,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_.clone(),\n-                                           &module_path[],\n+                                           &module_path[..],\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -1768,7 +1767,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     ValueNS => \"value\",\n                                   },\n                                   &token::get_name(name));\n-                span_err!(self.session, import_span, E0252, \"{}\", &msg[]);\n+                span_err!(self.session, import_span, E0252, \"{}\", &msg[..]);\n             }\n             Some(_) | None => {}\n         }\n@@ -1783,7 +1782,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            span_err!(self.session, import_span, E0253, \"{}\", &msg[]);\n+            span_err!(self.session, import_span, E0253, \"{}\", &msg[..]);\n         }\n     }\n \n@@ -1804,7 +1803,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       &token::get_name(name));\n-                    span_err!(self.session, import_span, E0254, \"{}\", &msg[]);\n+                    span_err!(self.session, import_span, E0254, \"{}\", &msg[..]);\n                 }\n                 Some(_) | None => {}\n             }\n@@ -1826,7 +1825,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       &token::get_name(name));\n-                    span_err!(self.session, import_span, E0255, \"{}\", &msg[]);\n+                    span_err!(self.session, import_span, E0255, \"{}\", &msg[..]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -1844,7 +1843,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               &token::get_name(name));\n-                            span_err!(self.session, import_span, E0256, \"{}\", &msg[]);\n+                            span_err!(self.session, import_span, E0256, \"{}\", &msg[..]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -1857,7 +1856,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        span_err!(self.session, span, E0257, \"{}\", &msg[]);\n+                                        span_err!(self.session, span, E0257, \"{}\", &msg[..]);\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -1866,7 +1865,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       &token::get_name(name));\n-                                    span_err!(self.session, import_span, E0258, \"{}\", &msg[]);\n+                                    span_err!(self.session, import_span, E0258, \"{}\", &msg[..]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -1920,18 +1919,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 -> ResolveResult<(Rc<Module>, LastPrivate)> {\n         fn search_parent_externals(needle: Name, module: &Rc<Module>)\n                                 -> Option<Rc<Module>> {\n-            module.external_module_children.borrow()\n-                                            .get(&needle).cloned()\n-                                            .map(|_| module.clone())\n-                                            .or_else(|| {\n-                match module.parent_link.clone() {\n-                    ModuleParentLink(parent, _) => {\n-                        search_parent_externals(needle,\n-                                                &parent.upgrade().unwrap())\n+            match module.external_module_children.borrow().get(&needle) {\n+                Some(_) => Some(module.clone()),\n+                None => match module.parent_link {\n+                    ModuleParentLink(ref parent, _) => {\n+                        search_parent_externals(needle, &parent.upgrade().unwrap())\n                     }\n                    _ => None\n                 }\n-            })\n+            }\n         }\n \n         let mut search_module = module_;\n@@ -1953,7 +1949,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let segment_name = token::get_name(name);\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n-                    let msg = if \"???\" == &module_name[] {\n+                    let msg = if \"???\" == &module_name[..] {\n                         span.hi = span.lo + Pos::from_usize(segment_name.len());\n \n                         match search_parent_externals(name,\n@@ -2066,7 +2062,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = self.names_to_string(module_path);\n-                let mpath = &mpath[];\n+                let mpath = &mpath[..];\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n@@ -2369,11 +2365,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut containing_module;\n         let mut i;\n         let first_module_path_string = token::get_name(module_path[0]);\n-        if \"self\" == &first_module_path_string[] {\n+        if \"self\" == &first_module_path_string[..] {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 1;\n-        } else if \"super\" == &first_module_path_string[] {\n+        } else if \"super\" == &first_module_path_string[..] {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 0;  // We'll handle `super` below.\n@@ -2384,7 +2380,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Now loop through all the `super`s we find.\n         while i < module_path.len() {\n             let string = token::get_name(module_path[i]);\n-            if \"super\" != &string[] {\n+            if \"super\" != &string[..] {\n                 break\n             }\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n@@ -2515,7 +2511,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn);\n-                self.resolve_error((*imports)[index].span, &err[]);\n+                self.resolve_error((*imports)[index].span, &err[..]);\n             }\n         }\n \n@@ -2853,7 +2849,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             generics,\n                                             implemented_traits,\n                                             &**self_type,\n-                                            &impl_items[]);\n+                                            &impl_items[..]);\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n@@ -3196,7 +3192,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, &msg[]);\n+                self.resolve_error(trait_reference.path.span, &msg[..]);\n             }\n             Some(def) => {\n                 match def {\n@@ -3624,7 +3620,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(ty.span, &msg[]);\n+                        self.resolve_error(ty.span, &msg[..]);\n                     }\n                 }\n             }\n@@ -3825,7 +3821,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_names_to_string(path));\n-                            self.resolve_error(path.span, &msg[]);\n+                            self.resolve_error(path.span, &msg[..]);\n                         }\n                     }\n                 }\n@@ -4082,7 +4078,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n-                                       &module_path[],\n+                                       &module_path[..],\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n@@ -4140,7 +4136,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 &module_path[],\n+                                                 &module_path[..],\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n@@ -4150,7 +4146,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(&module_path[]));\n+                                          self.names_to_string(&module_path[..]));\n                         (path.span, msg)\n                     }\n                 };\n@@ -4309,7 +4305,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                &name_path[],\n+                                                &name_path[..],\n                                                 UseLexicalScope,\n                                                 span,\n                                                 PathSearch) {\n@@ -4347,7 +4343,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n \n         // Look for a method in the current self type's impl module.\n-        match get_module(self, path.span, &name_path[]) {\n+        match get_module(self, path.span, &name_path[..]) {\n             Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n@@ -4568,7 +4564,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(path.span, &msg[]);\n+                        self.resolve_error(path.span, &msg[..]);\n                     }\n                 }\n "}, {"sha": "ef849bb3dca056348147adbf6a0a154e5c9d2dd4", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -127,7 +127,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, &s[], span);\n+        creader::validate_crate_name(sess, &s[..], span);\n         s\n     };\n \n@@ -141,11 +141,11 @@ pub fn find_crate_name(sess: Option<&Session>,\n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n             if let Some((attr, ref name)) = attr_crate_name {\n-                if *s != &name[] {\n+                if *s != &name[..] {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n-                    sess.span_err(attr.span, &msg[]);\n+                    sess.span_err(attr.span, &msg[..]);\n                 }\n             }\n             return validate(s.clone(), None);\n@@ -195,7 +195,7 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in &*tcx.sess.crate_metadata.borrow() {\n-        symbol_hasher.input_str(&meta[]);\n+        symbol_hasher.input_str(&meta[..]);\n     }\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(&encoder::encoded_ty(tcx, t)[]);\n@@ -262,7 +262,7 @@ pub fn sanitize(s: &str) -> String {\n     if result.len() > 0 &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", &result[]);\n+        return format!(\"_{}\", &result[..]);\n     }\n \n     return result;\n@@ -331,17 +331,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n     hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n     hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n-    exported_name(path, &hash[])\n+    exported_name(path, &hash[..])\n }\n \n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n-    let path = [PathName(token::intern(&s[])),\n+    let path = [PathName(token::intern(&s[..])),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    mangle(path.iter().cloned(), Some(&hash[]))\n+    mangle(path.iter().cloned(), Some(&hash[..]))\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n@@ -541,7 +541,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     for &(ref l, kind) in &*sess.cstore.get_used_libraries().borrow() {\n         match kind {\n             cstore::NativeStatic => {\n-                ab.add_native_library(&l[]).unwrap();\n+                ab.add_native_library(&l[..]).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -619,7 +619,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                                                  e)[])\n                 };\n \n-                let bc_data_deflated = match flate::deflate_bytes(&bc_data[]) {\n+                let bc_data_deflated = match flate::deflate_bytes(&bc_data[..]) {\n                     Some(compressed) => compressed,\n                     None => sess.fatal(&format!(\"failed to compress bytecode from {}\",\n                                                bc_filename.display())[])\n@@ -678,7 +678,7 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n     try! { writer.write_all(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write_all(&bc_data_deflated[]) };\n+    try! { writer.write_all(&bc_data_deflated[..]) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -733,7 +733,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n                 continue\n             }\n         };\n-        ab.add_rlib(&p, &name[], sess.lto()).unwrap();\n+        ab.add_rlib(&p, &name[..], sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.into_iter());\n@@ -769,7 +769,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // The invocations of cc share some flags across platforms\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(&pname[]);\n+    let mut cmd = Command::new(&pname[..]);\n \n     cmd.args(&sess.target.target.options.pre_link_args[]);\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n@@ -798,7 +798,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                 sess.note(&format!(\"{:?}\", &cmd)[]);\n                 let mut output = prog.error.clone();\n                 output.push_all(&prog.output[]);\n-                sess.note(str::from_utf8(&output[]).unwrap());\n+                sess.note(str::from_utf8(&output[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n             debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n@@ -868,7 +868,7 @@ fn link_args(cmd: &mut Command,\n \n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(morestack.as_vec());\n-            cmd.arg(&v[]);\n+            cmd.arg(&v[..]);\n         } else {\n             cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n@@ -993,7 +993,7 @@ fn link_args(cmd: &mut Command,\n             if sess.opts.cg.rpath {\n                 let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n-                cmd.arg(&v[]);\n+                cmd.arg(&v[..]);\n             }\n         } else {\n             cmd.arg(\"-shared\");\n@@ -1029,7 +1029,7 @@ fn link_args(cmd: &mut Command,\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n     cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n-    cmd.args(&used_link_args[]);\n+    cmd.args(&used_link_args[..]);\n }\n \n // # Native library linking\n@@ -1086,14 +1086,14 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         } else {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n-            let lib = archive::find_library(&l[],\n+            let lib = archive::find_library(&l[..],\n                                             &sess.target.target.options.staticlib_prefix,\n                                             &sess.target.target.options.staticlib_suffix,\n-                                            &search_path[],\n+                                            &search_path[..],\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(lib.as_vec());\n-            cmd.arg(&v[]);\n+            cmd.arg(&v[..]);\n         }\n     }\n     if takes_hints {\n@@ -1106,7 +1106,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                 cmd.arg(format!(\"-l{}\", l));\n             }\n             cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(&l[]);\n+                cmd.arg(\"-framework\").arg(&l[..]);\n             }\n             cstore::NativeStatic => unreachable!(),\n         }\n@@ -1248,7 +1248,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n         let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n-        cmd.arg(&v[]);\n+        cmd.arg(&v[..]);\n     }\n }\n \n@@ -1290,7 +1290,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n                 }\n                 cstore::NativeFramework => {\n                     cmd.arg(\"-framework\");\n-                    cmd.arg(&lib[]);\n+                    cmd.arg(&lib[..]);\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "0a0f2a9c18627adeb821ca15e03c7f21b881119d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -132,15 +132,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                                                         bc_decoded.len() as libc::size_t) {\n                     write::llvm_err(sess.diagnostic().handler(),\n                                     format!(\"failed to load bc of `{}`\",\n-                                            &name[]));\n+                                            &name[..]));\n                 }\n             });\n         }\n     }\n \n     // Internalize everything but the reachable symbols of the current module\n     let cstrs: Vec<CString> = reachable.iter().map(|s| {\n-        CString::from_slice(s.as_bytes())\n+        CString::new(s.clone()).unwrap()\n     }).collect();\n     let arr: Vec<*const libc::c_char> = cstrs.iter().map(|c| c.as_ptr()).collect();\n     let ptr = arr.as_ptr();"}, {"sha": "86b720d3fc171191f451bb9bc31a32e4eedef4ef", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -22,7 +22,7 @@ use syntax::codemap;\n use syntax::diagnostic;\n use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n \n-use std::ffi::{self, CString};\n+use std::ffi::{CStr, CString};\n use std::old_io::Command;\n use std::old_io::fs;\n use std::iter::Unfold;\n@@ -47,14 +47,14 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            handler.fatal(&msg[]);\n+            handler.fatal(&msg[..]);\n         } else {\n-            let err = ffi::c_str_to_bytes(&cstr);\n+            let err = CStr::from_ptr(cstr).to_bytes();\n             let err = String::from_utf8_lossy(err).to_string();\n             libc::free(cstr as *mut _);\n             handler.fatal(&format!(\"{}: {}\",\n-                                  &msg[],\n-                                  &err[])[]);\n+                                  &msg[..],\n+                                  &err[..])[]);\n         }\n     }\n }\n@@ -67,7 +67,7 @@ pub fn write_output_file(\n         output: &Path,\n         file_type: llvm::FileType) {\n     unsafe {\n-        let output_c = CString::from_slice(output.as_vec());\n+        let output_c = CString::new(output.as_vec()).unwrap();\n         let result = llvm::LLVMRustWriteOutputFile(\n                 target, pm, m, output_c.as_ptr(), file_type);\n         if !result {\n@@ -105,7 +105,7 @@ impl SharedEmitter {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n                                            &diag.msg[],\n-                                           &code[],\n+                                           &code[..],\n                                            diag.lvl);\n                 },\n                 None => {\n@@ -165,7 +165,7 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n \n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => &s[],\n+        Some(ref s) => &s[..],\n         None => &sess.target.target.options.relocation_model[]\n     };\n     let reloc_model = match reloc_model_arg {\n@@ -198,7 +198,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let fdata_sections = ffunction_sections;\n \n     let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => &s[],\n+        Some(ref s) => &s[..],\n         None => &sess.target.target.options.code_model[]\n     };\n \n@@ -221,13 +221,13 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let triple = &sess.target.target.llvm_target[];\n \n     let tm = unsafe {\n-        let triple = CString::from_slice(triple.as_bytes());\n+        let triple = CString::new(triple.as_bytes()).unwrap();\n         let cpu = match sess.opts.cg.target_cpu {\n             Some(ref s) => &**s,\n             None => &*sess.target.target.options.cpu\n         };\n-        let cpu = CString::from_slice(cpu.as_bytes());\n-        let features = CString::from_slice(target_feature(sess).as_bytes());\n+        let cpu = CString::new(cpu.as_bytes()).unwrap();\n+        let features = CString::new(target_feature(sess).as_bytes()).unwrap();\n         llvm::LLVMRustCreateTargetMachine(\n             triple.as_ptr(), cpu.as_ptr(), features.as_ptr(),\n             code_model,\n@@ -365,7 +365,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     let msg = llvm::build_string(|s| llvm::LLVMWriteSMDiagnosticToString(diag, s))\n         .expect(\"non-UTF8 SMDiagnostic\");\n \n-    report_inline_asm(cgcx, &msg[], cookie);\n+    report_inline_asm(cgcx, &msg[..], cookie);\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n@@ -380,7 +380,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n         }\n \n         llvm::diagnostic::Optimization(opt) => {\n-            let pass_name = str::from_utf8(ffi::c_str_to_bytes(&opt.pass_name))\n+            let pass_name = str::from_utf8(CStr::from_ptr(opt.pass_name).to_bytes())\n                                 .ok()\n                                 .expect(\"got a non-UTF8 pass name from LLVM\");\n             let enabled = match cgcx.remark {\n@@ -424,7 +424,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n         let out = output_names.with_extension(&ext);\n-        let out = CString::from_slice(out.as_vec());\n+        let out = CString::new(out.as_vec()).unwrap();\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n@@ -440,7 +440,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             // If we're verifying or linting, add them to the function pass\n             // manager.\n             let addpass = |pass: &str| {\n-                let pass = CString::from_slice(pass.as_bytes());\n+                let pass = CString::new(pass).unwrap();\n                 llvm::LLVMRustAddPass(fpm, pass.as_ptr())\n             };\n             if !config.no_verify { assert!(addpass(\"verify\")); }\n@@ -453,7 +453,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             }\n \n             for pass in &config.passes {\n-                let pass = CString::from_slice(pass.as_bytes());\n+                let pass = CString::new(pass.clone()).unwrap();\n                 if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n                     cgcx.handler.warn(&format!(\"unknown pass {:?}, ignoring\", pass));\n                 }\n@@ -477,7 +477,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                     if config.emit_lto_bc {\n                         let name = format!(\"{}.lto.bc\", name_extra);\n                         let out = output_names.with_extension(&name);\n-                        let out = CString::from_slice(out.as_vec());\n+                        let out = CString::new(out.as_vec()).unwrap();\n                         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n                     }\n                 },\n@@ -511,15 +511,15 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     if config.emit_bc {\n         let ext = format!(\"{}.bc\", name_extra);\n         let out = output_names.with_extension(&ext);\n-        let out = CString::from_slice(out.as_vec());\n+        let out = CString::new(out.as_vec()).unwrap();\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     time(config.time_passes, \"codegen passes\", (), |()| {\n         if config.emit_ir {\n             let ext = format!(\"{}.ll\", name_extra);\n             let out = output_names.with_extension(&ext);\n-            let out = CString::from_slice(out.as_vec());\n+            let out = CString::new(out.as_vec()).unwrap();\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n             })\n@@ -711,7 +711,7 @@ pub fn run_passes(sess: &Session,\n             };\n \n         let pname = get_cc_prog(sess);\n-        let mut cmd = Command::new(&pname[]);\n+        let mut cmd = Command::new(&pname[..]);\n \n         cmd.args(&sess.target.target.options.pre_link_args[]);\n         cmd.arg(\"-nostdlib\");\n@@ -829,12 +829,12 @@ pub fn run_passes(sess: &Session,\n         for i in 0..trans.modules.len() {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(&ext[]));\n+                remove(sess, &crate_output.with_extension(&ext[..]));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(&ext[]));\n+                remove(sess, &crate_output.with_extension(&ext[..]));\n             }\n         }\n \n@@ -960,7 +960,7 @@ fn run_work_multithreaded(sess: &Session,\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(&pname[]);\n+    let mut cmd = Command::new(&pname[..]);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n@@ -975,7 +975,7 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n                 sess.note(&format!(\"{:?}\", &cmd)[]);\n                 let mut note = prog.error.clone();\n                 note.push_all(&prog.output[]);\n-                sess.note(str::from_utf8(&note[]).unwrap());\n+                sess.note(str::from_utf8(&note[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n@@ -1004,7 +1004,7 @@ unsafe fn configure_llvm(sess: &Session) {\n     let mut llvm_args = Vec::new();\n     {\n         let mut add = |arg: &str| {\n-            let s = CString::from_slice(arg.as_bytes());\n+            let s = CString::new(arg).unwrap();\n             llvm_args.push(s.as_ptr());\n             llvm_c_strs.push(s);\n         };"}, {"sha": "3deca436a1f903be1c63edf3aaed4cfe1639fc79", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -28,7 +28,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(old_io)]\n #![feature(env)]"}, {"sha": "8d2a2d51ee42366b6f78d8262abf701d8966481a", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -155,7 +155,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     &qualname[],\n+                                     &qualname[..],\n                                      self.cur_scope);\n         }\n     }\n@@ -178,7 +178,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     &qualname[],\n+                                     &qualname[..],\n                                      self.cur_scope);\n         }\n     }\n@@ -197,7 +197,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let (ref span, ref qualname) = sub_paths[len-2];\n         self.fmt.sub_type_ref_str(path.span,\n                                   *span,\n-                                  &qualname[]);\n+                                  &qualname[..]);\n \n         // write the other sub-paths\n         if len <= 2 {\n@@ -207,7 +207,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     &qualname[],\n+                                     &qualname[..],\n                                      self.cur_scope);\n         }\n     }\n@@ -280,7 +280,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     id,\n                                     qualname,\n                                     &path_to_string(p)[],\n-                                    &typ[]);\n+                                    &typ[..]);\n             }\n             self.collected_paths.clear();\n         }\n@@ -356,7 +356,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         };\n \n         let qualname = format!(\"{}::{}\", qualname, &get_ident(method.pe_ident()));\n-        let qualname = &qualname[];\n+        let qualname = &qualname[..];\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -436,9 +436,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         &name[],\n-                                                         &qualname[],\n-                                                         &typ[],\n+                                                         &name[..],\n+                                                         &qualname[..],\n+                                                         &typ[..],\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n                                                &format!(\"Could not find sub-span for field {}\",\n@@ -470,7 +470,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.typedef_str(full_span,\n                                  Some(*param_ss),\n                                  param.id,\n-                                 &name[],\n+                                 &name[..],\n                                  \"\");\n         }\n         self.visit_generics(generics);\n@@ -487,10 +487,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.fn_str(item.span,\n                         sub_span,\n                         item.id,\n-                        &qualname[],\n+                        &qualname[..],\n                         self.cur_scope);\n \n-        self.process_formals(&decl.inputs, &qualname[]);\n+        self.process_formals(&decl.inputs, &qualname[..]);\n \n         // walk arg and return types\n         for arg in &decl.inputs {\n@@ -504,7 +504,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n \n-        self.process_generic_params(ty_params, item.span, &qualname[], item.id);\n+        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n     }\n \n     fn process_static(&mut self,\n@@ -526,8 +526,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             &get_ident(item.ident),\n-                            &qualname[],\n-                            &value[],\n+                            &qualname[..],\n+                            &value[..],\n                             &ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n@@ -549,7 +549,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             &get_ident(item.ident),\n-                            &qualname[],\n+                            &qualname[..],\n                             \"\",\n                             &ty_to_string(&*typ)[],\n                             self.cur_scope);\n@@ -575,17 +575,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             ctor_id,\n-                            &qualname[],\n+                            &qualname[..],\n                             self.cur_scope,\n-                            &val[]);\n+                            &val[..]);\n \n         // fields\n         for field in &def.fields {\n-            self.process_struct_field_def(field, &qualname[], item.id);\n+            self.process_struct_field_def(field, &qualname[..], item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, &qualname[], item.id);\n+        self.process_generic_params(ty_params, item.span, &qualname[..], item.id);\n     }\n \n     fn process_enum(&mut self,\n@@ -598,9 +598,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n                                                 item.id,\n-                                                &enum_name[],\n+                                                &enum_name[..],\n                                                 self.cur_scope,\n-                                                &val[]),\n+                                                &val[..]),\n             None => self.sess.span_bug(item.span,\n                                        &format!(\"Could not find subspan for enum {}\",\n                                                enum_name)[]),\n@@ -619,9 +619,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                self.span.span_for_first_ident(variant.span),\n                                                variant.node.id,\n                                                name,\n-                                               &qualname[],\n-                                               &enum_name[],\n-                                               &val[],\n+                                               &qualname[..],\n+                                               &enum_name[..],\n+                                               &val[..],\n                                                item.id);\n                     for arg in args {\n                         self.visit_ty(&*arg.ty);\n@@ -637,9 +637,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         self.span.span_for_first_ident(variant.span),\n                         variant.node.id,\n                         ctor_id,\n-                        &qualname[],\n-                        &enum_name[],\n-                        &val[],\n+                        &qualname[..],\n+                        &enum_name[..],\n+                        &val[..],\n                         item.id);\n \n                     for field in &struct_def.fields {\n@@ -650,7 +650,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, &enum_name[], item.id);\n+        self.process_generic_params(ty_params, item.span, &enum_name[..], item.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -724,9 +724,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.trait_str(item.span,\n                            sub_span,\n                            item.id,\n-                           &qualname[],\n+                           &qualname[..],\n                            self.cur_scope,\n-                           &val[]);\n+                           &val[..]);\n \n         // super-traits\n         for super_bound in &**trait_refs {\n@@ -758,7 +758,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, &qualname[], item.id);\n+        self.process_generic_params(generics, item.span, &qualname[..], item.id);\n         for method in methods {\n             self.visit_trait_item(method)\n         }\n@@ -776,9 +776,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.mod_str(item.span,\n                          sub_span,\n                          item.id,\n-                         &qualname[],\n+                         &qualname[..],\n                          self.cur_scope,\n-                         &filename[]);\n+                         &filename[..]);\n \n         self.nest(item.id, |v| visit::walk_mod(v, m));\n     }\n@@ -990,7 +990,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                self.cur_scope);\n \n         // walk receiver and args\n-        visit::walk_exprs(self, &args[]);\n+        visit::walk_exprs(self, &args[..]);\n     }\n \n     fn process_pat(&mut self, p:&ast::Pat) {\n@@ -1164,7 +1164,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           item.id,\n                                           cnum,\n                                           name,\n-                                          &location[],\n+                                          &location[..],\n                                           self.cur_scope);\n             }\n             ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n@@ -1196,8 +1196,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n-                                     &qualname[],\n-                                     &value[]);\n+                                     &qualname[..],\n+                                     &value[..]);\n \n                 self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, &qualname, item.id);\n@@ -1260,7 +1260,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 };\n \n                 qualname.push_str(&get_ident(method_type.ident));\n-                let qualname = &qualname[];\n+                let qualname = &qualname[..];\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n                 self.fmt.method_decl_str(method_type.span,\n@@ -1401,7 +1401,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n                 let mut id = String::from_str(\"$\");\n                 id.push_str(&ex.id.to_string()[]);\n-                self.process_formals(&decl.inputs, &id[]);\n+                self.process_formals(&decl.inputs, &id[..]);\n \n                 // walk arg and return types\n                 for arg in &decl.inputs {\n@@ -1464,7 +1464,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           Some(p.span),\n                                           id,\n                                           &path_to_string(p)[],\n-                                          &value[],\n+                                          &value[..],\n                                           \"\")\n                 }\n                 def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n@@ -1520,8 +1520,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                   sub_span,\n                                   id,\n                                   &path_to_string(p)[],\n-                                  &value[],\n-                                  &typ[]);\n+                                  &value[..],\n+                                  &typ[..]);\n         }\n         self.collected_paths.clear();\n \n@@ -1603,7 +1603,7 @@ pub fn process_crate(sess: &Session,\n         cur_scope: 0\n     };\n \n-    visitor.dump_crate_info(&cratename[], krate);\n+    visitor.dump_crate_info(&cratename[..], krate);\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "08e36bb1d85bb3eefc504b5c81b7244c7fff5ba5", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -43,7 +43,7 @@ impl Recorder {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n                              kind, su.extent_str(span), escape(su.snippet(span)));\n-        self.record(&result[]);\n+        self.record(&result[..]);\n     }\n }\n \n@@ -170,14 +170,14 @@ impl<'a> FmtStrs<'a> {\n             if s.len() > 1020 {\n                 &s[..1020]\n             } else {\n-                &s[]\n+                &s[..]\n             }\n         });\n \n         let pairs = fields.iter().zip(values);\n         let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from_str(v))));\n         Some(strs.fold(String::new(), |mut s, ss| {\n-            s.push_str(&ss[]);\n+            s.push_str(&ss[..]);\n             s\n         }))\n     }\n@@ -205,9 +205,9 @@ impl<'a> FmtStrs<'a> {\n         };\n \n         let mut result = String::from_str(label);\n-        result.push_str(&values_str[]);\n+        result.push_str(&values_str[..]);\n         result.push_str(\"\\n\");\n-        self.recorder.record(&result[]);\n+        self.recorder.record(&result[..]);\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -238,7 +238,7 @@ impl<'a> FmtStrs<'a> {\n             None => return,\n         };\n         let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n-        self.recorder.record(&result[]);\n+        self.recorder.record(&result[..]);\n     }\n \n     pub fn check_and_record(&mut self,"}, {"sha": "2826afb71a2c23cfcc945a66c908b6c806a7a3c3", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -566,7 +566,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         param_env: param_env,\n     };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, &pats[], &ctor, col, variant_size)\n+        check_match::specialize(&mcx, &pats[..], &ctor, col, variant_size)\n     )\n }\n \n@@ -987,7 +987,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if has_nested_bindings(m, col) {\n                 let expanded = expand_nested_bindings(bcx, m, col, val);\n                 compile_submatch_continue(bcx,\n-                                          &expanded[],\n+                                          &expanded[..],\n                                           vals,\n                                           chk,\n                                           col,\n@@ -1233,10 +1233,10 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;\n-        opt_vals.push_all(&vals_left[]);\n+        opt_vals.push_all(&vals_left[..]);\n         compile_submatch(opt_cx,\n-                         &opt_ms[],\n-                         &opt_vals[],\n+                         &opt_ms[..],\n+                         &opt_vals[..],\n                          branch_chk.as_ref().unwrap_or(chk),\n                          has_genuine_default);\n     }\n@@ -1255,8 +1255,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             _ => {\n                 compile_submatch(else_cx,\n-                                 &defaults[],\n-                                 &vals_left[],\n+                                 &defaults[..],\n+                                 &vals_left[..],\n                                  chk,\n                                  has_genuine_default);\n             }\n@@ -1468,7 +1468,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, &matches[], &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, &matches[..], &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in &arm_datas {\n@@ -1482,7 +1482,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, &arm_cxs[]);\n+    bcx = scope_cx.fcx.join_blocks(match_id, &arm_cxs[..]);\n     return bcx;\n }\n "}, {"sha": "eaf6eaa2f089d1273bec3b9f574fa24be70d68dc", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -155,7 +155,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, &elems[], false, t), false)\n+            Univariant(mk_struct(cx, &elems[..], false, t), false)\n         }\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -167,13 +167,13 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(cx.tcx().types.bool); }\n \n-            Univariant(mk_struct(cx, &ftys[], packed, t), dtor)\n+            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor)\n         }\n         ty::ty_closure(def_id, _, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, &upvar_types[], false, t), false)\n+            Univariant(mk_struct(cx, &upvar_types[..], false, t), false)\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n@@ -187,7 +187,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n-                return Univariant(mk_struct(cx, &ftys[], false, t),\n+                return Univariant(mk_struct(cx, &ftys[..], false, t),\n                                   dtor);\n             }\n \n@@ -219,7 +219,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                return Univariant(mk_struct(cx, &ftys[], false, t),\n+                return Univariant(mk_struct(cx, &ftys[..], false, t),\n                                   dtor);\n             }\n \n@@ -320,10 +320,10 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n                 ftys.push_all(&c.tys[]);\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                mk_struct(cx, &ftys[], false, t)\n+                mk_struct(cx, &ftys[..], false, t)\n             }).collect();\n \n-            ensure_enum_fits_in_address_space(cx, &fields[], t);\n+            ensure_enum_fits_in_address_space(cx, &fields[..], t);\n \n             General(ity, fields, dtor)\n         }\n@@ -453,9 +453,9 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n-    ensure_struct_fits_in_address_space(cx, &lltys[], packed, scapegoat);\n+    ensure_struct_fits_in_address_space(cx, &lltys[..], packed, scapegoat);\n \n-    let llty_rec = Type::struct_(cx, &lltys[], packed);\n+    let llty_rec = Type::struct_(cx, &lltys[..], packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec),\n         align: machine::llalign_of_min(cx, llty_rec),\n@@ -659,7 +659,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let (size, align) = union_size_and_align(&sts[]);\n+            let (size, align) = union_size_and_align(&sts[..]);\n             let align_s = align as u64;\n             assert_eq!(size % align_s, 0);\n             let align_units = size / align_s - 1;\n@@ -682,10 +682,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           Type::array(&discr_ty, align_s / discr_size - 1),\n                           fill_ty];\n             match name {\n-                None => Type::struct_(cx, &fields[], false),\n+                None => Type::struct_(cx, &fields[..], false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&fields[], false);\n+                    llty.set_struct_body(&fields[..], false);\n                     llty\n                 }\n             }\n@@ -763,7 +763,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n \n fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &DiscrField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = GEPi(bcx, scrutinee, &discrfield[]);\n+    let llptrptr = GEPi(bcx, scrutinee, &discrfield[..]);\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)), DebugLoc::None)\n@@ -851,7 +851,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n-                let llptrptr = GEPi(bcx, val, &discrfield[]);\n+                let llptrptr = GEPi(bcx, val, &discrfield[..]);\n                 let llptrty = val_ty(llptrptr).element_type();\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n@@ -933,7 +933,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, &fields[], st.packed);\n+        let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -972,7 +972,7 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n                 let fields = case.fields.iter().map(|&ty|\n                     type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n-                let real_ty = Type::struct_(ccx, &fields[], case.packed);\n+                let real_ty = Type::struct_(ccx, &fields[..], case.packed);\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n@@ -1045,18 +1045,18 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n         }\n         General(ity, ref cases, _) => {\n             let case = &cases[discr as uint];\n-            let (max_sz, _) = union_size_and_align(&cases[]);\n+            let (max_sz, _) = union_size_and_align(&cases[..]);\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n             f.push_all(vals);\n-            let mut contents = build_const_struct(ccx, case, &f[]);\n+            let mut contents = build_const_struct(ccx, case, &f[..]);\n             contents.push_all(&[padding(ccx, max_sz - case.size)]);\n-            C_struct(ccx, &contents[], false)\n+            C_struct(ccx, &contents[..], false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(ccx, &contents[], st.packed)\n+            C_struct(ccx, &contents[..], st.packed)\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             if discr == nndiscr {\n@@ -1080,7 +1080,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                 }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 &vals[])[],\n+                                                 &vals[..])[],\n                          false)\n             }\n         }"}, {"sha": "a3bd0cf6b1a623bac1cf719408aa45f7d1696859", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -71,7 +71,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>();\n-    inputs.push_all(&ext_inputs[]);\n+    inputs.push_all(&ext_inputs[..]);\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -91,18 +91,18 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         if !clobbers.is_empty() {\n             clobbers.push(',');\n         }\n-        clobbers.push_str(&more_clobbers[]);\n+        clobbers.push_str(&more_clobbers[..]);\n     }\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n         constraints.push(',');\n-        constraints.push_str(&clobbers[]);\n+        constraints.push_str(&clobbers[..]);\n     } else {\n-        constraints.push_str(&clobbers[]);\n+        constraints.push_str(&clobbers[..]);\n     }\n \n-    debug!(\"Asm Constraints: {}\", &constraints[]);\n+    debug!(\"Asm Constraints: {}\", &constraints[..]);\n \n     let num_outputs = outputs.len();\n \n@@ -112,16 +112,16 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     } else if num_outputs == 1 {\n         output_types[0]\n     } else {\n-        Type::struct_(bcx.ccx(), &output_types[], false)\n+        Type::struct_(bcx.ccx(), &output_types[..], false)\n     };\n \n     let dialect = match ia.dialect {\n         ast::AsmAtt   => llvm::AD_ATT,\n         ast::AsmIntel => llvm::AD_Intel\n     };\n \n-    let asm = CString::from_slice(ia.asm.as_bytes());\n-    let constraints = CString::from_slice(constraints.as_bytes());\n+    let asm = CString::new(ia.asm.as_bytes()).unwrap();\n+    let constraints = CString::new(constraints).unwrap();\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),\n                           constraints.as_ptr(),"}, {"sha": "3091c852f5587baa80a11f567d4cc31104f72f43", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -86,7 +86,7 @@ use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n use libc::{c_uint, uint64_t};\n-use std::ffi::{self, CString};\n+use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::mem;\n@@ -186,7 +186,7 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n                ty: Type, output: ty::FnOutput) -> ValueRef {\n \n-    let buf = CString::from_slice(name.as_bytes());\n+    let buf = CString::new(name).unwrap();\n     let llfn: ValueRef = unsafe {\n         llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf.as_ptr(), ty.to_ref())\n     };\n@@ -247,7 +247,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n-    set_llvm_fn_attrs(ccx, &attrs[], f);\n+    set_llvm_fn_attrs(ccx, &attrs[..], f);\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n     f\n@@ -340,7 +340,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n         None => ()\n     }\n     unsafe {\n-        let buf = CString::from_slice(name.as_bytes());\n+        let buf = CString::new(name.clone()).unwrap();\n         let c = llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf.as_ptr());\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n@@ -523,7 +523,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n-                      &name[],\n+                      &name[..],\n                       llvm::CCallConv,\n                       llty,\n                       dtor_ty)\n@@ -898,14 +898,14 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n-                    get_extern_rust_fn(ccx, t, &name[], did)\n+                    get_extern_rust_fn(ccx, t, &name[..], did)\n                 }\n                 RustIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n-                                                      &name[])\n+                                                      &name[..])\n                 }\n             }\n         }\n@@ -947,7 +947,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              &llargs[],\n+                              &llargs[..],\n                               normal_bcx.llbb,\n                               landing_pad,\n                               Some(attributes),\n@@ -961,7 +961,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Call(bcx,\n                             llfn,\n-                            &llargs[],\n+                            &llargs[..],\n                             Some(attributes),\n                             debug_loc);\n         return (llresult, bcx);\n@@ -1219,19 +1219,6 @@ pub fn alloca_zeroed<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n     p\n }\n \n-pub fn arrayalloca(cx: Block, ty: Type, v: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"arrayalloca\");\n-    if cx.unreachable.get() {\n-        unsafe {\n-            return llvm::LLVMGetUndef(ty.to_ref());\n-        }\n-    }\n-    debuginfo::clear_source_location(cx.fcx);\n-    let p = ArrayAlloca(cx, ty, v);\n-    call_lifetime_start(cx, p);\n-    p\n-}\n-\n // Creates the alloca slot which holds the pointer to the slot for the final return value\n pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                                           output_type: Ty<'tcx>) -> ValueRef {\n@@ -1646,7 +1633,7 @@ fn copy_closure_args_to_allocas<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n     let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => &types[],\n+        ty::ty_tup(ref types) => &types[..],\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1834,12 +1821,12 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n-                                  &monomorphized_arg_types[])\n+                                  &monomorphized_arg_types[..])\n     } else {\n         create_datums_for_fn_args_under_call_abi(\n             bcx,\n             arg_scope,\n-            &monomorphized_arg_types[])\n+            &monomorphized_arg_types[..])\n     };\n \n     bcx = match closure_env {\n@@ -1855,7 +1842,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 arg_scope,\n                 &decl.inputs[],\n                 arg_datums,\n-                &monomorphized_arg_types[])\n+                &monomorphized_arg_types[..])\n         }\n     };\n \n@@ -2000,7 +1987,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n                                       disr,\n-                                      &fields[],\n+                                      &fields[..],\n                                       None,\n                                       expr::SaveIn(llresult),\n                                       debug_loc);\n@@ -2070,7 +2057,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         ty::erase_late_bound_regions(\n             ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, &arg_tys[]);\n+    let arg_datums = create_datums_for_fn_args(&fcx, &arg_tys[..]);\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n@@ -2315,7 +2302,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n                          item.ident,\n-                         &impl_items[],\n+                         &impl_items[..],\n                          generics,\n                          item.id);\n       }\n@@ -2430,7 +2417,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected bare rust fn\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, node_type, &sym[]);\n+    let llfn = decl_rust_fn(ccx, node_type, &sym[..]);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2475,7 +2462,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n \n             match fn_sig.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(&t_in[]);\n+                    inputs.push_all(&t_in[..]);\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n@@ -2611,7 +2598,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n     let llfn = decl_fn(ccx,\n-                       &sym[],\n+                       &sym[..],\n                        cc,\n                        llfty,\n                        ty::FnConverging(ty::mk_nil(ccx.tcx())));\n@@ -2667,7 +2654,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(&s[]); }\n+                    Err(s) => { ccx.sess().fatal(&s[..]); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -2783,12 +2770,12 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(&sym[]) {\n+                        if contains_null(&sym[..]) {\n                             ccx.sess().fatal(\n                                 &format!(\"Illegal null byte in export_name \\\n                                          value: `{}`\", sym)[]);\n                         }\n-                        let buf = CString::from_slice(sym.as_bytes());\n+                        let buf = CString::new(sym.clone()).unwrap();\n                         let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n                                                     buf.as_ptr());\n \n@@ -2826,7 +2813,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                  &sect)[]);\n                     }\n                     unsafe {\n-                        let buf = CString::from_slice(sect.as_bytes());\n+                        let buf = CString::new(sect.as_bytes()).unwrap();\n                         llvm::LLVMSetSection(v, buf.as_ptr());\n                     }\n                 },\n@@ -2988,20 +2975,20 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n         Some(compressed) => compressed,\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n     });\n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[]);\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[..]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n                        cx.link_meta().crate_hash);\n-    let buf = CString::from_vec(name.into_bytes());\n+    let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n         llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(),\n                             buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n         let name = loader::meta_section_name(cx.sess().target.target.options.is_like_osx);\n-        let name = CString::from_slice(name.as_bytes());\n+        let name = CString::new(name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr())\n     }\n     return metadata;\n@@ -3039,8 +3026,8 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                     continue\n                 }\n \n-                let name = ffi::c_str_to_bytes(&llvm::LLVMGetValueName(val))\n-                               .to_vec();\n+                let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n+                                .to_bytes().to_vec();\n                 declared.insert(name);\n             }\n         }\n@@ -3056,8 +3043,8 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                     continue\n                 }\n \n-                let name = ffi::c_str_to_bytes(&llvm::LLVMGetValueName(val))\n-                               .to_vec();\n+                let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n+                                .to_bytes().to_vec();\n                 if !declared.contains(&name) &&\n                    !reachable.contains(str::from_utf8(&name).unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);\n@@ -3211,7 +3198,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     reachable.push(\"rust_eh_personality_catch\".to_string());\n \n     if codegen_units > 1 {\n-        internalize_symbols(&shared_ccx, &reachable.iter().map(|x| x.clone()).collect());\n+        internalize_symbols(&shared_ccx, &reachable.iter().cloned().collect());\n     }\n \n     let metadata_module = ModuleTranslation {"}, {"sha": "8199e6189c93b495c926ac1d9715ee29b1ddb90f", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -431,7 +431,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n-                let name = CString::from_slice(name.as_bytes());\n+                let name = CString::new(name).unwrap();\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n                                       name.as_ptr())\n             }\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, &v[])\n+            self.inbounds_gep(base, &v[..])\n         }\n     }\n \n@@ -775,8 +775,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let s = format!(\"{} ({})\",\n                             text,\n                             self.ccx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", &s[]);\n-            self.add_comment(&s[]);\n+            debug!(\"{}\", &s[..]);\n+            self.add_comment(&s[..]);\n         }\n     }\n \n@@ -786,7 +786,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let comment_text = format!(\"{} {}\", \"#\",\n                                        sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let comment_text = CString::from_vec(comment_text.into_bytes());\n+            let comment_text = CString::new(comment_text).unwrap();\n             let asm = unsafe {\n                 llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n                                          comment_text.as_ptr(), noname(), False,\n@@ -813,7 +813,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n-        let fty = Type::func(&argtys[], &output);\n+        let fty = Type::func(&argtys[..], &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);"}, {"sha": "3d3e35cd776f0fd311affbe03d9188f46312d44c", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -323,7 +323,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx,\n                               tuple_fn_ty,\n-                              &function_name[]);\n+                              &function_name[..]);\n \n     //\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n@@ -359,7 +359,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            DebugLoc::None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(&llargs[]),\n+                           ArgVals(&llargs[..]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n@@ -792,7 +792,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n                                       llfn,\n-                                      &llargs[],\n+                                      &llargs[..],\n                                       callee_ty,\n                                       debug_loc);\n         bcx = b;\n@@ -833,7 +833,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                          callee_ty,\n                                          llfn,\n                                          opt_llretslot.unwrap(),\n-                                         &llargs[],\n+                                         &llargs[..],\n                                          arg_tys,\n                                          debug_loc);\n     }"}, {"sha": "85e53618f6da9c7ed664b3a0e1643664d59eaab8", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -764,7 +764,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n                 let bcx_in = self.new_block(label.is_unwind(),\n-                                            &name[],\n+                                            &name[..],\n                                             None);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n@@ -811,7 +811,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => { return llbb; }\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, &name[], None);\n+                    pad_bcx = self.new_block(true, &name[..], None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }"}, {"sha": "1d4bbd79d71057baecdc624201e5d7a367355068", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -158,7 +158,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[]);\n+    let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[..]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -208,7 +208,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let function_type = typer.closure_type(closure_id, param_substs);\n \n     let freevars: Vec<ty::Freevar> =\n-        ty::with_freevars(tcx, id, |fv| fv.iter().map(|&fv| fv).collect());\n+        ty::with_freevars(tcx, id, |fv| fv.iter().cloned().collect());\n \n     let sig = ty::erase_late_bound_regions(tcx, &function_type.sig);\n \n@@ -221,7 +221,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                   &[],\n                   sig.output,\n                   function_type.abi,\n-                  ClosureEnv::Closure(&freevars[]));\n+                  ClosureEnv::Closure(&freevars[..]));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and"}, {"sha": "a9cda94bebac52513d98848c30cf01ca6a7262d5", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -488,7 +488,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                      opt_node_id: Option<ast::NodeId>)\n                      -> Block<'a, 'tcx> {\n         unsafe {\n-            let name = CString::from_slice(name.as_bytes());\n+            let name = CString::new(name).unwrap();\n             let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n                                                            self.llfn,\n                                                            name.as_ptr());\n@@ -757,7 +757,7 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        let s = CString::from_slice(s.as_bytes());\n+        let s = CString::new(s).unwrap();\n         llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n     }\n }\n@@ -835,7 +835,8 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let buf = CString::from_vec(format!(\"str{}\", gsym.usize()).into_bytes());\n+        let buf = CString::new(format!(\"str{}\", gsym.usize()));\n+        let buf = buf.unwrap();\n         let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n@@ -1161,8 +1162,8 @@ pub fn langcall(bcx: Block,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => bcx.tcx().sess.span_fatal(span, &msg[]),\n-                None => bcx.tcx().sess.fatal(&msg[]),\n+                Some(span) => bcx.tcx().sess.span_fatal(span, &msg[..]),\n+                None => bcx.tcx().sess.fatal(&msg[..]),\n             }\n         }\n     }"}, {"sha": "7705b53ee38c69ad7a4c74254666fc3901776dbe", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -75,7 +75,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitBinary(ref data) => {\n-            let g = addr_of(cx, C_bytes(cx, &data[]), \"binary\", e.id);\n+            let g = addr_of(cx, C_bytes(cx, &data[..]), \"binary\", e.id);\n             let base = ptrcast(g, Type::i8p(cx));\n             let prev_const = cx.const_unsized().borrow_mut()\n                                .insert(base, g);\n@@ -611,8 +611,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           }\n           ast::ExprTup(ref es) => {\n               let repr = adt::represent_type(cx, ety);\n-              let vals = map_list(&es[]);\n-              adt::trans_const(cx, &*repr, 0, &vals[])\n+              let vals = map_list(&es[..]);\n+              adt::trans_const(cx, &*repr, 0, &vals[..])\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let repr = adt::represent_type(cx, ety);\n@@ -642,9 +642,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       }\n                   }).collect::<Vec<_>>();\n                   if ty::type_is_simd(cx.tcx(), ety) {\n-                      C_vector(&cs[])\n+                      C_vector(&cs[..])\n                   } else {\n-                      adt::trans_const(cx, &*repr, discr, &cs[])\n+                      adt::trans_const(cx, &*repr, discr, &cs[..])\n                   }\n               })\n           }\n@@ -655,9 +655,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                               .collect::<Vec<_>>();\n             // If the vector contains enums, an LLVM array won't work.\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, &vs[], false)\n+                C_struct(cx, &vs[..], false)\n             } else {\n-                C_array(llunitty, &vs[])\n+                C_array(llunitty, &vs[..])\n             }\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n@@ -671,9 +671,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_val = const_expr(cx, &**elem, param_substs).0;\n             let vs: Vec<_> = repeat(unit_val).take(n).collect();\n             if val_ty(unit_val) != llunitty {\n-                C_struct(cx, &vs[], false)\n+                C_struct(cx, &vs[..], false)\n             } else {\n-                C_array(llunitty, &vs[])\n+                C_array(llunitty, &vs[..])\n             }\n           }\n           ast::ExprPath(_) | ast::ExprQPath(_) => {\n@@ -715,14 +715,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           }\n           ast::ExprCall(ref callee, ref args) => {\n               let opt_def = cx.tcx().def_map.borrow().get(&callee.id).cloned();\n-              let arg_vals = map_list(&args[]);\n+              let arg_vals = map_list(&args[..]);\n               match opt_def {\n                   Some(def::DefStruct(_)) => {\n                       if ty::type_is_simd(cx.tcx(), ety) {\n-                          C_vector(&arg_vals[])\n+                          C_vector(&arg_vals[..])\n                       } else {\n                           let repr = adt::represent_type(cx, ety);\n-                          adt::trans_const(cx, &*repr, 0, &arg_vals[])\n+                          adt::trans_const(cx, &*repr, 0, &arg_vals[..])\n                       }\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n@@ -733,7 +733,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n-                                       &arg_vals[])\n+                                       &arg_vals[..])\n                   }\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }"}, {"sha": "eb07bdb7ba11bb6a860a2c71a1b462f440d196e5", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -225,15 +225,15 @@ impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n \n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n-    let mod_name = CString::from_slice(mod_name.as_bytes());\n+    let mod_name = CString::new(mod_name).unwrap();\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n-    let data_layout = &*sess.target.target.data_layout;\n-    let data_layout = CString::from_slice(data_layout.as_bytes());\n+    let data_layout = sess.target.target.data_layout.as_bytes();\n+    let data_layout = CString::new(data_layout).unwrap();\n     llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n \n-    let llvm_target = &*sess.target.target.llvm_target;\n-    let llvm_target = CString::from_slice(llvm_target.as_bytes());\n+    let llvm_target = sess.target.target.llvm_target.as_bytes();\n+    let llvm_target = CString::new(llvm_target).unwrap();\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n     (llcx, llmod)\n }\n@@ -288,7 +288,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n             let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n-            let local_ccx = LocalCrateContext::new(&shared_ccx, &llmod_id[]);\n+            let local_ccx = LocalCrateContext::new(&shared_ccx, &llmod_id[..]);\n             shared_ccx.local_ccxs.push(local_ccx);\n         }\n "}, {"sha": "26e12a1af403dac45981d8bd2e4751c9f60fec69", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -177,7 +177,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let name = format!(\"then-block-{}-\", thn.id);\n-    let then_bcx_in = bcx.fcx.new_id_block(&name[], thn.id);\n+    let then_bcx_in = bcx.fcx.new_id_block(&name[..], thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n@@ -378,7 +378,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      &args[],\n+                                      &args[..],\n                                       Some(expr::Ignore),\n                                       call_info.debug_loc()).bcx;\n     Unreachable(bcx);\n@@ -407,7 +407,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      &args[],\n+                                      &args[..],\n                                       Some(expr::Ignore),\n                                       call_info.debug_loc()).bcx;\n     Unreachable(bcx);"}, {"sha": "fc0129239aac7e9b316749ef013d818c528b7602", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -299,7 +299,7 @@ impl<'tcx> TypeMap<'tcx> {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  &unique_type_id_str[])[]);\n+                                  &unique_type_id_str[..])[]);\n         }\n     }\n \n@@ -380,14 +380,14 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, component_type);\n                     let component_type_id =\n                         self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(&component_type_id[]);\n+                    unique_type_id.push_str(&component_type_id[..]);\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n                 unique_type_id.push('~');\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[]);\n+                unique_type_id.push_str(&inner_type_id[..]);\n             },\n             ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n                 unique_type_id.push('*');\n@@ -397,7 +397,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[]);\n+                unique_type_id.push_str(&inner_type_id[..]);\n             },\n             ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n                 unique_type_id.push('&');\n@@ -407,7 +407,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[]);\n+                unique_type_id.push_str(&inner_type_id[..]);\n             },\n             ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n@@ -421,7 +421,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[]);\n+                unique_type_id.push_str(&inner_type_id[..]);\n             },\n             ty::ty_trait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n@@ -452,7 +452,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n                         self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(&parameter_type_id[]);\n+                    unique_type_id.push_str(&parameter_type_id[..]);\n                     unique_type_id.push(',');\n                 }\n \n@@ -465,7 +465,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(&return_type_id[]);\n+                        unique_type_id.push_str(&return_type_id[..]);\n                     }\n                     ty::FnDiverging => {\n                         unique_type_id.push_str(\"!\");\n@@ -538,7 +538,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n                         type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(&param_type_id[]);\n+                    output.push_str(&param_type_id[..]);\n                     output.push(',');\n                 }\n \n@@ -568,7 +568,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n                 self.get_unique_type_id_as_string(parameter_type_id);\n-            unique_type_id.push_str(&parameter_type_id[]);\n+            unique_type_id.push_str(&parameter_type_id[..]);\n             unique_type_id.push(',');\n         }\n \n@@ -582,7 +582,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(&return_type_id[]);\n+                unique_type_id.push_str(&return_type_id[..]);\n             }\n             ty::FnDiverging => {\n                 unique_type_id.push_str(\"!\");\n@@ -806,11 +806,11 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_ident(ident).to_string();\n     let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(&var_name[]);\n+        namespace_node.mangled_name_of_contained_item(&var_name[..]);\n     let var_scope = namespace_node.scope;\n \n-    let var_name = CString::from_slice(var_name.as_bytes());\n-    let linkage_name = CString::from_slice(linkage_name.as_bytes());\n+    let var_name = CString::new(var_name).unwrap();\n+    let linkage_name = CString::new(linkage_name).unwrap();\n     unsafe {\n         llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n                                                 var_scope,\n@@ -1287,7 +1287,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match expr.node {\n                 ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::str_to_ident(&name[]);\n+                    let name = token::str_to_ident(&name[..]);\n                     (name, &**fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n@@ -1366,7 +1366,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (linkage_name, containing_scope) = if has_path {\n         let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n-            &function_name[]);\n+            &function_name[..]);\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n@@ -1379,8 +1379,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n \n-    let function_name = CString::from_slice(function_name.as_bytes());\n-    let linkage_name = CString::from_slice(linkage_name.as_bytes());\n+    let function_name = CString::new(function_name).unwrap();\n+    let linkage_name = CString::new(linkage_name).unwrap();\n     let fn_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateFunction(\n             DIB(cx),\n@@ -1451,7 +1451,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n-        return create_DIArray(DIB(cx), &signature[]);\n+        return create_DIArray(DIB(cx), &signature[..]);\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1486,7 +1486,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 actual_self_type,\n                 true);\n \n-            name_to_append_suffix_to.push_str(&actual_self_type_name[]);\n+            name_to_append_suffix_to.push_str(&actual_self_type_name[..]);\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1501,7 +1501,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let ident = special_idents::type_self;\n \n                 let ident = token::get_ident(ident);\n-                let name = CString::from_slice(ident.as_bytes());\n+                let name = CString::new(ident.as_bytes()).unwrap();\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -1525,7 +1525,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n-            name_to_append_suffix_to.push_str(&actual_type_name[]);\n+            name_to_append_suffix_to.push_str(&actual_type_name[..]);\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1535,7 +1535,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n                 let ident = token::get_ident(ident);\n-                let name = CString::from_slice(ident.as_bytes());\n+                let name = CString::new(ident.as_bytes()).unwrap();\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -1552,7 +1552,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         name_to_append_suffix_to.push('>');\n \n-        return create_DIArray(DIB(cx), &template_params[]);\n+        return create_DIArray(DIB(cx), &template_params[..]);\n     }\n }\n \n@@ -1601,7 +1601,7 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                             path_bytes.insert(1, prefix[1]);\n                         }\n \n-                        CString::from_vec(path_bytes)\n+                        CString::new(path_bytes).unwrap()\n                     }\n                     _ => fallback_path(cx)\n                 }\n@@ -1614,8 +1614,8 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n     let compile_unit_name = compile_unit_name.as_ptr();\n-    let work_dir = CString::from_slice(work_dir.as_vec());\n-    let producer = CString::from_slice(producer.as_bytes());\n+    let work_dir = CString::new(work_dir.as_vec()).unwrap();\n+    let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n     return unsafe {\n@@ -1632,7 +1632,7 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n     };\n \n     fn fallback_path(cx: &CrateContext) -> CString {\n-        CString::from_slice(cx.link_meta().crate_name.as_bytes())\n+        CString::new(cx.link_meta().crate_name.clone()).unwrap()\n     }\n }\n \n@@ -1646,7 +1646,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, &filename[]);\n+    let file_metadata = file_metadata(cx, &filename[..]);\n \n     let name = token::get_ident(variable_ident);\n     let loc = span_start(cx, span);\n@@ -1658,7 +1658,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n \n-    let name = CString::from_slice(name.as_bytes());\n+    let name = CString::new(name.as_bytes()).unwrap();\n     match (variable_access, [].as_slice()) {\n         (DirectVariable { alloca }, address_operations) |\n         (IndirectVariable {alloca, address_operations}, _) => {\n@@ -1724,8 +1724,8 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n             full_path\n         };\n \n-    let file_name = CString::from_slice(file_name.as_bytes());\n-    let work_dir = CString::from_slice(work_dir.as_bytes());\n+    let file_name = CString::new(file_name).unwrap();\n+    let work_dir = CString::new(work_dir).unwrap();\n     let file_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n                                       work_dir.as_ptr())\n@@ -1800,7 +1800,7 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let name = CString::from_slice(name.as_bytes());\n+    let name = CString::new(name).unwrap();\n     let ty_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateBasicType(\n             DIB(cx),\n@@ -1820,7 +1820,7 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n-    let name = CString::from_slice(name.as_bytes());\n+    let name = CString::new(name).unwrap();\n     let ptr_metadata = unsafe {\n         llvm::LLVMDIBuilderCreatePointerType(\n             DIB(cx),\n@@ -1959,7 +1959,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              &member_descriptions[]);\n+                                              &member_descriptions[..]);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -2031,7 +2031,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  &struct_name[],\n+                                                  &struct_name[..],\n                                                   unique_type_id,\n                                                   containing_scope);\n \n@@ -2098,7 +2098,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unique_type_id,\n         create_struct_stub(cx,\n                            tuple_llvm_type,\n-                           &tuple_name[],\n+                           &tuple_name[..],\n                            unique_type_id,\n                            UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n@@ -2158,7 +2158,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      &member_descriptions[]);\n+                                                      &member_descriptions[..]);\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,\n@@ -2191,7 +2191,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n                                                   variant_llvm_type,\n-                                                  &member_descriptions[]);\n+                                                  &member_descriptions[..]);\n                     vec![\n                         MemberDescription {\n                             name: \"\".to_string(),\n@@ -2291,7 +2291,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              &variant_member_descriptions[]);\n+                                              &variant_member_descriptions[..]);\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -2445,7 +2445,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         .iter()\n         .map(|v| {\n             let token = token::get_name(v.name);\n-            let name = CString::from_slice(token.as_bytes());\n+            let name = CString::new(token.as_bytes()).unwrap();\n             unsafe {\n                 llvm::LLVMDIBuilderCreateEnumerator(\n                     DIB(cx),\n@@ -2475,7 +2475,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   codemap::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n-                let name = CString::from_slice(discriminant_name.as_bytes());\n+                let name = CString::new(discriminant_name.as_bytes()).unwrap();\n                 let discriminant_type_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerationType(\n                         DIB(cx),\n@@ -2518,8 +2518,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              .borrow()\n                              .get_unique_type_id_as_string(unique_type_id);\n \n-    let enum_name = CString::from_slice(enum_name.as_bytes());\n-    let unique_type_id_str = CString::from_slice(unique_type_id_str.as_bytes());\n+    let enum_name = CString::new(enum_name).unwrap();\n+    let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n     let enum_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateUnionType(\n         DIB(cx),\n@@ -2644,7 +2644,8 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                 ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n             };\n \n-            let member_name = CString::from_slice(member_description.name.as_bytes());\n+            let member_name = member_description.name.as_bytes();\n+            let member_name = CString::new(member_name).unwrap();\n             unsafe {\n                 llvm::LLVMDIBuilderCreateMemberType(\n                     DIB(cx),\n@@ -2662,7 +2663,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         .collect();\n \n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), &member_metadata[]);\n+        let type_array = create_DIArray(DIB(cx), &member_metadata[..]);\n         llvm::LLVMDICompositeTypeSetTypeArray(DIB(cx), composite_type_metadata, type_array);\n     }\n }\n@@ -2681,8 +2682,8 @@ fn create_struct_stub(cx: &CrateContext,\n     let unique_type_id_str = debug_context(cx).type_map\n                                               .borrow()\n                                               .get_unique_type_id_as_string(unique_type_id);\n-    let name = CString::from_slice(struct_type_name.as_bytes());\n-    let unique_type_id = CString::from_slice(unique_type_id_str.as_bytes());\n+    let name = CString::new(struct_type_name).unwrap();\n+    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n     let metadata_stub = unsafe {\n         // LLVMDIBuilderCreateStructType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -2763,7 +2764,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n-                                    &member_llvm_types[],\n+                                    &member_llvm_types[..],\n                                     element_type));\n     let member_descriptions = [\n         MemberDescription {\n@@ -2789,7 +2790,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n-                                           &slice_type_name[],\n+                                           &slice_type_name[..],\n                                            unique_type_id,\n                                            &member_descriptions,\n                                            UNKNOWN_SCOPE_METADATA,\n@@ -2838,7 +2839,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n                 UNKNOWN_FILE_METADATA,\n-                create_DIArray(DIB(cx), &signature_metadata[]))\n+                create_DIArray(DIB(cx), &signature_metadata[..]))\n         },\n         false);\n }\n@@ -2864,7 +2865,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   &pp_type_name[])[]);\n+                                   &pp_type_name[..])[]);\n         }\n     };\n \n@@ -2878,7 +2879,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     composite_type_metadata(cx,\n                             trait_llvm_type,\n-                            &trait_type_name[],\n+                            &trait_type_name[..],\n                             unique_type_id,\n                             &[],\n                             containing_scope,\n@@ -2998,7 +2999,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   &elements[],\n+                                   &elements[..],\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n@@ -3022,9 +3023,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  type id '{}' to already be in \\\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n-                                                &unique_type_id_str[],\n+                                                &unique_type_id_str[..],\n                                                 ppaux::ty_to_string(cx.tcx(), t));\n-                    cx.sess().span_bug(usage_site_span, &error_message[]);\n+                    cx.sess().span_bug(usage_site_span, &error_message[..]);\n                 }\n             };\n \n@@ -3037,9 +3038,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      UniqueTypeId maps in \\\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n-                            &unique_type_id_str[],\n+                            &unique_type_id_str[..],\n                             ppaux::ty_to_string(cx.tcx(), t));\n-                        cx.sess().span_bug(usage_site_span, &error_message[]);\n+                        cx.sess().span_bug(usage_site_span, &error_message[..]);\n                     }\n                 }\n                 None => {\n@@ -3128,7 +3129,7 @@ fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n     attributes.iter().any(|attr| {\n         let meta_item: &ast::MetaItem = &*attr.node.value;\n         match meta_item.node {\n-            ast::MetaWord(ref value) => &value[] == \"no_debug\",\n+            ast::MetaWord(ref value) => &value[..] == \"no_debug\",\n             _ => false\n         }\n     })\n@@ -3971,8 +3972,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                         None => ptr::null_mut()\n                     };\n                     let namespace_name = token::get_name(name);\n-                    let namespace_name = CString::from_slice(namespace_name\n-                                                                .as_bytes());\n+                    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n                     let scope = unsafe {\n                         llvm::LLVMDIBuilderCreateNameSpace(\n                             DIB(cx),\n@@ -4020,7 +4020,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n     if needs_gdb_debug_scripts_section(ccx) {\n-        let empty = CString::from_slice(b\"\");\n+        let empty = CString::new(b\"\").unwrap();\n         let gdb_debug_scripts_section_global =\n             get_or_insert_gdb_debug_scripts_section_global(ccx);\n         unsafe {"}, {"sha": "1af9fa87c6b7d2f6fd7bf31ce2877ebe46ecb36c", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -1046,14 +1046,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &**discr, &arms[], dest)\n+            _match::trans_match(bcx, expr, &**discr, &arms[..], dest)\n         }\n         ast::ExprBlock(ref blk) => {\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n-                         &fields[],\n+                         &fields[..],\n                          base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n@@ -1118,7 +1118,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n                       0,\n-                      &numbered_fields[],\n+                      &numbered_fields[..],\n                       None,\n                       dest,\n                       expr.debug_loc())\n@@ -1153,21 +1153,21 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_overloaded_call(bcx,\n                                       expr,\n                                       &**f,\n-                                      &args[],\n+                                      &args[..],\n                                       Some(dest))\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n                                    &**f,\n-                                   callee::ArgExprs(&args[]),\n+                                   callee::ArgExprs(&args[..]),\n                                    dest)\n             }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n                                       &*args[0],\n-                                      callee::ArgExprs(&args[]),\n+                                      callee::ArgExprs(&args[..]),\n                                       dest)\n         }\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -1197,7 +1197,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let trait_ref =\n                     bcx.tcx().object_cast_map.borrow()\n                                              .get(&expr.id)\n-                                             .map(|t| (*t).clone())\n+                                             .cloned()\n                                              .unwrap();\n                 let trait_ref = bcx.monomorphize(&trait_ref);\n                 let datum = unpack_datum!(bcx, trans(bcx, &**val));\n@@ -1354,11 +1354,11 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         ty::ty_struct(did, substs) => {\n             let fields = struct_fields(tcx, did, substs);\n             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n-            op(0, &fields[])\n+            op(0, &fields[..])\n         }\n \n         ty::ty_tup(ref v) => {\n-            op(0, &tup_fields(&v[])[])\n+            op(0, &tup_fields(&v[..])[])\n         }\n \n         ty::ty_enum(_, substs) => {\n@@ -1378,7 +1378,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                                 tcx, enum_id, variant_id);\n                             let fields = struct_fields(tcx, variant_id, substs);\n                             let fields = monomorphize::normalize_associated_type(tcx, &fields);\n-                            op(variant_info.disr_val, &fields[])\n+                            op(variant_info.disr_val, &fields[..])\n                         }\n                         _ => {\n                             tcx.sess.bug(\"resolve didn't map this expr to a \\"}, {"sha": "4508fe21a65fadb90abcf37975190fd609b13139", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -135,7 +135,7 @@ pub fn register_static(ccx: &CrateContext,\n             };\n             unsafe {\n                 // Declare a symbol `foo` with the desired linkage.\n-                let buf = CString::from_slice(ident.as_bytes());\n+                let buf = CString::new(ident.as_bytes()).unwrap();\n                 let g1 = llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(),\n                                              buf.as_ptr());\n                 llvm::SetLinkage(g1, linkage);\n@@ -148,7 +148,7 @@ pub fn register_static(ccx: &CrateContext,\n                 // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(&ident);\n-                let real_name = CString::from_vec(real_name.into_bytes());\n+                let real_name = CString::new(real_name).unwrap();\n                 let g2 = llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(),\n                                              real_name.as_ptr());\n                 llvm::SetLinkage(g2, llvm::InternalLinkage);\n@@ -158,7 +158,7 @@ pub fn register_static(ccx: &CrateContext,\n         }\n         None => unsafe {\n             // Generate an external declaration.\n-            let buf = CString::from_slice(ident.as_bytes());\n+            let buf = CString::new(ident.as_bytes()).unwrap();\n             llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf.as_ptr())\n         }\n     }\n@@ -238,7 +238,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n-    let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[]);\n+    let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[..]);\n     let fn_type = cabi::compute_abi_info(ccx,\n                                          &llsig.llarg_tys[],\n                                          llsig.llret_ty,\n@@ -370,7 +370,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n-                                        &llargs_foreign[],\n+                                        &llargs_foreign[..],\n                                         cc,\n                                         Some(attrs),\n                                         call_debug_loc);\n@@ -611,7 +611,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, t, &ps[]);\n+        let llfn = base::decl_internal_rust_fn(ccx, t, &ps[..]);\n         base::set_llvm_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n@@ -974,7 +974,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     if tys.fn_sig.variadic {\n         Type::variadic_func(&llargument_tys, &llreturn_ty)\n     } else {\n-        Type::func(&llargument_tys[], &llreturn_ty)\n+        Type::func(&llargument_tys[..], &llreturn_ty)\n     }\n }\n "}, {"sha": "268b65c6ceb30c14f9af1889c890a870712e7fd8", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -170,7 +170,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, &old_sym[], llfnty, ty::mk_nil(ccx.tcx()));\n+            let glue = decl_cdecl_fn(ccx, &old_sym[..], llfnty, ty::mk_nil(ccx.tcx()));\n             (glue, None)\n         },\n         None => {\n@@ -304,7 +304,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, DebugLoc::None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[..], dtor_ty, DebugLoc::None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n@@ -513,7 +513,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n-    let buf = CString::from_slice(name.as_bytes());\n+    let buf = CString::new(name.clone()).unwrap();\n     let gvar = unsafe {\n         llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(),\n                             buf.as_ptr())\n@@ -541,7 +541,7 @@ fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n         ccx,\n         t,\n         &format!(\"glue_{}\", name)[]);\n-    let llfn = decl_cdecl_fn(ccx, &fn_nm[], llfnty, ty::mk_nil(ccx.tcx()));\n+    let llfn = decl_cdecl_fn(ccx, &fn_nm[..], llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);\n }"}, {"sha": "a1b66ed94f06bc8dfed134ea44cace4fd76e274d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -166,7 +166,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let name = token::get_ident(foreign_item.ident);\n \n     // For `transmute` we can just trans the input expr directly into dest\n-    if &name[] == \"transmute\" {\n+    if &name[..] == \"transmute\" {\n         let llret_ty = type_of::type_of(ccx, ret_ty.unwrap());\n         match args {\n             callee::ArgExprs(arg_exprs) => {\n@@ -274,13 +274,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n \n     // These are the only intrinsic functions that diverge.\n-    if &name[] == \"abort\" {\n+    if &name[..] == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n         Call(bcx, llfn, &[], None, call_debug_location);\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n-    } else if &name[] == \"unreachable\" {\n+    } else if &name[..] == \"unreachable\" {\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_nil(ccx));\n@@ -307,7 +307,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n-    let llval = match (simple, &name[]) {\n+    let llval = match (simple, &name[..]) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, None, call_debug_location)\n         }"}, {"sha": "ec48ab0d34a06b60d84d5312084649225a4816bd", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -131,7 +131,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         hash = format!(\"h{}\", state.finish());\n         ccx.tcx().map.with_path(fn_id.node, |path| {\n-            exported_name(path, &hash[])\n+            exported_name(path, &hash[..])\n         })\n     };\n \n@@ -141,9 +141,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut hash_id = Some(hash_id);\n     let mut mk_lldecl = |abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[])\n+            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[..])\n         } else {\n-            decl_internal_rust_fn(ccx, mono_ty, &s[])\n+            decl_internal_rust_fn(ccx, mono_ty, &s[..])\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n@@ -182,7 +182,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n                               ccx, &**decl, &**body, &[], d, psubsts, fn_id.node,\n-                              Some(&hash[]));\n+                              Some(&hash[..]));\n                       } else {\n                           trans_fn(ccx, &**decl, &**body, d, psubsts, fn_id.node, &[]);\n                       }\n@@ -206,7 +206,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     trans_enum_variant(ccx,\n                                        parent,\n                                        &*v,\n-                                       &args[],\n+                                       &args[..],\n                                        this_tv.disr_val,\n                                        psubsts,\n                                        d);"}, {"sha": "7b59e0258ee224c4ec6cdd91e4c012afa800c072", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 26, "deletions": 54, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -171,33 +171,27 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n     debug!(\"    vt={}, count={}\", vt.to_string(ccx), count);\n-    let llcount = C_uint(ccx, count);\n \n     let fixed_ty = ty::mk_vec(bcx.tcx(),\n                               vt.unit_ty,\n                               Some(count));\n-    let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n+    let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty);\n \n-    let llfixed = if count == 0 {\n-        // Just create a zero-sized alloca to preserve\n-        // the non-null invariant of the inner slice ptr\n-        let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n-        BitCast(bcx, llfixed, llfixed_ty)\n-    } else {\n-        // Make a fixed-length backing array and allocate it on the stack.\n-        let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n+    // Always create an alloca even if zero-sized, to preserve\n+    // the non-null invariant of the inner slice ptr\n+    let llfixed = base::alloca(bcx, llfixed_ty, \"\");\n \n+    if count > 0 {\n         // Arrange for the backing array to be cleaned up.\n-        let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n         let cleanup_scope = cleanup::temporary_scope(bcx.tcx(), content_expr.id);\n-        fcx.schedule_lifetime_end(cleanup_scope, llfixed_casted);\n-        fcx.schedule_drop_mem(cleanup_scope, llfixed_casted, fixed_ty);\n+        fcx.schedule_lifetime_end(cleanup_scope, llfixed);\n+        fcx.schedule_drop_mem(cleanup_scope, llfixed, fixed_ty);\n \n         // Generate the content into the backing array.\n-        bcx = write_content(bcx, &vt, slice_expr,\n-                            content_expr, SaveIn(llfixed));\n-\n-        llfixed_casted\n+        // llfixed has type *[T x N], but we want the type *T,\n+        // so use GEP to convert\n+        bcx = write_content(bcx, &vt, slice_expr, content_expr,\n+                            SaveIn(GEPi(bcx, llfixed, &[0, 0])));\n     };\n \n     immediate_rvalue_bcx(bcx, llfixed, vec_ty).to_expr_datumblock()\n@@ -426,49 +420,27 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n     let fcx = bcx.fcx;\n \n-    let next_bcx = fcx.new_temp_block(\"expr_repeat: while next\");\n     let loop_bcx = fcx.new_temp_block(\"expr_repeat\");\n-    let cond_bcx = fcx.new_temp_block(\"expr_repeat: loop cond\");\n-    let body_bcx = fcx.new_temp_block(\"expr_repeat: body: set\");\n-    let inc_bcx = fcx.new_temp_block(\"expr_repeat: body: inc\");\n-    Br(bcx, loop_bcx.llbb, DebugLoc::None);\n-\n-    let loop_counter = {\n-        // i = 0\n-        let i = alloca(loop_bcx, bcx.ccx().int_type(), \"__i\");\n-        Store(loop_bcx, C_uint(bcx.ccx(), 0_u32), i);\n+    let next_bcx = fcx.new_temp_block(\"expr_repeat: next\");\n \n-        Br(loop_bcx, cond_bcx.llbb, DebugLoc::None);\n-        i\n-    };\n-\n-    { // i < count\n-        let lhs = Load(cond_bcx, loop_counter);\n-        let rhs = count;\n-        let cond_val = ICmp(cond_bcx, llvm::IntULT, lhs, rhs, DebugLoc::None);\n-\n-        CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n-    }\n+    Br(bcx, loop_bcx.llbb, DebugLoc::None);\n \n-    { // loop body\n-        let i = Load(body_bcx, loop_counter);\n-        let lleltptr = if vt.llunit_alloc_size == 0 {\n-            data_ptr\n-        } else {\n-            InBoundsGEP(body_bcx, data_ptr, &[i])\n-        };\n-        let body_bcx = f(body_bcx, lleltptr, vt.unit_ty);\n+    let loop_counter = Phi(loop_bcx, bcx.ccx().int_type(),\n+                           &[C_uint(bcx.ccx(), 0 as usize)], &[bcx.llbb]);\n \n-        Br(body_bcx, inc_bcx.llbb, DebugLoc::None);\n-    }\n+    let bcx = loop_bcx;\n \n-    { // i += 1\n-        let i = Load(inc_bcx, loop_counter);\n-        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1_u32), DebugLoc::None);\n-        Store(inc_bcx, plusone, loop_counter);\n+    let lleltptr = if vt.llunit_alloc_size == 0 {\n+        data_ptr\n+    } else {\n+        InBoundsGEP(bcx, data_ptr, &[loop_counter])\n+    };\n+    let bcx = f(bcx, lleltptr, vt.unit_ty);\n+    let plusone = Add(bcx, loop_counter, C_uint(bcx.ccx(), 1us), DebugLoc::None);\n+    AddIncomingToPhi(loop_counter, plusone, bcx.llbb);\n \n-        Br(inc_bcx, cond_bcx.llbb, DebugLoc::None);\n-    }\n+    let cond_val = ICmp(bcx, llvm::IntULT, plusone, count, DebugLoc::None);\n+    CondBr(bcx, cond_val, loop_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n \n     next_bcx\n }"}, {"sha": "ad83135a0d46fa3681df8b6f4d6bc2cb8b7d7d64", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -163,7 +163,7 @@ impl Type {\n     }\n \n     pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n-        let name = CString::from_slice(name.as_bytes());\n+        let name = CString::new(name).unwrap();\n         ty!(llvm::LLVMStructCreateNamed(ccx.llcx(), name.as_ptr()))\n     }\n "}, {"sha": "489b56bbe6825f567968c2bc802549a21fcaf34b", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -67,7 +67,7 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                 abi: abi::Abi)\n                                                 -> Vec<Ty<'tcx>> {\n     if abi != abi::RustCall {\n-        return inputs.iter().map(|x| (*x).clone()).collect()\n+        return inputs.iter().cloned().collect()\n     }\n \n     if inputs.len() == 0 {\n@@ -144,7 +144,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n     atys.extend(input_tys);\n \n-    Type::func(&atys[], &lloutputtype)\n+    Type::func(&atys[..], &lloutputtype)\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -332,7 +332,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n           let name = llvm_type_name(cx, an_enum, did, tps);\n-          adt::incomplete_type_of(cx, &*repr, &name[])\n+          adt::incomplete_type_of(cx, &*repr, &name[..])\n       }\n       ty::ty_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n@@ -343,7 +343,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n           let name = llvm_type_name(cx, a_closure, did, substs.types.as_slice());\n-          adt::incomplete_type_of(cx, &*repr, &name[])\n+          adt::incomplete_type_of(cx, &*repr, &name[..])\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n@@ -399,7 +399,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, a_struct, did, tps);\n-              adt::incomplete_type_of(cx, &*repr, &name[])\n+              adt::incomplete_type_of(cx, &*repr, &name[..])\n           }\n       }\n "}, {"sha": "e3c1c66f78c9c47774ee1740b52a42a538f45c37", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -404,17 +404,30 @@ fn create_substs_for_ast_path<'tcx>(\n \n     let actual_supplied_ty_param_count = substs.types.len(TypeSpace);\n     for param in &ty_param_defs[actual_supplied_ty_param_count..] {\n-        match param.default {\n-            Some(default) => {\n+        if let Some(default) = param.default {\n+            // If we are converting an object type, then the\n+            // `Self` parameter is unknown. However, some of the\n+            // other type parameters may reference `Self` in their\n+            // defaults. This will lead to an ICE if we are not\n+            // careful!\n+            if self_ty.is_none() && ty::type_has_self(default) {\n+                tcx.sess.span_err(\n+                    span,\n+                    &format!(\"the type parameter `{}` must be explicitly specified \\\n+                              in an object type because its default value `{}` references \\\n+                              the type `Self`\",\n+                             param.name.user_string(tcx),\n+                             default.user_string(tcx)));\n+                substs.types.push(TypeSpace, tcx.types.err);\n+            } else {\n                 // This is a default type parameter.\n                 let default = default.subst_spanned(tcx,\n                                                     &substs,\n                                                     Some(span));\n                 substs.types.push(TypeSpace, default);\n             }\n-            None => {\n-                tcx.sess.span_bug(span, \"extra parameter without default\");\n-            }\n+        } else {\n+            tcx.sess.span_bug(span, \"extra parameter without default\");\n         }\n     }\n \n@@ -1139,14 +1152,14 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n-                match ast_ty_to_trait_ref(this, rscope, &**ty, &bounds[]) {\n+                match ast_ty_to_trait_ref(this, rscope, &**ty, &bounds[..]) {\n                     Ok((trait_ref, projection_bounds)) => {\n                         trait_ref_to_object_type(this,\n                                                  rscope,\n                                                  ast_ty.span,\n                                                  trait_ref,\n                                                  projection_bounds,\n-                                                 &bounds[])\n+                                                 &bounds[..])\n                     }\n                     Err(ErrorReported) => {\n                         this.tcx().types.err\n@@ -1185,7 +1198,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[])\n+                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[..])\n             }\n             ast::TyPath(ref path, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n@@ -1424,7 +1437,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n             // Skip the first argument if `self` is present.\n             &self_and_input_tys[1..]\n         } else {\n-            &self_and_input_tys[]\n+            &self_and_input_tys[..]\n         };\n \n         let (ior, lfp) = find_implied_output_region(input_tys, input_pats);\n@@ -1623,7 +1636,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n     ast_bounds: &[ast::TyParamBound])\n     -> Ty<'tcx>\n {\n-    let mut partitioned_bounds = partition_bounds(this.tcx(), span, &ast_bounds[]);\n+    let mut partitioned_bounds = partition_bounds(this.tcx(), span, &ast_bounds[..]);\n \n     let mut projection_bounds = Vec::new();\n     let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {"}, {"sha": "34c52981b794dff838208073f38a0d048a9cb59f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -162,7 +162,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_pat_enum(pcx, pat, &path, Some(&[]), expected);\n         }\n         ast::PatEnum(ref path, ref subpats) => {\n-            let subpats = subpats.as_ref().map(|v| &v[]);\n+            let subpats = subpats.as_ref().map(|v| &v[..]);\n             check_pat_enum(pcx, pat, path, subpats, expected);\n         }\n         ast::PatStruct(ref path, ref fields, etc) => {"}, {"sha": "0ad15456df98f16daab554c59b289287426b0523", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -256,7 +256,7 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     check_argument_types(fcx,\n                          call_expr.span,\n                          &fn_sig.inputs,\n-                         &expected_arg_tys[],\n+                         &expected_arg_tys[..],\n                          arg_exprs,\n                          AutorefArgs::No,\n                          fn_sig.variadic,"}, {"sha": "4aaaf4ffe5ab3028aa982a204df157ec4d289670", "filename": "src/librustc_typeck/check/implicator.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -329,6 +329,9 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     fn accumulate_from_assoc_types_transitive(&mut self,\n                                               data: &ty::PolyTraitPredicate<'tcx>)\n     {\n+        debug!(\"accumulate_from_assoc_types_transitive({})\",\n+               data.repr(self.tcx()));\n+\n         for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n             match ty::no_late_bound_regions(self.tcx(), &poly_trait_ref) {\n                 Some(trait_ref) => { self.accumulate_from_assoc_types(trait_ref); }\n@@ -340,13 +343,18 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     fn accumulate_from_assoc_types(&mut self,\n                                    trait_ref: Rc<ty::TraitRef<'tcx>>)\n     {\n+        debug!(\"accumulate_from_assoc_types({})\",\n+               trait_ref.repr(self.tcx()));\n+\n         let trait_def_id = trait_ref.def_id;\n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n         let assoc_type_projections: Vec<_> =\n             trait_def.associated_type_names\n                      .iter()\n                      .map(|&name| ty::mk_projection(self.tcx(), trait_ref.clone(), name))\n                      .collect();\n+        debug!(\"accumulate_from_assoc_types: assoc_type_projections={}\",\n+               assoc_type_projections.repr(self.tcx()));\n         let tys = match self.fully_normalize(&assoc_type_projections) {\n             Ok(tys) => { tys }\n             Err(ErrorReported) => { return; }"}, {"sha": "978fbbbcffc33e7dfec2e527fb4bc9dff9e8a030", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -901,7 +901,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"applicable_candidates: {}\", applicable_candidates.repr(self.tcx()));\n \n         if applicable_candidates.len() > 1 {\n-            match self.collapse_candidates_to_trait_pick(&applicable_candidates[]) {\n+            match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n                 Some(pick) => { return Some(Ok(pick)); }\n                 None => { }\n             }"}, {"sha": "1639772103b7aef5f95e7c5b6a6674d99b083152", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -172,7 +172,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"});\n \n-        fcx.sess().fileline_help(span, &msg[]);\n+        fcx.sess().fileline_help(span, &msg[..]);\n \n         for (i, trait_did) in candidates.iter().enumerate() {\n             fcx.sess().fileline_help(span,\n@@ -218,7 +218,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n             name = method_ustring);\n \n-        fcx.sess().fileline_help(span, &msg[]);\n+        fcx.sess().fileline_help(span, &msg[..]);\n \n         for (i, trait_info) in candidates.iter().enumerate() {\n             fcx.sess().fileline_help(span,\n@@ -306,10 +306,10 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         // Crate-local:\n         //\n         // meh.\n-        struct Visitor<'a, 'b: 'a, 'tcx: 'a + 'b> {\n+        struct Visitor<'a> {\n             traits: &'a mut AllTraitsVec,\n         }\n-        impl<'v,'a, 'b, 'tcx> visit::Visitor<'v> for Visitor<'a, 'b, 'tcx> {\n+        impl<'v, 'a> visit::Visitor<'v> for Visitor<'a> {\n             fn visit_item(&mut self, i: &'v ast::Item) {\n                 match i.node {\n                     ast::ItemTrait(..) => {"}, {"sha": "e443b4d0e606abd082e45a8fdd9f8b4e8efec526", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -638,7 +638,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     // Remember return type so that regionck can access it later.\n     let mut fn_sig_tys: Vec<Ty> =\n         arg_tys.iter()\n-        .map(|&ty| ty)\n+        .cloned()\n         .collect();\n \n     if let ty::FnConverging(ret_ty) = ret_ty {\n@@ -2208,7 +2208,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         check_argument_types(fcx,\n                              sp,\n-                             &err_inputs[],\n+                             &err_inputs[..],\n                              &[],\n                              args_no_rcvr,\n                              autoref_args,\n@@ -2227,7 +2227,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 check_argument_types(fcx,\n                                      sp,\n                                      &fty.sig.0.inputs[1..],\n-                                     &expected_arg_tys[],\n+                                     &expected_arg_tys[..],\n                                      args_no_rcvr,\n                                      autoref_args,\n                                      fty.sig.0.variadic,\n@@ -3054,7 +3054,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n-                        fcx.lookup_field_ty(expr.span, base_id, &fields[],\n+                        fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n                                             field.node.name, &(*substs))\n                     }\n                     _ => None\n@@ -3154,7 +3154,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if tuple_like {\n                             debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n-                            fcx.lookup_tup_field_ty(expr.span, base_id, &fields[],\n+                            fcx.lookup_tup_field_ty(expr.span, base_id, &fields[..],\n                                                     idx.node, &(*substs))\n                         } else {\n                             None\n@@ -3219,7 +3219,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         for field in ast_fields {\n             let mut expected_field_type = tcx.types.err;\n \n-            let pair = class_field_map.get(&field.ident.node.name).map(|x| *x);\n+            let pair = class_field_map.get(&field.ident.node.name).cloned();\n             match pair {\n                 None => {\n                     fcx.type_error_message(\n@@ -3327,7 +3327,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        class_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(struct_substs),\n-                                       &class_fields[],\n+                                       &class_fields[..],\n                                        fields,\n                                        base_expr.is_none(),\n                                        None);\n@@ -3370,7 +3370,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        variant_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(substitutions),\n-                                       &variant_fields[],\n+                                       &variant_fields[..],\n                                        fields,\n                                        true,\n                                        Some(enum_id));\n@@ -3731,10 +3731,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       ast::ExprCall(ref callee, ref args) => {\n-          callee::check_call(fcx, expr, &**callee, &args[], expected);\n+          callee::check_call(fcx, expr, &**callee, &args[..], expected);\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, &args[], &tps[], expected, lvalue_pref);\n+        check_method_call(fcx, expr, ident, &args[..], &tps[..], expected, lvalue_pref);\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {\n@@ -3821,7 +3821,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprTup(ref elts) => {\n         let flds = expected.only_has_type(fcx).and_then(|ty| {\n             match ty.sty {\n-                ty::ty_tup(ref flds) => Some(&flds[]),\n+                ty::ty_tup(ref flds) => Some(&flds[..]),\n                 _ => None\n             }\n         });\n@@ -3851,11 +3851,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n         // Resolve the path.\n-        let def = tcx.def_map.borrow().get(&id).map(|i| *i);\n+        let def = tcx.def_map.borrow().get(&id).cloned();\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, &fields[]);\n+                                          variant_id, &fields[..]);\n                 enum_id\n             }\n             Some(def::DefTrait(def_id)) => {\n@@ -3864,7 +3864,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     pprust::path_to_string(path));\n                 check_struct_fields_on_error(fcx,\n                                              id,\n-                                             &fields[],\n+                                             &fields[..],\n                                              base_expr);\n                 def_id\n             },\n@@ -3877,7 +3877,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  id,\n                                                  expr.span,\n                                                  struct_did,\n-                                                 &fields[],\n+                                                 &fields[..],\n                                                  base_expr.as_ref().map(|e| &**e));\n                     }\n                     _ => {\n@@ -3886,7 +3886,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             pprust::path_to_string(path));\n                         check_struct_fields_on_error(fcx,\n                                                      id,\n-                                                     &fields[],\n+                                                     &fields[..],\n                                                      base_expr);\n                     }\n                 }\n@@ -5231,10 +5231,10 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             }\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n-    } else if &name[] == \"abort\" || &name[] == \"unreachable\" {\n+    } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n         (0, Vec::new(), ty::FnDiverging)\n     } else {\n-        let (n_tps, inputs, output) = match &name[] {\n+        let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.uint),\n@@ -5259,7 +5259,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { span_fatal!(tcx.sess, it.span, E0240, \"{}\", &s[]); }\n+                  Err(s) => { span_fatal!(tcx.sess, it.span, E0240, \"{}\", &s[..]); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,"}, {"sha": "82abff8c425f42c5aca7d2aa62f73ac9c85a78de", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -294,8 +294,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         let len = self.region_bound_pairs.len();\n         let old_body_id = self.set_body_id(body.id);\n-        self.relate_free_regions(&fn_sig[], body.id, span);\n-        link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[]);\n+        self.relate_free_regions(&fn_sig[..], body.id, span);\n+        link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[..]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_bound_pairs.truncate(len);\n@@ -626,6 +626,20 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n+        ast::ExprBinary(_, ref lhs, ref rhs) => {\n+            // If you do `x OP y`, then the types of `x` and `y` must\n+            // outlive the operation you are performing.\n+            let lhs_ty = rcx.resolve_expr_type_adjusted(&**lhs);\n+            let rhs_ty = rcx.resolve_expr_type_adjusted(&**rhs);\n+            for &ty in [lhs_ty, rhs_ty].iter() {\n+                type_must_outlive(rcx,\n+                                  infer::Operand(expr.span),\n+                                  ty,\n+                                  ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+            }\n+            visit::walk_expr(rcx, expr);\n+        }\n+\n         ast::ExprUnary(op, ref lhs) if has_method_map => {\n             let implicitly_ref_args = !ast_util::is_by_value_unop(op);\n \n@@ -690,7 +704,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &**discr, &arms[]);\n+            link_match(rcx, &**discr, &arms[..]);\n \n             visit::walk_expr(rcx, expr);\n         }"}, {"sha": "3666b69d1c678ac4cc6a64d60118b794f4bdf449", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -126,6 +126,13 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     \"the trait cannot require that `Self : Sized`\");\n             }\n \n+            ObjectSafetyViolation::SupertraitSelf => {\n+                tcx.sess.span_note(\n+                    span,\n+                    \"the trait cannot use `Self` as a type parameter \\\n+                     in the supertrait listing\");\n+            }\n+\n             ObjectSafetyViolation::Method(method, MethodViolationCode::ByValueSelf) => {\n                 tcx.sess.span_note(\n                     span,"}, {"sha": "2601c4d275291d144762ff46ac1484aee3e3b5eb", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 145, "deletions": 13, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -10,21 +10,22 @@\n \n use astconv::AstConv;\n use check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n+use constrained_type_params::identify_constrained_type_params;\n use CrateCtxt;\n use middle::region;\n-use middle::subst;\n+use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util::{local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, special_idents};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -38,6 +39,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         CheckTypeWellFormedVisitor { ccx: ccx, cache: HashSet::new() }\n     }\n \n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.ccx.tcx\n+    }\n+\n     /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n     /// well-formed, meaning that they do not require any constraints not declared in the struct\n     /// definition itself. For example, this definition would be illegal:\n@@ -96,19 +101,29 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemConst(..) => {\n                 self.check_item_type(item);\n             }\n-            ast::ItemStruct(ref struct_def, _) => {\n-                self.check_type_defn(item, |fcx| vec![struct_variant(fcx, &**struct_def)]);\n+            ast::ItemStruct(ref struct_def, ref ast_generics) => {\n+                self.check_type_defn(item, |fcx| {\n+                    vec![struct_variant(fcx, &**struct_def)]\n+                });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            ast::ItemEnum(ref enum_def, _) => {\n-                self.check_type_defn(item, |fcx| enum_variants(fcx, enum_def));\n+            ast::ItemEnum(ref enum_def, ref ast_generics) => {\n+                self.check_type_defn(item, |fcx| {\n+                    enum_variants(fcx, enum_def)\n+                });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            ast::ItemTrait(..) => {\n+            ast::ItemTrait(_, ref ast_generics, _, _) => {\n                 let trait_predicates =\n                     ty::lookup_predicates(ccx.tcx, local_def(item.id));\n                 reject_non_type_param_bounds(\n                     ccx.tcx,\n                     item.span,\n                     &trait_predicates);\n+                self.check_variances(item, ast_generics, &trait_predicates,\n+                                     self.tcx().lang_items.phantom_fn());\n             }\n             _ => {}\n         }\n@@ -276,6 +291,123 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n         });\n     }\n+\n+    fn check_variances_for_type_defn(&self,\n+                                     item: &ast::Item,\n+                                     ast_generics: &ast::Generics)\n+    {\n+        let item_def_id = local_def(item.id);\n+        let predicates = ty::lookup_predicates(self.tcx(), item_def_id);\n+        self.check_variances(item,\n+                             ast_generics,\n+                             &predicates,\n+                             self.tcx().lang_items.phantom_data());\n+    }\n+\n+    fn check_variances(&self,\n+                       item: &ast::Item,\n+                       ast_generics: &ast::Generics,\n+                       ty_predicates: &ty::GenericPredicates<'tcx>,\n+                       suggested_marker_id: Option<ast::DefId>)\n+    {\n+        let variance_lang_items = &[\n+            self.tcx().lang_items.phantom_fn(),\n+            self.tcx().lang_items.phantom_data(),\n+        ];\n+\n+        let item_def_id = local_def(item.id);\n+        let is_lang_item = variance_lang_items.iter().any(|n| *n == Some(item_def_id));\n+        if is_lang_item {\n+            return;\n+        }\n+\n+        let variances = ty::item_variances(self.tcx(), item_def_id);\n+\n+        let mut constrained_parameters: HashSet<_> =\n+            variances.types\n+            .iter_enumerated()\n+            .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n+            .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n+            .collect();\n+\n+        identify_constrained_type_params(self.tcx(),\n+                                         ty_predicates.predicates.as_slice(),\n+                                         None,\n+                                         &mut constrained_parameters);\n+\n+        for (space, index, _) in variances.types.iter_enumerated() {\n+            let param_ty = self.param_ty(ast_generics, space, index);\n+            if constrained_parameters.contains(&param_ty) {\n+                continue;\n+            }\n+            let span = self.ty_param_span(ast_generics, item, space, index);\n+            self.report_bivariance(span, param_ty.name, suggested_marker_id);\n+        }\n+\n+        for (space, index, &variance) in variances.regions.iter_enumerated() {\n+            if variance != ty::Bivariant {\n+                continue;\n+            }\n+\n+            assert_eq!(space, TypeSpace);\n+            let span = ast_generics.lifetimes[index].lifetime.span;\n+            let name = ast_generics.lifetimes[index].lifetime.name;\n+            self.report_bivariance(span, name, suggested_marker_id);\n+        }\n+    }\n+\n+    fn param_ty(&self,\n+                ast_generics: &ast::Generics,\n+                space: ParamSpace,\n+                index: usize)\n+                -> ty::ParamTy\n+    {\n+        let name = match space {\n+            TypeSpace => ast_generics.ty_params[index].ident.name,\n+            SelfSpace => special_idents::type_self.name,\n+            FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n+        };\n+\n+        ty::ParamTy { space: space, idx: index as u32, name: name }\n+    }\n+\n+    fn ty_param_span(&self,\n+                     ast_generics: &ast::Generics,\n+                     item: &ast::Item,\n+                     space: ParamSpace,\n+                     index: usize)\n+                     -> Span\n+    {\n+        match space {\n+            TypeSpace => ast_generics.ty_params[index].span,\n+            SelfSpace => item.span,\n+            FnSpace => self.tcx().sess.span_bug(item.span, \"Fn space occupied?\"),\n+        }\n+    }\n+\n+    fn report_bivariance(&self,\n+                         span: Span,\n+                         param_name: ast::Name,\n+                         suggested_marker_id: Option<ast::DefId>)\n+    {\n+        self.tcx().sess.span_err(\n+            span,\n+            &format!(\"parameter `{}` is never used\",\n+                     param_name.user_string(self.tcx()))[]);\n+\n+        match suggested_marker_id {\n+            Some(def_id) => {\n+                self.tcx().sess.span_help(\n+                    span,\n+                    format!(\"consider removing `{}` or using a marker such as `{}`\",\n+                            param_name.user_string(self.tcx()),\n+                            ty::item_path_str(self.tcx(), def_id)).as_slice());\n+            }\n+            None => {\n+                // no lang items, no help!\n+            }\n+        }\n+    }\n }\n \n // Reject any predicates that do not involve a type parameter.\n@@ -343,9 +475,9 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match fk {\n             visit::FkFnBlock | visit::FkItemFn(..) => {}\n             visit::FkMethod(..) => {\n-                match ty::impl_or_trait_item(self.ccx.tcx, local_def(id)) {\n+                match ty::impl_or_trait_item(self.tcx(), local_def(id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n-                        reject_shadowing_type_parameters(self.ccx.tcx, span, &ty_method.generics)\n+                        reject_shadowing_type_parameters(self.tcx(), span, &ty_method.generics)\n                     }\n                     _ => {}\n                 }\n@@ -359,14 +491,14 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             &ast::TraitItem::ProvidedMethod(_) |\n             &ast::TraitItem::TypeTraitItem(_) => {},\n             &ast::TraitItem::RequiredMethod(ref method) => {\n-                match ty::impl_or_trait_item(self.ccx.tcx, local_def(method.id)) {\n+                match ty::impl_or_trait_item(self.tcx(), local_def(method.id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                         reject_non_type_param_bounds(\n-                            self.ccx.tcx,\n+                            self.tcx(),\n                             method.span,\n                             &ty_method.predicates);\n                         reject_shadowing_type_parameters(\n-                            self.ccx.tcx,\n+                            self.tcx(),\n                             method.span,\n                             &ty_method.generics);\n                     }"}, {"sha": "0b78af18e2617b2869bba2d8431488275e11f620", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 54, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -87,6 +87,7 @@ There are some shortcomings in this design:\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use middle::def;\n+use constrained_type_params::identify_constrained_type_params;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n@@ -268,7 +269,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[], enum_scheme.ty)\n+                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[..], enum_scheme.ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -313,7 +314,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     trait_id,\n                                     &trait_def.generics,\n                                     &trait_predicates,\n-                                    &trait_items[],\n+                                    &trait_items[..],\n                                     &m.id,\n                                     &m.ident.name,\n                                     &m.explicit_self,\n@@ -328,7 +329,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     trait_id,\n                                     &trait_def.generics,\n                                     &trait_predicates,\n-                                    &trait_items[],\n+                                    &trait_items[..],\n                                     &m.id,\n                                     &m.pe_ident().name,\n                                     m.pe_explicit_self(),\n@@ -871,7 +872,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                             local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 local_def(ctor_id),\n-                                                &inputs[],\n+                                                &inputs[..],\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n@@ -1358,7 +1359,7 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(ccx,\n                 subst::FnSpace,\n-                &early_lifetimes[],\n+                &early_lifetimes[..],\n                 &generics.ty_params[],\n                 &generics.where_clause,\n                 base_generics)\n@@ -1960,51 +1961,15 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let mut input_parameters: HashSet<_> =\n         impl_trait_ref.iter()\n                       .flat_map(|t| t.input_types().iter()) // Types in trait ref, if any\n-                      .chain(Some(impl_scheme.ty).iter())  // Self type, always\n+                      .chain(Some(impl_scheme.ty).iter())   // Self type, always\n                       .flat_map(|t| t.walk())\n-                      .filter_map(to_opt_param_ty)\n+                      .filter_map(|t| t.as_opt_param_ty())\n                       .collect();\n \n-    loop {\n-        let num_inputs = input_parameters.len();\n-\n-        let projection_predicates =\n-            impl_predicates.predicates\n-                           .iter()\n-                           .filter_map(|predicate| {\n-                               match *predicate {\n-                                   // Ignore higher-ranked binders. For the purposes\n-                                   // of this check, they don't matter because they\n-                                   // only affect named regions, and we're just\n-                                   // concerned about type parameters here.\n-                                   ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n-                                   _ => None,\n-                               }\n-                           });\n-\n-        for projection in projection_predicates {\n-            // Special case: watch out for some kind of sneaky attempt\n-            // to project out an associated type defined by this very trait.\n-            if Some(projection.projection_ty.trait_ref.clone()) == impl_trait_ref {\n-                continue;\n-            }\n-\n-            let relies_only_on_inputs =\n-                projection.projection_ty.trait_ref.input_types().iter()\n-                .flat_map(|t| t.walk())\n-                .filter_map(to_opt_param_ty)\n-                .all(|t| input_parameters.contains(&t));\n-\n-            if relies_only_on_inputs {\n-                input_parameters.extend(\n-                    projection.ty.walk().filter_map(to_opt_param_ty));\n-            }\n-        }\n-\n-        if input_parameters.len() == num_inputs {\n-            break;\n-        }\n-    }\n+    identify_constrained_type_params(tcx,\n+                                     impl_predicates.predicates.as_slice(),\n+                                     impl_trait_ref,\n+                                     &mut input_parameters);\n \n     for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n         let param_ty = ty::ParamTy { space: TypeSpace,\n@@ -2025,11 +1990,4 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         }\n     }\n-\n-    fn to_opt_param_ty<'tcx>(ty: Ty<'tcx>) -> Option<ty::ParamTy> {\n-        match ty.sty {\n-            ty::ty_param(ref d) => Some(d.clone()),\n-            _ => None,\n-        }\n-    }\n }"}, {"sha": "83d7e98500007318c645114089fd8b54decb032e", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{self};\n+\n+use std::collections::HashSet;\n+use std::rc::Rc;\n+\n+pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n+                                              predicates: &[ty::Predicate<'tcx>],\n+                                              impl_trait_ref: Option<Rc<ty::TraitRef<'tcx>>>,\n+                                              input_parameters: &mut HashSet<ty::ParamTy>)\n+{\n+    loop {\n+        let num_inputs = input_parameters.len();\n+\n+        let projection_predicates =\n+            predicates.iter()\n+                      .filter_map(|predicate| {\n+                          match *predicate {\n+                              // Ignore higher-ranked binders. For the purposes\n+                              // of this check, they don't matter because they\n+                              // only affect named regions, and we're just\n+                              // concerned about type parameters here.\n+                              ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n+                              _ => None,\n+                          }\n+                      });\n+\n+        for projection in projection_predicates {\n+            // Special case: watch out for some kind of sneaky attempt\n+            // to project out an associated type defined by this very trait.\n+            if Some(projection.projection_ty.trait_ref.clone()) == impl_trait_ref {\n+                continue;\n+            }\n+\n+            let relies_only_on_inputs =\n+                projection.projection_ty.trait_ref.input_types()\n+                                                  .iter()\n+                                                  .flat_map(|t| t.walk())\n+                                                  .filter_map(|t| t.as_opt_param_ty())\n+                                                  .all(|t| input_parameters.contains(&t));\n+\n+            if relies_only_on_inputs {\n+                input_parameters.extend(\n+                    projection.ty.walk().filter_map(|t| t.as_opt_param_ty()));\n+            }\n+        }\n+\n+        if input_parameters.len() == num_inputs {\n+            break;\n+        }\n+    }\n+}"}, {"sha": "b5dca0bd4f6f42348e2981d23bf079541b91986b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -123,6 +123,7 @@ mod check;\n mod rscope;\n mod astconv;\n mod collect;\n+mod constrained_type_params;\n mod coherence;\n mod variance;\n "}, {"sha": "1adcf133bf3e0788490204a73c62a4e120497526", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 270, "deletions": 126, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -187,6 +187,22 @@\n //!   and the definition-site variance of the [corresponding] type parameter\n //!   of a class `C` is `V1`, then the variance of `X` in the type expression\n //!   `C<E>` is `V3 = V1.xform(V2)`.\n+//!\n+//! ### Constraints\n+//!\n+//! If I have a struct or enum with where clauses:\n+//!\n+//!     struct Foo<T:Bar> { ... }\n+//!\n+//! you might wonder whether the variance of `T` with respect to `Bar`\n+//! affects the variance `T` with respect to `Foo`. I claim no.  The\n+//! reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n+//! `Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n+//! `X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n+//! case, the upcast will be illegal, but not because of a variance\n+//! failure, but rather because the target type `Foo<Y>` is itself just\n+//! not well-formed. Basically we get to assume well-formedness of all\n+//! types involved before considering variance.\n \n use self::VarianceTerm::*;\n use self::ParamKind::*;\n@@ -199,7 +215,6 @@ use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace}\n use middle::ty::{self, Ty};\n use std::fmt;\n use std::rc::Rc;\n-use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -258,6 +273,11 @@ struct TermsContext<'a, 'tcx: 'a> {\n \n     empty_variances: Rc<ty::ItemVariances>,\n \n+    // For marker types, UnsafeCell, and other lang items where\n+    // variance is hardcoded, records the item-id and the hardcoded\n+    // variance.\n+    lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n+\n     // Maps from the node id of a type/generic parameter to the\n     // corresponding inferred index.\n     inferred_map: NodeMap<InferredIndex>,\n@@ -269,7 +289,7 @@ struct TermsContext<'a, 'tcx: 'a> {\n #[derive(Copy, Debug, PartialEq)]\n enum ParamKind {\n     TypeParam,\n-    RegionParam\n+    RegionParam,\n }\n \n struct InferredInfo<'a> {\n@@ -279,6 +299,11 @@ struct InferredInfo<'a> {\n     index: uint,\n     param_id: ast::NodeId,\n     term: VarianceTermPtr<'a>,\n+\n+    // Initial value to use for this parameter when inferring\n+    // variance. For most parameters, this is Bivariant. But for lang\n+    // items and input type parameters on traits, it is different.\n+    initial_variance: ty::Variance,\n }\n \n fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n@@ -291,6 +316,8 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         inferred_map: NodeMap(),\n         inferred_infos: Vec::new(),\n \n+        lang_items: lang_items(tcx),\n+\n         // cache and share the variance struct used for items with\n         // no type/region parameters\n         empty_variances: Rc::new(ty::ItemVariances {\n@@ -304,7 +331,78 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n     terms_cx\n }\n \n+fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n+    let all = vec![\n+        (tcx.lang_items.phantom_fn(), vec![ty::Contravariant, ty::Covariant]),\n+        (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n+        (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n+\n+        // Deprecated:\n+        (tcx.lang_items.covariant_type(), vec![ty::Covariant]),\n+        (tcx.lang_items.contravariant_type(), vec![ty::Contravariant]),\n+        (tcx.lang_items.invariant_type(), vec![ty::Invariant]),\n+        (tcx.lang_items.covariant_lifetime(), vec![ty::Covariant]),\n+        (tcx.lang_items.contravariant_lifetime(), vec![ty::Contravariant]),\n+        (tcx.lang_items.invariant_lifetime(), vec![ty::Invariant]),\n+\n+        ];\n+\n+    all.into_iter()\n+       .filter(|&(ref d,_)| d.is_some())\n+       .filter(|&(ref d,_)| d.as_ref().unwrap().krate == ast::LOCAL_CRATE)\n+       .map(|(d, v)| (d.unwrap().node, v))\n+       .collect()\n+}\n+\n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n+    fn add_inferreds_for_item(&mut self,\n+                              item_id: ast::NodeId,\n+                              has_self: bool,\n+                              generics: &ast::Generics)\n+    {\n+        /*!\n+         * Add \"inferreds\" for the generic parameters declared on this\n+         * item. This has a lot of annoying parameters because we are\n+         * trying to drive this from the AST, rather than the\n+         * ty::Generics, so that we can get span info -- but this\n+         * means we must accommodate syntactic distinctions.\n+         */\n+\n+        // NB: In the code below for writing the results back into the\n+        // tcx, we rely on the fact that all inferreds for a particular\n+        // item are assigned continuous indices.\n+\n+        let inferreds_on_entry = self.num_inferred();\n+\n+        if has_self {\n+            self.add_inferred(item_id, TypeParam, SelfSpace, 0, item_id);\n+        }\n+\n+        for (i, p) in generics.lifetimes.iter().enumerate() {\n+            let id = p.lifetime.id;\n+            self.add_inferred(item_id, RegionParam, TypeSpace, i, id);\n+        }\n+\n+        for (i, p) in generics.ty_params.iter().enumerate() {\n+            self.add_inferred(item_id, TypeParam, TypeSpace, i, p.id);\n+        }\n+\n+        // If this item has no type or lifetime parameters,\n+        // then there are no variances to infer, so just\n+        // insert an empty entry into the variance map.\n+        // Arguably we could just leave the map empty in this\n+        // case but it seems cleaner to be able to distinguish\n+        // \"invalid item id\" from \"item id with no\n+        // parameters\".\n+        if self.num_inferred() == inferreds_on_entry {\n+            let newly_added =\n+                self.tcx.item_variance_map.borrow_mut().insert(\n+                    ast_util::local_def(item_id),\n+                    self.empty_variances.clone()).is_none();\n+            assert!(newly_added);\n+        }\n+    }\n+\n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n@@ -313,21 +411,48 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n+        let initial_variance = self.pick_initial_variance(item_id, space, index);\n         self.inferred_infos.push(InferredInfo { item_id: item_id,\n                                                 kind: kind,\n                                                 space: space,\n                                                 index: index,\n                                                 param_id: param_id,\n-                                                term: term });\n+                                                term: term,\n+                                                initial_variance: initial_variance });\n         let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n         assert!(newly_added);\n \n-        debug!(\"add_inferred(item_id={}, \\\n+        debug!(\"add_inferred(item_path={}, \\\n+                item_id={}, \\\n                 kind={:?}, \\\n+                space={:?}, \\\n                 index={}, \\\n-                param_id={},\n-                inf_index={:?})\",\n-                item_id, kind, index, param_id, inf_index);\n+                param_id={}, \\\n+                inf_index={:?}, \\\n+                initial_variance={:?})\",\n+               ty::item_path_str(self.tcx, ast_util::local_def(item_id)),\n+               item_id, kind, space, index, param_id, inf_index,\n+               initial_variance);\n+    }\n+\n+    fn pick_initial_variance(&self,\n+                             item_id: ast::NodeId,\n+                             space: ParamSpace,\n+                             index: uint)\n+                             -> ty::Variance\n+    {\n+        match space {\n+            SelfSpace | FnSpace => {\n+                ty::Bivariant\n+            }\n+\n+            TypeSpace => {\n+                match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n+                    Some(&(_, ref variances)) => variances[index],\n+                    None => ty::Bivariant\n+                }\n+            }\n+        }\n     }\n \n     fn num_inferred(&self) -> uint {\n@@ -339,44 +464,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n \n-        let inferreds_on_entry = self.num_inferred();\n-\n-        // NB: In the code below for writing the results back into the\n-        // tcx, we rely on the fact that all inferreds for a particular\n-        // item are assigned continuous indices.\n-        match item.node {\n-            ast::ItemTrait(..) => {\n-                self.add_inferred(item.id, TypeParam, SelfSpace, 0, item.id);\n-            }\n-            _ => { }\n-        }\n-\n         match item.node {\n             ast::ItemEnum(_, ref generics) |\n-            ast::ItemStruct(_, ref generics) |\n+            ast::ItemStruct(_, ref generics) => {\n+                self.add_inferreds_for_item(item.id, false, generics);\n+            }\n             ast::ItemTrait(_, ref generics, _, _) => {\n-                for (i, p) in generics.lifetimes.iter().enumerate() {\n-                    let id = p.lifetime.id;\n-                    self.add_inferred(item.id, RegionParam, TypeSpace, i, id);\n-                }\n-                for (i, p) in generics.ty_params.iter().enumerate() {\n-                    self.add_inferred(item.id, TypeParam, TypeSpace, i, p.id);\n-                }\n-\n-                // If this item has no type or lifetime parameters,\n-                // then there are no variances to infer, so just\n-                // insert an empty entry into the variance map.\n-                // Arguably we could just leave the map empty in this\n-                // case but it seems cleaner to be able to distinguish\n-                // \"invalid item id\" from \"item id with no\n-                // parameters\".\n-                if self.num_inferred() == inferreds_on_entry {\n-                    let newly_added = self.tcx.item_variance_map.borrow_mut().insert(\n-                        ast_util::local_def(item.id),\n-                        self.empty_variances.clone()).is_none();\n-                    assert!(newly_added);\n-                }\n-\n+                self.add_inferreds_for_item(item.id, true, generics);\n                 visit::walk_item(self, item);\n             }\n \n@@ -404,16 +498,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n struct ConstraintContext<'a, 'tcx: 'a> {\n     terms_cx: TermsContext<'a, 'tcx>,\n \n-    // These are the def-id of the std::marker::InvariantType,\n-    // std::marker::InvariantLifetime, and so on. The arrays\n-    // are indexed by the `ParamKind` (type, lifetime, self). Note\n-    // that there are no marker types for self, so the entries for\n-    // self are always None.\n-    invariant_lang_items: [Option<ast::DefId>; 2],\n-    covariant_lang_items: [Option<ast::DefId>; 2],\n-    contravariant_lang_items: [Option<ast::DefId>; 2],\n-    unsafe_cell_lang_item: Option<ast::DefId>,\n-\n     // These are pointers to common `ConstantTerm` instances\n     covariant: VarianceTermPtr<'a>,\n     contravariant: VarianceTermPtr<'a>,\n@@ -433,40 +517,14 @@ struct Constraint<'a> {\n \n fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n                                         krate: &ast::Crate)\n-                                        -> ConstraintContext<'a, 'tcx> {\n-    let mut invariant_lang_items = [None; 2];\n-    let mut covariant_lang_items = [None; 2];\n-    let mut contravariant_lang_items = [None; 2];\n-\n-    covariant_lang_items[TypeParam as uint] =\n-        terms_cx.tcx.lang_items.covariant_type();\n-    covariant_lang_items[RegionParam as uint] =\n-        terms_cx.tcx.lang_items.covariant_lifetime();\n-\n-    contravariant_lang_items[TypeParam as uint] =\n-        terms_cx.tcx.lang_items.contravariant_type();\n-    contravariant_lang_items[RegionParam as uint] =\n-        terms_cx.tcx.lang_items.contravariant_lifetime();\n-\n-    invariant_lang_items[TypeParam as uint] =\n-        terms_cx.tcx.lang_items.invariant_type();\n-    invariant_lang_items[RegionParam as uint] =\n-        terms_cx.tcx.lang_items.invariant_lifetime();\n-\n-    let unsafe_cell_lang_item = terms_cx.tcx.lang_items.unsafe_cell_type();\n-\n+                                        -> ConstraintContext<'a, 'tcx>\n+{\n     let covariant = terms_cx.arena.alloc(ConstantTerm(ty::Covariant));\n     let contravariant = terms_cx.arena.alloc(ConstantTerm(ty::Contravariant));\n     let invariant = terms_cx.arena.alloc(ConstantTerm(ty::Invariant));\n     let bivariant = terms_cx.arena.alloc(ConstantTerm(ty::Bivariant));\n     let mut constraint_cx = ConstraintContext {\n         terms_cx: terms_cx,\n-\n-        invariant_lang_items: invariant_lang_items,\n-        covariant_lang_items: covariant_lang_items,\n-        contravariant_lang_items: contravariant_lang_items,\n-        unsafe_cell_lang_item: unsafe_cell_lang_item,\n-\n         covariant: covariant,\n         contravariant: contravariant,\n         invariant: invariant,\n@@ -487,7 +545,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n         match item.node {\n             ast::ItemEnum(ref enum_definition, _) => {\n-                let generics = &ty::lookup_item_type(tcx, did).generics;\n+                let scheme = ty::lookup_item_type(tcx, did);\n+\n+                // Not entirely obvious: constraints on structs/enums do not\n+                // affect the variance of their type parameters. See discussion\n+                // in comment at top of module.\n+                //\n+                // self.add_constraints_from_generics(&scheme.generics);\n \n                 // Hack: If we directly call `ty::enum_variants`, it\n                 // annoyingly takes it upon itself to run off and\n@@ -505,29 +569,48 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                                                           &**ast_variant,\n                                                           /*discriminant*/ 0);\n                     for arg_ty in &variant.args {\n-                        self.add_constraints_from_ty(generics, *arg_ty, self.covariant);\n+                        self.add_constraints_from_ty(&scheme.generics, *arg_ty, self.covariant);\n                     }\n                 }\n             }\n \n             ast::ItemStruct(..) => {\n-                let generics = &ty::lookup_item_type(tcx, did).generics;\n+                let scheme = ty::lookup_item_type(tcx, did);\n+\n+                // Not entirely obvious: constraints on structs/enums do not\n+                // affect the variance of their type parameters. See discussion\n+                // in comment at top of module.\n+                //\n+                // self.add_constraints_from_generics(&scheme.generics);\n+\n                 let struct_fields = ty::lookup_struct_fields(tcx, did);\n                 for field_info in &struct_fields {\n                     assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n                     let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n-                    self.add_constraints_from_ty(generics, field_ty, self.covariant);\n+                    self.add_constraints_from_ty(&scheme.generics, field_ty, self.covariant);\n                 }\n             }\n \n             ast::ItemTrait(..) => {\n+                let trait_def = ty::lookup_trait_def(tcx, did);\n+                let predicates = ty::predicates(tcx, ty::mk_self_type(tcx), &trait_def.bounds);\n+                self.add_constraints_from_predicates(&trait_def.generics,\n+                                                     &predicates[],\n+                                                     self.covariant);\n+\n                 let trait_items = ty::trait_items(tcx, did);\n                 for trait_item in &*trait_items {\n                     match *trait_item {\n                         ty::MethodTraitItem(ref method) => {\n-                            self.add_constraints_from_sig(&method.generics,\n-                                                          &method.fty.sig,\n-                                                          self.covariant);\n+                            self.add_constraints_from_predicates(\n+                                &method.generics,\n+                                method.predicates.predicates.get_slice(FnSpace),\n+                                self.contravariant);\n+\n+                            self.add_constraints_from_sig(\n+                                &method.generics,\n+                                &method.fty.sig,\n+                                self.covariant);\n                         }\n                         ty::TypeTraitItem(_) => {}\n                     }\n@@ -544,9 +627,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             ast::ItemTy(..) |\n             ast::ItemImpl(..) |\n             ast::ItemMac(..) => {\n-                visit::walk_item(self, item);\n             }\n         }\n+\n+        visit::walk_item(self, item);\n     }\n }\n \n@@ -648,15 +732,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n \n-        if self.invariant_lang_items[kind as uint] == Some(item_def_id) {\n-            self.invariant\n-        } else if self.covariant_lang_items[kind as uint] == Some(item_def_id) {\n-            self.covariant\n-        } else if self.contravariant_lang_items[kind as uint] == Some(item_def_id) {\n-            self.contravariant\n-        } else if kind == TypeParam && Some(item_def_id) == self.unsafe_cell_lang_item {\n-            self.invariant\n-        } else if param_def_id.krate == ast::LOCAL_CRATE {\n+        if param_def_id.krate == ast::LOCAL_CRATE {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n@@ -724,14 +800,35 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n+    fn add_constraints_from_trait_ref(&mut self,\n+                                      generics: &ty::Generics<'tcx>,\n+                                      trait_ref: &ty::TraitRef<'tcx>,\n+                                      variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_trait_ref: trait_ref={} variance={:?}\",\n+               trait_ref.repr(self.tcx()),\n+               variance);\n+\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n+\n+        self.add_constraints_from_substs(\n+            generics,\n+            trait_ref.def_id,\n+            trait_def.generics.types.as_slice(),\n+            trait_def.generics.regions.as_slice(),\n+            trait_ref.substs,\n+            variance);\n+    }\n+\n     /// Adds constraints appropriate for an instance of `ty` appearing\n     /// in a context with the generics defined in `generics` and\n     /// ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n                                generics: &ty::Generics<'tcx>,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n+        debug!(\"add_constraints_from_ty(ty={}, variance={:?})\",\n+               ty.repr(self.tcx()),\n+               variance);\n \n         match ty.sty {\n             ty::ty_bool |\n@@ -754,6 +851,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_ty(generics, typ, variance);\n             }\n \n+\n             ty::ty_ptr(ref mt) => {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n@@ -797,27 +895,16 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ty_trait(ref data) => {\n-                let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                                      self.tcx().types.err);\n-                let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id());\n-\n-                // Traits never declare region parameters in the self\n-                // space nor anything in the fn space.\n-                assert!(trait_def.generics.regions.is_empty_in(subst::SelfSpace));\n-                assert!(trait_def.generics.types.is_empty_in(subst::FnSpace));\n-                assert!(trait_def.generics.regions.is_empty_in(subst::FnSpace));\n+                let poly_trait_ref =\n+                    data.principal_trait_ref_with_self_ty(self.tcx(),\n+                                                          self.tcx().types.err);\n \n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n \n-                self.add_constraints_from_substs(\n-                    generics,\n-                    trait_ref.def_id(),\n-                    trait_def.generics.types.get_slice(subst::TypeSpace),\n-                    trait_def.generics.regions.get_slice(subst::TypeSpace),\n-                    trait_ref.substs(),\n-                    variance);\n+                // Ignore the SelfSpace, it is erased.\n+                self.add_constraints_from_trait_ref(generics, &*poly_trait_ref.0, variance);\n \n                 let projections = data.projection_bounds_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);\n@@ -845,7 +932,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_sig(generics, sig, variance);\n             }\n \n-            ty::ty_infer(..) | ty::ty_err => {\n+            ty::ty_err => {\n+                // we encounter this when walking the trait references for object\n+                // types, where we use ty_err as the Self type\n+            }\n+\n+            ty::ty_infer(..) => {\n                 self.tcx().sess.bug(\n                     &format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n@@ -864,14 +956,19 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n+        debug!(\"add_constraints_from_substs(def_id={}, substs={}, variance={:?})\",\n+               def_id.repr(self.tcx()),\n+               substs.repr(self.tcx()),\n+               variance);\n \n         for p in type_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n                                        p.space, p.index as uint);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_ty = *substs.types.get(p.space, p.index as uint);\n+            debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n+                   variance_decl, variance_i);\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n         }\n \n@@ -885,6 +982,51 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n+    fn add_constraints_from_predicates(&mut self,\n+                                       generics: &ty::Generics<'tcx>,\n+                                       predicates: &[ty::Predicate<'tcx>],\n+                                       variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_generics({})\",\n+               generics.repr(self.tcx()));\n+\n+        for predicate in predicates.iter() {\n+            match *predicate {\n+                ty::Predicate::Trait(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_trait_ref(generics, &*data.trait_ref, variance);\n+                }\n+\n+                ty::Predicate::Equate(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_ty(generics, data.0, variance);\n+                    self.add_constraints_from_ty(generics, data.1, variance);\n+                }\n+\n+                ty::Predicate::TypeOutlives(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_ty(generics, data.0, variance);\n+\n+                    let variance_r = self.xform(variance, self.contravariant);\n+                    self.add_constraints_from_region(generics, data.1, variance_r);\n+                }\n+\n+                ty::Predicate::RegionOutlives(ty::Binder(ref data)) => {\n+                    // `'a : 'b` is still true if 'a gets bigger\n+                    self.add_constraints_from_region(generics, data.0, variance);\n+\n+                    // `'a : 'b` is still true if 'b gets smaller\n+                    let variance_r = self.xform(variance, self.contravariant);\n+                    self.add_constraints_from_region(generics, data.1, variance_r);\n+                }\n+\n+                ty::Predicate::Projection(ty::Binder(ref data)) => {\n+                    self.add_constraints_from_trait_ref(generics,\n+                                                        &*data.projection_ty.trait_ref,\n+                                                        variance);\n+\n+                    self.add_constraints_from_ty(generics, data.ty, self.invariant);\n+                }\n+            }\n+        }\n+    }\n+\n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n@@ -969,7 +1111,12 @@ struct SolveContext<'a, 'tcx: 'a> {\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n-    let solutions: Vec<_> = repeat(ty::Bivariant).take(terms_cx.num_inferred()).collect();\n+\n+    let solutions =\n+        terms_cx.inferred_infos.iter()\n+                               .map(|ii| ii.initial_variance)\n+                               .collect();\n+\n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,\n         constraints: constraints,\n@@ -1034,20 +1181,16 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             let mut types = VecPerParamSpace::empty();\n             let mut regions = VecPerParamSpace::empty();\n \n-            while index < num_inferred &&\n-                  inferred_infos[index].item_id == item_id {\n+            while index < num_inferred && inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n                 debug!(\"Index {} Info {} / {:?} / {:?} Variance {:?}\",\n                        index, info.index, info.kind, info.space, variance);\n                 match info.kind {\n-                    TypeParam => {\n-                        types.push(info.space, variance);\n-                    }\n-                    RegionParam => {\n-                        regions.push(info.space, variance);\n-                    }\n+                    TypeParam => { types.push(info.space, variance); }\n+                    RegionParam => { regions.push(info.space, variance); }\n                 }\n+\n                 index += 1;\n             }\n \n@@ -1065,7 +1208,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[]);\n+                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[..]);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()\n@@ -1144,3 +1287,4 @@ fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n         (x, ty::Bivariant) | (ty::Bivariant, x) => x,\n     }\n }\n+"}, {"sha": "ad91c3cb2c35b60e4b023c655ef8486403ebfd12", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -112,7 +112,7 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let buf = CString::from_slice(p.as_vec());\n+            let buf = CString::new(p.as_vec()).unwrap();\n             let fd = unsafe {\n                 libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n                            libc::S_IRWXU)"}, {"sha": "44c0acda66fba8e8c3c0384ae763d970b488fadd", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -34,7 +34,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n          class,\n          id,\n          &mut out).unwrap();\n-    String::from_utf8_lossy(&out[]).into_owned()\n+    String::from_utf8_lossy(&out[..]).into_owned()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "7ea5bd569e1996df853eeccd1e550b3a6309e49e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -236,7 +236,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                 s.push_str(&highlight::highlight(&text,\n                                                  None,\n                                                  Some(\"rust-example-rendered\")));\n-                let output = CString::from_vec(s.into_bytes());\n+                let output = CString::new(s).unwrap();\n                 hoedown_buffer_puts(ob, output.as_ptr());\n             })\n         }\n@@ -293,7 +293,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                                format!(\"{} \", sec)\n                            });\n \n-        let text = CString::from_vec(text.into_bytes());\n+        let text = CString::new(text).unwrap();\n         unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n     }\n "}, {"sha": "fc3c87389917abebacff1d984cebd20078a43e3a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -1404,8 +1404,7 @@ impl<'a> fmt::Display for Item<'a> {\n \n         try!(write!(fmt,\n         r##\"<span id='render-detail'>\n-            <a id=\"collapse-all\" href=\"#\">[-]\n-            </a>&nbsp;<a id=\"expand-all\" href=\"#\">[+]</a>\n+            <a id=\"collapse-all\" href=\"#\">[-]</a>&nbsp;<a id=\"expand-all\" href=\"#\">[+]</a>\n         </span>\"##));\n \n         // Write `src` tag"}, {"sha": "2f0755ecb898a0bf17b04cdd9b3641eb6b21f752", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -374,8 +374,8 @@ a {\n     color: #000;\n     background: transparent;\n }\n-p a { color: #4e8bca; }\n-p a:hover { text-decoration: underline; }\n+.docblock a { color: #4e8bca; }\n+.docblock a:hover { text-decoration: underline; }\n \n .content span.trait, .content a.trait, .block a.current.trait { color: #ed9603; }\n .content span.mod, .content a.mod, block a.current.mod { color: #4d76ae; }"}, {"sha": "f9e0948d7bc8a0ee6d707bb349d71d3592bf32f4", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -23,7 +23,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(env)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(old_io)]\n #![feature(libc)]"}, {"sha": "722f14fa6d4c7b0dcff44ad75f8d7f7bfa8686c2", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -293,7 +293,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n             let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n                 &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n                 _ => true\n-            }).map(|x| x.clone()).collect();\n+            }).cloned().collect();\n             if docstr.len() > 0 {\n                 a.push(clean::NameValue(\"doc\".to_string(), docstr));\n             }"}, {"sha": "c52b0bab1fa8b800129e3688e7423bca40dba82d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -333,7 +333,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     name: name,\n                     items: items.clone(),\n                     generics: gen.clone(),\n-                    bounds: b.iter().map(|x| (*x).clone()).collect(),\n+                    bounds: b.iter().cloned().collect(),\n                     id: item.id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,"}, {"sha": "10cf02f85e818579e5ed811acaa424ee4e65b251", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 84, "deletions": 10, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -12,16 +12,17 @@\n \n use std::usize;\n use std::default::Default;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n+#[cfg(stage0)] use std::hash::Hasher;\n use std::collections::hash_state::HashState;\n \n use {Decodable, Encodable, Decoder, Encoder};\n-use std::collections::{DList, RingBuf, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n+use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n use collections::enum_set::{EnumSet, CLike};\n \n impl<\n     T: Encodable\n-> Encodable for DList<T> {\n+> Encodable for LinkedList<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -32,10 +33,10 @@ impl<\n     }\n }\n \n-impl<T:Decodable> Decodable for DList<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<DList<T>, D::Error> {\n+impl<T:Decodable> Decodable for LinkedList<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n         d.read_seq(|d, len| {\n-            let mut list = DList::new();\n+            let mut list = LinkedList::new();\n             for i in 0..len {\n                 list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n@@ -44,7 +45,7 @@ impl<T:Decodable> Decodable for DList<T> {\n     }\n }\n \n-impl<T: Encodable> Encodable for RingBuf<T> {\n+impl<T: Encodable> Encodable for VecDeque<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -55,10 +56,10 @@ impl<T: Encodable> Encodable for RingBuf<T> {\n     }\n }\n \n-impl<T:Decodable> Decodable for RingBuf<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<RingBuf<T>, D::Error> {\n+impl<T:Decodable> Decodable for VecDeque<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n-            let mut deque: RingBuf<T> = RingBuf::new();\n+            let mut deque: VecDeque<T> = VecDeque::new();\n             for i in 0..len {\n                 deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n@@ -157,6 +158,7 @@ impl<\n     }\n }\n \n+#[cfg(stage0)]\n impl<K, V, S> Encodable for HashMap<K, V, S>\n     where K: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n           V: Encodable,\n@@ -175,7 +177,26 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n         })\n     }\n }\n+#[cfg(not(stage0))]\n+impl<K, V, S> Encodable for HashMap<K, V, S>\n+    where K: Encodable + Hash + Eq,\n+          V: Encodable,\n+          S: HashState,\n+{\n+    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        e.emit_map(self.len(), |e| {\n+            let mut i = 0;\n+            for (key, val) in self {\n+                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n+                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<K, V, S> Decodable for HashMap<K, V, S>\n     where K: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n           V: Decodable,\n@@ -195,7 +216,27 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n         })\n     }\n }\n+#[cfg(not(stage0))]\n+impl<K, V, S> Decodable for HashMap<K, V, S>\n+    where K: Decodable + Hash + Eq,\n+          V: Decodable,\n+          S: HashState + Default,\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n+        d.read_map(|d, len| {\n+            let state = Default::default();\n+            let mut map = HashMap::with_capacity_and_hash_state(len, state);\n+            for i in 0..len {\n+                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n+                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n+                map.insert(key, val);\n+            }\n+            Ok(map)\n+        })\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<T, S> Encodable for HashSet<T, S>\n     where T: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n           S: HashState,\n@@ -212,7 +253,24 @@ impl<T, S> Encodable for HashSet<T, S>\n         })\n     }\n }\n+#[cfg(not(stage0))]\n+impl<T, S> Encodable for HashSet<T, S>\n+    where T: Encodable + Hash + Eq,\n+          S: HashState,\n+{\n+    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            let mut i = 0;\n+            for e in self {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<T, S> Decodable for HashSet<T, S>\n     where T: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n           S: HashState + Default,\n@@ -229,6 +287,22 @@ impl<T, S> Decodable for HashSet<T, S>\n         })\n     }\n }\n+#[cfg(not(stage0))]\n+impl<T, S> Decodable for HashSet<T, S>\n+    where T: Decodable + Hash + Eq,\n+          S: HashState + Default,\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n+        d.read_seq(|d, len| {\n+            let state = Default::default();\n+            let mut set = HashSet::with_capacity_and_hash_state(len, state);\n+            for i in 0..len {\n+                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(set)\n+        })\n+    }\n+}\n \n impl<V: Encodable> Encodable for VecMap<V> {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {"}, {"sha": "a0f42815b439611b61fd1e07a748b69adaa2cef4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -1120,7 +1120,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n         match *self {\n-            Json::String(ref s) => Some(&s[]),\n+            Json::String(ref s) => Some(&s[..]),\n             _ => None\n         }\n     }\n@@ -2237,7 +2237,7 @@ impl ::Decoder for Decoder {\n                 return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n             }\n         };\n-        let idx = match names.iter().position(|n| *n == &name[]) {\n+        let idx = match names.iter().position(|n| *n == &name[..]) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -3461,7 +3461,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(&mem_buf[]).unwrap();\n+        let json_str = from_utf8(&mem_buf[..]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3477,7 +3477,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(&mem_buf[]).unwrap();\n+        let json_str = from_utf8(&mem_buf[..]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3517,7 +3517,7 @@ mod tests {\n             write!(&mut writer, \"{}\",\n                    super::as_pretty_json(&json).indent(i)).unwrap();\n \n-            let printed = from_utf8(&writer[]).unwrap();\n+            let printed = from_utf8(&writer[..]).unwrap();\n \n             // Check for indents at each line\n             let lines: Vec<&str> = printed.lines().collect();\n@@ -3549,7 +3549,7 @@ mod tests {\n         let mut map = HashMap::new();\n         map.insert(Enum::Foo, 0);\n         let result = json::encode(&map).unwrap();\n-        assert_eq!(&result[], r#\"{\"Foo\":0}\"#);\n+        assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n         let decoded: HashMap<Enum, _> = json::decode(&result).unwrap();\n         assert_eq!(map, decoded);\n     }"}, {"sha": "d476fd72abc3b03ea2f8cc8b729f8182fa78fad6", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -31,7 +31,6 @@ Core encoding and decoding interfaces.\n #![feature(int_uint)]\n #![feature(old_io)]\n #![feature(old_path)]\n-#![feature(hash)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]"}, {"sha": "70f0ba4bb23af013d1429e4d5fcdb2e882a85bac", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -326,7 +326,7 @@ impl Encodable for str {\n \n impl Encodable for String {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self[])\n+        s.emit_str(&self[..])\n     }\n }\n "}, {"sha": "ade4f1f0533ee73abdb388bab488ac4a9a2d0452", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 49, "deletions": 90, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d", "patch": "@@ -14,12 +14,12 @@ use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n-use borrow::BorrowFrom;\n+use borrow::Borrow;\n use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n use fmt::{self, Debug};\n-use hash::{self, Hash, SipHasher};\n+use hash::{Hash, SipHasher};\n use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n use mem::{self, replace};\n@@ -440,31 +440,29 @@ impl<K, V, M> SearchResult<K, V, M> {\n     }\n }\n \n-impl<K, V, S, H> HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n-    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash<H> {\n+    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash {\n         table::make_hash(&self.hash_state, x)\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n     fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<H>\n+        where K: Borrow<Q>, Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n             .into_option()\n     }\n \n     fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<H>\n+        where K: Borrow<Q>, Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n             .into_option()\n     }\n \n@@ -490,7 +488,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     }\n }\n \n-impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n+impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     /// Create an empty HashMap.\n     ///\n     /// # Example\n@@ -520,10 +518,8 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     }\n }\n \n-impl<K, V, S, H> HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n     /// Creates an empty hashmap which will use the given hasher to hash keys.\n     ///\n@@ -1037,7 +1033,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash + Eq\n     {\n         self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n@@ -1060,7 +1056,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash + Eq\n     {\n         self.search(k).is_some()\n     }\n@@ -1086,7 +1082,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash + Eq\n     {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n@@ -1138,7 +1134,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash + Eq\n     {\n         if self.table.size() == 0 {\n             return None\n@@ -1195,10 +1191,8 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n     }\n }\n \n-impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n-    where K: Eq + Hash<H>, V: PartialEq,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> PartialEq for HashMap<K, V, S>\n+    where K: Eq + Hash, V: PartialEq, S: HashState\n {\n     fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n         if self.len() != other.len() { return false; }\n@@ -1210,17 +1204,13 @@ impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Eq for HashMap<K, V, S>\n-    where K: Eq + Hash<H>, V: Eq,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> Eq for HashMap<K, V, S>\n+    where K: Eq + Hash, V: Eq, S: HashState\n {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Debug for HashMap<K, V, S>\n-    where K: Eq + Hash<H> + Debug, V: Debug,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> Debug for HashMap<K, V, S>\n+    where K: Eq + Hash + Debug, V: Debug, S: HashState\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"HashMap {{\"));\n@@ -1235,22 +1225,20 @@ impl<K, V, S, H> Debug for HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Default for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> Default for HashMap<K, V, S>\n+    where K: Eq + Hash,\n+          S: HashState + Default,\n {\n     fn default() -> HashMap<K, V, S> {\n         HashMap::with_hash_state(Default::default())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          Q: Eq + Hash<H> + BorrowFrom<K>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash + Borrow<Q>,\n+          Q: Eq + Hash,\n+          S: HashState,\n {\n     type Output = V;\n \n@@ -1261,11 +1249,10 @@ impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          Q: Eq + Hash<H> + BorrowFrom<K>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash + Borrow<Q>,\n+          Q: Eq + Hash,\n+          S: HashState,\n {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n@@ -1373,10 +1360,8 @@ enum VacantEntryState<K, V, M> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n@@ -1387,10 +1372,8 @@ impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n@@ -1401,10 +1384,8 @@ impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> IntoIterator for HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n@@ -1550,12 +1531,11 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState + Default\n {\n-    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n+    fn from_iter<T: IntoIterator<Item=(K, V)>>(iterable: T) -> HashMap<K, V, S> {\n+        let iter = iterable.into_iter();\n         let lower = iter.size_hint().0;\n         let mut map = HashMap::with_capacity_and_hash_state(lower,\n                                                             Default::default());\n@@ -1565,12 +1545,10 @@ impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n-    fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -1606,9 +1584,9 @@ impl RandomState {\n #[unstable(feature = \"std_misc\",\n            reason = \"hashing an hash maps may be altered\")]\n impl HashState for RandomState {\n-    type Hasher = Hasher;\n-    fn hasher(&self) -> Hasher {\n-        Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n+    type Hasher = SipHasher;\n+    fn hasher(&self) -> SipHasher {\n+        SipHasher::new_with_keys(self.k0, self.k1)\n     }\n }\n \n@@ -1621,25 +1599,6 @@ impl Default for RandomState {\n     }\n }\n \n-/// A hasher implementation which is generated from `RandomState` instances.\n-///\n-/// This is the default hasher used in a `HashMap` to hash keys. Types do not\n-/// typically declare an ability to explicitly hash into this particular type,\n-/// but rather in a `H: hash::Writer` type parameter.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-pub struct Hasher { inner: SipHasher }\n-\n-impl hash::Writer for Hasher {\n-    fn write(&mut self, data: &[u8]) { self.inner.write(data) }\n-}\n-\n-impl hash::Hasher for Hasher {\n-    type Output = u64;\n-    fn reset(&mut self) { self.inner.reset() }\n-    fn finish(&self) -> u64 { self.inner.finish() }\n-}\n-\n #[cfg(test)]\n mod test_map {\n     use prelude::v1::*;"}, {"sha": "f9e5044c597616a129a687e25e0f3a35d8e7f786", "filename": "src/libstd/collections/hash/map_stage0.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "39c1458b720019cd84f52245f7e7204f085cfe88", "filename": "src/libstd/collections/hash/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "e0631a64d44b127048402f0667195daed7e4ffc6", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 52, "deletions": 76, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "68c9e02d8ad7205483c7e577506fab2c4f3299a6", "filename": "src/libstd/collections/hash/set_stage0.rs", "status": "added", "additions": 1252, "deletions": 0, "changes": 1252, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "7e6dd45b51e48f69f553388787dc490f1f843e03", "filename": "src/libstd/collections/hash/state.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "f301f6db92f96a7bf96d2ee545128212db7c9de7", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 56, "deletions": 23, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "0e64370df60ecbdc8b24ff51abc1a506ba83b8a2", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "b0fb9c29403511d13e42b274030523c50efbbf67", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "8676586e7dc2a7e32971773e026af9537bdbea25", "filename": "src/libstd/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "8976813d3f91e9681a84f48d8ca552733319ff6c", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 326, "deletions": 76, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "1bff6afb776079b0e5102ad2b0e92541d089263c", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "84149a2eb8e43353a1d9857c8a19cdecd65f379e", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "e9a8dbb4098afb3f15340725b35894ae409cf20b", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "f6cb4a8c9f36988f3b834b55261f1394eda32e70", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "fbd403ea593b8a970b0218f876a193d4cc71f778", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "51944adf3b40395f7adb88b57943ce2fb21a5b3d", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "571a1b03ef07fbd879a1e98c7caafe1838506d87", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "2d2d0d8b33a4c9e68ef0bf00e7f2511b878d7b22", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "fc3deb67f41ec97148e6a2639964129193006150", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "d05669d32b8cfc0d7f3b8b411b2bce5adc0cb471", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "c803cfbcb7d85db2b9a77b33955b1ebce56c67a8", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "e9005aa22bcfbebc37cbb051a1bcde0c412d3180", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "15eee9e4a0c02d3c2fa0360319a9cab81dec737c", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "887dc804c7af3da57949f4ea87c1fa249c46e751", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "f181fc5df5759b557ae5f9099ff12fd6061754b7", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "2e05f6d974e3ed9492917d5e8335413261e9c6bc", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "49a5efec7c2e48095a9bdc282b5274d7b24a5410", "filename": "src/libstd/path.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "5c891441198039940cab0e08776a06379d9bf860", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "61f5bd0f013606f37f2e4476acf3b155c5f7f6af", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "e2ac5ac24f89ec01269f0eb545a58d381e296b46", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "713f79c5d0814d29b64d0936779ce547cd3ce29c", "filename": "src/libstd/sys/common/net2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "ca3ae1a7a34360fa158012705feba28fbba07b83", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "8b560339f304474c6cb67d523d69a138f7c2341f", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "b8b9dcfb3c68920b2602ed2e1e22072ac5d106be", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "5c847002d2394f35c1f4d7cb9c142f40edbe2de6", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "92a47c6c3850df3a34b3ac132e83f72314db86d6", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "b79ad7031fa48dc31dcc208036ae5f5bf353eaf1", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "83b6a14b78d95fd3f1ed4d8c385ec550bbb63d11", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "3d1ef3a2c37f7e8267dfb65d84f79ba4e0e55bc1", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "3c9cdc65975f6f9f5e1b7027774b2a7dd0fa564f", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "b30ac889120c229343f6d48938c50658c24d891f", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "06fa5c4bba7253d66f4a3b45c00a6e3097168b8f", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "c90ba7645feb4b29f14a6b6854804c6d79d617e9", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "51cf30324233c772cfaa66185365640db174b275", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "2d1a5e10bd63f73a6e815452f8ea9abb41e35cf6", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "a756fb29f81aeb5f32c4d446efb633cf6220b2b9", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "6520d30487c76d978e6d5441370214c0332402c3", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "60d24e6174fd757a5cd949443ebc803ae1a6b61e", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 194, "deletions": 1, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "3653e7e31d5c6df556132b437f9ea107f16547a4", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "140e21b5d04b756cb0a1abcf4e838f74a56e3231", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "ba08f61b5575ccef6c7817b9ddc712605b296a1e", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "f660296fcd7b6c72892ac064bf3c0963376256a0", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "62e676891a0e6c349fc6581cacf302c8de2484e5", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "099f646294235d175dcdf47b59ac0daa419f7024", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "dfe3477bddc3bba2eaafb7a92479e2c1e013a6d9", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "27219774cf148c52f68f8e009fc8d7130691fdd8", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "b3afc3fc4dd13399d7ff542496a0850279f22e22", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "a6cfd1a5a9ac3c1e612b02995457433ee344987d", "filename": "src/libsyntax/diagnostics/registry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "d4ccabbd63b4a2edfb5f411a13b06b317e27440c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "38098e50dee83750ef905ce8309433f51f5c021e", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "9410a51e7a5f660a368534d275fa651d7d5e13e1", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "93098484ae01343de6df460a61db1d43048e0916", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "b912ed34ae0ad19c780be51cbd640736a7020053", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "2149c7a7f77a7da72d86848fd952f24a415865ca", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "f8bc331bfcfe7697a13bc4a0df84e03229f57075", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "281f23f9e61e8b232d2c083348bdaa90b873b790", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "9c04d1e928295d42c387eb8d3748b1e91d301c4d", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "d4dda7390a52f7788dae1cc2e2d7fcf25de6ccf0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "e17329d7d33002b96f85c9060a1962a82330b7fe", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "2c7bf713aad85d67728d2abaddaa95906c5e9dac", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "c8d48750c75093259d428d491914075dd202b827", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "664f7b3e088480e2a55ef7e6a93cba00eab2a9f1", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "fa6d934a4575581561476a177af7bb8872cdf195", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "0d92bd761b418e28e4ecd2d17817a983245a660e", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "071158fcebb5cf32da776b2e98394450dbf47108", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "3a7fa54edbdd772ab633557e8962b8041340846a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "f5201d4a8bc68f73ea9f46c07e6bca61330a561e", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "1f06db600278b4162c807fcc83d8f36bae593d2d", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "fd08cbd161bfe3db302137e480539c2b3de8d6ff", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "7ed48bdbb928dc9ace647ea772f902f3c1228e96", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "8480772ce6c1ad1b7c1528031800a9bafb06327f", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "370201e53825efef69f01d9c7313127f3a436cef", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 72, "deletions": 75, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "433c013591c2d1557b84fcbb3c7a01d69b03d506", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "1593bfb97fe1da755ff08f1697d05c65e85d9eb1", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "f26578e740120d8f33695834534ac2a6c6d15d1d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 86, "deletions": 87, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "adb5383a8fd544d0f666dbf74d92e2fb729f20d5", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "4e4a571ede7b864af3b797be5784fb6fc582e7b9", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "7b1fc91e45b5bb3547841faf5f7505210a03b5f0", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "dffeac6f3f7938df88ae352309b3a9fb068c42f3", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 85, "deletions": 11, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "0a39d3809045a2e56f745255e6b204bc5d43f8d0", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "5418533aff1d918129f9bae1f6f5059dd603fe55", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "be1c623c8590512c1f699aed09e7bc496039bd57", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "0b577f8de74c2a9b2e8178584173c29e8d134b7a", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "c40a5534efbbb4e8d3d6146c6c513a124a420c62", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "82c1a4b1195ce06ca1f948e39c13fe01f613991f", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "4e94be59ade0dd540f2f743138df9cae9ae52dd1", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "4891e6382e3e8aa89d530aa18427836428c47157", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "224f1ef1a8b9b6feaaa5e559b6bbfea5f2c953e5", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "43c882c7d5b8a69c1c660049f7abf6f969fe8764", "filename": "src/rustbook/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Frustbook%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Frustbook%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ferror.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "c5d4875423ae1ee62893be77b7183018ff35ccf4", "filename": "src/rustbook/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ftest.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "cc42b288e6638a0f7c36e385dbf25012c8ac791c", "filename": "src/test/auxiliary/coherence-orphan-lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fcoherence-orphan-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fcoherence-orphan-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence-orphan-lib.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "0a65174911ec7149b473c4e9216bb35e2c173a27", "filename": "src/test/auxiliary/default_type_params_xc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "ca5c6072cb371b98bd9ea096807f65abbb570944", "filename": "src/test/auxiliary/inner_static.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Finner_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Finner_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finner_static.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "a48088609f982ca7565fccde0828912430998f4c", "filename": "src/test/auxiliary/issue-14421.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-14421.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-14421.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-14421.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "b590160a0c2ab5d8c1c467660a26dbc4818081a8", "filename": "src/test/auxiliary/issue-16643.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-16643.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "fb55a077005eb8d9662a02f4e24f1b2f67900784", "filename": "src/test/auxiliary/issue-17662.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-17662.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-17662.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17662.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "96f33f97a696973c891a36bbe0e0a742f5598bf9", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "89b3b56121a1614961297566eb8088c21a5808ef", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "4ce7e3079e330a0a82f8b445076d55bf51ff4c92", "filename": "src/test/auxiliary/issue_20389.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue_20389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue_20389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_20389.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "545e15fe1664d657ef941e983f72dd1b6c66b4d9", "filename": "src/test/auxiliary/issue_3907.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3907.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "9006a5d1775f764eb7f569fa7f491b09dd7b27da", "filename": "src/test/auxiliary/issue_8401.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_8401.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "4f2792aebcd2408639256271ae4254015e744f07", "filename": "src/test/auxiliary/issue_9123.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue_9123.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fissue_9123.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_9123.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "b9cc20b63cc5640258ac6bc70afde33440a6d24a", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "e9d98889ff854062f3434ea105b5b91f401fca81", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "ffb234f70c8e754ec7f4d86411101598ac100118", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "fb535eb8336f9b2df90d027c61cef3fb9f731097", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "fc1bea5a9fd41128c88b9a1b2506ed398cdb9477", "filename": "src/test/auxiliary/nested_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnested_item.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "cf3e9903b5ad001e2bef688a792cfe8c5e630d07", "filename": "src/test/auxiliary/orphan_check_diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Forphan_check_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Forphan_check_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Forphan_check_diagnostics.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "3c8cba13ae73d07296407009850cd94adca716ed", "filename": "src/test/auxiliary/overloaded_autoderef_xc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "d0ab944813a0ac7c025de01bc2a3d0811825abac", "filename": "src/test/auxiliary/plugin_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_args.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "42691579491bbfb7e7abb069fd995bf62288e8f0", "filename": "src/test/auxiliary/private_trait_xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}, {"sha": "04f1062c16f02a572e8f97c9345b2f6b99469983", "filename": "src/test/auxiliary/svh-a-base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522d09dfecbeca1595f25ac58c6d0178bbd21d7d/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs?ref=522d09dfecbeca1595f25ac58c6d0178bbd21d7d"}]}