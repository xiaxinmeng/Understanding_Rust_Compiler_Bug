{"sha": "92f3b74db21c9cd6faaa013b716efb8535ba24d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZjNiNzRkYjIxYzljZDZmYWFhMDEzYjcxNmVmYjg1MzViYTI0ZDk=", "commit": {"author": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-09-02T17:04:38Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-04T20:23:23Z"}, "message": "Use struct+impl syntax instead of the (deprecated) struct with embedded methods syntax. Also standardise the comment indentation and add some whitespace between items.", "tree": {"sha": "32f997198f071d68f03400091139f271f702fd49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32f997198f071d68f03400091139f271f702fd49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92f3b74db21c9cd6faaa013b716efb8535ba24d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92f3b74db21c9cd6faaa013b716efb8535ba24d9", "html_url": "https://github.com/rust-lang/rust/commit/92f3b74db21c9cd6faaa013b716efb8535ba24d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92f3b74db21c9cd6faaa013b716efb8535ba24d9/comments", "author": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5f674ae2a2c06f9e76af23d270fa22365aadc62", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f674ae2a2c06f9e76af23d270fa22365aadc62", "html_url": "https://github.com/rust-lang/rust/commit/c5f674ae2a2c06f9e76af23d270fa22365aadc62"}], "stats": {"total": 336, "additions": 185, "deletions": 151}, "files": [{"sha": "c7e41f86e72ead7991e3b64b35ac475421d4e1e0", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 185, "deletions": 151, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/92f3b74db21c9cd6faaa013b716efb8535ba24d9/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f3b74db21c9cd6faaa013b716efb8535ba24d9/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=92f3b74db21c9cd6faaa013b716efb8535ba24d9", "patch": "@@ -2,47 +2,57 @@ use vec::{to_mut, from_elem};\n \n export Bitv, from_bytes, from_bools, from_fn;\n \n+struct SmallBitv {\n+    /// only the lowest nbits of this value are used. the rest is undefined.\n+    mut bits: u32\n+}\n+\n+fn SmallBitv(bits: u32) -> SmallBitv {\n+    SmallBitv {bits: bits}\n+}\n+\n /// a mask that has a 1 for each defined bit in a small_bitv, assuming n bits\n #[inline(always)]\n fn small_mask(nbits: uint) -> u32 {\n     (1 << nbits) - 1\n }\n \n-struct SmallBitv {\n-    /// only the lowest nbits of this value are used. the rest is undefined.\n-    let mut bits: u32;\n-    new(bits: u32) { self.bits = bits; }\n-    priv {\n-        #[inline(always)]\n-        fn bits_op(right_bits: u32, nbits: uint, f: fn(u32, u32) -> u32)\n-                                                                     -> bool {\n-            let mask = small_mask(nbits);\n-            let old_b: u32 = self.bits;\n-            let new_b = f(old_b, right_bits);\n-            self.bits = new_b;\n-            mask & old_b != mask & new_b\n-        }\n+impl SmallBitv {\n+\n+    #[inline(always)]\n+    fn bits_op(right_bits: u32, nbits: uint, f: fn(u32, u32) -> u32) -> bool {\n+        let mask = small_mask(nbits);\n+        let old_b: u32 = self.bits;\n+        let new_b = f(old_b, right_bits);\n+        self.bits = new_b;\n+        mask & old_b != mask & new_b\n     }\n+\n     #[inline(always)]\n     fn union(s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n+\n     #[inline(always)]\n     fn intersect(s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n+\n     #[inline(always)]\n     fn become(s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n+\n     #[inline(always)]\n     fn difference(s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 ^ u2)\n     }\n+\n     #[inline(always)]\n     pure fn get(i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n+\n     #[inline(always)]\n     fn set(i: uint, x: bool) {\n         if x {\n@@ -52,25 +62,41 @@ struct SmallBitv {\n             self.bits &= !(1<<i as u32);\n         }\n     }\n+\n     #[inline(always)]\n     fn equals(b: &SmallBitv, nbits: uint) -> bool {\n         let mask = small_mask(nbits);\n         mask & self.bits == mask & b.bits\n     }\n+\n     #[inline(always)]\n     fn clear() { self.bits = 0; }\n+\n     #[inline(always)]\n     fn set_all() { self.bits = !0; }\n+\n     #[inline(always)]\n     fn is_true(nbits: uint) -> bool {\n         small_mask(nbits) & !self.bits == 0\n     }\n+\n     #[inline(always)]\n     fn is_false(nbits: uint) -> bool {\n         small_mask(nbits) & self.bits == 0\n     }\n+\n     #[inline(always)]\n     fn invert() { self.bits = !self.bits; }\n+\n+}\n+\n+struct BigBitv {\n+    // only mut b/c of clone and lack of other constructor\n+    mut storage: ~[mut uint]\n+}\n+\n+fn BigBitv(-storage: ~[mut uint]) -> BigBitv {\n+    BigBitv {storage: storage}\n }\n \n /**\n@@ -89,33 +115,27 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n     }\n }\n \n-struct BigBitv {\n-    // only mut b/c of clone and lack of other constructor\n-    let mut storage: ~[mut uint];\n-    new(-storage: ~[mut uint]) {\n-        self.storage <- storage;\n-    }\n-    priv {\n-        #[inline(always)]\n-        fn process(b: &BigBitv, nbits: uint, op: fn(uint, uint) -> uint)\n-                                                                     -> bool {\n-            let len = b.storage.len();\n-            assert (self.storage.len() == len);\n-            let mut changed = false;\n-            do uint::range(0, len) |i| {\n-                let mask = big_mask(nbits, i);\n-                let w0 = self.storage[i] & mask;\n-                let w1 = b.storage[i] & mask;\n-                let w = op(w0, w1) & mask;\n-                if w0 != w unchecked {\n-                    changed = true;\n-                    self.storage[i] = w;\n-                }\n-                true\n+impl BigBitv {\n+\n+    #[inline(always)]\n+    fn process(b: &BigBitv, nbits: uint, op: fn(uint, uint) -> uint) -> bool {\n+        let len = b.storage.len();\n+        assert (self.storage.len() == len);\n+        let mut changed = false;\n+        do uint::range(0, len) |i| {\n+            let mask = big_mask(nbits, i);\n+            let w0 = self.storage[i] & mask;\n+            let w1 = b.storage[i] & mask;\n+            let w = op(w0, w1) & mask;\n+            if w0 != w unchecked {\n+                changed = true;\n+                self.storage[i] = w;\n             }\n-            changed\n+            true\n         }\n+        changed\n     }\n+\n     #[inline(always)]\n      fn each_storage(op: fn(&uint) -> bool) {\n         for uint::range(0, self.storage.len()) |i| {\n@@ -125,34 +145,41 @@ struct BigBitv {\n             if !b { break; }\n         }\n      }\n+\n     #[inline(always)]\n     fn invert() { for self.each_storage() |w| { w = !w } }\n+\n     #[inline(always)]\n     fn union(b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, lor)\n     }\n+\n     #[inline(always)]\n     fn intersect(b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, land)\n     }\n+\n     #[inline(always)]\n     fn become(b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, right)\n     }\n+\n     #[inline(always)]\n     fn difference(b: &BigBitv, nbits: uint) -> bool {\n         self.invert();\n         let b = self.intersect(b, nbits);\n         self.invert();\n         b\n     }\n+\n     #[inline(always)]\n     pure fn get(i: uint) -> bool {\n         let w = i / uint_bits;\n         let b = i % uint_bits;\n         let x = 1 & self.storage[w] >> b;\n         x == 1\n     }\n+\n     #[inline(always)]\n     fn set(i: uint, x: bool) {\n         let w = i / uint_bits;\n@@ -161,6 +188,7 @@ struct BigBitv {\n         self.storage[w] = if x { self.storage[w] | flag }\n                  else { self.storage[w] & !flag };\n     }\n+\n     #[inline(always)]\n     fn equals(b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n@@ -171,6 +199,7 @@ struct BigBitv {\n             }\n         }\n     }\n+\n }\n \n enum BitvVariant { Big(~BigBitv), Small(~SmallBitv) }\n@@ -179,80 +208,85 @@ enum Op {Union, Intersect, Assign, Difference}\n \n // The bitvector type\n struct Bitv {\n-    let rep: BitvVariant;\n-    let nbits: uint;\n+    rep: BitvVariant,\n+    nbits: uint\n+}\n \n-    new(nbits: uint, init: bool) {\n-        self.nbits = nbits;\n-        if nbits <= 32 {\n-          self.rep = Small(~SmallBitv(if init {!0} else {0}));\n-        }\n-        else {\n-          let nelems = nbits/uint_bits +\n-                       if nbits % uint_bits == 0 {0} else {1};\n-          let elem = if init {!0} else {0};\n-          let s = to_mut(from_elem(nelems, elem));\n-          self.rep = Big(~BigBitv(s));\n-        };\n-    }\n-\n-    priv {\n-        fn die() -> ! {\n-            fail ~\"Tried to do operation on bit vectors with \\\n-                  different sizes\";\n+fn Bitv (nbits: uint, init: bool) -> Bitv {\n+    let rep = if nbits <= 32 {\n+        Small(~SmallBitv(if init {!0} else {0}))\n+    }\n+    else {\n+        let nelems = nbits/uint_bits +\n+                     if nbits % uint_bits == 0 {0} else {1};\n+        let elem = if init {!0} else {0};\n+        let s = to_mut(from_elem(nelems, elem));\n+        Big(~BigBitv(s))\n+    };\n+    Bitv {rep: rep, nbits: nbits}\n+}\n+\n+priv impl Bitv {\n+\n+    fn die() -> ! {\n+        fail ~\"Tried to do operation on bit vectors with different sizes\";\n+    }\n+\n+    #[inline(always)]\n+    fn do_op(op: Op, other: &Bitv) -> bool {\n+        if self.nbits != other.nbits {\n+            self.die();\n         }\n-        #[inline(always)]\n-        fn do_op(op: Op, other: &Bitv) -> bool {\n-            if self.nbits != other.nbits {\n-                self.die();\n-            }\n-            match self.rep {\n-              Small(s) => match other.rep {\n-                Small(s1) => match op {\n-                  Union      => s.union(s1,      self.nbits),\n-                  Intersect  => s.intersect(s1,  self.nbits),\n-                  Assign     => s.become(s1,     self.nbits),\n-                  Difference => s.difference(s1, self.nbits)\n-                },\n-                Big(_) => self.die()\n-              },\n-              Big(s) => match other.rep {\n-                Small(_) => self.die(),\n-                Big(s1) => match op {\n-                  Union      => s.union(s1,      self.nbits),\n-                  Intersect  => s.intersect(s1,  self.nbits),\n-                  Assign     => s.become(s1,     self.nbits),\n-                  Difference => s.difference(s1, self.nbits)\n-                }\n-              }\n+        match self.rep {\n+          Small(s) => match other.rep {\n+            Small(s1) => match op {\n+              Union      => s.union(s1,      self.nbits),\n+              Intersect  => s.intersect(s1,  self.nbits),\n+              Assign     => s.become(s1,     self.nbits),\n+              Difference => s.difference(s1, self.nbits)\n+            },\n+            Big(_) => self.die()\n+          },\n+          Big(s) => match other.rep {\n+            Small(_) => self.die(),\n+            Big(s1) => match op {\n+              Union      => s.union(s1,      self.nbits),\n+              Intersect  => s.intersect(s1,  self.nbits),\n+              Assign     => s.become(s1,     self.nbits),\n+              Difference => s.difference(s1, self.nbits)\n             }\n+          }\n         }\n     }\n \n-/**\n- * Calculates the union of two bitvectors\n- *\n- * Sets `self` to the union of `self` and `v1`. Both bitvectors must be\n- * the same length. Returns 'true' if `self` changed.\n-*/\n+}\n+\n+impl Bitv {\n+\n+    /**\n+     * Calculates the union of two bitvectors\n+     *\n+     * Sets `self` to the union of `self` and `v1`. Both bitvectors must be\n+     * the same length. Returns 'true' if `self` changed.\n+    */\n     #[inline(always)]\n     fn union(v1: &Bitv) -> bool { self.do_op(Union, v1) }\n \n-/**\n- * Calculates the intersection of two bitvectors\n- *\n- * Sets `self` to the intersection of `self` and `v1`. Both bitvectors must be\n- * the same length. Returns 'true' if `self` changed.\n-*/\n+    /**\n+     * Calculates the intersection of two bitvectors\n+     *\n+     * Sets `self` to the intersection of `self` and `v1`. Both bitvectors\n+     * must be the same length. Returns 'true' if `self` changed.\n+    */\n     #[inline(always)]\n     fn intersect(v1: &Bitv) -> bool { self.do_op(Intersect, v1) }\n \n-/**\n- * Assigns the value of `v1` to `self`\n- *\n- * Both bitvectors must be the same length. Returns `true` if `self` was\n- * changed\n- */\n+    /**\n+     * Assigns the value of `v1` to `self`\n+     *\n+     * Both bitvectors must be the same length. Returns `true` if `self` was\n+     * changed\n+     */\n     #[inline(always)]\n     fn assign(v: &Bitv) -> bool { self.do_op(Assign, v) }\n \n@@ -282,11 +316,11 @@ struct Bitv {\n        }\n     }\n \n-/**\n- * Set the value of a bit at a given index\n- *\n- * `i` must be less than the length of the bitvector.\n- */\n+    /**\n+     * Set the value of a bit at a given index\n+     *\n+     * `i` must be less than the length of the bitvector.\n+     */\n     #[inline(always)]\n     fn set(i: uint, x: bool) {\n       assert (i < self.nbits);\n@@ -296,12 +330,12 @@ struct Bitv {\n       }\n     }\n \n-/**\n- * Compares two bitvectors\n- *\n- * Both bitvectors must be the same length. Returns `true` if both bitvectors\n- * contain identical elements.\n- */\n+    /**\n+     * Compares two bitvectors\n+     *\n+     * Both bitvectors must be the same length. Returns `true` if both\n+     * bitvectors contain identical elements.\n+     */\n     #[inline(always)]\n     fn equal(v1: Bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n@@ -342,18 +376,19 @@ struct Bitv {\n         Big(s) => for s.each_storage() |w| { w = !w } }\n     }\n \n-/**\n- * Calculate the difference between two bitvectors\n- *\n- * Sets each element of `v0` to the value of that element minus the element\n- * of `v1` at the same index. Both bitvectors must be the same length.\n- *\n- * Returns `true` if `v0` was changed.\n- */\n-   #[inline(always)]\n+    /**\n+     * Calculate the difference between two bitvectors\n+     *\n+     * Sets each element of `v0` to the value of that element minus the\n+     * element of `v1` at the same index. Both bitvectors must be the same\n+     * length.\n+     *\n+     * Returns `true` if `v0` was changed.\n+     */\n+    #[inline(always)]\n     fn difference(v: ~Bitv) -> bool { self.do_op(Difference, v) }\n \n-        /// Returns true if all bits are 1\n+    /// Returns true if all bits are 1\n     #[inline(always)]\n     fn is_true() -> bool {\n       match self.rep {\n@@ -375,7 +410,6 @@ struct Bitv {\n     }\n \n     /// Returns true if all bits are 0\n-\n     fn is_false() -> bool {\n       match self.rep {\n         Small(b) => b.is_false(self.nbits),\n@@ -390,11 +424,11 @@ struct Bitv {\n       return if self.get(i) { 1 } else { 0 };\n     }\n \n-/**\n- * Converts `self` to a vector of uint with the same length.\n- *\n- * Each uint in the resulting vector has either value 0u or 1u.\n- */\n+    /**\n+     * Converts `self` to a vector of uint with the same length.\n+     *\n+     * Each uint in the resulting vector has either value 0u or 1u.\n+     */\n     fn to_vec() -> ~[uint] {\n         vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n@@ -437,36 +471,36 @@ struct Bitv {\n         vec::from_fn(self.nbits, |i| self[i])\n     }\n \n-/**\n- * Converts `self` to a string.\n- *\n- * The resulting string has the same length as `self`, and each\n- * character is either '0' or '1'.\n- */\n+    /**\n+     * Converts `self` to a string.\n+     *\n+     * The resulting string has the same length as `self`, and each\n+     * character is either '0' or '1'.\n+     */\n      fn to_str() -> ~str {\n        let mut rs = ~\"\";\n        for self.each() |i| { if i { rs += ~\"1\"; } else { rs += ~\"0\"; } };\n        rs\n      }\n \n \n-/**\n- * Compare a bitvector to a vector of uint\n- *\n- * The uint vector is expected to only contain the values 0u and 1u. Both the\n- * bitvector and vector must have the same length\n- */\n-     fn eq_vec(v: ~[uint]) -> bool {\n-       assert self.nbits == v.len();\n-       let mut i = 0;\n-       while i < self.nbits {\n-           let w0 = self.get(i);\n-           let w1 = v[i];\n-           if !w0 && w1 != 0u || w0 && w1 == 0u { return false; }\n-           i = i + 1;\n-       }\n-       true\n-     }\n+    /**\n+     * Compare a bitvector to a vector of uint\n+     *\n+     * The uint vector is expected to only contain the values 0u and 1u. Both\n+     * the bitvector and vector must have the same length\n+     */\n+    fn eq_vec(v: ~[uint]) -> bool {\n+        assert self.nbits == v.len();\n+        let mut i = 0;\n+        while i < self.nbits {\n+            let w0 = self.get(i);\n+            let w1 = v[i];\n+            if !w0 && w1 != 0u || w0 && w1 == 0u { return false; }\n+            i = i + 1;\n+        }\n+        true\n+    }\n \n     fn ones(f: fn(uint) -> bool) {\n         for uint::range(0, self.nbits) |i| {\n@@ -476,7 +510,7 @@ struct Bitv {\n         }\n     }\n \n-} // end of bitv class\n+}\n \n /**\n  * Transform a byte-vector into a bitv. Each byte becomes 8 bits,"}]}