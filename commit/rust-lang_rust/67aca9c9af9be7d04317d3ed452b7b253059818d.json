{"sha": "67aca9c9af9be7d04317d3ed452b7b253059818d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3YWNhOWM5YWY5YmU3ZDA0MzE3ZDNlZDQ1MmI3YjI1MzA1OTgxOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-07T13:11:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-07T13:11:10Z"}, "message": "auto merge of #10844 : huonw/rust/deriving-expn-info, r=alexcrichton\n\nPreviously something like\r\n\r\n    struct NotEq;\r\n\r\n    #[deriving(Eq)]\r\n    struct Error {\r\n        foo: NotEq\r\n    }\r\n\r\nwould just point to the `foo` field, with no mention of the\r\n`deriving(Eq)`. With this patch, the compiler creates a note saying \"in\r\nexpansion of #[deriving(Eq)]\" pointing to the Eq.\r\n\r\n(includes some cleanup/preparation; the commit view might be nicer, to filter out the noise of the first one.)", "tree": {"sha": "fbbc08cd04b09eb4fb7816b24267f785c02fcb68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbbc08cd04b09eb4fb7816b24267f785c02fcb68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67aca9c9af9be7d04317d3ed452b7b253059818d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67aca9c9af9be7d04317d3ed452b7b253059818d", "html_url": "https://github.com/rust-lang/rust/commit/67aca9c9af9be7d04317d3ed452b7b253059818d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67aca9c9af9be7d04317d3ed452b7b253059818d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c719ec1bc3939c2d30f7fbd3160db5c6497fc63", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c719ec1bc3939c2d30f7fbd3160db5c6497fc63", "html_url": "https://github.com/rust-lang/rust/commit/7c719ec1bc3939c2d30f7fbd3160db5c6497fc63"}, {"sha": "0c0e73eed6ee914c0be3fbc2ed200482a51c3fa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c0e73eed6ee914c0be3fbc2ed200482a51c3fa9", "html_url": "https://github.com/rust-lang/rust/commit/0c0e73eed6ee914c0be3fbc2ed200482a51c3fa9"}], "stats": {"total": 530, "additions": 299, "deletions": 231}, "files": [{"sha": "cf8dbfdcad6a5e7cef768b3e6d9573a528142991", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -18,7 +18,7 @@ use std::vec;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n-use syntax::codemap::{dummy_sp, Span, ExpnInfo, NameAndSpan};\n+use syntax::codemap::{dummy_sp, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold::ast_fold;\n@@ -158,6 +158,7 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n         call_site: dummy_sp(),\n         callee: NameAndSpan {\n             name: @\"test\",\n+            format: MacroAttribute,\n             span: None\n         }\n     });"}, {"sha": "f4cb19bfa247400c16883211e130bb160d83a5e3", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -161,8 +161,22 @@ pub struct LocWithOpt {\n // used to be structural records. Better names, anyone?\n pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n+\n #[deriving(IterBytes)]\n-pub struct NameAndSpan {name: @str, span: Option<Span>}\n+pub enum MacroFormat {\n+    // e.g. #[deriving(...)] <item>\n+    MacroAttribute,\n+    // e.g. `format!()`\n+    MacroBang\n+}\n+\n+#[deriving(IterBytes)]\n+pub struct NameAndSpan {\n+    name: @str,\n+    // the format with which the macro was invoked.\n+    format: MacroFormat,\n+    span: Option<Span>\n+}\n \n /// Extra information for tracking macro expansion of spans\n #[deriving(IterBytes)]"}, {"sha": "59f33bc77696fcf9757f172142e789bb77b1d5ee", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -342,8 +342,13 @@ fn highlight_lines(cm: @codemap::CodeMap,\n fn print_macro_backtrace(cm: @codemap::CodeMap, sp: Span) {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.as_ref().map_default(~\"\", |span| cm.span_to_str(*span));\n+        let (pre, post) = match ei.callee.format {\n+            codemap::MacroAttribute => (\"#[\", \"]\"),\n+            codemap::MacroBang => (\"\", \"!\")\n+        };\n+\n         print_diagnostic(ss, note,\n-                         format!(\"in expansion of {}!\", ei.callee.name));\n+                         format!(\"in expansion of {}{}{}\", pre, ei.callee.name, post));\n         let ss = cm.span_to_str(ei.call_site);\n         print_diagnostic(ss, note, \"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);"}, {"sha": "9285defe69ea11db1b80a1318ded48f9b3aef7a3", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -20,6 +20,8 @@ pub fn expand_deriving_clone(cx: @ExtCtxt,\n                              in_items: ~[@item])\n                           -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"clone\", \"Clone\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -37,7 +39,7 @@ pub fn expand_deriving_clone(cx: @ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n@@ -46,6 +48,8 @@ pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n                                   in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"clone\", \"DeepClone\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -65,7 +69,7 @@ pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n fn cs_clone("}, {"sha": "74680266cb709c29ef2156b085db21dfee6b0b77", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -45,6 +45,8 @@ pub fn expand_deriving_eq(cx: @ExtCtxt,\n     );\n \n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"cmp\", \"Eq\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -53,5 +55,5 @@ pub fn expand_deriving_eq(cx: @ExtCtxt,\n             md!(\"ne\", cs_ne)\n         ]\n     };\n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }"}, {"sha": "d48cfbd7dd70787e671049f7a13be5dcf0cab3db", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -35,6 +35,8 @@ pub fn expand_deriving_ord(cx: @ExtCtxt,\n     );\n \n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"cmp\", \"Ord\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -45,7 +47,7 @@ pub fn expand_deriving_ord(cx: @ExtCtxt,\n             md!(\"ge\", false, true)\n         ]\n     };\n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n /// Strict inequality."}, {"sha": "ab822d14b484519e73998a3fc64d2967bc3b719e", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -24,6 +24,8 @@ pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n     }\n \n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"cmp\", \"TotalEq\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -40,5 +42,5 @@ pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }"}, {"sha": "2ace39a3486885221b6544ab5d1e7d04068882ef", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -21,6 +21,8 @@ pub fn expand_deriving_totalord(cx: @ExtCtxt,\n                                 mitem: @MetaItem,\n                                 in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"cmp\", \"TotalOrd\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -38,7 +40,7 @@ pub fn expand_deriving_totalord(cx: @ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n "}, {"sha": "0aade760b7ba689e4f9b9dd8fe52488e5d2a9647", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -24,6 +24,8 @@ pub fn expand_deriving_decodable(cx: @ExtCtxt,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new_(~[\"extra\", \"serialize\", \"Decodable\"], None,\n                          ~[~Literal(Path::new_local(\"__D\"))], true),\n         additional_bounds: ~[],\n@@ -46,7 +48,7 @@ pub fn expand_deriving_decodable(cx: @ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n fn decodable_substructure(cx: @ExtCtxt, span: Span,"}, {"sha": "393d808a0254e1e435eb6b7f5cea44aeb84ead84", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -20,6 +20,8 @@ pub fn expand_deriving_default(cx: @ExtCtxt,\n                             in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"default\", \"Default\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -36,7 +38,7 @@ pub fn expand_deriving_default(cx: @ExtCtxt,\n             },\n         ]\n     };\n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n fn default_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "09210116c37675a023565d9d78b6c811995581ce", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -86,6 +86,8 @@ pub fn expand_deriving_encodable(cx: @ExtCtxt,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new_(~[\"extra\", \"serialize\", \"Encodable\"], None,\n                          ~[~Literal(Path::new_local(\"__E\"))], true),\n         additional_bounds: ~[],\n@@ -108,7 +110,7 @@ pub fn expand_deriving_encodable(cx: @ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n fn encodable_substructure(cx: @ExtCtxt, span: Span,"}, {"sha": "fefc4a9bafb6957f925f8f7dd12441af6c8d3ed5", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 228, "deletions": 213, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -179,7 +179,8 @@ use ast::{P, enum_def, Expr, Ident, Generics, struct_def};\n \n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use codemap::{Span,respan};\n+use codemap;\n+use codemap::Span;\n use opt_vec;\n \n use std::vec;\n@@ -188,6 +189,11 @@ pub use self::ty::*;\n mod ty;\n \n pub struct TraitDef<'self> {\n+    /// The extension context\n+    cx: @ExtCtxt,\n+    /// The span for the current #[deriving(Foo)] header.\n+    span: Span,\n+\n     /// Path of the trait, including any type parameters\n     path: Path<'self>,\n     /// Additional bounds required of any type parameters of the type,\n@@ -310,23 +316,20 @@ pub type EnumNonMatchFunc<'self> =\n \n \n impl<'self> TraitDef<'self> {\n-    pub fn expand(&self, cx: @ExtCtxt,\n-                  trait_span: Span,\n+    pub fn expand(&self,\n                   _mitem: @ast::MetaItem,\n                   in_items: ~[@ast::item]) -> ~[@ast::item] {\n         let mut result = ~[];\n         for item in in_items.iter() {\n             result.push(*item);\n             match item.node {\n                 ast::item_struct(struct_def, ref generics) => {\n-                    result.push(self.expand_struct_def(cx, trait_span,\n-                                                       struct_def,\n+                    result.push(self.expand_struct_def(struct_def,\n                                                        item.ident,\n                                                        generics));\n                 }\n                 ast::item_enum(ref enum_def, ref generics) => {\n-                    result.push(self.expand_enum_def(cx, trait_span,\n-                                                     enum_def,\n+                    result.push(self.expand_enum_def(enum_def,\n                                                      item.ident,\n                                                      generics));\n                 }\n@@ -346,12 +349,14 @@ impl<'self> TraitDef<'self> {\n      * where B1, B2, ... are the bounds given by `bounds_paths`.'\n      *\n      */\n-    fn create_derived_impl(&self, cx: @ExtCtxt, trait_span: Span,\n+    fn create_derived_impl(&self,\n                            type_ident: Ident, generics: &Generics,\n                            methods: ~[@ast::method]) -> @ast::item {\n-        let trait_path = self.path.to_path(cx, trait_span, type_ident, generics);\n+        let cx = self.cx;\n+        let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n-        let mut trait_generics = self.generics.to_generics(cx, trait_span, type_ident, generics);\n+        let mut trait_generics = self.generics.to_generics(cx, self.span,\n+                                                           type_ident, generics);\n         // Copy the lifetimes\n         for l in generics.lifetimes.iter() {\n             trait_generics.lifetimes.push(*l)\n@@ -363,7 +368,7 @@ impl<'self> TraitDef<'self> {\n             let mut bounds = opt_vec::from(\n                 // extra restrictions on the generics parameters to the type being derived upon\n                 self.additional_bounds.map(|p| {\n-                    cx.typarambound(p.to_path(cx, trait_span, type_ident, generics))\n+                    cx.typarambound(p.to_path(cx, self.span, type_ident, generics))\n                 }));\n             // require the current trait\n             bounds.push(cx.typarambound(trait_path.clone()));\n@@ -376,22 +381,23 @@ impl<'self> TraitDef<'self> {\n \n         // Create the type parameters on the `self` path.\n         let self_ty_params = generics.ty_params.map(|ty_param| {\n-            cx.ty_ident(trait_span, ty_param.ident)\n+            cx.ty_ident(self.span, ty_param.ident)\n         });\n \n         let self_lifetimes = generics.lifetimes.clone();\n \n         // Create the type of `self`.\n-        let self_type = cx.ty_path(cx.path_all(trait_span, false, ~[ type_ident ], self_lifetimes,\n-                                               opt_vec::take_vec(self_ty_params)), None);\n+        let self_type = cx.ty_path(\n+            cx.path_all(self.span, false, ~[ type_ident ], self_lifetimes,\n+                             opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute(\n-            trait_span,\n-            cx.meta_name_value(trait_span,\n+            self.span,\n+            cx.meta_name_value(self.span,\n                                @\"doc\",\n                                ast::lit_str(@\"Automatically derived.\", ast::CookedStr)));\n         cx.item(\n-            trait_span,\n+            self.span,\n             ::parse::token::special_idents::clownshoes_extensions,\n             ~[doc_attr],\n             ast::item_impl(trait_generics,\n@@ -400,99 +406,96 @@ impl<'self> TraitDef<'self> {\n                            methods.map(|x| *x)))\n     }\n \n-    fn expand_struct_def(&self, cx: @ExtCtxt,\n-                         trait_span: Span,\n+    fn expand_struct_def(&self,\n                          struct_def: &struct_def,\n                          type_ident: Ident,\n                          generics: &Generics) -> @ast::item {\n         let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(cx, trait_span, type_ident, generics);\n+                method_def.split_self_nonself_args(self, type_ident, generics);\n \n             let body = if method_def.is_static() {\n                 method_def.expand_static_struct_method_body(\n-                    cx, trait_span,\n+                    self,\n                     struct_def,\n                     type_ident,\n                     self_args, nonself_args)\n             } else {\n-                method_def.expand_struct_method_body(cx, trait_span,\n+                method_def.expand_struct_method_body(self,\n                                                      struct_def,\n                                                      type_ident,\n                                                      self_args, nonself_args)\n             };\n \n-            method_def.create_method(cx, trait_span,\n+            method_def.create_method(self,\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n         });\n \n-        self.create_derived_impl(cx, trait_span, type_ident, generics, methods)\n+        self.create_derived_impl(type_ident, generics, methods)\n     }\n \n     fn expand_enum_def(&self,\n-                       cx: @ExtCtxt, trait_span: Span,\n                        enum_def: &enum_def,\n                        type_ident: Ident,\n                        generics: &Generics) -> @ast::item {\n         let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(cx, trait_span, type_ident, generics);\n+                method_def.split_self_nonself_args(self, type_ident, generics);\n \n             let body = if method_def.is_static() {\n                 method_def.expand_static_enum_method_body(\n-                    cx, trait_span,\n+                    self,\n                     enum_def,\n                     type_ident,\n                     self_args, nonself_args)\n             } else {\n-                method_def.expand_enum_method_body(cx, trait_span,\n+                method_def.expand_enum_method_body(self,\n                                                    enum_def,\n                                                    type_ident,\n                                                    self_args, nonself_args)\n             };\n \n-            method_def.create_method(cx, trait_span,\n+            method_def.create_method(self,\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n         });\n \n-        self.create_derived_impl(cx, trait_span, type_ident, generics, methods)\n+        self.create_derived_impl(type_ident, generics, methods)\n     }\n }\n \n impl<'self> MethodDef<'self> {\n     fn call_substructure_method(&self,\n-                                cx: @ExtCtxt,\n-                                trait_span: Span,\n+                                trait_: &TraitDef,\n                                 type_ident: Ident,\n                                 self_args: &[@Expr],\n                                 nonself_args: &[@Expr],\n                                 fields: &SubstructureFields)\n         -> @Expr {\n         let substructure = Substructure {\n             type_ident: type_ident,\n-            method_ident: cx.ident_of(self.name),\n+            method_ident: trait_.cx.ident_of(self.name),\n             self_args: self_args,\n             nonself_args: nonself_args,\n             fields: fields\n         };\n-        (self.combine_substructure)(cx, trait_span,\n+        (self.combine_substructure)(trait_.cx, trait_.span,\n                                     &substructure)\n     }\n \n-    fn get_ret_ty(&self, cx: @ExtCtxt, trait_span: Span,\n+    fn get_ret_ty(&self, trait_: &TraitDef,\n                   generics: &Generics, type_ident: Ident) -> P<ast::Ty> {\n-        self.ret_ty.to_ty(cx, trait_span, type_ident, generics)\n+        self.ret_ty.to_ty(trait_.cx, trait_.span, type_ident, generics)\n     }\n \n     fn is_static(&self) -> bool {\n         self.explicit_self.is_none()\n     }\n \n-    fn split_self_nonself_args(&self, cx: @ExtCtxt, trait_span: Span,\n+    fn split_self_nonself_args(&self, trait_: &TraitDef,\n                                type_ident: Ident, generics: &Generics)\n         -> (ast::explicit_self, ~[@Expr], ~[@Expr], ~[(Ident, P<ast::Ty>)]) {\n \n@@ -503,22 +506,23 @@ impl<'self> MethodDef<'self> {\n \n         let ast_explicit_self = match self.explicit_self {\n             Some(ref self_ptr) => {\n-                let (self_expr, explicit_self) = ty::get_explicit_self(cx, trait_span, self_ptr);\n+                let (self_expr, explicit_self) =\n+                    ty::get_explicit_self(trait_.cx, trait_.span, self_ptr);\n \n                 self_args.push(self_expr);\n                 nonstatic = true;\n \n                 explicit_self\n             }\n-            None => respan(trait_span, ast::sty_static),\n+            None => codemap::respan(trait_.span, ast::sty_static),\n         };\n \n         for (i, ty) in self.args.iter().enumerate() {\n-            let ast_ty = ty.to_ty(cx, trait_span, type_ident, generics);\n-            let ident = cx.ident_of(format!(\"__arg_{}\", i));\n+            let ast_ty = ty.to_ty(trait_.cx, trait_.span, type_ident, generics);\n+            let ident = trait_.cx.ident_of(format!(\"__arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n-            let arg_expr = cx.expr_ident(trait_span, ident);\n+            let arg_expr = trait_.cx.expr_ident(trait_.span, ident);\n \n             match *ty {\n                 // for static methods, just treat any Self\n@@ -527,7 +531,7 @@ impl<'self> MethodDef<'self> {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(~Self, _) if nonstatic => {\n-                    self_args.push(cx.expr_deref(trait_span, arg_expr))\n+                    self_args.push(trait_.cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {\n                     nonself_args.push(arg_expr);\n@@ -538,27 +542,27 @@ impl<'self> MethodDef<'self> {\n         (ast_explicit_self, self_args, nonself_args, arg_tys)\n     }\n \n-    fn create_method(&self, cx: @ExtCtxt, trait_span: Span,\n+    fn create_method(&self, trait_: &TraitDef,\n                      type_ident: Ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n                      arg_types: ~[(Ident, P<ast::Ty>)],\n                      body: @Expr) -> @ast::method {\n         // create the generics that aren't for Self\n-        let fn_generics = self.generics.to_generics(cx, trait_span, type_ident, generics);\n+        let fn_generics = self.generics.to_generics(trait_.cx, trait_.span, type_ident, generics);\n \n         let args = arg_types.move_iter().map(|(name, ty)| {\n-            cx.arg(trait_span, name, ty)\n+            trait_.cx.arg(trait_.span, name, ty)\n         }).collect();\n \n-        let ret_type = self.get_ret_ty(cx, trait_span, generics, type_ident);\n+        let ret_type = self.get_ret_ty(trait_, generics, type_ident);\n \n-        let method_ident = cx.ident_of(self.name);\n-        let fn_decl = cx.fn_decl(args, ret_type);\n-        let body_block = cx.block_expr(body);\n+        let method_ident = trait_.cx.ident_of(self.name);\n+        let fn_decl = trait_.cx.fn_decl(args, ret_type);\n+        let body_block = trait_.cx.block_expr(body);\n \n         let attrs = if self.inline {\n-            ~[cx.attribute(trait_span, cx.meta_word(trait_span, @\"inline\"))]\n+            ~[trait_.cx.attribute(trait_.span, trait_.cx.meta_word(trait_.span, @\"inline\"))]\n         } else {\n             ~[]\n         };\n@@ -573,7 +577,7 @@ impl<'self> MethodDef<'self> {\n             decl: fn_decl,\n             body: body_block,\n             id: ast::DUMMY_NODE_ID,\n-            span: trait_span,\n+            span: trait_.span,\n             self_id: ast::DUMMY_NODE_ID,\n             vis: ast::inherited,\n         }\n@@ -601,8 +605,7 @@ impl<'self> MethodDef<'self> {\n    ~~~\n     */\n     fn expand_struct_method_body(&self,\n-                                 cx: @ExtCtxt,\n-                                 trait_span: Span,\n+                                 trait_: &TraitDef,\n                                  struct_def: &struct_def,\n                                  type_ident: Ident,\n                                  self_args: &[@Expr],\n@@ -613,10 +616,9 @@ impl<'self> MethodDef<'self> {\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = ~[];\n         for i in range(0u, self_args.len()) {\n-            let (pat, ident_expr) = create_struct_pattern(cx, trait_span,\n-                                                          type_ident, struct_def,\n-                                                          format!(\"__self_{}\", i),\n-                                                          ast::MutImmutable);\n+            let (pat, ident_expr) = trait_.create_struct_pattern(type_ident, struct_def,\n+                                                                 format!(\"__self_{}\", i),\n+                                                                 ast::MutImmutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n         }\n@@ -638,13 +640,14 @@ impl<'self> MethodDef<'self> {\n                     }\n                 }).collect()\n             }\n-            [] => { cx.span_bug(trait_span, \"No self arguments to non-static \\\n-                                       method in generic `deriving`\") }\n+            [] => { trait_.cx.span_bug(trait_.span,\n+                                       \"No self arguments to non-static method \\\n+                                       in generic `deriving`\") }\n         };\n \n         // body of the inner most destructuring match\n         let mut body = self.call_substructure_method(\n-            cx, trait_span,\n+            trait_,\n             type_ident,\n             self_args,\n             nonself_args,\n@@ -654,23 +657,22 @@ impl<'self> MethodDef<'self> {\n         // structs. This is actually right-to-left, but it shoudn't\n         // matter.\n         for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n-            body = cx.expr_match(trait_span, arg_expr,\n-                                 ~[ cx.arm(trait_span, ~[pat], body) ])\n+            body = trait_.cx.expr_match(trait_.span, arg_expr,\n+                                        ~[ trait_.cx.arm(trait_.span, ~[pat], body) ])\n         }\n         body\n     }\n \n     fn expand_static_struct_method_body(&self,\n-                                        cx: @ExtCtxt,\n-                                        trait_span: Span,\n+                                        trait_: &TraitDef,\n                                         struct_def: &struct_def,\n                                         type_ident: Ident,\n                                         self_args: &[@Expr],\n                                         nonself_args: &[@Expr])\n         -> @Expr {\n-        let summary = summarise_struct(cx, trait_span, struct_def);\n+        let summary = trait_.summarise_struct(struct_def);\n \n-        self.call_substructure_method(cx, trait_span,\n+        self.call_substructure_method(trait_,\n                                       type_ident,\n                                       self_args, nonself_args,\n                                       &StaticStruct(struct_def, summary))\n@@ -703,15 +705,14 @@ impl<'self> MethodDef<'self> {\n    ~~~\n     */\n     fn expand_enum_method_body(&self,\n-                               cx: @ExtCtxt,\n-                               trait_span: Span,\n+                               trait_: &TraitDef,\n                                enum_def: &enum_def,\n                                type_ident: Ident,\n                                self_args: &[@Expr],\n                                nonself_args: &[@Expr])\n         -> @Expr {\n         let mut matches = ~[];\n-        self.build_enum_match(cx, trait_span, enum_def, type_ident,\n+        self.build_enum_match(trait_, enum_def, type_ident,\n                               self_args, nonself_args,\n                               None, &mut matches, 0)\n     }\n@@ -739,7 +740,7 @@ impl<'self> MethodDef<'self> {\n     the first call).\n     */\n     fn build_enum_match(&self,\n-                        cx: @ExtCtxt, trait_span: Span,\n+                        trait_: &TraitDef,\n                         enum_def: &enum_def,\n                         type_ident: Ident,\n                         self_args: &[@Expr],\n@@ -748,12 +749,13 @@ impl<'self> MethodDef<'self> {\n                         matches_so_far: &mut ~[(uint, P<ast::variant>,\n                                               ~[(Span, Option<Ident>, @Expr)])],\n                         match_count: uint) -> @Expr {\n+        let cx = trait_.cx;\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n             if matches_so_far.len() == 0 {\n-                cx.span_bug(trait_span, \"no self match on an enum in generic \\\n-                                   `deriving`\");\n+                cx.span_bug(trait_.span,\n+                            \"no self match on an enum in generic `deriving`\");\n             }\n             // we currently have a vec of vecs, where each\n             // subvec is the fields of one of the arguments,\n@@ -803,7 +805,7 @@ impl<'self> MethodDef<'self> {\n                     substructure = EnumNonMatching(*matches_so_far);\n                 }\n             }\n-            self.call_substructure_method(cx, trait_span, type_ident,\n+            self.call_substructure_method(trait_, type_ident,\n                                           self_args, nonself_args,\n                                           &substructure)\n \n@@ -822,46 +824,44 @@ impl<'self> MethodDef<'self> {\n                 // make a matching-variant match, and a _ match.\n                 let index = match matching {\n                     Some(i) => i,\n-                    None => cx.span_bug(trait_span,\n+                    None => cx.span_bug(trait_.span,\n                                         \"Non-matching variants when required to \\\n                                         be matching in generic `deriving`\")\n                 };\n \n                 // matching-variant match\n                 let variant = enum_def.variants[index];\n-                let (pattern, idents) = create_enum_variant_pattern(cx,\n-                                                                    variant,\n-                                                                    current_match_str,\n-                                                                    ast::MutImmutable);\n+                let (pattern, idents) = trait_.create_enum_variant_pattern(variant,\n+                                                                           current_match_str,\n+                                                                           ast::MutImmutable);\n \n                 matches_so_far.push((index, variant, idents));\n-                let arm_expr = self.build_enum_match(cx, trait_span,\n+                let arm_expr = self.build_enum_match(trait_,\n                                                      enum_def,\n                                                      type_ident,\n                                                      self_args, nonself_args,\n                                                      matching,\n                                                      matches_so_far,\n                                                      match_count + 1);\n                 matches_so_far.pop();\n-                arms.push(cx.arm(trait_span, ~[ pattern ], arm_expr));\n+                arms.push(cx.arm(trait_.span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n                     let e = &EnumNonMatching(&[]);\n-                    let wild_expr = self.call_substructure_method(cx, trait_span, type_ident,\n+                    let wild_expr = self.call_substructure_method(trait_, type_ident,\n                                                                   self_args, nonself_args,\n                                                                   e);\n-                    let wild_arm = cx.arm(trait_span,\n-                                          ~[ cx.pat_wild(trait_span) ],\n+                    let wild_arm = cx.arm(trait_.span,\n+                                          ~[ cx.pat_wild(trait_.span) ],\n                                           wild_expr);\n                     arms.push(wild_arm);\n                 }\n             } else {\n                 // create an arm matching on each variant\n                 for (index, &variant) in enum_def.variants.iter().enumerate() {\n-                    let (pattern, idents) = create_enum_variant_pattern(cx,\n-                                                                        variant,\n-                                                                        current_match_str,\n-                                                                        ast::MutImmutable);\n+                    let (pattern, idents) = trait_.create_enum_variant_pattern(variant,\n+                                                                               current_match_str,\n+                                                                               ast::MutImmutable);\n \n                     matches_so_far.push((index, variant, idents));\n                     let new_matching =\n@@ -870,7 +870,7 @@ impl<'self> MethodDef<'self> {\n                             Some(i) if index == i => Some(i),\n                             _ => None\n                         };\n-                    let arm_expr = self.build_enum_match(cx, trait_span,\n+                    let arm_expr = self.build_enum_match(trait_,\n                                                          enum_def,\n                                                          type_ident,\n                                                          self_args, nonself_args,\n@@ -879,19 +879,18 @@ impl<'self> MethodDef<'self> {\n                                                          match_count + 1);\n                     matches_so_far.pop();\n \n-                    let arm = cx.arm(trait_span, ~[ pattern ], arm_expr);\n+                    let arm = cx.arm(trait_.span, ~[ pattern ], arm_expr);\n                     arms.push(arm);\n                 }\n             }\n \n             // match foo { arm, arm, arm, ... }\n-            cx.expr_match(trait_span, self_args[match_count], arms)\n+            cx.expr_match(trait_.span, self_args[match_count], arms)\n         }\n     }\n \n     fn expand_static_enum_method_body(&self,\n-                                      cx: @ExtCtxt,\n-                                      trait_span: Span,\n+                                      trait_: &TraitDef,\n                                       enum_def: &enum_def,\n                                       type_ident: Ident,\n                                       self_args: &[@Expr],\n@@ -900,160 +899,176 @@ impl<'self> MethodDef<'self> {\n         let summary = enum_def.variants.map(|v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n-                ast::tuple_variant_kind(ref args) => Unnamed(args.map(|va| va.ty.span)),\n+                ast::tuple_variant_kind(ref args) => {\n+                    Unnamed(args.map(|va| trait_.set_expn_info(va.ty.span)))\n+                }\n                 ast::struct_variant_kind(struct_def) => {\n-                    summarise_struct(cx, trait_span, struct_def)\n+                    trait_.summarise_struct(struct_def)\n                 }\n             };\n             (ident, summary)\n         });\n-        self.call_substructure_method(cx,\n-                                      trait_span, type_ident,\n+        self.call_substructure_method(trait_, type_ident,\n                                       self_args, nonself_args,\n                                       &StaticEnum(enum_def, summary))\n     }\n }\n \n-fn summarise_struct(cx: @ExtCtxt, trait_span: Span,\n-                    struct_def: &struct_def) -> StaticFields {\n-    let mut named_idents = ~[];\n-    let mut just_spans = ~[];\n-    for field in struct_def.fields.iter() {\n-        match field.node.kind {\n-            ast::named_field(ident, _) => named_idents.push((ident, field.span)),\n-            ast::unnamed_field => just_spans.push(field.span),\n-        }\n+#[deriving(Eq)] // dogfooding!\n+enum StructType {\n+    Unknown, Record, Tuple\n+}\n+\n+// general helper methods.\n+impl<'a> TraitDef<'a> {\n+    fn set_expn_info(&self, mut to_set: Span) -> Span {\n+        let trait_name = match self.path.path.last_opt() {\n+            None => self.cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n+            Some(name) => *name\n+        };\n+        to_set.expn_info = Some(@codemap::ExpnInfo {\n+            call_site: to_set,\n+            callee: codemap::NameAndSpan {\n+                name: format!(\"deriving({})\", trait_name).to_managed(),\n+                format: codemap::MacroAttribute,\n+                span: Some(self.span)\n+            }\n+        });\n+        to_set\n     }\n \n-    match (just_spans.is_empty(), named_idents.is_empty()) {\n-        (false, false) => cx.span_bug(trait_span,\n-                                      \"A struct with named and unnamed \\\n-                                      fields in generic `deriving`\"),\n-        // named fields\n-        (_, false) => Named(named_idents),\n-        // tuple structs (includes empty structs)\n-        (_, _)     => Unnamed(just_spans)\n+    fn summarise_struct(&self, struct_def: &struct_def) -> StaticFields {\n+        let mut named_idents = ~[];\n+        let mut just_spans = ~[];\n+        for field in struct_def.fields.iter(){\n+            let sp = self.set_expn_info(field.span);\n+            match field.node.kind {\n+                ast::named_field(ident, _) => named_idents.push((ident, sp)),\n+                ast::unnamed_field => just_spans.push(sp),\n+            }\n+        }\n+\n+        match (just_spans.is_empty(), named_idents.is_empty()) {\n+            (false, false) => self.cx.span_bug(self.span,\n+                                               \"A struct with named and unnamed \\\n+                                               fields in generic `deriving`\"),\n+            // named fields\n+            (_, false) => Named(named_idents),\n+            // tuple structs (includes empty structs)\n+            (_, _)     => Unnamed(just_spans)\n+        }\n     }\n-}\n \n-pub fn create_subpatterns(cx: @ExtCtxt,\n+    fn create_subpatterns(&self,\n                           field_paths: ~[ast::Path],\n                           mutbl: ast::Mutability)\n-                   -> ~[@ast::Pat] {\n-    field_paths.map(|path| {\n-        cx.pat(path.span,\n-               ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n-    })\n-}\n+                          -> ~[@ast::Pat] {\n+        field_paths.map(|path| {\n+            self.cx.pat(path.span,\n+                        ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n+            })\n+    }\n \n-#[deriving(Eq)] // dogfooding!\n-enum StructType {\n-    Unknown, Record, Tuple\n-}\n+    fn create_struct_pattern(&self,\n+                             struct_ident: Ident,\n+                             struct_def: &struct_def,\n+                             prefix: &str,\n+                             mutbl: ast::Mutability)\n+        -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n+        let cx = self.cx;\n+\n+        if struct_def.fields.is_empty() {\n+            return (\n+                cx.pat_ident_binding_mode(\n+                    self.span, struct_ident, ast::BindByValue(ast::MutImmutable)),\n+                ~[]);\n+        }\n \n-fn create_struct_pattern(cx: @ExtCtxt,\n-                         trait_span: Span,\n-                         struct_ident: Ident,\n-                         struct_def: &struct_def,\n-                         prefix: &str,\n-                         mutbl: ast::Mutability)\n-    -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n-    if struct_def.fields.is_empty() {\n-        return (\n-            cx.pat_ident_binding_mode(\n-                trait_span, struct_ident, ast::BindByValue(ast::MutImmutable)),\n-            ~[]);\n-    }\n+        let matching_path = cx.path(self.span, ~[ struct_ident ]);\n \n-    let matching_path = cx.path(trait_span, ~[ struct_ident ]);\n+        let mut paths = ~[];\n+        let mut ident_expr = ~[];\n+        let mut struct_type = Unknown;\n \n-    let mut paths = ~[];\n-    let mut ident_expr = ~[];\n-    let mut struct_type = Unknown;\n+        for (i, struct_field) in struct_def.fields.iter().enumerate() {\n+            let sp = self.set_expn_info(struct_field.span);\n+            let opt_id = match struct_field.node.kind {\n+                ast::named_field(ident, _) if (struct_type == Unknown ||\n+                                               struct_type == Record) => {\n+                    struct_type = Record;\n+                    Some(ident)\n+                }\n+                ast::unnamed_field if (struct_type == Unknown ||\n+                                       struct_type == Tuple) => {\n+                    struct_type = Tuple;\n+                    None\n+                }\n+                _ => {\n+                    cx.span_bug(sp, \"A struct with named and unnamed fields in `deriving`\");\n+                }\n+            };\n+            let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n+            paths.push(path.clone());\n+            ident_expr.push((sp, opt_id, cx.expr_path(path)));\n+        }\n \n-    for (i, struct_field) in struct_def.fields.iter().enumerate() {\n-        let opt_id = match struct_field.node.kind {\n-            ast::named_field(ident, _) if (struct_type == Unknown ||\n-                                           struct_type == Record) => {\n-                struct_type = Record;\n-                Some(ident)\n-            }\n-            ast::unnamed_field if (struct_type == Unknown ||\n-                                   struct_type == Tuple) => {\n-                struct_type = Tuple;\n-                None\n-            }\n-            _ => {\n-                cx.span_bug(struct_field.span,\n-                            \"A struct with named and unnamed fields in `deriving`\");\n-            }\n+        let subpats = self.create_subpatterns(paths, mutbl);\n+\n+        // struct_type is definitely not Unknown, since struct_def.fields\n+        // must be nonempty to reach here\n+        let pattern = if struct_type == Record {\n+            let field_pats = subpats.iter().zip(ident_expr.iter()).map(|(&pat, &(_, id, _))| {\n+                // id is guaranteed to be Some\n+                ast::FieldPat { ident: id.unwrap(), pat: pat }\n+            }).collect();\n+            cx.pat_struct(self.span, matching_path, field_pats)\n+        } else {\n+            cx.pat_enum(self.span, matching_path, subpats)\n         };\n-        let path = cx.path_ident(struct_field.span,\n-                                 cx.ident_of(format!(\"{}_{}\", prefix, i)));\n-        paths.push(path.clone());\n-        ident_expr.push((struct_field.span, opt_id, cx.expr_path(path)));\n-    }\n \n-    let subpats = create_subpatterns(cx, paths, mutbl);\n+        (pattern, ident_expr)\n+    }\n \n-    // struct_type is definitely not Unknown, since struct_def.fields\n-    // must be nonempty to reach here\n-    let pattern = if struct_type == Record {\n-        let field_pats = subpats.iter().zip(ident_expr.iter()).map(|(&pat, &(_, id, _))| {\n-            // id is guaranteed to be Some\n-            ast::FieldPat { ident: id.unwrap(), pat: pat }\n-        }).collect();\n-        cx.pat_struct(trait_span, matching_path, field_pats)\n-    } else {\n-        cx.pat_enum(trait_span, matching_path, subpats)\n-    };\n+    fn create_enum_variant_pattern(&self,\n+                                   variant: &ast::variant,\n+                                   prefix: &str,\n+                                   mutbl: ast::Mutability)\n+        -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n+        let cx = self.cx;\n+        let variant_ident = variant.node.name;\n+        match variant.node.kind {\n+            ast::tuple_variant_kind(ref variant_args) => {\n+                if variant_args.is_empty() {\n+                    return (cx.pat_ident_binding_mode(variant.span, variant_ident,\n+                                                      ast::BindByValue(ast::MutImmutable)),\n+                            ~[]);\n+                }\n \n-    (pattern, ident_expr)\n-}\n+                let matching_path = cx.path_ident(variant.span, variant_ident);\n \n-fn create_enum_variant_pattern(cx: @ExtCtxt,\n-                               variant: &ast::variant,\n-                               prefix: &str,\n-                               mutbl: ast::Mutability)\n-    -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n-\n-    let variant_ident = variant.node.name;\n-    match variant.node.kind {\n-        ast::tuple_variant_kind(ref variant_args) => {\n-            if variant_args.is_empty() {\n-                return (cx.pat_ident_binding_mode(variant.span, variant_ident,\n-                                                  ast::BindByValue(ast::MutImmutable)),\n-                        ~[]);\n-            }\n+                let mut paths = ~[];\n+                let mut ident_expr = ~[];\n+                for (i, va) in variant_args.iter().enumerate() {\n+                    let sp = self.set_expn_info(va.ty.span);\n+                    let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n \n-            let matching_path = cx.path_ident(variant.span, variant_ident);\n+                    paths.push(path.clone());\n+                    ident_expr.push((sp, None, cx.expr_path(path)));\n+                }\n \n-            let mut paths = ~[];\n-            let mut ident_expr = ~[];\n-            for (i, va) in variant_args.iter().enumerate() {\n-                let path = cx.path_ident(va.ty.span,\n-                                         cx.ident_of(format!(\"{}_{}\", prefix, i)));\n+                let subpats = self.create_subpatterns(paths, mutbl);\n \n-                paths.push(path.clone());\n-                ident_expr.push((va.ty.span, None, cx.expr_path(path)));\n+                (cx.pat_enum(variant.span, matching_path, subpats),\n+                 ident_expr)\n+            }\n+            ast::struct_variant_kind(struct_def) => {\n+                self.create_struct_pattern(variant_ident, struct_def,\n+                                           prefix, mutbl)\n             }\n-\n-            let subpats = create_subpatterns(cx, paths, mutbl);\n-\n-            (cx.pat_enum(variant.span, matching_path, subpats),\n-             ident_expr)\n-        }\n-        ast::struct_variant_kind(struct_def) => {\n-            create_struct_pattern(cx, variant.span,\n-                                  variant_ident, struct_def,\n-                                  prefix,\n-                                  mutbl)\n         }\n     }\n }\n \n-\n-\n /* helpful premade recipes */\n \n /**"}, {"sha": "837b8bd59ec9aa09c69e3088a7b9158dab4415a0", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -20,6 +20,8 @@ pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n                                   mitem: @MetaItem,\n                                   in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"to_bytes\", \"IterBytes\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -40,7 +42,7 @@ pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n fn iter_bytes_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "73ea627ff5457009c927699c77ff86c34b634553", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -20,6 +20,8 @@ pub fn expand_deriving_from_primitive(cx: @ExtCtxt,\n                                       mitem: @MetaItem,\n                                       in_items: ~[@item]) -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"num\", \"FromPrimitive\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -59,7 +61,7 @@ pub fn expand_deriving_from_primitive(cx: @ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n fn cs_from(name: &str, cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "91ed60324cf1a6f5ca2647fa133f9480a33e1260", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -22,6 +22,8 @@ pub fn expand_deriving_rand(cx: @ExtCtxt,\n                             in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"rand\", \"Rand\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -45,7 +47,7 @@ pub fn expand_deriving_rand(cx: @ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "fd8c21f4f98677d65c0cd9ff4ca77632752205d0", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -21,6 +21,8 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n                               in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"to_str\", \"ToStr\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -37,7 +39,7 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n // It used to be the case that this deriving implementation invoked"}, {"sha": "67f14a8d4864570a9afc6ab5d4ec65a061ea23c6", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -20,6 +20,8 @@ pub fn expand_deriving_zero(cx: @ExtCtxt,\n                             in_items: ~[@item])\n     -> ~[@item] {\n     let trait_def = TraitDef {\n+        cx: cx, span: span,\n+\n         path: Path::new(~[\"std\", \"num\", \"Zero\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -52,7 +54,7 @@ pub fn expand_deriving_zero(cx: @ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(cx, span, mitem, in_items)\n+    trait_def.expand(mitem, in_items)\n }\n \n fn zero_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "4bb35457182f75db8cd1d942d43bb652e02f6abc", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67aca9c9af9be7d04317d3ed452b7b253059818d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=67aca9c9af9be7d04317d3ed452b7b253059818d", "patch": "@@ -18,7 +18,7 @@ use ext::build::AstBuilder;\n use attr;\n use attr::AttrMetaMethods;\n use codemap;\n-use codemap::{Span, Spanned, ExpnInfo, NameAndSpan};\n+use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n use fold::*;\n use opt_vec;\n@@ -69,6 +69,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                 call_site: e.span,\n                                 callee: NameAndSpan {\n                                     name: extnamestr,\n+                                    format: MacroBang,\n                                     span: exp_span,\n                                 },\n                             });\n@@ -257,6 +258,7 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n                           name: mname,\n+                          format: MacroAttribute,\n                           span: None\n                       }\n                   });\n@@ -352,6 +354,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n+                    format: MacroBang,\n                     span: span\n                 }\n             });\n@@ -370,6 +373,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n+                    format: MacroBang,\n                     span: span\n                 }\n             });\n@@ -459,6 +463,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 call_site: s.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n+                    format: MacroBang,\n                     span: exp_span,\n                 }\n             });"}]}