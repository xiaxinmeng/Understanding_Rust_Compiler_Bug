{"sha": "ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "node_id": "C_kwDOAAsO6NoAKGVjYWM4ZmQ1YWZiYjRjYThhOThmOGIwZDNiNTQ3NjA4ZTA0Y2ZjNDQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-28T02:03:26Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-28T02:03:43Z"}, "message": "Descriptive error when users try to combine RPITIT/AFIT with specialization", "tree": {"sha": "43e93cb3e088c8affc4a5763a4168fe31556317f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43e93cb3e088c8affc4a5763a4168fe31556317f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "html_url": "https://github.com/rust-lang/rust/commit/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6290ae92b2df2bfff09abdcb80a3aa483692bab6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6290ae92b2df2bfff09abdcb80a3aa483692bab6", "html_url": "https://github.com/rust-lang/rust/commit/6290ae92b2df2bfff09abdcb80a3aa483692bab6"}], "stats": {"total": 148, "additions": 83, "deletions": 65}, "files": [{"sha": "848828175e2d8f22dffc95ac22fc9b55612f1e62", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "patch": "@@ -792,17 +792,19 @@ fn check_impl_items_against_trait<'tcx>(\n             trait_def.must_implement_one_of.as_deref();\n \n         for &trait_item_id in tcx.associated_item_def_ids(impl_trait_ref.def_id) {\n-            let is_implemented = ancestors\n-                .leaf_def(tcx, trait_item_id)\n+            let leaf_def = ancestors.leaf_def(tcx, trait_item_id);\n+\n+            let is_implemented = leaf_def\n+                .as_ref()\n                 .map_or(false, |node_item| node_item.item.defaultness(tcx).has_value());\n \n             if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n                 missing_items.push(tcx.associated_item(trait_item_id));\n             }\n \n             // true if this item is specifically implemented in this impl\n-            let is_implemented_here = ancestors\n-                .leaf_def(tcx, trait_item_id)\n+            let is_implemented_here = leaf_def\n+                .as_ref()\n                 .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n \n             if !is_implemented_here {\n@@ -831,6 +833,36 @@ fn check_impl_items_against_trait<'tcx>(\n                     }\n                 }\n             }\n+\n+            if let Some(leaf_def) = &leaf_def\n+                && !leaf_def.is_final()\n+                && let def_id = leaf_def.item.def_id\n+                && tcx.impl_method_has_trait_impl_trait_tys(def_id)\n+            {\n+                let def_kind = tcx.def_kind(def_id);\n+                let descr = tcx.def_kind_descr(def_kind, def_id);\n+                let (msg, feature) = if tcx.asyncness(def_id).is_async() {\n+                    (\n+                        format!(\"async {descr} in trait cannot be specialized\"),\n+                        sym::async_fn_in_trait,\n+                    )\n+                } else {\n+                    (\n+                        format!(\n+                            \"{descr} with return-position `impl Trait` in trait cannot be specialized\"\n+                        ),\n+                        sym::return_position_impl_trait_in_trait,\n+                    )\n+                };\n+                tcx.sess\n+                    .struct_span_err(tcx.def_span(def_id), msg)\n+                    .note(format!(\n+                        \"specialization behaves in inconsistent and \\\n+                        surprising ways with `#![feature({feature})]`, \\\n+                        and for now is disallowed\"\n+                    ))\n+                    .emit();\n+            }\n         }\n \n         if !missing_items.is_empty() {"}, {"sha": "27490a09a36469ead8c52b643b164ee668e2a8cb", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "patch": "@@ -1101,34 +1101,6 @@ fn should_encode_const(def_kind: DefKind) -> bool {\n     }\n }\n \n-fn should_encode_trait_impl_trait_tys(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if tcx.def_kind(def_id) != DefKind::AssocFn {\n-        return false;\n-    }\n-\n-    let Some(item) = tcx.opt_associated_item(def_id) else { return false; };\n-    if item.container != ty::AssocItemContainer::ImplContainer {\n-        return false;\n-    }\n-\n-    let Some(trait_item_def_id) = item.trait_item_def_id else { return false; };\n-\n-    // FIXME(RPITIT): This does a somewhat manual walk through the signature\n-    // of the trait fn to look for any RPITITs, but that's kinda doing a lot\n-    // of work. We can probably remove this when we refactor RPITITs to be\n-    // associated types.\n-    tcx.fn_sig(trait_item_def_id).subst_identity().skip_binder().output().walk().any(|arg| {\n-        if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Alias(ty::Projection, data) = ty.kind()\n-            && tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n-        {\n-            true\n-        } else {\n-            false\n-        }\n-    })\n-}\n-\n // Return `false` to avoid encoding impl trait in trait, while we don't use the query.\n fn should_encode_fn_impl_trait_in_trait<'tcx>(_tcx: TyCtxt<'tcx>, _def_id: DefId) -> bool {\n     false\n@@ -1211,7 +1183,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             if let DefKind::Enum | DefKind::Struct | DefKind::Union = def_kind {\n                 self.encode_info_for_adt(def_id);\n             }\n-            if should_encode_trait_impl_trait_tys(tcx, def_id)\n+            if tcx.impl_method_has_trait_impl_trait_tys(def_id)\n                 && let Ok(table) = self.tcx.collect_return_position_impl_trait_in_trait_tys(def_id)\n             {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);"}, {"sha": "5084bc9cec6c67555a7f3a7b9969788eebf62dc9", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "patch": "@@ -2541,6 +2541,34 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n         def_id\n     }\n+\n+    pub fn impl_method_has_trait_impl_trait_tys(self, def_id: DefId) -> bool {\n+        if self.def_kind(def_id) != DefKind::AssocFn {\n+            return false;\n+        }\n+\n+        let Some(item) = self.opt_associated_item(def_id) else { return false; };\n+        if item.container != ty::AssocItemContainer::ImplContainer {\n+            return false;\n+        }\n+\n+        let Some(trait_item_def_id) = item.trait_item_def_id else { return false; };\n+\n+        // FIXME(RPITIT): This does a somewhat manual walk through the signature\n+        // of the trait fn to look for any RPITITs, but that's kinda doing a lot\n+        // of work. We can probably remove this when we refactor RPITITs to be\n+        // associated types.\n+        self.fn_sig(trait_item_def_id).subst_identity().skip_binder().output().walk().any(|arg| {\n+            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                && let ty::Alias(ty::Projection, data) = ty.kind()\n+                && self.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        })\n+    }\n }\n \n /// Yields the parent function's `LocalDefId` if `def_id` is an `impl Trait` definition."}, {"sha": "013db2edb398d40c52c8a3ea1d5410d6247cd687", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "patch": "@@ -1307,25 +1307,8 @@ fn assemble_candidate_for_impl_trait_in_trait<'cx, 'tcx>(\n         let _ = selcx.infcx.commit_if_ok(|_| {\n             match selcx.select(&obligation.with(tcx, trait_predicate)) {\n                 Ok(Some(super::ImplSource::UserDefined(data))) => {\n-                    let Ok(leaf_def) = specialization_graph::assoc_def(tcx, data.impl_def_id, trait_fn_def_id) else {\n-                        return Err(());\n-                    };\n-                    // Only reveal a specializable default if we're past type-checking\n-                    // and the obligation is monomorphic, otherwise passes such as\n-                    // transmute checking and polymorphic MIR optimizations could\n-                    // get a result which isn't correct for all monomorphizations.\n-                    if leaf_def.is_final()\n-                        || (obligation.param_env.reveal() == Reveal::All\n-                            && !selcx\n-                                .infcx\n-                                .resolve_vars_if_possible(obligation.predicate.trait_ref(tcx))\n-                                .still_further_specializable())\n-                    {\n-                        candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(data));\n-                        Ok(())\n-                    } else {\n-                        Err(())\n-                    }\n+                    candidate_set.push_candidate(ProjectionCandidate::ImplTraitInTrait(data));\n+                    Ok(())\n                 }\n                 Ok(None) => {\n                     candidate_set.mark_ambiguous();\n@@ -2216,7 +2199,8 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         Ok(assoc_ty) => assoc_ty,\n         Err(guar) => return Progress::error(tcx, guar),\n     };\n-    if !leaf_def.item.defaultness(tcx).has_value() {\n+    // We don't support specialization for RPITITs anyways... yet.\n+    if !leaf_def.is_final() {\n         return Progress { term: tcx.ty_error_misc().into(), obligations };\n     }\n "}, {"sha": "f71fd9980a261374877c5f1a5c571a5ff6c7f8be", "filename": "tests/ui/async-await/in-trait/dont-project-to-specializable-projection.stderr", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/tests%2Fui%2Fasync-await%2Fin-trait%2Fdont-project-to-specializable-projection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/tests%2Fui%2Fasync-await%2Fin-trait%2Fdont-project-to-specializable-projection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fdont-project-to-specializable-projection.stderr?ref=ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "patch": "@@ -7,20 +7,13 @@ LL | #![feature(async_fn_in_trait)]\n    = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error[E0053]: method `foo` has an incompatible type for trait\n-  --> $DIR/dont-project-to-specializable-projection.rs:14:35\n+error: async associated function in trait cannot be specialized\n+  --> $DIR/dont-project-to-specializable-projection.rs:14:5\n    |\n LL |     default async fn foo(_: T) -> &'static str {\n-   |                                   ^^^^^^^^^^^^ expected associated type, found future\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: type in trait\n-  --> $DIR/dont-project-to-specializable-projection.rs:10:27\n-   |\n-LL |     async fn foo(_: T) -> &'static str;\n-   |                           ^^^^^^^^^^^^\n-   = note: expected signature `fn(_) -> impl Future<Output = &'static str>`\n-              found signature `fn(_) -> impl Future<Output = &'static str>`\n+   = note: specialization behaves in inconsistent and surprising ways with `#![feature(async_fn_in_trait)]`, and for now is disallowed\n \n error: aborting due to previous error; 1 warning emitted\n \n-For more information about this error, try `rustc --explain E0053`."}, {"sha": "2fcffdf3f9a298f50daaed33566b47c498b932d3", "filename": "tests/ui/impl-trait/in-trait/specialization-broken.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fspecialization-broken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fspecialization-broken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fspecialization-broken.rs?ref=ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "patch": "@@ -15,6 +15,7 @@ where\n {\n     fn bar(&self) -> U {\n         //~^ ERROR method `bar` has an incompatible type for trait\n+        //~| ERROR method with return-position `impl Trait` in trait cannot be specialized\n         *self\n     }\n }"}, {"sha": "dc621d6b8a848ff1d92d0fa17a1092af20622696", "filename": "tests/ui/impl-trait/in-trait/specialization-broken.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fspecialization-broken.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fspecialization-broken.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fspecialization-broken.stderr?ref=ecac8fd5afbb4ca8a98f8b0d3b547608e04cfc44", "patch": "@@ -18,6 +18,14 @@ LL |     fn bar(&self) -> impl Sized;\n    = note: expected signature `fn(&U) -> impl Sized`\n               found signature `fn(&U) -> U`\n \n-error: aborting due to previous error\n+error: method with return-position `impl Trait` in trait cannot be specialized\n+  --> $DIR/specialization-broken.rs:16:5\n+   |\n+LL |     fn bar(&self) -> U {\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: specialization behaves in inconsistent and surprising ways with `#![feature(return_position_impl_trait_in_trait)]`, and for now is disallowed\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0053`."}]}