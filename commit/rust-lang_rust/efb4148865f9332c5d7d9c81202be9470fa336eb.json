{"sha": "efb4148865f9332c5d7d9c81202be9470fa336eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYjQxNDg4NjVmOTMzMmM1ZDdkOWM4MTIwMmJlOTQ3MGZhMzM2ZWI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-25T12:53:08Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-26T18:47:42Z"}, "message": "`#[inline]` non-generic `pub fn`s in `rustc_target::abi` and `ty::layout`.", "tree": {"sha": "766f66e3907f1fe0cc28a8d8d8be96aa8bc77c1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/766f66e3907f1fe0cc28a8d8d8be96aa8bc77c1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efb4148865f9332c5d7d9c81202be9470fa336eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efb4148865f9332c5d7d9c81202be9470fa336eb", "html_url": "https://github.com/rust-lang/rust/commit/efb4148865f9332c5d7d9c81202be9470fa336eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efb4148865f9332c5d7d9c81202be9470fa336eb/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9f4b221b92193c7e95b1beb502c6eb32c3b613", "html_url": "https://github.com/rust-lang/rust/commit/4b9f4b221b92193c7e95b1beb502c6eb32c3b613"}], "stats": {"total": 31, "additions": 31, "deletions": 0}, "files": [{"sha": "03c0bb79d685b80b39efe5c3fa73685927e8a606", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efb4148865f9332c5d7d9c81202be9470fa336eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb4148865f9332c5d7d9c81202be9470fa336eb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=efb4148865f9332c5d7d9c81202be9470fa336eb", "patch": "@@ -42,6 +42,7 @@ pub trait IntegerExt {\n }\n \n impl IntegerExt for Integer {\n+    #[inline]\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>, signed: bool) -> Ty<'tcx> {\n         match (*self, signed) {\n             (I8, false) => tcx.types.u8,\n@@ -149,6 +150,7 @@ pub trait PrimitiveExt {\n }\n \n impl PrimitiveExt for Primitive {\n+    #[inline]\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n@@ -160,6 +162,7 @@ impl PrimitiveExt for Primitive {\n \n     /// Return an *integer* type matching this primitive.\n     /// Useful in particular when dealing with enum discriminants.\n+    #[inline]\n     fn to_int_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n@@ -2016,12 +2019,14 @@ pub trait HasParamEnv<'tcx> {\n }\n \n impl<'tcx> HasDataLayout for TyCtxt<'tcx> {\n+    #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.data_layout\n     }\n }\n \n impl<'tcx> HasTyCtxt<'tcx> for TyCtxt<'tcx> {\n+    #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         *self\n     }\n@@ -2053,6 +2058,7 @@ impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode, and will normalize the input type.\n+    #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n@@ -2064,6 +2070,7 @@ impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode, and will normalize the input type.\n+    #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n@@ -2414,6 +2421,7 @@ where\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n+    #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::LayoutError::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -2604,6 +2612,7 @@ where\n /// compiled with `-Cpanic=unwind` and referenced from another crate compiled\n /// with `-Cpanic=abort` will look like they can't unwind when in fact they\n /// might (from a foreign exception or similar).\n+#[inline]\n pub fn fn_can_unwind(\n     tcx: TyCtxt<'tcx>,\n     codegen_fn_attr_flags: CodegenFnAttrFlags,\n@@ -2679,6 +2688,7 @@ pub fn fn_can_unwind(\n     }\n }\n \n+#[inline]\n pub fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n     use rustc_target::spec::abi::Abi::*;\n     match tcx.sess.target.adjust_abi(abi) {"}, {"sha": "2820a486dfd4be89dbe1a175142771cc403d021c", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efb4148865f9332c5d7d9c81202be9470fa336eb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb4148865f9332c5d7d9c81202be9470fa336eb/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=efb4148865f9332c5d7d9c81202be9470fa336eb", "patch": "@@ -194,6 +194,7 @@ impl TargetDataLayout {\n     /// to represent object size in bits. It would need to be 1 << 61 to account for this, but is\n     /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n     /// address space on 64-bit ARMv8 and x86_64.\n+    #[inline]\n     pub fn obj_size_bound(&self) -> u64 {\n         match self.pointer_size.bits() {\n             16 => 1 << 15,\n@@ -203,6 +204,7 @@ impl TargetDataLayout {\n         }\n     }\n \n+    #[inline]\n     pub fn ptr_sized_integer(&self) -> Integer {\n         match self.pointer_size.bits() {\n             16 => I16,\n@@ -212,6 +214,7 @@ impl TargetDataLayout {\n         }\n     }\n \n+    #[inline]\n     pub fn vector_align(&self, vec_size: Size) -> AbiAndPrefAlign {\n         for &(size, align) in &self.vector_align {\n             if size == vec_size {\n@@ -562,14 +565,17 @@ pub struct AbiAndPrefAlign {\n }\n \n impl AbiAndPrefAlign {\n+    #[inline]\n     pub fn new(align: Align) -> AbiAndPrefAlign {\n         AbiAndPrefAlign { abi: align, pref: align }\n     }\n \n+    #[inline]\n     pub fn min(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n         AbiAndPrefAlign { abi: self.abi.min(other.abi), pref: self.pref.min(other.pref) }\n     }\n \n+    #[inline]\n     pub fn max(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n         AbiAndPrefAlign { abi: self.abi.max(other.abi), pref: self.pref.max(other.pref) }\n     }\n@@ -586,6 +592,7 @@ pub enum Integer {\n }\n \n impl Integer {\n+    #[inline]\n     pub fn size(self) -> Size {\n         match self {\n             I8 => Size::from_bytes(1),\n@@ -609,6 +616,7 @@ impl Integer {\n     }\n \n     /// Finds the smallest Integer type which can represent the signed value.\n+    #[inline]\n     pub fn fit_signed(x: i128) -> Integer {\n         match x {\n             -0x0000_0000_0000_0080..=0x0000_0000_0000_007f => I8,\n@@ -620,6 +628,7 @@ impl Integer {\n     }\n \n     /// Finds the smallest Integer type which can represent the unsigned value.\n+    #[inline]\n     pub fn fit_unsigned(x: u128) -> Integer {\n         match x {\n             0..=0x0000_0000_0000_00ff => I8,\n@@ -655,6 +664,9 @@ impl Integer {\n         I8\n     }\n \n+    // FIXME(eddyb) consolidate this and other methods that find the appropriate\n+    // `Integer` given some requirements.\n+    #[inline]\n     fn from_size(size: Size) -> Result<Self, String> {\n         match size.bits() {\n             8 => Ok(Integer::I8),\n@@ -706,10 +718,14 @@ impl Primitive {\n         }\n     }\n \n+    // FIXME(eddyb) remove, it's trivial thanks to `matches!`.\n+    #[inline]\n     pub fn is_float(self) -> bool {\n         matches!(self, F32 | F64)\n     }\n \n+    // FIXME(eddyb) remove, it's completely unused.\n+    #[inline]\n     pub fn is_int(self) -> bool {\n         matches!(self, Int(..))\n     }\n@@ -786,6 +802,7 @@ pub struct Scalar {\n }\n \n impl Scalar {\n+    #[inline]\n     pub fn is_bool(&self) -> bool {\n         matches!(self.value, Int(I8, false))\n             && matches!(self.valid_range, WrappingRange { start: 0, end: 1 })\n@@ -852,6 +869,7 @@ pub enum FieldsShape {\n }\n \n impl FieldsShape {\n+    #[inline]\n     pub fn count(&self) -> usize {\n         match *self {\n             FieldsShape::Primitive => 0,\n@@ -861,6 +879,7 @@ impl FieldsShape {\n         }\n     }\n \n+    #[inline]\n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n             FieldsShape::Primitive => {\n@@ -884,6 +903,7 @@ impl FieldsShape {\n         }\n     }\n \n+    #[inline]\n     pub fn memory_index(&self, i: usize) -> usize {\n         match *self {\n             FieldsShape::Primitive => {\n@@ -967,6 +987,7 @@ impl Abi {\n     }\n \n     /// Returns `true` if this is a single signed integer scalar\n+    #[inline]\n     pub fn is_signed(&self) -> bool {\n         match *self {\n             Abi::Scalar(ref scal) => match scal.value {"}]}