{"sha": "64187b837486be90b897c7014572aa3537dc9b27", "node_id": "C_kwDOAAsO6NoAKDY0MTg3YjgzNzQ4NmJlOTBiODk3YzcwMTQ1NzJhYTM1MzdkYzliMjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-08T17:04:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-08T17:04:45Z"}, "message": "Auto merge of #92260 - jyn514:less-python-logic, r=Mark-Simulacrum\n\nMove some more bootstrap logic from python to rust\n\nSame rationale as https://github.com/rust-lang/rust/pull/76544; it would be nice to make python entirely optional at some point.\n\nThis also removes $ROOT as an option for the build directory; I haven't been using it, and like Alex\nsaid in https://github.com/rust-lang/rust/pull/76544#discussion_r488248930 it seems like a misfeature.\n\nThis allows running `cargo run` from src/bootstrap, although that still gives\nlots of compile errors if you don't use the beta toolchain. It's not exactly the same as using `x.py`, since it won't have `BOOTSTRAP_DOWNLOAD_RUSTC` set, but it's pretty close. Doing this from the top-level directory requires https://github.com/rust-lang/cargo/issues/7290 to be fixed, or using `cargo run -p bootstrap`.\n\nThe next steps for making python optional are to move download-ci-llvm and download-rustc support into rustbuild, likely be shelling out as the python scripts do today.\n\nIt would also be nice (although not required) to move submodule support there, but that would require taking bootstrap out of the workspace to avoid errors from crates that haven't been cloned yet.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "08fc12f20c229c2787efb074f27794a4e2732057", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08fc12f20c229c2787efb074f27794a4e2732057"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64187b837486be90b897c7014572aa3537dc9b27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64187b837486be90b897c7014572aa3537dc9b27", "html_url": "https://github.com/rust-lang/rust/commit/64187b837486be90b897c7014572aa3537dc9b27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64187b837486be90b897c7014572aa3537dc9b27/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b97dc20784698730bd7bc1a20eabdcd32066d174", "url": "https://api.github.com/repos/rust-lang/rust/commits/b97dc20784698730bd7bc1a20eabdcd32066d174", "html_url": "https://github.com/rust-lang/rust/commit/b97dc20784698730bd7bc1a20eabdcd32066d174"}, {"sha": "477cae3bd7d71c347b3031809a153cfbeecd1c23", "url": "https://api.github.com/repos/rust-lang/rust/commits/477cae3bd7d71c347b3031809a153cfbeecd1c23", "html_url": "https://github.com/rust-lang/rust/commit/477cae3bd7d71c347b3031809a153cfbeecd1c23"}], "stats": {"total": 220, "additions": 171, "deletions": 49}, "files": [{"sha": "4c32547f0590b6178241808a0cd70440fab63598", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -3,6 +3,7 @@ name = \"bootstrap\"\n version = \"0.0.0\"\n edition = \"2021\"\n build = \"build.rs\"\n+default-run = \"bootstrap\"\n \n [lib]\n path = \"lib.rs\""}, {"sha": "1777dae594f8e3fa7595e74bbc7f67ca6b018e6e", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -1267,7 +1267,7 @@ def bootstrap(help_triggered):\n     build.check_vendored_status()\n \n     build_dir = build.get_toml('build-dir', 'build') or 'build'\n-    build.build_dir = os.path.abspath(build_dir.replace(\"$ROOT\", build.rust_root))\n+    build.build_dir = os.path.abspath(build_dir)\n \n     with open(os.path.join(build.rust_root, \"src\", \"stage0.json\")) as f:\n         data = json.load(f)\n@@ -1302,10 +1302,7 @@ def bootstrap(help_triggered):\n     env = os.environ.copy()\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n-    env[\"BUILD_DIR\"] = build.build_dir\n     env[\"RUSTC_BOOTSTRAP\"] = '1'\n-    if toml_path:\n-        env[\"BOOTSTRAP_CONFIG\"] = toml_path\n     if build.rustc_commit is not None:\n         env[\"BOOTSTRAP_DOWNLOAD_RUSTC\"] = '1'\n     run(args, env=env, verbose=build.verbose, is_bootstrap=True)"}, {"sha": "1903f0baef1fae4d71a8f0ce3210e3a7e334965b", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -883,7 +883,7 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn rustdoc_cmd(&self, compiler: Compiler) -> Command {\n-        let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n+        let mut cmd = Command::new(&self.bootstrap_out.join(\"rustdoc\"));\n         cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n             // Note that this is *not* the sysroot_libdir because rustdoc must be linked\n@@ -1249,7 +1249,7 @@ impl<'a> Builder<'a> {\n             .env(\"RUSTC_STAGE\", stage.to_string())\n             .env(\"RUSTC_SYSROOT\", &sysroot)\n             .env(\"RUSTC_LIBDIR\", &libdir)\n-            .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n+            .env(\"RUSTDOC\", self.bootstrap_out.join(\"rustdoc\"))\n             .env(\n                 \"RUSTDOC_REAL\",\n                 if cmd == \"doc\" || cmd == \"rustdoc\" || (cmd == \"test\" && want_rustdoc) {\n@@ -1263,7 +1263,7 @@ impl<'a> Builder<'a> {\n         // Clippy support is a hack and uses the default `cargo-clippy` in path.\n         // Don't override RUSTC so that the `cargo-clippy` in path will be run.\n         if cmd != \"clippy\" {\n-            cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"));\n+            cargo.env(\"RUSTC\", self.bootstrap_out.join(\"rustc\"));\n         }\n \n         // Dealing with rpath here is a little special, so let's go into some"}, {"sha": "b76bb569852cdb9806b1f8664b619a258cf5c28f", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -8,10 +8,10 @@ fn configure(cmd: &str, host: &[&str], target: &[&str]) -> Config {\n     config.save_toolstates = None;\n     config.dry_run = true;\n     config.ninja_in_file = false;\n-    // try to avoid spurious failures in dist where we create/delete each others file\n     config.out = PathBuf::from(env::var_os(\"BOOTSTRAP_OUTPUT_DIRECTORY\").unwrap());\n     config.initial_rustc = PathBuf::from(env::var_os(\"RUSTC\").unwrap());\n     config.initial_cargo = PathBuf::from(env::var_os(\"BOOTSTRAP_INITIAL_CARGO\").unwrap());\n+    // try to avoid spurious failures in dist where we create/delete each others file\n     let dir = config\n         .out\n         .join(\"tmp-rustbuild-tests\")"}, {"sha": "73a855ae4d72aa38660d475725987524be3ac2e4", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -6,7 +6,6 @@\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::ffi::OsString;\n use std::fmt;\n use std::fs;\n use std::path::{Path, PathBuf};\n@@ -392,7 +391,6 @@ derive_merge! {\n         build: Option<String>,\n         host: Option<Vec<String>>,\n         target: Option<Vec<String>>,\n-        // This is ignored, the rust code always gets the build directory from the `BUILD_DIR` env variable\n         build_dir: Option<String>,\n         cargo: Option<String>,\n         rustc: Option<String>,\n@@ -588,18 +586,6 @@ derive_merge! {\n }\n \n impl Config {\n-    fn path_from_python(var_key: &str) -> PathBuf {\n-        match env::var_os(var_key) {\n-            Some(var_val) => Self::normalize_python_path(var_val),\n-            _ => panic!(\"expected '{}' to be set\", var_key),\n-        }\n-    }\n-\n-    /// Normalizes paths from Python slightly. We don't trust paths from Python (#49785).\n-    fn normalize_python_path(path: OsString) -> PathBuf {\n-        Path::new(&path).components().collect()\n-    }\n-\n     pub fn default_opts() -> Config {\n         let mut config = Config::default();\n         config.llvm_optimize = true;\n@@ -625,7 +611,7 @@ impl Config {\n         let manifest_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n         // Undo `src/bootstrap`\n         config.src = manifest_dir.parent().unwrap().parent().unwrap().to_owned();\n-        config.out = Config::path_from_python(\"BUILD_DIR\");\n+        config.out = PathBuf::from(\"build\");\n \n         config.initial_cargo = PathBuf::from(env!(\"CARGO\"));\n         config.initial_rustc = PathBuf::from(env!(\"RUSTC\"));\n@@ -655,12 +641,6 @@ impl Config {\n         config.llvm_profile_use = flags.llvm_profile_use;\n         config.llvm_profile_generate = flags.llvm_profile_generate;\n \n-        if config.dry_run {\n-            let dir = config.out.join(\"tmp-dry-run\");\n-            t!(fs::create_dir_all(&dir));\n-            config.out = dir;\n-        }\n-\n         #[cfg(test)]\n         let get_toml = |_| TomlConfig::default();\n         #[cfg(not(test))]\n@@ -677,7 +657,15 @@ impl Config {\n             }\n         };\n \n-        let mut toml = flags.config.as_deref().map(get_toml).unwrap_or_else(TomlConfig::default);\n+        // check --config first, then `$RUST_BOOTSTRAP_CONFIG` first, then `config.toml`\n+        let toml_path = flags\n+            .config\n+            .clone()\n+            .or_else(|| env::var_os(\"RUST_BOOTSTRAP_CONFIG\").map(PathBuf::from))\n+            .unwrap_or_else(|| PathBuf::from(\"config.toml\"));\n+        let mut toml =\n+            if toml_path.exists() { get_toml(&toml_path) } else { TomlConfig::default() };\n+\n         if let Some(include) = &toml.profile {\n             let mut include_path = config.src.clone();\n             include_path.push(\"src\");\n@@ -689,12 +677,25 @@ impl Config {\n         }\n \n         config.changelog_seen = toml.changelog_seen;\n-        if let Some(cfg) = flags.config {\n-            config.config = cfg;\n-        }\n+        config.config = toml_path;\n \n         let build = toml.build.unwrap_or_default();\n \n+        set(&mut config.initial_rustc, build.rustc.map(PathBuf::from));\n+        set(&mut config.out, build.build_dir.map(PathBuf::from));\n+        // NOTE: Bootstrap spawns various commands with different working directories.\n+        // To avoid writing to random places on the file system, `config.out` needs to be an absolute path.\n+        if !config.out.is_absolute() {\n+            // `canonicalize` requires the path to already exist. Use our vendored copy of `absolute` instead.\n+            config.out = crate::util::absolute(&config.out);\n+        }\n+\n+        if config.dry_run {\n+            let dir = config.out.join(\"tmp-dry-run\");\n+            t!(fs::create_dir_all(&dir));\n+            config.out = dir;\n+        }\n+\n         config.hosts = if let Some(arg_host) = flags.host {\n             arg_host\n         } else if let Some(file_host) = build.host {"}, {"sha": "1a4e6a9688803b544295aa7d1c7ba0d5d2d9c2d0", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -3,7 +3,6 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::env;\n use std::path::PathBuf;\n use std::process;\n \n@@ -541,7 +540,6 @@ Arguments:\n         // Get any optional paths which occur after the subcommand\n         let mut paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n-        let cfg_file = env::var_os(\"BOOTSTRAP_CONFIG\").map(PathBuf::from);\n         let verbose = matches.opt_present(\"verbose\");\n \n         // User passed in -h/--help?\n@@ -671,7 +669,7 @@ Arguments:\n             } else {\n                 None\n             },\n-            config: cfg_file,\n+            config: matches.opt_str(\"config\").map(PathBuf::from),\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().expect(\"`jobs` should be a number\")),\n             cmd,\n             incremental: matches.opt_present(\"incremental\"),"}, {"sha": "2ae63858ff610bfba465b9e79b4ed80b660d7d82", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -261,6 +261,7 @@ pub struct Build {\n     // Properties derived from the above configuration\n     src: PathBuf,\n     out: PathBuf,\n+    bootstrap_out: PathBuf,\n     rust_info: channel::GitInfo,\n     cargo_info: channel::GitInfo,\n     rls_info: channel::GitInfo,\n@@ -435,6 +436,20 @@ impl Build {\n             .expect(\"failed to read src/version\");\n         let version = version.trim();\n \n+        let bootstrap_out = if std::env::var(\"BOOTSTRAP_PYTHON\").is_ok() {\n+            out.join(\"bootstrap\").join(\"debug\")\n+        } else {\n+            let workspace_target_dir = std::env::var(\"CARGO_TARGET_DIR\")\n+                .map(PathBuf::from)\n+                .unwrap_or_else(|_| src.join(\"target\"));\n+            let bootstrap_out = workspace_target_dir.join(\"debug\");\n+            if !bootstrap_out.join(\"rustc\").exists() {\n+                // this restriction can be lifted whenever https://github.com/rust-lang/rfcs/pull/3028 is implemented\n+                panic!(\"run `cargo build --bins` before `cargo run`\")\n+            }\n+            bootstrap_out\n+        };\n+\n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n@@ -453,6 +468,7 @@ impl Build {\n             version: version.to_string(),\n             src,\n             out,\n+            bootstrap_out,\n \n             rust_info,\n             cargo_info,\n@@ -629,7 +645,7 @@ impl Build {\n         }\n \n         if let Subcommand::Setup { profile } = &self.config.cmd {\n-            return setup::setup(&self.config.src, *profile);\n+            return setup::setup(&self.config, *profile);\n         }\n \n         {"}, {"sha": "e1235829b3aeff524b6997bf24ebd5f66312b050", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -1,5 +1,5 @@\n-use crate::TargetSelection;\n use crate::{t, VERSION};\n+use crate::{Config, TargetSelection};\n use std::env::consts::EXE_SUFFIX;\n use std::fmt::Write as _;\n use std::fs::File;\n@@ -81,24 +81,22 @@ impl fmt::Display for Profile {\n     }\n }\n \n-pub fn setup(src_path: &Path, profile: Profile) {\n-    let cfg_file = env::var_os(\"BOOTSTRAP_CONFIG\").map(PathBuf::from);\n+pub fn setup(config: &Config, profile: Profile) {\n+    let path = &config.config;\n \n-    if cfg_file.as_ref().map_or(false, |f| f.exists()) {\n-        let file = cfg_file.unwrap();\n+    if path.exists() {\n         println!(\n             \"error: you asked `x.py` to setup a new config file, but one already exists at `{}`\",\n-            file.display()\n+            path.display()\n         );\n-        println!(\"help: try adding `profile = \\\"{}\\\"` at the top of {}\", profile, file.display());\n+        println!(\"help: try adding `profile = \\\"{}\\\"` at the top of {}\", profile, path.display());\n         println!(\n             \"note: this will use the configuration in {}\",\n-            profile.include_path(src_path).display()\n+            profile.include_path(&config.src).display()\n         );\n         std::process::exit(1);\n     }\n \n-    let path = cfg_file.unwrap_or_else(|| \"config.toml\".into());\n     let settings = format!(\n         \"# Includes one of the default files in src/bootstrap/defaults\\n\\\n     profile = \\\"{}\\\"\\n\\\n@@ -107,7 +105,7 @@ pub fn setup(src_path: &Path, profile: Profile) {\n     );\n     t!(fs::write(path, settings));\n \n-    let include_path = profile.include_path(src_path);\n+    let include_path = profile.include_path(&config.src);\n     println!(\"`x.py` will now use the configuration at {}\", include_path.display());\n \n     let build = TargetSelection::from_user(&env!(\"BUILD_TRIPLE\"));\n@@ -138,7 +136,7 @@ pub fn setup(src_path: &Path, profile: Profile) {\n \n     println!();\n \n-    t!(install_git_hook_maybe(src_path));\n+    t!(install_git_hook_maybe(&config.src));\n \n     println!();\n "}, {"sha": "58b73ebed5000118365eb8cbab5ce2ae3ff8f425", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -730,7 +730,7 @@ impl Step for RustdocTheme {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        let rustdoc = builder.out.join(\"bootstrap/debug/rustdoc\");\n+        let rustdoc = builder.bootstrap_out.join(\"rustdoc\");\n         let mut cmd = builder.tool_cmd(Tool::RustdocTheme);\n         cmd.arg(rustdoc.to_str().unwrap())\n             .arg(builder.src.join(\"src/librustdoc/html/static/css/themes\").to_str().unwrap())\n@@ -2346,6 +2346,8 @@ impl Step for Bootstrap {\n             .current_dir(builder.src.join(\"src/bootstrap\"))\n             .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n             .env(\"CARGO_TARGET_DIR\", builder.out.join(\"bootstrap\"))\n+            // HACK: bootstrap's tests want to know the output directory, but there's no way to set\n+            // it except through config.toml. Set it through an env variable instead.\n             .env(\"BOOTSTRAP_OUTPUT_DIRECTORY\", &builder.config.out)\n             .env(\"BOOTSTRAP_INITIAL_CARGO\", &builder.config.initial_cargo)\n             .env(\"RUSTC_BOOTSTRAP\", \"1\")"}, {"sha": "30d9665dd0f4ad98f2974c4796bf877b33db18fd", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64187b837486be90b897c7014572aa3537dc9b27/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=64187b837486be90b897c7014572aa3537dc9b27", "patch": "@@ -440,3 +440,112 @@ fn fail(s: &str) -> ! {\n     println!(\"\\n\\n{}\\n\\n\", s);\n     std::process::exit(1);\n }\n+\n+/// Copied from `std::path::absolute` until it stabilizes.\n+///\n+/// FIXME: this shouldn't exist.\n+pub(crate) fn absolute(path: &Path) -> PathBuf {\n+    if path.as_os_str().is_empty() {\n+        panic!(\"can't make empty path absolute\");\n+    }\n+    #[cfg(unix)]\n+    {\n+        t!(absolute_unix(path), format!(\"could not make path absolute: {}\", path.display()))\n+    }\n+    #[cfg(windows)]\n+    {\n+        t!(absolute_windows(path), format!(\"could not make path absolute: {}\", path.display()))\n+    }\n+    #[cfg(not(any(unix, windows)))]\n+    {\n+        println!(\"warning: bootstrap is not supported on non-unix platforms\");\n+        t!(std::fs::canonicalize(t!(std::env::current_dir()))).join(path)\n+    }\n+}\n+\n+#[cfg(unix)]\n+/// Make a POSIX path absolute without changing its semantics.\n+fn absolute_unix(path: &Path) -> io::Result<PathBuf> {\n+    // This is mostly a wrapper around collecting `Path::components`, with\n+    // exceptions made where this conflicts with the POSIX specification.\n+    // See 4.13 Pathname Resolution, IEEE Std 1003.1-2017\n+    // https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13\n+\n+    use std::os::unix::prelude::OsStrExt;\n+    let mut components = path.components();\n+    let path_os = path.as_os_str().as_bytes();\n+\n+    let mut normalized = if path.is_absolute() {\n+        // \"If a pathname begins with two successive <slash> characters, the\n+        // first component following the leading <slash> characters may be\n+        // interpreted in an implementation-defined manner, although more than\n+        // two leading <slash> characters shall be treated as a single <slash>\n+        // character.\"\n+        if path_os.starts_with(b\"//\") && !path_os.starts_with(b\"///\") {\n+            components.next();\n+            PathBuf::from(\"//\")\n+        } else {\n+            PathBuf::new()\n+        }\n+    } else {\n+        env::current_dir()?\n+    };\n+    normalized.extend(components);\n+\n+    // \"Interfaces using pathname resolution may specify additional constraints\n+    // when a pathname that does not name an existing directory contains at\n+    // least one non- <slash> character and contains one or more trailing\n+    // <slash> characters\".\n+    // A trailing <slash> is also meaningful if \"a symbolic link is\n+    // encountered during pathname resolution\".\n+\n+    if path_os.ends_with(b\"/\") {\n+        normalized.push(\"\");\n+    }\n+\n+    Ok(normalized)\n+}\n+\n+#[cfg(windows)]\n+fn absolute_windows(path: &std::path::Path) -> std::io::Result<std::path::PathBuf> {\n+    use std::ffi::OsString;\n+    use std::io::Error;\n+    use std::os::windows::ffi::{OsStrExt, OsStringExt};\n+    use std::ptr::null_mut;\n+    #[link(name = \"kernel32\")]\n+    extern \"system\" {\n+        fn GetFullPathNameW(\n+            lpFileName: *const u16,\n+            nBufferLength: u32,\n+            lpBuffer: *mut u16,\n+            lpFilePart: *mut *const u16,\n+        ) -> u32;\n+    }\n+\n+    unsafe {\n+        // encode the path as UTF-16\n+        let path: Vec<u16> = path.as_os_str().encode_wide().chain([0]).collect();\n+        let mut buffer = Vec::new();\n+        // Loop until either success or failure.\n+        loop {\n+            // Try to get the absolute path\n+            let len = GetFullPathNameW(\n+                path.as_ptr(),\n+                buffer.len().try_into().unwrap(),\n+                buffer.as_mut_ptr(),\n+                null_mut(),\n+            );\n+            match len as usize {\n+                // Failure\n+                0 => return Err(Error::last_os_error()),\n+                // Buffer is too small, resize.\n+                len if len > buffer.len() => buffer.resize(len, 0),\n+                // Success!\n+                len => {\n+                    buffer.truncate(len);\n+                    return Ok(OsString::from_wide(&buffer).into());\n+                }\n+            }\n+        }\n+    }\n+}"}]}