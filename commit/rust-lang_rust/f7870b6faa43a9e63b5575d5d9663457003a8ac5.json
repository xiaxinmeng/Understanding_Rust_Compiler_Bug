{"sha": "f7870b6faa43a9e63b5575d5d9663457003a8ac5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ODcwYjZmYWE0M2E5ZTYzYjU1NzVkNWQ5NjYzNDU3MDAzYThhYzU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-15T13:04:18Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-15T13:12:47Z"}, "message": "Rollup merge of #22339 - petrochenkov:int, r=huonw\n\n Some function signatures have changed, so this is a [breaking-change].\nIn particular, radixes and numerical values of digits are represented by `u32` now.\n\nPart of #22240", "tree": {"sha": "d7cc47b3b9417d037b687c74678b1febf59d07df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7cc47b3b9417d037b687c74678b1febf59d07df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7870b6faa43a9e63b5575d5d9663457003a8ac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7870b6faa43a9e63b5575d5d9663457003a8ac5", "html_url": "https://github.com/rust-lang/rust/commit/f7870b6faa43a9e63b5575d5d9663457003a8ac5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7870b6faa43a9e63b5575d5d9663457003a8ac5/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8acaaa9e0e631944ae809d3228561f7dfc44e66b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8acaaa9e0e631944ae809d3228561f7dfc44e66b", "html_url": "https://github.com/rust-lang/rust/commit/8acaaa9e0e631944ae809d3228561f7dfc44e66b"}, {"sha": "b1cd76906a4c7e40e3eb3569450d2dbd3be9fcab", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1cd76906a4c7e40e3eb3569450d2dbd3be9fcab", "html_url": "https://github.com/rust-lang/rust/commit/b1cd76906a4c7e40e3eb3569450d2dbd3be9fcab"}], "stats": {"total": 357, "additions": 179, "deletions": 178}, "files": [{"sha": "dc8716d1378df6ce3296716f204ad70a444f0c88", "filename": "src/etc/unicode.py", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -366,7 +366,7 @@ def emit_conversions_module(f, lowerupper, upperlower):\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n+    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<usize> {\n         match table.binary_search(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n@@ -449,13 +449,13 @@ def emit_charwidth_module(f, width_table):\n \"\"\")\n \n     f.write(\"\"\"\n-    pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n-        match c as uint {\n+    pub fn width(c: char, is_cjk: bool) -> Option<usize> {\n+        match c as usize {\n             _c @ 0 => Some(0),          // null is zero width\n             cu if cu < 0x20 => None,    // control sequences have no width\n             cu if cu < 0x7F => Some(1), // ASCII\n             cu if cu < 0xA0 => None,    // more control sequences\n-            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as uint)\n+            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as usize)\n         }\n     }\n \n@@ -610,7 +610,7 @@ def optimize_width_table(wtable):\n         rf.write(\"\"\"\n /// The version of [Unicode](http://www.unicode.org/)\n /// that the `UnicodeChar` and `UnicodeStrPrelude` traits are based on.\n-pub const UNICODE_VERSION: (uint, uint, uint) = (%s, %s, %s);\n+pub const UNICODE_VERSION: (u64, u64, u64) = (%s, %s, %s);\n \"\"\" % unicode_version)\n         (canon_decomp, compat_decomp, gencats, combines,\n                 lowerupper, upperlower) = load_unicode_data(\"UnicodeData.txt\")"}, {"sha": "683e450acb230ba84df9e8ce11548c7a647fc6aa", "filename": "src/libcore/char.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -119,16 +119,16 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// ```\n #[inline]\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n+pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n     }\n     if num < radix {\n         unsafe {\n             if num < 10 {\n-                Some(transmute(('0' as uint + num) as u32))\n+                Some(transmute('0' as u32 + num))\n             } else {\n-                Some(transmute(('a' as uint + num - 10) as u32))\n+                Some(transmute('a' as u32 + num - 10))\n             }\n         }\n     } else {\n@@ -164,7 +164,7 @@ pub trait CharExt {\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool;\n+    fn is_digit(self, radix: u32) -> bool;\n \n     /// Converts a character to the corresponding digit.\n     ///\n@@ -189,7 +189,7 @@ pub trait CharExt {\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint>;\n+    fn to_digit(self, radix: u32) -> Option<u32>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a character, as `char`s.\n     ///\n@@ -275,7 +275,7 @@ pub trait CharExt {\n     /// assert_eq!(n, 2);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint;\n+    fn len_utf8(self) -> usize;\n \n     /// Returns the number of bytes this character would need if encoded in UTF-16.\n     ///\n@@ -287,7 +287,7 @@ pub trait CharExt {\n     /// assert_eq!(n, 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint;\n+    fn len_utf16(self) -> usize;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer, and then returns the number\n     /// of bytes written.\n@@ -317,7 +317,7 @@ pub trait CharExt {\n     /// assert_eq!(result, None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer, and then returns the\n     /// number of `u16`s written.\n@@ -347,27 +347,27 @@ pub trait CharExt {\n     /// assert_eq!(result, None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool {\n+    fn is_digit(self, radix: u32) -> bool {\n         self.to_digit(radix).is_some()\n     }\n \n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint> {\n+    fn to_digit(self, radix: u32) -> Option<u32> {\n         if radix > 36 {\n             panic!(\"to_digit: radix is too high (maximum 36)\");\n         }\n         let val = match self {\n-          '0' ... '9' => self as uint - ('0' as uint),\n-          'a' ... 'z' => self as uint + 10 - ('a' as uint),\n-          'A' ... 'Z' => self as uint + 10 - ('A' as uint),\n+          '0' ... '9' => self as u32 - '0' as u32,\n+          'a' ... 'z' => self as u32 - 'a' as u32 + 10,\n+          'A' ... 'Z' => self as u32 - 'A' as u32 + 10,\n           _ => return None,\n         };\n         if val < radix { Some(val) }\n@@ -396,7 +396,7 @@ impl CharExt for char {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint {\n+    fn len_utf8(self) -> usize {\n         let code = self as u32;\n         match () {\n             _ if code < MAX_ONE_B   => 1,\n@@ -408,22 +408,22 @@ impl CharExt for char {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint {\n+    fn len_utf16(self) -> usize {\n         let ch = self as u32;\n         if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n     }\n \n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> {\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> {\n         encode_utf8_raw(self as u32, dst)\n     }\n \n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> {\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> {\n         encode_utf16_raw(self as u32, dst)\n     }\n }\n@@ -435,7 +435,7 @@ impl CharExt for char {\n /// and a `None` will be returned.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n+pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if code < MAX_ONE_B && dst.len() >= 1 {\n         dst[0] = code as u8;\n@@ -467,7 +467,7 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n /// and a `None` will be returned.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<uint> {\n+pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n         // The BMP falls through (assuming non-surrogate, as it should)\n@@ -499,7 +499,7 @@ enum EscapeUnicodeState {\n     Backslash,\n     Type,\n     LeftBrace,\n-    Value(uint),\n+    Value(usize),\n     RightBrace,\n     Done,\n }"}, {"sha": "8e09e52daee198cff18f31a26433f173e4ad5d14", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -53,7 +53,7 @@ pub enum SignFormat {\n     SignNeg\n }\n \n-static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11;\n+static DIGIT_E_RADIX: u32 = ('e' as u32) - ('a' as u32) + 11;\n \n /// Converts a number to its string representation as a byte vector.\n /// This is meant to be a common base implementation for all numeric string\n@@ -87,7 +87,7 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11;\n ///   between digit and exponent sign `'p'`.\n pub fn float_to_str_bytes_common<T: Float, U, F>(\n     num: T,\n-    radix: uint,\n+    radix: u32,\n     negative_zero: bool,\n     sign: SignFormat,\n     digits: SignificantDigits,\n@@ -156,7 +156,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         deccum = deccum / radix_gen;\n         deccum = deccum.trunc();\n \n-        let c = char::from_digit(current_digit.to_int().unwrap() as uint, radix);\n+        let c = char::from_digit(current_digit.to_int().unwrap() as u32, radix);\n         buf[end] = c.unwrap() as u8;\n         end += 1;\n \n@@ -211,7 +211,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n             // See note in first loop.\n             let current_digit = deccum.trunc().abs();\n \n-            let c = char::from_digit(current_digit.to_int().unwrap() as uint,\n+            let c = char::from_digit(current_digit.to_int().unwrap() as u32,\n                                      radix);\n             buf[end] = c.unwrap() as u8;\n             end += 1;\n@@ -228,7 +228,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n             let ascii2value = |chr: u8| {\n                 (chr as char).to_digit(radix).unwrap()\n             };\n-            let value2ascii = |val: uint| {\n+            let value2ascii = |val: u32| {\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n "}, {"sha": "7612469c8088bbfe3c30579d02e28f48aa4482fd", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -1432,12 +1432,12 @@ pub trait Float\n #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n pub trait FromStrRadix {\n     type Err;\n-    fn from_str_radix(str: &str, radix: uint) -> Result<Self, Self::Err>;\n+    fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::Err>;\n }\n \n /// A utility function that just calls FromStrRadix::from_str_radix.\n #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint)\n+pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: u32)\n                                        -> Result<T, T::Err> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n@@ -1501,7 +1501,7 @@ macro_rules! from_str_radix_float_impl {\n             /// `None` if the string did not represent a valid number.\n             /// Otherwise, `Some(n)` where `n` is the floating-point number\n             /// represented by `src`.\n-            fn from_str_radix(src: &str, radix: uint)\n+            fn from_str_radix(src: &str, radix: u32)\n                               -> Result<$T, ParseFloatError> {\n                 use self::FloatErrorKind::*;\n                 use self::ParseFloatError as PFE;\n@@ -1661,7 +1661,7 @@ macro_rules! from_str_radix_int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStrRadix for $T {\n             type Err = ParseIntError;\n-            fn from_str_radix(src: &str, radix: uint)\n+            fn from_str_radix(src: &str, radix: u32)\n                               -> Result<$T, ParseIntError> {\n                 use self::IntErrorKind::*;\n                 use self::ParseIntError as PIE;"}, {"sha": "ce26abe606dd4b432e7f85101e41e1de83e507d9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -41,7 +41,7 @@ macro_rules! delegate_iter {\n         delegate_iter!{$te : $ti}\n         impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n-            fn len(&self) -> uint {\n+            fn len(&self) -> usize {\n                 self.0.len()\n             }\n         }\n@@ -56,7 +56,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -78,7 +78,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -100,7 +100,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -178,7 +178,7 @@ pub enum Utf8Error {\n     /// The offset is guaranteed to be in bounds of the slice in question, and\n     /// the byte at the specified offset was the first invalid byte in the\n     /// sequence detected.\n-    InvalidByte(uint),\n+    InvalidByte(usize),\n \n     /// The byte slice was invalid because more bytes were needed but no more\n     /// bytes were available.\n@@ -227,7 +227,7 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0;\n-    while *s.offset(len as int) != 0 {\n+    while *s.offset(len as isize) != 0 {\n         len += 1;\n     }\n     let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n@@ -250,7 +250,7 @@ impl CharEq for char {\n     fn matches(&mut self, c: char) -> bool { *self == c }\n \n     #[inline]\n-    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n+    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n }\n \n impl<F> CharEq for F where F: FnMut(char) -> bool {\n@@ -383,7 +383,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (len, _) = self.iter.size_hint();\n         (len.saturating_add(3) / 4, Some(len))\n     }\n@@ -428,16 +428,16 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n-    front_offset: uint,\n+    front_offset: usize,\n     iter: Chars<'a>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for CharIndices<'a> {\n-    type Item = (uint, char);\n+    type Item = (usize, char);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, char)> {\n+    fn next(&mut self) -> Option<(usize, char)> {\n         let (pre_len, _) = self.iter.iter.size_hint();\n         match self.iter.next() {\n             None => None,\n@@ -451,15 +451,15 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, char)> {\n+    fn next_back(&mut self) -> Option<(usize, char)> {\n         match self.iter.next_back() {\n             None => None,\n             Some(ch) => {\n@@ -512,7 +512,7 @@ struct CharSplits<'a, Sep> {\n struct CharSplitsN<'a, Sep> {\n     iter: CharSplits<'a, Sep>,\n     /// The number of splits remaining\n-    count: uint,\n+    count: usize,\n     invert: bool,\n }\n \n@@ -636,15 +636,15 @@ impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n /// within a larger string using naive search\n #[derive(Clone)]\n struct NaiveSearcher {\n-    position: uint\n+    position: usize\n }\n \n impl NaiveSearcher {\n     fn new() -> NaiveSearcher {\n         NaiveSearcher { position: 0 }\n     }\n \n-    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(usize, usize)> {\n         while self.position + needle.len() <= haystack.len() {\n             if &haystack[self.position .. self.position + needle.len()] == needle {\n                 let match_pos = self.position;\n@@ -663,13 +663,13 @@ impl NaiveSearcher {\n #[derive(Clone)]\n struct TwoWaySearcher {\n     // constants\n-    crit_pos: uint,\n-    period: uint,\n+    crit_pos: usize,\n+    period: usize,\n     byteset: u64,\n \n     // variables\n-    position: uint,\n-    memory: uint\n+    position: usize,\n+    memory: usize\n }\n \n /*\n@@ -756,7 +756,7 @@ impl TwoWaySearcher {\n \n         // This isn't in the original algorithm, as far as I'm aware.\n         let byteset = needle.iter()\n-                            .fold(0, |a, &b| (1 << ((b & 0x3f) as uint)) | a);\n+                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n \n         // A particularly readable explanation of what's going on here can be found\n         // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n@@ -794,7 +794,8 @@ impl TwoWaySearcher {\n     // How far we can jump when we encounter a mismatch is all based on the fact\n     // that (u, v) is a critical factorization for the needle.\n     #[inline]\n-    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(uint, uint)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n+            -> Option<(usize, usize)> {\n         'search: loop {\n             // Check that we have room to search in\n             if self.position + needle.len() > haystack.len() {\n@@ -804,7 +805,7 @@ impl TwoWaySearcher {\n             // Quickly skip by large portions unrelated to our substring\n             if (self.byteset >>\n                     ((haystack[self.position + needle.len() - 1] & 0x3f)\n-                     as uint)) & 1 == 0 {\n+                     as usize)) & 1 == 0 {\n                 self.position += needle.len();\n                 if !long_period {\n                     self.memory = 0;\n@@ -851,7 +852,7 @@ impl TwoWaySearcher {\n     // Specifically, returns (i, p), where i is the starting index of v in some\n     // critical factorization (u, v) and p = period(v)\n     #[inline]\n-    fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) {\n+    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n         let mut left = -1; // Corresponds to i in the paper\n         let mut right = 0; // Corresponds to j in the paper\n         let mut offset = 1; // Corresponds to k in the paper\n@@ -937,16 +938,16 @@ pub struct MatchIndices<'a> {\n #[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n-    last_end: uint,\n+    last_end: usize,\n     finished: bool\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for MatchIndices<'a> {\n-    type Item = (uint, uint);\n+    type Item = (usize, usize);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n+    fn next(&mut self) -> Option<(usize, usize)> {\n         match self.searcher {\n             Naive(ref mut searcher)\n                 => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes()),\n@@ -991,8 +992,9 @@ Section: Comparing strings\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n+    // NOTE: In theory n should be libc::size_t and not usize, but libc is not available here\n     #[allow(improper_ctypes)]\n-    extern { fn memcmp(s1: *const i8, s2: *const i8, n: uint) -> i32; }\n+    extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n     a.len() == b.len() && unsafe {\n         memcmp(a.as_ptr() as *const i8,\n                b.as_ptr() as *const i8,\n@@ -1049,7 +1051,7 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         // ASCII characters are always valid, so only large\n         // bytes need more examination.\n         if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as uint] as uint;\n+            let w = UTF8_CHAR_WIDTH[first as usize] as usize;\n             let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n@@ -1124,7 +1126,7 @@ pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n     /// Index of the first byte of the next `char`\n-    pub next: uint,\n+    pub next: usize,\n }\n \n /// Mask of the value bits of a continuation byte\n@@ -1209,10 +1211,10 @@ mod traits {\n     /// // &s[3 .. 100];\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::Range<uint>> for str {\n+    impl ops::Index<ops::Range<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::Range<uint>) -> &str {\n+        fn index(&self, index: &ops::Range<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if index.start <= index.end &&\n                self.is_char_boundary(index.start) &&\n@@ -1232,10 +1234,10 @@ mod traits {\n     /// Panics when `end` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeTo<uint>> for str {\n+    impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.end) {\n                 unsafe { self.slice_unchecked(0, index.end) }\n@@ -1252,10 +1254,10 @@ mod traits {\n     /// Panics when `begin` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeFrom<uint>> for str {\n+    impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.start) {\n                 unsafe { self.slice_unchecked(index.start, self.len()) }\n@@ -1332,40 +1334,40 @@ pub trait StrExt {\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n     fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n     fn split<'a, P: CharEq>(&'a self, pat: P) -> Split<'a, P>;\n-    fn splitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> SplitN<'a, P>;\n+    fn splitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n     fn split_terminator<'a, P: CharEq>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n-    fn rsplitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> RSplitN<'a, P>;\n+    fn rsplitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n     fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n-    fn char_len(&self) -> uint;\n-    fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n+    fn char_len(&self) -> usize;\n+    fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n+    unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n     fn starts_with(&self, pat: &str) -> bool;\n     fn ends_with(&self, pat: &str) -> bool;\n     fn trim_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n     fn trim_left_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n     fn trim_right_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n-    fn is_char_boundary(&self, index: uint) -> bool;\n-    fn char_range_at(&self, start: uint) -> CharRange;\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n-    fn char_at(&self, i: uint) -> char;\n-    fn char_at_reverse(&self, i: uint) -> char;\n+    fn is_char_boundary(&self, index: usize) -> bool;\n+    fn char_range_at(&self, start: usize) -> CharRange;\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange;\n+    fn char_at(&self, i: usize) -> char;\n+    fn char_at_reverse(&self, i: usize) -> char;\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n-    fn find<P: CharEq>(&self, pat: P) -> Option<uint>;\n-    fn rfind<P: CharEq>(&self, pat: P) -> Option<uint>;\n-    fn find_str(&self, pat: &str) -> Option<uint>;\n+    fn find<P: CharEq>(&self, pat: P) -> Option<usize>;\n+    fn rfind<P: CharEq>(&self, pat: P) -> Option<usize>;\n+    fn find_str(&self, pat: &str) -> Option<usize>;\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n-    fn subslice_offset(&self, inner: &str) -> uint;\n+    fn subslice_offset(&self, inner: &str) -> usize;\n     fn as_ptr(&self) -> *const u8;\n-    fn len(&self) -> uint;\n+    fn len(&self) -> usize;\n     fn is_empty(&self) -> bool;\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n #[inline(never)]\n-fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n+fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     assert!(begin <= end);\n     panic!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n           begin, end, s);\n@@ -1409,7 +1411,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n+    fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1426,7 +1428,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n+    fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n         RSplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1470,9 +1472,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_len(&self) -> uint { self.chars().count() }\n+    fn char_len(&self) -> usize { self.chars().count() }\n \n-    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n+    fn slice_chars(&self, begin: usize, end: usize) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;\n         let mut begin_byte = None;\n@@ -1496,9 +1498,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n+    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         mem::transmute(Slice {\n-            data: self.as_ptr().offset(begin as int),\n+            data: self.as_ptr().offset(begin as isize),\n             len: end - begin,\n         })\n     }\n@@ -1550,7 +1552,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn is_char_boundary(&self, index: uint) -> bool {\n+    fn is_char_boundary(&self, index: usize) -> bool {\n         if index == self.len() { return true; }\n         match self.as_bytes().get(index) {\n             None => false,\n@@ -1559,13 +1561,13 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_range_at(&self, i: uint) -> CharRange {\n+    fn char_range_at(&self, i: usize) -> CharRange {\n         let (c, n) = char_range_at_raw(self.as_bytes(), i);\n         CharRange { ch: unsafe { mem::transmute(c) }, next: n }\n     }\n \n     #[inline]\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         let mut prev = start;\n \n         prev = prev.saturating_sub(1);\n@@ -1574,14 +1576,14 @@ impl StrExt for str {\n         }\n \n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n-        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n+        fn multibyte_char_range_at_reverse(s: &str, mut i: usize) -> CharRange {\n             // while there is a previous byte == 10......\n             while i > 0 && s.as_bytes()[i] & !CONT_MASK == TAG_CONT_U8 {\n                 i -= 1;\n             }\n \n             let mut val = s.as_bytes()[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+            let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n@@ -1596,12 +1598,12 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_at(&self, i: uint) -> char {\n+    fn char_at(&self, i: usize) -> char {\n         self.char_range_at(i).ch\n     }\n \n     #[inline]\n-    fn char_at_reverse(&self, i: uint) -> char {\n+    fn char_at_reverse(&self, i: usize) -> char {\n         self.char_range_at_reverse(i).ch\n     }\n \n@@ -1610,7 +1612,7 @@ impl StrExt for str {\n         unsafe { mem::transmute(self) }\n     }\n \n-    fn find<P: CharEq>(&self, mut pat: P) -> Option<uint> {\n+    fn find<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n         if pat.only_ascii() {\n             self.bytes().position(|b| pat.matches(b as char))\n         } else {\n@@ -1621,7 +1623,7 @@ impl StrExt for str {\n         }\n     }\n \n-    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<uint> {\n+    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n         if pat.only_ascii() {\n             self.bytes().rposition(|b| pat.matches(b as char))\n         } else {\n@@ -1632,7 +1634,7 @@ impl StrExt for str {\n         }\n     }\n \n-    fn find_str(&self, needle: &str) -> Option<uint> {\n+    fn find_str(&self, needle: &str) -> Option<usize> {\n         if needle.is_empty() {\n             Some(0)\n         } else {\n@@ -1653,10 +1655,10 @@ impl StrExt for str {\n         }\n     }\n \n-    fn subslice_offset(&self, inner: &str) -> uint {\n-        let a_start = self.as_ptr() as uint;\n+    fn subslice_offset(&self, inner: &str) -> usize {\n+        let a_start = self.as_ptr() as usize;\n         let a_end = a_start + self.len();\n-        let b_start = inner.as_ptr() as uint;\n+        let b_start = inner.as_ptr() as usize;\n         let b_end = b_start + inner.len();\n \n         assert!(a_start <= b_start);\n@@ -1670,7 +1672,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn len(&self) -> uint { self.repr().len }\n+    fn len(&self) -> usize { self.repr().len }\n \n     #[inline]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n@@ -1683,15 +1685,15 @@ impl StrExt for str {\n /// index of the next code point.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n+pub fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n     if bytes[i] < 128u8 {\n         return (bytes[i] as u32, i + 1);\n     }\n \n     // Multibyte case is a fn to allow char_range_at to inline cleanly\n-    fn multibyte_char_range_at(bytes: &[u8], i: uint) -> (u32, usize) {\n+    fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) {\n         let mut val = bytes[i] as u32;\n-        let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+        let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n         assert!((w != 0));\n \n         val = utf8_first_byte!(val, w);\n@@ -1718,7 +1720,7 @@ impl<'a> Iterator for Lines<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1734,7 +1736,7 @@ impl<'a> Iterator for LinesAny<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "baad31a61e105817916cd12ed9708afa4b61a683", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -422,7 +422,7 @@ impl<'a> Parser<'a> {\n                 Some((_, c)) => {\n                     match c.to_digit(10) {\n                         Some(i) => {\n-                            cur = cur * 10 + i;\n+                            cur = cur * 10 + i as usize;\n                             found = true;\n                             self.cur.next();\n                         }"}, {"sha": "0a3abd5d1acc3cbe3787d7478d06d77e0dadc598", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -159,12 +159,12 @@ impl AsciiExt for u8 {\n \n     #[inline]\n     fn to_ascii_uppercase(&self) -> u8 {\n-        ASCII_UPPERCASE_MAP[*self as uint]\n+        ASCII_UPPERCASE_MAP[*self as usize]\n     }\n \n     #[inline]\n     fn to_ascii_lowercase(&self) -> u8 {\n-        ASCII_LOWERCASE_MAP[*self as uint]\n+        ASCII_LOWERCASE_MAP[*self as usize]\n     }\n \n     #[inline]"}, {"sha": "7d15a16309e5b3f481a52440fa1df25b44d614da", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -370,7 +370,7 @@ impl Float for f32 {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigAll, ExpNone, false);\n+        num, 10, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -383,7 +383,7 @@ pub fn to_string(num: f32) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, SignNeg, DigAll, ExpNone, false);\n+        num, 16, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -396,7 +396,7 @@ pub fn to_str_hex(num: f32) -> String {\n /// * radix - The base to use\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n+pub fn to_str_radix_special(num: f32, rdx: u32) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n \n@@ -411,7 +411,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n+        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n }\n \n@@ -426,7 +426,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n+        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n }\n \n@@ -442,7 +442,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n+        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n }\n \n@@ -458,7 +458,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);\n+        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r\n }\n "}, {"sha": "0ce56371c77e544733a9dfc3a72a4ca2809b1e79", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -379,7 +379,7 @@ impl Float for f64 {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigAll, ExpNone, false);\n+        num, 10, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -392,7 +392,7 @@ pub fn to_string(num: f64) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, SignNeg, DigAll, ExpNone, false);\n+        num, 16, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -405,7 +405,7 @@ pub fn to_str_hex(num: f64) -> String {\n /// * radix - The base to use\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n+pub fn to_str_radix_special(num: f64, rdx: u32) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n \n@@ -420,7 +420,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n+        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n }\n \n@@ -435,7 +435,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n+        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n }\n \n@@ -451,7 +451,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n+        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n }\n \n@@ -467,7 +467,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);\n+        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r\n }\n "}, {"sha": "cf5e1eb0eb7ca4095ef85c2df69faa54a28f7398", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -182,7 +182,7 @@ fn int_to_str_bytes_common<T, F>(num: T, radix: uint, sign: SignFormat, mut f: F\n /// - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n ///   between digit and exponent sign `'p'`.\n pub fn float_to_str_bytes_common<T: Float>(\n-        num: T, radix: uint, negative_zero: bool,\n+        num: T, radix: u32, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n         ) -> (Vec<u8>, bool) {\n     assert!(2 <= radix && radix <= 36);\n@@ -253,7 +253,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n         deccum = deccum / radix_gen;\n         deccum = deccum.trunc();\n \n-        buf.push(char::from_digit(current_digit.to_int().unwrap() as uint, radix)\n+        buf.push(char::from_digit(current_digit.to_int().unwrap() as u32, radix)\n              .unwrap() as u8);\n \n         // No more digits to calculate for the non-fractional part -> break\n@@ -310,7 +310,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n             let current_digit = deccum.trunc().abs();\n \n             buf.push(char::from_digit(\n-                current_digit.to_int().unwrap() as uint, radix).unwrap() as u8);\n+                current_digit.to_int().unwrap() as u32, radix).unwrap() as u8);\n \n             // Decrease the deccumulator one fractional digit at a time\n             deccum = deccum.fract();\n@@ -324,7 +324,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n             let ascii2value = |chr: u8| {\n                 (chr as char).to_digit(radix).unwrap()\n             };\n-            let value2ascii = |val: uint| {\n+            let value2ascii = |val: u32| {\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n \n@@ -412,7 +412,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n /// `to_str_bytes_common()`, for details see there.\n #[inline]\n pub fn float_to_str_common<T: Float>(\n-        num: T, radix: uint, negative_zero: bool,\n+        num: T, radix: u32, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n         ) -> (String, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n@@ -422,8 +422,8 @@ pub fn float_to_str_common<T: Float>(\n \n // Some constants for from_str_bytes_common's input validation,\n // they define minimum radix values for which the character is a valid digit.\n-static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n-static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+static DIGIT_P_RADIX: u32 = ('p' as u32) - ('a' as u32) + 11;\n+static DIGIT_E_RADIX: u32 = ('e' as u32) - ('a' as u32) + 11;\n \n #[cfg(test)]\n mod tests {"}, {"sha": "38ba0b38df5a7a6f8c51a8aa3859b6a7da56ccfa", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -645,7 +645,7 @@ impl<'a> StringReader<'a> {\n \n     /// Scan through any digits (base `radix`) or underscores, and return how\n     /// many digits there were.\n-    fn scan_digits(&mut self, radix: usize) -> usize {\n+    fn scan_digits(&mut self, radix: u32) -> usize {\n         let mut len = 0;\n         loop {\n             let c = self.curr;"}, {"sha": "82b5ec11d95d1dd8aef5c9f990ade25c9a950d27", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -297,7 +297,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             PushParam => {\n                 // params are 1-indexed\n                 stack.push(mparams[match cur.to_digit(10) {\n-                    Some(d) => d - 1,\n+                    Some(d) => d as usize - 1,\n                     None => return Err(\"bad param number\".to_string())\n                 }].clone());\n             },"}, {"sha": "977cb783344e366e07c5a34403e9a8507a848c3c", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -32,7 +32,6 @@\n #![feature(no_std)]\n #![no_std]\n #![feature(slicing_syntax)]\n-#![feature(int_uint)]\n #![feature(core)]\n \n extern crate core;"}, {"sha": "61f447a3dd3b687a836c4f17f308aabd76ab41ca", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -14,7 +14,7 @@\n \n /// The version of [Unicode](http://www.unicode.org/)\n /// that the unicode parts of `CharExt` and `UnicodeStrPrelude` traits are based on.\n-pub const UNICODE_VERSION: (uint, uint, uint) = (7, 0, 0);\n+pub const UNICODE_VERSION: (u64, u64, u64) = (7, 0, 0);\n \n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n@@ -6977,7 +6977,7 @@ pub mod conversions {\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n+    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<usize> {\n         match table.binary_search_by(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n@@ -7613,13 +7613,13 @@ pub mod charwidth {\n         }\n     }\n \n-    pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n-        match c as uint {\n+    pub fn width(c: char, is_cjk: bool) -> Option<usize> {\n+        match c as usize {\n             _c @ 0 => Some(0),          // null is zero width\n             cu if cu < 0x20 => None,    // control sequences have no width\n             cu if cu < 0x7F => Some(1), // ASCII\n             cu if cu < 0xA0 => None,    // more control sequences\n-            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as uint)\n+            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as usize)\n         }\n     }\n "}, {"sha": "c0f45ca4d7247e948143cc06a86595df4a3a5e09", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -36,7 +36,7 @@ pub trait CharExt {\n     /// Panics if given a radix > 36.\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool;\n+    fn is_digit(self, radix: u32) -> bool;\n \n     /// Converts a character to the corresponding digit.\n     ///\n@@ -51,7 +51,7 @@ pub trait CharExt {\n     /// Panics if given a radix outside the range [0..36].\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint>;\n+    fn to_digit(self, radix: u32) -> Option<u32>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape\n     /// of a character, as `char`s.\n@@ -80,12 +80,12 @@ pub trait CharExt {\n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint;\n+    fn len_utf8(self) -> usize;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint;\n+    fn len_utf16(self) -> usize;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n@@ -94,7 +94,7 @@ pub trait CharExt {\n     /// and a `None` will be returned.\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n@@ -103,7 +103,7 @@ pub trait CharExt {\n     /// and a `None` will be returned.\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n \n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n@@ -216,31 +216,31 @@ pub trait CharExt {\n     /// `is_cjk` = `false`) if the context cannot be reliably determined.\n     #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n-    fn width(self, is_cjk: bool) -> Option<uint>;\n+    fn width(self, is_cjk: bool) -> Option<usize>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool { C::is_digit(self, radix) }\n+    fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint> { C::to_digit(self, radix) }\n+    fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> char::EscapeUnicode { C::escape_unicode(self) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> char::EscapeDefault { C::escape_default(self) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint { C::len_utf8(self) }\n+    fn len_utf8(self) -> usize { C::len_utf8(self) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint { C::len_utf16(self) }\n+    fn len_utf16(self) -> usize { C::len_utf16(self) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> { C::encode_utf8(self, dst) }\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> { C::encode_utf16(self, dst) }\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_alphabetic(self) -> bool {\n@@ -313,5 +313,5 @@ impl CharExt for char {\n \n     #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n-    fn width(self, is_cjk: bool) -> Option<uint> { charwidth::width(self, is_cjk) }\n+    fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n }"}, {"sha": "9bd8c5525a056828966e0838637722518d0370f6", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -43,7 +43,7 @@ pub trait UnicodeStr {\n     fn words<'a>(&'a self) -> Words<'a>;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n-    fn width(&self, is_cjk: bool) -> uint;\n+    fn width(&self, is_cjk: bool) -> usize;\n     fn trim<'a>(&'a self) -> &'a str;\n     fn trim_left<'a>(&'a self) -> &'a str;\n     fn trim_right<'a>(&'a self) -> &'a str;\n@@ -57,7 +57,7 @@ impl UnicodeStr for str {\n \n     #[inline]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        GraphemeIndices { start_offset: self.as_ptr() as uint, iter: self.graphemes(is_extended) }\n+        GraphemeIndices { start_offset: self.as_ptr() as usize, iter: self.graphemes(is_extended) }\n     }\n \n     #[inline]\n@@ -78,7 +78,7 @@ impl UnicodeStr for str {\n     fn is_alphanumeric(&self) -> bool { self.chars().all(|c| c.is_alphanumeric()) }\n \n     #[inline]\n-    fn width(&self, is_cjk: bool) -> uint {\n+    fn width(&self, is_cjk: bool) -> usize {\n         self.chars().map(|c| c.width(is_cjk).unwrap_or(0)).sum()\n     }\n \n@@ -101,28 +101,28 @@ impl UnicodeStr for str {\n /// External iterator for grapheme clusters and byte offsets.\n #[derive(Clone)]\n pub struct GraphemeIndices<'a> {\n-    start_offset: uint,\n+    start_offset: usize,\n     iter: Graphemes<'a>,\n }\n \n impl<'a> Iterator for GraphemeIndices<'a> {\n-    type Item = (uint, &'a str);\n+    type Item = (usize, &'a str);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, &'a str)> {\n-        self.iter.next().map(|s| (s.as_ptr() as uint - self.start_offset, s))\n+    fn next(&mut self) -> Option<(usize, &'a str)> {\n+        self.iter.next().map(|s| (s.as_ptr() as usize - self.start_offset, s))\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n \n impl<'a> DoubleEndedIterator for GraphemeIndices<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, &'a str)> {\n-        self.iter.next_back().map(|s| (s.as_ptr() as uint - self.start_offset, s))\n+    fn next_back(&mut self) -> Option<(usize, &'a str)> {\n+        self.iter.next_back().map(|s| (s.as_ptr() as usize - self.start_offset, s))\n     }\n }\n \n@@ -151,7 +151,7 @@ impl<'a> Iterator for Graphemes<'a> {\n     type Item = &'a str;\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let slen = self.string.len();\n         (cmp::min(slen, 1), Some(slen))\n     }\n@@ -378,8 +378,8 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n #[inline]\n-pub fn utf8_char_width(b: u8) -> uint {\n-    return UTF8_CHAR_WIDTH[b as uint] as uint;\n+pub fn utf8_char_width(b: u8) -> usize {\n+    return UTF8_CHAR_WIDTH[b as usize] as usize;\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n@@ -468,7 +468,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (low, high) = self.iter.size_hint();\n         // we could be entirely valid surrogates (2 elements per\n         // char), or entirely non-surrogates (1 element per char)\n@@ -534,7 +534,7 @@ impl<I> Iterator for Utf16Encoder<I> where I: Iterator<Item=char> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (low, high) = self.chars.size_hint();\n         // every char gets either one u16 or two u16,\n         // so this iterator is between 1 or 2 times as"}, {"sha": "bfe22712de8c3b2e0b4e5b2092fd6854b8a8b1da", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7870b6faa43a9e63b5575d5d9663457003a8ac5/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=f7870b6faa43a9e63b5575d5d9663457003a8ac5", "patch": "@@ -19,18 +19,18 @@ macro_rules! t {\n \n pub fn main() {\n     // Basic usage\n-    t!(to_string(1.2345678e-5f64, 10u, true, SignNeg, DigMax(6), ExpDec, false),\n+    t!(to_string(1.2345678e-5f64, 10, true, SignNeg, DigMax(6), ExpDec, false),\n              \"1.234568e-5\");\n \n     // Hexadecimal output\n-    t!(to_string(7.281738281250e+01f64, 16u, true, SignAll, DigMax(6), ExpBin, false),\n+    t!(to_string(7.281738281250e+01f64, 16, true, SignAll, DigMax(6), ExpBin, false),\n               \"+1.2345p+6\");\n-    t!(to_string(-1.777768135071e-02f64, 16u, true, SignAll, DigMax(6), ExpBin, false),\n+    t!(to_string(-1.777768135071e-02f64, 16, true, SignAll, DigMax(6), ExpBin, false),\n              \"-1.2345p-6\");\n \n     // Some denormals\n-    t!(to_string(4.9406564584124654e-324f64, 10u, true, SignNeg, DigMax(6), ExpBin, false),\n+    t!(to_string(4.9406564584124654e-324f64, 10, true, SignNeg, DigMax(6), ExpBin, false),\n              \"1p-1074\");\n-    t!(to_string(2.2250738585072009e-308f64, 10u, true, SignNeg, DigMax(6), ExpBin, false),\n+    t!(to_string(2.2250738585072009e-308f64, 10, true, SignNeg, DigMax(6), ExpBin, false),\n              \"1p-1022\");\n }"}]}