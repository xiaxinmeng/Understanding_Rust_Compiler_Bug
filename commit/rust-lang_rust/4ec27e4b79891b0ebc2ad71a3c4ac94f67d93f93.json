{"sha": "4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYzI3ZTRiNzk4OTFiMGViYzJhZDcxYTNjNGFjOTRmNjdkOTNmOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-20T00:51:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-20T00:51:54Z"}, "message": "Auto merge of #79220 - Dylan-DPC:rollup-5bpbygd, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #79119 (Clarify availability of atomic operations)\n - #79123 (Add u128 and i128 integer tests)\n - #79177 (Test drop order for (destructuring) assignments)\n - #79181 (rustdoc: add [src] links to methods on a trait's page)\n - #79183 (Make compiletest testing use the local sysroot)\n - #79185 (expand/resolve: Pre-requisites to \"Turn `#[derive]` into a regular macro attribute\")\n - #79193 (Revert #78969 \"Normalize function type during validation\")\n - #79194 (Make as{_mut,}_slice on array::IntoIter public)\n - #79204 (Add jyn514 email alias to mailmap)\n - #79212 (Move `rustc_ty` -> `rustc_ty_utils`)\n - #79217 (Add the \"memcpy\" doc alias to slice::copy_from_slice)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "602e46b3159e5835cba6bcb4e8441189f2aa0d8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/602e46b3159e5835cba6bcb4e8441189f2aa0d8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "html_url": "https://github.com/rust-lang/rust/commit/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09c9c9f7da72b774cc445c0f56fc0b9792a49647", "url": "https://api.github.com/repos/rust-lang/rust/commits/09c9c9f7da72b774cc445c0f56fc0b9792a49647", "html_url": "https://github.com/rust-lang/rust/commit/09c9c9f7da72b774cc445c0f56fc0b9792a49647"}, {"sha": "5adc00fbb8a40ecc685b26abfce0a4b619eb4c88", "url": "https://api.github.com/repos/rust-lang/rust/commits/5adc00fbb8a40ecc685b26abfce0a4b619eb4c88", "html_url": "https://github.com/rust-lang/rust/commit/5adc00fbb8a40ecc685b26abfce0a4b619eb4c88"}], "stats": {"total": 1369, "additions": 633, "deletions": 736}, "files": [{"sha": "d3e400e5f9061b309d79734f7fbdd67bb4a267d4", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -148,6 +148,7 @@ Jorge Aparicio <japaric@linux.com> <japaricious@gmail.com>\n Joseph Martin <pythoner6@gmail.com>\n Joseph T. Lyons <JosephTLyons@gmail.com> <josephtlyons@gmail.com>\n Joseph T. Lyons <JosephTLyons@gmail.com> <JosephTLyons@users.noreply.github.com>\n+Joshua Nelson <jyn514@gmail.com> <joshua@yottadb.com>\n jumbatm <jumbatm@gmail.com> <30644300+jumbatm@users.noreply.github.com>\n Junyoung Cho <june0.cho@samsung.com>\n Jyun-Yan You <jyyou.tw@gmail.com> <jyyou@cs.nctu.edu.tw>"}, {"sha": "b5abab7ba965dece00b6d8abf655351691c321e0", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -3802,7 +3802,7 @@ dependencies = [\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n  \"rustc_traits\",\n- \"rustc_ty\",\n+ \"rustc_ty_utils\",\n  \"rustc_typeck\",\n  \"smallvec 1.4.2\",\n  \"tempfile\",\n@@ -4240,7 +4240,7 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustc_ty\"\n+name = \"rustc_ty_utils\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures\","}, {"sha": "09ed1af345675befdf9ed2678922cbeeafb30153", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,7 +1,7 @@\n //! Implementation of the `#[cfg_accessible(path)]` attribute macro.\n \n use rustc_ast as ast;\n-use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n use rustc_span::symbol::sym;\n@@ -31,7 +31,7 @@ impl MultiItemModifier for Expander {\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,\n-        _span: Span,\n+        span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n@@ -49,11 +49,14 @@ impl MultiItemModifier for Expander {\n             None => return ExpandResult::Ready(Vec::new()),\n         };\n \n-        let failure_msg = \"cannot determine whether the path is accessible or not\";\n         match ecx.resolver.cfg_accessible(ecx.current_expansion.id, path) {\n             Ok(true) => ExpandResult::Ready(vec![item]),\n             Ok(false) => ExpandResult::Ready(Vec::new()),\n-            Err(_) => ExpandResult::Retry(item, failure_msg.into()),\n+            Err(Indeterminate) if ecx.force_mode => {\n+                ecx.span_err(span, \"cannot determine whether the path is accessible or not\");\n+                ExpandResult::Ready(vec![item])\n+            }\n+            Err(Indeterminate) => ExpandResult::Retry(item),\n         }\n     }\n }"}, {"sha": "a767de53dae1fcad387ff1e3dc48afbc6f24f3a1", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -407,13 +407,7 @@ impl<'a> TraitDef<'a> {\n                             _ => false,\n                         })\n                     }\n-                    _ => {\n-                        // Non-ADT derive is an error, but it should have been\n-                        // set earlier; see\n-                        // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n-                        // librustc_expand/base.rs:Annotatable::derive_allowed()\n-                        return;\n-                    }\n+                    _ => unreachable!(),\n                 };\n                 let container_id = cx.current_expansion.id.expn_data().parent;\n                 let always_copy = has_no_type_params && cx.resolver.has_derive_copy(container_id);\n@@ -475,12 +469,7 @@ impl<'a> TraitDef<'a> {\n                 );\n                 push(Annotatable::Item(P(ast::Item { attrs, ..(*newitem).clone() })))\n             }\n-            _ => {\n-                // Non-Item derive is an error, but it should have been\n-                // set earlier; see\n-                // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n-                // librustc_expand/base.rs:Annotatable::derive_allowed()\n-            }\n+            _ => unreachable!(),\n         }\n     }\n "}, {"sha": "72d94af4694abf477ead0f110f9a47b3e8a70d89", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -98,13 +98,7 @@ fn inject_impl_of_structural_trait(\n ) {\n     let item = match *item {\n         Annotatable::Item(ref item) => item,\n-        _ => {\n-            // Non-Item derive is an error, but it should have been\n-            // set earlier; see\n-            // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n-            // librustc_expand/base.rs:Annotatable::derive_allowed()\n-            return;\n-        }\n+        _ => unreachable!(),\n     };\n \n     let generics = match item.kind {"}, {"sha": "1c76c31e1a7ff9131311928e181e41bbef1679b0", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -251,8 +251,7 @@ pub enum ExpandResult<T, U> {\n     /// Expansion produced a result (possibly dummy).\n     Ready(T),\n     /// Expansion could not produce a result and needs to be retried.\n-    /// The string is an explanation that will be printed if we are stuck in an infinite retry loop.\n-    Retry(U, String),\n+    Retry(U),\n }\n \n // `meta_item` is the attribute, and `item` is the item being modified.\n@@ -889,8 +888,10 @@ pub trait ResolverExpand {\n     /// Some parent node that is close enough to the given macro call.\n     fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId;\n \n+    // Resolver interfaces for specific built-in macros.\n+    /// Does `#[derive(...)]` attribute with the given `ExpnId` have built-in `Copy` inside it?\n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool;\n-    fn add_derive_copy(&mut self, expn_id: ExpnId);\n+    /// Path resolution logic for `#[cfg_accessible(path)]`.\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }\n \n@@ -919,6 +920,9 @@ pub struct ExtCtxt<'a> {\n     pub root_path: PathBuf,\n     pub resolver: &'a mut dyn ResolverExpand,\n     pub current_expansion: ExpansionData,\n+    /// Error recovery mode entered when expansion is stuck\n+    /// (or during eager expansion, but that's a hack).\n+    pub force_mode: bool,\n     pub expansions: FxHashMap<Span, Vec<String>>,\n     /// Called directly after having parsed an external `mod foo;` in expansion.\n     pub(super) extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate)>,\n@@ -945,6 +949,7 @@ impl<'a> ExtCtxt<'a> {\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n             },\n+            force_mode: false,\n             expansions: FxHashMap::default(),\n         }\n     }"}, {"sha": "563783c5b795db575cf37bf1061798d1dfbd15a9", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,5 +1,7 @@\n //! Conditional compilation stripping.\n \n+use crate::base::Annotatable;\n+\n use rustc_ast::attr::HasAttrs;\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n@@ -496,6 +498,49 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn configure_fn_decl(&mut self, fn_decl: &mut ast::FnDecl) {\n         fn_decl.inputs.flat_map_in_place(|arg| self.configure(arg));\n     }\n+\n+    pub fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n+        // Since the item itself has already been configured by the InvocationCollector,\n+        // we know that fold result vector will contain exactly one element\n+        match item {\n+            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n+            Annotatable::TraitItem(item) => {\n+                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n+            }\n+            Annotatable::ImplItem(item) => {\n+                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n+            }\n+            Annotatable::ForeignItem(item) => {\n+                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n+            }\n+            Annotatable::Stmt(stmt) => {\n+                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n+            }\n+            Annotatable::Expr(mut expr) => Annotatable::Expr({\n+                self.visit_expr(&mut expr);\n+                expr\n+            }),\n+            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n+            Annotatable::Field(field) => {\n+                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n+            }\n+            Annotatable::FieldPat(fp) => {\n+                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n+            }\n+            Annotatable::GenericParam(param) => {\n+                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n+            }\n+            Annotatable::Param(param) => {\n+                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n+            }\n+            Annotatable::StructField(sf) => {\n+                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n+            }\n+            Annotatable::Variant(v) => {\n+                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n+            }\n+        }\n+    }\n }\n \n impl<'a> MutVisitor for StripUnconfigured<'a> {"}, {"sha": "5be2fee8b38fa8074505a3e7c8aed90060c8625a", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 126, "deletions": 257, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -209,6 +209,28 @@ impl AstFragmentKind {\n         self.make_from(DummyResult::any(span)).expect(\"couldn't create a dummy AST fragment\")\n     }\n \n+    /// Fragment supports macro expansion and not just inert attributes, `cfg` and `cfg_attr`.\n+    pub fn supports_macro_expansion(self) -> bool {\n+        match self {\n+            AstFragmentKind::OptExpr\n+            | AstFragmentKind::Expr\n+            | AstFragmentKind::Pat\n+            | AstFragmentKind::Ty\n+            | AstFragmentKind::Stmts\n+            | AstFragmentKind::Items\n+            | AstFragmentKind::TraitItems\n+            | AstFragmentKind::ImplItems\n+            | AstFragmentKind::ForeignItems => true,\n+            AstFragmentKind::Arms\n+            | AstFragmentKind::Fields\n+            | AstFragmentKind::FieldPats\n+            | AstFragmentKind::GenericParams\n+            | AstFragmentKind::Params\n+            | AstFragmentKind::StructFields\n+            | AstFragmentKind::Variants => false,\n+        }\n+    }\n+\n     fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(\n         self,\n         items: I,\n@@ -404,6 +426,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     // Recursively expand all macro invocations in this AST fragment.\n     pub fn fully_expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n+        let orig_force_mode = self.cx.force_mode;\n         self.cx.current_expansion.depth = 0;\n \n         // Collect all macro invocations and replace them with placeholders.\n@@ -432,6 +455,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 invocations = mem::take(&mut undetermined_invocations);\n                 force = !mem::replace(&mut progress, false);\n+                if force && self.monotonic {\n+                    self.cx.sess.delay_span_bug(\n+                        invocations.last().unwrap().0.span(),\n+                        \"expansion entered force mode without producing any errors\",\n+                    );\n+                }\n                 continue;\n             };\n \n@@ -460,18 +489,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n+            self.cx.force_mode = force;\n \n             // FIXME(jseyfried): Refactor out the following logic\n+            let fragment_kind = invoc.fragment_kind;\n             let (expanded_fragment, new_invocations) = match res {\n                 InvocationRes::Single(ext) => match self.expand_invoc(invoc, &ext.kind) {\n                     ExpandResult::Ready(fragment) => self.collect_invocations(fragment, &[]),\n-                    ExpandResult::Retry(invoc, explanation) => {\n+                    ExpandResult::Retry(invoc) => {\n                         if force {\n-                            // We are stuck, stop retrying and produce a dummy fragment.\n-                            let span = invoc.span();\n-                            self.cx.span_err(span, &explanation);\n-                            let fragment = invoc.fragment_kind.dummy(span);\n-                            self.collect_invocations(fragment, &[])\n+                            self.cx.span_bug(\n+                                invoc.span(),\n+                                \"expansion entered force mode but is still stuck\",\n+                            );\n                         } else {\n                             // Cannot expand, will retry this invocation later.\n                             undetermined_invocations\n@@ -483,36 +513,45 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 InvocationRes::DeriveContainer(_exts) => {\n                     // FIXME: Consider using the derive resolutions (`_exts`) immediately,\n                     // instead of enqueuing the derives to be resolved again later.\n-                    let (derives, item) = match invoc.kind {\n+                    let (derives, mut item) = match invoc.kind {\n                         InvocationKind::DeriveContainer { derives, item } => (derives, item),\n                         _ => unreachable!(),\n                     };\n-                    if !item.derive_allowed() {\n+                    let (item, derive_placeholders) = if !item.derive_allowed() {\n                         self.error_derive_forbidden_on_non_adt(&derives, &item);\n-                    }\n+                        item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n+                        (item, Vec::new())\n+                    } else {\n+                        let mut item = StripUnconfigured {\n+                            sess: self.cx.sess,\n+                            features: self.cx.ecfg.features,\n+                        }\n+                        .fully_configure(item);\n+                        item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n+\n+                        invocations.reserve(derives.len());\n+                        let derive_placeholders = derives\n+                            .into_iter()\n+                            .map(|path| {\n+                                let expn_id = ExpnId::fresh(None);\n+                                invocations.push((\n+                                    Invocation {\n+                                        kind: InvocationKind::Derive { path, item: item.clone() },\n+                                        fragment_kind,\n+                                        expansion_data: ExpansionData {\n+                                            id: expn_id,\n+                                            ..self.cx.current_expansion.clone()\n+                                        },\n+                                    },\n+                                    None,\n+                                ));\n+                                NodeId::placeholder_from_expn_id(expn_id)\n+                            })\n+                            .collect::<Vec<_>>();\n+                        (item, derive_placeholders)\n+                    };\n \n-                    let mut item = self.fully_configure(item);\n-                    item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n-\n-                    let mut derive_placeholders = Vec::with_capacity(derives.len());\n-                    invocations.reserve(derives.len());\n-                    for path in derives {\n-                        let expn_id = ExpnId::fresh(None);\n-                        derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n-                        invocations.push((\n-                            Invocation {\n-                                kind: InvocationKind::Derive { path, item: item.clone() },\n-                                fragment_kind: invoc.fragment_kind,\n-                                expansion_data: ExpansionData {\n-                                    id: expn_id,\n-                                    ..invoc.expansion_data.clone()\n-                                },\n-                            },\n-                            None,\n-                        ));\n-                    }\n-                    let fragment =\n-                        invoc.fragment_kind.expect_from_annotatables(::std::iter::once(item));\n+                    let fragment = fragment_kind.expect_from_annotatables(::std::iter::once(item));\n                     self.collect_invocations(fragment, &derive_placeholders)\n                 }\n             };\n@@ -526,6 +565,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         self.cx.current_expansion = orig_expansion_data;\n+        self.cx.force_mode = orig_force_mode;\n \n         // Finally incorporate all the expanded macros into the input AST fragment.\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n@@ -601,48 +641,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         (fragment, invocations)\n     }\n \n-    fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n-        let mut cfg = StripUnconfigured { sess: &self.cx.sess, features: self.cx.ecfg.features };\n-        // Since the item itself has already been configured by the InvocationCollector,\n-        // we know that fold result vector will contain exactly one element\n-        match item {\n-            Annotatable::Item(item) => Annotatable::Item(cfg.flat_map_item(item).pop().unwrap()),\n-            Annotatable::TraitItem(item) => {\n-                Annotatable::TraitItem(cfg.flat_map_trait_item(item).pop().unwrap())\n-            }\n-            Annotatable::ImplItem(item) => {\n-                Annotatable::ImplItem(cfg.flat_map_impl_item(item).pop().unwrap())\n-            }\n-            Annotatable::ForeignItem(item) => {\n-                Annotatable::ForeignItem(cfg.flat_map_foreign_item(item).pop().unwrap())\n-            }\n-            Annotatable::Stmt(stmt) => {\n-                Annotatable::Stmt(stmt.map(|stmt| cfg.flat_map_stmt(stmt).pop().unwrap()))\n-            }\n-            Annotatable::Expr(mut expr) => Annotatable::Expr({\n-                cfg.visit_expr(&mut expr);\n-                expr\n-            }),\n-            Annotatable::Arm(arm) => Annotatable::Arm(cfg.flat_map_arm(arm).pop().unwrap()),\n-            Annotatable::Field(field) => {\n-                Annotatable::Field(cfg.flat_map_field(field).pop().unwrap())\n-            }\n-            Annotatable::FieldPat(fp) => {\n-                Annotatable::FieldPat(cfg.flat_map_field_pattern(fp).pop().unwrap())\n-            }\n-            Annotatable::GenericParam(param) => {\n-                Annotatable::GenericParam(cfg.flat_map_generic_param(param).pop().unwrap())\n-            }\n-            Annotatable::Param(param) => {\n-                Annotatable::Param(cfg.flat_map_param(param).pop().unwrap())\n-            }\n-            Annotatable::StructField(sf) => {\n-                Annotatable::StructField(cfg.flat_map_struct_field(sf).pop().unwrap())\n-            }\n-            Annotatable::Variant(v) => Annotatable::Variant(cfg.flat_map_variant(v).pop().unwrap()),\n-        }\n-    }\n-\n     fn error_recursion_limit_reached(&mut self) {\n         let expn_data = self.cx.current_expansion.id.expn_data();\n         let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n@@ -735,20 +733,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         Ok(meta) => {\n                             let items = match expander.expand(self.cx, span, &meta, item) {\n                                 ExpandResult::Ready(items) => items,\n-                                ExpandResult::Retry(item, explanation) => {\n+                                ExpandResult::Retry(item) => {\n                                     // Reassemble the original invocation for retrying.\n-                                    return ExpandResult::Retry(\n-                                        Invocation {\n-                                            kind: InvocationKind::Attr {\n-                                                attr,\n-                                                item,\n-                                                derives,\n-                                                after_derive,\n-                                            },\n-                                            ..invoc\n+                                    return ExpandResult::Retry(Invocation {\n+                                        kind: InvocationKind::Attr {\n+                                            attr,\n+                                            item,\n+                                            derives,\n+                                            after_derive,\n                                         },\n-                                        explanation,\n-                                    );\n+                                        ..invoc\n+                                    });\n                                 }\n                             };\n                             fragment_kind.expect_from_annotatables(items)\n@@ -772,24 +767,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             InvocationKind::Derive { path, item } => match ext {\n                 SyntaxExtensionKind::Derive(expander)\n                 | SyntaxExtensionKind::LegacyDerive(expander) => {\n-                    if !item.derive_allowed() {\n-                        return ExpandResult::Ready(fragment_kind.dummy(span));\n-                    }\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n                     let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n                     let items = match expander.expand(self.cx, span, &meta, item) {\n                         ExpandResult::Ready(items) => items,\n-                        ExpandResult::Retry(item, explanation) => {\n+                        ExpandResult::Retry(item) => {\n                             // Reassemble the original invocation for retrying.\n-                            return ExpandResult::Retry(\n-                                Invocation {\n-                                    kind: InvocationKind::Derive { path: meta.path, item },\n-                                    ..invoc\n-                                },\n-                                explanation,\n-                            );\n+                            return ExpandResult::Retry(Invocation {\n+                                kind: InvocationKind::Derive { path: meta.path, item },\n+                                ..invoc\n+                            });\n                         }\n                     };\n                     fragment_kind.expect_from_annotatables(items)\n@@ -1034,11 +1023,9 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(\n         &mut self,\n-        attr: Option<ast::Attribute>,\n-        derives: Vec<Path>,\n+        (attr, derives, after_derive): (Option<ast::Attribute>, Vec<Path>, bool),\n         item: Annotatable,\n         kind: AstFragmentKind,\n-        after_derive: bool,\n     ) -> AstFragment {\n         self.collect(\n             kind,\n@@ -1054,61 +1041,46 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         attrs: &mut Vec<ast::Attribute>,\n         after_derive: &mut bool,\n     ) -> Option<ast::Attribute> {\n-        let attr = attrs\n+        attrs\n             .iter()\n             .position(|a| {\n                 if a.has_name(sym::derive) {\n                     *after_derive = true;\n                 }\n                 !self.cx.sess.is_attr_known(a) && !is_builtin_attr(a)\n             })\n-            .map(|i| attrs.remove(i));\n-        if let Some(attr) = &attr {\n-            if !self.cx.ecfg.custom_inner_attributes()\n-                && attr.style == ast::AttrStyle::Inner\n-                && !attr.has_name(sym::test)\n-            {\n-                feature_err(\n-                    &self.cx.sess.parse_sess,\n-                    sym::custom_inner_attributes,\n-                    attr.span,\n-                    \"non-builtin inner attributes are unstable\",\n-                )\n-                .emit();\n-            }\n-        }\n-        attr\n+            .map(|i| attrs.remove(i))\n     }\n \n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n-    fn classify_item(\n+    fn take_first_attr(\n         &mut self,\n         item: &mut impl HasAttrs,\n-    ) -> (Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool) {\n+    ) -> Option<(Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)> {\n         let (mut attr, mut traits, mut after_derive) = (None, Vec::new(), false);\n \n         item.visit_attrs(|mut attrs| {\n             attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n             traits = collect_derives(&mut self.cx, &mut attrs);\n         });\n \n-        (attr, traits, after_derive)\n+        if attr.is_some() || !traits.is_empty() { Some((attr, traits, after_derive)) } else { None }\n     }\n \n-    /// Alternative to `classify_item()` that ignores `#[derive]` so invocations fallthrough\n+    /// Alternative to `take_first_attr()` that ignores `#[derive]` so invocations fallthrough\n     /// to the unused-attributes lint (making it an error on statements and expressions\n     /// is a breaking change)\n-    fn classify_nonitem(\n+    fn take_first_attr_no_derive(\n         &mut self,\n         nonitem: &mut impl HasAttrs,\n-    ) -> (Option<ast::Attribute>, /* after_derive */ bool) {\n+    ) -> Option<(Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)> {\n         let (mut attr, mut after_derive) = (None, false);\n \n         nonitem.visit_attrs(|mut attrs| {\n             attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n         });\n \n-        (attr, after_derive)\n+        attr.map(|attr| (Some(attr), Vec::new(), after_derive))\n     }\n \n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n@@ -1152,23 +1124,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         visit_clobber(expr.deref_mut(), |mut expr| {\n             self.cfg.configure_expr_kind(&mut expr.kind);\n \n-            // ignore derives so they remain unused\n-            let (attr, after_derive) = self.classify_nonitem(&mut expr);\n-\n-            if let Some(ref attr_value) = attr {\n+            if let Some(attr) = self.take_first_attr_no_derive(&mut expr) {\n                 // Collect the invoc regardless of whether or not attributes are permitted here\n                 // expansion will eat the attribute so it won't error later.\n-                self.cfg.maybe_emit_expr_attr_err(attr_value);\n+                attr.0.as_ref().map(|attr| self.cfg.maybe_emit_expr_attr_err(attr));\n \n                 // AstFragmentKind::Expr requires the macro to emit an expression.\n                 return self\n-                    .collect_attr(\n-                        attr,\n-                        vec![],\n-                        Annotatable::Expr(P(expr)),\n-                        AstFragmentKind::Expr,\n-                        after_derive,\n-                    )\n+                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::Expr)\n                     .make_expr()\n                     .into_inner();\n             }\n@@ -1186,16 +1149,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n         let mut arm = configure!(self, arm);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut arm);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut arm) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Arm(arm),\n-                    AstFragmentKind::Arms,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Arm(arm), AstFragmentKind::Arms)\n                 .make_arms();\n         }\n \n@@ -1205,16 +1161,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_field(&mut self, field: ast::Field) -> SmallVec<[ast::Field; 1]> {\n         let mut field = configure!(self, field);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut field);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut field) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Field(field),\n-                    AstFragmentKind::Fields,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Field(field), AstFragmentKind::Fields)\n                 .make_fields();\n         }\n \n@@ -1224,16 +1173,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_field_pattern(&mut self, fp: ast::FieldPat) -> SmallVec<[ast::FieldPat; 1]> {\n         let mut fp = configure!(self, fp);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut fp);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut fp) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::FieldPat(fp),\n-                    AstFragmentKind::FieldPats,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::FieldPat(fp), AstFragmentKind::FieldPats)\n                 .make_field_patterns();\n         }\n \n@@ -1243,16 +1185,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n         let mut p = configure!(self, p);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut p);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut p) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Param(p),\n-                    AstFragmentKind::Params,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Param(p), AstFragmentKind::Params)\n                 .make_params();\n         }\n \n@@ -1262,16 +1197,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_struct_field(&mut self, sf: ast::StructField) -> SmallVec<[ast::StructField; 1]> {\n         let mut sf = configure!(self, sf);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut sf);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut sf) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::StructField(sf),\n-                    AstFragmentKind::StructFields,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::StructField(sf), AstFragmentKind::StructFields)\n                 .make_struct_fields();\n         }\n \n@@ -1281,16 +1209,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n         let mut variant = configure!(self, variant);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut variant);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut variant) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Variant(variant),\n-                    AstFragmentKind::Variants,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Variant(variant), AstFragmentKind::Variants)\n                 .make_variants();\n         }\n \n@@ -1302,20 +1223,11 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         expr.filter_map(|mut expr| {\n             self.cfg.configure_expr_kind(&mut expr.kind);\n \n-            // Ignore derives so they remain unused.\n-            let (attr, after_derive) = self.classify_nonitem(&mut expr);\n-\n-            if let Some(ref attr_value) = attr {\n-                self.cfg.maybe_emit_expr_attr_err(attr_value);\n+            if let Some(attr) = self.take_first_attr_no_derive(&mut expr) {\n+                attr.0.as_ref().map(|attr| self.cfg.maybe_emit_expr_attr_err(attr));\n \n                 return self\n-                    .collect_attr(\n-                        attr,\n-                        vec![],\n-                        Annotatable::Expr(P(expr)),\n-                        AstFragmentKind::OptExpr,\n-                        after_derive,\n-                    )\n+                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::OptExpr)\n                     .make_opt_expr()\n                     .map(|expr| expr.into_inner());\n             }\n@@ -1354,25 +1266,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, after_derive) = if stmt.is_item() {\n-                // FIXME: Handle custom attributes on statements (#15701)\n-                (None, vec![], false)\n-            } else {\n-                // ignore derives on non-item statements so it falls through\n-                // to the unused-attributes lint\n-                let (attr, after_derive) = self.classify_nonitem(&mut stmt);\n-                (attr, vec![], after_derive)\n-            };\n+            // FIXME: Handle custom attributes on statements (#15701).\n+            let attr =\n+                if stmt.is_item() { None } else { self.take_first_attr_no_derive(&mut stmt) };\n \n-            if attr.is_some() || !derives.is_empty() {\n+            if let Some(attr) = attr {\n                 return self\n-                    .collect_attr(\n-                        attr,\n-                        derives,\n-                        Annotatable::Stmt(P(stmt)),\n-                        AstFragmentKind::Stmts,\n-                        after_derive,\n-                    )\n+                    .collect_attr(attr, Annotatable::Stmt(P(stmt)), AstFragmentKind::Stmts)\n                     .make_stmts();\n             }\n         }\n@@ -1412,16 +1312,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = configure!(self, item);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut item);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut item) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Item(item),\n-                    AstFragmentKind::Items,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Item(item), AstFragmentKind::Items)\n                 .make_items();\n         }\n \n@@ -1515,16 +1408,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n         let mut item = configure!(self, item);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut item);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut item) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::TraitItem(item),\n-                    AstFragmentKind::TraitItems,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::TraitItem(item), AstFragmentKind::TraitItems)\n                 .make_trait_items();\n         }\n \n@@ -1545,16 +1431,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n         let mut item = configure!(self, item);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut item);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut item) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::ImplItem(item),\n-                    AstFragmentKind::ImplItems,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::ImplItem(item), AstFragmentKind::ImplItems)\n                 .make_impl_items();\n         }\n \n@@ -1595,16 +1474,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         &mut self,\n         mut foreign_item: P<ast::ForeignItem>,\n     ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n-        let (attr, traits, after_derive) = self.classify_item(&mut foreign_item);\n-\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut foreign_item) {\n             return self\n                 .collect_attr(\n                     attr,\n-                    traits,\n                     Annotatable::ForeignItem(foreign_item),\n                     AstFragmentKind::ForeignItems,\n-                    after_derive,\n                 )\n                 .make_foreign_items();\n         }\n@@ -1639,15 +1514,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     ) -> SmallVec<[ast::GenericParam; 1]> {\n         let mut param = configure!(self, param);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut param);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut param) {\n             return self\n                 .collect_attr(\n                     attr,\n-                    traits,\n                     Annotatable::GenericParam(param),\n                     AstFragmentKind::GenericParams,\n-                    after_derive,\n                 )\n                 .make_generic_params();\n         }\n@@ -1830,7 +1702,4 @@ impl<'feat> ExpansionConfig<'feat> {\n     fn proc_macro_hygiene(&self) -> bool {\n         self.features.map_or(false, |features| features.proc_macro_hygiene)\n     }\n-    fn custom_inner_attributes(&self) -> bool {\n-        self.features.map_or(false, |features| features.custom_inner_attributes)\n-    }\n }"}, {"sha": "dea167740edca5611dced8456d7a7b1a0e962784", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -75,38 +75,9 @@ impl MultiItemModifier for ProcMacroDerive {\n         item: Annotatable,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let item = match item {\n-            Annotatable::Arm(..)\n-            | Annotatable::Field(..)\n-            | Annotatable::FieldPat(..)\n-            | Annotatable::GenericParam(..)\n-            | Annotatable::Param(..)\n-            | Annotatable::StructField(..)\n-            | Annotatable::Variant(..) => panic!(\"unexpected annotatable\"),\n-            Annotatable::Item(item) => item,\n-            Annotatable::ImplItem(_)\n-            | Annotatable::TraitItem(_)\n-            | Annotatable::ForeignItem(_)\n-            | Annotatable::Stmt(_)\n-            | Annotatable::Expr(_) => {\n-                ecx.span_err(\n-                    span,\n-                    \"proc-macro derives may only be applied to a struct, enum, or union\",\n-                );\n-                return ExpandResult::Ready(Vec::new());\n-            }\n+            Annotatable::Item(item) => token::NtItem(item),\n+            _ => unreachable!(),\n         };\n-        match item.kind {\n-            ItemKind::Struct(..) | ItemKind::Enum(..) | ItemKind::Union(..) => {}\n-            _ => {\n-                ecx.span_err(\n-                    span,\n-                    \"proc-macro derives may only be applied to a struct, enum, or union\",\n-                );\n-                return ExpandResult::Ready(Vec::new());\n-            }\n-        }\n-\n-        let item = token::NtItem(item);\n         let input = if item.pretty_printing_compatibility_hack() {\n             TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n         } else {"}, {"sha": "4ede9d67b741f0b4841b2d4d27b17f6000ee44a5", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -39,6 +39,9 @@ pub enum NonMacroAttrKind {\n     Tool,\n     /// Single-segment custom attribute registered by a derive macro (`#[serde(default)]`).\n     DeriveHelper,\n+    /// Single-segment custom attribute registered by a derive macro\n+    /// but used before that derive macro was expanded (deprecated).\n+    DeriveHelperCompat,\n     /// Single-segment custom attribute registered with `#[register_attr]`.\n     Registered,\n }\n@@ -370,7 +373,9 @@ impl NonMacroAttrKind {\n         match self {\n             NonMacroAttrKind::Builtin => \"built-in attribute\",\n             NonMacroAttrKind::Tool => \"tool attribute\",\n-            NonMacroAttrKind::DeriveHelper => \"derive helper attribute\",\n+            NonMacroAttrKind::DeriveHelper | NonMacroAttrKind::DeriveHelperCompat => {\n+                \"derive helper attribute\"\n+            }\n             NonMacroAttrKind::Registered => \"explicitly registered attribute\",\n         }\n     }\n@@ -385,7 +390,9 @@ impl NonMacroAttrKind {\n     /// Users of some attributes cannot mark them as used, so they are considered always used.\n     pub fn is_used(self) -> bool {\n         match self {\n-            NonMacroAttrKind::Tool | NonMacroAttrKind::DeriveHelper => true,\n+            NonMacroAttrKind::Tool\n+            | NonMacroAttrKind::DeriveHelper\n+            | NonMacroAttrKind::DeriveHelperCompat => true,\n             NonMacroAttrKind::Builtin | NonMacroAttrKind::Registered => false,\n         }\n     }"}, {"sha": "61fad8863e7c423679bd32d9cc81567370781c9b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     }\n \n     pub(super) fn asyncness(&self, local_def_id: LocalDefId) -> Option<hir::IsAsync> {\n-        // similar to the asyncness fn in rustc_ty::ty\n+        // similar to the asyncness fn in rustc_ty_utils::ty\n         let hir_id = self.tcx().hir().local_def_id_to_hir_id(local_def_id);\n         let node = self.tcx().hir().get(hir_id);\n         let fn_like = rustc_middle::hir::map::blocks::FnLikeNode::from_node(node)?;"}, {"sha": "2481a27dee7951588f552ab92e4e87f985fcf4f1", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -41,7 +41,7 @@ rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n rustc_privacy = { path = \"../rustc_privacy\" }\n rustc_resolve = { path = \"../rustc_resolve\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n-rustc_ty = { path = \"../rustc_ty\" }\n+rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n tempfile = \"3.0.5\"\n \n [target.'cfg(windows)'.dependencies]"}, {"sha": "5fd560d7effb37abc5e227e485bd7e99ce8cb10e", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -699,7 +699,7 @@ pub static DEFAULT_QUERY_PROVIDERS: SyncLazy<Providers> = SyncLazy::new(|| {\n     rustc_passes::provide(providers);\n     rustc_resolve::provide(providers);\n     rustc_traits::provide(providers);\n-    rustc_ty::provide(providers);\n+    rustc_ty_utils::provide(providers);\n     rustc_metadata::provide(providers);\n     rustc_lint::provide(providers);\n     rustc_symbol_mangling::provide(providers);"}, {"sha": "919e4a90a1716ca49d8995b2ba7d643e3690ace8", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -38,9 +38,7 @@ pub struct Validator {\n impl<'tcx> MirPass<'tcx> for Validator {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = body.source.def_id();\n-        // We need to param_env_reveal_all_normalized, as some optimizations\n-        // change types in ways that require unfolding opaque types.\n-        let param_env = tcx.param_env_reveal_all_normalized(def_id);\n+        let param_env = tcx.param_env(def_id);\n         let mir_phase = self.mir_phase;\n \n         let always_live_locals = AlwaysLiveLocals::new(body);\n@@ -81,6 +79,7 @@ pub fn equal_up_to_regions(\n     }\n \n     // Normalize lifetimes away on both sides, then compare.\n+    let param_env = param_env.with_reveal_all_normalized(tcx);\n     let normalize = |ty: Ty<'tcx>| {\n         tcx.normalize_erasing_regions(\n             param_env,\n@@ -168,14 +167,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return true;\n         }\n         // Normalize projections and things like that.\n-        let src = self.tcx.normalize_erasing_regions(self.param_env, src);\n-        let dest = self.tcx.normalize_erasing_regions(self.param_env, dest);\n+        // FIXME: We need to reveal_all, as some optimizations change types in ways\n+        // that require unfolding opaque types.\n+        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n+        let src = self.tcx.normalize_erasing_regions(param_env, src);\n+        let dest = self.tcx.normalize_erasing_regions(param_env, dest);\n \n         // Type-changing assignments can happen when subtyping is used. While\n         // all normal lifetimes are erased, higher-ranked types with their\n         // late-bound lifetimes are still around and can lead to type\n         // differences. So we compare ignoring lifetimes.\n-        equal_up_to_regions(self.tcx, self.param_env, src, dest)\n+        equal_up_to_regions(self.tcx, param_env, src, dest)\n     }\n }\n \n@@ -363,7 +365,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::Call { func, args, destination, cleanup, .. } => {\n                 let func_ty = func.ty(&self.body.local_decls, self.tcx);\n-                let func_ty = self.tcx.normalize_erasing_regions(self.param_env, func_ty);\n                 match func_ty.kind() {\n                     ty::FnPtr(..) | ty::FnDef(..) => {}\n                     _ => self.fail("}, {"sha": "41985757b57af4906812c7682b8774f31cd2c63b", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -312,14 +312,13 @@ impl<'a> Parser<'a> {\n }\n \n pub fn maybe_needs_tokens(attrs: &[ast::Attribute]) -> bool {\n+    // One of the attributes may either itself be a macro, or apply derive macros (`derive`),\n+    // or expand to macro attributes (`cfg_attr`).\n     attrs.iter().any(|attr| {\n-        if let Some(ident) = attr.ident() {\n+        attr.ident().map_or(true, |ident| {\n             ident.name == sym::derive\n-            // This might apply a custom attribute/derive\n-            || ident.name == sym::cfg_attr\n-            || !rustc_feature::is_builtin_attr_name(ident.name)\n-        } else {\n-            true\n-        }\n+                || ident.name == sym::cfg_attr\n+                || !rustc_feature::is_builtin_attr_name(ident.name)\n+        })\n     })\n }"}, {"sha": "2cca1a6ee5979eb0ae065e8923b79509cdb0c0c1", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -609,7 +609,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::DeriveHelpersCompat => {\n-                    let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n                     if filter_fn(res) {\n                         for derive in parent_scope.derives {\n                             let parent_scope = &ParentScope { derives: &[], ..*parent_scope };"}, {"sha": "1ee96f81e4fabcb2e6c0495f61a19c6b36aa2400", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 70, "deletions": 62, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -12,24 +12,24 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::ptr_key::PtrKey;\n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_expand::base::{Indeterminate, InvocationRes, ResolverExpand, SyntaxExtension};\n use rustc_expand::compile_declarative_macro;\n-use rustc_expand::expand::{AstFragment, AstFragmentKind, Invocation, InvocationKind};\n+use rustc_expand::expand::{AstFragment, Invocation, InvocationKind};\n use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id;\n use rustc_middle::middle::stability;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::UNUSED_MACROS;\n+use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{self, ExpnData, ExpnId, ExpnKind};\n+use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-\n-use rustc_data_structures::sync::Lrc;\n-use rustc_span::hygiene::{AstPass, MacroKind};\n use std::cell::Cell;\n use std::{mem, ptr};\n \n@@ -241,15 +241,20 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             }\n         };\n \n-        let (path, kind, derives, after_derive) = match invoc.kind {\n+        let (path, kind, inner_attr, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } => (\n                 &attr.get_normal_item().path,\n                 MacroKind::Attr,\n+                attr.style == ast::AttrStyle::Inner,\n                 self.arenas.alloc_ast_paths(derives),\n                 after_derive,\n             ),\n-            InvocationKind::Bang { ref mac, .. } => (&mac.path, MacroKind::Bang, &[][..], false),\n-            InvocationKind::Derive { ref path, .. } => (path, MacroKind::Derive, &[][..], false),\n+            InvocationKind::Bang { ref mac, .. } => {\n+                (&mac.path, MacroKind::Bang, false, &[][..], false)\n+            }\n+            InvocationKind::Derive { ref path, .. } => {\n+                (path, MacroKind::Derive, false, &[][..], false)\n+            }\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n                 // Block expansion of the container until we resolve all derives in it.\n                 // This is required for two reasons:\n@@ -281,7 +286,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n                                     ext.helper_attrs.iter().map(|name| Ident::new(*name, span)),\n                                 );\n                                 if ext.is_derive_copy {\n-                                    self.add_derive_copy(invoc_id);\n+                                    self.containers_deriving_copy.insert(invoc_id);\n                                 }\n                                 ext\n                             }\n@@ -299,8 +304,17 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n         // Derives are not included when `invocations` are collected, so we have to add them here.\n         let parent_scope = &ParentScope { derives, ..parent_scope };\n+        let require_inert = !invoc.fragment_kind.supports_macro_expansion();\n         let node_id = self.lint_node_id(eager_expansion_root);\n-        let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, node_id, force)?;\n+        let (ext, res) = self.smart_resolve_macro_path(\n+            path,\n+            kind,\n+            require_inert,\n+            inner_attr,\n+            parent_scope,\n+            node_id,\n+            force,\n+        )?;\n \n         let span = invoc.span();\n         invoc_id.set_expn_data(ext.expn_data(\n@@ -318,29 +332,6 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             self.definitions.add_parent_module_of_macro_def(invoc_id, normal_module_def_id);\n         }\n \n-        match invoc.fragment_kind {\n-            AstFragmentKind::Arms\n-            | AstFragmentKind::Fields\n-            | AstFragmentKind::FieldPats\n-            | AstFragmentKind::GenericParams\n-            | AstFragmentKind::Params\n-            | AstFragmentKind::StructFields\n-            | AstFragmentKind::Variants => {\n-                if let Res::Def(..) = res {\n-                    self.session.span_err(\n-                        span,\n-                        &format!(\n-                            \"expected an inert attribute, found {} {}\",\n-                            res.article(),\n-                            res.descr()\n-                        ),\n-                    );\n-                    return Ok(InvocationRes::Single(self.dummy_ext(kind)));\n-                }\n-            }\n-            _ => {}\n-        }\n-\n         Ok(InvocationRes::Single(ext))\n     }\n \n@@ -360,10 +351,6 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         self.containers_deriving_copy.contains(&expn_id)\n     }\n \n-    fn add_derive_copy(&mut self, expn_id: ExpnId) {\n-        self.containers_deriving_copy.insert(expn_id);\n-    }\n-\n     // The function that implements the resolution logic of `#[cfg_accessible(path)]`.\n     // Returns true if the path can certainly be resolved in one of three namespaces,\n     // returns false if the path certainly cannot be resolved in any of the three namespaces.\n@@ -403,18 +390,21 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n impl<'a> Resolver<'a> {\n     /// Resolve macro path with error reporting and recovery.\n+    /// Uses dummy syntax extensions for unresolved macros or macros with unexpected resolutions\n+    /// for better error recovery.\n     fn smart_resolve_macro_path(\n         &mut self,\n         path: &ast::Path,\n         kind: MacroKind,\n+        require_inert: bool,\n+        inner_attr: bool,\n         parent_scope: &ParentScope<'a>,\n         node_id: NodeId,\n         force: bool,\n     ) -> Result<(Lrc<SyntaxExtension>, Res), Indeterminate> {\n         let (ext, res) = match self.resolve_macro_path(path, Some(kind), parent_scope, true, force)\n         {\n             Ok((Some(ext), res)) => (ext, res),\n-            // Use dummy syntax extensions for unresolved macros for better recovery.\n             Ok((None, res)) => (self.dummy_ext(kind), res),\n             Err(Determinacy::Determined) => (self.dummy_ext(kind), Res::Err),\n             Err(Determinacy::Undetermined) => return Err(Indeterminate),\n@@ -451,19 +441,43 @@ impl<'a> Resolver<'a> {\n \n         self.check_stability_and_deprecation(&ext, path, node_id);\n \n-        Ok(if ext.macro_kind() != kind {\n-            let expected = kind.descr_expected();\n+        let unexpected_res = if ext.macro_kind() != kind {\n+            Some((kind.article(), kind.descr_expected()))\n+        } else if require_inert && matches!(res, Res::Def(..)) {\n+            Some((\"a\", \"non-macro attribute\"))\n+        } else {\n+            None\n+        };\n+        if let Some((article, expected)) = unexpected_res {\n             let path_str = pprust::path_to_string(path);\n             let msg = format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str);\n             self.session\n                 .struct_span_err(path.span, &msg)\n-                .span_label(path.span, format!(\"not {} {}\", kind.article(), expected))\n+                .span_label(path.span, format!(\"not {} {}\", article, expected))\n                 .emit();\n-            // Use dummy syntax extensions for unexpected macro kinds for better recovery.\n-            (self.dummy_ext(kind), Res::Err)\n-        } else {\n-            (ext, res)\n-        })\n+            return Ok((self.dummy_ext(kind), Res::Err));\n+        }\n+\n+        // We are trying to avoid reporting this error if other related errors were reported.\n+        if inner_attr\n+            && !self.session.features_untracked().custom_inner_attributes\n+            && path != &sym::test\n+            && res != Res::Err\n+        {\n+            feature_err(\n+                &self.session.parse_sess,\n+                sym::custom_inner_attributes,\n+                path.span,\n+                match res {\n+                    Res::Def(..) => \"inner macro attributes are unstable\",\n+                    Res::NonMacroAttr(..) => \"custom inner attributes are unstable\",\n+                    _ => unreachable!(),\n+                },\n+            )\n+            .emit();\n+        }\n+\n+        Ok((ext, res))\n     }\n \n     pub fn resolve_macro_path(\n@@ -568,10 +582,9 @@ impl<'a> Resolver<'a> {\n             struct Flags: u8 {\n                 const MACRO_RULES          = 1 << 0;\n                 const MODULE               = 1 << 1;\n-                const DERIVE_HELPER_COMPAT = 1 << 2;\n-                const MISC_SUGGEST_CRATE   = 1 << 3;\n-                const MISC_SUGGEST_SELF    = 1 << 4;\n-                const MISC_FROM_PRELUDE    = 1 << 5;\n+                const MISC_SUGGEST_CRATE   = 1 << 2;\n+                const MISC_SUGGEST_SELF    = 1 << 3;\n+                const MISC_FROM_PRELUDE    = 1 << 4;\n             }\n         }\n \n@@ -646,14 +659,11 @@ impl<'a> Resolver<'a> {\n                             ) {\n                                 Ok((Some(ext), _)) => {\n                                     if ext.helper_attrs.contains(&ident.name) {\n-                                        let binding = (\n-                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                            ty::Visibility::Public,\n+                                        result = ok(\n+                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat),\n                                             derive.span,\n-                                            ExpnId::root(),\n-                                        )\n-                                            .to_name_binding(this.arenas);\n-                                        result = Ok((binding, Flags::DERIVE_HELPER_COMPAT));\n+                                            this.arenas,\n+                                        );\n                                         break;\n                                     }\n                                 }\n@@ -799,17 +809,15 @@ impl<'a> Resolver<'a> {\n                             let (res, innermost_res) = (binding.res(), innermost_binding.res());\n                             if res != innermost_res {\n                                 let builtin = Res::NonMacroAttr(NonMacroAttrKind::Builtin);\n-                                let is_derive_helper_compat = |res, flags: Flags| {\n-                                    res == Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper)\n-                                        && flags.contains(Flags::DERIVE_HELPER_COMPAT)\n-                                };\n+                                let derive_helper_compat =\n+                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n \n                                 let ambiguity_error_kind = if is_import {\n                                     Some(AmbiguityKind::Import)\n                                 } else if innermost_res == builtin || res == builtin {\n                                     Some(AmbiguityKind::BuiltinAttr)\n-                                } else if is_derive_helper_compat(innermost_res, innermost_flags)\n-                                    || is_derive_helper_compat(res, flags)\n+                                } else if innermost_res == derive_helper_compat\n+                                    || res == derive_helper_compat\n                                 {\n                                     Some(AmbiguityKind::DeriveHelper)\n                                 } else if innermost_flags.contains(Flags::MACRO_RULES)"}, {"sha": "df472e6ed7e9d7698fc744efeb0076d500ee6436", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -997,7 +997,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // type.\n                 //\n                 // NOTE: This should be kept in sync with the similar code in\n-                // `rustc_ty::instance::resolve_associated_item()`.\n+                // `rustc_ty_utils::instance::resolve_associated_item()`.\n                 let node_item =\n                     assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n                         .map_err(|ErrorReported| ())?;"}, {"sha": "5020437bcf9cc031351bdef0adb66ddf960c23ab", "filename": "compiler/rustc_ty_utils/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2FCargo.toml?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,6 +1,6 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"rustc_ty\"\n+name = \"rustc_ty_utils\"\n version = \"0.0.0\"\n edition = \"2018\"\n ", "previous_filename": "compiler/rustc_ty/Cargo.toml"}, {"sha": "24ba071786607fc4daa5aa03e0661e8be2ab22c7", "filename": "compiler/rustc_ty_utils/src/common_traits.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "previous_filename": "compiler/rustc_ty/src/common_traits.rs"}, {"sha": "cf2c6efb4711f465d4466cf5a3528579ba1c6e38", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "previous_filename": "compiler/rustc_ty/src/instance.rs"}, {"sha": "904c0062a926fae436baeca592d1db14ecabd351", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "previous_filename": "compiler/rustc_ty/src/lib.rs"}, {"sha": "d62fc764c76d719e5d859f1cddc72e5006a9067c", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "previous_filename": "compiler/rustc_ty/src/needs_drop.rs"}, {"sha": "720ad42da2aaa37d2e0f3ca4bc351c924b3b5a5d", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "previous_filename": "compiler/rustc_ty/src/ty.rs"}, {"sha": "706f865b4d14f1fd9fbe4573dc473a2c3f696876", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -69,7 +69,8 @@ impl<T, const N: usize> IntoIter<T, N> {\n \n     /// Returns an immutable slice of all elements that have not been yielded\n     /// yet.\n-    fn as_slice(&self) -> &[T] {\n+    #[unstable(feature = \"array_value_iter_slice\", issue = \"65798\")]\n+    pub fn as_slice(&self) -> &[T] {\n         // SAFETY: We know that all elements within `alive` are properly initialized.\n         unsafe {\n             let slice = self.data.get_unchecked(self.alive.clone());\n@@ -78,7 +79,8 @@ impl<T, const N: usize> IntoIter<T, N> {\n     }\n \n     /// Returns a mutable slice of all elements that have not been yielded yet.\n-    fn as_mut_slice(&mut self) -> &mut [T] {\n+    #[unstable(feature = \"array_value_iter_slice\", issue = \"65798\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n         // SAFETY: We know that all elements within `alive` are properly initialized.\n         unsafe {\n             let slice = self.data.get_unchecked_mut(self.alive.clone());"}, {"sha": "c50aa18caf69a59acb6a5cc411e7f38070101095", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -2724,6 +2724,7 @@ impl<T> [T] {\n     ///\n     /// [`clone_from_slice`]: #method.clone_from_slice\n     /// [`split_at_mut`]: #method.split_at_mut\n+    #[doc(alias = \"memcpy\")]\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     pub fn copy_from_slice(&mut self, src: &[T])\n     where"}, {"sha": "9d2045990570b5e4a919b27e9435be3aaf5d550e", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -47,9 +47,16 @@\n //!\n //! * PowerPC and MIPS platforms with 32-bit pointers do not have `AtomicU64` or\n //!   `AtomicI64` types.\n-//! * ARM platforms like `armv5te` that aren't for Linux do not have any atomics\n-//!   at all.\n-//! * ARM targets with `thumbv6m` do not have atomic operations at all.\n+//! * ARM platforms like `armv5te` that aren't for Linux only provide `load`\n+//!   and `store` operations, and do not support Compare and Swap (CAS)\n+//!   operations, such as `swap`, `fetch_add`, etc. Additionally on Linux,\n+//!   these CAS operations are implemented via [operating system support], which\n+//!   may come with a performance penalty.\n+//! * ARM targets with `thumbv6m` only provide `load` and `store` operations,\n+//!   and do not support Compare and Swap (CAS) operations, such as `swap`,\n+//!   `fetch_add`, etc.\n+//!\n+//! [operating system support]: https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt\n //!\n //! Note that future platforms may be added that also do not have support for\n //! some atomic operations. Maximally portable code will want to be careful"}, {"sha": "72c0b225991f6bf116a020b6f8edf69d744bad81", "filename": "library/core/tests/num/i128.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fi128.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -0,0 +1 @@\n+int_module!(i128, i128);"}, {"sha": "90c476567844eae873e13efd4dacd8d4091c4bf1", "filename": "library/core/tests/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -131,9 +131,9 @@ macro_rules! int_module {\n                 assert_eq!(B.rotate_left(0), B);\n                 assert_eq!(C.rotate_left(0), C);\n                 // Rotating by a multiple of word size should also have no effect\n-                assert_eq!(A.rotate_left(64), A);\n-                assert_eq!(B.rotate_left(64), B);\n-                assert_eq!(C.rotate_left(64), C);\n+                assert_eq!(A.rotate_left(128), A);\n+                assert_eq!(B.rotate_left(128), B);\n+                assert_eq!(C.rotate_left(128), C);\n             }\n \n             #[test]"}, {"sha": "012ab4ea5c573a669ad352c2320947a273b2f56d", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -11,6 +11,7 @@ use core::str::FromStr;\n #[macro_use]\n mod int_macros;\n \n+mod i128;\n mod i16;\n mod i32;\n mod i64;\n@@ -19,6 +20,7 @@ mod i8;\n #[macro_use]\n mod uint_macros;\n \n+mod u128;\n mod u16;\n mod u32;\n mod u64;"}, {"sha": "716d1836f2c0ef17ef234aed869fd45f0b5df2f9", "filename": "library/core/tests/num/u128.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fu128.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -0,0 +1 @@\n+uint_module!(u128, u128);"}, {"sha": "445f8fb350eebe24db114f45012111427efa29f1", "filename": "library/core/tests/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -96,9 +96,9 @@ macro_rules! uint_module {\n                 assert_eq!(B.rotate_left(0), B);\n                 assert_eq!(C.rotate_left(0), C);\n                 // Rotating by a multiple of word size should also have no effect\n-                assert_eq!(A.rotate_left(64), A);\n-                assert_eq!(B.rotate_left(64), B);\n-                assert_eq!(C.rotate_left(64), C);\n+                assert_eq!(A.rotate_left(128), A);\n+                assert_eq!(B.rotate_left(128), B);\n+                assert_eq!(C.rotate_left(128), C);\n             }\n \n             #[test]"}, {"sha": "e087e2b8ff1531b952c35dcc5a6e7736af7467ad", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -484,10 +484,13 @@ impl Step for CompiletestTest {\n         let host = self.host;\n         let compiler = builder.compiler(0, host);\n \n+        // We need `ToolStd` for the locally-built sysroot because\n+        // compiletest uses unstable features of the `test` crate.\n+        builder.ensure(compile::Std { compiler, target: host });\n         let cargo = tool::prepare_tool_cargo(\n             builder,\n             compiler,\n-            Mode::ToolBootstrap,\n+            Mode::ToolStd,\n             host,\n             \"test\",\n             \"src/tools/compiletest\","}, {"sha": "147a8d33765af4574f391668595a95944e80091f", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1194,6 +1194,16 @@ fn write_minify(\n     }\n }\n \n+fn write_srclink(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n+    if let Some(l) = cx.src_href(item, cache) {\n+        write!(\n+            buf,\n+            \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"{}\\\">[src]</a>\",\n+            l, \"goto source code\"\n+        )\n+    }\n+}\n+\n #[derive(Debug, Eq, PartialEq, Hash)]\n struct ItemEntry {\n     url: String,\n@@ -1706,13 +1716,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache)\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n     if cx.shared.include_sources && !item.is_primitive() {\n-        if let Some(l) = cx.src_href(item, cache) {\n-            write!(\n-                buf,\n-                \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"{}\\\">[src]</a>\",\n-                l, \"goto source code\"\n-            );\n-        }\n+        write_srclink(cx, item, buf, cache);\n     }\n \n     write!(buf, \"</span>\"); // out-of-band\n@@ -2624,7 +2628,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n         write!(w, \"{}<span class=\\\"loading-content\\\">Loading content...</span>\", extra_content)\n     }\n \n-    fn trait_item(w: &mut Buffer, cx: &Context, m: &clean::Item, t: &clean::Item) {\n+    fn trait_item(w: &mut Buffer, cx: &Context, m: &clean::Item, t: &clean::Item, cache: &Cache) {\n         let name = m.name.as_ref().unwrap();\n         info!(\"Documenting {} on {}\", name, t.name.as_deref().unwrap_or_default());\n         let item_type = m.type_();\n@@ -2633,6 +2637,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl);\n         write!(w, \"</code>\");\n         render_stability_since(w, m, t);\n+        write_srclink(cx, m, w, cache);\n         write!(w, \"</h3>\");\n         document(w, cx, m, Some(t));\n     }\n@@ -2644,8 +2649,8 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n             \"Associated Types\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for t in &types {\n-            trait_item(w, cx, *t, it);\n+        for t in types {\n+            trait_item(w, cx, t, it, cache);\n         }\n         write_loading_content(w, \"</div>\");\n     }\n@@ -2657,8 +2662,8 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n             \"Associated Constants\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for t in &consts {\n-            trait_item(w, cx, *t, it);\n+        for t in consts {\n+            trait_item(w, cx, t, it, cache);\n         }\n         write_loading_content(w, \"</div>\");\n     }\n@@ -2671,8 +2676,8 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n             \"Required methods\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for m in &required {\n-            trait_item(w, cx, *m, it);\n+        for m in required {\n+            trait_item(w, cx, m, it, cache);\n         }\n         write_loading_content(w, \"</div>\");\n     }\n@@ -2683,8 +2688,8 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n             \"Provided methods\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for m in &provided {\n-            trait_item(w, cx, *m, it);\n+        for m in provided {\n+            trait_item(w, cx, m, it, cache);\n         }\n         write_loading_content(w, \"</div>\");\n     }\n@@ -3693,13 +3698,7 @@ fn render_impl(\n             StabilityLevel::Unstable { .. } => None,\n         });\n         render_stability_since_raw(w, since.as_deref(), outer_version);\n-        if let Some(l) = cx.src_href(&i.impl_item, cache) {\n-            write!(\n-                w,\n-                \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"{}\\\">[src]</a>\",\n-                l, \"goto source code\"\n-            );\n-        }\n+        write_srclink(cx, &i.impl_item, w, cache);\n         write!(w, \"</h3>\");\n \n         if trait_.is_some() {\n@@ -3765,13 +3764,7 @@ fn render_impl(\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n                     write!(w, \"</code>\");\n                     render_stability_since_raw(w, item.stable_since().as_deref(), outer_version);\n-                    if let Some(l) = cx.src_href(item, cache) {\n-                        write!(\n-                            w,\n-                            \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"{}\\\">[src]</a>\",\n-                            l, \"goto source code\"\n-                        );\n-                    }\n+                    write_srclink(cx, item, w, cache);\n                     write!(w, \"</h4>\");\n                 }\n             }\n@@ -3787,13 +3780,7 @@ fn render_impl(\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\");\n                 write!(w, \"</code>\");\n                 render_stability_since_raw(w, item.stable_since().as_deref(), outer_version);\n-                if let Some(l) = cx.src_href(item, cache) {\n-                    write!(\n-                        w,\n-                        \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"{}\\\">[src]</a>\",\n-                        l, \"goto source code\"\n-                    );\n-                }\n+                write_srclink(cx, item, w, cache);\n                 write!(w, \"</h4>\");\n             }\n             clean::AssocTypeItem(ref bounds, ref default) => {"}, {"sha": "7d22913b99de909028c83571a3324e0efff4ac11", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -659,7 +659,7 @@ a {\n \ttext-decoration: underline;\n }\n \n-.invisible > .srclink, h4 > code + .srclink {\n+.invisible > .srclink, h4 > code + .srclink, h3 > code + .srclink {\n \tposition: absolute;\n \ttop: 0;\n \tright: 0;\n@@ -857,25 +857,25 @@ body.blur > :not(#help) {\n \ttop: 0;\n }\n \n-.impl-items .since, .impl .since {\n+.impl-items .since, .impl .since, .methods .since {\n \tflex-grow: 0;\n \tpadding-left: 12px;\n \tpadding-right: 2px;\n \tposition: initial;\n }\n \n-.impl-items .srclink, .impl .srclink {\n+.impl-items .srclink, .impl .srclink, .methods .srclink {\n \tflex-grow: 0;\n \t/* Override header settings otherwise it's too bold */\n \tfont-size: 17px;\n \tfont-weight: normal;\n }\n \n-.impl-items code, .impl code {\n+.impl-items code, .impl code, .methods code {\n \tflex-grow: 1;\n }\n \n-.impl-items h4, h4.impl, h3.impl {\n+.impl-items h4, h4.impl, h3.impl, .methods h3 {\n \tdisplay: flex;\n \tflex-basis: 100%;\n \tfont-size: 16px;"}, {"sha": "77116695690fc75366d3ef4ddbf62b28a70bf10a", "filename": "src/test/rustdoc/trait-src-link.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Frustdoc%2Ftrait-src-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Frustdoc%2Ftrait-src-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftrait-src-link.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -0,0 +1,26 @@\n+#![crate_name = \"quix\"]\n+pub trait Foo {\n+    // @has quix/trait.Foo.html '//a[@href=\"../src/quix/trait-src-link.rs.html#4\"]' '[src]'\n+    fn required();\n+\n+    // @has quix/trait.Foo.html '//a[@href=\"../src/quix/trait-src-link.rs.html#7\"]' '[src]'\n+    fn provided() {}\n+}\n+\n+pub struct Bar;\n+\n+impl Foo for Bar {\n+    // @has quix/struct.Bar.html '//a[@href=\"../src/quix/trait-src-link.rs.html#14\"]' '[src]'\n+    fn required() {}\n+    // @has quix/struct.Bar.html '//a[@href=\"../src/quix/trait-src-link.rs.html#7\"]' '[src]'\n+}\n+\n+pub struct Baz;\n+\n+impl Foo for Baz {\n+    // @has quix/struct.Baz.html '//a[@href=\"../src/quix/trait-src-link.rs.html#22\"]' '[src]'\n+    fn required() {}\n+\n+    // @has quix/struct.Baz.html '//a[@href=\"../src/quix/trait-src-link.rs.html#25\"]' '[src]'\n+    fn provided() {}\n+}"}, {"sha": "8770fb1ded8eba4214175209601c9a9e18494e40", "filename": "src/test/ui/attrs-resolution-errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fattrs-resolution-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fattrs-resolution-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattrs-resolution-errors.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,12 +1,12 @@\n enum FooEnum {\n     #[test]\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     Bar(i32),\n }\n \n struct FooStruct {\n     #[test]\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     bar: i32,\n }\n \n@@ -21,20 +21,20 @@ fn main() {\n     match foo_struct {\n         FooStruct {\n             #[test] bar\n-            //~^ ERROR expected an inert attribute, found an attribute macro\n+            //~^ ERROR expected non-macro attribute, found attribute macro\n         } => {}\n     }\n \n     match 1 {\n         0 => {}\n         #[test]\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         _ => {}\n     }\n \n     let _another_foo_strunct = FooStruct {\n         #[test]\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         bar: 1,\n     };\n }"}, {"sha": "883f96e5c193163ac2311d5bfbf1e41be3ad8729", "filename": "src/test/ui/attrs-resolution-errors.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fattrs-resolution-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fattrs-resolution-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattrs-resolution-errors.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,32 +1,32 @@\n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:2:5\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:2:7\n    |\n LL |     #[test]\n-   |     ^^^^^^^\n+   |       ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:8:5\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:8:7\n    |\n LL |     #[test]\n-   |     ^^^^^^^\n+   |       ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:23:13\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:23:15\n    |\n LL |             #[test] bar\n-   |             ^^^^^^^\n+   |               ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:30:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:30:11\n    |\n LL |         #[test]\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:36:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:36:11\n    |\n LL |         #[test]\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n error: aborting due to 5 previous errors\n "}, {"sha": "50504a44c95183b78de472e16b1bd886fb5869ed", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,6 +1,6 @@\n #![feature(cfg_accessible)]\n \n-#[cfg_accessible(Z)] //~ ERROR cannot determine whether the path is accessible or not\n+#[cfg_accessible(Z)] // OK, recovered after the other `cfg_accessible` produces an error.\n struct S;\n \n #[cfg_accessible(S)] //~ ERROR cannot determine whether the path is accessible or not"}, {"sha": "33af7d62548ec2687b4bb0bb58459f0df6a86763", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -4,11 +4,5 @@ error: cannot determine whether the path is accessible or not\n LL | #[cfg_accessible(S)]\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: cannot determine whether the path is accessible or not\n-  --> $DIR/cfg_accessible-stuck.rs:3:1\n-   |\n-LL | #[cfg_accessible(Z)]\n-   | ^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "d06b31c7f270224d66628222b9dd9e3603ca85fe", "filename": "src/test/ui/destructuring-assignment/drop-order.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdrop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdrop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fdrop-order.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -0,0 +1,44 @@\n+// run-pass\n+\n+//! Test that let bindings and destructuring assignments have consistent drop orders\n+\n+#![feature(destructuring_assignment)]\n+#![allow(unused_variables, unused_assignments)]\n+\n+use std::cell::RefCell;\n+\n+thread_local! {\n+    static DROP_ORDER: RefCell<Vec<usize>> = RefCell::new(Vec::new());\n+}\n+\n+struct DropRecorder(usize);\n+impl Drop for DropRecorder {\n+    fn drop(&mut self) {\n+        DROP_ORDER.with(|d| d.borrow_mut().push(self.0));\n+    }\n+}\n+\n+fn main() {\n+    let expected_drop_order = vec![1, 4, 5, 3, 2];\n+    // Check the drop order for let bindings:\n+    {\n+        let _ = DropRecorder(1);\n+        let _val = DropRecorder(2);\n+        let (x, _) = (DropRecorder(3), DropRecorder(4));\n+        drop(DropRecorder(5));\n+    }\n+    DROP_ORDER.with(|d| {\n+        assert_eq!(&*d.borrow(), &expected_drop_order);\n+        d.borrow_mut().clear();\n+    });\n+    // Check that the drop order for destructuring assignment is the same:\n+    {\n+        let _val;\n+        let x;\n+        _ = DropRecorder(1);\n+        _val = DropRecorder(2);\n+        (x, _) = (DropRecorder(3), DropRecorder(4));\n+        drop(DropRecorder(5));\n+    }\n+    DROP_ORDER.with(|d| assert_eq!(&*d.borrow(), &expected_drop_order));\n+}"}, {"sha": "1102f3c4640a188a3b0adb5785b4a11cc25cdb60", "filename": "src/test/ui/issues/issue-36617.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,5 +1,4 @@\n #![derive(Copy)] //~ ERROR `derive` may only be applied to structs, enums and unions\n                  //~| ERROR cannot determine resolution for the derive macro `Copy`\n-                 //~| ERROR cannot determine resolution for the derive macro `Copy`\n \n fn main() {}"}, {"sha": "dc6ef1692591382f51290e50c1d22e05a9acd775", "filename": "src/test/ui/issues/issue-36617.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -12,14 +12,6 @@ LL | #![derive(Copy)]\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: cannot determine resolution for the derive macro `Copy`\n-  --> $DIR/issue-36617.rs:1:11\n-   |\n-LL | #![derive(Copy)]\n-   |           ^^^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0774`."}, {"sha": "bf95f8fa7e1ec8fbcfb388efed713b96be520c49", "filename": "src/test/ui/issues/issue-49934-errors.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,10 +1,8 @@\n fn foo<#[derive(Debug)] T>() {\n //~^ ERROR `derive` may only be applied to structs, enums and unions\n-//~| ERROR expected an inert attribute, found a derive macro\n     match 0 {\n         #[derive(Debug)]\n         //~^ ERROR `derive` may only be applied to structs, enums and unions\n-        //~| ERROR expected an inert attribute, found a derive macro\n         _ => (),\n     }\n }"}, {"sha": "71cd2d30342438c5a713e5bbf3b84669c7bd0ab8", "filename": "src/test/ui/issues/issue-49934-errors.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -4,24 +4,12 @@ error[E0774]: `derive` may only be applied to structs, enums and unions\n LL | fn foo<#[derive(Debug)] T>() {\n    |        ^^^^^^^^^^^^^^^^\n \n-error: expected an inert attribute, found a derive macro\n-  --> $DIR/issue-49934-errors.rs:1:17\n-   |\n-LL | fn foo<#[derive(Debug)] T>() {\n-   |                 ^^^^^\n-\n error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-49934-errors.rs:5:9\n+  --> $DIR/issue-49934-errors.rs:4:9\n    |\n LL |         #[derive(Debug)]\n    |         ^^^^^^^^^^^^^^^^\n \n-error: expected an inert attribute, found a derive macro\n-  --> $DIR/issue-49934-errors.rs:5:18\n-   |\n-LL |         #[derive(Debug)]\n-   |                  ^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0774`."}, {"sha": "fb4bf2b8b44e7642e5f68244b9057cd2234e4f8f", "filename": "src/test/ui/issues/issue-50865-private-impl-trait/auxiliary/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-50865-private-impl-trait%2Fauxiliary%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fissues%2Fissue-50865-private-impl-trait%2Fauxiliary%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50865-private-impl-trait%2Fauxiliary%2Flib.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,3 +1,7 @@\n+// revisions: default miropt\n+//[miropt]compile-flags: -Z mir-opt-level=2\n+// ~^ This flag is for #77668, it used to be ICE.\n+\n #![crate_type = \"lib\"]\n \n pub fn bar<P>( // Error won't happen if \"bar\" is not generic"}, {"sha": "1fd7cddc7c937b6c007396d9271938494af6a145", "filename": "src/test/ui/malformed/issue-69341-malformed-derive-inert.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -4,7 +4,6 @@ struct CLI {\n     #[derive(parse())]\n     //~^ ERROR traits in `#[derive(...)]` don't accept arguments\n     //~| ERROR cannot find derive macro `parse` in this scope\n-    //~| ERROR cannot find derive macro `parse` in this scope\n     path: (),\n     //~^ ERROR `derive` may only be applied to structs, enums and unions\n }"}, {"sha": "db40ce07530450db1c91cd47642a21dae4d26873", "filename": "src/test/ui/malformed/issue-69341-malformed-derive-inert.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -5,7 +5,7 @@ LL |     #[derive(parse())]\n    |                   ^^ help: remove the arguments\n \n error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-69341-malformed-derive-inert.rs:8:5\n+  --> $DIR/issue-69341-malformed-derive-inert.rs:7:5\n    |\n LL |     path: (),\n    |     ^^^^^^^^\n@@ -16,12 +16,6 @@ error: cannot find derive macro `parse` in this scope\n LL |     #[derive(parse())]\n    |              ^^^^^\n \n-error: cannot find derive macro `parse` in this scope\n-  --> $DIR/issue-69341-malformed-derive-inert.rs:4:14\n-   |\n-LL |     #[derive(parse())]\n-   |              ^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0774`."}, {"sha": "4d083bf23215599a16ecf1c8f16cabcf6a678488", "filename": "src/test/ui/mir/mir-inlining/ice-issue-77306-1.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-77306-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-77306-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-77306-1.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,27 +1,17 @@\n-// Regression test for various issues related to normalization & inlining.\n-// * #68347, #77306, #77668 - missed normalization during inlining.\n-// * #78442 - missed normalization in validator after inlining.\n-//\n-// build-pass\n+// run-pass\n // compile-flags:-Zmir-opt-level=2\n \n+// Previously ICEd because we did not normalize during inlining,\n+// see https://github.com/rust-lang/rust/pull/77306 for more discussion.\n+\n pub fn write() {\n     create()()\n }\n \n-pub fn write_generic<T>(_t: T) {\n-    hide()();\n-}\n-\n pub fn create() -> impl FnOnce() {\n    || ()\n }\n \n-pub fn hide() -> impl Fn() {\n-    write\n-}\n-\n fn main() {\n     write();\n-    write_generic(());\n }"}, {"sha": "4c72ecbfc03a8b109178df6439fba627802ecab4", "filename": "src/test/ui/proc-macro/proc-macro-gates.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -7,11 +7,11 @@\n extern crate test_macros;\n \n fn _test_inner() {\n-    #![empty_attr] //~ ERROR: non-builtin inner attributes are unstable\n+    #![empty_attr] //~ ERROR: inner macro attributes are unstable\n }\n \n mod _test2_inner {\n-    #![empty_attr] //~ ERROR: non-builtin inner attributes are unstable\n+    #![empty_attr] //~ ERROR: inner macro attributes are unstable\n }\n \n #[empty_attr = \"y\"] //~ ERROR: key-value macro attributes are not supported"}, {"sha": "33a808037eea56d1fff6ad1c97bcf2914cce7ee2", "filename": "src/test/ui/proc-macro/proc-macro-gates.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,17 +1,17 @@\n-error[E0658]: non-builtin inner attributes are unstable\n-  --> $DIR/proc-macro-gates.rs:10:5\n+error[E0658]: inner macro attributes are unstable\n+  --> $DIR/proc-macro-gates.rs:10:8\n    |\n LL |     #![empty_attr]\n-   |     ^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^\n    |\n    = note: see issue #54726 <https://github.com/rust-lang/rust/issues/54726> for more information\n    = help: add `#![feature(custom_inner_attributes)]` to the crate attributes to enable\n \n-error[E0658]: non-builtin inner attributes are unstable\n-  --> $DIR/proc-macro-gates.rs:14:5\n+error[E0658]: inner macro attributes are unstable\n+  --> $DIR/proc-macro-gates.rs:14:8\n    |\n LL |     #![empty_attr]\n-   |     ^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^\n    |\n    = note: see issue #54726 <https://github.com/rust-lang/rust/issues/54726> for more information\n    = help: add `#![feature(custom_inner_attributes)]` to the crate attributes to enable"}, {"sha": "38fbd4733d5cbe8a59935fc003fe3d6d750af12b", "filename": "src/test/ui/proc-macro/proc-macro-gates2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -10,11 +10,11 @@ extern crate test_macros;\n // should either require a feature gate or not be allowed on stable.\n \n fn _test6<#[empty_attr] T>() {}\n-//~^ ERROR: expected an inert attribute, found an attribute macro\n+//~^ ERROR: expected non-macro attribute, found attribute macro\n \n fn _test7() {\n     match 1 {\n-        #[empty_attr] //~ ERROR: expected an inert attribute, found an attribute macro\n+        #[empty_attr] //~ ERROR: expected non-macro attribute, found attribute macro\n         0 => {}\n         _ => {}\n     }"}, {"sha": "64df34e7ce390b1a581beaa1f7c75c18cca3f0eb", "filename": "src/test/ui/proc-macro/proc-macro-gates2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,14 +1,14 @@\n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-gates2.rs:12:11\n+error: expected non-macro attribute, found attribute macro `empty_attr`\n+  --> $DIR/proc-macro-gates2.rs:12:13\n    |\n LL | fn _test6<#[empty_attr] T>() {}\n-   |           ^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-gates2.rs:17:9\n+error: expected non-macro attribute, found attribute macro `empty_attr`\n+  --> $DIR/proc-macro-gates2.rs:17:11\n    |\n LL |         #[empty_attr]\n-   |         ^^^^^^^^^^^^^\n+   |           ^^^^^^^^^^ not a non-macro attribute\n \n error: aborting due to 2 previous errors\n "}, {"sha": "6403b3f55c40ccf714e927b592ae41bd44dfbe12", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-builtin-attrs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -3,7 +3,7 @@ extern \"C\" {\n         /// Foo\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -19,7 +19,7 @@ type FnType = fn(\n     /// Foo\n     //~^ ERROR documentation comments cannot be applied to function\n     #[test] a: u32,\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     /// Bar\n     //~^ ERROR documentation comments cannot be applied to function\n     #[must_use]\n@@ -34,7 +34,7 @@ pub fn foo(\n     /// Foo\n     //~^ ERROR documentation comments cannot be applied to function\n     #[test] a: u32,\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     /// Bar\n     //~^ ERROR documentation comments cannot be applied to function\n     #[must_use]\n@@ -54,7 +54,7 @@ impl SelfStruct {\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -69,7 +69,7 @@ impl SelfStruct {\n         /// Foo\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -90,7 +90,7 @@ impl RefStruct {\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -109,7 +109,7 @@ trait RefTrait {\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -124,7 +124,7 @@ trait RefTrait {\n         /// Foo\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -144,7 +144,7 @@ impl RefTrait for RefStruct {\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -161,7 +161,7 @@ fn main() {\n         /// Foo\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: u32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]"}, {"sha": "edca8cea68d72a9cc7c8d56d27a8d26b6f5891fe", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-builtin-attrs.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,62 +1,62 @@\n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:5:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:5:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:21:5\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:21:7\n    |\n LL |     #[test] a: u32,\n-   |     ^^^^^^^\n+   |       ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:36:5\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:36:7\n    |\n LL |     #[test] a: u32,\n-   |     ^^^^^^^\n+   |       ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:56:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:56:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:71:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:71:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:92:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:92:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:111:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:111:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:126:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:126:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:146:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:146:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:163:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:163:11\n    |\n LL |         #[test] a: u32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n error: documentation comments cannot be applied to function parameters\n   --> $DIR/param-attrs-builtin-attrs.rs:3:9"}, {"sha": "fcfa610ec8554e438e833c0589c15c810a08cc60", "filename": "src/test/ui/rfc-2565-param-attrs/proc-macro-cannot-be-used.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -8,58 +8,58 @@ use ident_mac::id;\n struct W(u8);\n \n extern \"C\" { fn ffi(#[id] arg1: i32, #[id] ...); }\n-//~^ ERROR expected an inert attribute, found an attribute macro\n-//~| ERROR expected an inert attribute, found an attribute macro\n+//~^ ERROR expected non-macro attribute, found attribute macro\n+//~| ERROR expected non-macro attribute, found attribute macro\n \n unsafe extern \"C\" fn cvar(arg1: i32, #[id] mut args: ...) {}\n-//~^ ERROR expected an inert attribute, found an attribute macro\n+//~^ ERROR expected non-macro attribute, found attribute macro\n \n type Alias = extern \"C\" fn(#[id] u8, #[id] ...);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n \n fn free(#[id] arg1: u8) {\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     let lam = |#[id] W(x), #[id] y: usize| ();\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n }\n \n impl W {\n     fn inherent1(#[id] self, #[id] arg1: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn inherent2(#[id] &self, #[id] arg1: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn inherent3<'a>(#[id] &'a mut self, #[id] arg1: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn inherent4<'a>(#[id] self: Box<Self>, #[id] arg1: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n }\n \n trait A {\n     fn trait1(#[id] self, #[id] arg1: u8);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn trait2(#[id] &self, #[id] arg1: u8);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn trait3<'a>(#[id] &'a mut self, #[id] arg1: u8);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn trait4<'a>(#[id] self: Box<Self>, #[id] arg1: u8, #[id] Vec<u8>);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n }\n \n fn main() {}"}, {"sha": "38c5050f3428dd932e2cd9e30bdf6b3c3573e121", "filename": "src/test/ui/rfc-2565-param-attrs/proc-macro-cannot-be-used.stderr", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,176 +1,176 @@\n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:10:21\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:10:23\n    |\n LL | extern \"C\" { fn ffi(#[id] arg1: i32, #[id] ...); }\n-   |                     ^^^^^\n+   |                       ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:10:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:10:40\n    |\n LL | extern \"C\" { fn ffi(#[id] arg1: i32, #[id] ...); }\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:14:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:14:40\n    |\n LL | unsafe extern \"C\" fn cvar(arg1: i32, #[id] mut args: ...) {}\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:17:28\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:17:30\n    |\n LL | type Alias = extern \"C\" fn(#[id] u8, #[id] ...);\n-   |                            ^^^^^\n+   |                              ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:17:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:17:40\n    |\n LL | type Alias = extern \"C\" fn(#[id] u8, #[id] ...);\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:21:9\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:21:11\n    |\n LL | fn free(#[id] arg1: u8) {\n-   |         ^^^^^\n+   |           ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:23:16\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:23:18\n    |\n LL |     let lam = |#[id] W(x), #[id] y: usize| ();\n-   |                ^^^^^\n+   |                  ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:23:28\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:23:30\n    |\n LL |     let lam = |#[id] W(x), #[id] y: usize| ();\n-   |                            ^^^^^\n+   |                              ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:29:18\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:29:20\n    |\n LL |     fn inherent1(#[id] self, #[id] arg1: u8) {}\n-   |                  ^^^^^\n+   |                    ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:29:30\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:29:32\n    |\n LL |     fn inherent1(#[id] self, #[id] arg1: u8) {}\n-   |                              ^^^^^\n+   |                                ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:32:18\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:32:20\n    |\n LL |     fn inherent2(#[id] &self, #[id] arg1: u8) {}\n-   |                  ^^^^^\n+   |                    ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:32:31\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:32:33\n    |\n LL |     fn inherent2(#[id] &self, #[id] arg1: u8) {}\n-   |                               ^^^^^\n+   |                                 ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:35:22\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:35:24\n    |\n LL |     fn inherent3<'a>(#[id] &'a mut self, #[id] arg1: u8) {}\n-   |                      ^^^^^\n+   |                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:35:42\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:35:44\n    |\n LL |     fn inherent3<'a>(#[id] &'a mut self, #[id] arg1: u8) {}\n-   |                                          ^^^^^\n+   |                                            ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:38:22\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:38:24\n    |\n LL |     fn inherent4<'a>(#[id] self: Box<Self>, #[id] arg1: u8) {}\n-   |                      ^^^^^\n+   |                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:38:45\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:38:47\n    |\n LL |     fn inherent4<'a>(#[id] self: Box<Self>, #[id] arg1: u8) {}\n-   |                                             ^^^^^\n+   |                                               ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:41:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:41:40\n    |\n LL |     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8) {}\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:41:54\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:41:56\n    |\n LL |     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8) {}\n-   |                                                      ^^^^^\n+   |                                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:47:15\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:47:17\n    |\n LL |     fn trait1(#[id] self, #[id] arg1: u8);\n-   |               ^^^^^\n+   |                 ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:47:27\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:47:29\n    |\n LL |     fn trait1(#[id] self, #[id] arg1: u8);\n-   |                           ^^^^^\n+   |                             ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:50:15\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:50:17\n    |\n LL |     fn trait2(#[id] &self, #[id] arg1: u8);\n-   |               ^^^^^\n+   |                 ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:50:28\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:50:30\n    |\n LL |     fn trait2(#[id] &self, #[id] arg1: u8);\n-   |                            ^^^^^\n+   |                              ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:53:19\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:53:21\n    |\n LL |     fn trait3<'a>(#[id] &'a mut self, #[id] arg1: u8);\n-   |                   ^^^^^\n+   |                     ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:53:39\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:53:41\n    |\n LL |     fn trait3<'a>(#[id] &'a mut self, #[id] arg1: u8);\n-   |                                       ^^^^^\n+   |                                         ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:56:19\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:56:21\n    |\n LL |     fn trait4<'a>(#[id] self: Box<Self>, #[id] arg1: u8, #[id] Vec<u8>);\n-   |                   ^^^^^\n+   |                     ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:56:42\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:56:44\n    |\n LL |     fn trait4<'a>(#[id] self: Box<Self>, #[id] arg1: u8, #[id] Vec<u8>);\n-   |                                          ^^^^^\n+   |                                            ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:56:58\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:56:60\n    |\n LL |     fn trait4<'a>(#[id] self: Box<Self>, #[id] arg1: u8, #[id] Vec<u8>);\n-   |                                                          ^^^^^\n+   |                                                            ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:60:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:60:40\n    |\n LL |     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8);\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:60:54\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:60:56\n    |\n LL |     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8);\n-   |                                                      ^^^^^\n+   |                                                        ^^ not a non-macro attribute\n \n error: aborting due to 29 previous errors\n "}, {"sha": "70e04bf7ee6e81216918bf504e5925ef0596fb1d", "filename": "src/test/ui/span/issue-36530.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -6,7 +6,7 @@\n \n #[foo]\n mod foo {\n-    #![foo] //~ ERROR non-builtin inner attributes are unstable\n+    #![foo] //~ ERROR custom inner attributes are unstable\n }\n \n fn main() {}"}, {"sha": "a998d7217a13f563322a74698f5f29addd1c408c", "filename": "src/test/ui/span/issue-36530.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -1,8 +1,8 @@\n-error[E0658]: non-builtin inner attributes are unstable\n-  --> $DIR/issue-36530.rs:9:5\n+error[E0658]: custom inner attributes are unstable\n+  --> $DIR/issue-36530.rs:9:8\n    |\n LL |     #![foo]\n-   |     ^^^^^^^\n+   |        ^^^\n    |\n    = note: see issue #54726 <https://github.com/rust-lang/rust/issues/54726> for more information\n    = help: add `#![feature(custom_inner_attributes)]` to the crate attributes to enable"}, {"sha": "8f1599a5abcb0fbf98e965e8cf84dcff70d9f108", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -5,9 +5,6 @@\n //~| ERROR cannot determine resolution for the derive macro `Debug`\n //~| ERROR cannot determine resolution for the derive macro `PartialEq`\n //~| ERROR cannot determine resolution for the derive macro `Eq`\n-//~| ERROR cannot determine resolution for the derive macro `Debug`\n-//~| ERROR cannot determine resolution for the derive macro `PartialEq`\n-//~| ERROR cannot determine resolution for the derive macro `Eq`\n struct DerivedOn;\n \n fn main() {}"}, {"sha": "85beac535c965616031408ae8c2d8b1938fc992e", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.stderr", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr?ref=4ec27e4b79891b0ebc2ad71a3c4ac94f67d93f93", "patch": "@@ -28,30 +28,6 @@ LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: cannot determine resolution for the derive macro `Eq`\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:29\n-   |\n-LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   |                             ^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: cannot determine resolution for the derive macro `PartialEq`\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:18\n-   |\n-LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   |                  ^^^^^^^^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: cannot determine resolution for the derive macro `Debug`\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:11\n-   |\n-LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   |           ^^^^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0774`."}]}