{"sha": "ff5a245f52813d4d876f283b0dffa3674e9210b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNWEyNDVmNTI4MTNkNGQ4NzZmMjgzYjBkZmZhMzY3NGU5MjEwYjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-02T15:02:58Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T11:08:00Z"}, "message": "check that entire ref is in-bounds before recursing; add macro for validation msgs on error", "tree": {"sha": "4d27386e05eb512770b94937320b49fe9a870255", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d27386e05eb512770b94937320b49fe9a870255"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff5a245f52813d4d876f283b0dffa3674e9210b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff5a245f52813d4d876f283b0dffa3674e9210b1", "html_url": "https://github.com/rust-lang/rust/commit/ff5a245f52813d4d876f283b0dffa3674e9210b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff5a245f52813d4d876f283b0dffa3674e9210b1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa", "html_url": "https://github.com/rust-lang/rust/commit/bf5e6ebdd3e1d54d210ff0285058ffa0979b9baa"}], "stats": {"total": 182, "additions": 86, "deletions": 96}, "files": [{"sha": "1b75982a83a575c78c03cb92d6c825862f5074d4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ff5a245f52813d4d876f283b0dffa3674e9210b1", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// If you want to check bounds before doing a memory access, be sure to\n     /// check the pointer one past the end of your access, then everything will\n     /// work out exactly.\n-    pub fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n+    pub fn check_bounds_ptr(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset.bytes() > allocation_size {\n@@ -296,6 +296,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         Ok(())\n     }\n+\n+    /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n+    #[inline(always)]\n+    pub fn check_bounds(&self, ptr: Pointer, size: Size, access: bool) -> EvalResult<'tcx> {\n+        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds_ptr(ptr.offset(size, &*self)?, access)\n+    }\n }\n \n /// Allocation accessors\n@@ -524,8 +531,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds(ptr.offset(size, &*self)?, true)?;\n+        self.check_bounds(ptr, size, true)?;\n \n         if check_defined_and_ptr {\n             self.check_defined(ptr, size)?;\n@@ -569,8 +575,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds(ptr.offset(size, &self)?, true)?;\n+        self.check_bounds(ptr, size, true)?;\n \n         self.mark_definedness(ptr, size, true)?;\n         self.clear_relocations(ptr, size)?;"}, {"sha": "44faa45d19113762dc8ba2acb55ae95de7287707", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 40, "deletions": 76, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=ff5a245f52813d4d876f283b0dffa3674e9210b1", "patch": "@@ -22,7 +22,7 @@ use super::{\n     OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef\n };\n \n-macro_rules! validation_failure{\n+macro_rules! validation_failure {\n     ($what:expr, $where:expr, $details:expr) => {{\n         let where_ = path_format($where);\n         let where_ = if where_.is_empty() {\n@@ -49,6 +49,15 @@ macro_rules! validation_failure{\n     }};\n }\n \n+macro_rules! try_validation {\n+    ($e:expr, $what:expr, $where:expr) => {{\n+        match $e {\n+            Ok(x) => x,\n+            Err(_) => return validation_failure!($what, $where),\n+        }\n+    }}\n+}\n+\n /// We want to show a nice path to the invalid field for diagnotsics,\n /// but avoid string operations in the happy case where no error happens.\n /// So we track a `Vec<PathElem>` where `PathElem` contains all the data we\n@@ -230,8 +239,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         path: &mut Vec<PathElem>,\n         ref_tracking: Option<&mut RefTracking<'tcx>>,\n     ) -> EvalResult<'tcx> {\n-        // Skip recursion for some external statics\n-        if let Scalar::Ptr(ptr) = place.ptr {\n+        // Before we do anything else, make sure this is entirely in-bounds.\n+        if !place.layout.is_zst() {\n+            let ptr = try_validation!(place.ptr.to_ptr(),\n+                \"integer pointer in non-ZST reference\", path);\n+            let size = self.size_and_align_of(place.extra, place.layout)?.0;\n+            try_validation!(self.memory.check_bounds(ptr, size, false),\n+                \"dangling reference (not entirely in bounds)\", path);\n+            // Skip recursion for some external statics\n             let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n             if let Some(AllocType::Static(did)) = alloc_kind {\n                 // statics from other crates are already checked.\n@@ -257,7 +272,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(())\n     }\n \n-    /// This function checks the data at `op`.\n+    /// This function checks the data at `op`.  `op` is assumed to cover valid memory if it\n+    /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     /// The `path` may be pushed to, but the part that is present when the function\n     /// starts must not be changed!\n@@ -305,13 +321,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let dest = match dest.layout.ty.sty {\n                     ty::Dynamic(..) => {\n                         let dest = dest.to_mem_place(); // immediate trait objects are not a thing\n-                        match self.unpack_dyn_trait(dest) {\n-                            Ok(res) => res.1.into(),\n-                            Err(_) =>\n-                                return validation_failure!(\n-                                    \"invalid vtable in fat pointer\", path\n-                                ),\n-                        }\n+                        try_validation!(self.unpack_dyn_trait(dest),\n+                            \"invalid vtable in fat pointer\", path).1.into()\n                     }\n                     _ => dest\n                 };\n@@ -337,20 +348,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // expectation.\n                     layout::Abi::Scalar(ref scalar_layout) => {\n                         let size = scalar_layout.value.size(self);\n-                        let value = match self.read_value(dest) {\n-                            Ok(val) => val,\n-                            Err(err) => match err.kind {\n-                                EvalErrorKind::PointerOutOfBounds { .. } |\n-                                EvalErrorKind::ReadUndefBytes(_) =>\n-                                    return validation_failure!(\n-                                        \"uninitialized or out-of-bounds memory\", path\n-                                    ),\n-                                _ =>\n-                                    return validation_failure!(\n-                                        \"unrepresentable data\", path\n-                                    ),\n-                            }\n-                        };\n+                        let value = try_validation!(self.read_value(dest),\n+                            \"uninitialized or unrepresentable data\", path);\n                         let scalar = value.to_scalar_or_undef();\n                         self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n                         // Recursively check *safe* references\n@@ -367,35 +366,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 if dest.layout.ty.builtin_deref(true).is_some() =>\n             {\n                 // This is a fat pointer.\n-                let ptr = match self.read_value(dest.into())\n-                    .and_then(|val| self.ref_to_mplace(val))\n-                {\n-                    Ok(ptr) => ptr,\n-                    Err(_) =>\n-                        return validation_failure!(\n-                            \"undefined location or metadata in fat pointer\", path\n-                        ),\n-                };\n+                let ptr = try_validation!(self.read_value(dest.into()),\n+                    \"undefined location in fat pointer\", path);\n+                let ptr = try_validation!(self.ref_to_mplace(ptr),\n+                    \"undefined metadata in fat pointer\", path);\n                 // check metadata early, for better diagnostics\n                 match self.tcx.struct_tail(ptr.layout.ty).sty {\n                     ty::Dynamic(..) => {\n-                        match ptr.extra.unwrap().to_ptr() {\n-                            Ok(_) => {},\n-                            Err(_) =>\n-                                return validation_failure!(\n-                                    \"non-pointer vtable in fat pointer\", path\n-                                ),\n-                        }\n+                        let vtable = try_validation!(ptr.extra.unwrap().to_ptr(),\n+                            \"non-pointer vtable in fat pointer\", path);\n+                        try_validation!(self.read_drop_type_from_vtable(vtable),\n+                            \"invalid drop fn in vtable\", path);\n+                        try_validation!(self.read_size_and_align_from_vtable(vtable),\n+                            \"invalid size or align in vtable\", path);\n                         // FIXME: More checks for the vtable.\n                     }\n                     ty::Slice(..) | ty::Str => {\n-                        match ptr.extra.unwrap().to_usize(self) {\n-                            Ok(_) => {},\n-                            Err(_) =>\n-                                return validation_failure!(\n-                                    \"non-integer slice length in fat pointer\", path\n-                                ),\n-                        }\n+                        try_validation!(ptr.extra.unwrap().to_usize(self),\n+                            \"non-integer slice length in fat pointer\", path);\n                     }\n                     _ =>\n                         bug!(\"Unexpected unsized type tail: {:?}\",\n@@ -418,23 +406,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 match dest.layout.ty.sty {\n                     // Special handling for strings to verify UTF-8\n                     ty::Str => {\n-                        match self.read_str(dest) {\n-                            Ok(_) => {},\n-                            Err(err) => match err.kind {\n-                                EvalErrorKind::PointerOutOfBounds { .. } |\n-                                EvalErrorKind::ReadUndefBytes(_) =>\n-                                    // The error here looks slightly different than it does\n-                                    // for slices, because we do not report the index into the\n-                                    // str at which we are OOB.\n-                                    return validation_failure!(\n-                                        \"uninitialized or out-of-bounds memory\", path\n-                                    ),\n-                                _ =>\n-                                    return validation_failure!(\n-                                        \"non-UTF-8 data in str\", path\n-                                    ),\n-                            }\n-                        }\n+                        try_validation!(self.read_str(dest),\n+                            \"uninitialized or non-UTF-8 data in str\", path);\n                     }\n                     // Special handling for arrays/slices of builtin integer types\n                     ty::Array(tys, ..) | ty::Slice(tys) if {\n@@ -470,18 +443,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                                             \"undefined bytes\", path\n                                         )\n                                     },\n-                                    EvalErrorKind::PointerOutOfBounds { allocation_size, .. } => {\n-                                        // If the array access is out-of-bounds, the first\n-                                        // undefined access is the after the end of the array.\n-                                        let i = (allocation_size.bytes() * ty_size) as usize;\n-                                        path.push(PathElem::ArrayElem(i));\n-                                    },\n-                                    _ => (),\n+                                    // Other errors shouldn't be possible\n+                                    _ => return Err(err),\n                                 }\n-\n-                                return validation_failure!(\n-                                    \"uninitialized or out-of-bounds memory\", path\n-                                )\n                             }\n                         }\n                     },"}, {"sha": "0f58c84c10b5ec15da05c2884ca125c43a286826", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs?ref=ff5a245f52813d4d876f283b0dffa3674e9210b1", "patch": "@@ -9,14 +9,18 @@\n // except according to those terms.\n \n union Foo {\n-    a: u8,\n+    a: usize,\n     b: Bar,\n+    c: &'static Bar,\n }\n \n #[derive(Copy, Clone)]\n enum Bar {}\n \n-const BAD_BAD_BAD: Bar = unsafe { Foo { a: 1 }.b};\n+const BAD_BAD_BAD: Bar = unsafe { Foo { a: 1 }.b };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+const BAD_BAD_REF: &Bar = unsafe { Foo { a: 1 }.c };\n //~^ ERROR this constant likely exhibits undefined behavior\n \n fn main() {"}, {"sha": "95cf8865c8de2aa3b6c9912ae633e2f5981a55f4", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=ff5a245f52813d4d876f283b0dffa3674e9210b1", "patch": "@@ -1,11 +1,19 @@\n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/ub-uninhabit.rs:19:1\n+  --> $DIR/ub-uninhabit.rs:20:1\n    |\n-LL | const BAD_BAD_BAD: Bar = unsafe { Foo { a: 1 }.b};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+LL | const BAD_BAD_BAD: Bar = unsafe { Foo { a: 1 }.b };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to previous error\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-uninhabit.rs:23:1\n+   |\n+LL | const BAD_BAD_REF: &Bar = unsafe { Foo { a: 1 }.c };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type at .<deref>\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "6ea758ea9fe665b124df2022ce7a117a95baa2f6", "filename": "src/test/ui/consts/const-eval/ub-usize-in-ref.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-usize-in-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-usize-in-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-usize-in-ref.rs?ref=ff5a245f52813d4d876f283b0dffa3674e9210b1", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n union Foo {\n     a: &'static u8,\n     b: usize,\n }\n \n-// This might point to an invalid address, but that's the user's problem\n const USIZE_AS_STATIC_REF: &'static u8 = unsafe { Foo { b: 1337 }.a};\n+//~^ ERROR this constant likely exhibits undefined behavior\n \n fn main() {\n }"}, {"sha": "55bc1e50aac009b007c44819f5f5fc7423a98d0b", "filename": "src/test/ui/consts/const-eval/ub-usize-in-ref.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-usize-in-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-usize-in-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-usize-in-ref.stderr?ref=ff5a245f52813d4d876f283b0dffa3674e9210b1", "patch": "@@ -0,0 +1,11 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-usize-in-ref.rs:16:1\n+   |\n+LL | const USIZE_AS_STATIC_REF: &'static u8 = unsafe { Foo { b: 1337 }.a};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered integer pointer in non-ZST reference\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "08aaa40e2f3c9e8b564de169487c63db5ca05689", "filename": "src/test/ui/union-ub-fat-ptr.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff5a245f52813d4d876f283b0dffa3674e9210b1/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr?ref=ff5a245f52813d4d876f283b0dffa3674e9210b1", "patch": "@@ -2,7 +2,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:87:1\n    |\n LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or out-of-bounds memory at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -26,7 +26,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:99:1\n    |\n LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or out-of-bounds memory at .<deref>[1]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -42,15 +42,15 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:106:1\n    |\n LL | const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid vtable in fat pointer at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:109:1\n    |\n LL | const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid vtable in fat pointer at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -98,15 +98,15 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:132:1\n    |\n LL | const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-UTF-8 data in str at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:135:1\n    |\n LL | const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-UTF-8 data in str at .<deref>.0\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}