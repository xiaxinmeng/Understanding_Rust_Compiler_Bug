{"sha": "55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZDM1ZjEyYWU3YTczZmNlZjFjNTliNWIyY2MwMTQyYTU1NzkzNGM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-10-02T13:12:20Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-10-02T13:13:50Z"}, "message": "Merge branch 'master' into metadiet\n\nrlib sizes:\n1445222 liballoc_jemalloc-bb943c5a.rlib\n10664 liballoc_system-bb943c5a.rlib\n143592 libarena-bb943c5a.rlib\n3639102 libcollections-bb943c5a.rlib\n16316910 libcore-bb943c5a.rlib\n214154 libflate-bb943c5a.rlib\n231440 libfmt_macros-bb943c5a.rlib\n536976 libgetopts-bb943c5a.rlib\n209672 libgraphviz-bb943c5a.rlib\n408008 liblibc-bb943c5a.rlib\n189610 liblog-bb943c5a.rlib\n662184 librand-bb943c5a.rlib\n605112 librbml-bb943c5a.rlib\n1397820 librustc_back-bb943c5a.rlib\n38383772 librustc-bb943c5a.rlib\n12842 librustc_bitflags-bb943c5a.rlib\n2297822 librustc_borrowck-bb943c5a.rlib\n571064 librustc_data_structures-bb943c5a.rlib\n9356542 librustc_driver-bb943c5a.rlib\n9477226 librustc_front-bb943c5a.rlib\n1605698 librustc_lint-bb943c5a.rlib\n77111720 librustc_llvm-bb943c5a.rlib\n4783848 librustc_mir-bb943c5a.rlib\n3534256 librustc_platform_intrinsics-bb943c5a.rlib\n593038 librustc_privacy-bb943c5a.rlib\n3122202 librustc_resolve-bb943c5a.rlib\n14185212 librustc_trans-bb943c5a.rlib\n11940328 librustc_typeck-bb943c5a.rlib\n1634264 librustc_unicode-bb943c5a.rlib\n15564160 librustdoc-bb943c5a.rlib\n8153964 libstd-bb943c5a.rlib\n30589338 libsyntax-bb943c5a.rlib\n897110 libterm-bb943c5a.rlib\n1360662 libtest-bb943c5a.rlib", "tree": {"sha": "476d9742426d7892a3f1e3aaaf1f907893bd0deb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/476d9742426d7892a3f1e3aaaf1f907893bd0deb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "html_url": "https://github.com/rust-lang/rust/commit/55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db817ceda4fe204261c9d1773dc137830e58e225", "url": "https://api.github.com/repos/rust-lang/rust/commits/db817ceda4fe204261c9d1773dc137830e58e225", "html_url": "https://github.com/rust-lang/rust/commit/db817ceda4fe204261c9d1773dc137830e58e225"}, {"sha": "e82faeb65594302897223b2ca4ee6927fb54625f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82faeb65594302897223b2ca4ee6927fb54625f", "html_url": "https://github.com/rust-lang/rust/commit/e82faeb65594302897223b2ca4ee6927fb54625f"}], "stats": {"total": 4348, "additions": 2489, "deletions": 1859}, "files": [{"sha": "5f3148c7c33c57571882e009d36932884f324fa7", "filename": "src/librustc/front/map/collector.rs", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -0,0 +1,344 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+use super::MapEntry::*;\n+\n+use rustc_front::hir::*;\n+use rustc_front::util;\n+use rustc_front::visit::{self, Visitor};\n+use middle::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use std::iter::repeat;\n+use syntax::ast::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::codemap::Span;\n+\n+/// A Visitor that walks over an AST and collects Node's into an AST\n+/// Map.\n+pub struct NodeCollector<'ast> {\n+    pub map: Vec<MapEntry<'ast>>,\n+    pub definitions: Definitions,\n+    pub parent_node: NodeId,\n+}\n+\n+impl<'ast> NodeCollector<'ast> {\n+    pub fn root() -> NodeCollector<'ast> {\n+        let mut collector = NodeCollector {\n+            map: vec![],\n+            definitions: Definitions::new(),\n+            parent_node: CRATE_NODE_ID,\n+        };\n+        collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+\n+        let result = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        assert_eq!(result, CRATE_DEF_INDEX);\n+\n+        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n+\n+        collector\n+    }\n+\n+    pub fn extend(parent: &'ast InlinedParent,\n+                  parent_node: NodeId,\n+                  parent_def_path: DefPath,\n+                  map: Vec<MapEntry<'ast>>,\n+                  definitions: Definitions)\n+                  -> NodeCollector<'ast> {\n+        let mut collector = NodeCollector {\n+            map: map,\n+            parent_node: parent_node,\n+            definitions: definitions,\n+        };\n+\n+        collector.insert_entry(parent_node, RootInlinedParent(parent));\n+        collector.create_def(parent_node, DefPathData::InlinedRoot(parent_def_path));\n+\n+        collector\n+    }\n+\n+    fn parent_def(&self) -> Option<DefIndex> {\n+        let mut parent_node = Some(self.parent_node);\n+        while let Some(p) = parent_node {\n+            if let Some(q) = self.definitions.opt_def_index(p) {\n+                return Some(q);\n+            }\n+            parent_node = self.map[p as usize].parent_node();\n+        }\n+        None\n+    }\n+\n+    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n+        let parent_def = self.parent_def();\n+        self.definitions.create_def_with_parent(parent_def, node_id, data)\n+    }\n+\n+    fn create_def_with_parent(&mut self,\n+                              parent: Option<DefIndex>,\n+                              node_id: NodeId,\n+                              data: DefPathData)\n+                              -> DefIndex {\n+        self.definitions.create_def_with_parent(parent, node_id, data)\n+    }\n+\n+    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n+        debug!(\"ast_map: {:?} => {:?}\", id, entry);\n+        let len = self.map.len();\n+        if id as usize >= len {\n+            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n+        }\n+        self.map[id as usize] = entry;\n+    }\n+\n+    fn insert_def(&mut self, id: NodeId, node: Node<'ast>, data: DefPathData) -> DefIndex {\n+        self.insert(id, node);\n+        self.create_def(id, data)\n+    }\n+\n+    fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n+        let entry = MapEntry::from_node(self.parent_node, node);\n+        self.insert_entry(id, entry);\n+    }\n+\n+    fn visit_fn_decl(&mut self, decl: &'ast FnDecl) {\n+        for a in &decl.inputs {\n+            self.insert(a.id, NodeArg(&*a.pat));\n+        }\n+    }\n+}\n+\n+impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        // Pick the def data. This need not be unique, but the more\n+        // information we encapsulate into\n+        let def_data = match i.node {\n+            ItemDefaultImpl(..) | ItemImpl(..) => DefPathData::Impl,\n+            ItemEnum(..) | ItemStruct(..) | ItemTrait(..) => DefPathData::Type(i.name),\n+            ItemExternCrate(..) | ItemMod(..) => DefPathData::Mod(i.name),\n+            ItemStatic(..) | ItemConst(..) | ItemFn(..) => DefPathData::Value(i.name),\n+            _ => DefPathData::Misc,\n+        };\n+\n+        self.insert_def(i.id, NodeItem(i), def_data);\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = i.id;\n+\n+        match i.node {\n+            ItemImpl(..) => {}\n+            ItemEnum(ref enum_definition, _) => {\n+                for v in &enum_definition.variants {\n+                    let variant_def_index =\n+                        self.insert_def(v.node.id,\n+                                        NodeVariant(&**v),\n+                                        DefPathData::EnumVariant(v.node.name));\n+\n+                    match v.node.kind {\n+                        TupleVariantKind(ref args) => {\n+                            for arg in args {\n+                                self.create_def_with_parent(Some(variant_def_index),\n+                                                            arg.id,\n+                                                            DefPathData::PositionalField);\n+                            }\n+                        }\n+                        StructVariantKind(ref def) => {\n+                            for field in &def.fields {\n+                                self.create_def_with_parent(\n+                                    Some(variant_def_index),\n+                                    field.node.id,\n+                                    DefPathData::Field(field.node.kind));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            ItemForeignMod(..) => {\n+            }\n+            ItemStruct(ref struct_def, _) => {\n+                // If this is a tuple-like struct, register the constructor.\n+                if let Some(ctor_id) = struct_def.ctor_id {\n+                    self.insert_def(ctor_id,\n+                                    NodeStructCtor(&**struct_def),\n+                                    DefPathData::StructCtor);\n+                }\n+\n+                for field in &struct_def.fields {\n+                    self.create_def(field.node.id, DefPathData::Field(field.node.kind));\n+                }\n+            }\n+            ItemTrait(_, _, ref bounds, _) => {\n+                for b in bounds.iter() {\n+                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n+                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n+                    }\n+                }\n+            }\n+            ItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathList(_, ref paths) => {\n+                        for path in paths {\n+                            self.insert(path.node.id(), NodeItem(i));\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_item(self, i);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n+        self.insert_def(foreign_item.id,\n+                        NodeForeignItem(foreign_item),\n+                        DefPathData::Value(foreign_item.name));\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = foreign_item.id;\n+        visit::walk_foreign_item(self, foreign_item);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.insert_def(ty_param.id,\n+                            NodeTyParam(ty_param),\n+                            DefPathData::TypeParam(ty_param.name));\n+        }\n+\n+        visit::walk_generics(self, generics);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n+        let def_data = match ti.node {\n+            MethodTraitItem(..) | ConstTraitItem(..) => DefPathData::Value(ti.name),\n+            TypeTraitItem(..) => DefPathData::Type(ti.name),\n+        };\n+\n+        self.insert(ti.id, NodeTraitItem(ti));\n+        self.create_def(ti.id, def_data);\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = ti.id;\n+\n+        match ti.node {\n+            ConstTraitItem(_, Some(ref expr)) => {\n+                self.create_def(expr.id, DefPathData::Initializer);\n+            }\n+            _ => { }\n+        }\n+\n+        visit::walk_trait_item(self, ti);\n+\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n+        let def_data = match ii.node {\n+            MethodImplItem(..) | ConstImplItem(..) => DefPathData::Value(ii.name),\n+            TypeImplItem(..) => DefPathData::Type(ii.name),\n+        };\n+\n+        self.insert_def(ii.id, NodeImplItem(ii), def_data);\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = ii.id;\n+\n+        match ii.node {\n+            ConstImplItem(_, ref expr) => {\n+                self.create_def(expr.id, DefPathData::Initializer);\n+            }\n+            _ => { }\n+        }\n+\n+        visit::walk_impl_item(self, ii);\n+\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'ast Pat) {\n+        let maybe_binding = match pat.node {\n+            PatIdent(_, id, _) => Some(id.node),\n+            _ => None\n+        };\n+\n+        if let Some(id) = maybe_binding {\n+            self.insert_def(pat.id, NodeLocal(pat), DefPathData::Binding(id.name));\n+        } else {\n+            self.insert(pat.id, NodePat(pat));\n+        }\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = pat.id;\n+        visit::walk_pat(self, pat);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        self.insert(expr.id, NodeExpr(expr));\n+\n+        match expr.node {\n+            ExprClosure(..) => { self.create_def(expr.id, DefPathData::ClosureExpr); }\n+            _ => { }\n+        }\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = expr.id;\n+        visit::walk_expr(self, expr);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n+        let id = util::stmt_id(stmt);\n+        self.insert(id, NodeStmt(stmt));\n+        let parent_node = self.parent_node;\n+        self.parent_node = id;\n+        visit::walk_stmt(self, stmt);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n+                b: &'ast Block, s: Span, id: NodeId) {\n+        assert_eq!(self.parent_node, id);\n+        self.visit_fn_decl(fd);\n+        visit::walk_fn(self, fk, fd, b, s);\n+    }\n+\n+    fn visit_ty(&mut self, ty: &'ast Ty) {\n+        match ty.node {\n+            TyBareFn(ref fd) => {\n+                self.visit_fn_decl(&*fd.decl);\n+            }\n+            _ => {}\n+        }\n+        visit::walk_ty(self, ty);\n+    }\n+\n+    fn visit_block(&mut self, block: &'ast Block) {\n+        self.insert(block.id, NodeBlock(block));\n+        let parent_node = self.parent_node;\n+        self.parent_node = block.id;\n+        visit::walk_block(self, block);\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n+        self.insert(lifetime.id, NodeLifetime(lifetime));\n+    }\n+\n+    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+        self.visit_lifetime(&def.lifetime);\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n+    }\n+}\n+"}, {"sha": "c1eb5f1f11845ae47612c2ee2f55091e3ca3b8cc", "filename": "src/librustc/front/map/definitions.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -0,0 +1,263 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use metadata::cstore::LOCAL_CRATE;\n+use middle::def_id::{DefId, DefIndex};\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_front::hir;\n+use syntax::ast;\n+use syntax::parse::token::InternedString;\n+use util::nodemap::NodeMap;\n+\n+#[derive(Clone)]\n+pub struct Definitions {\n+    data: Vec<DefData>,\n+    key_map: FnvHashMap<DefKey, DefIndex>,\n+    node_map: NodeMap<DefIndex>,\n+}\n+\n+/// A unique identifier that we can use to lookup a definition\n+/// precisely. It combines the index of the definition's parent (if\n+/// any) with a `DisambiguatedDefPathData`.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct DefKey {\n+    /// Parent path.\n+    pub parent: Option<DefIndex>,\n+\n+    /// Identifier of this node.\n+    pub disambiguated_data: DisambiguatedDefPathData,\n+}\n+\n+/// Pair of `DefPathData` and an integer disambiguator. The integer is\n+/// normally 0, but in the event that there are multiple defs with the\n+/// same `parent` and `data`, we use this field to disambiguate\n+/// between them. This introduces some artificial ordering dependency\n+/// but means that if you have (e.g.) two impls for the same type in\n+/// the same module, they do get distinct def-ids.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct DisambiguatedDefPathData {\n+    pub data: DefPathData,\n+    pub disambiguator: u32\n+}\n+\n+/// For each definition, we track the following data.  A definition\n+/// here is defined somewhat circularly as \"something with a def-id\",\n+/// but it generally corresponds to things like structs, enums, etc.\n+/// There are also some rather random cases (like const initializer\n+/// expressions) that are mostly just leftovers.\n+#[derive(Clone, Debug)]\n+pub struct DefData {\n+    pub key: DefKey,\n+\n+    /// Local ID within the HIR.\n+    pub node_id: ast::NodeId,\n+}\n+\n+pub type DefPath = Vec<DisambiguatedDefPathData>;\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum DefPathData {\n+    // Root: these should only be used for the root nodes, because\n+    // they are treated specially by the `def_path` function.\n+    CrateRoot,\n+    InlinedRoot(DefPath),\n+\n+    // Catch-all for random DefId things like DUMMY_NODE_ID\n+    Misc,\n+\n+    // Different kinds of items and item-like things:\n+    Impl,\n+    Type(ast::Name),\n+    Mod(ast::Name),\n+    Value(ast::Name),\n+    MacroDef(ast::Name),\n+    ClosureExpr,\n+\n+    // Subportions of items\n+    TypeParam(ast::Name),\n+    LifetimeDef(ast::Name),\n+    EnumVariant(ast::Name),\n+    PositionalField,\n+    Field(hir::StructFieldKind),\n+    StructCtor, // implicit ctor for a tuple-like struct\n+    Initializer, // initializer for a const\n+    Binding(ast::Name), // pattern binding\n+\n+    // An external crate that does not have an `extern crate` in this\n+    // crate.\n+    DetachedCrate(ast::Name),\n+}\n+\n+impl Definitions {\n+    pub fn new() -> Definitions {\n+        Definitions {\n+            data: vec![],\n+            key_map: FnvHashMap(),\n+            node_map: NodeMap(),\n+        }\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.data.len()\n+    }\n+\n+    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+        self.data[index.as_usize()].key.clone()\n+    }\n+\n+    /// Returns the path from the crate root to `index`. The root\n+    /// nodes are not included in the path (i.e., this will be an\n+    /// empty vector for the crate root). For an inlined item, this\n+    /// will be the path of the item in the external crate (but the\n+    /// path will begin with the path to the external crate).\n+    pub fn def_path(&self, index: DefIndex) -> DefPath {\n+        make_def_path(index, |p| self.def_key(p))\n+    }\n+\n+    pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n+        self.node_map.get(&node).cloned()\n+    }\n+\n+    pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n+        self.opt_def_index(node).map(DefId::local)\n+    }\n+\n+    pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n+        if def_id.krate == LOCAL_CRATE {\n+            assert!(def_id.index.as_usize() < self.data.len());\n+            Some(self.data[def_id.index.as_usize()].node_id)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn create_def_with_parent(&mut self,\n+                                  parent: Option<DefIndex>,\n+                                  node_id: ast::NodeId,\n+                                  data: DefPathData)\n+                                  -> DefIndex {\n+        assert!(!self.node_map.contains_key(&node_id),\n+                \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n+                node_id,\n+                data,\n+                self.data[self.node_map[&node_id].as_usize()]);\n+\n+        // Find a unique DefKey. This basically means incrementing the disambiguator\n+        // until we get no match.\n+        let mut key = DefKey {\n+            parent: parent,\n+            disambiguated_data: DisambiguatedDefPathData {\n+                data: data,\n+                disambiguator: 0\n+            }\n+        };\n+\n+        while self.key_map.contains_key(&key) {\n+            key.disambiguated_data.disambiguator += 1;\n+        }\n+\n+        // Create the definition.\n+        let index = DefIndex::new(self.data.len());\n+        self.data.push(DefData { key: key.clone(), node_id: node_id });\n+        self.node_map.insert(node_id, index);\n+        self.key_map.insert(key, index);\n+\n+        index\n+    }\n+}\n+\n+impl DefPathData {\n+    pub fn as_interned_str(&self) -> InternedString {\n+        use self::DefPathData::*;\n+        match *self {\n+            Type(name) |\n+            Mod(name) |\n+            Value(name) |\n+            MacroDef(name) |\n+            TypeParam(name) |\n+            LifetimeDef(name) |\n+            EnumVariant(name) |\n+            DetachedCrate(name) |\n+            Binding(name) => {\n+                name.as_str()\n+            }\n+\n+            Field(hir::StructFieldKind::NamedField(name, _)) => {\n+                name.as_str()\n+            }\n+\n+            PositionalField |\n+            Field(hir::StructFieldKind::UnnamedField(_)) => {\n+                InternedString::new(\"<field>\")\n+            }\n+\n+            // note that this does not show up in user printouts\n+            CrateRoot => {\n+                InternedString::new(\"<root>\")\n+            }\n+\n+            // note that this does not show up in user printouts\n+            InlinedRoot(_) => {\n+                InternedString::new(\"<inlined-root>\")\n+            }\n+\n+            Misc => {\n+                InternedString::new(\"?\")\n+            }\n+\n+            Impl => {\n+                InternedString::new(\"<impl>\")\n+            }\n+\n+            ClosureExpr => {\n+                InternedString::new(\"<closure>\")\n+            }\n+\n+            StructCtor => {\n+                InternedString::new(\"<constructor>\")\n+            }\n+\n+            Initializer => {\n+                InternedString::new(\"<initializer>\")\n+            }\n+        }\n+    }\n+\n+    pub fn to_string(&self) -> String {\n+        self.as_interned_str().to_string()\n+    }\n+}\n+\n+pub fn make_def_path<FN>(start_index: DefIndex, mut get_key: FN) -> DefPath\n+    where FN: FnMut(DefIndex) -> DefKey\n+{\n+    let mut result = vec![];\n+    let mut index = Some(start_index);\n+    while let Some(p) = index {\n+        let key = get_key(p);\n+        match key.disambiguated_data.data {\n+            DefPathData::CrateRoot => {\n+                assert!(key.parent.is_none());\n+                break;\n+            }\n+            DefPathData::InlinedRoot(ref p) => {\n+                assert!(key.parent.is_none());\n+                result.extend(p.iter().cloned().rev());\n+                break;\n+            }\n+            _ => {\n+                result.push(key.disambiguated_data);\n+                index = key.parent;\n+            }\n+        }\n+    }\n+    result.reverse();\n+    result\n+}"}, {"sha": "825d5da0c999dbc67805d6738672c27074f89f7f", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 70, "deletions": 216, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -11,31 +11,34 @@\n pub use self::Node::*;\n pub use self::PathElem::*;\n use self::MapEntry::*;\n+use self::collector::NodeCollector;\n+pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData, DisambiguatedDefPathData};\n \n use metadata::inline::InlinedItem;\n use metadata::inline::InlinedItem as II;\n use middle::def_id::DefId;\n \n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::{Span, Spanned};\n use syntax::parse::token;\n \n use rustc_front::hir::*;\n use rustc_front::fold::Folder;\n-use rustc_front::visit::{self, Visitor};\n-use rustc_front::util;\n+use rustc_front::visit;\n use rustc_front::print::pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n use std::fmt;\n use std::io;\n-use std::iter::{self, repeat};\n+use std::iter;\n use std::mem;\n use std::slice;\n \n pub mod blocks;\n+mod collector;\n+pub mod definitions;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum PathElem {\n@@ -130,7 +133,7 @@ pub enum Node<'ast> {\n /// Represents an entry and its parent NodeID.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n-enum MapEntry<'ast> {\n+pub enum MapEntry<'ast> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n@@ -263,10 +266,45 @@ pub struct Map<'ast> {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: RefCell<Vec<MapEntry<'ast>>>\n+    map: RefCell<Vec<MapEntry<'ast>>>,\n+\n+    definitions: RefCell<Definitions>,\n }\n \n impl<'ast> Map<'ast> {\n+    pub fn num_local_def_ids(&self) -> usize {\n+        self.definitions.borrow().len()\n+    }\n+\n+    pub fn def_key(&self, def_id: DefId) -> DefKey {\n+        assert!(def_id.is_local());\n+        self.definitions.borrow().def_key(def_id.index)\n+    }\n+\n+    pub fn def_path_from_id(&self, id: NodeId) -> DefPath {\n+        self.def_path(self.local_def_id(id))\n+    }\n+\n+    pub fn def_path(&self, def_id: DefId) -> DefPath {\n+        assert!(def_id.is_local());\n+        self.definitions.borrow().def_path(def_id.index)\n+    }\n+\n+    pub fn local_def_id(&self, node: NodeId) -> DefId {\n+        self.opt_local_def_id(node).unwrap_or_else(|| {\n+            panic!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n+                   node, self.find_entry(node))\n+        })\n+    }\n+\n+    pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n+        self.definitions.borrow().opt_local_def_id(node)\n+    }\n+\n+    pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n+        self.definitions.borrow().as_local_node_id(def_id)\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.borrow().len()\n     }\n@@ -288,6 +326,10 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn get_if_local(&self, id: DefId) -> Option<Node<'ast>> {\n+        self.as_local_node_id(id).map(|id| self.get(id))\n+    }\n+\n     /// Retrieve the Node corresponding to `id`, returning None if\n     /// cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'ast>> {\n@@ -383,7 +425,7 @@ impl<'ast> Map<'ast> {\n         match self.find_entry(parent) {\n             Some(RootInlinedParent(&InlinedParent {ii: II::TraitItem(did, _), ..})) => did,\n             Some(RootInlinedParent(&InlinedParent {ii: II::ImplItem(did, _), ..})) => did,\n-            _ => DefId::local(parent)\n+            _ => self.local_def_id(parent)\n         }\n     }\n \n@@ -596,9 +638,13 @@ impl<'ast> Map<'ast> {\n             .unwrap_or_else(|| panic!(\"AstMap.span: could not find span for id {:?}\", id))\n     }\n \n+    pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n+        self.as_local_node_id(id).map(|id| self.span(id))\n+    }\n+\n     pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n-        if def_id.is_local() {\n-            self.opt_span(def_id.node).unwrap_or(fallback)\n+        if let Some(node_id) = self.as_local_node_id(def_id) {\n+            self.opt_span(node_id).unwrap_or(fallback)\n         } else {\n             fallback\n         }\n@@ -741,194 +787,10 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n     }\n }\n \n-/// A Visitor that walks over an AST and collects Node's into an AST Map.\n-struct NodeCollector<'ast> {\n-    map: Vec<MapEntry<'ast>>,\n-    parent_node: NodeId,\n-}\n-\n-impl<'ast> NodeCollector<'ast> {\n-    fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n-        debug!(\"ast_map: {:?} => {:?}\", id, entry);\n-        let len = self.map.len();\n-        if id as usize >= len {\n-            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n-        }\n-        self.map[id as usize] = entry;\n-    }\n-\n-    fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n-        let entry = MapEntry::from_node(self.parent_node, node);\n-        self.insert_entry(id, entry);\n-    }\n-\n-    fn visit_fn_decl(&mut self, decl: &'ast FnDecl) {\n-        for a in &decl.inputs {\n-            self.insert(a.id, NodeArg(&*a.pat));\n-        }\n-    }\n-}\n-\n-impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n-    fn visit_item(&mut self, i: &'ast Item) {\n-        self.insert(i.id, NodeItem(i));\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = i.id;\n-\n-        match i.node {\n-            ItemImpl(_, _, _, _, _, ref impl_items) => {\n-                for ii in impl_items {\n-                    self.insert(ii.id, NodeImplItem(ii));\n-                }\n-            }\n-            ItemEnum(ref enum_definition, _) => {\n-                for v in &enum_definition.variants {\n-                    self.insert(v.node.id, NodeVariant(&**v));\n-                }\n-            }\n-            ItemForeignMod(ref nm) => {\n-                for nitem in &nm.items {\n-                    self.insert(nitem.id, NodeForeignItem(&**nitem));\n-                }\n-            }\n-            ItemStruct(ref struct_def, _) => {\n-                // If this is a tuple-like struct, register the constructor.\n-                match struct_def.ctor_id {\n-                    Some(ctor_id) => {\n-                        self.insert(ctor_id, NodeStructCtor(&**struct_def));\n-                    }\n-                    None => {}\n-                }\n-            }\n-            ItemTrait(_, _, ref bounds, ref trait_items) => {\n-                for b in bounds.iter() {\n-                    if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n-                        self.insert(t.trait_ref.ref_id, NodeItem(i));\n-                    }\n-                }\n-\n-                for ti in trait_items {\n-                    self.insert(ti.id, NodeTraitItem(ti));\n-                }\n-            }\n-            ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathList(_, ref paths) => {\n-                        for path in paths {\n-                            self.insert(path.node.id(), NodeItem(i));\n-                        }\n-                    }\n-                    _ => ()\n-                }\n-            }\n-            _ => {}\n-        }\n-        visit::walk_item(self, i);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'ast Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            self.insert(ty_param.id, NodeTyParam(ty_param));\n-        }\n-\n-        visit::walk_generics(self, generics);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n-        let parent_node = self.parent_node;\n-        self.parent_node = ti.id;\n-        visit::walk_trait_item(self, ti);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n-        let parent_node = self.parent_node;\n-        self.parent_node = ii.id;\n-\n-        visit::walk_impl_item(self, ii);\n-\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'ast Pat) {\n-        self.insert(pat.id, match pat.node {\n-            // Note: this is at least *potentially* a pattern...\n-            PatIdent(..) => NodeLocal(pat),\n-            _ => NodePat(pat)\n-        });\n-\n-        let parent_node = self.parent_node;\n-        self.parent_node = pat.id;\n-        visit::walk_pat(self, pat);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'ast Expr) {\n-        self.insert(expr.id, NodeExpr(expr));\n-        let parent_node = self.parent_node;\n-        self.parent_node = expr.id;\n-        visit::walk_expr(self, expr);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        let id = util::stmt_id(stmt);\n-        self.insert(id, NodeStmt(stmt));\n-        let parent_node = self.parent_node;\n-        self.parent_node = id;\n-        visit::walk_stmt(self, stmt);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, id: NodeId) {\n-        let parent_node = self.parent_node;\n-        self.parent_node = id;\n-        self.visit_fn_decl(fd);\n-        visit::walk_fn(self, fk, fd, b, s);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_ty(&mut self, ty: &'ast Ty) {\n-        let parent_node = self.parent_node;\n-        self.parent_node = ty.id;\n-        match ty.node {\n-            TyBareFn(ref fd) => {\n-                self.visit_fn_decl(&*fd.decl);\n-            }\n-            _ => {}\n-        }\n-        visit::walk_ty(self, ty);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_block(&mut self, block: &'ast Block) {\n-        self.insert(block.id, NodeBlock(block));\n-        let parent_node = self.parent_node;\n-        self.parent_node = block.id;\n-        visit::walk_block(self, block);\n-        self.parent_node = parent_node;\n-    }\n-\n-    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n-        self.insert(lifetime.id, NodeLifetime(lifetime));\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n-        self.visit_lifetime(&def.lifetime);\n-    }\n-}\n-\n pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n-    let mut collector = NodeCollector {\n-        map: vec![],\n-        parent_node: CRATE_NODE_ID,\n-    };\n-    collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+    let mut collector = NodeCollector::root();\n     visit::walk_crate(&mut collector, &forest.krate);\n-    let map = collector.map;\n+    let NodeCollector { map, definitions, .. } = collector;\n \n     if log_enabled!(::log::DEBUG) {\n         // This only makes sense for ordered stores; note the\n@@ -948,7 +810,8 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n \n     Map {\n         forest: forest,\n-        map: RefCell::new(map)\n+        map: RefCell::new(map),\n+        definitions: RefCell::new(definitions),\n     }\n }\n \n@@ -957,6 +820,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest) -> Map<'ast> {\n /// the item itself.\n pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           path: Vec<PathElem>,\n+                                          def_path: DefPath,\n                                           ii: InlinedItem,\n                                           fold_ops: F)\n                                           -> &'ast InlinedItem {\n@@ -980,29 +844,18 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n     });\n \n     let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n-    let mut collector = NodeCollector {\n-        map: mem::replace(&mut *map.map.borrow_mut(), vec![]),\n-        parent_node: ii_parent_id,\n-    };\n-    collector.insert_entry(ii_parent_id, RootInlinedParent(ii_parent));\n+    let mut collector =\n+        NodeCollector::extend(\n+            ii_parent,\n+            ii_parent_id,\n+            def_path,\n+            mem::replace(&mut *map.map.borrow_mut(), vec![]),\n+            mem::replace(&mut *map.definitions.borrow_mut(), Definitions::new()));\n     ii_parent.ii.visit(&mut collector);\n \n-    // Methods get added to the AST map when their impl is visited.  Since we\n-    // don't decode and instantiate the impl, but just the method, we have to\n-    // add it to the table now. Likewise with foreign items.\n-    match ii_parent.ii {\n-        II::Item(_) => {}\n-        II::TraitItem(_, ref ti) => {\n-            collector.insert(ti.id, NodeTraitItem(ti));\n-        }\n-        II::ImplItem(_, ref ii) => {\n-            collector.insert(ii.id, NodeImplItem(ii));\n-        }\n-        II::Foreign(ref i) => {\n-            collector.insert(i.id, NodeForeignItem(i));\n-        }\n-    }\n     *map.map.borrow_mut() = collector.map;\n+    *map.definitions.borrow_mut() = collector.definitions;\n+\n     &ii_parent.ii\n }\n \n@@ -1134,3 +987,4 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n     }\n }\n+"}, {"sha": "85d589242426ac72add795a862e262896d53a442", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -43,12 +43,16 @@ pub const tag_items_data_parent_item: usize = 0x28;\n \n pub const tag_items_data_item_is_tuple_struct_ctor: usize = 0x29;\n \n+pub const tag_items_closure_kind: usize = 0x2a;\n+pub const tag_items_closure_ty: usize = 0x2b;\n+pub const tag_def_key: usize = 0x2c;\n+\n+// GAP 0x2d 0x2e\n+\n pub const tag_index: usize = 0x110; // top-level only\n pub const tag_xref_index: usize = 0x111; // top-level only\n pub const tag_xref_data: usize = 0x112; // top-level only\n \n-// GAP 0x2a, 0x2b, 0x2c, 0x2d, 0x2e\n-\n pub const tag_meta_item_name_value: usize = 0x2f;\n \n pub const tag_meta_item_name: usize = 0x30;\n@@ -130,8 +134,7 @@ enum_from_u32! {\n         // GAP 0x60\n         tag_table_adjustments = 0x61,\n         // GAP 0x62, 0x63\n-        tag_table_closure_tys = 0x64,\n-        tag_table_closure_kinds = 0x65,\n+            // GAP 0x64, 0x65\n         tag_table_upvar_capture_map = 0x66,\n         // GAP 0x67, 0x68\n         tag_table_const_qualif = 0x69,\n@@ -150,12 +153,12 @@ pub const tag_dylib_dependency_formats: usize = 0x106; // top-level only\n // tag_lang_items\n // - tag_lang_items_item\n //   - tag_lang_items_item_id: u32\n-//   - tag_lang_items_item_node_id: u32\n+//   - tag_lang_items_item_index: u32\n \n pub const tag_lang_items: usize = 0x107; // top-level only\n pub const tag_lang_items_item: usize = 0x73;\n pub const tag_lang_items_item_id: usize = 0x74;\n-pub const tag_lang_items_item_node_id: usize = 0x75;\n+pub const tag_lang_items_item_index: usize = 0x75;\n pub const tag_lang_items_missing: usize = 0x76;\n \n pub const tag_item_unnamed_field: usize = 0x77;\n@@ -202,8 +205,8 @@ pub struct LinkMeta {\n \n pub const tag_struct_fields: usize = 0x10d; // top-level only\n pub const tag_struct_field: usize = 0x8a;\n-pub const tag_struct_field_id: usize = 0x8b;\n \n+pub const tag_items_data_item_struct_ctor: usize = 0x8b;\n pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n \n pub const tag_items_data_region: usize = 0x8e;"}, {"sha": "6c81562f7b2912e892111c98954d6526ba75c9be", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -325,6 +325,7 @@ impl<'a> CrateReader<'a> {\n         let cmeta = Rc::new(cstore::crate_metadata {\n             name: name.to_string(),\n             local_path: RefCell::new(SmallVector::zero()),\n+            local_def_path: RefCell::new(vec![]),\n             index: decoder::load_index(metadata.as_slice()),\n             xref_index: decoder::load_xrefs(metadata.as_slice()),\n             data: metadata,\n@@ -549,7 +550,8 @@ impl<'a> CrateReader<'a> {\n             self.sess.abort_if_errors();\n         }\n \n-        let registrar = decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice())\n+        let registrar =\n+            decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice())\n             .map(|id| decoder::get_symbol_from_buf(ekrate.metadata.as_slice(), id));\n \n         match (ekrate.dylib.as_ref(), registrar) {\n@@ -752,6 +754,9 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                                                               i.span,\n                                                               PathKind::Crate,\n                                                               true);\n+                        let def_id = self.ast_map.local_def_id(i.id);\n+                        let def_path = self.ast_map.def_path(def_id);\n+                        cmeta.update_local_def_path(def_path);\n                         self.ast_map.with_path(i.id, |path| {\n                             cmeta.update_local_path(path)\n                         });"}, {"sha": "e04df51dc6862dce539c49b2510fa798a1ecc74f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -14,7 +14,7 @@ use front::map as ast_map;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::inline::InlinedItem;\n-use middle::def_id::DefId;\n+use middle::def_id::{DefId, DefIndex};\n use middle::lang_items;\n use middle::ty;\n use util::nodemap::FnvHashMap;\n@@ -33,15 +33,15 @@ pub struct MethodInfo {\n \n pub fn get_symbol(cstore: &cstore::CStore, def: DefId) -> String {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_symbol(&cdata, def.node)\n+    decoder::get_symbol(&cdata, def.index)\n }\n \n /// Iterates over all the language items in the given crate.\n pub fn each_lang_item<F>(cstore: &cstore::CStore,\n                          cnum: ast::CrateNum,\n                          f: F)\n                          -> bool where\n-    F: FnMut(ast::NodeId, usize) -> bool,\n+    F: FnMut(DefIndex, usize) -> bool,\n {\n     let crate_data = cstore.get_crate_data(cnum);\n     decoder::each_lang_item(&*crate_data, f)\n@@ -59,7 +59,7 @@ pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n     };\n     decoder::each_child_of_item(cstore.intr.clone(),\n                                 &*crate_data,\n-                                def_id.node,\n+                                def_id.index,\n                                 get_crate_data,\n                                 callback)\n }\n@@ -83,7 +83,7 @@ pub fn each_top_level_item_of_crate<F>(cstore: &cstore::CStore,\n pub fn get_item_path(tcx: &ty::ctxt, def: DefId) -> Vec<ast_map::PathElem> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    let path = decoder::get_item_path(&*cdata, def.node);\n+    let path = decoder::get_item_path(&*cdata, def.index);\n \n     cdata.with_local_path(|cpath| {\n         let mut r = Vec::with_capacity(cpath.len() + path.len());\n@@ -96,7 +96,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: DefId) -> Vec<ast_map::PathElem> {\n pub fn get_item_name(tcx: &ty::ctxt, def: DefId) -> ast::Name {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_name(&cstore.intr, &cdata, def.node)\n+    decoder::get_item_name(&cstore.intr, &cdata, def.index)\n }\n \n pub enum FoundAst<'ast> {\n@@ -113,85 +113,85 @@ pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId,\n                                 -> FoundAst<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::maybe_get_item_ast(&*cdata, tcx, def.node, decode_inlined_item)\n+    decoder::maybe_get_item_ast(&*cdata, tcx, def.index, decode_inlined_item)\n }\n \n /// Returns information about the given implementation.\n pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: DefId)\n                       -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl_items(&*cdata, impl_def_id.node)\n+    decoder::get_impl_items(&*cdata, impl_def_id.index)\n }\n \n pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                     -> ty::ImplOrTraitItem<'tcx> {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n     decoder::get_impl_or_trait_item(tcx.sess.cstore.intr.clone(),\n                                     &*cdata,\n-                                    def.node,\n+                                    def.index,\n                                     tcx)\n }\n \n pub fn get_trait_name(cstore: &cstore::CStore, def: DefId) -> ast::Name {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_name(cstore.intr.clone(),\n                             &*cdata,\n-                            def.node)\n+                            def.index)\n }\n \n pub fn is_static_method(cstore: &cstore::CStore, def: DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::is_static_method(&*cdata, def.node)\n+    decoder::is_static_method(&*cdata, def.index)\n }\n \n pub fn get_trait_item_def_ids(cstore: &cstore::CStore, def: DefId)\n                               -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_item_def_ids(&*cdata, def.node)\n+    decoder::get_trait_item_def_ids(&*cdata, def.index)\n }\n \n pub fn get_item_variances(cstore: &cstore::CStore,\n                           def: DefId) -> ty::ItemVariances {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_variances(&*cdata, def.node)\n+    decoder::get_item_variances(&*cdata, def.index)\n }\n \n pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                         def: DefId)\n                                         -> Vec<Rc<ty::Method<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n+    decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.index, tcx)\n }\n \n pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                    -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.node, tcx)\n+    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.index, tcx)\n }\n \n pub fn get_methods_if_impl(cstore: &cstore::CStore,\n                                   def: DefId)\n                                -> Option<Vec<MethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.node)\n+    decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.index)\n }\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: DefId)\n                       -> Vec<ast::Attribute> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_item_attrs(&*cdata, def_id.node)\n+    decoder::get_item_attrs(&*cdata, def_id.index)\n }\n \n pub fn get_struct_field_names(cstore: &cstore::CStore, def: DefId) -> Vec<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_field_names(&cstore.intr, &*cdata, def.node)\n+    decoder::get_struct_field_names(&cstore.intr, &*cdata, def.index)\n }\n \n-pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId) -> FnvHashMap<ast::NodeId,\n-        Vec<ast::Attribute>> {\n+pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId)\n+                              -> FnvHashMap<DefId, Vec<ast::Attribute>> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_field_attrs(&*cdata)\n }\n@@ -201,35 +201,35 @@ pub fn get_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type(&*cdata, def.node, tcx)\n+    decoder::get_type(&*cdata, def.index, tcx)\n }\n \n pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_def(&*cdata, def.node, tcx)\n+    decoder::get_trait_def(&*cdata, def.index, tcx)\n }\n \n pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_adt_def(&cstore.intr, &*cdata, def.node, tcx)\n+    decoder::get_adt_def(&cstore.intr, &*cdata, def.index, tcx)\n }\n \n pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                             -> ty::GenericPredicates<'tcx>\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_predicates(&*cdata, def.node, tcx)\n+    decoder::get_predicates(&*cdata, def.index, tcx)\n }\n \n pub fn get_super_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_super_predicates(&*cdata, def.node, tcx)\n+    decoder::get_super_predicates(&*cdata, def.index, tcx)\n }\n \n pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n@@ -238,7 +238,7 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_polarity(&*cdata, def.node)\n+    decoder::get_impl_polarity(&*cdata, def.index)\n }\n \n pub fn get_custom_coerce_unsized_kind<'tcx>(\n@@ -248,7 +248,7 @@ pub fn get_custom_coerce_unsized_kind<'tcx>(\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_custom_coerce_unsized_kind(&*cdata, def.node)\n+    decoder::get_custom_coerce_unsized_kind(&*cdata, def.index)\n }\n \n // Given a def_id for an impl, return the trait it implements,\n@@ -258,7 +258,7 @@ pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> Option<ty::TraitRef<'tcx>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_trait(&*cdata, def.node, tcx)\n+    decoder::get_impl_trait(&*cdata, def.index, tcx)\n }\n \n pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n@@ -273,7 +273,7 @@ pub fn each_inherent_implementation_for_type<F>(cstore: &cstore::CStore,\n     F: FnMut(DefId),\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_inherent_implementation_for_type(&*cdata, def_id.node, callback)\n+    decoder::each_inherent_implementation_for_type(&*cdata, def_id.index, callback)\n }\n \n pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n@@ -294,15 +294,15 @@ pub fn get_trait_of_item(cstore: &cstore::CStore,\n                          tcx: &ty::ctxt)\n                          -> Option<DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_trait_of_item(&*cdata, def_id.node, tcx)\n+    decoder::get_trait_of_item(&*cdata, def_id.index, tcx)\n }\n \n pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n                                            def_id: DefId)\n     -> Option<DefId>\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.node)\n+    decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.index)\n }\n \n pub fn get_dylib_dependency_formats(cstore: &cstore::CStore,\n@@ -324,7 +324,7 @@ pub fn get_method_arg_names(cstore: &cstore::CStore, did: DefId)\n     -> Vec<String>\n {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::get_method_arg_names(&*cdata, did.node)\n+    decoder::get_method_arg_names(&*cdata, did.index)\n }\n \n pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n@@ -336,24 +336,24 @@ pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n \n pub fn is_typedef(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_typedef(&*cdata, did.node)\n+    decoder::is_typedef(&*cdata, did.index)\n }\n \n pub fn is_const_fn(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_const_fn(&*cdata, did.node)\n+    decoder::is_const_fn(&*cdata, did.index)\n }\n \n pub fn is_impl(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_impl(&*cdata, did.node)\n+    decoder::is_impl(&*cdata, did.index)\n }\n \n pub fn get_stability(cstore: &cstore::CStore,\n                      def: DefId)\n                      -> Option<attr::Stability> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_stability(&*cdata, def.node)\n+    decoder::get_stability(&*cdata, def.index)\n }\n \n pub fn is_staged_api(cstore: &cstore::CStore, krate: ast::CrateNum) -> bool {\n@@ -363,21 +363,42 @@ pub fn is_staged_api(cstore: &cstore::CStore, krate: ast::CrateNum) -> bool {\n pub fn get_repr_attrs(cstore: &cstore::CStore, def: DefId)\n                       -> Vec<attr::ReprAttr> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_repr_attrs(&*cdata, def.node)\n+    decoder::get_repr_attrs(&*cdata, def.index)\n }\n \n pub fn is_defaulted_trait(cstore: &cstore::CStore, trait_def_id: DefId) -> bool {\n     let cdata = cstore.get_crate_data(trait_def_id.krate);\n-    decoder::is_defaulted_trait(&*cdata, trait_def_id.node)\n+    decoder::is_defaulted_trait(&*cdata, trait_def_id.index)\n }\n \n pub fn is_default_impl(cstore: &cstore::CStore, impl_did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(impl_did.krate);\n-    decoder::is_default_impl(&*cdata, impl_did.node)\n+    decoder::is_default_impl(&*cdata, impl_did.index)\n }\n \n pub fn is_extern_fn(cstore: &cstore::CStore, did: DefId,\n                     tcx: &ty::ctxt) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_extern_fn(&*cdata, did.node, tcx)\n+    decoder::is_extern_fn(&*cdata, did.index, tcx)\n }\n+\n+pub fn closure_kind<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureKind {\n+    assert!(!def_id.is_local());\n+    let cdata = tcx.sess.cstore.get_crate_data(def_id.krate);\n+    decoder::closure_kind(&*cdata, def_id.index)\n+}\n+\n+pub fn closure_ty<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n+    assert!(!def_id.is_local());\n+    let cdata = tcx.sess.cstore.get_crate_data(def_id.krate);\n+    decoder::closure_ty(&*cdata, def_id.index, tcx)\n+}\n+\n+pub fn def_path(tcx: &ty::ctxt, def: DefId) -> ast_map::DefPath {\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    let path = decoder::def_path(&*cdata, def.index);\n+    let local_path = cdata.local_def_path();\n+    local_path.into_iter().chain(path).collect()\n+}\n+"}, {"sha": "c0e7667666c096fbd5ddfc825b30ac1b6e5396f9", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -59,6 +59,7 @@ pub struct ImportedFileMap {\n pub struct crate_metadata {\n     pub name: String,\n     pub local_path: RefCell<SmallVector<ast_map::PathElem>>,\n+    pub local_def_path: RefCell<ast_map::DefPath>,\n     pub data: MetadataBlob,\n     pub cnum_map: RefCell<cnum_map>,\n     pub cnum: ast::CrateNum,\n@@ -111,6 +112,10 @@ pub struct CStore {\n     pub intr: Rc<IdentInterner>,\n }\n \n+/// Item definitions in the currently-compiled crate would have the CrateNum\n+/// LOCAL_CRATE in their DefId.\n+pub const LOCAL_CRATE: ast::CrateNum = 0;\n+\n impl CStore {\n     pub fn new(intr: Rc<IdentInterner>) -> CStore {\n         CStore {\n@@ -310,6 +315,23 @@ impl crate_metadata {\n         }\n     }\n \n+    pub fn local_def_path(&self) -> ast_map::DefPath {\n+        let local_def_path = self.local_def_path.borrow();\n+        if local_def_path.is_empty() {\n+            let name = ast_map::DefPathData::DetachedCrate(token::intern(&self.name));\n+            vec![ast_map::DisambiguatedDefPathData { data: name, disambiguator: 0 }]\n+        } else {\n+            local_def_path.clone()\n+        }\n+    }\n+\n+    pub fn update_local_def_path(&self, candidate: ast_map::DefPath) {\n+        let mut local_def_path = self.local_def_path.borrow_mut();\n+        if local_def_path.is_empty() || candidate.len() < local_def_path.len() {\n+            *local_def_path = candidate;\n+        }\n+    }\n+\n     pub fn is_allocator(&self) -> bool {\n         let attrs = decoder::get_crate_attributes(self.data());\n         attr::contains_name(&attrs, \"allocator\")"}, {"sha": "28d801bb8c98b74ec02a9dd2ef3f8e2c1d4f6129", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 156, "deletions": 100, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -15,11 +15,12 @@\n pub use self::DefLike::*;\n use self::Family::*;\n \n-use front::map as ast_map;\n+use front::map as hir_map;\n use rustc_front::hir;\n \n use back::svh::Svh;\n use metadata::cstore::crate_metadata;\n+use metadata::cstore::LOCAL_CRATE;\n use metadata::common::*;\n use metadata::csearch::MethodInfo;\n use metadata::csearch;\n@@ -29,7 +30,7 @@ use metadata::index;\n use metadata::inline::InlinedItem;\n use metadata::tydecode::TyDecoder;\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::{DefId, DefIndex};\n use middle::lang_items;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n@@ -58,23 +59,23 @@ use syntax::ptr::P;\n pub type Cmd<'a> = &'a crate_metadata;\n \n impl crate_metadata {\n-    fn get_item(&self, item_id: ast::NodeId) -> Option<rbml::Doc> {\n+    fn get_item(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n         self.index.lookup_item(self.data(), item_id).map(|pos| {\n             reader::doc_at(self.data(), pos as usize).unwrap().doc\n         })\n     }\n \n-    fn lookup_item(&self, item_id: ast::NodeId) -> rbml::Doc {\n+    fn lookup_item(&self, item_id: DefIndex) -> rbml::Doc {\n         match self.get_item(item_id) {\n-            None => panic!(\"lookup_item: id not found: {}\", item_id),\n+            None => panic!(\"lookup_item: id not found: {:?}\", item_id),\n             Some(d) => d\n         }\n     }\n }\n \n pub fn load_index(data: &[u8]) -> index::Index {\n     let index = reader::get_doc(rbml::Doc::new(data), tag_index);\n-    index::Index::from_buf(index.data, index.start, index.end)\n+    index::Index::from_rbml(index)\n }\n \n pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n@@ -174,7 +175,8 @@ fn item_symbol(item: rbml::Doc) -> String {\n \n fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> DefId {\n     let id = reader::doc_as_u64(d);\n-    let def_id = DefId { krate: (id >> 32) as u32, node: id as u32 };\n+    let index = DefIndex::new((id & 0xFFFF_FFFF) as usize);\n+    let def_id = DefId { krate: (id >> 32) as u32, index: index };\n     translate_def_id(cdata, def_id)\n }\n \n@@ -207,14 +209,14 @@ fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n fn doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                        &mut |_, did| translate_def_id(cdata, did))\n+                        &mut |did| translate_def_id(cdata, did))\n         .parse_ty()\n }\n \n fn maybe_doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Option<Ty<'tcx>> {\n     reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n         TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                            &mut |_, did| translate_def_id(cdata, did))\n+                            &mut |did| translate_def_id(cdata, did))\n             .parse_ty()\n     })\n }\n@@ -227,7 +229,7 @@ pub fn item_type<'tcx>(_item_id: DefId, item: rbml::Doc,\n fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n                        -> ty::TraitRef<'tcx> {\n     TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                        &mut |_, did| translate_def_id(cdata, did))\n+                        &mut |did| translate_def_id(cdata, did))\n         .parse_trait_ref()\n }\n \n@@ -237,15 +239,15 @@ fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n+fn item_path(item_doc: rbml::Doc) -> Vec<hir_map::PathElem> {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n     reader::docs(path_doc).filter_map(|(tag, elt_doc)| {\n         if tag == tag_path_elem_mod {\n             let s = elt_doc.as_str_slice();\n-            Some(ast_map::PathMod(token::intern(s)))\n+            Some(hir_map::PathMod(token::intern(s)))\n         } else if tag == tag_path_elem_name {\n             let s = elt_doc.as_str_slice();\n-            Some(ast_map::PathName(token::intern(s)))\n+            Some(hir_map::PathName(token::intern(s)))\n         } else {\n             // ignore tag_path_len element\n             None\n@@ -341,7 +343,7 @@ fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n }\n \n pub fn get_trait_def<'tcx>(cdata: Cmd,\n-                           item_id: ast::NodeId,\n+                           item_id: DefIndex,\n                            tcx: &ty::ctxt<'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n@@ -364,7 +366,7 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n \n pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                          cdata: Cmd,\n-                         item_id: ast::NodeId,\n+                         item_id: DefIndex,\n                          tcx: &ty::ctxt<'tcx>) -> ty::AdtDefMaster<'tcx>\n {\n     fn get_enum_variants<'tcx>(intr: &IdentInterner,\n@@ -374,7 +376,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n         let mut disr_val = 0;\n         reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n             let did = translated_def_id(cdata, p);\n-            let item = cdata.lookup_item(did.node);\n+            let item = cdata.lookup_item(did.index);\n \n             if let Some(disr) = variant_disr_val(item) {\n                 disr_val = disr;\n@@ -386,6 +388,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                 did: did,\n                 name: item_name(intr, item),\n                 fields: get_variant_fields(intr, cdata, item, tcx),\n+                ctor_id: did,\n                 disr_val: disr\n             }\n         }).collect()\n@@ -414,23 +417,34 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                                 cdata: Cmd,\n                                 doc: rbml::Doc,\n                                 did: DefId,\n+                                ctor_id: DefId,\n                                 tcx: &ty::ctxt<'tcx>) -> ty::VariantDefData<'tcx, 'tcx> {\n         ty::VariantDefData {\n             did: did,\n             name: item_name(intr, doc),\n             fields: get_variant_fields(intr, cdata, doc, tcx),\n+            ctor_id: ctor_id,\n             disr_val: 0\n         }\n     }\n \n     let doc = cdata.lookup_item(item_id);\n-    let did = DefId { krate: cdata.cnum, node: item_id };\n+    let did = DefId { krate: cdata.cnum, index: item_id };\n     let (kind, variants) = match item_family(doc) {\n-        Enum => (ty::AdtKind::Enum,\n-                 get_enum_variants(intr, cdata, doc, tcx)),\n-        Struct => (ty::AdtKind::Struct,\n-                   vec![get_struct_variant(intr, cdata, doc, did, tcx)]),\n-        _ => tcx.sess.bug(\"get_adt_def called on a non-ADT\")\n+        Enum => {\n+            (ty::AdtKind::Enum,\n+             get_enum_variants(intr, cdata, doc, tcx))\n+        }\n+        Struct => {\n+            let ctor_did =\n+                reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).\n+                map_or(did, |ctor_doc| translated_def_id(cdata, ctor_doc));\n+            (ty::AdtKind::Struct,\n+             vec![get_struct_variant(intr, cdata, doc, did, ctor_did, tcx)])\n+        }\n+        _ => tcx.sess.bug(\n+            &format!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n+                     item_family(doc), did))\n     };\n \n     let adt = tcx.intern_adt_def(did, kind, variants);\n@@ -444,7 +458,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n             // from the ctor.\n             debug!(\"evaluating the ctor-type of {:?}\",\n                    variant.name);\n-            let ctor_ty = get_type(cdata, variant.did.node, tcx).ty;\n+            let ctor_ty = get_type(cdata, variant.did.index, tcx).ty;\n             debug!(\"evaluating the ctor-type of {:?}.. {:?}\",\n                    variant.name,\n                    ctor_ty);\n@@ -464,7 +478,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n         } else {\n             for field in &variant.fields {\n                 debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n-                let ty = get_type(cdata, field.did.node, tcx).ty;\n+                let ty = get_type(cdata, field.did.index, tcx).ty;\n                 field.fulfill_ty(ty);\n                 debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n                        variant.name, field.name, ty);\n@@ -476,7 +490,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n }\n \n pub fn get_predicates<'tcx>(cdata: Cmd,\n-                            item_id: ast::NodeId,\n+                            item_id: DefIndex,\n                             tcx: &ty::ctxt<'tcx>)\n                             -> ty::GenericPredicates<'tcx>\n {\n@@ -485,19 +499,19 @@ pub fn get_predicates<'tcx>(cdata: Cmd,\n }\n \n pub fn get_super_predicates<'tcx>(cdata: Cmd,\n-                                  item_id: ast::NodeId,\n+                                  item_id: DefIndex,\n                                   tcx: &ty::ctxt<'tcx>)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n }\n \n-pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n+pub fn get_type<'tcx>(cdata: Cmd, id: DefIndex, tcx: &ty::ctxt<'tcx>)\n                       -> ty::TypeScheme<'tcx>\n {\n     let item_doc = cdata.lookup_item(id);\n-    let t = item_type(DefId { krate: cdata.cnum, node: id }, item_doc, tcx,\n+    let t = item_type(DefId { krate: cdata.cnum, index: id }, item_doc, tcx,\n                       cdata);\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n     ty::TypeScheme {\n@@ -506,15 +520,15 @@ pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n     }\n }\n \n-pub fn get_stability(cdata: Cmd, id: ast::NodeId) -> Option<attr::Stability> {\n+pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n     let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_item_stability).map(|doc| {\n         let mut decoder = reader::Decoder::new(doc);\n         Decodable::decode(&mut decoder).unwrap()\n     })\n }\n \n-pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n+pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n     let item = cdata.lookup_item(id);\n     match reader::maybe_get_doc(item, tag_items_data_item_repr).map(|doc| {\n         let mut decoder = reader::Decoder::new(doc);\n@@ -526,7 +540,7 @@ pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n }\n \n pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n-                               id: ast::NodeId)\n+                               id: DefIndex)\n                                -> Option<hir::ImplPolarity>\n {\n     let item_doc = cdata.lookup_item(id);\n@@ -541,7 +555,7 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n \n pub fn get_custom_coerce_unsized_kind<'tcx>(\n     cdata: Cmd,\n-    id: ast::NodeId)\n+    id: DefIndex)\n     -> Option<ty::adjustment::CustomCoerceUnsized>\n {\n     let item_doc = cdata.lookup_item(id);\n@@ -552,7 +566,7 @@ pub fn get_custom_coerce_unsized_kind<'tcx>(\n }\n \n pub fn get_impl_trait<'tcx>(cdata: Cmd,\n-                            id: ast::NodeId,\n+                            id: DefIndex,\n                             tcx: &ty::ctxt<'tcx>)\n                             -> Option<ty::TraitRef<'tcx>>\n {\n@@ -568,12 +582,12 @@ pub fn get_impl_trait<'tcx>(cdata: Cmd,\n     }\n }\n \n-pub fn get_symbol(cdata: Cmd, id: ast::NodeId) -> String {\n+pub fn get_symbol(cdata: Cmd, id: DefIndex) -> String {\n     return item_symbol(cdata.lookup_item(id));\n }\n \n /// If you have a crate_metadata, call get_symbol instead\n-pub fn get_symbol_from_buf(data: &[u8], id: ast::NodeId) -> String {\n+pub fn get_symbol_from_buf(data: &[u8], id: DefIndex) -> String {\n     let index = load_index(data);\n     let pos = index.lookup_item(data, id).unwrap();\n     let doc = reader::doc_at(data, pos as usize).unwrap().doc;\n@@ -590,18 +604,17 @@ pub enum DefLike {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n-    F: FnMut(ast::NodeId, usize) -> bool,\n+    F: FnMut(DefIndex, usize) -> bool,\n {\n     let root = rbml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item).all(|item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n         let id = reader::doc_as_u32(id_doc) as usize;\n-        let node_id_doc = reader::get_doc(item_doc,\n-                                          tag_lang_items_item_node_id);\n-        let node_id = reader::doc_as_u32(node_id_doc) as ast::NodeId;\n+        let index_doc = reader::get_doc(item_doc, tag_lang_items_item_index);\n+        let index = DefIndex::from_u32(reader::doc_as_u32(index_doc));\n \n-        f(node_id, id)\n+        f(index, id)\n     })\n }\n \n@@ -630,7 +643,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         };\n \n         // Get the item.\n-        match crate_data.get_item(child_def_id.node) {\n+        match crate_data.get_item(child_def_id.index) {\n             None => {}\n             Some(child_item_doc) => {\n                 // Hand off the item to the callback.\n@@ -648,12 +661,12 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n     for inherent_impl_def_id_doc in reader::tagged_docs(item_doc,\n                                                              tag_items_data_item_inherent_impl) {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc, cdata);\n-        if let Some(inherent_impl_doc) = cdata.get_item(inherent_impl_def_id.node) {\n+        if let Some(inherent_impl_doc) = cdata.get_item(inherent_impl_def_id.index) {\n             for impl_item_def_id_doc in reader::tagged_docs(inherent_impl_doc,\n                                                                  tag_item_impl_item) {\n                 let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n                                                    cdata);\n-                if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.node) {\n+                if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.index) {\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n                         let static_method_name = item_name(&*intr, impl_method_doc);\n@@ -689,7 +702,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         };\n \n         // Get the item.\n-        if let Some(child_item_doc) = crate_data.get_item(child_def_id.node) {\n+        if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n             // Hand off the item to the callback.\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n@@ -702,7 +715,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n /// Iterates over each child of the given item.\n pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n                                cdata: Cmd,\n-                               id: ast::NodeId,\n+                               id: DefIndex,\n                                get_crate_data: G,\n                                callback: F) where\n     F: FnMut(DefLike, ast::Name, hir::Visibility),\n@@ -741,34 +754,39 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                 callback)\n }\n \n-pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n+pub fn get_item_path(cdata: Cmd, id: DefIndex) -> Vec<hir_map::PathElem> {\n     item_path(cdata.lookup_item(id))\n }\n \n-pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId) -> ast::Name {\n+pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Name {\n     item_name(intr, cdata.lookup_item(id))\n }\n \n pub type DecodeInlinedItem<'a> =\n     Box<for<'tcx> FnMut(Cmd,\n                         &ty::ctxt<'tcx>,\n-                        Vec<ast_map::PathElem>,\n-                        rbml::Doc)\n-                        -> Result<&'tcx InlinedItem, Vec<ast_map::PathElem>> + 'a>;\n-\n-pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeId,\n+                        Vec<hir_map::PathElem>,\n+                        hir_map::DefPath,\n+                        rbml::Doc,\n+                        DefId)\n+                        -> Result<&'tcx InlinedItem, (Vec<hir_map::PathElem>,\n+                                                      hir_map::DefPath)> + 'a>;\n+\n+pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: DefIndex,\n                                 mut decode_inlined_item: DecodeInlinedItem)\n                                 -> csearch::FoundAst<'tcx> {\n-    debug!(\"Looking up item: {}\", id);\n+    debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n+    let item_did = item_def_id(item_doc, cdata);\n     let path = item_path(item_doc).split_last().unwrap().1.to_vec();\n-    match decode_inlined_item(cdata, tcx, path, item_doc) {\n+    let def_path = def_path(cdata, id);\n+    match decode_inlined_item(cdata, tcx, path, def_path, item_doc, item_did) {\n         Ok(ii) => csearch::FoundAst::Found(ii),\n-        Err(path) => {\n+        Err((path, def_path)) => {\n             match item_parent_item(cdata, item_doc) {\n                 Some(did) => {\n-                    let parent_item = cdata.lookup_item(did.node);\n-                    match decode_inlined_item(cdata, tcx, path, parent_item) {\n+                    let parent_item = cdata.lookup_item(did.index);\n+                    match decode_inlined_item(cdata, tcx, path, def_path, parent_item, did) {\n                         Ok(ii) => csearch::FoundAst::FoundParent(did, ii),\n                         Err(_) => csearch::FoundAst::NotFound\n                     }\n@@ -807,7 +825,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n }\n \n /// Returns the def IDs of all the items in the given implementation.\n-pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n+pub fn get_impl_items(cdata: Cmd, impl_id: DefIndex)\n                       -> Vec<ty::ImplOrTraitItemId> {\n     reader::tagged_docs(cdata.lookup_item(impl_id), tag_item_impl_item).map(|doc| {\n         let def_id = item_def_id(doc, cdata);\n@@ -822,13 +840,13 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n \n pub fn get_trait_name(intr: Rc<IdentInterner>,\n                       cdata: Cmd,\n-                      id: ast::NodeId)\n+                      id: DefIndex)\n                       -> ast::Name {\n     let doc = cdata.lookup_item(id);\n     item_name(&*intr, doc)\n }\n \n-pub fn is_static_method(cdata: Cmd, id: ast::NodeId) -> bool {\n+pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n     let doc = cdata.lookup_item(id);\n     match item_sort(doc) {\n         Some('r') | Some('p') => {\n@@ -840,15 +858,15 @@ pub fn is_static_method(cdata: Cmd, id: ast::NodeId) -> bool {\n \n pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n-                                    id: ast::NodeId,\n+                                    id: DefIndex,\n                                     tcx: &ty::ctxt<'tcx>)\n                                     -> ty::ImplOrTraitItem<'tcx> {\n     let item_doc = cdata.lookup_item(id);\n \n     let def_id = item_def_id(item_doc, cdata);\n \n     let container_id = item_require_parent_item(cdata, item_doc);\n-    let container_doc = cdata.lookup_item(container_id.node);\n+    let container_doc = cdata.lookup_item(container_id.index);\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n         _ => ImplContainer(container_id),\n@@ -904,7 +922,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     }\n }\n \n-pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n+pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n                               -> Vec<ty::ImplOrTraitItemId> {\n     let item = cdata.lookup_item(id);\n     reader::tagged_docs(item, tag_item_trait_item).map(|mth| {\n@@ -918,7 +936,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n     }).collect()\n }\n \n-pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n+pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> ty::ItemVariances {\n     let item_doc = cdata.lookup_item(id);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n     let mut decoder = reader::Decoder::new(variance_doc);\n@@ -927,19 +945,19 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n \n pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                         cdata: Cmd,\n-                                        id: ast::NodeId,\n+                                        id: DefIndex,\n                                         tcx: &ty::ctxt<'tcx>)\n                                         -> Vec<Rc<ty::Method<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n     reader::tagged_docs(item, tag_item_trait_item).filter_map(|mth_id| {\n         let did = item_def_id(mth_id, cdata);\n-        let mth = cdata.lookup_item(did.node);\n+        let mth = cdata.lookup_item(did.index);\n \n         if item_sort(mth) == Some('p') {\n             let trait_item = get_impl_or_trait_item(intr.clone(),\n                                                     cdata,\n-                                                    did.node,\n+                                                    did.index,\n                                                     tcx);\n             if let ty::MethodTraitItem(ref method) = trait_item {\n                 Some((*method).clone())\n@@ -954,21 +972,21 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n \n pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n                                    cdata: Cmd,\n-                                   id: ast::NodeId,\n+                                   id: DefIndex,\n                                    tcx: &ty::ctxt<'tcx>)\n                                    -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n     [tag_item_trait_item, tag_item_impl_item].iter().flat_map(|&tag| {\n         reader::tagged_docs(item, tag).filter_map(|ac_id| {\n             let did = item_def_id(ac_id, cdata);\n-            let ac_doc = cdata.lookup_item(did.node);\n+            let ac_doc = cdata.lookup_item(did.index);\n \n             match item_sort(ac_doc) {\n                 Some('C') | Some('c') => {\n                     let trait_item = get_impl_or_trait_item(intr.clone(),\n                                                             cdata,\n-                                                            did.node,\n+                                                            did.index,\n                                                             tcx);\n                     if let ty::ConstTraitItem(ref ac) = trait_item {\n                         Some((*ac).clone())\n@@ -984,7 +1002,7 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n \n pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n                                   cdata: Cmd,\n-                                  node_id: ast::NodeId)\n+                                  node_id: DefIndex)\n                                -> Option<Vec<MethodInfo> > {\n     let item = cdata.lookup_item(node_id);\n     if item_family(item) != Impl {\n@@ -1001,7 +1019,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n \n     let mut impl_methods = Vec::new();\n     for impl_method_id in impl_method_ids {\n-        let impl_method_doc = cdata.lookup_item(impl_method_id.node);\n+        let impl_method_doc = cdata.lookup_item(impl_method_id.index);\n         let family = item_family(impl_method_doc);\n         match family {\n             StaticMethod | Method => {\n@@ -1021,7 +1039,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n /// If node_id is the constructor of a tuple struct, retrieve the NodeId of\n /// the actual type definition, otherwise, return None\n pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n-                                           node_id: ast::NodeId)\n+                                           node_id: DefIndex)\n     -> Option<DefId>\n {\n     let item = cdata.lookup_item(node_id);\n@@ -1031,24 +1049,24 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n }\n \n pub fn get_item_attrs(cdata: Cmd,\n-                      orig_node_id: ast::NodeId)\n+                      orig_node_id: DefIndex)\n                       -> Vec<ast::Attribute> {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n     let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n-    let node_id = node_id.map(|x| x.node).unwrap_or(orig_node_id);\n+    let node_id = node_id.map(|x| x.index).unwrap_or(orig_node_id);\n     let item = cdata.lookup_item(node_id);\n     get_attributes(item)\n }\n \n-pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<ast::NodeId, Vec<ast::Attribute>> {\n+pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<DefId, Vec<ast::Attribute>> {\n     let data = rbml::Doc::new(cdata.data());\n     let fields = reader::get_doc(data, tag_struct_fields);\n     reader::tagged_docs(fields, tag_struct_field).map(|field| {\n-        let id = reader::doc_as_u32(reader::get_doc(field, tag_struct_field_id));\n+        let def_id = translated_def_id(cdata, reader::get_doc(field, tag_def_id));\n         let attrs = get_attributes(field);\n-        (id, attrs)\n+        (def_id, attrs)\n     }).collect()\n }\n \n@@ -1060,7 +1078,7 @@ fn struct_field_family_to_visibility(family: Family) -> hir::Visibility {\n     }\n }\n \n-pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId)\n+pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: DefIndex)\n     -> Vec<ast::Name> {\n     let item = cdata.lookup_item(id);\n     reader::tagged_docs(item, tag_item_field).map(|an_item| {\n@@ -1218,14 +1236,14 @@ pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()>\n // crate to the correct local crate number.\n pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n     if did.is_local() {\n-        return DefId { krate: cdata.cnum, node: did.node };\n+        return DefId { krate: cdata.cnum, index: did.index };\n     }\n \n     match cdata.cnum_map.borrow().get(&did.krate) {\n         Some(&n) => {\n             DefId {\n                 krate: n,\n-                node: did.node,\n+                index: did.index,\n             }\n         }\n         None => panic!(\"didn't find a crate in the cnum_map\")\n@@ -1236,20 +1254,20 @@ pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n // for an external crate.\n fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n     if did.krate == cdata.cnum {\n-        return Some(DefId { krate: LOCAL_CRATE, node: did.node });\n+        return Some(DefId { krate: LOCAL_CRATE, index: did.index });\n     }\n \n     for (&local, &global) in cdata.cnum_map.borrow().iter() {\n         if global == did.krate {\n-            return Some(DefId { krate: local, node: did.node });\n+            return Some(DefId { krate: local, index: did.index });\n         }\n     }\n \n     None\n }\n \n pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n-                                                id: ast::NodeId,\n+                                                id: DefIndex,\n                                                 mut callback: F)\n     where F: FnMut(DefId),\n {\n@@ -1267,7 +1285,7 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     F: FnMut(DefId),\n {\n     if cdata.cnum == def_id.krate {\n-        let item_doc = cdata.lookup_item(def_id.node);\n+        let item_doc = cdata.lookup_item(def_id.index);\n         for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_extension_impl) {\n             callback(item_def_id(impl_doc, cdata));\n         }\n@@ -1289,14 +1307,14 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     }\n }\n \n-pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n+pub fn get_trait_of_item(cdata: Cmd, id: DefIndex, tcx: &ty::ctxt)\n                          -> Option<DefId> {\n     let item_doc = cdata.lookup_item(id);\n     let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n         Some(item_id) => item_id,\n     };\n-    let parent_item_doc = cdata.lookup_item(parent_item_id.node);\n+    let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n         Impl | DefaultImpl => {\n@@ -1322,9 +1340,9 @@ pub fn get_native_libraries(cdata: Cmd)\n     }).collect()\n }\n \n-pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n+pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n     reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n-        .map(|doc| reader::doc_as_u32(doc))\n+        .map(|doc| DefIndex::from_u32(reader::doc_as_u32(doc)))\n }\n \n pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n@@ -1376,7 +1394,7 @@ pub fn get_missing_lang_items(cdata: Cmd)\n     }).collect()\n }\n \n-pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n+pub fn get_method_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n     let method_doc = cdata.lookup_item(id);\n     match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n         Some(args_doc) => {\n@@ -1394,28 +1412,28 @@ pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n     reader::tagged_docs(items, tag_reachable_id).map(|doc| {\n         DefId {\n             krate: cdata.cnum,\n-            node: reader::doc_as_u32(doc),\n+            index: DefIndex::from_u32(reader::doc_as_u32(doc)),\n         }\n     }).collect()\n }\n \n-pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n+pub fn is_typedef(cdata: Cmd, id: DefIndex) -> bool {\n     let item_doc = cdata.lookup_item(id);\n     match item_family(item_doc) {\n         Type => true,\n         _ => false,\n     }\n }\n \n-pub fn is_const_fn(cdata: Cmd, id: ast::NodeId) -> bool {\n+pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n     let item_doc = cdata.lookup_item(id);\n     match fn_constness(item_doc) {\n         hir::Constness::Const => true,\n         hir::Constness::NotConst => false,\n     }\n }\n \n-pub fn is_impl(cdata: Cmd, id: ast::NodeId) -> bool {\n+pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n     let item_doc = cdata.lookup_item(id);\n     match item_family(item_doc) {\n         Impl => true,\n@@ -1435,7 +1453,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n     for p in reader::tagged_docs(doc, tag_type_param_def) {\n         let bd =\n             TyDecoder::with_doc(tcx, cdata.cnum, p,\n-                                &mut |_, did| translate_def_id(cdata, did))\n+                                &mut |did| translate_def_id(cdata, did))\n             .parse_type_param_def();\n         types.push(bd.space, bd);\n     }\n@@ -1457,7 +1475,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n \n         let bounds = reader::tagged_docs(rp_doc, tag_items_data_region).map(|p| {\n             TyDecoder::with_doc(tcx, cdata.cnum, p,\n-                                &mut |_, did| translate_def_id(cdata, did))\n+                                &mut |did| translate_def_id(cdata, did))\n             .parse_region()\n         }).collect();\n \n@@ -1480,7 +1498,7 @@ fn doc_predicate<'tcx>(cdata: Cmd,\n         cdata.data(), reader::doc_as_u32(doc)).unwrap() as usize;\n     TyDecoder::new(\n         cdata.data(), cdata.cnum, predicate_pos, tcx,\n-        &mut |_, did| translate_def_id(cdata, did)\n+        &mut |did| translate_def_id(cdata, did)\n     ).parse_predicate()\n }\n \n@@ -1509,14 +1527,14 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n     ty::GenericPredicates { predicates: predicates }\n }\n \n-pub fn is_defaulted_trait(cdata: Cmd, trait_id: ast::NodeId) -> bool {\n+pub fn is_defaulted_trait(cdata: Cmd, trait_id: DefIndex) -> bool {\n     let trait_doc = cdata.lookup_item(trait_id);\n     assert!(item_family(trait_doc) == Family::Trait);\n     let defaulted_doc = reader::get_doc(trait_doc, tag_defaulted_trait);\n     reader::doc_as_u8(defaulted_doc) != 0\n }\n \n-pub fn is_default_impl(cdata: Cmd, impl_id: ast::NodeId) -> bool {\n+pub fn is_default_impl(cdata: Cmd, impl_id: DefIndex) -> bool {\n     let impl_doc = cdata.lookup_item(impl_id);\n     item_family(impl_doc) == Family::DefaultImpl\n }\n@@ -1531,7 +1549,7 @@ pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {\n     }).collect()\n }\n \n-pub fn is_extern_fn(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt) -> bool {\n+pub fn is_extern_fn(cdata: Cmd, id: DefIndex, tcx: &ty::ctxt) -> bool {\n     let item_doc = match cdata.get_item(id) {\n         Some(doc) => doc,\n         None => return false,\n@@ -1546,3 +1564,41 @@ pub fn is_extern_fn(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt) -> bool {\n         false\n     }\n }\n+\n+pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n+    let closure_doc = cdata.lookup_item(closure_id);\n+    let closure_kind_doc = reader::get_doc(closure_doc, tag_items_closure_kind);\n+    let mut decoder = reader::Decoder::new(closure_kind_doc);\n+    ty::ClosureKind::decode(&mut decoder).unwrap()\n+}\n+\n+pub fn closure_ty<'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: &ty::ctxt<'tcx>)\n+                        -> ty::ClosureTy<'tcx> {\n+    let closure_doc = cdata.lookup_item(closure_id);\n+    let closure_ty_doc = reader::get_doc(closure_doc, tag_items_closure_ty);\n+    TyDecoder::with_doc(tcx, cdata.cnum, closure_ty_doc, &mut |did| translate_def_id(cdata, did))\n+        .parse_closure_ty()\n+}\n+\n+fn def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n+    match reader::maybe_get_doc(item_doc, tag_def_key) {\n+        Some(def_key_doc) => {\n+            let mut decoder = reader::Decoder::new(def_key_doc);\n+            hir_map::DefKey::decode(&mut decoder).unwrap()\n+        }\n+        None => {\n+            panic!(\"failed to find block with tag {:?} for item with family {:?}\",\n+                   tag_def_key,\n+                   item_family(item_doc))\n+        }\n+    }\n+}\n+\n+pub fn def_path(cdata: Cmd, id: DefIndex) -> hir_map::DefPath {\n+    debug!(\"def_path(id={:?})\", id);\n+    hir_map::definitions::make_def_path(id, |parent| {\n+        debug!(\"def_path: parent={:?}\", parent);\n+        let parent_doc = cdata.lookup_item(parent);\n+        def_key(parent_doc)\n+    })\n+}"}, {"sha": "caccdbd338269c7c1d39c88cc9ea5a945d4af35d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 196, "deletions": 233, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -17,12 +17,13 @@ use back::svh::Svh;\n use session::config;\n use metadata::common::*;\n use metadata::cstore;\n+use metadata::cstore::LOCAL_CRATE;\n use metadata::decoder;\n use metadata::tyencode;\n-use metadata::index::{self, IndexEntry};\n+use metadata::index::{self, IndexData};\n use metadata::inline::InlinedItemRef;\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n use middle::stability;\n use middle::subst;\n@@ -34,6 +35,7 @@ use std::cell::RefCell;\n use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n+use std::u32;\n use syntax::abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::attr;\n@@ -75,21 +77,25 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub reachable: &'a NodeSet,\n }\n \n+impl<'a, 'tcx> EncodeContext<'a,'tcx> {\n+    fn local_id(&self, def_id: DefId) -> NodeId {\n+        self.tcx.map.as_local_node_id(def_id).unwrap()\n+    }\n+}\n+\n /// \"interned\" entries referenced by id\n #[derive(PartialEq, Eq, Hash)]\n pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n \n struct CrateIndex<'tcx> {\n-    items: Vec<IndexEntry>,\n+    items: IndexData,\n     xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n }\n \n impl<'tcx> CrateIndex<'tcx> {\n-    fn index_item(&mut self, rbml_w: &mut Encoder, id: NodeId) {\n-        self.items.push(IndexEntry {\n-            node: id,\n-            pos: rbml_w.mark_stable_position(),\n-        });\n+    fn record(&mut self, id: DefId, rbml_w: &mut Encoder) {\n+        let position = rbml_w.mark_stable_position();\n+        self.items.record(id, position);\n     }\n \n     fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n@@ -106,6 +112,26 @@ fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n     rbml_w.wr_tagged_u64(tag_def_id, def_to_u64(id));\n }\n \n+/// For every DefId that we create a metadata item for, we include a\n+/// serialized copy of its DefKey, which allows us to recreate a path.\n+fn encode_def_id_and_key(ecx: &EncodeContext,\n+                         rbml_w: &mut Encoder,\n+                         def_id: DefId)\n+{\n+    encode_def_id(rbml_w, def_id);\n+    encode_def_key(ecx, rbml_w, def_id);\n+}\n+\n+fn encode_def_key(ecx: &EncodeContext,\n+                  rbml_w: &mut Encoder,\n+                  def_id: DefId)\n+{\n+    rbml_w.start_tag(tag_def_key);\n+    let def_key = ecx.tcx.map.def_key(def_id);\n+    def_key.encode(rbml_w);\n+    rbml_w.end_tag();\n+}\n+\n fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a, 'tcx>,\n                               trait_ref: ty::TraitRef<'tcx>,\n@@ -128,17 +154,18 @@ fn encode_family(rbml_w: &mut Encoder, c: char) {\n }\n \n pub fn def_to_u64(did: DefId) -> u64 {\n-    (did.krate as u64) << 32 | (did.node as u64)\n+    assert!(did.index.as_u32() < u32::MAX);\n+    (did.krate as u64) << 32 | (did.index.as_usize() as u64)\n }\n \n pub fn def_to_string(did: DefId) -> String {\n-    format!(\"{}:{}\", did.krate, did.node)\n+    format!(\"{}:{}\", did.krate, did.index.as_usize())\n }\n \n fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: NodeId) {\n-    let v = ecx.tcx.item_variances(DefId::local(id));\n+    let v = ecx.tcx.item_variances(ecx.tcx.map.local_def_id(id));\n     rbml_w.start_tag(tag_item_variances);\n     v.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -151,8 +178,8 @@ fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n                            index,\n-                           &ecx.tcx.lookup_item_type(DefId::local(id)),\n-                           &ecx.tcx.lookup_predicates(DefId::local(id)));\n+                           &ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n+                           &ecx.tcx.lookup_predicates(ecx.tcx.map.local_def_id(id)));\n }\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n@@ -283,10 +310,10 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n-    let def = ecx.tcx.lookup_adt_def(DefId::local(id));\n+    let def = ecx.tcx.lookup_adt_def(ecx.tcx.map.local_def_id(id));\n     for variant in &def.variants {\n         let vid = variant.did;\n-        assert!(vid.is_local());\n+        let variant_node_id = ecx.local_id(vid);\n \n         if let ty::VariantKind::Dict = variant.kind() {\n             // tuple-like enum variant fields aren't really items so\n@@ -296,15 +323,15 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             }\n         }\n \n-        index.index_item(rbml_w, vid.node);\n+        index.record(vid, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, vid);\n+        encode_def_id_and_key(ecx, rbml_w, vid);\n         encode_family(rbml_w, match variant.kind() {\n             ty::VariantKind::Unit | ty::VariantKind::Tuple => 'v',\n             ty::VariantKind::Dict => 'V'\n         });\n         encode_name(rbml_w, variant.name);\n-        encode_parent_item(rbml_w, DefId::local(id));\n+        encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(id));\n         encode_visibility(rbml_w, vis);\n \n         let attrs = ecx.tcx.get_attrs(vid);\n@@ -321,9 +348,9 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_disr_val(ecx, rbml_w, specified_disr_val);\n             disr_val = specified_disr_val;\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, index, vid.node);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, variant_node_id);\n \n-        ecx.tcx.map.with_path(vid.node, |path| encode_path(rbml_w, path));\n+        ecx.tcx.map.with_path(variant_node_id, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n         disr_val = disr_val.wrapping_add(1);\n     }\n@@ -343,107 +370,6 @@ fn encode_path<PI: Iterator<Item=PathElem>>(rbml_w: &mut Encoder, path: PI) {\n     rbml_w.end_tag();\n }\n \n-fn encode_reexported_static_method(rbml_w: &mut Encoder,\n-                                   exp: &def::Export,\n-                                   method_def_id: DefId,\n-                                   method_name: Name) {\n-    debug!(\"(encode reexported static method) {}::{}\",\n-            exp.name, method_name);\n-    rbml_w.start_tag(tag_items_data_item_reexport);\n-    rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n-                         def_to_u64(method_def_id));\n-    rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n-                         &format!(\"{}::{}\", exp.name,\n-                                            method_name));\n-    rbml_w.end_tag();\n-}\n-\n-fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n-                                         rbml_w: &mut Encoder,\n-                                         exp: &def::Export)\n-                                         -> bool {\n-    let impl_items = ecx.tcx.impl_items.borrow();\n-    match ecx.tcx.inherent_impls.borrow().get(&exp.def_id) {\n-        Some(implementations) => {\n-            for base_impl_did in implementations.iter() {\n-                for &method_did in impl_items.get(base_impl_did).unwrap() {\n-                    let impl_item = ecx.tcx.impl_or_trait_item(method_did.def_id());\n-                    if let ty::MethodTraitItem(ref m) = impl_item {\n-                        encode_reexported_static_method(rbml_w,\n-                                                        exp,\n-                                                        m.def_id,\n-                                                        m.name);\n-                    }\n-                }\n-            }\n-\n-            true\n-        }\n-        None => { false }\n-    }\n-}\n-\n-fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n-                                          rbml_w: &mut Encoder,\n-                                          exp: &def::Export)\n-                                          -> bool {\n-    match ecx.tcx.trait_items_cache.borrow().get(&exp.def_id) {\n-        Some(trait_items) => {\n-            for trait_item in trait_items.iter() {\n-                if let ty::MethodTraitItem(ref m) = *trait_item {\n-                    encode_reexported_static_method(rbml_w,\n-                                                    exp,\n-                                                    m.def_id,\n-                                                    m.name);\n-                }\n-            }\n-            true\n-        }\n-        None => { false }\n-    }\n-}\n-\n-fn encode_reexported_static_methods(ecx: &EncodeContext,\n-                                    rbml_w: &mut Encoder,\n-                                    mod_path: PathElems,\n-                                    exp: &def::Export) {\n-    if let Some(ast_map::NodeItem(item)) = ecx.tcx.map.find(exp.def_id.node) {\n-        let path_differs = ecx.tcx.map.with_path(exp.def_id.node, |path| {\n-            let (mut a, mut b) = (path, mod_path.clone());\n-            loop {\n-                match (a.next(), b.next()) {\n-                    (None, None) => return true,\n-                    (None, _) | (_, None) => return false,\n-                    (Some(x), Some(y)) => if x != y { return false },\n-                }\n-            }\n-        });\n-\n-        //\n-        // We don't need to reexport static methods on items\n-        // declared in the same module as our `pub use ...` since\n-        // that's done when we encode the item itself.\n-        //\n-        // The only exception is when the reexport *changes* the\n-        // name e.g. `pub use Foo = self::Bar` -- we have\n-        // encoded metadata for static methods relative to Bar,\n-        // but not yet for Foo.\n-        //\n-        if path_differs || item.name != exp.name {\n-            if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n-                if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n-                    debug!(\"(encode reexported static methods) {} [trait]\",\n-                           item.name);\n-                }\n-            }\n-            else {\n-                debug!(\"(encode reexported static methods) {} [base]\",\n-                       item.name);\n-            }\n-        }\n-    }\n-}\n-\n /// Iterates through \"auxiliary node IDs\", which are node IDs that describe\n /// top-level items that are sub-items of the given item. Specifically:\n ///\n@@ -471,26 +397,23 @@ fn each_auxiliary_node_id<F>(item: &hir::Item, callback: F) -> bool where\n \n fn encode_reexports(ecx: &EncodeContext,\n                     rbml_w: &mut Encoder,\n-                    id: NodeId,\n-                    path: PathElems) {\n+                    id: NodeId) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n     match ecx.reexports.get(&id) {\n         Some(exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports {\n-                debug!(\"(encoding info for module) reexport '{}' ({}/{}) for \\\n+                debug!(\"(encoding info for module) reexport '{}' ({:?}) for \\\n                         {}\",\n                        exp.name,\n-                       exp.def_id.krate,\n-                       exp.def_id.node,\n+                       exp.def_id,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n                                      def_to_u64(exp.def_id));\n                 rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n                                      &exp.name.as_str());\n                 rbml_w.end_tag();\n-                encode_reexported_static_methods(ecx, rbml_w, path.clone(), exp);\n             }\n         },\n         None => debug!(\"(encoding info for module) found no reexports for {}\", id),\n@@ -506,33 +429,33 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        name: Name,\n                        vis: hir::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, DefId::local(id));\n+    encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n     encode_family(rbml_w, 'm');\n     encode_name(rbml_w, name);\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n     for item in &md.items {\n         rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(DefId::local(item.id)));\n+                             def_to_u64(ecx.tcx.map.local_def_id(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(DefId::local(auxiliary_node_id)));\n+                                 def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n             true\n         });\n     }\n \n     encode_path(rbml_w, path.clone());\n     encode_visibility(rbml_w, vis);\n \n-    let stab = stability::lookup(ecx.tcx, DefId::local(id));\n+    let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(id));\n     encode_stability(rbml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == hir::Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-        encode_reexports(ecx, rbml_w, id, path);\n+        encode_reexports(ecx, rbml_w, id);\n     }\n     encode_attributes(rbml_w, attrs);\n \n@@ -604,15 +527,15 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           field: ty::FieldDef<'tcx>,\n                           index: &mut CrateIndex<'tcx>) {\n     let nm = field.name;\n-    let id = field.did.node;\n+    let id = ecx.local_id(field.did);\n \n-    index.index_item(rbml_w, id);\n+    index.record(field.did, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     debug!(\"encode_field: encoding {} {}\", nm, id);\n     encode_struct_field_family(rbml_w, field.vis);\n     encode_name(rbml_w, nm);\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, id);\n-    encode_def_id(rbml_w, DefId::local(id));\n+    encode_def_id_and_key(ecx, rbml_w, field.did);\n \n     let stab = stability::lookup(ecx.tcx, field.did);\n     encode_stability(rbml_w, stab);\n@@ -626,20 +549,22 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                          ctor_id: NodeId,\n                                          index: &mut CrateIndex<'tcx>,\n                                          struct_id: NodeId) {\n-    index.index_item(rbml_w, ctor_id);\n+    let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n+\n+    index.record(ctor_def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, DefId::local(ctor_id));\n+    encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n     encode_family(rbml_w, 'o');\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, ctor_id);\n     encode_name(rbml_w, name);\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n-    encode_parent_item(rbml_w, DefId::local(struct_id));\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n \n     if ecx.item_symbols.borrow().contains_key(&ctor_id) {\n         encode_symbol(ecx, rbml_w, ctor_id);\n     }\n \n-    let stab = stability::lookup(ecx.tcx, DefId::local(ctor_id));\n+    let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n     encode_stability(rbml_w, stab);\n \n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n@@ -734,7 +659,7 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                      rbml_w: &mut Encoder,\n                                      index: &mut CrateIndex<'tcx>,\n                                      method_ty: &ty::Method<'tcx>) {\n-    encode_def_id(rbml_w, method_ty.def_id);\n+    encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n     encode_generics(rbml_w, ecx, index,\n                     &method_ty.generics, &method_ty.predicates,\n@@ -760,19 +685,19 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n            associated_const.def_id,\n            associated_const.name);\n \n-    index.index_item(rbml_w, associated_const.def_id.node);\n+    index.record(associated_const.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n-    encode_def_id(rbml_w, associated_const.def_id);\n+    encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n     encode_name(rbml_w, associated_const.name);\n     encode_visibility(rbml_w, associated_const.vis);\n     encode_family(rbml_w, 'C');\n \n-    encode_parent_item(rbml_w, DefId::local(parent_id));\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'C');\n \n     encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                    associated_const.def_id.local_id());\n+                                    ecx.local_id(associated_const.def_id));\n \n     let stab = stability::lookup(ecx.tcx, associated_const.def_id);\n     encode_stability(rbml_w, stab);\n@@ -782,7 +707,10 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(DefId::local(parent_id), ii));\n+        encode_inlined_item(ecx,\n+                            rbml_w,\n+                            InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                     ii));\n     }\n \n     rbml_w.end_tag();\n@@ -799,17 +727,18 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            m.name);\n-    index.index_item(rbml_w, m.def_id.node);\n+    index.record(m.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_method_ty_fields(ecx, rbml_w, index, m);\n-    encode_parent_item(rbml_w, DefId::local(parent_id));\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'r');\n \n     let stab = stability::lookup(ecx.tcx, m.def_id);\n     encode_stability(rbml_w, stab);\n \n-    encode_bounds_and_type_for_item(rbml_w, ecx, index, m.def_id.local_id());\n+    let m_node_id = ecx.local_id(m.def_id);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, index, m_node_id);\n \n     let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem)));\n@@ -821,12 +750,15 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             let needs_inline = any_types || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n             if needs_inline || sig.constness == hir::Constness::Const {\n-                encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(DefId::local(parent_id),\n-                                                               impl_item));\n+                encode_inlined_item(ecx,\n+                                    rbml_w,\n+                                    InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                             impl_item));\n             }\n             encode_constness(rbml_w, sig.constness);\n             if !any_types {\n-                encode_symbol(ecx, rbml_w, m.def_id.node);\n+                let m_id = ecx.local_id(m.def_id);\n+                encode_symbol(ecx, rbml_w, m_id);\n             }\n             encode_method_argument_names(rbml_w, &sig.decl);\n         }\n@@ -846,14 +778,14 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n            associated_type.def_id,\n            associated_type.name);\n \n-    index.index_item(rbml_w, associated_type.def_id.node);\n+    index.record(associated_type.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n-    encode_def_id(rbml_w, associated_type.def_id);\n+    encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n     encode_name(rbml_w, associated_type.name);\n     encode_visibility(rbml_w, associated_type.vis);\n     encode_family(rbml_w, 'y');\n-    encode_parent_item(rbml_w, DefId::local(parent_id));\n+    encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 't');\n \n     let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n@@ -994,14 +926,14 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n-    let def_id = DefId::local(item.id);\n-    let stab = stability::lookup(tcx, DefId::local(item.id));\n+    let def_id = ecx.tcx.map.local_def_id(item.id);\n+    let stab = stability::lookup(tcx, ecx.tcx.map.local_def_id(item.id));\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         if m == hir::MutMutable {\n             encode_family(rbml_w, 'b');\n         } else {\n@@ -1017,9 +949,9 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemConst(_, _) => {\n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n@@ -1031,9 +963,9 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, FN_FAMILY);\n         let tps_len = generics.ty_params.len();\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n@@ -1054,7 +986,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemMod(ref m) => {\n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n@@ -1065,26 +997,26 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'n');\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n \n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(DefId::local(foreign_item.id)));\n+                                 def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n       hir::ItemTy(..) => {\n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n@@ -1094,18 +1026,18 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         rbml_w.end_tag();\n       }\n       hir::ItemEnum(ref enum_definition, _) => {\n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n \n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 't');\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n         for v in &enum_definition.variants {\n-            encode_variant_id(rbml_w, DefId::local(v.node.id));\n+            encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.id));\n         }\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_path(rbml_w, path);\n@@ -1128,11 +1060,11 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let variant = def.struct_variant();\n \n         /* Index the class*/\n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n \n         /* Now, make an item for the class itself */\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'S');\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n \n@@ -1154,30 +1086,33 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n \n+        if let Some(ctor_id) = struct_def.ctor_id {\n+            let ctor_did = ecx.tcx.map.local_def_id(ctor_id);\n+            rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n+                                 def_to_u64(ctor_did));\n+        }\n+\n         rbml_w.end_tag();\n \n         for field in &variant.fields {\n             encode_field(ecx, rbml_w, field, index);\n         }\n \n         // If this is a tuple-like struct, encode the type of the constructor.\n-        match struct_def.ctor_id {\n-            Some(ctor_id) => {\n-                encode_info_for_struct_ctor(ecx, rbml_w, item.name,\n-                                            ctor_id, index, def_id.node);\n-            }\n-            None => {}\n+        if let Some(ctor_id) = struct_def.ctor_id {\n+            encode_info_for_struct_ctor(ecx, rbml_w, item.name,\n+                                        ctor_id, index, item.id);\n         }\n       }\n       hir::ItemDefaultImpl(unsafety, _) => {\n-          index.index_item(rbml_w, item.id);\n+          index.record(def_id, rbml_w);\n           rbml_w.start_tag(tag_items_data_item);\n-          encode_def_id(rbml_w, def_id);\n+          encode_def_id_and_key(ecx, rbml_w, def_id);\n           encode_family(rbml_w, 'd');\n           encode_name(rbml_w, item.name);\n           encode_unsafety(rbml_w, unsafety);\n \n-          let trait_ref = tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n+          let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n@@ -1187,17 +1122,17 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let impl_items = tcx.impl_items.borrow();\n         let items = impl_items.get(&def_id).unwrap();\n \n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n \n-        match tcx.custom_coerce_unsized_kinds.borrow().get(&DefId::local(item.id)) {\n+        match tcx.custom_coerce_unsized_kinds.borrow().get(&ecx.tcx.map.local_def_id(item.id)) {\n             Some(&kind) => {\n                 rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n                 kind.encode(rbml_w);\n@@ -1224,7 +1159,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(trait_ref) = tcx.impl_trait_ref(DefId::local(item.id)) {\n+        if let Some(trait_ref) = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1276,9 +1211,9 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n       }\n       hir::ItemTrait(_, _, _, ref ms) => {\n-        index.index_item(rbml_w, item.id);\n+        index.record(def_id, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n+        encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'I');\n         encode_item_variances(rbml_w, ecx, item.id);\n         let trait_def = tcx.lookup_trait_def(def_id);\n@@ -1334,7 +1269,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         for (i, &item_def_id) in r.iter().enumerate() {\n             assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n-            index.index_item(rbml_w, item_def_id.def_id().node);\n+            index.record(item_def_id.def_id(), rbml_w);\n             rbml_w.start_tag(tag_items_data_item);\n \n             encode_parent_item(rbml_w, def_id);\n@@ -1348,7 +1283,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             match trait_item_type {\n                 ty::ConstTraitItem(associated_const) => {\n                     encode_name(rbml_w, associated_const.name);\n-                    encode_def_id(rbml_w, associated_const.def_id);\n+                    encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n                     encode_visibility(rbml_w, associated_const.vis);\n \n                     let elem = ast_map::PathName(associated_const.name);\n@@ -1358,7 +1293,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                     encode_family(rbml_w, 'C');\n \n                     encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                                    associated_const.def_id.local_id());\n+                                                    ecx.local_id(associated_const.def_id));\n \n                     is_nonstatic_method = false;\n                 }\n@@ -1382,14 +1317,14 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                         }\n                     }\n                     encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                                                    method_def_id.local_id());\n+                                                    ecx.local_id(method_def_id));\n \n                     is_nonstatic_method = method_ty.explicit_self !=\n                         ty::StaticExplicitSelfCategory;\n                 }\n                 ty::TypeTraitItem(associated_type) => {\n                     encode_name(rbml_w, associated_type.name);\n-                    encode_def_id(rbml_w, associated_type.def_id);\n+                    encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n \n                     let elem = ast_map::PathName(associated_type.name);\n                     encode_path(rbml_w,\n@@ -1426,7 +1361,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                         // FIXME: I feel like there is something funny\n                         // going on.\n                         encode_bounds_and_type_for_item(rbml_w, ecx, index,\n-                            item_def_id.def_id().local_id());\n+                                                        ecx.local_id(item_def_id.def_id()));\n                     }\n \n                     if body.is_some() {\n@@ -1457,9 +1392,11 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                           index: &mut CrateIndex<'tcx>,\n                                           path: PathElems,\n                                           abi: abi::Abi) {\n-    index.index_item(rbml_w, nitem.id);\n+    let def_id = ecx.tcx.map.local_def_id(nitem.id);\n+\n+    index.record(def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n-    encode_def_id(rbml_w, DefId::local(nitem.id));\n+    encode_def_id_and_key(ecx, rbml_w, def_id);\n     encode_visibility(rbml_w, nitem.vis);\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {\n@@ -1470,7 +1407,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, DefId::local(nitem.id));\n+        let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_method_argument_names(rbml_w, &*fndecl);\n@@ -1483,7 +1420,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, DefId::local(nitem.id));\n+        let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_name(rbml_w, nitem.name);\n@@ -1493,7 +1430,34 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.end_tag();\n }\n \n-fn my_visit_expr(_e: &hir::Expr) { }\n+fn my_visit_expr(expr: &hir::Expr,\n+                 rbml_w: &mut Encoder,\n+                 ecx: &EncodeContext,\n+                 index: &mut CrateIndex) {\n+    match expr.node {\n+        hir::ExprClosure(..) => {\n+            let def_id = ecx.tcx.map.local_def_id(expr.id);\n+\n+            index.record(def_id, rbml_w);\n+\n+            rbml_w.start_tag(tag_items_data_item);\n+            encode_def_id_and_key(ecx, rbml_w, def_id);\n+\n+            rbml_w.start_tag(tag_items_closure_ty);\n+            write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n+            rbml_w.end_tag();\n+\n+            rbml_w.start_tag(tag_items_closure_kind);\n+            ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n+            rbml_w.end_tag();\n+\n+            ecx.tcx.map.with_path(expr.id, |path| encode_path(rbml_w, path));\n+\n+            rbml_w.end_tag();\n+        }\n+        _ => { }\n+    }\n+}\n \n fn my_visit_item<'a, 'tcx>(i: &hir::Item,\n                            rbml_w: &mut Encoder,\n@@ -1529,21 +1493,15 @@ struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_expr(&mut self, ex: &hir::Expr) {\n         visit::walk_expr(self, ex);\n-        my_visit_expr(ex);\n+        my_visit_expr(ex, self.rbml_w_for_visit_item, self.ecx, self.index);\n     }\n     fn visit_item(&mut self, i: &hir::Item) {\n         visit::walk_item(self, i);\n-        my_visit_item(i,\n-                      self.rbml_w_for_visit_item,\n-                      self.ecx,\n-                      self.index);\n+        my_visit_item(i, self.rbml_w_for_visit_item, self.ecx, self.index);\n     }\n     fn visit_foreign_item(&mut self, ni: &hir::ForeignItem) {\n         visit::walk_foreign_item(self, ni);\n-        my_visit_foreign_item(ni,\n-                              self.rbml_w_for_visit_item,\n-                              self.ecx,\n-                              self.index);\n+        my_visit_foreign_item(ni, self.rbml_w_for_visit_item, self.ecx, self.index);\n     }\n }\n \n@@ -1552,12 +1510,12 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                    krate: &hir::Crate)\n                                    -> CrateIndex<'tcx> {\n     let mut index = CrateIndex {\n-        items: Vec::new(),\n+        items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n         xrefs: FnvHashMap()\n     };\n     rbml_w.start_tag(tag_items_data);\n \n-    index.index_item(rbml_w, CRATE_NODE_ID);\n+    index.record(DefId::local(CRATE_DEF_INDEX), rbml_w);\n     encode_info_for_mod(ecx,\n                         rbml_w,\n                         &krate.module,\n@@ -1577,10 +1535,9 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     index\n }\n \n-fn encode_item_index(rbml_w: &mut Encoder, index: Vec<IndexEntry>)\n-{\n+fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n     rbml_w.start_tag(tag_index);\n-    index::write_index(index, rbml_w.writer);\n+    index.write_index(rbml_w.writer);\n     rbml_w.end_tag();\n }\n \n@@ -1694,12 +1651,12 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_lang_items);\n \n-    for (i, &def_id) in ecx.tcx.lang_items.items() {\n-        if let Some(id) = def_id {\n-            if id.is_local() {\n+    for (i, &opt_def_id) in ecx.tcx.lang_items.items() {\n+        if let Some(def_id) = opt_def_id {\n+            if def_id.is_local() {\n                 rbml_w.start_tag(tag_lang_items_item);\n                 rbml_w.wr_tagged_u32(tag_lang_items_item_id, i as u32);\n-                rbml_w.wr_tagged_u32(tag_lang_items_item_node_id, id.node as u32);\n+                rbml_w.wr_tagged_u32(tag_lang_items_item_index, def_id.index.as_u32());\n                 rbml_w.end_tag();\n             }\n         }\n@@ -1733,7 +1690,10 @@ fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     match ecx.tcx.sess.plugin_registrar_fn.get() {\n-        Some(id) => { rbml_w.wr_tagged_u32(tag_plugin_registrar_fn, id); }\n+        Some(id) => {\n+            let def_id = ecx.tcx.map.local_def_id(id);\n+            rbml_w.wr_tagged_u32(tag_plugin_registrar_fn, def_id.index.as_u32());\n+        }\n         None => {}\n     }\n }\n@@ -1778,24 +1738,26 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &hir::Crate) {\n-    struct StructFieldVisitor<'a, 'b:'a> {\n-        rbml_w: &'a mut Encoder<'b>,\n+fn encode_struct_field_attrs(ecx: &EncodeContext,\n+                             rbml_w: &mut Encoder,\n+                             krate: &hir::Crate) {\n+    struct StructFieldVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n+        ecx: &'a EncodeContext<'b, 'tcx>,\n+        rbml_w: &'a mut Encoder<'c>,\n     }\n \n-    impl<'a, 'b, 'v> Visitor<'v> for StructFieldVisitor<'a, 'b> {\n+    impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for StructFieldVisitor<'a, 'b, 'c, 'tcx> {\n         fn visit_struct_field(&mut self, field: &hir::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n-            self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n+            let def_id = self.ecx.tcx.map.local_def_id(field.node.id);\n+            encode_def_id(self.rbml_w, def_id);\n             encode_attributes(self.rbml_w, &field.node.attrs);\n             self.rbml_w.end_tag();\n         }\n     }\n \n     rbml_w.start_tag(tag_struct_fields);\n-    visit::walk_crate(&mut StructFieldVisitor {\n-        rbml_w: rbml_w\n-    }, krate);\n+    visit::walk_crate(&mut StructFieldVisitor { ecx: ecx, rbml_w: rbml_w }, krate);\n     rbml_w.end_tag();\n }\n \n@@ -1816,7 +1778,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n             if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n                     def_id.krate != LOCAL_CRATE {\n                 self.rbml_w.start_tag(tag_impls_impl);\n-                encode_def_id(self.rbml_w, DefId::local(item.id));\n+                encode_def_id(self.rbml_w, self.ecx.tcx.map.local_def_id(item.id));\n                 self.rbml_w.wr_tagged_u64(tag_impls_impl_trait_def_id, def_to_u64(def_id));\n                 self.rbml_w.end_tag();\n             }\n@@ -1858,17 +1820,17 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n         rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(DefId::local(item.id)));\n+                             def_to_u64(ecx.tcx.map.local_def_id(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(DefId::local(auxiliary_node_id)));\n+                                 def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n             true\n         });\n     }\n \n     // Encode reexports for the root module.\n-    encode_reexports(ecx, rbml_w, 0, [].iter().cloned().chain(LinkedPath::empty()));\n+    encode_reexports(ecx, rbml_w, 0);\n \n     rbml_w.end_tag();\n     rbml_w.end_tag();\n@@ -1882,8 +1844,9 @@ fn encode_misc_info(ecx: &EncodeContext,\n // definition (as that's not defined in this crate).\n fn encode_reachable(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_reachable_ids);\n-    for id in ecx.reachable {\n-        rbml_w.wr_tagged_u32(tag_reachable_id, *id);\n+    for &id in ecx.reachable {\n+        let def_id = ecx.tcx.map.local_def_id(id);\n+        rbml_w.wr_tagged_u32(tag_reachable_id, def_id.index.as_u32());\n     }\n     rbml_w.end_tag();\n }\n@@ -2102,7 +2065,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     encode_xrefs(&ecx, &mut rbml_w, index.xrefs);\n     stats.xref_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n-    encode_struct_field_attrs(&mut rbml_w, krate);\n+    encode_struct_field_attrs(&ecx, &mut rbml_w, krate);\n \n     stats.total_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n "}, {"sha": "60bbdaddd751607c7e75c1ffeade30db3d440852", "filename": "src/librustc/metadata/index.rs", "status": "modified", "additions": 65, "deletions": 159, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Findex.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -8,148 +8,98 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::def_id::{DefId, DefIndex};\n+use rbml;\n use std::io::{Cursor, Write};\n use std::slice;\n use std::u32;\n-use syntax::ast::NodeId;\n \n-#[derive(Copy, Clone, PartialEq, PartialOrd, Eq, Ord)]\n-pub struct IndexEntry {\n-    pub node: NodeId,\n-    pub pos: u64\n-}\n-\n-#[derive(Debug)]\n-pub struct IndexArrayEntry {\n-    bits: u32,\n-    first_pos: u32\n+/// As part of the metadata, we generate an index that stores, for\n+/// each DefIndex, the position of the corresponding RBML document (if\n+/// any).  This is just a big `[u32]` slice, where an entry of\n+/// `u32::MAX` indicates that there is no RBML document. This little\n+/// struct just stores the offsets within the metadata of the start\n+/// and end of this slice. These are actually part of an RBML\n+/// document, but for looking things up in the metadata, we just\n+/// discard the RBML positioning and jump directly to the data.\n+pub struct Index {\n+    data_start: usize,\n+    data_end: usize,\n }\n \n-impl IndexArrayEntry {\n-    fn encode_to<W: Write>(&self, b: &mut W) {\n-        write_be_u32(b, self.bits);\n-        write_be_u32(b, self.first_pos);\n+impl Index {\n+    /// Given the RBML doc representing the index, save the offests\n+    /// for later.\n+    pub fn from_rbml(index: rbml::Doc) -> Index {\n+        Index { data_start: index.start, data_end: index.end }\n     }\n \n-    fn decode_from(b: &[u32]) -> Self {\n-        IndexArrayEntry {\n-            bits: u32::from_be(b[0]),\n-            first_pos: u32::from_be(b[1])\n+    /// Given the metadata, extract out the offset of a particular\n+    /// DefIndex (if any).\n+    #[inline(never)]\n+    pub fn lookup_item(&self, bytes: &[u8], def_index: DefIndex) -> Option<u32> {\n+        let words = bytes_to_words(&bytes[self.data_start..self.data_end]);\n+        let index = def_index.as_usize();\n+\n+        debug!(\"lookup_item: index={:?} words.len={:?}\",\n+               index, words.len());\n+\n+        let position = u32::from_be(words[index]);\n+        if position == u32::MAX {\n+            debug!(\"lookup_item: position=u32::MAX\");\n+            None\n+        } else {\n+            debug!(\"lookup_item: position={:?}\", position);\n+            Some(position)\n         }\n     }\n }\n \n-/// The Item Index\n-///\n-/// This index maps the NodeId of each item to its location in the\n-/// metadata.\n-///\n-/// The index is a sparse bit-vector consisting of a index-array\n-/// and a position-array. Each entry in the index-array handles 32 nodes.\n-/// The first word is a bit-array consisting of the nodes that hold items,\n-/// the second is the index of the first of the items in the position-array.\n-/// If there is a large set of non-item trailing nodes, they can be omitted\n-/// from the index-array.\n-///\n-/// The index is serialized as an array of big-endian 32-bit words.\n-/// The first word is the number of items in the position-array.\n-/// Then, for each item, its position in the metadata follows.\n-/// After that the index-array is stored.\n-///\n-/// struct index {\n-///     u32 item_count;\n-///     u32 items[self.item_count];\n-///     struct { u32 bits; u32 offset; } positions[..];\n-/// }\n-pub struct Index {\n-    position_start: usize,\n-    index_start: usize,\n-    index_end: usize,\n+/// While we are generating the metadata, we also track the position\n+/// of each DefIndex. It is not required that all definitions appear\n+/// in the metadata, nor that they are serialized in order, and\n+/// therefore we first allocate the vector here and fill it with\n+/// `u32::MAX`. Whenever an index is visited, we fill in the\n+/// appropriate spot by calling `record_position`. We should never\n+/// visit the same index twice.\n+pub struct IndexData {\n+    positions: Vec<u32>,\n }\n \n-pub fn write_index(mut entries: Vec<IndexEntry>, buf: &mut Cursor<Vec<u8>>) {\n-    assert!(entries.len() < u32::MAX as usize);\n-    entries.sort();\n-\n-    let mut last_entry = IndexArrayEntry { bits: 0, first_pos: 0 };\n-\n-    write_be_u32(buf, entries.len() as u32);\n-    for &IndexEntry { pos, .. } in &entries {\n-        assert!(pos < u32::MAX as u64);\n-        write_be_u32(buf, pos as u32);\n+impl IndexData {\n+    pub fn new(max_index: usize) -> IndexData {\n+        IndexData {\n+            positions: vec![u32::MAX; max_index]\n+        }\n     }\n \n-    let mut pos_in_index_array = 0;\n-    for (i, &IndexEntry { node, .. }) in entries.iter().enumerate() {\n-        let (x, s) = (node / 32 as u32, node % 32 as u32);\n-        while x > pos_in_index_array {\n-            pos_in_index_array += 1;\n-            last_entry.encode_to(buf);\n-            last_entry = IndexArrayEntry { bits: 0, first_pos: i as u32 };\n-        }\n-        last_entry.bits |= 1<<s;\n+    pub fn record(&mut self, def_id: DefId, position: u64) {\n+        assert!(def_id.is_local());\n+        self.record_index(def_id.index, position)\n     }\n-    last_entry.encode_to(buf);\n \n-    info!(\"write_index: {} items, {} array entries\",\n-          entries.len(), pos_in_index_array);\n-}\n+    pub fn record_index(&mut self, item: DefIndex, position: u64) {\n+        let item = item.as_usize();\n \n-impl Index {\n-    fn lookup_index(&self, index: &[u32], i: u32) -> Option<IndexArrayEntry> {\n-        let ix = (i as usize)*2;\n-        if ix >= index.len() {\n-            None\n-        } else {\n-            Some(IndexArrayEntry::decode_from(&index[ix..ix+2]))\n-        }\n-    }\n+        assert!(position < (u32::MAX as u64));\n+        let position = position as u32;\n \n-    fn item_from_pos(&self, positions: &[u32], pos: u32) -> u32 {\n-        u32::from_be(positions[pos as usize])\n-    }\n+        assert!(self.positions[item] == u32::MAX,\n+                \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n+                item, self.positions[item], position);\n \n-    #[inline(never)]\n-    pub fn lookup_item(&self, buf: &[u8], node: NodeId) -> Option<u32> {\n-        let index = bytes_to_words(&buf[self.index_start..self.index_end]);\n-        let positions = bytes_to_words(&buf[self.position_start..self.index_start]);\n-        let (x, s) = (node / 32 as u32, node % 32 as u32);\n-        let result = match self.lookup_index(index, x) {\n-            Some(IndexArrayEntry { bits, first_pos }) => {\n-                let bit = 1<<s;\n-                if bits & bit == 0 {\n-                    None\n-                } else {\n-                    let prev_nodes_for_entry = (bits&(bit-1)).count_ones();\n-                    Some(self.item_from_pos(\n-                        positions,\n-                        first_pos+prev_nodes_for_entry))\n-                }\n-            }\n-            None => None // trailing zero\n-        };\n-        debug!(\"lookup_item({:?}) = {:?}\", node, result);\n-        result\n+        self.positions[item] = position;\n     }\n \n-    pub fn from_buf(buf: &[u8], start: usize, end: usize) -> Self {\n-        let buf = bytes_to_words(&buf[start..end]);\n-        let position_count = buf[0].to_be() as usize;\n-        let position_len = position_count*4;\n-        info!(\"loaded index - position: {}-{}-{}\", start, start+position_len, end);\n-        debug!(\"index contents are {:?}\",\n-               buf.iter().map(|b| format!(\"{:08x}\", b)).collect::<Vec<_>>().concat());\n-        assert!(end-4-start >= position_len);\n-        assert_eq!((end-4-start-position_len)%8, 0);\n-        Index {\n-            position_start: start+4,\n-            index_start: start+position_len+4,\n-            index_end: end\n+    pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) {\n+        for &position in &self.positions {\n+            write_be_u32(buf, position);\n         }\n     }\n }\n \n-/// A dense index with integer keys\n+/// A dense index with integer keys. Different API from IndexData (should\n+/// these be merged?)\n pub struct DenseIndex {\n     start: usize,\n     end: usize\n@@ -193,47 +143,3 @@ fn bytes_to_words(b: &[u8]) -> &[u32] {\n     assert!(b.len() % 4 == 0);\n     unsafe { slice::from_raw_parts(b.as_ptr() as *const u32, b.len()/4) }\n }\n-\n-#[test]\n-fn test_index() {\n-    let entries = vec![\n-        IndexEntry { node: 0, pos: 17 },\n-        IndexEntry { node: 31, pos: 29 },\n-        IndexEntry { node: 32, pos: 1175 },\n-        IndexEntry { node: 191, pos: 21 },\n-        IndexEntry { node: 128, pos: 34 },\n-        IndexEntry { node: 145, pos: 70 },\n-        IndexEntry { node: 305, pos: 93214 },\n-        IndexEntry { node: 138, pos: 64 },\n-        IndexEntry { node: 129, pos: 53 },\n-        IndexEntry { node: 192, pos: 33334 },\n-        IndexEntry { node: 200, pos: 80123 },\n-    ];\n-    let mut c = Cursor::new(vec![]);\n-    write_index(entries.clone(), &mut c);\n-    let mut buf = c.into_inner();\n-    let expected: &[u8] = &[\n-        0, 0, 0, 11, // # entries\n-        // values:\n-        0,0,0,17, 0,0,0,29, 0,0,4,151, 0,0,0,34,\n-        0,0,0,53, 0,0,0,64, 0,0,0,70, 0,0,0,21,\n-        0,0,130,54, 0,1,56,251, 0,1,108,30,\n-        // index:\n-        128,0,0,1,0,0,0,0, 0,0,0,1,0,0,0,2,\n-        0,0,0,0,0,0,0,3,   0,0,0,0,0,0,0,3,\n-        0,2,4,3,0,0,0,3,   128,0,0,0,0,0,0,7,\n-        0,0,1,1,0,0,0,8,   0,0,0,0,0,0,0,10,\n-        0,0,0,0,0,0,0,10,  0,2,0,0,0,0,0,10\n-    ];\n-    assert_eq!(buf, expected);\n-\n-    // insert some junk padding\n-    for i in 0..17 { buf.insert(0, i); buf.push(i) }\n-    let index = Index::from_buf(&buf, 17, buf.len()-17);\n-\n-    // test round-trip\n-    for i in 0..4096 {\n-        assert_eq!(index.lookup_item(&buf, i),\n-                   entries.iter().find(|e| e.node == i).map(|n| n.pos as u32));\n-    }\n-}"}, {"sha": "d03af6b672284b2accff9b886315e06aa71ad880", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 20, "deletions": 51, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -16,11 +16,9 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::DefIdSource::*;\n-\n use rustc_front::hir;\n \n-use middle::def_id::DefId;\n+use middle::def_id::{DefId, DefIndex};\n use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n@@ -36,32 +34,7 @@ use syntax::parse::token;\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n-// Def id conversion: when we encounter def-ids, they have to be translated.\n-// For example, the crate number must be converted from the crate number used\n-// in the library we are reading from into the local crate numbers in use\n-// here.  To perform this translation, the type decoder is supplied with a\n-// conversion function of type `conv_did`.\n-//\n-// Sometimes, particularly when inlining, the correct translation of the\n-// def-id will depend on where it originated from.  Therefore, the conversion\n-// function is given an indicator of the source of the def-id.  See\n-// astencode.rs for more information.\n-#[derive(Copy, Clone, Debug)]\n-pub enum DefIdSource {\n-    // Identifies a struct, trait, enum, etc.\n-    NominalType,\n-\n-    // Identifies a type alias (`type X = ...`).\n-    TypeWithId,\n-\n-    // Identifies a region parameter (`fn foo<'X>() { ... }`).\n-    RegionParameter,\n-\n-    // Identifies a closure\n-    ClosureSource\n-}\n-\n-pub type DefIdConvert<'a> = &'a mut FnMut(DefIdSource, DefId) -> DefId;\n+pub type DefIdConvert<'a> = &'a mut FnMut(DefId) -> DefId;\n \n pub struct TyDecoder<'a, 'tcx: 'a> {\n     data: &'a [u8],\n@@ -189,7 +162,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 ty::BrAnon(id)\n             }\n             '[' => {\n-                let def = self.parse_def(RegionParameter);\n+                let def = self.parse_def();\n                 let name = token::intern(&self.parse_str(']'));\n                 ty::BrNamed(def, name)\n             }\n@@ -215,19 +188,14 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n-                // this is the wrong NodeId, but `param_id` is only accessed\n-                // by the receiver-matching code in collect, which won't\n-                // be going down this code path, and anyway I will kill it\n-                // the moment wfcheck becomes the standard.\n-                let node_id = self.parse_uint() as ast::NodeId;\n-                assert_eq!(self.next(), '|');\n+                let def_id = self.parse_def();\n                 let space = self.parse_param_space();\n                 assert_eq!(self.next(), '|');\n                 let index = self.parse_u32();\n                 assert_eq!(self.next(), '|');\n                 let name = token::intern(&self.parse_str(']'));\n                 ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    param_id: node_id,\n+                    def_id: def_id,\n                     space: space,\n                     index: index,\n                     name: name\n@@ -320,7 +288,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     pub fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n-        let def = self.parse_def(NominalType);\n+        let def = self.parse_def();\n         let substs = self.tcx.mk_substs(self.parse_substs());\n         ty::TraitRef {def_id: def, substs: substs}\n     }\n@@ -349,7 +317,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'c' => return tcx.types.char,\n             't' => {\n                 assert_eq!(self.next(), '[');\n-                let did = self.parse_def(NominalType);\n+                let did = self.parse_def();\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n                 let def = self.tcx.lookup_adt_def(did);\n@@ -396,7 +364,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 return tcx.mk_tup(params);\n             }\n             'F' => {\n-                let def_id = self.parse_def(NominalType);\n+                let def_id = self.parse_def();\n                 return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(self.parse_bare_fn_ty()));\n             }\n             'G' => {\n@@ -435,21 +403,21 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 return tt;\n             }\n             '\\\"' => {\n-                let _ = self.parse_def(TypeWithId);\n+                let _ = self.parse_def();\n                 let inner = self.parse_ty();\n                 inner\n             }\n             'a' => {\n                 assert_eq!(self.next(), '[');\n-                let did = self.parse_def(NominalType);\n+                let did = self.parse_def();\n                 let substs = self.parse_substs();\n                 assert_eq!(self.next(), ']');\n                 let def = self.tcx.lookup_adt_def(did);\n                 return self.tcx.mk_struct(def, self.tcx.mk_substs(substs));\n             }\n             'k' => {\n                 assert_eq!(self.next(), '[');\n-                let did = self.parse_def(ClosureSource);\n+                let did = self.parse_def();\n                 let substs = self.parse_substs();\n                 let mut tys = vec![];\n                 while self.peek() != '.' {\n@@ -484,9 +452,9 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         ty::TypeAndMut { ty: self.parse_ty(), mutbl: m }\n     }\n \n-    fn parse_def(&mut self, source: DefIdSource) -> DefId {\n+    fn parse_def(&mut self) -> DefId {\n         let def_id = parse_defid(self.scan(|c| c == '|'));\n-        return (self.conv_def_id)(source, def_id);\n+        return (self.conv_def_id)(def_id);\n     }\n \n     fn parse_uint(&mut self) -> usize {\n@@ -576,7 +544,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'p' => ty::Binder(self.parse_projection_predicate()).to_predicate(),\n             'w' => ty::Predicate::WellFormed(self.parse_ty()),\n             'O' => {\n-                let def_id = self.parse_def(NominalType);\n+                let def_id = self.parse_def();\n                 assert_eq!(self.next(), '|');\n                 ty::Predicate::ObjectSafe(def_id)\n             }\n@@ -596,12 +564,12 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n \n     pub fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n         let name = self.parse_name(':');\n-        let def_id = self.parse_def(NominalType);\n+        let def_id = self.parse_def();\n         let space = self.parse_param_space();\n         assert_eq!(self.next(), '|');\n         let index = self.parse_u32();\n         assert_eq!(self.next(), '|');\n-        let default_def_id = self.parse_def(NominalType);\n+        let default_def_id = self.parse_def();\n         let default = self.parse_opt(|this| this.parse_ty());\n         let object_lifetime_default = self.parse_object_lifetime_default();\n \n@@ -618,7 +586,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n \n     pub fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n         let name = self.parse_name(':');\n-        let def_id = self.parse_def(NominalType);\n+        let def_id = self.parse_def();\n         let space = self.parse_param_space();\n         assert_eq!(self.next(), '|');\n         let index = self.parse_u32();\n@@ -726,11 +694,12 @@ fn parse_defid(buf: &[u8]) -> DefId {\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n         s.parse::<usize>().ok()\n     }) {\n-        Some(dn) => dn as ast::NodeId,\n+        Some(dn) => dn,\n         None => panic!(\"internal error: parse_defid: id expected, found {:?}\",\n                        def_part)\n     };\n-    DefId { krate: crate_num, node: def_num }\n+    let index = DefIndex::new(def_num);\n+    DefId { krate: crate_num, index: index }\n }\n \n fn parse_unsafety(c: char) -> hir::Unsafety {"}, {"sha": "1b993a00e28448889342ca4fb373bb3f92dbd812", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -254,7 +254,7 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n         }\n         ty::ReEarlyBound(ref data) => {\n             mywrite!(w, \"B[{}|{}|{}|{}]\",\n-                     data.param_id,\n+                     (cx.ds)(data.def_id),\n                      data.space.to_uint(),\n                      data.index,\n                      data.name);"}, {"sha": "40e89b390888fa62d55762b27a7f8255f7b45b41", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 41, "deletions": 123, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -24,14 +24,12 @@ use metadata::decoder;\n use metadata::encoder as e;\n use metadata::inline::{InlinedItem, InlinedItemRef};\n use metadata::tydecode;\n-use metadata::tydecode::{DefIdSource, NominalType, TypeWithId};\n-use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::ty::adjustment;\n use middle::ty::cast;\n use middle::check_const::ConstQualif;\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::privacy::{AllPublic, LastMod};\n use middle::region;\n use middle::subst;\n@@ -71,10 +69,6 @@ trait tr {\n     fn tr(&self, dcx: &DecodeContext) -> Self;\n }\n \n-trait tr_intern {\n-    fn tr_intern(&self, dcx: &DecodeContext) -> DefId;\n-}\n-\n // ______________________________________________________________________\n // Top-level methods.\n \n@@ -128,10 +122,13 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  path: Vec<ast_map::PathElem>,\n-                                 par_doc: rbml::Doc)\n-                                 -> Result<&'tcx InlinedItem, Vec<ast_map::PathElem>> {\n+                                 def_path: ast_map::DefPath,\n+                                 par_doc: rbml::Doc,\n+                                 orig_did: DefId)\n+                                 -> Result<&'tcx InlinedItem, (Vec<ast_map::PathElem>,\n+                                                               ast_map::DefPath)> {\n     match par_doc.opt_child(c::tag_ast) {\n-      None => Err(path),\n+      None => Err((path, def_path)),\n       Some(ast_doc) => {\n         let mut path_as_str = None;\n         debug!(\"> Decoding inlined fn: {:?}::?\",\n@@ -152,7 +149,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             last_filemap_index: Cell::new(0)\n         };\n         let raw_ii = decode_ast(ast_doc);\n-        let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, raw_ii, dcx);\n+        let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, def_path, raw_ii, dcx);\n \n         let name = match *ii {\n             InlinedItem::Item(ref i) => i.name,\n@@ -166,7 +163,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                name);\n         region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n         decode_side_tables(dcx, ast_doc);\n-        copy_item_types(dcx, ii);\n+        copy_item_types(dcx, ii, orig_did);\n         match *ii {\n           InlinedItem::Item(ref i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n@@ -205,17 +202,6 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n         (id.wrapping_sub(self.from_id_range.min).wrapping_add(self.to_id_range.min))\n     }\n \n-    /// Gets the original crate's DefId from a translated internal\n-    /// def-id.\n-    pub fn reverse_tr_id(&self, id: ast::NodeId) -> DefId {\n-        // from_id_range should be non-empty\n-        assert!(!self.from_id_range.empty());\n-        // Use wrapping arithmetic because otherwise it introduces control flow.\n-        // Maybe we should just have the control flow? -- aatch\n-        let node = id.wrapping_sub(self.to_id_range.min).wrapping_add(self.from_id_range.min);\n-        DefId { krate: self.cdata.cnum, node: node }\n-    }\n-\n     /// Translates an EXTERNAL def-id, converting the crate number from the one used in the encoded\n     /// data to the current crate numbers..  By external, I mean that it be translated to a\n     /// reference to the item in its original crate, as opposed to being translated to a reference\n@@ -224,24 +210,10 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     /// be inlined.  Note that even when the inlined function is referencing itself recursively, we\n     /// would want `tr_def_id` for that reference--- conceptually the function calls the original,\n     /// non-inlined version, and trans deals with linking that recursive call to the inlined copy.\n-    ///\n-    /// However, there are a *few* cases where def-ids are used but we know that the thing being\n-    /// referenced is in fact *internal* to the item being inlined.  In those cases, you should use\n-    /// `tr_intern_def_id()` below.\n     pub fn tr_def_id(&self, did: DefId) -> DefId {\n-\n         decoder::translate_def_id(self.cdata, did)\n     }\n \n-    /// Translates an INTERNAL def-id, meaning a def-id that is\n-    /// known to refer to some part of the item currently being\n-    /// inlined.  In that case, we want to convert the def-id to\n-    /// refer to the current crate and to the new, inlined node-id.\n-    pub fn tr_intern_def_id(&self, did: DefId) -> DefId {\n-        assert_eq!(did.krate, LOCAL_CRATE);\n-        DefId { krate: LOCAL_CRATE, node: self.tr_id(did.node) }\n-    }\n-\n     /// Translates a `Span` from an extern crate to the corresponding `Span`\n     /// within the local crate's codemap. `creader::import_codemap()` will\n     /// already have allocated any additionally needed FileMaps in the local\n@@ -300,12 +272,6 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     }\n }\n \n-impl tr_intern for DefId {\n-    fn tr_intern(&self, dcx: &DecodeContext) -> DefId {\n-        dcx.tr_intern_def_id(*self)\n-    }\n-}\n-\n impl tr for DefId {\n     fn tr(&self, dcx: &DecodeContext) -> DefId {\n         dcx.tr_def_id(*self)\n@@ -471,7 +437,11 @@ impl tr for def::Def {\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n           def::DefConst(did) => { def::DefConst(did.tr(dcx)) }\n           def::DefAssociatedConst(did) => def::DefAssociatedConst(did.tr(dcx)),\n-          def::DefLocal(nid) => { def::DefLocal(dcx.tr_id(nid)) }\n+          def::DefLocal(_, nid) => {\n+              let nid = dcx.tr_id(nid);\n+              let did = dcx.tcx.map.local_def_id(nid);\n+              def::DefLocal(did, nid)\n+          }\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n           },\n@@ -482,11 +452,13 @@ impl tr for def::Def {\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n           def::DefTyParam(s, index, def_id, n) => def::DefTyParam(s, index, def_id.tr(dcx), n),\n           def::DefUse(did) => def::DefUse(did.tr(dcx)),\n-          def::DefUpvar(nid1, index, nid2) => {\n-            def::DefUpvar(dcx.tr_id(nid1), index, dcx.tr_id(nid2))\n+          def::DefUpvar(_, nid1, index, nid2) => {\n+              let nid1 = dcx.tr_id(nid1);\n+              let nid2 = dcx.tr_id(nid2);\n+              let did1 = dcx.tcx.map.local_def_id(nid1);\n+              def::DefUpvar(did1, nid1, index, nid2)\n           }\n           def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n-          def::DefRegion(nid) => def::DefRegion(dcx.tr_id(nid)),\n           def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid))\n         }\n     }\n@@ -579,10 +551,6 @@ impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n     }\n }\n \n-pub fn encode_closure_kind(ebml_w: &mut Encoder, kind: ty::ClosureKind) {\n-    kind.encode(ebml_w).unwrap();\n-}\n-\n pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n     kind.encode(ebml_w).unwrap();\n }\n@@ -606,8 +574,6 @@ impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n }\n \n trait rbml_writer_helpers<'tcx> {\n-    fn emit_closure_type<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                             closure_type: &ty::ClosureTy<'tcx>);\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n@@ -630,14 +596,6 @@ trait rbml_writer_helpers<'tcx> {\n }\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n-    fn emit_closure_type<'b>(&mut self,\n-                             ecx: &e::EncodeContext<'b, 'tcx>,\n-                             closure_type: &ty::ClosureTy<'tcx>) {\n-        self.emit_opaque(|this| {\n-            Ok(e::write_closure_type(ecx, this, closure_type))\n-        });\n-    }\n-\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region) {\n         self.emit_opaque(|this| Ok(e::write_region(ecx, this, r)));\n     }\n@@ -866,7 +824,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             rbml_w.tag(c::tag_table_upvar_capture_map, |rbml_w| {\n                 rbml_w.id(id);\n \n-                let var_id = freevar.def.def_id().node;\n+                let var_id = freevar.def.var_id();\n                 let upvar_id = ty::UpvarId {\n                     var_id: var_id,\n                     closure_expr_id: id\n@@ -914,20 +872,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&DefId::local(id)) {\n-        rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_closure_type(ecx, closure_type);\n-        })\n-    }\n-\n-    if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&DefId::local(id)) {\n-        rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n-            rbml_w.id(id);\n-            encode_closure_kind(rbml_w, *closure_kind)\n-        })\n-    }\n-\n     if let Some(cast_kind) = tcx.cast_kinds.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_cast_kinds, |rbml_w| {\n             rbml_w.id(id);\n@@ -979,17 +923,12 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                     -> adjustment::AutoAdjustment<'tcx>;\n     fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                  -> cast::CastKind;\n-    fn read_closure_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                 -> ty::ClosureKind;\n-    fn read_closure_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                               -> ty::ClosureTy<'tcx>;\n     fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> adjustment::AutoDerefRef<'tcx>;\n     fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                             -> adjustment::AutoRef<'tcx>;\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n-                      source: DefIdSource,\n                       did: DefId)\n                       -> DefId;\n \n@@ -1013,7 +952,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         self.read_opaque(|_, doc| {\n             Ok(\n                 tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                                              &mut |_, id| decoder::translate_def_id(cdata, id))\n+                                              &mut |id| decoder::translate_def_id(cdata, id))\n                     .parse_ty())\n         }).unwrap()\n     }\n@@ -1035,7 +974,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         self.read_opaque(|_, doc| {\n             Ok(\n                 tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                                              &mut |_, id| decoder::translate_def_id(cdata, id))\n+                                              &mut |id| decoder::translate_def_id(cdata, id))\n                     .parse_substs())\n         }).unwrap()\n     }\n@@ -1048,7 +987,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             Ok(op(\n                 &mut tydecode::TyDecoder::with_doc(\n                     dcx.tcx, dcx.cdata.cnum, doc,\n-                    &mut |s, a| this.convert_def_id(dcx, s, a))))\n+                    &mut |a| this.convert_def_id(dcx, a))))\n         }).unwrap();\n \n         fn type_string(doc: rbml::Doc) -> String {\n@@ -1101,7 +1040,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                            -> subst::Substs<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::TyDecoder::with_doc(dcx.tcx, dcx.cdata.cnum, doc,\n-                                             &mut |s, a| this.convert_def_id(dcx, s, a))\n+                                             &mut |a| this.convert_def_id(dcx, a))\n                .parse_substs())\n         }).unwrap()\n     }\n@@ -1208,18 +1147,6 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         Decodable::decode(self).unwrap()\n     }\n \n-    fn read_closure_kind<'b, 'c>(&mut self, _dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                 -> ty::ClosureKind\n-    {\n-        Decodable::decode(self).unwrap()\n-    }\n-\n-    fn read_closure_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                               -> ty::ClosureTy<'tcx>\n-    {\n-        self.read_ty_encoded(dcx, |decoder| decoder.parse_closure_ty())\n-    }\n-\n     /// Converts a def-id that appears in a type.  The correct\n     /// translation will depend on what kind of def-id this is.\n     /// This is a subtle point: type definitions are not\n@@ -1254,14 +1181,10 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     /// def-ids so that all these distinctions were unnecessary.\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n-                      source: tydecode::DefIdSource,\n                       did: DefId)\n                       -> DefId {\n-        let r = match source {\n-            NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n-            ClosureSource => dcx.tr_intern_def_id(did)\n-        };\n-        debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n+        let r = dcx.tr_def_id(did);\n+        debug!(\"convert_def_id(did={:?})={:?}\", did, r);\n         return r;\n     }\n }\n@@ -1339,18 +1262,6 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n                     }\n-                    c::tag_table_closure_tys => {\n-                        let closure_ty =\n-                            val_dsr.read_closure_ty(dcx);\n-                        dcx.tcx.tables.borrow_mut().closure_tys.insert(DefId::local(id),\n-                                                                closure_ty);\n-                    }\n-                    c::tag_table_closure_kinds => {\n-                        let closure_kind =\n-                            val_dsr.read_closure_kind(dcx);\n-                        dcx.tcx.tables.borrow_mut().closure_kinds.insert(DefId::local(id),\n-                                                                  closure_kind);\n-                    }\n                     c::tag_table_cast_kinds => {\n                         let cast_kind =\n                             val_dsr.read_cast_kind(dcx);\n@@ -1375,10 +1286,11 @@ fn decode_side_tables(dcx: &DecodeContext,\n \n // copy the tcache entries from the original item to the new\n // inlined item\n-fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem) {\n-    fn copy_item_type(dcx: &DecodeContext, inlined_node: ast::NodeId) {\n-        let inlined_did = DefId::local(inlined_node);\n-        let remote_did = dcx.reverse_tr_id(inlined_node);\n+fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n+    fn copy_item_type(dcx: &DecodeContext,\n+                      inlined_id: ast::NodeId,\n+                      remote_did: DefId) {\n+        let inlined_did = dcx.tcx.map.local_def_id(inlined_id);\n         dcx.tcx.register_item_type(inlined_did,\n                                    dcx.tcx.lookup_item_type(remote_did));\n \n@@ -1390,19 +1302,25 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem) {\n         &InlinedItem::ImplItem(_, ref ii) => ii.id,\n         &InlinedItem::Foreign(ref fi) => fi.id\n     };\n-    copy_item_type(dcx, item_node_id);\n+    copy_item_type(dcx, item_node_id, orig_did);\n \n     // copy the entries of inner items\n     if let &InlinedItem::Item(ref item) = ii {\n         match item.node {\n             hir::ItemEnum(ref def, _) => {\n-                for variant in &def.variants {\n-                    copy_item_type(dcx, variant.node.id);\n+                let orig_def = dcx.tcx.lookup_adt_def(orig_did);\n+                for (i_variant, orig_variant) in\n+                    def.variants.iter().zip(orig_def.variants.iter())\n+                {\n+                    copy_item_type(dcx, i_variant.node.id, orig_variant.did);\n                 }\n             }\n             hir::ItemStruct(ref def, _) => {\n                 if let Some(ctor_id) = def.ctor_id {\n-                    copy_item_type(dcx, ctor_id);\n+                    let ctor_did = dcx.tcx.lookup_adt_def(orig_did)\n+                        .struct_variant().ctor_id;\n+                    println!(\"copying ctor {:?}\", ctor_did);\n+                    copy_item_type(dcx, ctor_id, ctor_did);\n                 }\n             }\n             _ => {}"}, {"sha": "15c56d23da203f6e995bbe888ff9f40410b3d279", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -659,7 +659,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                                              doesn't point to a constant\");\n                     }\n                 }\n-                Some(def::DefLocal(_)) if v.mode == Mode::ConstFn => {\n+                Some(def::DefLocal(..)) if v.mode == Mode::ConstFn => {\n                     // Sadly, we can't determine whether the types are zero-sized.\n                     v.add_qualif(ConstQualif::NOT_CONST | ConstQualif::NON_ZERO_SIZED);\n                 }"}, {"sha": "283c6264717f035b029f14da69755157826273cc", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -245,7 +245,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                 let pat_ty = cx.tcx.pat_ty(p);\n                 if let ty::TyEnum(edef, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-                    if let Some(DefLocal(_)) = def {\n+                    if let Some(DefLocal(..)) = def {\n                         if edef.variants.iter().any(|variant|\n                             variant.name == ident.node.name\n                                 && variant.kind() == VariantKind::Unit"}, {"sha": "acb66b8efe7eb059c9ec2a9839b39230a54250ce", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -240,37 +240,43 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n                     Some(DefAssociatedConst(def_id)) |\n-                    Some(DefConst(def_id)) if def_id.is_local() => {\n-                        match self.ast_map.get(def_id.node) {\n-                          ast_map::NodeItem(item) =>\n-                            self.visit_item(item),\n-                          ast_map::NodeTraitItem(item) =>\n-                            self.visit_trait_item(item),\n-                          ast_map::NodeImplItem(item) =>\n-                            self.visit_impl_item(item),\n-                          ast_map::NodeForeignItem(_) => {},\n-                          _ => {\n-                              self.sess.span_bug(\n-                                  e.span,\n-                                  &format!(\"expected item, found {}\",\n-                                           self.ast_map.node_to_string(def_id.node)));\n-                          }\n+                    Some(DefConst(def_id)) => {\n+                        if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n+                            match self.ast_map.get(node_id) {\n+                                ast_map::NodeItem(item) =>\n+                                    self.visit_item(item),\n+                                ast_map::NodeTraitItem(item) =>\n+                                    self.visit_trait_item(item),\n+                                ast_map::NodeImplItem(item) =>\n+                                    self.visit_impl_item(item),\n+                                ast_map::NodeForeignItem(_) => {},\n+                                _ => {\n+                                    self.sess.span_bug(\n+                                        e.span,\n+                                        &format!(\"expected item, found {}\",\n+                                                 self.ast_map.node_to_string(node_id)));\n+                                }\n+                            }\n                         }\n                     }\n                     // For variants, we only want to check expressions that\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(DefVariant(enum_id, variant_id, false)) if enum_id.is_local() => {\n-                        if let hir::ItemEnum(ref enum_def, ref generics) =\n-                               self.ast_map.expect_item(enum_id.local_id()).node {\n-                            self.populate_enum_discriminants(enum_def);\n-                            let variant = self.ast_map.expect_variant(variant_id.local_id());\n-                            self.visit_variant(variant, generics);\n-                        } else {\n-                            self.sess.span_bug(e.span,\n-                                \"`check_static_recursion` found \\\n-                                 non-enum in DefVariant\");\n+                    Some(DefVariant(enum_id, variant_id, false)) => {\n+                        if let Some(enum_node_id) = self.ast_map.as_local_node_id(enum_id) {\n+                            if let hir::ItemEnum(ref enum_def, ref generics) =\n+                                self.ast_map.expect_item(enum_node_id).node\n+                            {\n+                                self.populate_enum_discriminants(enum_def);\n+                                let variant_id = self.ast_map.as_local_node_id(variant_id).unwrap();\n+                                let variant = self.ast_map.expect_variant(variant_id);\n+                                self.visit_variant(variant, generics);\n+                            } else {\n+                                self.sess.span_bug(e.span,\n+                                                   \"`check_static_recursion` found \\\n+                                                    non-enum in DefVariant\");\n+                            }\n                         }\n                     }\n                     _ => ()"}, {"sha": "06ec176c30e22aeeaeeaf84ab6882a30aef5568a", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 17, "deletions": 38, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -69,50 +69,29 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         None\n     }\n \n-    if enum_def.is_local() {\n-        match tcx.map.find(enum_def.node) {\n+    if let Some(enum_node_id) = tcx.map.as_local_node_id(enum_def) {\n+        let variant_node_id = tcx.map.as_local_node_id(variant_def).unwrap();\n+        match tcx.map.find(enum_node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 hir::ItemEnum(hir::EnumDef { ref variants }, _) => {\n-                    variant_expr(&variants[..], variant_def.node)\n+                    variant_expr(&variants[..], variant_node_id)\n                 }\n                 _ => None\n             },\n             Some(_) => None\n         }\n     } else {\n-        match tcx.extern_const_variants.borrow().get(&variant_def) {\n-            Some(&ast::DUMMY_NODE_ID) => return None,\n-            Some(&expr_id) => {\n-                return Some(tcx.map.expect_expr(expr_id));\n-            }\n-            None => {}\n-        }\n-        let expr_id = match csearch::maybe_get_item_ast(tcx, enum_def,\n-            Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n-            csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n-                hir::ItemEnum(hir::EnumDef { ref variants }, _) => {\n-                    // NOTE this doesn't do the right thing, it compares inlined\n-                    // NodeId's to the original variant_def's NodeId, but they\n-                    // come from different crates, so they will likely never match.\n-                    variant_expr(&variants[..], variant_def.node).map(|e| e.id)\n-                }\n-                _ => None\n-            },\n-            _ => None\n-        };\n-        tcx.extern_const_variants.borrow_mut().insert(variant_def,\n-                                                      expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n-        expr_id.map(|id| tcx.map.expect_expr(id))\n+        None\n     }\n }\n \n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                         def_id: DefId,\n                                         maybe_ref_id: Option<ast::NodeId>)\n                                         -> Option<&'tcx Expr> {\n-    if def_id.is_local() {\n-        match tcx.map.find(def_id.node) {\n+    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+        match tcx.map.find(node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 hir::ItemConst(_, ref const_expr) => {\n@@ -164,7 +143,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         }\n         let mut used_ref_id = false;\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-            Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n+            Box::new(astencode::decode_inlined_item)) {\n             csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n@@ -220,7 +199,7 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: DefId)\n     }\n \n     let fn_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-        box |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n+        box astencode::decode_inlined_item) {\n         csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n         csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n         _ => None\n@@ -233,14 +212,14 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: DefId)\n pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId)\n                                    -> Option<FnLikeNode<'tcx>>\n {\n-    let fn_id = if !def_id.is_local() {\n+    let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+        node_id\n+    } else {\n         if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n             fn_id\n         } else {\n             return None;\n         }\n-    } else {\n-        def_id.node\n     };\n \n     let fn_like = match FnLikeNode::from_node(tcx.map.get(fn_id)) {\n@@ -919,8 +898,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n           let (const_expr, const_ty) = match opt_def {\n               Some(def::DefConst(def_id)) => {\n-                  if def_id.is_local() {\n-                      match tcx.map.find(def_id.node) {\n+                  if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+                      match tcx.map.find(node_id) {\n                           Some(ast_map::NodeItem(it)) => match it.node {\n                               hir::ItemConst(ref ty, ref expr) => {\n                                   (Some(&**expr), Some(&**ty))\n@@ -934,9 +913,9 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   }\n               }\n               Some(def::DefAssociatedConst(def_id)) => {\n-                  if def_id.is_local() {\n+                  if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n                       match tcx.impl_or_trait_item(def_id).container() {\n-                          ty::TraitContainer(trait_id) => match tcx.map.find(def_id.node) {\n+                          ty::TraitContainer(trait_id) => match tcx.map.find(node_id) {\n                               Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                                   hir::ConstTraitItem(ref ty, _) => {\n                                       if let ExprTypeChecked = ty_hint {\n@@ -954,7 +933,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               },\n                               _ => (None, None)\n                           },\n-                          ty::ImplContainer(_) => match tcx.map.find(def_id.node) {\n+                          ty::ImplContainer(_) => match tcx.map.find(node_id) {\n                               Some(ast_map::NodeImplItem(ii)) => match ii.node {\n                                   hir::ConstImplItem(ref ty, ref expr) => {\n                                       (Some(&**expr), Some(&**ty))"}, {"sha": "6e31b733254bd73f90d370117d01fc62181dc19d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -29,17 +29,15 @@ use syntax::attr::{self, AttrMetaMethods};\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore(tcx: &ty::ctxt, def_id: DefId) -> bool {\n-    if !def_id.is_local() {\n-        return false;\n-    }\n-\n-    match tcx.map.find(def_id.node) {\n-        Some(ast_map::NodeItem(..))\n-        | Some(ast_map::NodeImplItem(..))\n-        | Some(ast_map::NodeForeignItem(..))\n-        | Some(ast_map::NodeTraitItem(..)) => true,\n-        _ => false\n+fn should_explore(tcx: &ty::ctxt, node_id: ast::NodeId) -> bool {\n+    match tcx.map.find(node_id) {\n+        Some(ast_map::NodeItem(..)) |\n+        Some(ast_map::NodeImplItem(..)) |\n+        Some(ast_map::NodeForeignItem(..)) |\n+        Some(ast_map::NodeTraitItem(..)) =>\n+            true,\n+        _ =>\n+            false\n     }\n }\n \n@@ -50,7 +48,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n     inherited_pub_visibility: bool,\n-    ignore_variant_stack: Vec<ast::NodeId>,\n+    ignore_variant_stack: Vec<DefId>,\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n@@ -68,10 +66,19 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn check_def_id(&mut self, def_id: DefId) {\n-        if should_explore(self.tcx, def_id) {\n-            self.worklist.push(def_id.node);\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+            if should_explore(self.tcx, node_id) {\n+                self.worklist.push(node_id);\n+            }\n+            self.live_symbols.insert(node_id);\n+        }\n+    }\n+\n+    fn insert_def_id(&mut self, def_id: DefId) {\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+            debug_assert!(!should_explore(self.tcx, node_id));\n+            self.live_symbols.insert(node_id);\n         }\n-        self.live_symbols.insert(def_id.node);\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n@@ -88,13 +95,14 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.tcx.def_map.borrow().get(id).map(|def| {\n             match def.full_def() {\n                 def::DefConst(_) | def::DefAssociatedConst(..) => {\n-                    self.check_def_id(def.def_id())\n+                    self.check_def_id(def.def_id());\n                 }\n                 _ if self.ignore_non_const_paths => (),\n                 def::DefPrimTy(_) => (),\n+                def::DefSelfTy(..) => (),\n                 def::DefVariant(enum_id, variant_id, _) => {\n                     self.check_def_id(enum_id);\n-                    if !self.ignore_variant_stack.contains(&variant_id.node) {\n+                    if !self.ignore_variant_stack.contains(&variant_id) {\n                         self.check_def_id(variant_id);\n                     }\n                 }\n@@ -113,15 +121,15 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n         if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n-            self.live_symbols.insert(def.struct_variant().field_named(name).did.node);\n+            self.insert_def_id(def.struct_variant().field_named(name).did);\n         } else {\n             self.tcx.sess.span_bug(lhs.span, \"named field access on non-struct\")\n         }\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n         if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n-            self.live_symbols.insert(def.struct_variant().fields[idx].did.node);\n+            self.insert_def_id(def.struct_variant().fields[idx].did);\n         }\n     }\n \n@@ -137,7 +145,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             if let hir::PatWild(hir::PatWildSingle) = pat.node.pat.node {\n                 continue;\n             }\n-            self.live_symbols.insert(variant.field_named(pat.node.name).did.node);\n+            self.insert_def_id(variant.field_named(pat.node.name).did);\n         }\n     }\n \n@@ -469,8 +477,10 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     // `ctor_id`. On the other hand, in a statement like\n     // `type <ident> <generics> = <ty>;` where <ty> refers to a struct_ctor,\n     // DefMap maps <ty> to `id` instead.\n-    fn symbol_is_live(&mut self, id: ast::NodeId,\n-                      ctor_id: Option<ast::NodeId>) -> bool {\n+    fn symbol_is_live(&mut self,\n+                      id: ast::NodeId,\n+                      ctor_id: Option<ast::NodeId>)\n+                      -> bool {\n         if self.live_symbols.contains(&id)\n            || ctor_id.map_or(false,\n                              |ctor| self.live_symbols.contains(&ctor)) {\n@@ -481,14 +491,16 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         let impl_items = self.tcx.impl_items.borrow();\n-        match self.tcx.inherent_impls.borrow().get(&DefId::local(id)) {\n+        match self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in impl_list.iter() {\n                     for item_did in impl_items.get(impl_did).unwrap().iter() {\n-                        if self.live_symbols.contains(&item_did.def_id()\n-                                                               .node) {\n-                            return true;\n+                        if let Some(item_node_id) =\n+                                self.tcx.map.as_local_node_id(item_did.def_id()) {\n+                            if self.live_symbols.contains(&item_node_id) {\n+                                return true;\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "3e8325b86121dbed515172b9c60f74c01f5677b4", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -10,7 +10,7 @@\n \n pub use self::Def::*;\n \n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n use util::nodemap::NodeMap;\n@@ -29,15 +29,17 @@ pub enum Def {\n     DefStatic(DefId, bool /* is_mutbl */),\n     DefConst(DefId),\n     DefAssociatedConst(DefId),\n-    DefLocal(ast::NodeId),\n+    DefLocal(DefId, // def id of variable\n+             ast::NodeId), // node id of variable\n     DefVariant(DefId /* enum */, DefId /* variant */, bool /* is_structure */),\n     DefTy(DefId, bool /* is_enum */),\n     DefAssociatedTy(DefId /* trait */, DefId),\n     DefTrait(DefId),\n     DefPrimTy(hir::PrimTy),\n     DefTyParam(ParamSpace, u32, DefId, ast::Name),\n     DefUse(DefId),\n-    DefUpvar(ast::NodeId,  // id of closed over local\n+    DefUpvar(DefId,        // def id of closed over local\n+             ast::NodeId,  // node id of closed over local\n              usize,        // index in the freevars list of the closure\n              ast::NodeId), // expr node that creates the closure\n \n@@ -50,7 +52,6 @@ pub enum Def {\n     /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n     ///   it to a def whose id is the StructDef.ctor_id.\n     DefStruct(DefId),\n-    DefRegion(ast::NodeId),\n     DefLabel(ast::NodeId),\n     DefMethod(DefId),\n }\n@@ -114,10 +115,21 @@ pub struct Export {\n }\n \n impl Def {\n-    pub fn local_node_id(&self) -> ast::NodeId {\n-        let def_id = self.def_id();\n-        assert_eq!(def_id.krate, LOCAL_CRATE);\n-        def_id.node\n+    pub fn var_id(&self) -> ast::NodeId {\n+        match *self {\n+            DefLocal(_, id) |\n+            DefUpvar(_, id, _, _) => {\n+                id\n+            }\n+\n+            DefFn(..) | DefMod(..) | DefForeignMod(..) | DefStatic(..) |\n+            DefVariant(..) | DefTy(..) | DefAssociatedTy(..) |\n+            DefTyParam(..) | DefUse(..) | DefStruct(..) | DefTrait(..) |\n+            DefMethod(..) | DefConst(..) | DefAssociatedConst(..) |\n+            DefPrimTy(..) | DefLabel(..) | DefSelfTy(..) => {\n+                panic!(\"attempted .def_id() on invalid {:?}\", self)\n+            }\n+        }\n     }\n \n     pub fn def_id(&self) -> DefId {\n@@ -126,19 +138,15 @@ impl Def {\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n             DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n             DefMethod(id) | DefConst(id) | DefAssociatedConst(id) |\n-            DefSelfTy(Some(id), None)=> {\n+            DefLocal(id, _) | DefUpvar(id, _, _, _) => {\n                 id\n             }\n-            DefLocal(id) |\n-            DefUpvar(id, _, _) |\n-            DefRegion(id) |\n-            DefLabel(id)  |\n-            DefSelfTy(_, Some((_, id))) => {\n-                DefId::local(id)\n-            }\n \n-            DefPrimTy(_) => panic!(\"attempted .def_id() on DefPrimTy\"),\n-            DefSelfTy(..) => panic!(\"attempted .def_id() on invalid DefSelfTy\"),\n+            DefLabel(..)  |\n+            DefPrimTy(..) |\n+            DefSelfTy(..) => {\n+                panic!(\"attempted .def_id() on invalid def: {:?}\", self)\n+            }\n         }\n     }\n "}, {"sha": "ba4eac9e9eb86410c53aa91bb8d9f02094a1cade", "filename": "src/librustc/middle/def_id.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef_id.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -8,21 +8,55 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use metadata::cstore::LOCAL_CRATE;\n use middle::ty;\n-use syntax::ast::{CrateNum, NodeId};\n+use syntax::ast::CrateNum;\n use std::fmt;\n+use std::u32;\n \n+/// A DefIndex is an index into the hir-map for a crate, identifying a\n+/// particular definition. It should really be considered an interned\n+/// shorthand for a particular DefPath.\n+#[derive(Clone, Debug, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n+           RustcDecodable, Hash, Copy)]\n+pub struct DefIndex(u32);\n+\n+impl DefIndex {\n+    pub fn new(x: usize) -> DefIndex {\n+        assert!(x < (u32::MAX as usize));\n+        DefIndex(x as u32)\n+    }\n+\n+    pub fn from_u32(x: u32) -> DefIndex {\n+        DefIndex(x)\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+/// The crate root is always assigned index 0 by the AST Map code,\n+/// thanks to `NodeCollector::new`.\n+pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n+\n+/// A DefId identifies a particular *definition*, by combining a crate\n+/// index and a def index.\n #[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n            RustcDecodable, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n-    pub node: NodeId,\n+    pub index: DefIndex,\n }\n \n impl fmt::Debug for DefId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"DefId {{ krate: {}, node: {}\",\n-                    self.krate, self.node));\n+        try!(write!(f, \"DefId {{ krate: {:?}, node: {:?}\",\n+                    self.krate, self.index));\n \n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n@@ -40,23 +74,11 @@ impl fmt::Debug for DefId {\n \n \n impl DefId {\n-    pub fn local(id: NodeId) -> DefId {\n-        DefId { krate: LOCAL_CRATE, node: id }\n-    }\n-\n-    /// Read the node id, asserting that this def-id is krate-local.\n-    pub fn local_id(&self) -> NodeId {\n-        assert_eq!(self.krate, LOCAL_CRATE);\n-        self.node\n+    pub fn local(index: DefIndex) -> DefId {\n+        DefId { krate: LOCAL_CRATE, index: index }\n     }\n \n     pub fn is_local(&self) -> bool {\n         self.krate == LOCAL_CRATE\n     }\n }\n-\n-\n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n-pub const LOCAL_CRATE: CrateNum = 0;\n-"}, {"sha": "1eed7fb95a1f580dc19e519ff7c2c5caf2738c33", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -276,15 +276,13 @@ enum PassArgs {\n }\n \n impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n-    pub fn new(delegate: &'d mut Delegate<'tcx>,\n+    pub fn new(delegate: &'d mut (Delegate<'tcx>),\n                typer: &'t infer::InferCtxt<'a, 'tcx>)\n                -> ExprUseVisitor<'d,'t,'a,'tcx> where 'tcx:'a\n     {\n-        ExprUseVisitor {\n-            typer: typer,\n-            mc: mc::MemCategorizationContext::new(typer),\n-            delegate: delegate,\n-        }\n+        let mc: mc::MemCategorizationContext<'t, 'a, 'tcx> =\n+            mc::MemCategorizationContext::new(typer);\n+        ExprUseVisitor { typer: typer, mc: mc, delegate: delegate }\n     }\n \n     pub fn walk_fn(&mut self,\n@@ -1160,7 +1158,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let id_var = freevar.def.def_id().node;\n+                let id_var = freevar.def.var_id();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n                 let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n@@ -1192,7 +1190,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = upvar_def.def_id().node;\n+        let var_id = upvar_def.var_id();\n         let var_ty = try!(self.typer.node_ty(var_id));\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "3b44dc12ac197412f0bd8e8c3af37c969952d178", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -1455,20 +1455,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         def_id: DefId)\n                         -> Option<ty::ClosureKind>\n     {\n-        self.tables.borrow().closure_kinds.get(&def_id).cloned()\n+        if def_id.is_local() {\n+            self.tables.borrow().closure_kinds.get(&def_id).cloned()\n+        } else {\n+            // During typeck, ALL closures are local. But afterwards,\n+            // during trans, we see closure ids from other traits.\n+            // That may require loading the closure data out of the\n+            // cstore.\n+            Some(ty::Tables::closure_kind(&self.tables, self.tcx, def_id))\n+        }\n     }\n \n     pub fn closure_type(&self,\n                         def_id: DefId,\n                         substs: &ty::ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        let closure_ty = self.tables\n-                             .borrow()\n-                             .closure_tys\n-                             .get(&def_id)\n-                             .unwrap()\n-                             .subst(self.tcx, &substs.func_substs);\n+        let closure_ty =\n+            ty::Tables::closure_type(self.tables,\n+                                     self.tcx,\n+                                     def_id,\n+                                     substs);\n \n         if self.normalize {\n             normalize_associated_type(&self.tcx, &closure_ty)"}, {"sha": "03c75fc6cc370e1b45bb94115022f7f837db97ad", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -21,6 +21,7 @@\n \n pub use self::LangItem::*;\n \n+use front::map as hir_map;\n use session::Session;\n use metadata::csearch::each_lang_item;\n use middle::def_id::DefId;\n@@ -144,38 +145,42 @@ impl LanguageItems {\n     )*\n }\n \n-struct LanguageItemCollector<'a> {\n+struct LanguageItemCollector<'a, 'tcx: 'a> {\n     items: LanguageItems,\n \n+    ast_map: &'a hir_map::Map<'tcx>,\n+\n     session: &'a Session,\n \n     item_refs: FnvHashMap<&'static str, usize>,\n }\n \n-impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n+impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let Some(value) = extract(&item.attrs) {\n             let item_index = self.item_refs.get(&value[..]).cloned();\n \n             if let Some(item_index) = item_index {\n-                self.collect_item(item_index, DefId::local(item.id), item.span)\n+                self.collect_item(item_index, self.ast_map.local_def_id(item.id), item.span)\n             }\n         }\n \n         visit::walk_item(self, item);\n     }\n }\n \n-impl<'a> LanguageItemCollector<'a> {\n-    pub fn new(session: &'a Session) -> LanguageItemCollector<'a> {\n+impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n+    pub fn new(session: &'a Session, ast_map: &'a hir_map::Map<'tcx>)\n+               -> LanguageItemCollector<'a, 'tcx> {\n         let mut item_refs = FnvHashMap();\n \n         $( item_refs.insert($name, $variant as usize); )*\n \n         LanguageItemCollector {\n             session: session,\n+            ast_map: ast_map,\n             items: LanguageItems::new(),\n-            item_refs: item_refs\n+            item_refs: item_refs,\n         }\n     }\n \n@@ -203,8 +208,8 @@ impl<'a> LanguageItemCollector<'a> {\n     pub fn collect_external_language_items(&mut self) {\n         let crate_store = &self.session.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n-            each_lang_item(crate_store, crate_number, |node_id, item_index| {\n-                let def_id = DefId { krate: crate_number, node: node_id };\n+            each_lang_item(crate_store, crate_number, |index, item_index| {\n+                let def_id = DefId { krate: crate_number, index: index };\n                 self.collect_item(item_index, def_id, DUMMY_SP);\n                 true\n             });\n@@ -230,9 +235,11 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n     return None;\n }\n \n-pub fn collect_language_items(krate: &hir::Crate,\n-                              session: &Session) -> LanguageItems {\n-    let mut collector = LanguageItemCollector::new(session);\n+pub fn collect_language_items(session: &Session,\n+                              map: &hir_map::Map)\n+                              -> LanguageItems {\n+    let krate: &hir::Crate = map.krate();\n+    let mut collector = LanguageItemCollector::new(session, map);\n     collector.collect(krate);\n     let LanguageItemCollector { mut items, .. } = collector;\n     weak_lang_items::check_crate(krate, session, &mut items);"}, {"sha": "3b56597d353a308b7c0bf695d892ae137ed4724d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -465,7 +465,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         let mut call_caps = Vec::new();\n         ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n-                if let DefLocal(rv) = fv.def {\n+                if let DefLocal(_, rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     call_caps.push(CaptureInfo {ln: fv_ln,\n                                                 var_nid: rv});\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match self.ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n-          DefLocal(nid) => {\n+          DefLocal(_, nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n                 self.init_from_succ(ln, succ);\n@@ -1517,9 +1517,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             hir::ExprPath(..) => {\n-                if let DefLocal(nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n-                                                                   .unwrap()\n-                                                                   .full_def() {\n+                if let DefLocal(_, nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n+                                                                      .unwrap()\n+                                                                      .full_def() {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability"}, {"sha": "555f864befbe08bdb7f7e642d5bc13fe99032f32", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -551,7 +551,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n           def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n-          def::DefTyParam(..) | def::DefRegion(_) |\n+          def::DefTyParam(..) |\n           def::DefLabel(_) | def::DefSelfTy(..) |\n           def::DefAssociatedTy(..) => {\n               Ok(Rc::new(cmt_ {\n@@ -575,7 +575,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               }))\n           }\n \n-          def::DefUpvar(var_id, _, fn_node_id) => {\n+          def::DefUpvar(_, var_id, _, fn_node_id) => {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n                   ty::TyClosure(closure_id, _) => {\n@@ -600,7 +600,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               }\n           }\n \n-          def::DefLocal(vid) => {\n+          def::DefLocal(_, vid) => {\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,"}, {"sha": "48550c3d8b2f1a52314d2d4a22361086d046ee14", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -219,7 +219,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> hir::Path {\n }\n \n /// Return variants that are necessary to exist for the pattern to match.\n-pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<ast::NodeId> {\n+pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n     let mut variants = vec![];\n     walk_pat(pat, |p| {\n         match p.node {\n@@ -228,7 +228,7 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<ast::NodeId> {\n             hir::PatStruct(..) => {\n                 match dm.borrow().get(&p.id) {\n                     Some(&PathResolution { base_def: DefVariant(_, id, _), .. }) => {\n-                        variants.push(id.node);\n+                        variants.push(id);\n                     }\n                     _ => ()\n                 }"}, {"sha": "a89da9704d9fd8d7d845e7b51cb39b474c4b0d6c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -17,7 +17,7 @@\n \n use front::map as ast_map;\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::ty;\n use middle::privacy;\n use session::config;\n@@ -61,20 +61,15 @@ fn method_might_be_inlined(tcx: &ty::ctxt, sig: &hir::MethodSig,\n         generics_require_inlining(&sig.generics) {\n         return true\n     }\n-    if impl_src.is_local() {\n-        {\n-            match tcx.map.find(impl_src.node) {\n-                Some(ast_map::NodeItem(item)) => {\n-                    item_might_be_inlined(&*item)\n-                }\n-                Some(..) | None => {\n-                    tcx.sess.span_bug(impl_item.span, \"impl did is not an item\")\n-                }\n-            }\n+    if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_src) {\n+        match tcx.map.find(impl_node_id) {\n+            Some(ast_map::NodeItem(item)) =>\n+                item_might_be_inlined(&*item),\n+            Some(..) | None =>\n+                tcx.sess.span_bug(impl_item.span, \"impl did is not an item\")\n         }\n     } else {\n-        tcx.sess.span_bug(impl_item.span, \"found a foreign impl as a parent \\\n-                                           of a local method\")\n+        tcx.sess.span_bug(impl_item.span, \"found a foreign impl as a parent of a local method\")\n     }\n }\n \n@@ -106,22 +101,22 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                 };\n \n                 let def_id = def.def_id();\n-                if def_id.is_local() {\n+                if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(def_id.node)\n+                        self.worklist.push(node_id);\n                     } else {\n                         match def {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n                             def::DefConst(..) | def::DefAssociatedConst(..) => {\n-                                self.worklist.push(def_id.node);\n+                                self.worklist.push(node_id);\n                             }\n \n                             // If this wasn't a static, then the destination is\n                             // surely reachable.\n                             _ => {\n-                                self.reachable_symbols.insert(def_id.node);\n+                                self.reachable_symbols.insert(node_id);\n                             }\n                         }\n                     }\n@@ -132,11 +127,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                 let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n                 match self.tcx.impl_or_trait_item(def_id).container() {\n                     ty::ImplContainer(_) => {\n-                        if def_id.is_local() {\n+                        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {\n-                                self.worklist.push(def_id.node)\n+                                self.worklist.push(node_id)\n                             }\n-                            self.reachable_symbols.insert(def_id.node);\n+                            self.reachable_symbols.insert(node_id);\n                         }\n                     }\n                     ty::TraitContainer(_) => {}\n@@ -171,11 +166,11 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        if def_id.krate != LOCAL_CRATE {\n-            return false\n-        }\n+        let node_id = match self.tcx.map.as_local_node_id(def_id) {\n+            Some(node_id) => node_id,\n+            None => { return false; }\n+        };\n \n-        let node_id = def_id.node;\n         match self.tcx.map.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n@@ -204,11 +199,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            assert!(impl_did.is_local());\n-                            match self.tcx\n-                                      .map\n-                                      .expect_item(impl_did.node)\n-                                      .node {\n+                            let impl_node_id = self.tcx.map.as_local_node_id(impl_did).unwrap();\n+                            match self.tcx.map.expect_item(impl_node_id).node {\n                                 hir::ItemImpl(_, _, ref generics, _, _, _) => {\n                                     generics_require_inlining(generics)\n                                 }\n@@ -354,8 +346,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         drop_trait.for_each_impl(self.tcx, |drop_impl| {\n             for destructor in &self.tcx.impl_items.borrow()[&drop_impl] {\n                 let destructor_did = destructor.def_id();\n-                if destructor_did.is_local() {\n-                    self.reachable_symbols.insert(destructor_did.node);\n+                if let Some(destructor_node_id) = self.tcx.map.as_local_node_id(destructor_did) {\n+                    self.reachable_symbols.insert(destructor_node_id);\n                 }\n             }\n         })\n@@ -377,8 +369,10 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     }\n     for (_, item) in tcx.lang_items.items() {\n         match *item {\n-            Some(did) if did.is_local() => {\n-                reachable_context.worklist.push(did.node);\n+            Some(did) => {\n+                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n+                    reachable_context.worklist.push(node_id);\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "be227e620b8811b567e551d18a9fe6b9318e58ec", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -13,8 +13,9 @@\n \n use session::Session;\n use lint;\n+use metadata::cstore::LOCAL_CRATE;\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::ty;\n use middle::privacy::PublicItems;\n use metadata::csearch;\n@@ -112,7 +113,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                             \"An API can't be stabilized after it is deprecated\");\n                     }\n \n-                    self.index.map.insert(DefId::local(id), Some(stab));\n+                    let def_id = self.tcx.map.local_def_id(id);\n+                    self.index.map.insert(def_id, Some(stab));\n \n                     // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                     if stab.level != attr::Stable {\n@@ -128,7 +130,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                            use_parent, self.parent);\n                     if use_parent {\n                         if let Some(stab) = self.parent {\n-                            self.index.map.insert(DefId::local(id), Some(stab));\n+                            let def_id = self.tcx.map.local_def_id(id);\n+                            self.index.map.insert(def_id, Some(stab));\n                         } else if self.index.staged_api[&LOCAL_CRATE] && required\n                             && self.export_map.contains(&id)\n                             && !self.tcx.sess.opts.test {\n@@ -380,7 +383,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n                 Some(cnum) => cnum,\n                 None => return,\n             };\n-            let id = DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n+            let id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n             maybe_do_stability_check(tcx, id, item.span, cb);\n         }\n \n@@ -471,6 +474,7 @@ pub fn check_path(tcx: &ty::ctxt, path: &hir::Path, id: ast::NodeId,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         Some(def::DefPrimTy(..)) => {}\n+        Some(def::DefSelfTy(..)) => {}\n         Some(def) => {\n             maybe_do_stability_check(tcx, def.def_id(), path.span, cb);\n         }"}, {"sha": "a3795a32afca25188db2444f3a76dd544176dd1e", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -17,7 +17,8 @@ use super::PredicateObligation;\n use super::project;\n use super::util;\n \n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use metadata::cstore::LOCAL_CRATE;\n+use middle::def_id::DefId;\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use middle::infer::{self, InferCtxt};"}, {"sha": "60f6cffa346af696b1b594671e926a172252b74b", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -37,7 +37,7 @@ use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n use super::object_safety;\n use super::util;\n \n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::subst::{Subst, Substs, TypeSpace};\n@@ -1719,7 +1719,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n             ty::TyTuple(ref tys) => ok_if(tys.clone()),\n \n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::TyClosure(_, ref substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1729,7 +1729,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // captures are by value. Really what we ought to do\n                 // is reserve judgement and then intertwine this\n                 // analysis with closure inference.\n-                assert_eq!(def_id.krate, LOCAL_CRATE);\n \n                 // Unboxed closures shouldn't be\n                 // implicitly copyable\n@@ -1863,7 +1862,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 tys.clone()\n             }\n \n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::TyClosure(_, ref substs) => {\n                 // FIXME(#27086). We are invariant w/r/t our\n                 // substs.func_substs, but we don't see them as\n                 // constituent types; this seems RIGHT but also like\n@@ -1872,7 +1871,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // OIBIT interact? That is, there is no way to say\n                 // \"make me invariant with respect to this TYPE, but\n                 // do not act as though I can reach it\"\n-                assert_eq!(def_id.krate, LOCAL_CRATE);\n                 substs.upvar_tys.clone()\n             }\n "}, {"sha": "e506e5b2c077286dc7522f1a7a3308f0ef0f3de5", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -16,6 +16,7 @@\n use front::map as ast_map;\n use session::Session;\n use lint;\n+use metadata::csearch;\n use middle;\n use middle::def::DefMap;\n use middle::def_id::DefId;\n@@ -134,6 +135,40 @@ impl<'tcx> Tables<'tcx> {\n             closure_kinds: DefIdMap(),\n         }\n     }\n+\n+    pub fn closure_kind(this: &RefCell<Self>,\n+                        tcx: &ty::ctxt<'tcx>,\n+                        def_id: DefId)\n+                        -> ty::ClosureKind {\n+        // If this is a local def-id, it should be inserted into the\n+        // tables by typeck; else, it will be retreived from\n+        // the external crate metadata.\n+        if let Some(&kind) = this.borrow().closure_kinds.get(&def_id) {\n+            return kind;\n+        }\n+\n+        let kind = csearch::closure_kind(tcx, def_id);\n+        this.borrow_mut().closure_kinds.insert(def_id, kind);\n+        kind\n+    }\n+\n+    pub fn closure_type(this: &RefCell<Self>,\n+                        tcx: &ty::ctxt<'tcx>,\n+                        def_id: DefId,\n+                        substs: &ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n+    {\n+        // If this is a local def-id, it should be inserted into the\n+        // tables by typeck; else, it will be retreived from\n+        // the external crate metadata.\n+        if let Some(ty) = this.borrow().closure_tys.get(&def_id) {\n+            return ty.subst(tcx, &substs.func_substs);\n+        }\n+\n+        let ty = csearch::closure_ty(tcx, def_id);\n+        this.borrow_mut().closure_tys.insert(def_id, ty.clone());\n+        ty.subst(tcx, &substs.func_substs)\n+    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n@@ -272,7 +307,6 @@ pub struct ctxt<'tcx> {\n \n     /// These caches are used by const_eval when decoding external constants.\n     pub extern_const_statics: RefCell<DefIdMap<NodeId>>,\n-    pub extern_const_variants: RefCell<DefIdMap<NodeId>>,\n     pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n \n     pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),\n@@ -336,19 +370,8 @@ pub struct ctxt<'tcx> {\n     /// constitute it.\n     pub fragment_infos: RefCell<DefIdMap<Vec<ty::FragmentInfo>>>,\n }\n-impl<'tcx> ctxt<'tcx> {\n-    pub fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind {\n-        *self.tables.borrow().closure_kinds.get(&def_id).unwrap()\n-    }\n-\n-    pub fn closure_type(&self,\n-                        def_id: DefId,\n-                        substs: &ClosureSubsts<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-    {\n-        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, &substs.func_substs)\n-    }\n \n+impl<'tcx> ctxt<'tcx> {\n     pub fn type_parameter_def(&self,\n                               node_id: NodeId)\n                               -> ty::TypeParameterDef<'tcx>\n@@ -476,7 +499,6 @@ impl<'tcx> ctxt<'tcx> {\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n             extern_const_statics: RefCell::new(DefIdMap()),\n-            extern_const_variants: RefCell::new(DefIdMap()),\n             extern_const_fns: RefCell::new(DefIdMap()),\n             node_lint_levels: RefCell::new(FnvHashMap()),\n             transmute_restrictions: RefCell::new(Vec::new()),"}, {"sha": "61536934aae13cebbae6cd7a8900f7bee6446f76", "filename": "src/librustc/middle/ty/error.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -302,13 +302,15 @@ impl<'tcx> ty::ctxt<'tcx> {\n                                              expected.ty,\n                                              found.ty));\n \n-                match (expected.def_id.is_local(),\n-                       self.map.opt_span(expected.def_id.node)) {\n-                    (true, Some(span)) => {\n+                match\n+                    self.map.as_local_node_id(expected.def_id)\n+                            .and_then(|node_id| self.map.opt_span(node_id))\n+                {\n+                    Some(span) => {\n                         self.sess.span_note(span,\n                                             &format!(\"a default was defined here...\"));\n                     }\n-                    (_, _) => {\n+                    None => {\n                         self.sess.note(\n                             &format!(\"a default is defined on `{}`\",\n                                      self.item_path_str(expected.def_id)));\n@@ -319,13 +321,15 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     expected.origin_span,\n                     &format!(\"...that was applied to an unconstrained type variable here\"));\n \n-                match (found.def_id.is_local(),\n-                       self.map.opt_span(found.def_id.node)) {\n-                    (true, Some(span)) => {\n+                match\n+                    self.map.as_local_node_id(found.def_id)\n+                            .and_then(|node_id| self.map.opt_span(node_id))\n+                {\n+                    Some(span) => {\n                         self.sess.span_note(span,\n                                             &format!(\"a second default was defined here...\"));\n                     }\n-                    (_, _) => {\n+                    None => {\n                         self.sess.note(\n                             &format!(\"a second default is defined on `{}`\",\n                                      self.item_path_str(found.def_id)));"}, {"sha": "fddfb7b583eb364559b8362747f93b0b0c89f0e8", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -22,9 +22,10 @@ pub use self::LvaluePreference::*;\n use front::map as ast_map;\n use front::map::LinkedPath;\n use metadata::csearch;\n+use metadata::cstore::LOCAL_CRATE;\n use middle;\n use middle::def::{self, ExportMap};\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n@@ -616,7 +617,7 @@ pub struct RegionParameterDef {\n impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            param_id: self.def_id.node,\n+            def_id: self.def_id,\n             space: self.space,\n             index: self.index,\n             name: self.name,\n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n                         let impl_id = cx.map.get_parent(id);\n-                        let impl_def_id = DefId::local(impl_id);\n+                        let impl_def_id = cx.map.local_def_id(impl_id);\n                         let scheme = cx.lookup_item_type(impl_def_id);\n                         let predicates = cx.lookup_predicates(impl_def_id);\n                         cx.construct_parameter_environment(impl_item.span,\n@@ -1132,7 +1133,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     hir::ConstImplItem(_, _) => {\n-                        let def_id = DefId::local(id);\n+                        let def_id = cx.map.local_def_id(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(impl_item.span,\n@@ -1141,7 +1142,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     hir::MethodImplItem(_, ref body) => {\n-                        let method_def_id = DefId::local(id);\n+                        let method_def_id = cx.map.local_def_id(id);\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n@@ -1167,7 +1168,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the trait\n                         let trait_id = cx.map.get_parent(id);\n-                        let trait_def_id = DefId::local(trait_id);\n+                        let trait_def_id = cx.map.local_def_id(trait_id);\n                         let trait_def = cx.lookup_trait_def(trait_def_id);\n                         let predicates = cx.lookup_predicates(trait_def_id);\n                         cx.construct_parameter_environment(trait_item.span,\n@@ -1176,7 +1177,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     hir::ConstTraitItem(..) => {\n-                        let def_id = DefId::local(id);\n+                        let def_id = cx.map.local_def_id(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(trait_item.span,\n@@ -1189,8 +1190,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         // block, unless this is a trait method with\n                         // no default, then fallback to the method id.\n                         let body_id = body.as_ref().map(|b| b.id).unwrap_or(id);\n-                        let method_def_id = DefId::local(id);\n-\n+                        let method_def_id = cx.map.local_def_id(id);\n                         match cx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n@@ -1215,7 +1215,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(_, _, _, _, _, ref body) => {\n                         // We assume this is a function.\n-                        let fn_def_id = DefId::local(id);\n+                        let fn_def_id = cx.map.local_def_id(id);\n                         let fn_scheme = cx.lookup_item_type(fn_def_id);\n                         let fn_predicates = cx.lookup_predicates(fn_def_id);\n \n@@ -1229,7 +1229,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     hir::ItemImpl(..) |\n                     hir::ItemConst(..) |\n                     hir::ItemStatic(..) => {\n-                        let def_id = DefId::local(id);\n+                        let def_id = cx.map.local_def_id(id);\n                         let scheme = cx.lookup_item_type(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(item.span,\n@@ -1238,7 +1238,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            id)\n                     }\n                     hir::ItemTrait(..) => {\n-                        let def_id = DefId::local(id);\n+                        let def_id = cx.map.local_def_id(id);\n                         let trait_def = cx.lookup_trait_def(def_id);\n                         let predicates = cx.lookup_predicates(def_id);\n                         cx.construct_parameter_environment(item.span,\n@@ -1473,7 +1473,10 @@ pub struct VariantDefData<'tcx, 'container: 'tcx> {\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub disr_val: Disr,\n-    pub fields: Vec<FieldDefData<'tcx, 'container>>\n+    pub fields: Vec<FieldDefData<'tcx, 'container>>,\n+    /// The DefId of the variant's ctor (unless the variant is a\n+    /// tuple-like struct variant, this is just the variant's def-id).\n+    pub ctor_id: DefId\n }\n \n pub struct FieldDefData<'tcx, 'container: 'tcx> {\n@@ -2100,11 +2103,11 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn provided_trait_methods(&self, id: DefId) -> Vec<Rc<Method<'tcx>>> {\n-        if id.is_local() {\n-            if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id.node).node {\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id).node {\n                 ms.iter().filter_map(|ti| {\n                     if let hir::MethodTraitItem(_, Some(_)) = ti.node {\n-                        match self.impl_or_trait_item(DefId::local(ti.id)) {\n+                        match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n                             MethodTraitItem(m) => Some(m),\n                             _ => {\n                                 self.sess.bug(\"provided_trait_methods(): \\\n@@ -2125,12 +2128,12 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn associated_consts(&self, id: DefId) -> Vec<Rc<AssociatedConst<'tcx>>> {\n-        if id.is_local() {\n-            match self.map.expect_item(id.node).node {\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            match self.map.expect_item(id).node {\n                 ItemTrait(_, _, _, ref tis) => {\n                     tis.iter().filter_map(|ti| {\n                         if let hir::ConstTraitItem(_, _) = ti.node {\n-                            match self.impl_or_trait_item(DefId::local(ti.id)) {\n+                            match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n                                     self.sess.bug(\"associated_consts(): \\\n@@ -2146,7 +2149,7 @@ impl<'tcx> ctxt<'tcx> {\n                 ItemImpl(_, _, _, _, _, ref iis) => {\n                     iis.iter().filter_map(|ii| {\n                         if let hir::ConstImplItem(_, _) = ii.node {\n-                            match self.impl_or_trait_item(DefId::local(ii.id)) {\n+                            match self.impl_or_trait_item(self.map.local_def_id(ii.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n                                     self.sess.bug(\"associated_consts(): \\\n@@ -2186,8 +2189,8 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn trait_impl_polarity(&self, id: DefId) -> Option<hir::ImplPolarity> {\n-        if id.is_local() {\n-            match self.map.find(id.node) {\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            match self.map.find(id) {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n                         hir::ItemImpl(_, polarity, _, _, _, _) => Some(polarity),\n@@ -2242,9 +2245,9 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Returns whether this DefId refers to an impl\n     pub fn is_impl(&self, id: DefId) -> bool {\n-        if id.is_local() {\n+        if let Some(id) = self.map.as_local_node_id(id) {\n             if let Some(ast_map::NodeItem(\n-                &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id.node) {\n+                &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id) {\n                 true\n             } else {\n                 false\n@@ -2262,19 +2265,27 @@ impl<'tcx> ctxt<'tcx> {\n         self.with_path(id, |path| ast_map::path_to_string(path))\n     }\n \n+    pub fn def_path(&self, id: DefId) -> ast_map::DefPath {\n+        if id.is_local() {\n+            self.map.def_path(id)\n+        } else {\n+            csearch::def_path(self, id)\n+        }\n+    }\n+\n     pub fn with_path<T, F>(&self, id: DefId, f: F) -> T where\n         F: FnOnce(ast_map::PathElems) -> T,\n     {\n-        if id.is_local() {\n-            self.map.with_path(id.node, f)\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            self.map.with_path(id, f)\n         } else {\n             f(csearch::get_item_path(self, id).iter().cloned().chain(LinkedPath::empty()))\n         }\n     }\n \n     pub fn item_name(&self, id: DefId) -> ast::Name {\n-        if id.is_local() {\n-            self.map.get_path_elem(id.node).name()\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            self.map.get_path_elem(id).name()\n         } else {\n             csearch::get_item_name(self, id)\n         }\n@@ -2334,8 +2345,8 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Get the attributes of a definition.\n     pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n-        if did.is_local() {\n-            Cow::Borrowed(self.map.attrs(did.node))\n+        if let Some(id) = self.map.as_local_node_id(did) {\n+            Cow::Borrowed(self.map.attrs(id))\n         } else {\n             Cow::Owned(csearch::get_item_attrs(&self.sess.cstore, did))\n         }\n@@ -2479,6 +2490,18 @@ impl<'tcx> ctxt<'tcx> {\n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n     }\n \n+    pub fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind {\n+        Tables::closure_kind(&self.tables, self, def_id)\n+    }\n+\n+    pub fn closure_type(&self,\n+                        def_id: DefId,\n+                        substs: &ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n+    {\n+        Tables::closure_type(&self.tables, self, def_id, substs)\n+    }\n+\n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n     /// If it implements no trait, return `None`.\n     pub fn trait_id_of_impl(&self, def_id: DefId) -> Option<DefId> {"}, {"sha": "c6debc382279b6a41e70046dc4c05cf54fd19f9a", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use std::ops;\n use std::mem;\n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId};\n+use syntax::ast::{self, Name};\n use syntax::parse::token::special_idents;\n \n use rustc_front::hir;\n@@ -675,7 +675,7 @@ pub enum Region {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n-    pub param_id: NodeId,\n+    pub def_id: DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n     pub name: Name,"}, {"sha": "b546438f392a02ea16ec178de7435127454d7443", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -461,7 +461,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     tcx.sess.cstore.get_crate_hash(did.krate)\n                 };\n                 h.as_str().hash(state);\n-                did.node.hash(state);\n+                did.index.hash(state);\n             };\n             let mt = |state: &mut SipHasher, mt: TypeAndMut| {\n                 mt.mutbl.hash(state);"}, {"sha": "67ced5d32594d09cfcf6bd26ed3892ce39cc46ac", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -27,7 +27,7 @@ use std::fmt;\n use syntax::abi;\n use syntax::ast;\n use syntax::parse::token;\n-use syntax::ast::DUMMY_NODE_ID;\n+use syntax::ast::CRATE_NODE_ID;\n use rustc_front::hir;\n \n pub fn verbose() -> bool {\n@@ -232,7 +232,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrEnv => {\n                 let name = token::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(DefId::local(DUMMY_NODE_ID), name)\n+                ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID), name)\n             }\n         })\n     }).0;\n@@ -309,18 +309,18 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n \n impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeParameterDef({}, {}:{}, {:?}/{})\",\n+        write!(f, \"TypeParameterDef({}, {:?}, {:?}/{})\",\n                self.name,\n-               self.def_id.krate, self.def_id.node,\n+               self.def_id,\n                self.space, self.index)\n     }\n }\n \n impl fmt::Debug for ty::RegionParameterDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionParameterDef({}, {}:{}, {:?}/{}, {:?})\",\n+        write!(f, \"RegionParameterDef({}, {:?}, {:?}/{}, {:?})\",\n                self.name,\n-               self.def_id.krate, self.def_id.node,\n+               self.def_id,\n                self.space, self.index,\n                self.bounds)\n     }\n@@ -455,7 +455,7 @@ impl fmt::Debug for ty::BoundRegion {\n             BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n             BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n             BrNamed(did, name) => {\n-                write!(f, \"BrNamed({}:{}, {:?})\", did.krate, did.node, name)\n+                write!(f, \"BrNamed({:?}, {:?})\", did, name)\n             }\n             BrEnv => \"BrEnv\".fmt(f),\n         }\n@@ -466,8 +466,8 @@ impl fmt::Debug for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n-                write!(f, \"ReEarlyBound({}, {:?}, {}, {})\",\n-                       data.param_id,\n+                write!(f, \"ReEarlyBound({:?}, {:?}, {}, {})\",\n+                       data.def_id,\n                        data.space,\n                        data.index,\n                        data.name)\n@@ -888,15 +888,15 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n             TyStr => write!(f, \"str\"),\n-            TyClosure(ref did, ref substs) => ty::tls::with(|tcx| {\n+            TyClosure(did, ref substs) => ty::tls::with(|tcx| {\n                 try!(write!(f, \"[closure\"));\n \n-                if did.is_local() {\n-                    try!(write!(f, \"@{:?}\", tcx.map.span(did.node)));\n+                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n+                    try!(write!(f, \"@{:?}\", tcx.map.span(node_id)));\n                     let mut sep = \" \";\n-                    try!(tcx.with_freevars(did.node, |freevars| {\n+                    try!(tcx.with_freevars(node_id, |freevars| {\n                         for (freevar, upvar_ty) in freevars.iter().zip(&substs.upvar_tys) {\n-                            let node_id = freevar.def.local_node_id();\n+                            let node_id = freevar.def.var_id();\n                             try!(write!(f,\n                                         \"{}{}:{}\",\n                                         sep,"}, {"sha": "175bac01daa71c27e2e313774b6c9c0d3f9d3c96", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -20,7 +20,7 @@ use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n use borrowck::LoanPathElem::{LpDeref, LpInterior};\n use borrowck::move_data::InvalidMovePathIndex;\n use borrowck::move_data::{MoveData, MovePathIndex};\n-use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n+use rustc::middle::def_id::{DefId};\n use rustc::middle::ty;\n use rustc::middle::mem_categorization as mc;\n \n@@ -133,7 +133,7 @@ pub fn build_unfragmented_map(this: &mut borrowck::BorrowckCtxt,\n     }\n \n     let mut fraginfo_map = this.tcx.fragment_infos.borrow_mut();\n-    let fn_did = DefId { krate: LOCAL_CRATE, node: id };\n+    let fn_did = this.tcx.map.local_def_id(id);\n     let prev = fraginfo_map.insert(fn_did, fragment_infos);\n     assert!(prev.is_none());\n }"}, {"sha": "d004d557856b7e3c124d66e12f0d716a61fe5f36", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -661,7 +661,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n          LocalCrateReader::new(&sess, &ast_map).read_crates(krate));\n \n     let lang_items = time(time_passes, \"language item collection\", ||\n-                          middle::lang_items::collect_language_items(krate, &sess));\n+                          middle::lang_items::collect_language_items(&sess, &ast_map));\n \n     let resolve::CrateMap {\n         def_map,"}, {"sha": "dc550bb698f16034bdbf124b3389af0138c2e4d2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -130,7 +130,7 @@ fn test_env<F>(source_string: &str,\n     let krate = ast_map.krate();\n \n     // run just enough stuff to build a tcx:\n-    let lang_items = lang_items::collect_language_items(krate, &sess);\n+    let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n     let resolve::CrateMap { def_map, freevars, .. } =\n         resolve::resolve_crate(&sess, &ast_map, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     {\n         let name = token::intern(name);\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            param_id: ast::DUMMY_NODE_ID,\n+            def_id: self.infcx.tcx.map.local_def_id(ast::DUMMY_NODE_ID),\n             space: space,\n             index: index,\n             name: name"}, {"sha": "91d1d398a0e548ea782b2c9c4be8fce78754a76e", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::def;\n-use middle::def_id::DefId;\n use middle::ty;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -29,7 +28,8 @@ pub enum MethodLateContext {\n }\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n-    match cx.tcx.impl_or_trait_items.borrow().get(&DefId::local(id)) {\n+    let def_id = cx.tcx.map.local_def_id(id);\n+    match cx.tcx.impl_or_trait_items.borrow().get(&def_id) {\n         None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n         Some(item) => match item.container() {\n             ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n@@ -274,7 +274,7 @@ impl LateLintPass for NonSnakeCase {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         if let &hir::PatIdent(_, ref path1, _) = &p.node {\n             let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-            if let Some(def::DefLocal(_)) = def {\n+            if let Some(def::DefLocal(..)) = def {\n                 self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n             }\n         }"}, {"sha": "1df3c1609b890894d02e116b5a538ff08c758db0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -202,10 +202,12 @@ impl LateLintPass for RawPointerDerive {\n             }\n             _ => return,\n         };\n-        if !did.is_local() {\n+        let node_id = if let Some(node_id) = cx.tcx.map.as_local_node_id(did) {\n+            node_id\n+        } else {\n             return;\n-        }\n-        let item = match cx.tcx.map.find(did.node) {\n+        };\n+        let item = match cx.tcx.map.find(node_id) {\n             Some(hir_map::NodeItem(item)) => item,\n             _ => return,\n         };\n@@ -246,7 +248,11 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                     return false;\n                 }\n                 let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n-                def == Some(def::DefLocal(fieldpat.node.pat.id))\n+                if let Some(def_id) = cx.tcx.map.opt_local_def_id(fieldpat.node.pat.id) {\n+                    def == Some(def::DefLocal(def_id, fieldpat.node.pat.id))\n+                } else {\n+                    false\n+                }\n             });\n             for fieldpat in field_pats {\n                 if let hir::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n@@ -458,13 +464,15 @@ impl LateLintPass for MissingDoc {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = cx.tcx.trait_ref_to_def_id(trait_ref);\n-                match cx.tcx.map.find(real_trait.node) {\n-                    Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n-                        for itm in impl_items {\n-                            self.private_traits.insert(itm.id);\n-                        }\n-                    },\n-                    _ => { }\n+                if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n+                    match cx.tcx.map.find(node_id) {\n+                        Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n+                            for itm in impl_items {\n+                                self.private_traits.insert(itm.id);\n+                            }\n+                        },\n+                        _ => { }\n+                    }\n                 }\n                 return\n             },\n@@ -555,15 +563,15 @@ impl LateLintPass for MissingCopyImplementations {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(DefId::local(item.id));\n+                let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n                 (def, cx.tcx.mk_struct(def,\n                                        cx.tcx.mk_substs(Substs::empty())))\n             }\n             hir::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                let def = cx.tcx.lookup_adt_def(DefId::local(item.id));\n+                let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n                 (def, cx.tcx.mk_enum(def,\n                                      cx.tcx.mk_substs(Substs::empty())))\n             }\n@@ -629,9 +637,11 @@ impl LateLintPass for MissingDebugImplementations {\n             let debug_def = cx.tcx.lookup_trait_def(debug);\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n-                if d.is_local() {\n-                    if let Some(ty_def) = cx.tcx.node_id_to_type(d.node).ty_to_def_id() {\n-                        impls.insert(ty_def.node);\n+                if let Some(n) = cx.tcx.map.as_local_node_id(d) {\n+                    if let Some(ty_def) = cx.tcx.node_id_to_type(n).ty_to_def_id() {\n+                        if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n+                            impls.insert(node_id);\n+                        }\n                     }\n                 }\n             });\n@@ -764,7 +774,7 @@ impl LateLintPass for UnconditionalRecursion {\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {\n-                cx.tcx.impl_or_trait_item(DefId::local(id)).as_opt_method()\n+                cx.tcx.impl_or_trait_item(cx.tcx.map.local_def_id(id)).as_opt_method()\n             }\n             // closures can't recur, so they don't matter.\n             FnKind::Closure => return\n@@ -877,8 +887,11 @@ impl LateLintPass for UnconditionalRecursion {\n                                   id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    tcx.def_map.borrow().get(&callee.id)\n-                        .map_or(false, |def| def.def_id() == DefId::local(fn_id))\n+                    tcx.def_map\n+                       .borrow()\n+                       .get(&callee.id)\n+                       .map_or(false,\n+                               |def| def.def_id() == tcx.map.local_def_id(fn_id))\n                 }\n                 _ => false\n             }\n@@ -888,20 +901,22 @@ impl LateLintPass for UnconditionalRecursion {\n         fn expr_refers_to_this_method(tcx: &ty::ctxt,\n                                       method: &ty::Method,\n                                       id: ast::NodeId) -> bool {\n-            let tables = tcx.tables.borrow();\n-\n             // Check for method calls and overloaded operators.\n-            if let Some(m) = tables.method_map.get(&ty::MethodCall::expr(id)) {\n+            let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n+            if let Some(m) = opt_m {\n                 if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                     return true;\n                 }\n             }\n \n             // Check for overloaded autoderef method calls.\n-            if let Some(&adjustment::AdjustDerefRef(ref adj)) = tables.adjustments.get(&id) {\n+            let opt_adj = tcx.tables.borrow().adjustments.get(&id).cloned();\n+            if let Some(adjustment::AdjustDerefRef(adj)) = opt_adj {\n                 for i in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tables.method_map.get(&method_call) {\n+                    if let Some(m) = tcx.tables.borrow().method_map\n+                                                        .get(&method_call)\n+                                                        .cloned() {\n                         if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n@@ -914,9 +929,13 @@ impl LateLintPass for UnconditionalRecursion {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n                         Some(def::DefMethod(def_id)) => {\n-                            let no_substs = &ty::ItemSubsts::empty();\n-                            let ts = tables.item_substs.get(&callee.id).unwrap_or(no_substs);\n-                            method_call_refers_to_method(tcx, method, def_id, &ts.substs, id)\n+                            let item_substs =\n+                                tcx.tables.borrow().item_substs\n+                                                   .get(&callee.id)\n+                                                   .cloned()\n+                                                   .unwrap_or_else(|| ty::ItemSubsts::empty());\n+                            method_call_refers_to_method(\n+                                tcx, method, def_id, &item_substs.substs, id)\n                         }\n                         _ => false\n                     }\n@@ -953,7 +972,12 @@ impl LateLintPass for UnconditionalRecursion {\n                         traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n                                                 trait_ref.to_poly_trait_predicate());\n \n-                    let param_env = ty::ParameterEnvironment::for_item(tcx, method.def_id.node);\n+                    // unwrap() is ok here b/c `method` is the method\n+                    // defined in this crate whose body we are\n+                    // checking, so it's always local\n+                    let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n+\n+                    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n                     let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env), false);\n                     let mut selcx = traits::SelectionContext::new(&infcx);\n                     match selcx.select(&obligation) {"}, {"sha": "f3549e6dda7c19ca203a8d10b36d99cd9951d2c1", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -139,8 +139,8 @@ impl LateLintPass for UnusedResults {\n             ty::TyBool => return,\n             ty::TyStruct(def, _) |\n             ty::TyEnum(def, _) => {\n-                if def.did.is_local() {\n-                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n+                if let Some(def_node_id) = cx.tcx.map.as_local_node_id(def.did) {\n+                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def_node_id) {\n                         check_must_use(cx, &it.attrs, s.span)\n                     } else {\n                         false"}, {"sha": "ebde7e1d097b367c74f5e5a14fb345870ae018f4", "filename": "src/librustc_mir/dump.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_mir%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_mir%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdump.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -26,7 +26,6 @@ use repr::Mir;\n use std::fs::File;\n use tcx::{PatNode, Cx};\n \n-use self::rustc::middle::def_id::DefId;\n use self::rustc::middle::infer;\n use self::rustc::middle::region::CodeExtentData;\n use self::rustc::middle::ty::{self, Ty};\n@@ -210,7 +209,7 @@ fn closure_self_ty<'a,'tcx>(tcx: &ty::ctxt<'tcx>,\n     let region =\n         tcx.mk_region(region);\n \n-    match tcx.closure_kind(DefId::local(closure_expr_id)) {\n+    match tcx.closure_kind(tcx.map.local_def_id(closure_expr_id)) {\n         ty::ClosureKind::FnClosureKind =>\n             tcx.mk_ref(region,\n                        ty::TypeAndMut { ty: closure_ty,"}, {"sha": "97becd474b1fec2473bb3a947b29596b6327014e", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -17,7 +17,6 @@ use tcx::block;\n use tcx::pattern::PatNode;\n use tcx::rustc::front::map;\n use tcx::rustc::middle::def;\n-use tcx::rustc::middle::def_id::DefId;\n use tcx::rustc::middle::region::CodeExtent;\n use tcx::rustc::middle::pat_util;\n use tcx::rustc::middle::ty::{self, Ty};\n@@ -570,13 +569,13 @@ fn convert_var<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     match def {\n-        def::DefLocal(node_id) => {\n+        def::DefLocal(_, node_id) => {\n             ExprKind::VarRef {\n                 id: node_id,\n             }\n         }\n \n-        def::DefUpvar(id_var, index, closure_expr_id) => {\n+        def::DefUpvar(_, id_var, index, closure_expr_id) => {\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n             let var_ty = cx.tcx.node_id_to_type(id_var);\n \n@@ -612,7 +611,7 @@ fn convert_var<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n             let region =\n                 cx.tcx.mk_region(region);\n \n-            let self_expr = match cx.tcx.closure_kind(DefId::local(closure_expr_id)) {\n+            let self_expr = match cx.tcx.closure_kind(cx.tcx.map.local_def_id(closure_expr_id)) {\n                 ty::ClosureKind::FnClosureKind => {\n                     let ref_closure_ty =\n                         cx.tcx.mk_ref(region,\n@@ -818,7 +817,7 @@ fn capture_freevar<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                                freevar: &ty::Freevar,\n                                freevar_ty: Ty<'tcx>)\n                                -> ExprRef<Cx<'a,'tcx>> {\n-    let id_var = freevar.def.def_id().node;\n+    let id_var = freevar.def.var_id();\n     let upvar_id = ty::UpvarId { var_id: id_var, closure_expr_id: closure_expr.id };\n     let upvar_capture = cx.tcx.upvar_capture(upvar_id).unwrap();\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);"}, {"sha": "ca5411f9c790a5e3a3c9d05da956725e71ff1322", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 63, "deletions": 40, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -263,19 +263,26 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     hir::TyPath(..) => {\n                         match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                             def::DefPrimTy(..) => true,\n+                            def::DefSelfTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n-                                !did.is_local() ||\n-                                 self.exported_items.contains(&did.node)\n+                                if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+                                    self.exported_items.contains(&node_id)\n+                                } else {\n+                                    true\n+                                }\n                             }\n                         }\n                     }\n                     _ => true,\n                 };\n-                let tr = self.tcx.impl_trait_ref(DefId::local(item.id));\n+                let tr = self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id));\n                 let public_trait = tr.clone().map_or(false, |tr| {\n-                    !tr.def_id.is_local() ||\n-                     self.exported_items.contains(&tr.def_id.node)\n+                    if let Some(node_id) = self.tcx.map.as_local_node_id(tr.def_id) {\n+                        self.exported_items.contains(&node_id)\n+                    } else {\n+                        true\n+                    }\n                 });\n \n                 if public_ty || public_trait {\n@@ -331,11 +338,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemTy(ref ty, _) if public_first => {\n                 if let hir::TyPath(..) = ty.node {\n                     match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n-                        def::DefPrimTy(..) | def::DefTyParam(..) => {},\n+                        def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {},\n                         def => {\n                             let did = def.def_id();\n-                            if did.is_local() {\n-                                self.exported_items.insert(did.node);\n+                            if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+                                self.exported_items.insert(node_id);\n                             }\n                         }\n                     }\n@@ -363,8 +370,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         if self.prev_exported {\n             assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n             for export in self.export_map.get(&id).unwrap() {\n-                if export.def_id.is_local() {\n-                    self.reexports.insert(export.def_id.node);\n+                if let Some(node_id) = self.tcx.map.as_local_node_id(export.def_id) {\n+                    self.reexports.insert(node_id);\n                 }\n             }\n         }\n@@ -404,7 +411,9 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Determines whether the given definition is public from the point of view\n     // of the current item.\n     fn def_privacy(&self, did: DefId) -> PrivacyResult {\n-        if !did.is_local() {\n+        let node_id = if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+            node_id\n+        } else {\n             if self.external_exports.contains(&did) {\n                 debug!(\"privacy - {:?} was externally exported\", did);\n                 return Allowable;\n@@ -496,19 +505,19 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                     ExternallyDenied\n                 }\n             };\n-        }\n+        };\n \n         debug!(\"privacy - local {} not public all the way down\",\n-               self.tcx.map.node_to_string(did.node));\n+               self.tcx.map.node_to_string(node_id));\n         // return quickly for things in the same module\n-        if self.parents.get(&did.node) == self.parents.get(&self.curitem) {\n+        if self.parents.get(&node_id) == self.parents.get(&self.curitem) {\n             debug!(\"privacy - same parent, we're done here\");\n             return Allowable;\n         }\n \n         // We now know that there is at least one private member between the\n         // destination and the root.\n-        let mut closest_private_id = did.node;\n+        let mut closest_private_id = node_id;\n         loop {\n             debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n             let vis = match self.tcx.map.find(closest_private_id) {\n@@ -578,6 +587,15 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         }\n     }\n \n+    /// True if `id` is both local and private-accessible\n+    fn local_private_accessible(&self, did: DefId) -> bool {\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+            self.private_accessible(node_id)\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// For a local private node in the AST, this function will determine\n     /// whether the node is accessible by the current module that iteration is\n     /// inside.\n@@ -639,11 +657,15 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             DisallowedBy(id) => id,\n         };\n \n-        // If we're disallowed by a particular id, then we attempt to give a\n-        // nice error message to say why it was disallowed. It was either\n-        // because the item itself is private or because its parent is private\n-        // and its parent isn't in our ancestry.\n-        let (err_span, err_msg) = if id == source_did.unwrap_or(to_check).node {\n+        // If we're disallowed by a particular id, then we attempt to\n+        // give a nice error message to say why it was disallowed. It\n+        // was either because the item itself is private or because\n+        // its parent is private and its parent isn't in our\n+        // ancestry. (Both the item being checked and its parent must\n+        // be local.)\n+        let def_id = source_did.unwrap_or(to_check);\n+        let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n+        let (err_span, err_msg) = if id == node_id {\n             return Some((span, format!(\"{} is private\", msg), None));\n         } else {\n             (span, format!(\"{} is inaccessible\", msg))\n@@ -663,8 +685,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                         };\n                         let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n                         let did = def.def_id();\n-                        assert!(did.is_local());\n-                        match self.tcx.map.get(did.node) {\n+                        let node_id = self.tcx.map.as_local_node_id(did).unwrap();\n+                        match self.tcx.map.get(node_id) {\n                             ast_map::NodeItem(item) => item,\n                             _ => self.tcx.sess.span_bug(item.span,\n                                                         \"path is not an item\")\n@@ -699,9 +721,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             }\n             UnnamedField(idx) => &v.fields[idx]\n         };\n-        if field.vis == hir::Public ||\n-            (field.did.is_local() && self.private_accessible(field.did.node)) {\n-            return\n+        if field.vis == hir::Public || self.local_private_accessible(field.did) {\n+            return;\n         }\n \n         let struct_desc = match def.adt_kind() {\n@@ -891,11 +912,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != hir::Public && (\n-                            !f.did.is_local() ||\n-                                    !self.private_accessible(f.did.node))\n-                        });\n-\n+                        f.vis != hir::Public && !self.local_private_accessible(f.did)\n+                    });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,\n                                   \"cannot invoke tuple struct constructor with private \\\n@@ -1131,21 +1149,22 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n         let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n             // `int` etc. (None doesn't seem to occur.)\n-            None | Some(def::DefPrimTy(..)) => return false,\n+            None | Some(def::DefPrimTy(..)) | Some(def::DefSelfTy(..)) => return false,\n             Some(def) => def.def_id(),\n         };\n+\n         // A path can only be private if:\n         // it's in this crate...\n-        if !did.is_local() {\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+            // .. and it corresponds to a private type in the AST (this returns\n+            // None for type parameters)\n+            match self.tcx.map.find(node_id) {\n+                Some(ast_map::NodeItem(ref item)) => item.vis != hir::Public,\n+                Some(_) | None => false,\n+            }\n+        } else {\n             return false\n         }\n-\n-        // .. and it corresponds to a private type in the AST (this returns\n-        // None for type parameters)\n-        match self.tcx.map.find(did.node) {\n-            Some(ast_map::NodeItem(ref item)) => item.vis != hir::Public,\n-            Some(_) | None => false,\n-        }\n     }\n \n     fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n@@ -1245,7 +1264,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                               |tr| {\n                         let did = self.tcx.trait_ref_to_def_id(tr);\n \n-                        !did.is_local() || self.trait_is_public(did.node)\n+                        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+                            self.trait_is_public(node_id)\n+                        } else {\n+                            true // external traits must be public\n+                        }\n                     });\n \n                 // `true` iff this is a trait impl or at least one method is public."}, {"sha": "f74144565fc588415c475b944dfbf40193f61072", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -34,7 +34,7 @@ use self::NamespaceError::*;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n-use rustc::middle::def_id::DefId;\n+use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n \n use syntax::ast::{Name, NodeId};\n use syntax::attr::AttrMetaMethods;\n@@ -387,7 +387,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemExternCrate(_) => {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 if let Some(crate_id) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n-                    let def_id = DefId { krate: crate_id, node: 0 };\n+                    let def_id = DefId { krate: crate_id, index: CRATE_DEF_INDEX };\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(Rc::downgrade(parent), name);\n                     let external_module = Rc::new(Module::new(parent_link,\n@@ -409,7 +409,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n \n                 let parent_link = self.get_parent_link(parent, name);\n-                let def_id = DefId { krate: 0, node: item.id };\n+                let def_id = self.ast_map.local_def_id(item.id);\n                 name_bindings.define_module(parent_link,\n                                             Some(def_id),\n                                             NormalModuleKind,\n@@ -427,18 +427,20 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n                 let mutbl = m == hir::MutMutable;\n \n-                name_bindings.define_value(DefStatic(DefId::local(item.id), mutbl), sp, modifiers);\n+                name_bindings.define_value(DefStatic(self.ast_map.local_def_id(item.id), mutbl),\n+                                           sp,\n+                                           modifiers);\n                 parent.clone()\n             }\n             ItemConst(_, _) => {\n                 self.add_child(name, parent, ForbidDuplicateValues, sp)\n-                    .define_value(DefConst(DefId::local(item.id)), sp, modifiers);\n+                    .define_value(DefConst(self.ast_map.local_def_id(item.id)), sp, modifiers);\n                 parent.clone()\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n \n-                let def = DefFn(DefId::local(item.id), false);\n+                let def = DefFn(self.ast_map.local_def_id(item.id), false);\n                 name_bindings.define_value(def, sp, modifiers);\n                 parent.clone()\n             }\n@@ -448,12 +450,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings =\n                     self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n \n-                name_bindings.define_type(DefTy(DefId::local(item.id), false), sp,\n+                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), false), sp,\n                                           modifiers);\n \n                 let parent_link = self.get_parent_link(parent, name);\n                 name_bindings.set_module_kind(parent_link,\n-                                              Some(DefId::local(item.id)),\n+                                              Some(self.ast_map.local_def_id(item.id)),\n                                               TypeModuleKind,\n                                               false,\n                                               is_public,\n@@ -465,11 +467,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings =\n                     self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n \n-                name_bindings.define_type(DefTy(DefId::local(item.id), true), sp, modifiers);\n+                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), true),\n+                                          sp,\n+                                          modifiers);\n \n                 let parent_link = self.get_parent_link(parent, name);\n                 name_bindings.set_module_kind(parent_link,\n-                                              Some(DefId::local(item.id)),\n+                                              Some(self.ast_map.local_def_id(item.id)),\n                                               EnumModuleKind,\n                                               false,\n                                               is_public,\n@@ -478,9 +482,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let module = name_bindings.get_module();\n \n                 for variant in &(*enum_definition).variants {\n+                    let item_def_id = self.ast_map.local_def_id(item.id);\n                     self.build_reduced_graph_for_variant(\n                         &**variant,\n-                        DefId::local(item.id),\n+                        item_def_id,\n                         &module);\n                 }\n                 parent.clone()\n@@ -497,12 +502,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, forbid, sp);\n \n                 // Define a name in the type namespace.\n-                name_bindings.define_type(DefTy(DefId::local(item.id), false), sp, modifiers);\n+                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), false),\n+                                          sp,\n+                                          modifiers);\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if let Some(cid) = ctor_id {\n-                    name_bindings.define_value(DefStruct(DefId::local(cid)), sp, modifiers);\n+                    name_bindings.define_value(DefStruct(self.ast_map.local_def_id(cid)),\n+                                               sp,\n+                                               modifiers);\n                 }\n \n                 // Record the def ID and fields of this struct.\n@@ -512,7 +521,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         UnnamedField(_) => None\n                     }\n                 }).collect();\n-                self.structs.insert(DefId::local(item.id), named_fields);\n+                let item_def_id = self.ast_map.local_def_id(item.id);\n+                self.structs.insert(item_def_id, named_fields);\n \n                 parent.clone()\n             }\n@@ -527,14 +537,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 // Add all the items within to a new module.\n                 let parent_link = self.get_parent_link(parent, name);\n                 name_bindings.define_module(parent_link,\n-                                            Some(DefId::local(item.id)),\n+                                            Some(self.ast_map.local_def_id(item.id)),\n                                             TraitModuleKind,\n                                             false,\n                                             is_public,\n                                             sp);\n                 let module_parent = name_bindings.get_module();\n \n-                let def_id = DefId::local(item.id);\n+                let def_id = self.ast_map.local_def_id(item.id);\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n@@ -545,25 +555,25 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                     match trait_item.node {\n                         hir::ConstTraitItem(..) => {\n-                            let def = DefAssociatedConst(DefId::local(trait_item.id));\n+                            let def = DefAssociatedConst(self.ast_map.local_def_id(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         hir::MethodTraitItem(..) => {\n-                            let def = DefMethod(DefId::local(trait_item.id));\n+                            let def = DefMethod(self.ast_map.local_def_id(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         hir::TypeTraitItem(..) => {\n-                            let def = DefAssociatedTy(DefId::local(item.id),\n-                                                      DefId::local(trait_item.id));\n+                            let def = DefAssociatedTy(self.ast_map.local_def_id(item.id),\n+                                                      self.ast_map.local_def_id(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_type(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                     }\n \n-                    self.trait_item_map.insert((trait_item.name, def_id),\n-                                               DefId::local(trait_item.id));\n+                    let trait_item_def_id = self.ast_map.local_def_id(trait_item.id);\n+                    self.trait_item_map.insert((trait_item.name, def_id), trait_item_def_id);\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n@@ -583,7 +593,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             TupleVariantKind(_) => false,\n             StructVariantKind(_) => {\n                 // Not adding fields for variants as they are not accessed with a self receiver\n-                self.structs.insert(DefId::local(variant.node.id), Vec::new());\n+                let variant_def_id = self.ast_map.local_def_id(variant.node.id);\n+                self.structs.insert(variant_def_id, Vec::new());\n                 true\n             }\n         };\n@@ -594,10 +605,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         // variants are always treated as importable to allow them to be glob\n         // used\n         child.define_value(DefVariant(item_id,\n-                                      DefId::local(variant.node.id), is_exported),\n+                                      self.ast_map.local_def_id(variant.node.id), is_exported),\n                            variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n         child.define_type(DefVariant(item_id,\n-                                     DefId::local(variant.node.id), is_exported),\n+                                     self.ast_map.local_def_id(variant.node.id), is_exported),\n                           variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n     }\n \n@@ -618,10 +629,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n-                DefFn(DefId::local(foreign_item.id), false)\n+                DefFn(self.ast_map.local_def_id(foreign_item.id), false)\n             }\n             ForeignItemStatic(_, m) => {\n-                DefStatic(DefId::local(foreign_item.id), m)\n+                DefStatic(self.ast_map.local_def_id(foreign_item.id), m)\n             }\n         };\n         name_bindings.define_value(def, foreign_item.span, modifiers);\n@@ -805,7 +816,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             self.structs.insert(def_id, fields);\n           }\n           DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n-          DefUse(..) | DefUpvar(..) | DefRegion(..) |\n+          DefUse(..) | DefUpvar(..) |\n           DefLabel(..) | DefSelfTy(..) => {\n             panic!(\"didn't expect `{:?}`\", def);\n           }"}, {"sha": "40477d8698ebec8a61f8cf6291421fb05bde3e44", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -65,7 +65,7 @@ use rustc::util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast;\n-use syntax::ast::{Ident, Name, NodeId, CrateNum, TyIs, TyI8, TyI16, TyI32, TyI64};\n+use syntax::ast::{CRATE_NODE_ID, Ident, Name, NodeId, CrateNum, TyIs, TyI8, TyI16, TyI32, TyI64};\n use syntax::ast::{TyUs, TyU8, TyU16, TyU32, TyU64, TyF64, TyF32};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n@@ -1188,8 +1188,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n            make_glob_map: MakeGlobMap) -> Resolver<'a, 'tcx> {\n         let graph_root = NameBindings::new();\n \n+        let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n         graph_root.define_module(NoParentLink,\n-                                 Some(DefId { krate: 0, node: 0 }),\n+                                 Some(root_def_id),\n                                  NormalModuleKind,\n                                  false,\n                                  true,\n@@ -1257,8 +1258,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n-        if did.is_local() {\n-            self.ast_map.expect_item(did.node).name\n+        if let Some(node_id) = self.ast_map.as_local_node_id(did) {\n+            self.ast_map.expect_item(node_id).name\n         } else {\n             csearch::get_trait_name(&self.session.cstore, did)\n         }\n@@ -1981,19 +1982,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.session.span_bug(span,\n                     &format!(\"unexpected {:?} in bindings\", def))\n             }\n-            DefLocal(node_id) => {\n+            DefLocal(_, node_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n                             let prev_def = def;\n+                            let node_def_id = self.ast_map.local_def_id(node_id);\n \n                             let mut seen = self.freevars_seen.borrow_mut();\n                             let seen = seen.entry(function_id).or_insert_with(|| NodeMap());\n                             if let Some(&index) = seen.get(&node_id) {\n-                                def = DefUpvar(node_id, index, function_id);\n+                                def = DefUpvar(node_def_id, node_id, index, function_id);\n                                 continue;\n                             }\n                             let mut freevars = self.freevars.borrow_mut();\n@@ -2002,7 +2004,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let depth = vec.len();\n                             vec.push(Freevar { def: prev_def, span: span });\n \n-                            def = DefUpvar(node_id, depth, function_id);\n+                            def = DefUpvar(node_def_id, node_id, depth, function_id);\n                             seen.insert(node_id, depth);\n                         }\n                         ItemRibKind | MethodRibKind => {\n@@ -2156,7 +2158,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                TypeSpace,\n                                                                ItemRibKind),\n                                              |this| {\n-                    this.with_self_rib(DefSelfTy(Some(DefId::local(item.id)), None), |this| {\n+                    let local_def_id = this.ast_map.local_def_id(item.id);\n+                    this.with_self_rib(DefSelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_ty_param_bound, bounds);\n \n@@ -2280,7 +2283,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     function_type_rib.bindings.insert(name,\n                         DlDef(DefTyParam(space,\n                                          index as u32,\n-                                         DefId::local(type_parameter.id),\n+                                         self.ast_map.local_def_id(type_parameter.id),\n                                          name)));\n                 }\n                 self.type_ribs.push(function_type_rib);\n@@ -2815,7 +2818,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             debug!(\"(resolving pattern) binding `{}`\",\n                                    renamed);\n \n-                            let def = DefLocal(pattern.id);\n+                            let def_id = self.ast_map.local_def_id(pattern.id);\n+                            let def = DefLocal(def_id, pattern.id);\n \n                             // Record the definition so that later passes\n                             // will be able to distinguish variants from\n@@ -3497,8 +3501,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         fn is_static_method(this: &Resolver, did: DefId) -> bool {\n-            if did.is_local() {\n-                let sig = match this.ast_map.get(did.node) {\n+            if let Some(node_id) = this.ast_map.as_local_node_id(did) {\n+                let sig = match this.ast_map.get(node_id) {\n                     hir_map::NodeTraitItem(trait_item) => match trait_item.node {\n                         hir::MethodTraitItem(ref sig, _) => sig,\n                         _ => return false\n@@ -3845,9 +3849,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         fn add_trait_info(found_traits: &mut Vec<DefId>,\n                           trait_def_id: DefId,\n                           name: Name) {\n-            debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n-                trait_def_id.krate,\n-                trait_def_id.node,\n+            debug!(\"(adding trait info) found trait {:?} for method '{}'\",\n+                trait_def_id,\n                 name);\n             found_traits.push(trait_def_id);\n         }"}, {"sha": "0eb1e2cc06f613c2b550d8abc9c7bcda03de404d", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -102,9 +102,9 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         self.add_exports_for_module(&mut exports, module_);\n         match module_.def_id.get() {\n             Some(def_id) => {\n-                self.export_map.insert(def_id.node, exports);\n-                debug!(\"(computing exports) writing exports for {} (some)\",\n-                       def_id.node);\n+                let node_id = self.ast_map.as_local_node_id(def_id).unwrap();\n+                self.export_map.insert(node_id, exports);\n+                debug!(\"(computing exports) writing exports for {} (some)\", node_id);\n             }\n             None => {}\n         }"}, {"sha": "6cbee926a08e14e430ff7bc8ad49d2ac27d4394a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -25,7 +25,7 @@ use metadata::loader::METADATA_FILENAME;\n use metadata::{encoder, cstore, filesearch, csearch, creader};\n use middle::dependency_format::Linkage;\n use middle::ty::{self, Ty};\n-use rustc::front::map::{PathElem, PathElems, PathName};\n+use rustc::front::map::DefPath;\n use trans::{CrateContext, CrateTranslation, gensym_name};\n use util::common::time;\n use util::sha2::{Digest, Sha256};\n@@ -36,6 +36,7 @@ use std::env;\n use std::ffi::OsString;\n use std::fs::{self, PathExt};\n use std::io::{self, Read, Write};\n+use std::iter::once;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n@@ -44,7 +45,7 @@ use flate;\n use serialize::hex::ToHex;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, InternedString};\n use syntax::attr::AttrMetaMethods;\n \n use rustc_front::hir;\n@@ -284,8 +285,7 @@ pub fn sanitize(s: &str) -> String {\n     return result;\n }\n \n-pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n-                                           hash: Option<&str>) -> String {\n+pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -> String {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n     //\n@@ -308,8 +308,8 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n     }\n \n     // First, connect each component with <len, name> pairs.\n-    for e in path {\n-        push(&mut n, &e.name().as_str())\n+    for data in path {\n+        push(&mut n, &data);\n     }\n \n     match hash {\n@@ -321,11 +321,13 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n     n\n }\n \n-pub fn exported_name(path: PathElems, hash: &str) -> String {\n+pub fn exported_name(path: DefPath, hash: &str) -> String {\n+    let path = path.into_iter()\n+                   .map(|e| e.data.as_interned_str());\n     mangle(path, Some(hash))\n }\n \n-pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathElems,\n+pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: DefPath,\n                                       t: Ty<'tcx>, id: ast::NodeId) -> String {\n     let mut hash = get_symbol_hash(ccx, t);\n \n@@ -353,14 +355,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n-    let path = [PathName(token::intern(&t.to_string())),\n-                gensym_name(name)];\n+    let path = [token::intern(&t.to_string()).as_str(), gensym_name(name).as_str()];\n     let hash = get_symbol_hash(ccx, t);\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n \n-pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n-    mangle(path.chain(Some(gensym_name(flav))), None)\n+pub fn mangle_internal_name_by_path_and_seq(path: DefPath, flav: &str) -> String {\n+    let names =\n+        path.into_iter()\n+            .map(|e| e.data.as_interned_str())\n+            .chain(once(gensym_name(flav).as_str())); // append unique version of \"flav\"\n+    mangle(names, None)\n }\n \n pub fn get_linker(sess: &Session) -> (String, Command) {"}, {"sha": "dc0bdd8573d87f98adcede2202b0e7579d89a9e3", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -235,7 +235,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n         let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n-            def::DefPrimTy(_) => None,\n+            def::DefPrimTy(..) => None,\n+            def::DefSelfTy(..) => None,\n             _ => Some(def.def_id()),\n         }\n     }\n@@ -257,14 +258,13 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             def::DefStatic(_, _) |\n             def::DefConst(_) |\n             def::DefAssociatedConst(..) |\n-            def::DefLocal(_) |\n+            def::DefLocal(..) |\n             def::DefVariant(_, _, _) |\n             def::DefUpvar(..) => Some(recorder::VarRef),\n \n             def::DefFn(..) => Some(recorder::FnRef),\n \n             def::DefSelfTy(..) |\n-            def::DefRegion(_) |\n             def::DefLabel(_) |\n             def::DefTyParam(..) |\n             def::DefUse(_) |\n@@ -721,7 +721,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     }\n                 }\n             }\n-            def::DefLocal(_) |\n+            def::DefLocal(..) |\n             def::DefStatic(_,_) |\n             def::DefConst(..) |\n             def::DefAssociatedConst(..) |\n@@ -1170,7 +1170,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             }\n             let def = def_map.get(&id).unwrap().full_def();\n             match def {\n-                def::DefLocal(id) => {\n+                def::DefLocal(_, id) => {\n                     let value = if immut == ast::MutImmutable {\n                         self.span.snippet(p.span).to_string()\n                     } else {"}, {"sha": "00781bd27110a8a1633ba1b2e1f4d2b41feb8daa", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -10,7 +10,7 @@\n \n use middle::ty;\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n \n use std::env;\n use std::fs::{self, File};\n@@ -348,15 +348,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_method_data(&self, id: ast::NodeId, name: ast::Name, span: Span) -> FunctionData {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let qualname = match self.tcx.impl_of_method(DefId::local(id)) {\n-            Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n-                NodeItem(item) => {\n+        let qualname = match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n+            Some(impl_id) => match self.tcx.map.get_if_local(impl_id) {\n+                Some(NodeItem(item)) => {\n                     match item.node {\n                         hir::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from(\"<\");\n                             result.push_str(&rustc_front::print::pprust::ty_to_string(&**ty));\n \n-                            match self.tcx.trait_of_item(DefId::local(id)) {\n+                            match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n@@ -369,27 +369,27 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         }\n                         _ => {\n                             self.tcx.sess.span_bug(span,\n-                                &format!(\"Container {} for method {} not an impl?\",\n-                                         impl_id.node, id));\n+                                &format!(\"Container {:?} for method {} not an impl?\",\n+                                         impl_id, id));\n                         }\n                     }\n                 }\n-                _ => {\n+                r => {\n                     self.tcx.sess.span_bug(span,\n-                        &format!(\"Container {} for method {} is not a node item {:?}\",\n-                                 impl_id.node, id, self.tcx.map.get(impl_id.node)));\n-                }\n+                        &format!(\"Container {:?} for method {} is not a node item {:?}\",\n+                                 impl_id, id, r));\n+                },\n             },\n-            None => match self.tcx.trait_of_item(DefId::local(id)) {\n+            None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                 Some(def_id) => {\n-                    match self.tcx.map.get(def_id.node) {\n-                        NodeItem(_) => {\n+                    match self.tcx.map.get_if_local(def_id) {\n+                        Some(NodeItem(_)) => {\n                             format!(\"::{}\", self.tcx.item_path_str(def_id))\n                         }\n-                        _ => {\n+                        r => {\n                             self.tcx.sess.span_bug(span,\n-                                &format!(\"Could not find container {} for method {}\",\n-                                         def_id.node, id));\n+                                &format!(\"Could not find container {:?} for method {}, got {:?}\",\n+                                         def_id, id, r));\n                         }\n                     }\n                 }\n@@ -402,11 +402,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let qualname = format!(\"{}::{}\", qualname, name);\n \n-        let decl_id = self.tcx.trait_item_of_item(DefId::local(id))\n+        let def_id = self.tcx.map.local_def_id(id);\n+        let decl_id =\n+            self.tcx.trait_item_of_item(def_id)\n             .and_then(|new_id| {\n-                let def_id = new_id.def_id();\n-                if def_id.node != 0 && def_id != DefId::local(id) {\n-                    Some(def_id)\n+                let new_def_id = new_id.def_id();\n+                if new_def_id != def_id {\n+                    Some(new_def_id)\n                 } else {\n                     None\n                 }\n@@ -595,13 +597,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     fn trait_method_has_body(&self, mr: &ty::ImplOrTraitItem) -> bool {\n         let def_id = mr.def_id();\n-        if def_id.krate != LOCAL_CRATE {\n-            return false;\n-        }\n-\n-        let trait_item = self.tcx.map.expect_trait_item(def_id.node);\n-        if let hir::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n-            true\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+            let trait_item = self.tcx.map.expect_trait_item(node_id);\n+            if let hir::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n+                true\n+            } else {\n+                false\n+            }\n         } else {\n             false\n         }\n@@ -635,7 +637,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n         let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n-            def::DefPrimTy(_) => None,\n+            def::DefPrimTy(_) | def::DefSelfTy(..) => None,\n             _ => Some(def.def_id()),\n         }\n     }"}, {"sha": "f388f76c744e6ea6bd5e19dbffe80f5b2db97509", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -13,15 +13,16 @@ pub use self::Row::*;\n use super::escape;\n use super::span_utils::SpanUtils;\n \n-use middle::def_id::DefId;\n+use metadata::cstore::LOCAL_CRATE;\n+use middle::def_id::{CRATE_DEF_INDEX, DefId};\n \n use std::io::Write;\n \n use syntax::ast;\n use syntax::ast::NodeId;\n use syntax::codemap::*;\n \n-const ZERO_DEF_ID: DefId = DefId { node: 0, krate: 0 };\n+const CRATE_ROOT_DEF_ID: DefId = DefId { krate: LOCAL_CRATE, index: CRATE_DEF_INDEX };\n \n pub struct Recorder {\n     // output file\n@@ -381,7 +382,7 @@ impl<'a> FmtStrs<'a> {\n                       decl_id: Option<DefId>,\n                       scope_id: NodeId) {\n         let values = match decl_id {\n-            Some(decl_id) => svec!(id, name, decl_id.node, decl_id.krate, scope_id),\n+            Some(decl_id) => svec!(id, name, decl_id.index.as_usize(), decl_id.krate, scope_id),\n             None => svec!(id, name, \"\", \"\", scope_id),\n         };\n         self.check_and_record(Function,\n@@ -436,15 +437,15 @@ impl<'a> FmtStrs<'a> {\n                     ref_id: Option<DefId>,\n                     trait_id: Option<DefId>,\n                     scope_id: NodeId) {\n-        let ref_id = ref_id.unwrap_or(ZERO_DEF_ID);\n-        let trait_id = trait_id.unwrap_or(ZERO_DEF_ID);\n+        let ref_id = ref_id.unwrap_or(CRATE_ROOT_DEF_ID);\n+        let trait_id = trait_id.unwrap_or(CRATE_ROOT_DEF_ID);\n         self.check_and_record(Impl,\n                               span,\n                               sub_span,\n                               svec!(id,\n-                                    ref_id.node,\n+                                    ref_id.index.as_usize(),\n                                     ref_id.krate,\n-                                    trait_id.node,\n+                                    trait_id.index.as_usize(),\n                                     trait_id.krate,\n                                     scope_id));\n     }\n@@ -469,14 +470,11 @@ impl<'a> FmtStrs<'a> {\n                          mod_id: Option<DefId>,\n                          name: &str,\n                          parent: NodeId) {\n-        let (mod_node, mod_crate) = match mod_id {\n-            Some(mod_id) => (mod_id.node, mod_id.krate),\n-            None => (0, 0),\n-        };\n+        let mod_id = mod_id.unwrap_or(CRATE_ROOT_DEF_ID);\n         self.check_and_record(UseAlias,\n                               span,\n                               sub_span,\n-                              svec!(id, mod_node, mod_crate, name, parent));\n+                              svec!(id, mod_id.index.as_usize(), mod_id.krate, name, parent));\n     }\n \n     pub fn use_glob_str(&mut self,\n@@ -513,7 +511,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(Inheritance,\n                               span,\n                               sub_span,\n-                              svec!(base_id.node,\n+                              svec!(base_id.index.as_usize(),\n                                     base_id.krate,\n                                     deriv_id,\n                                     0));\n@@ -527,7 +525,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(FnCall,\n                               span,\n                               sub_span,\n-                              svec!(id.node, id.krate, \"\", scope_id));\n+                              svec!(id.index.as_usize(), id.krate, \"\", scope_id));\n     }\n \n     pub fn meth_call_str(&mut self,\n@@ -536,18 +534,15 @@ impl<'a> FmtStrs<'a> {\n                          defid: Option<DefId>,\n                          declid: Option<DefId>,\n                          scope_id: NodeId) {\n-        let (dfn, dfk) = match defid {\n-            Some(defid) => (defid.node, defid.krate),\n-            None => (0, 0),\n-        };\n+        let defid = defid.unwrap_or(CRATE_ROOT_DEF_ID);\n         let (dcn, dck) = match declid {\n-            Some(declid) => (s!(declid.node), s!(declid.krate)),\n+            Some(declid) => (s!(declid.index.as_usize()), s!(declid.krate)),\n             None => (\"\".to_string(), \"\".to_string()),\n         };\n         self.check_and_record(MethodCall,\n                               span,\n                               sub_span,\n-                              svec!(dfn, dfk, dcn, dck, scope_id));\n+                              svec!(defid.index.as_usize(), defid.krate, dcn, dck, scope_id));\n     }\n \n     pub fn sub_mod_ref_str(&mut self, span: Span, sub_span: Span, qualname: &str, parent: NodeId) {\n@@ -600,6 +595,6 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(kind,\n                               span,\n                               sub_span,\n-                              svec!(id.node, id.krate, \"\", scope_id));\n+                              svec!(id.index.as_usize(), id.krate, \"\", scope_id));\n     }\n }"}, {"sha": "1eb4a7a5e0c45533572c7c17c176e7ee91e1cde4", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -1432,19 +1432,19 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool {\n     let (vid, field) = match discr.node {\n         hir::ExprPath(..) => match bcx.def(discr.id) {\n-            def::DefLocal(vid) | def::DefUpvar(vid, _, _) => (vid, None),\n+            def::DefLocal(_, vid) | def::DefUpvar(_, vid, _, _) => (vid, None),\n             _ => return false\n         },\n         hir::ExprField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n-                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _, _)) => vid,\n+                Some(def::DefLocal(_, vid)) | Some(def::DefUpvar(_, vid, _, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::NamedField(field.node)))\n         },\n         hir::ExprTupField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n-                Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _, _)) => vid,\n+                Some(def::DefLocal(_, vid)) | Some(def::DefUpvar(_, vid, _, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::PositionalField(field.node)))"}, {"sha": "05b20ac3fb7d436a3d3fead1315e4b7f245f2502", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -37,7 +37,7 @@ use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n use middle::cfg;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::pat_util::simple_name;\n@@ -1286,7 +1286,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n \n     // Create the drop-flag hints for every unfragmented path in the function.\n     let tcx = fcx.ccx.tcx();\n-    let fn_did = DefId { krate: LOCAL_CRATE, node: fcx.id };\n+    let fn_did = tcx.map.local_def_id(fcx.id);\n     let mut hints = fcx.lldropflag_hints.borrow_mut();\n     let fragment_infos = tcx.fragment_infos.borrow();\n \n@@ -1576,7 +1576,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            param_substs);\n \n     let has_env = match closure_env {\n-        closure::ClosureEnv::Closure(_) => true,\n+        closure::ClosureEnv::Closure(..) => true,\n         closure::ClosureEnv::NotClosure => false,\n     };\n \n@@ -2085,7 +2085,8 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                     // error in trans. This is used to write compile-fail tests\n                     // that actually test that compilation succeeds without\n                     // reporting an error.\n-                    if ccx.tcx().has_attr(DefId::local(item.id), \"rustc_error\") {\n+                    let item_def_id = ccx.tcx().map.local_def_id(item.id);\n+                    if ccx.tcx().has_attr(item_def_id, \"rustc_error\") {\n                         ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n                     }\n                 }\n@@ -2252,13 +2253,14 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                     Ok(id) => id,\n                     Err(s) => { ccx.sess().fatal(&s[..]); }\n                 };\n-                let start_fn = if start_def_id.is_local() {\n-                    get_item_val(ccx, start_def_id.node)\n-                } else {\n-                    let start_fn_type = csearch::get_type(ccx.tcx(),\n-                                                          start_def_id).ty;\n-                    trans_external_path(ccx, start_def_id, start_fn_type)\n-                };\n+                let start_fn =\n+                    if let Some(start_node_id) = ccx.tcx().map.as_local_node_id(start_def_id) {\n+                        get_item_val(ccx, start_node_id)\n+                    } else {\n+                        let start_fn_type = csearch::get_type(ccx.tcx(),\n+                                                              start_def_id).ty;\n+                        trans_external_path(ccx, start_def_id, start_fn_type)\n+                    };\n \n                 let args = {\n                     let opaque_rust_main = llvm::LLVMBuildPointerCast(bld,\n@@ -2307,10 +2309,11 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n     match attr::find_export_name_attr(ccx.sess().diagnostic(), attrs) {\n         // Use provided name\n         Some(name) => name.to_string(),\n-        _ => ccx.tcx().map.with_path(id, |path| {\n+        _ => {\n+            let path = ccx.tcx().map.def_path_from_id(id);\n             if attr::contains_name(attrs, \"no_mangle\") {\n                 // Don't mangle\n-                path.last().unwrap().to_string()\n+                path.last().unwrap().data.to_string()\n             } else {\n                 match weak_lang_items::link_name(attrs) {\n                     Some(name) => name.to_string(),\n@@ -2320,7 +2323,7 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n                     }\n                 }\n             }\n-        })\n+        }\n     }\n }\n "}, {"sha": "b806f36b9109fbf5ac95046daa2b682a8552abc4", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -22,8 +22,9 @@ use arena::TypedArena;\n use back::link;\n use session;\n use llvm::{self, ValueRef, get_params};\n+use metadata::cstore::LOCAL_CRATE;\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::infer::normalize_associated_type;\n use middle::subst;\n use middle::subst::{Substs};\n@@ -139,8 +140,10 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n         match def {\n             def::DefFn(did, _) if {\n                 let maybe_def_id = inline::get_local_instance(bcx.ccx(), did);\n-                let maybe_ast_node = maybe_def_id.and_then(|def_id| bcx.tcx().map\n-                                                                             .find(def_id.node));\n+                let maybe_ast_node = maybe_def_id.and_then(|def_id| {\n+                    let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n+                    bcx.tcx().map.find(node_id)\n+                });\n                 match maybe_ast_node {\n                     Some(hir_map::NodeStructCtor(_)) => true,\n                     _ => false\n@@ -161,7 +164,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n                                                     ExprId(ref_expr.id),\n                                                     bcx.fcx.param_substs);\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-                Callee { bcx: bcx, data: Intrinsic(def_id.node, substs), ty: expr_ty }\n+                let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n+                Callee { bcx: bcx, data: Intrinsic(node_id, substs), ty: expr_ty }\n             }\n             def::DefFn(did, _) => {\n                 fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n@@ -211,8 +215,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n             }\n             def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n             def::DefTy(..) | def::DefPrimTy(..) | def::DefAssociatedTy(..) |\n-            def::DefUse(..) | def::DefRegion(..) | def::DefLabel(..) |\n-            def::DefTyParam(..) | def::DefSelfTy(..) => {\n+            def::DefUse(..) | def::DefLabel(..) | def::DefTyParam(..) |\n+            def::DefSelfTy(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     &format!(\"cannot translate def {:?} \\\n@@ -403,10 +407,13 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n \n     fn is_named_tuple_constructor(tcx: &ty::ctxt, def_id: DefId) -> bool {\n-        if !def_id.is_local() { return false; }\n+        let node_id = match tcx.map.as_local_node_id(def_id) {\n+            Some(n) => n,\n+            None => { return false; }\n+        };\n         let map_node = session::expect(\n             &tcx.sess,\n-            tcx.map.find(def_id.node),\n+            tcx.map.find(node_id),\n             || \"local item should be in ast map\".to_string());\n \n         match map_node {\n@@ -464,9 +471,9 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n     // Find the actual function pointer.\n     let mut val = {\n-        if def_id.is_local() {\n+        if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n             // Internal reference.\n-            get_item_val(ccx, def_id.node)\n+            get_item_val(ccx, node_id)\n         } else {\n             // External reference.\n             trans_external_path(ccx, def_id, fn_type)"}, {"sha": "d3509c2f8133a259be40e758e01bc6b2ef0f8284", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -36,17 +36,17 @@ use rustc_front::hir;\n \n \n fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        closure_def_id: DefId,\n                                         arg_scope_id: ScopeId,\n                                         freevars: &[ty::Freevar])\n                                         -> Block<'blk, 'tcx>\n {\n     let _icx = push_ctxt(\"closure::load_closure_environment\");\n \n     // Special case for small by-value selfs.\n-    let closure_id = DefId::local(bcx.fcx.id);\n-    let self_type = self_type_for_closure(bcx.ccx(), closure_id,\n-                                                  node_id_type(bcx, closure_id.node));\n-    let kind = kind_for_closure(bcx.ccx(), closure_id);\n+    let closure_ty = node_id_type(bcx, bcx.fcx.id);\n+    let self_type = self_type_for_closure(bcx.ccx(), closure_def_id, closure_ty);\n+    let kind = kind_for_closure(bcx.ccx(), closure_def_id);\n     let llenv = if kind == ty::FnOnceClosureKind &&\n             !arg_is_indirect(bcx.ccx(), self_type) {\n         let datum = rvalue_scratch_datum(bcx,\n@@ -69,8 +69,8 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     for (i, freevar) in freevars.iter().enumerate() {\n-        let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n-                                     closure_expr_id: closure_id.node };\n+        let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n+                                     closure_expr_id: bcx.fcx.id };\n         let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n         let mut upvar_ptr = StructGEP(bcx, llenv, i);\n         let captured_by_ref = match upvar_capture {\n@@ -80,21 +80,21 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 true\n             }\n         };\n-        let def_id = freevar.def.def_id();\n-        bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n+        let node_id = freevar.def.var_id();\n+        bcx.fcx.llupvars.borrow_mut().insert(node_id, upvar_ptr);\n \n         if kind == ty::FnOnceClosureKind && !captured_by_ref {\n             let hint = bcx.fcx.lldropflag_hints.borrow().hint_datum(upvar_id.var_id);\n             bcx.fcx.schedule_drop_mem(arg_scope_id,\n                                       upvar_ptr,\n-                                      node_id_type(bcx, def_id.node),\n+                                      node_id_type(bcx, node_id),\n                                       hint)\n         }\n \n         if let Some(env_pointer_alloca) = env_pointer_alloca {\n             debuginfo::create_captured_var_metadata(\n                 bcx,\n-                def_id.node,\n+                node_id,\n                 env_pointer_alloca,\n                 i,\n                 captured_by_ref,\n@@ -107,7 +107,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub enum ClosureEnv<'a> {\n     NotClosure,\n-    Closure(&'a [ty::Freevar]),\n+    Closure(DefId, &'a [ty::Freevar]),\n }\n \n impl<'a> ClosureEnv<'a> {\n@@ -116,11 +116,11 @@ impl<'a> ClosureEnv<'a> {\n     {\n         match self {\n             ClosureEnv::NotClosure => bcx,\n-            ClosureEnv::Closure(freevars) => {\n+            ClosureEnv::Closure(def_id, freevars) => {\n                 if freevars.is_empty() {\n                     bcx\n                 } else {\n-                    load_closure_environment(bcx, arg_scope, freevars)\n+                    load_closure_environment(bcx, def_id, arg_scope, freevars)\n                 }\n             }\n         }\n@@ -147,9 +147,8 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let symbol = ccx.tcx().map.with_path(closure_id.node, |path| {\n-        mangle_internal_name_by_path_and_seq(path, \"closure\")\n-    });\n+    let path = ccx.tcx().def_path(closure_id);\n+    let symbol = mangle_internal_name_by_path_and_seq(path, \"closure\");\n \n     let function_type = ccx.tcx().mk_closure_from_closure_substs(closure_id, Box::new(substs));\n     let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type);\n@@ -176,9 +175,14 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                                     decl: &hir::FnDecl,\n                                     body: &hir::Block,\n                                     id: ast::NodeId,\n+                                    closure_def_id: DefId, // (*)\n                                     closure_substs: &'tcx ty::ClosureSubsts<'tcx>)\n                                     -> Option<Block<'a, 'tcx>>\n {\n+    // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n+    // defid of the closure in its original crate, whereas `id` will be the id of the local\n+    // inlined copy.\n+\n     let param_substs = closure_substs.func_substs;\n \n     let ccx = match dest {\n@@ -188,10 +192,10 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"closure::trans_closure_expr\");\n \n-    debug!(\"trans_closure_expr()\");\n+    debug!(\"trans_closure_expr(id={:?}, closure_def_id={:?}, closure_substs={:?})\",\n+           id, closure_def_id, closure_substs);\n \n-    let closure_id = DefId::local(id);\n-    let llfn = get_or_create_closure_declaration(ccx, closure_id, closure_substs);\n+    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n@@ -200,7 +204,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // of the closure expression.\n \n     let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n-    let function_type = infcx.closure_type(closure_id, closure_substs);\n+    let function_type = infcx.closure_type(closure_def_id, closure_substs);\n \n     let freevars: Vec<ty::Freevar> =\n         tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n@@ -216,7 +220,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                   &[],\n                   sig.output,\n                   function_type.abi,\n-                  ClosureEnv::Closure(&freevars));\n+                  ClosureEnv::Closure(closure_def_id, &freevars));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and\n@@ -235,7 +239,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(bcx, &*repr, dest_addr, 0, i);\n-        let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n+        let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n                                      closure_expr_id: id };\n         match tcx.upvar_capture(upvar_id).unwrap() {\n             ty::UpvarCapture::ByValue => {"}, {"sha": "d160465c619b95e80f6c2e907b6e33c987d87fe0", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -39,7 +39,6 @@ use trans::type_of;\n use middle::traits;\n use middle::ty::{self, HasTypeFlags, Ty};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n-use rustc::front::map::{PathElem, PathName};\n use rustc_front::hir;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n@@ -167,11 +166,11 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n \n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n-pub fn gensym_name(name: &str) -> PathElem {\n+pub fn gensym_name(name: &str) -> ast::Name {\n     let num = token::gensym(name).0;\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n-    PathName(token::gensym(&format!(\"{}:{}\", name, num)))\n+    token::gensym(&format!(\"{}:{}\", name, num))\n }\n \n /*\n@@ -1020,7 +1019,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                    trait_ref);\n             ccx.sess().span_fatal(\n                 span,\n-                \"reached the recursion limit during monomorphization\");\n+                \"reached the recursion limit during monomorphization (selection ambiguity)\");\n         }\n         Err(e) => {\n             tcx.sess.span_bug(\n@@ -1145,8 +1144,9 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }), ..}) => ty,\n         _ => ctor_ty\n     }.ty_adt_def().unwrap();\n+    let inlined_vid_def_id = ccx.tcx().map.local_def_id(inlined_vid);\n     adt_def.variants.iter().find(|v| {\n-        DefId::local(inlined_vid) == v.did ||\n+        inlined_vid_def_id == v.did ||\n             ccx.external().borrow().get(&v.did) == Some(&Some(inlined_vid))\n     }).unwrap_or_else(|| {\n         ccx.sess().bug(&format!(\"no variant for {:?}::{}\", adt_def, inlined_vid))"}, {"sha": "a7bb4043e7d8187f12b116cdafe37b63275785ec", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -13,6 +13,7 @@ use back::abi;\n use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n+use metadata::cstore::LOCAL_CRATE;\n use middle::{check_const, def};\n use middle::const_eval::{self, ConstVal};\n use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n@@ -25,7 +26,7 @@ use middle::const_eval::{const_int_checked_shl, const_uint_checked_shl};\n use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::const_eval::eval_const_expr_partial;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n@@ -782,7 +783,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprPath(..) => {\n             let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n             match def {\n-                def::DefLocal(id) => {\n+                def::DefLocal(_, id) => {\n                     if let Some(val) = fn_args.and_then(|args| args.get(&id).cloned()) {\n                         val\n                     } else {\n@@ -876,9 +877,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         hir::ExprClosure(_, ref decl, ref body) => {\n             match ety.sty {\n-                ty::TyClosure(_, ref substs) => {\n+                ty::TyClosure(def_id, ref substs) => {\n                     closure::trans_closure_expr(closure::Dest::Ignore(cx), decl,\n-                                                body, e.id, substs);\n+                                                body, e.id, def_id, substs);\n                 }\n                 _ =>\n                     cx.sess().span_bug(\n@@ -959,6 +960,9 @@ fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             did: DefId,\n                             ty: Ty<'tcx>)\n                             -> ValueRef {\n-    if did.is_local() { return base::get_item_val(ccx, did.node) }\n-    base::trans_external_path(ccx, did, ty)\n+    if let Some(node_id) = ccx.tcx().map.as_local_node_id(did) {\n+        base::get_item_val(ccx, node_id)\n+    } else {\n+        base::trans_external_path(ccx, did, ty)\n+    }\n }"}, {"sha": "a921bbbc43e30f48f3673de735c2a1895fce5cd9", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -324,8 +324,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                             output: &mut String) {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n-            let source_def_id = if def_id.is_local() {\n-                match cx.external_srcs().borrow().get(&def_id.node).cloned() {\n+            let source_def_id = if let Some(node_id) = cx.tcx().map.as_local_node_id(def_id) {\n+                match cx.external_srcs().borrow().get(&node_id).cloned() {\n                     Some(source_def_id) => {\n                         // The given def_id identifies the inlined copy of a\n                         // type definition, let's take the source of the copy.\n@@ -346,7 +346,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(&format!(\"{:x}\", def_id.node));\n+            output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n \n             // Maybe check that there is no self type here.\n \n@@ -1887,7 +1887,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n     let variable_type = cx.tcx().node_id_to_type(node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let namespace_node = namespace_for_item(cx, DefId::local(node_id));\n+    let node_def_id = cx.tcx().map.local_def_id(node_id);\n+    let namespace_node = namespace_for_item(cx, node_def_id);\n     let var_name = name.to_string();\n     let linkage_name =\n         namespace_node.mangled_name_of_contained_item(&var_name[..]);"}, {"sha": "a08f33c8899943ede12c914c26b98ecc22eb51d4", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -351,7 +351,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // somehow (storing a path in the hir_map, or construct a path using the\n     // enclosing function).\n     let (linkage_name, containing_scope) = if has_path {\n-        let namespace_node = namespace_for_item(cx, DefId::local(fn_ast_id));\n+        let fn_ast_def_id = cx.tcx().map.local_def_id(fn_ast_id);\n+        let namespace_node = namespace_for_item(cx, fn_ast_def_id);\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n             &function_name[..]);\n         let containing_scope = namespace_node.scope;"}, {"sha": "276f9936ac52ad36ff5e129cf3f84390f14b191c", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -99,12 +99,9 @@ pub fn assert_type_for_node_id(cx: &CrateContext,\n pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n                                    -> (DIScope, Span) {\n     let containing_scope = namespace_for_item(cx, def_id).scope;\n-    let definition_span = if def_id.is_local() {\n-        cx.tcx().map.span(def_id.node)\n-    } else {\n-        // For external items there is no span information\n-        codemap::DUMMY_SP\n-    };\n+    let definition_span = cx.tcx().map.def_id_span(def_id, codemap::DUMMY_SP /* (1) */ );\n+\n+    // (1) For external items there is no span information\n \n     (containing_scope, definition_span)\n }"}, {"sha": "8d57c24ca90bbddc753ea6ec4d6a4cd38dc47552", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -923,13 +923,13 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let const_ty = expr_ty(bcx, ref_expr);\n \n             // For external constants, we don't inline.\n-            let val = if did.is_local() {\n+            let val = if let Some(node_id) = bcx.tcx().map.as_local_node_id(did) {\n                 // Case 1.\n \n                 // The LLVM global has the type of its initializer,\n                 // which may not be equal to the enum's type for\n                 // non-C-like enums.\n-                let val = base::get_item_val(bcx.ccx(), did.node);\n+                let val = base::get_item_val(bcx.ccx(), node_id);\n                 let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n                 PointerCast(bcx, val, pty)\n             } else {\n@@ -1195,14 +1195,23 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 SaveIn(lldest) => closure::Dest::SaveIn(bcx, lldest),\n                 Ignore => closure::Dest::Ignore(bcx.ccx())\n             };\n-            let substs = match expr_ty(bcx, expr).sty {\n-                ty::TyClosure(_, ref substs) => substs,\n+\n+            // NB. To get the id of the closure, we don't use\n+            // `local_def_id(id)`, but rather we extract the closure\n+            // def-id from the expr's type. This is because this may\n+            // be an inlined expression from another crate, and we\n+            // want to get the ORIGINAL closure def-id, since that is\n+            // the key we need to find the closure-kind and\n+            // closure-type etc.\n+            let (def_id, substs) = match expr_ty(bcx, expr).sty {\n+                ty::TyClosure(def_id, ref substs) => (def_id, substs),\n                 ref t =>\n                     bcx.tcx().sess.span_bug(\n                         expr.span,\n                         &format!(\"closure expr without closure type: {:?}\", t)),\n             };\n-            closure::trans_closure_expr(dest, decl, body, expr.id, substs).unwrap_or(bcx)\n+\n+            closure::trans_closure_expr(dest, decl, body, expr.id, def_id, substs).unwrap_or(bcx)\n         }\n         hir::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n@@ -1358,7 +1367,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     match def {\n-        def::DefUpvar(nid, _, _) => {\n+        def::DefUpvar(_, nid, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             let lval = Lvalue::new_with_hint(\"expr::trans_local_var (upvar)\",\n@@ -1372,7 +1381,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        def::DefLocal(nid) => {\n+        def::DefLocal(_, nid) => {\n             let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n                 Some(&v) => v,\n                 None => {"}, {"sha": "6b9f1559d3793c3eb081cd0b0b60c152d9c06052", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -29,9 +29,9 @@ use trans::type_of::*;\n use trans::type_of;\n use middle::ty::{self, Ty};\n use middle::subst::Substs;\n-use rustc::front::map as hir_map;\n \n use std::cmp;\n+use std::iter::once;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n use syntax::abi::{PlatformIntrinsic, RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n@@ -610,10 +610,12 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let t = tcx.node_id_to_type(id);\n         let t = monomorphize::apply_param_substs(tcx, param_substs, &t);\n \n-        let ps = ccx.tcx().map.with_path(id, |path| {\n-            let abi = Some(hir_map::PathName(special_idents::clownshoe_abi.name));\n-            link::mangle(path.chain(abi), hash)\n-        });\n+        let path =\n+            tcx.map.def_path_from_id(id)\n+                   .into_iter()\n+                   .map(|e| e.data.as_interned_str())\n+                   .chain(once(special_idents::clownshoe_abi.name.as_str()));\n+        let ps = link::mangle(path, hash);\n \n         // Compute the type that the function would have if it were just a\n         // normal Rust function. This will be the type of the wrappee fn."}, {"sha": "b8f75df8c11caae241d638dbe2bbd0d24a192bc7", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -30,7 +30,8 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n             // Already inline\n             debug!(\"instantiate_inline({}): already inline as node id {}\",\n                    ccx.tcx().item_path_str(fn_id), node_id);\n-            return Some(DefId::local(node_id));\n+            let node_def_id = ccx.tcx().map.local_def_id(node_id);\n+            return Some(node_def_id);\n         }\n         Some(&None) => {\n             return None; // Not inlinable\n@@ -43,7 +44,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n     let csearch_result =\n         csearch::maybe_get_item_ast(\n             ccx.tcx(), fn_id,\n-            Box::new(|a,b,c,d| astencode::decode_inlined_item(a, b, c, d)));\n+            Box::new(astencode::decode_inlined_item));\n \n     let inline_id = match csearch_result {\n         csearch::FoundAst::NotFound => {\n@@ -144,8 +145,9 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n             // reuse that code, it needs to be able to look up the traits for\n             // inlined items.\n             let ty_trait_item = ccx.tcx().impl_or_trait_item(fn_id).clone();\n+            let trait_item_def_id = ccx.tcx().map.local_def_id(trait_item.id);\n             ccx.tcx().impl_or_trait_items.borrow_mut()\n-                     .insert(DefId::local(trait_item.id), ty_trait_item);\n+                     .insert(trait_item_def_id, ty_trait_item);\n \n             // If this is a default method, we can't look up the\n             // impl type. But we aren't going to translate anyways, so\n@@ -185,12 +187,13 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n         }\n     };\n \n-    Some(DefId::local(inline_id))\n+    let inline_def_id = ccx.tcx().map.local_def_id(inline_id);\n+    Some(inline_def_id)\n }\n \n pub fn get_local_instance(ccx: &CrateContext, fn_id: DefId)\n     -> Option<DefId> {\n-    if fn_id.is_local() {\n+    if let Some(_) = ccx.tcx().map.as_local_node_id(fn_id) {\n         Some(fn_id)\n     } else {\n         instantiate_inline(ccx, fn_id)"}, {"sha": "33f798be85e87101c66663c0f44c7ca79ee5fb66", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -38,7 +38,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n                                 psubsts: &'tcx subst::Substs<'tcx>,\n                                 ref_id: Option<ast::NodeId>)\n-    -> (ValueRef, Ty<'tcx>, bool) {\n+                                -> (ValueRef, Ty<'tcx>, bool) {\n     debug!(\"monomorphic_fn(\\\n             fn_id={:?}, \\\n             real_substs={:?}, \\\n@@ -49,6 +49,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n \n+    // we can only monomorphize things in this crate (or inlined into it)\n+    let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n+\n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n     let hash_id = MonoId {\n@@ -82,7 +85,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let map_node = session::expect(\n         ccx.sess(),\n-        ccx.tcx().map.find(fn_id.node),\n+        ccx.tcx().map.find(fn_node_id),\n         || {\n             format!(\"while monomorphizing {:?}, couldn't find it in \\\n                      the item map (may have attempted to monomorphize \\\n@@ -91,10 +94,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         });\n \n     if let hir_map::NodeForeignItem(_) = map_node {\n-        let abi = ccx.tcx().map.get_foreign_abi(fn_id.node);\n+        let abi = ccx.tcx().map.get_foreign_abi(fn_node_id);\n         if abi != abi::RustIntrinsic && abi != abi::PlatformIntrinsic {\n             // Foreign externs don't have to be monomorphized.\n-            return (get_item_val(ccx, fn_id.node), mono_ty, true);\n+            return (get_item_val(ccx, fn_node_id), mono_ty, true);\n         }\n     }\n \n@@ -107,11 +110,13 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             Some(&d) => d, None => 0\n         };\n \n+        debug!(\"monomorphic_fn: depth for fn_id={:?} is {:?}\", fn_id, depth+1);\n+\n         // Random cut-off -- code that needs to instantiate the same function\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n         if depth > ccx.sess().recursion_limit.get() {\n-            ccx.sess().span_fatal(ccx.tcx().map.span(fn_id.node),\n+            ccx.sess().span_fatal(ccx.tcx().map.span(fn_node_id),\n                 \"reached the recursion limit during monomorphization\");\n         }\n \n@@ -125,9 +130,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         mono_ty.hash(&mut state);\n \n         hash = format!(\"h{}\", state.finish());\n-        ccx.tcx().map.with_path(fn_id.node, |path| {\n-            exported_name(path, &hash[..])\n-        })\n+        let path = ccx.tcx().map.def_path_from_id(fn_node_id);\n+        exported_name(path, &hash[..])\n     };\n \n     debug!(\"monomorphize_fn mangled to {}\", s);\n@@ -136,7 +140,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut hash_id = Some(hash_id);\n     let mut mk_lldecl = |abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[..])\n+            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s)\n         } else {\n             // FIXME(nagisa): perhaps needs a more fine grained selection? See\n             // setup_lldecl below.\n@@ -178,10 +182,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n-                              ccx, &**decl, &**body, &[], d, psubsts, fn_id.node,\n+                              ccx, &**decl, &**body, &[], d, psubsts, fn_node_id,\n                               Some(&hash[..]));\n                       } else {\n-                          trans_fn(ccx, &**decl, &**body, d, psubsts, fn_id.node, &[]);\n+                          trans_fn(ccx, &**decl, &**body, d, psubsts, fn_node_id, &[]);\n                       }\n                   }\n \n@@ -193,11 +197,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         hir_map::NodeVariant(v) => {\n-            let variant = inlined_variant_def(ccx, fn_id.node);\n+            let variant = inlined_variant_def(ccx, fn_node_id);\n             assert_eq!(v.node.name, variant.name);\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n-            trans_enum_variant(ccx, fn_id.node, variant.disr_val, psubsts, d);\n+            trans_enum_variant(ccx, fn_node_id, variant.disr_val, psubsts, d);\n             d\n         }\n         hir_map::NodeImplItem(impl_item) => {"}, {"sha": "dd15c132560392d8e60cf7311fd8653b77e23471", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -52,7 +52,7 @@ use middle::astconv_util::{prim_ty_to_ty, prohibit_type_params, prohibit_project\n use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n@@ -167,12 +167,13 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &hir::Lifetime)\n         }\n \n         Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n-            ty::ReLateBound(debruijn, ty::BrNamed(DefId::local(id), lifetime.name))\n+            ty::ReLateBound(debruijn, ty::BrNamed(tcx.map.local_def_id(id), lifetime.name))\n         }\n \n         Some(&rl::DefEarlyBoundRegion(space, index, id)) => {\n+            let def_id = tcx.map.local_def_id(id);\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                param_id: id,\n+                def_id: def_id,\n                 space: space,\n                 index: index,\n                 name: lifetime.name\n@@ -182,7 +183,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &hir::Lifetime)\n         Some(&rl::DefFreeRegion(scope, id)) => {\n             ty::ReFree(ty::FreeRegion {\n                     scope: tcx.region_maps.item_extent(scope.node_id),\n-                    bound_region: ty::BrNamed(DefId::local(id),\n+                    bound_region: ty::BrNamed(tcx.map.local_def_id(id),\n                                               lifetime.name)\n                 })\n         }\n@@ -1263,7 +1264,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         (_, def::DefSelfTy(Some(trait_did), Some((impl_id, _)))) => {\n             // `Self` in an impl of a trait - we have a concrete self type and a\n             // trait reference.\n-            let trait_ref = tcx.impl_trait_ref(DefId::local(impl_id)).unwrap();\n+            let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(impl_id)).unwrap();\n             let trait_ref = if let Some(free_substs) = this.get_free_substs() {\n                 trait_ref.subst(tcx, free_substs)\n             } else {\n@@ -1290,9 +1291,9 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         (&ty::TyParam(_), def::DefSelfTy(Some(trait_did), None)) => {\n-            assert_eq!(trait_did.krate, LOCAL_CRATE);\n+            let trait_node_id = tcx.map.as_local_node_id(trait_did).unwrap();\n             match find_bound_for_assoc_item(this,\n-                                            trait_did.node,\n+                                            trait_node_id,\n                                             token::special_idents::type_self.name,\n                                             assoc_name,\n                                             span) {\n@@ -1301,9 +1302,9 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         (&ty::TyParam(_), def::DefTyParam(_, _, param_did, param_name)) => {\n-            assert_eq!(param_did.krate, LOCAL_CRATE);\n+            let param_node_id = tcx.map.as_local_node_id(param_did).unwrap();\n             match find_bound_for_assoc_item(this,\n-                                            param_did.node,\n+                                            param_node_id,\n                                             param_name,\n                                             assoc_name,\n                                             span) {\n@@ -1324,15 +1325,15 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let trait_did = bound.0.def_id;\n     let ty = this.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n \n-    let item_did = if trait_did.is_local() {\n+    let item_did = if let Some(trait_id) = tcx.map.as_local_node_id(trait_did) {\n         // `ty::trait_items` used below requires information generated\n         // by type collection, which may be in progress at this point.\n-        match tcx.map.expect_item(trait_did.node).node {\n+        match tcx.map.expect_item(trait_id).node {\n             hir::ItemTrait(_, _, _, ref trait_items) => {\n                 let item = trait_items.iter()\n                                       .find(|i| i.name == assoc_name)\n                                       .expect(\"missing associated type\");\n-                DefId::local(item.id)\n+                tcx.map.local_def_id(item.id)\n             }\n             _ => unreachable!()\n         }\n@@ -1506,11 +1507,12 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             // we don't have the trait information around, which is just sad.\n \n             if !base_segments.is_empty() {\n+                let id_node = tcx.map.as_local_node_id(id).unwrap();\n                 span_err!(tcx.sess,\n                           span,\n                           E0247,\n                           \"found module name used as a type: {}\",\n-                          tcx.map.node_to_string(id.node));\n+                          tcx.map.node_to_user_string(id_node));\n                 return this.tcx().types.err;\n             }\n \n@@ -1520,10 +1522,10 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             prim_ty_to_ty(tcx, base_segments, prim_ty)\n         }\n         _ => {\n-            let node = def.def_id().node;\n+            let id_node = tcx.map.as_local_node_id(def.def_id()).unwrap();\n             span_err!(tcx.sess, span, E0248,\n                       \"found value `{}` used as a type\",\n-                      tcx.map.path_to_string(node));\n+                      tcx.map.path_to_string(id_node));\n             return this.tcx().types.err;\n         }\n     }\n@@ -1638,7 +1640,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n-                    base_def: def::DefMod(DefId::local(ast::CRATE_NODE_ID)),\n+                    base_def: def::DefMod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }"}, {"sha": "8bcff22575563592178e9f678495cc02e1717160", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use middle::def;\n-use middle::def_id::DefId;\n use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n@@ -202,9 +201,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n                 d\n             } else if qself.position == 0 {\n+                // This is just a sentinel for finish_resolving_def_to_ty.\n+                let sentinel = fcx.tcx().map.local_def_id(ast::CRATE_NODE_ID);\n                 def::PathResolution {\n-                    // This is just a sentinel for finish_resolving_def_to_ty.\n-                    base_def: def::DefMod(DefId::local(ast::CRATE_NODE_ID)),\n+                    base_def: def::DefMod(sentinel),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }"}, {"sha": "dcecec7007d52c2254608eaa8fe694f42d1f9c11", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -25,7 +25,8 @@ use super::UnresolvedTypeAction;\n use super::write_call;\n \n use CrateCtxt;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use metadata::cstore::LOCAL_CRATE;\n+use middle::def_id::DefId;\n use middle::infer;\n use middle::ty::{self, LvaluePreference, Ty};\n use syntax::codemap::Span;"}, {"sha": "4f7a6395395461f4d444916b0934d5e5d3f4a42f", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -13,7 +13,6 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv;\n-use middle::def_id::DefId;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n@@ -46,7 +45,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                           decl: &'tcx hir::FnDecl,\n                           body: &'tcx hir::Block,\n                           expected_sig: Option<ty::FnSig<'tcx>>) {\n-    let expr_def_id = DefId::local(expr.id);\n+    let expr_def_id = fcx.tcx().map.local_def_id(expr.id);\n \n     debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n            opt_kind,"}, {"sha": "c46f386af277a7a2886b92d8dddca7338ac8aabb", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -169,8 +169,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_param_env =\n-        ty::ParameterEnvironment::for_item(tcx, impl_m.def_id.node);\n+    let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_m_node_id);\n \n     // Create mapping from impl to skolemized.\n     let impl_to_skol_substs = &impl_param_env.free_substs;\n@@ -428,8 +428,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_param_env =\n-        ty::ParameterEnvironment::for_item(tcx, impl_c.def_id.node);\n+    let impl_c_node_id = tcx.map.as_local_node_id(impl_c.def_id).unwrap();\n+    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_c_node_id);\n \n     // Create mapping from impl to skolemized.\n     let impl_to_skol_substs = &impl_param_env.free_substs;"}, {"sha": "870a81e510ee709eb8ec1f79a0b362f96a3cd2d3", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -10,7 +10,7 @@\n \n use check::regionck::{self, Rcx};\n \n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use middle::infer;\n use middle::region;\n@@ -77,11 +77,12 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     drop_impl_ty: &ty::Ty<'tcx>,\n     self_type_did: DefId) -> Result<(), ()>\n {\n-    assert!(drop_impl_did.is_local() && self_type_did.is_local());\n+    let drop_impl_node_id = tcx.map.as_local_node_id(drop_impl_did).unwrap();\n+    let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n \n-    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_did.node);\n+    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n     let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env), true);\n \n     let named_type = tcx.lookup_item_type(self_type_did).ty;\n@@ -96,7 +97,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                                    named_type, fresh_impl_self_ty) {\n         span_err!(tcx.sess, drop_impl_span, E0366,\n                   \"Implementations of Drop cannot be specialized\");\n-        let item_span = tcx.map.span(self_type_did.node);\n+        let item_span = tcx.map.span(self_type_node_id);\n         tcx.sess.span_note(item_span,\n                            \"Use same sequence of generic type and region \\\n                             parameters that is on the struct/enum definition\");\n@@ -110,7 +111,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     }\n \n     let free_regions = FreeRegionMap::new();\n-    infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_did.node);\n+    infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_node_id);\n     Ok(())\n }\n \n@@ -158,7 +159,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    assert_eq!(self_type_did.krate, LOCAL_CRATE);\n+    let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n \n     let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n \n@@ -195,7 +196,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // repeated `contains` calls.\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n-            let item_span = tcx.map.span(self_type_did.node);\n+            let item_span = tcx.map.span(self_type_node_id);\n             span_err!(tcx.sess, drop_impl_span, E0367,\n                       \"The requirement `{}` is added only by the Drop impl.\", predicate);\n             tcx.sess.span_note(item_span,"}, {"sha": "4afc610f63ea553e4dc803006467815e7f740e4d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -13,7 +13,6 @@\n \n use astconv::AstConv;\n use intrinsics;\n-use middle::def_id::DefId;\n use middle::subst;\n use middle::ty::FnSig;\n use middle::ty::{self, Ty};\n@@ -43,7 +42,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: &ty::ctxt<'tcx>, it: &hir::ForeignItem,\n             variadic: false,\n         }),\n     }));\n-    let i_ty = tcx.lookup_item_type(DefId::local(it.id));\n+    let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     if i_n_tps != n_tps {\n         span_err!(tcx.sess, it.span, E0094,\n@@ -365,7 +364,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     };\n \n     let tcx = ccx.tcx;\n-    let i_ty = tcx.lookup_item_type(DefId::local(it.id));\n+    let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n     let name = it.name.as_str();\n "}, {"sha": "e10175c81aa1ff93e0ce6c99caeba1af31d925f4", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -15,6 +15,7 @@ use CrateCtxt;\n \n use astconv::AstConv;\n use check::{self, FnCtxt};\n+use front::map as hir_map;\n use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate, HasTypeFlags};\n use middle::def;\n use middle::def_id::DefId;\n@@ -364,13 +365,11 @@ impl PartialOrd for TraitInfo {\n }\n impl Ord for TraitInfo {\n     fn cmp(&self, other: &TraitInfo) -> Ordering {\n-        // accessible traits are more important/relevant than\n-        // inaccessible ones, local crates are more important than\n-        // remote ones (local: cnum == 0), and NodeIds just for\n-        // totality.\n+        // local crates are more important than remote ones (local:\n+        // cnum == 0), and otherwise we throw in the defid for totality\n \n-        let lhs = (other.def_id.krate, other.def_id.node);\n-        let rhs = (self.def_id.krate, self.def_id.node);\n+        let lhs = (other.def_id.krate, other.def_id);\n+        let rhs = (self.def_id.krate, self.def_id);\n         lhs.cmp(&rhs)\n     }\n }\n@@ -385,21 +384,24 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         // Crate-local:\n         //\n         // meh.\n-        struct Visitor<'a> {\n+        struct Visitor<'a, 'tcx:'a> {\n+            map: &'a hir_map::Map<'tcx>,\n             traits: &'a mut AllTraitsVec,\n         }\n-        impl<'v, 'a> visit::Visitor<'v> for Visitor<'a> {\n+        impl<'v, 'a, 'tcx> visit::Visitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n                 match i.node {\n                     hir::ItemTrait(..) => {\n-                        self.traits.push(TraitInfo::new(DefId::local(i.id)));\n+                        let def_id = self.map.local_def_id(i.id);\n+                        self.traits.push(TraitInfo::new(def_id));\n                     }\n                     _ => {}\n                 }\n                 visit::walk_item(self, i)\n             }\n         }\n         visit::walk_crate(&mut Visitor {\n+            map: &ccx.tcx.map,\n             traits: &mut traits\n         }, ccx.tcx.map.krate());\n "}, {"sha": "08a0f1c7e871d032551de4d4718c5eda6a5fd525", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -83,9 +83,10 @@ use self::TupleArgumentsFlag::*;\n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n+use metadata::cstore::LOCAL_CRATE;\n use middle::astconv_util::prohibit_type_params;\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::infer;\n use middle::infer::type_variable;\n use middle::pat_util::{self, pat_id_map};\n@@ -687,15 +688,15 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n \n     check_representable(tcx, span, id, \"struct\");\n \n-    if tcx.lookup_simd(DefId::local(id)) {\n+    if tcx.lookup_simd(ccx.tcx.map.local_def_id(id)) {\n         check_simd(tcx, span, id);\n     }\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     debug!(\"check_item_type(it.id={}, it.name={})\",\n            it.id,\n-           ccx.tcx.item_path_str(DefId::local(it.id)));\n+           ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n@@ -710,7 +711,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n-          match ccx.tcx.impl_trait_ref(DefId::local(it.id)) {\n+          match ccx.tcx.impl_trait_ref(ccx.tcx.map.local_def_id(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n@@ -741,7 +742,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n             }\n         } else {\n             for item in &m.items {\n-                let pty = ccx.tcx.lookup_item_type(DefId::local(item.id));\n+                let pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(item.id));\n                 if !pty.generics.types.is_empty() {\n                     span_err!(ccx.tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n@@ -763,18 +764,18 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     debug!(\"check_item_body(it.id={}, it.name={})\",\n            it.id,\n-           ccx.tcx.item_path_str(DefId::local(it.id)));\n+           ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       hir::ItemFn(ref decl, _, _, _, _, ref body) => {\n-        let fn_pty = ccx.tcx.lookup_item_type(DefId::local(it.id));\n+        let fn_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n         check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n-        let impl_pty = ccx.tcx.lookup_item_type(DefId::local(it.id));\n+        let impl_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n \n         for impl_item in impl_items {\n             match impl_item.node {\n@@ -792,7 +793,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         }\n       }\n       hir::ItemTrait(_, _, _, ref trait_items) => {\n-        let trait_def = ccx.tcx.lookup_trait_def(DefId::local(it.id));\n+        let trait_def = ccx.tcx.lookup_trait_def(ccx.tcx.map.local_def_id(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n                 hir::ConstTraitItem(_, Some(ref expr)) => {\n@@ -911,7 +912,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        let ty_impl_item = ccx.tcx.impl_or_trait_item(DefId::local(impl_item.id));\n+        let ty_impl_item = ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(impl_item.id));\n         let ty_trait_item = trait_items.iter()\n             .find(|ac| ac.name() == ty_impl_item.name())\n             .unwrap_or_else(|| {\n@@ -1953,7 +1954,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .unwrap_or(type_variable::Default {\n                                 ty: self.infcx().next_ty_var(),\n                                 origin_span: codemap::DUMMY_SP,\n-                                def_id: DefId::local(0) // what do I put here?\n+                                def_id: self.tcx().map.local_def_id(0) // what do I put here?\n                             });\n \n                     // This is to ensure that we elimnate any non-determinism from the error\n@@ -3356,7 +3357,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n-                    base_def: def::DefMod(DefId::local(ast::CRATE_NODE_ID)),\n+                    base_def: def::DefMod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n@@ -4108,7 +4109,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let inh = static_inherited_fields(ccx, &tables);\n     let rty = ccx.tcx.node_id_to_type(id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-    let declty = fcx.ccx.tcx.lookup_item_type(DefId::local(id)).ty;\n+    let declty = fcx.ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n@@ -4124,8 +4125,13 @@ fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     check_expr_with_hint(fcx, e, declty);\n     demand::coerce(fcx, e.span, declty, e);\n-    fcx.select_all_obligations_or_error();\n+\n+    fcx.select_all_obligations_and_apply_defaults();\n+    upvar::closure_analyze_const(&fcx, e);\n+    fcx.select_obligations_where_possible();\n     fcx.check_casts();\n+    fcx.select_all_obligations_or_error();\n+\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n }\n@@ -4236,7 +4242,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             }\n         }\n \n-        let def_id = DefId::local(id);\n+        let def_id = ccx.tcx.map.local_def_id(id);\n \n         let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n         for (v, variant) in vs.iter().zip(variants.iter()) {\n@@ -4247,7 +4253,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 Some(i) => {\n                     span_err!(ccx.tcx.sess, v.span, E0081,\n                         \"discriminant value `{}` already exists\", disr_vals[i]);\n-                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variants[i].did.node),\n+                    let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n+                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variant_i_node_id),\n                         \"conflicting discriminant here\")\n                 }\n                 None => {}\n@@ -4274,8 +4281,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    let hint = *ccx.tcx.lookup_repr_hints(DefId { krate: LOCAL_CRATE, node: id })\n-        .get(0).unwrap_or(&attr::ReprAny);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    let hint = *ccx.tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {\n@@ -4298,7 +4305,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 defn: def::Def)\n                                                 -> (TypeScheme<'tcx>, GenericPredicates<'tcx>) {\n     match defn {\n-        def::DefLocal(nid) | def::DefUpvar(nid, _, _) => {\n+        def::DefLocal(_, nid) | def::DefUpvar(_, nid, _, _) => {\n             let typ = fcx.local_ty(sp, nid);\n             (ty::TypeScheme { generics: ty::Generics::empty(), ty: typ },\n              ty::GenericPredicates::empty())\n@@ -4316,7 +4323,6 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefMod(..) |\n         def::DefForeignMod(..) |\n         def::DefUse(..) |\n-        def::DefRegion(..) |\n         def::DefLabel(..) |\n         def::DefSelfTy(..) => {\n             fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n@@ -4487,7 +4493,6 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefForeignMod(..) |\n         def::DefLocal(..) |\n         def::DefUse(..) |\n-        def::DefRegion(..) |\n         def::DefLabel(..) |\n         def::DefUpvar(..) => {\n             segment_spaces = vec![None; segments.len()];"}, {"sha": "78d493c8a711cb9ca2acb474f66fe800adde4e46", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -43,7 +43,6 @@\n use super::FnCtxt;\n \n use check::demand;\n-use middle::def_id::DefId;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty::{self, Ty};\n@@ -73,6 +72,20 @@ pub fn closure_analyze_fn(fcx: &FnCtxt,\n     assert!(fcx.inh.deferred_call_resolutions.borrow().is_empty());\n }\n \n+pub fn closure_analyze_const(fcx: &FnCtxt,\n+                             body: &hir::Expr)\n+{\n+    let mut seed = SeedBorrowKind::new(fcx);\n+    seed.visit_expr(body);\n+    let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n+\n+    let mut adjust = AdjustBorrowKind::new(fcx, &closures_with_inferred_kinds);\n+    adjust.visit_expr(body);\n+\n+    // it's our job to process these.\n+    assert!(fcx.inh.deferred_call_resolutions.borrow().is_empty());\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // SEED BORROW KIND\n \n@@ -116,7 +129,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                      capture_clause: hir::CaptureClause,\n                      _body: &hir::Block)\n     {\n-        let closure_def_id = DefId::local(expr.id);\n+        let closure_def_id = self.tcx().map.local_def_id(expr.id);\n         if !self.fcx.inh.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n             self.closures_with_inferred_kinds.insert(expr.id);\n             self.fcx.inh.tables.borrow_mut().closure_kinds\n@@ -127,7 +140,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n \n         self.tcx().with_freevars(expr.id, |freevars| {\n             for freevar in freevars {\n-                let var_node_id = freevar.def.local_node_id();\n+                let var_node_id = freevar.def.var_id();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                              closure_expr_id: expr.id };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n@@ -215,7 +228,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n         // Now we must process and remove any deferred resolutions,\n         // since we have a concrete closure kind.\n-        let closure_def_id = DefId::local(id);\n+        let closure_def_id = self.fcx.tcx().map.local_def_id(id);\n         if self.closures_with_inferred_kinds.contains(&id) {\n             let mut deferred_call_resolutions =\n                 self.fcx.remove_deferred_call_resolutions(closure_def_id);\n@@ -236,16 +249,16 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter()\n                     .map(|freevar| {\n-                        let freevar_def_id = freevar.def.def_id();\n-                        let freevar_ty = self.fcx.node_ty(freevar_def_id.node);\n+                        let freevar_node_id = freevar.def.var_id();\n+                        let freevar_ty = self.fcx.node_ty(freevar_node_id);\n                         let upvar_id = ty::UpvarId {\n-                            var_id: freevar_def_id.node,\n+                            var_id: freevar_node_id,\n                             closure_expr_id: closure_id\n                         };\n                         let capture = self.fcx.infcx().upvar_capture(upvar_id).unwrap();\n \n-                        debug!(\"freevar_def_id={:?} freevar_ty={:?} capture={:?}\",\n-                               freevar_def_id, freevar_ty, capture);\n+                        debug!(\"freevar_node_id={:?} freevar_ty={:?} capture={:?}\",\n+                               freevar_node_id, freevar_ty, capture);\n \n                         match capture {\n                             ty::UpvarCapture::ByValue => freevar_ty,\n@@ -469,7 +482,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n             return;\n         }\n \n-        let closure_def_id = DefId::local(closure_id);\n+        let closure_def_id = self.fcx.tcx().map.local_def_id(closure_id);\n         let closure_kinds = &mut self.fcx.inh.tables.borrow_mut().closure_kinds;\n         let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n "}, {"sha": "b5cf069bda6847dcade038ccfc1f6a1e83c8f764", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -12,7 +12,6 @@ use astconv::AstConv;\n use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck, wfcheck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n-use middle::def_id::DefId;\n use middle::region;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n@@ -57,7 +56,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n                item.id,\n-               ccx.tcx.item_path_str(DefId::local(item.id)));\n+               ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -81,7 +80,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 self.check_impl(item);\n             }\n             hir::ItemImpl(_, hir::ImplPolarity::Negative, _, Some(_), _, _) => {\n-                let trait_ref = ccx.tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n+                let item_def_id = ccx.tcx.map.local_def_id(item.id);\n+                let trait_ref = ccx.tcx.impl_trait_ref(item_def_id).unwrap();\n                 ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n@@ -117,9 +117,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n             hir::ItemTrait(_, _, _, ref items) => {\n                 let trait_predicates =\n-                    ccx.tcx.lookup_predicates(DefId::local(item.id));\n+                    ccx.tcx.lookup_predicates(ccx.tcx.map.local_def_id(item.id));\n                 reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n-                if ccx.tcx.trait_has_default_impl(DefId::local(item.id)) {\n+                if ccx.tcx.trait_has_default_impl(ccx.tcx.map.local_def_id(item.id)) {\n                     if !items.is_empty() {\n                         wfcheck::error_380(ccx, item.span);\n                     }\n@@ -133,7 +133,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         F: for<'fcx> FnMut(&mut CheckTypeWellFormedVisitor<'ccx, 'tcx>, &FnCtxt<'fcx, 'tcx>),\n     {\n         let ccx = self.ccx;\n-        let item_def_id = DefId::local(item.id);\n+        let item_def_id = ccx.tcx.map.local_def_id(item.id);\n         let type_scheme = ccx.tcx.lookup_item_type(item_def_id);\n         let type_predicates = ccx.tcx.lookup_predicates(item_def_id);\n         reject_non_type_param_bounds(ccx.tcx, item.span, &type_predicates);\n@@ -194,7 +194,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         Some(&mut this.cache));\n             debug!(\"check_item_type at bounds_checker.scope: {:?}\", bounds_checker.scope);\n \n-            let type_scheme = fcx.tcx().lookup_item_type(DefId::local(item.id));\n+            let item_def_id = fcx.tcx().map.local_def_id(item.id);\n+            let type_scheme = fcx.tcx().lookup_item_type(item_def_id);\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh\n                                                           .infcx\n@@ -230,7 +231,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Similarly, obtain an \"inside\" reference to the trait\n             // that the impl implements.\n-            let trait_ref = match fcx.tcx().impl_trait_ref(DefId::local(item.id)) {\n+            let trait_ref = match fcx.tcx().impl_trait_ref(fcx.tcx().map.local_def_id(item.id)) {\n                 None => { return; }\n                 Some(t) => { t }\n             };\n@@ -279,7 +280,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let item_def_id = DefId::local(item.id);\n+        let item_def_id = self.tcx().map.local_def_id(item.id);\n         let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n         let variances = self.tcx().item_variances(item_def_id);\n \n@@ -431,7 +432,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match fk {\n             FnKind::Closure | FnKind::ItemFn(..) => {}\n             FnKind::Method(..) => {\n-                match self.tcx().impl_or_trait_item(DefId::local(id)) {\n+                match self.tcx().impl_or_trait_item(self.tcx().map.local_def_id(id)) {\n                     ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                         reject_shadowing_type_parameters(self.tcx(), span, &ty_method.generics)\n                     }\n@@ -444,7 +445,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n         if let hir::MethodTraitItem(_, None) = trait_item.node {\n-            match self.tcx().impl_or_trait_item(DefId::local(trait_item.id)) {\n+            match self.tcx().impl_or_trait_item(self.tcx().map.local_def_id(trait_item.id)) {\n                 ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n                     reject_non_type_param_bounds(\n                         self.tcx(),"}, {"sha": "b8d942ad22703ddf23dbb3792ceae67c3d0c6091", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -63,7 +63,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n                item.id,\n-               ccx.tcx.item_path_str(DefId::local(item.id)));\n+               ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -90,7 +90,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             hir::ItemImpl(_, hir::ImplPolarity::Negative, _, Some(_), _, _) => {\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n \n-                let trait_ref = ccx.tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n+                let trait_ref = ccx.tcx.impl_trait_ref(ccx.tcx.map.local_def_id(item.id)).unwrap();\n                 ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n@@ -137,7 +137,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n             let free_id = fcx.inh.infcx.parameter_environment.free_id;\n \n-            let item = fcx.tcx().impl_or_trait_item(DefId::local(item_id));\n+            let item = fcx.tcx().impl_or_trait_item(fcx.tcx().map.local_def_id(item_id));\n \n             let mut implied_bounds = match item.container() {\n                 ty::TraitContainer(_) => vec![],\n@@ -216,7 +216,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n \n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let predicates = fcx.tcx().lookup_predicates(DefId::local(item.id));\n+            let predicates = fcx.tcx().lookup_predicates(fcx.tcx().map.local_def_id(item.id));\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n@@ -228,7 +228,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                    item: &hir::Item,\n                    items: &[P<hir::TraitItem>])\n     {\n-        let trait_def_id = DefId::local(item.id);\n+        let trait_def_id = self.tcx().map.local_def_id(item.id);\n \n         if self.ccx.tcx.trait_has_default_impl(trait_def_id) {\n             if !items.is_empty() {\n@@ -251,7 +251,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         self.with_item_fcx(item, |fcx, this| {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let type_scheme = fcx.tcx().lookup_item_type(DefId::local(item.id));\n+            let type_scheme = fcx.tcx().lookup_item_type(fcx.tcx().map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyBareFn(_, ref bare_fn_ty) => bare_fn_ty,\n@@ -260,7 +260,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             };\n \n-            let predicates = fcx.tcx().lookup_predicates(DefId::local(item.id));\n+            let predicates = fcx.tcx().lookup_predicates(fcx.tcx().map.local_def_id(item.id));\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n \n             let mut implied_bounds = vec![];\n@@ -276,7 +276,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         debug!(\"check_item_type: {:?}\", item);\n \n         self.with_item_fcx(item, |fcx, this| {\n-            let type_scheme = fcx.tcx().lookup_item_type(DefId::local(item.id));\n+            let type_scheme = fcx.tcx().lookup_item_type(fcx.tcx().map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.inh\n                                                           .infcx\n@@ -299,7 +299,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n         self.with_item_fcx(item, |fcx, this| {\n             let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let item_def_id = DefId::local(item.id);\n+            let item_def_id = fcx.tcx().map.local_def_id(item.id);\n \n             match *ast_trait_ref {\n                 Some(ref ast_trait_ref) => {\n@@ -328,7 +328,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n-            impl_implied_bounds(fcx, DefId::local(item.id), item.span)\n+            impl_implied_bounds(fcx, fcx.tcx().map.local_def_id(item.id), item.span)\n         });\n     }\n \n@@ -386,7 +386,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let item_def_id = DefId::local(item.id);\n+        let item_def_id = self.tcx().map.local_def_id(item.id);\n         let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n         let variances = self.tcx().item_variances(item_def_id);\n "}, {"sha": "16884e76a8ec72279169d32edb71323b969905d7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -388,8 +388,8 @@ impl ResolveReason {\n                 tcx.expr_span(upvar_id.closure_expr_id)\n             }\n             ResolvingClosure(did) => {\n-                if did.is_local() {\n-                    tcx.expr_span(did.node)\n+                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n+                    tcx.expr_span(node_id)\n                 } else {\n                     DUMMY_SP\n                 }"}, {"sha": "b3ec10a8941dc753e69b3f72344cecfbdb2ba5bd", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -16,7 +16,7 @@\n // mappings. That mapping code resides here.\n \n \n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n use middle::traits;\n@@ -138,7 +138,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n     fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n-        let impl_did = DefId::local(item.id);\n+        let impl_did = tcx.map.local_def_id(item.id);\n         let self_type = tcx.lookup_item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n@@ -194,15 +194,16 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         match item.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 impl_items.iter().map(|impl_item| {\n+                    let impl_def_id = self.crate_context.tcx.map.local_def_id(impl_item.id);\n                     match impl_item.node {\n                         hir::ConstImplItem(..) => {\n-                            ConstTraitItemId(DefId::local(impl_item.id))\n+                            ConstTraitItemId(impl_def_id)\n                         }\n                         hir::MethodImplItem(..) => {\n-                            MethodTraitItemId(DefId::local(impl_item.id))\n+                            MethodTraitItemId(impl_def_id)\n                         }\n                         hir::TypeImplItem(_) => {\n-                            TypeTraitItemId(DefId::local(impl_item.id))\n+                            TypeTraitItemId(impl_def_id)\n                         }\n                     }\n                 }).collect()\n@@ -245,17 +246,15 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 }\n                 _ => {\n                     // Destructors only work on nominal types.\n-                    if impl_did.is_local() {\n-                        {\n-                            match tcx.map.find(impl_did.node) {\n-                                Some(hir_map::NodeItem(item)) => {\n-                                    span_err!(tcx.sess, item.span, E0120,\n-                                        \"the Drop trait may only be implemented on structures\");\n-                                }\n-                                _ => {\n-                                    tcx.sess.bug(\"didn't find impl in ast \\\n-                                                  map\");\n-                                }\n+                    if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n+                        match tcx.map.find(impl_node_id) {\n+                            Some(hir_map::NodeItem(item)) => {\n+                                span_err!(tcx.sess, item.span, E0120,\n+                                          \"the Drop trait may only be implemented on structures\");\n+                            }\n+                            _ => {\n+                                tcx.sess.bug(\"didn't find impl in ast \\\n+                                              map\");\n                             }\n                         }\n                     } else {\n@@ -281,18 +280,20 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_copy: impl_did={:?}\",\n                    impl_did);\n \n-            if impl_did.krate != LOCAL_CRATE {\n+            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+                n\n+            } else {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n                 return\n-            }\n+            };\n \n             let self_type = tcx.lookup_item_type(impl_did);\n             debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n                    self_type);\n \n-            let span = tcx.map.span(impl_did.node);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n+            let span = tcx.map.span(impl_node_id);\n+            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n             let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n             assert!(!self_type.has_escaping_regions());\n \n@@ -350,20 +351,22 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n                    impl_did);\n \n-            if impl_did.krate != LOCAL_CRATE {\n+            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+                n\n+            } else {\n                 debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n                         in this crate\");\n                 return;\n-            }\n+            };\n \n             let source = tcx.lookup_item_type(impl_did).ty;\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n                    source, target);\n \n-            let span = tcx.map.span(impl_did.node);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n+            let span = tcx.map.span(impl_node_id);\n+            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n             let source = source.subst(tcx, &param_env.free_substs);\n             let target = target.subst(tcx, &param_env.free_substs);\n             assert!(!source.has_escaping_regions());\n@@ -463,7 +466,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n \n             // Register an obligation for `A: Trait<B>`.\n-            let cause = traits::ObligationCause::misc(span, impl_did.node);\n+            let cause = traits::ObligationCause::misc(span, impl_node_id);\n             let predicate = traits::predicate_for_trait_def(tcx, cause, trait_def_id,\n                                                             0, source, vec![target]);\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n@@ -477,7 +480,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let mut free_regions = FreeRegionMap::new();\n             free_regions.relate_free_regions_from_predicates(tcx, &infcx.parameter_environment\n                                                                         .caller_bounds);\n-            infcx.resolve_regions_and_report_errors(&free_regions, impl_did.node);\n+            infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n             if let Some(kind) = kind {\n                 tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);"}, {"sha": "f796f7fe9f9bd0d191d0ac8eefd811d9c146b936", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -11,7 +11,8 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use metadata::cstore::LOCAL_CRATE;\n+use middle::def_id::DefId;\n use middle::traits;\n use middle::ty;\n use syntax::ast;\n@@ -63,7 +64,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n     fn check_item(&self, item: &hir::Item) {\n-        let def_id = DefId::local(item.id);\n+        let def_id = self.tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemImpl(_, _, _, None, _, _) => {\n                 // For inherent impls, self type must be a nominal type"}, {"sha": "706f28f9fe4b03af30b7f358de1fec029007e17a", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -11,7 +11,8 @@\n //! Overlap: No two impls for the same trait are implemented for the\n //! same type.\n \n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use metadata::cstore::LOCAL_CRATE;\n+use middle::def_id::DefId;\n use middle::traits;\n use middle::ty;\n use middle::infer::{self, new_infer_ctxt};\n@@ -111,7 +112,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             }\n         } else if impl2_def_id.krate != LOCAL_CRATE {\n             Some((impl1_def_id, impl2_def_id))\n-        } else if impl1_def_id.node < impl2_def_id.node {\n+        } else if impl1_def_id < impl2_def_id {\n             Some((impl1_def_id, impl2_def_id))\n         } else {\n             Some((impl2_def_id, impl1_def_id))\n@@ -164,8 +165,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     }\n \n     fn span_of_impl(&self, impl_did: DefId) -> Span {\n-        assert_eq!(impl_did.krate, LOCAL_CRATE);\n-        self.tcx.map.span(impl_did.node)\n+        let node_id = self.tcx.map.as_local_node_id(impl_did).unwrap();\n+        self.tcx.map.span(node_id)\n     }\n }\n \n@@ -177,20 +178,20 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n-                let impl_def_id = DefId::local(item.id);\n+                let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 match prev_default_impl {\n                     Some(prev_id) => {\n                         self.report_overlap_error(trait_ref.def_id,\n                                                   impl_def_id,\n-                                                  DefId::local(prev_id));\n+                                                  self.tcx.map.local_def_id(prev_id));\n                     }\n                     None => { }\n                 }\n             }\n             hir::ItemImpl(_, _, _, Some(_), ref self_ty, _) => {\n-                let impl_def_id = DefId::local(item.id);\n+                let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match trait_ref.self_ty().sty {"}, {"sha": "f7b10b9001340097e9faa11ed7120bb709a0d492", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -11,7 +11,6 @@\n //! Unsafety checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n-use middle::def_id::DefId;\n use middle::ty;\n use rustc_front::visit;\n use rustc_front::hir;\n@@ -30,7 +29,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     fn check_unsafety_coherence(&mut self, item: &'v hir::Item,\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity) {\n-        match self.tcx.impl_trait_ref(DefId::local(item.id)) {\n+        match self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id)) {\n             None => {\n                 // Inherent impl.\n                 match unsafety {"}, {"sha": "da272b52ebccc95dfc473d9bc30ab2aa2b2811e0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 121, "deletions": 102, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -66,7 +66,7 @@ There are some shortcomings in this design:\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use middle::def;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::free_region::FreeRegionMap;\n@@ -198,7 +198,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     }\n \n     fn method_ty(&self, method_id: ast::NodeId) -> Rc<ty::Method<'tcx>> {\n-        let def_id = DefId::local(method_id);\n+        let def_id = self.tcx.map.local_def_id(method_id);\n         match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n             ty::MethodTraitItem(ref mty) => mty.clone(),\n             _ => {\n@@ -316,16 +316,16 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     {\n         let tcx = self.tcx;\n \n-        if trait_id.krate != LOCAL_CRATE {\n-            return tcx.lookup_trait_def(trait_id)\n-        }\n-\n-        let item = match tcx.map.get(trait_id.node) {\n-            hir_map::NodeItem(item) => item,\n-            _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n-        };\n+        if let Some(trait_id) = tcx.map.as_local_node_id(trait_id) {\n+            let item = match tcx.map.get(trait_id) {\n+                hir_map::NodeItem(item) => item,\n+                _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n+            };\n \n-        trait_def_of_item(self, &*item)\n+            trait_def_of_item(self, &*item)\n+        } else {\n+            tcx.lookup_trait_def(trait_id)\n+        }\n     }\n \n     /// Ensure that the (transitive) super predicates for\n@@ -402,8 +402,8 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n                                            assoc_name: ast::Name)\n                                            -> bool\n     {\n-        if trait_def_id.is_local() {\n-            trait_defines_associated_type_named(self.ccx, trait_def_id.node, assoc_name)\n+        if let Some(trait_id) = self.tcx().map.as_local_node_id(trait_def_id) {\n+            trait_defines_associated_type_named(self.ccx, trait_id, assoc_name)\n         } else {\n             let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n             trait_def.associated_type_names.contains(&assoc_name)\n@@ -558,10 +558,10 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();\n         match path_res.base_def {\n             def::DefSelfTy(Some(def_id), None) => {\n-                path_res.depth == 0 && def_id.node == param_id\n+                path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n             }\n             def::DefTyParam(_, _, def_id, _) => {\n-                path_res.depth == 0 && def_id == DefId::local(param_id)\n+                path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n             }\n             _ => {\n                 false\n@@ -591,7 +591,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                               sig, untransformed_rcvr_ty);\n \n-    let def_id = DefId::local(id);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n     let ty_method = ty::Method::new(name,\n                                     ty_generics,\n                                     ty_generic_predicates,\n@@ -631,12 +631,12 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n     /* add the field to the tcache */\n-    ccx.tcx.register_item_type(DefId::local(v.node.id),\n+    ccx.tcx.register_item_type(ccx.tcx.map.local_def_id(v.node.id),\n                                ty::TypeScheme {\n                                    generics: struct_generics.clone(),\n                                    ty: tt\n                                });\n-    ccx.tcx.predicates.borrow_mut().insert(DefId::local(v.node.id),\n+    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(v.node.id),\n                                            struct_predicates.clone());\n }\n \n@@ -648,21 +648,21 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       ty: ty::Ty<'tcx>,\n                                       has_value: bool)\n {\n-    ccx.tcx.predicates.borrow_mut().insert(DefId::local(id),\n+    ccx.tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(id),\n                                            ty::GenericPredicates::empty());\n \n     write_ty_to_tcx(ccx.tcx, id, ty);\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n         name: name,\n         vis: vis,\n-        def_id: DefId::local(id),\n+        def_id: ccx.tcx.map.local_def_id(id),\n         container: container,\n         ty: ty,\n         has_value: has_value\n     });\n     ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(DefId::local(id), ty::ConstTraitItem(associated_const));\n+       .insert(ccx.tcx.map.local_def_id(id), ty::ConstTraitItem(associated_const));\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -676,11 +676,11 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         name: name,\n         vis: vis,\n         ty: ty,\n-        def_id: DefId::local(id),\n+        def_id: ccx.tcx.map.local_def_id(id),\n         container: container\n     });\n     ccx.tcx.impl_or_trait_items.borrow_mut()\n-       .insert(DefId::local(id), ty::TypeTraitItem(associated_type));\n+       .insert(ccx.tcx.map.local_def_id(id), ty::TypeTraitItem(associated_type));\n }\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -751,7 +751,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n             convert_enum_variant_types(ccx,\n-                                       tcx.lookup_adt_def_master(DefId::local(it.id)),\n+                                       tcx.lookup_adt_def_master(ccx.tcx.map.local_def_id(it.id)),\n                                        scheme,\n                                        predicates,\n                                        &enum_definition.variants);\n@@ -765,7 +765,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n-            tcx.impl_trait_refs.borrow_mut().insert(DefId::local(it.id), Some(trait_ref));\n+            tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+                                                    Some(trait_ref));\n         }\n         hir::ItemImpl(_, _,\n                       ref generics,\n@@ -782,21 +783,21 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            tcx.register_item_type(DefId::local(it.id),\n+            tcx.register_item_type(ccx.tcx.map.local_def_id(it.id),\n                                    TypeScheme { generics: ty_generics.clone(),\n                                                 ty: selfty });\n-            tcx.predicates.borrow_mut().insert(DefId::local(it.id),\n+            tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n                                                ty_predicates.clone());\n             if let &Some(ref ast_trait_ref) = opt_trait_ref {\n                 tcx.impl_trait_refs.borrow_mut().insert(\n-                    DefId::local(it.id),\n+                    ccx.tcx.map.local_def_id(it.id),\n                     Some(astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n                                                              &ExplicitRscope,\n                                                              ast_trait_ref,\n                                                              Some(selfty)))\n                         );\n             } else {\n-                tcx.impl_trait_refs.borrow_mut().insert(DefId::local(it.id), None);\n+                tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id), None);\n             }\n \n \n@@ -838,12 +839,12 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 if let hir::ConstImplItem(ref ty, _) = impl_item.node {\n                     let ty = ccx.icx(&ty_predicates)\n                                 .to_ty(&ExplicitRscope, &*ty);\n-                    tcx.register_item_type(DefId::local(impl_item.id),\n+                    tcx.register_item_type(ccx.tcx.map.local_def_id(impl_item.id),\n                                            TypeScheme {\n                                                generics: ty_generics.clone(),\n                                                ty: ty,\n                                            });\n-                    convert_associated_const(ccx, ImplContainer(DefId::local(it.id)),\n+                    convert_associated_const(ccx, ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n                                              impl_item.name, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n                                              ty, true /* has_value */);\n@@ -860,7 +861,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n-                    convert_associated_type(ccx, ImplContainer(DefId::local(it.id)),\n+                    convert_associated_type(ccx, ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n                                             impl_item.name, impl_item.id, impl_item.vis,\n                                             Some(typ));\n                 }\n@@ -879,7 +880,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n             });\n             convert_methods(ccx,\n-                            ImplContainer(DefId::local(it.id)),\n+                            ImplContainer(ccx.tcx.map.local_def_id(it.id)),\n                             methods,\n                             selfty,\n                             &ty_generics,\n@@ -899,15 +900,15 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             enforce_impl_params_are_constrained(tcx,\n                                                 generics,\n-                                                DefId::local(it.id),\n+                                                ccx.tcx.map.local_def_id(it.id),\n                                                 impl_items);\n         },\n         hir::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n-                ccx.ensure_super_predicates(it.span, DefId::local(it.id));\n+                ccx.ensure_super_predicates(it.span, ccx.tcx.map.local_def_id(it.id));\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = tcx.lookup_predicates(DefId::local(it.id));\n+            let trait_predicates = tcx.lookup_predicates(ccx.tcx.map.local_def_id(it.id));\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n@@ -917,14 +918,18 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     hir::ConstTraitItem(ref ty, ref default) => {\n                         let ty = ccx.icx(&trait_predicates)\n                                     .to_ty(&ExplicitRscope, ty);\n-                        tcx.register_item_type(DefId::local(trait_item.id),\n+                        tcx.register_item_type(ccx.tcx.map.local_def_id(trait_item.id),\n                                                TypeScheme {\n                                                    generics: trait_def.generics.clone(),\n                                                    ty: ty,\n                                                });\n-                        convert_associated_const(ccx, TraitContainer(DefId::local(it.id)),\n-                                                 trait_item.name, trait_item.id,\n-                                                 hir::Public, ty, default.is_some());\n+                        convert_associated_const(ccx,\n+                                                 TraitContainer(ccx.tcx.map.local_def_id(it.id)),\n+                                                 trait_item.name,\n+                                                 trait_item.id,\n+                                                 hir::Public,\n+                                                 ty,\n+                                                 default.is_some())\n                     }\n                     _ => {}\n                 }\n@@ -938,8 +943,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                             |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n                         });\n \n-                        convert_associated_type(ccx, TraitContainer(DefId::local(it.id)),\n-                                                trait_item.name, trait_item.id, hir::Public,\n+                        convert_associated_type(ccx,\n+                                                TraitContainer(ccx.tcx.map.local_def_id(it.id)),\n+                                                trait_item.name,\n+                                                trait_item.id,\n+                                                hir::Public,\n                                                 typ);\n                     }\n                     _ => {}\n@@ -956,15 +964,15 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Run convert_methods on the trait methods.\n             convert_methods(ccx,\n-                            TraitContainer(DefId::local(it.id)),\n+                            TraitContainer(ccx.tcx.map.local_def_id(it.id)),\n                             methods,\n                             tcx.mk_self_type(),\n                             &trait_def.generics,\n                             &trait_predicates);\n \n             // Add an entry mapping\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n-                let def_id = DefId::local(trait_item.id);\n+                let def_id = ccx.tcx.map.local_def_id(trait_item.id);\n                 match trait_item.node {\n                     hir::ConstTraitItem(..) => {\n                         ty::ConstTraitItemId(def_id)\n@@ -977,7 +985,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     }\n                 }\n             }).collect());\n-            tcx.trait_item_def_ids.borrow_mut().insert(DefId::local(it.id), trait_item_def_ids);\n+            tcx.trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+                                                       trait_item_def_ids);\n \n             // This must be done after `collect_trait_methods` so that\n             // we have a method type stored for every method.\n@@ -998,7 +1007,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n \n-            let variant = tcx.lookup_adt_def_master(DefId::local(it.id)).struct_variant();\n+            let it_def_id = ccx.tcx.map.local_def_id(it.id);\n+            let variant = tcx.lookup_adt_def_master(it_def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields.iter().zip(variant.fields.iter()) {\n                 convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n@@ -1036,14 +1046,14 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n                 .iter()\n                 .map(|field| field.unsubst_ty())\n                 .collect();\n-            tcx.mk_ctor_fn(DefId::local(ctor_id),\n+            tcx.mk_ctor_fn(tcx.map.local_def_id(ctor_id),\n                            &inputs[..],\n                            scheme.ty)\n         }\n     };\n     write_ty_to_tcx(tcx, ctor_id, ctor_ty);\n-    tcx.predicates.borrow_mut().insert(DefId::local(ctor_id), predicates);\n-    tcx.register_item_type(DefId::local(ctor_id),\n+    tcx.predicates.borrow_mut().insert(tcx.map.local_def_id(ctor_id), predicates);\n+    tcx.register_item_type(tcx.map.local_def_id(ctor_id),\n                            TypeScheme {\n                                generics: scheme.generics,\n                                ty: ctor_ty\n@@ -1092,10 +1102,11 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 did: DefId,\n                                 name: ast::Name,\n                                 disr_val: ty::Disr,\n-                                def: &hir::StructDef) -> ty::VariantDefData<'tcx, 'tcx> {\n+                                def: &hir::StructDef,\n+                                ctor_id: DefId) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n     let fields = def.fields.iter().map(|f| {\n-        let fid = DefId::local(f.node.id);\n+        let fid = tcx.map.local_def_id(f.node.id);\n         match f.node.kind {\n             hir::NamedField(name, vis) => {\n                 let dup_span = seen_fields.get(&name).cloned();\n@@ -1119,7 +1130,8 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n         did: did,\n         name: name,\n         disr_val: disr_val,\n-        fields: fields\n+        fields: fields,\n+        ctor_id: ctor_id\n     }\n }\n \n@@ -1129,11 +1141,13 @@ fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> ty::AdtDefMaster<'tcx>\n {\n \n-    let did = DefId::local(it.id);\n+    let did = tcx.map.local_def_id(it.id);\n+    let ctor_id = def.ctor_id.map_or(did,\n+        |ctor_id| tcx.map.local_def_id(ctor_id));\n     tcx.intern_adt_def(\n         did,\n         ty::AdtKind::Struct,\n-        vec![convert_struct_variant(tcx, did, it.name, 0, def)]\n+        vec![convert_struct_variant(tcx, did, it.name, 0, def, ctor_id)]\n     )\n }\n \n@@ -1206,7 +1220,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   disr: ty::Disr)\n                                   -> ty::VariantDefData<'tcx, 'tcx>\n     {\n-        let did = DefId::local(v.node.id);\n+        let did = tcx.map.local_def_id(v.node.id);\n         let name = v.node.name;\n         match v.node.kind {\n             hir::TupleVariantKind(ref va) => {\n@@ -1216,19 +1230,20 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     disr_val: disr,\n                     fields: va.iter().map(|&hir::VariantArg { id, .. }| {\n                         ty::FieldDefData::new(\n-                            DefId::local(id),\n+                            tcx.map.local_def_id(id),\n                             special_idents::unnamed_field.name,\n                             hir::Visibility::Public\n                         )\n-                    }).collect()\n+                    }).collect(),\n+                    ctor_id: did\n                 }\n             }\n             hir::StructVariantKind(ref def) => {\n-                convert_struct_variant(tcx, did, name, disr, &def)\n+                convert_struct_variant(tcx, did, name, disr, &def, did)\n             }\n         }\n     }\n-    let did = DefId::local(it.id);\n+    let did = tcx.map.local_def_id(it.id);\n     let repr_hints = tcx.lookup_repr_hints(did);\n     let (repr_type, repr_type_ty) = tcx.enum_repr_type(repr_hints.get(0));\n     let mut prev_disr = None;\n@@ -1242,7 +1257,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n         prev_disr = Some(disr);\n         v\n     }).collect();\n-    tcx.intern_adt_def(DefId::local(it.id), ty::AdtKind::Enum, variants)\n+    tcx.intern_adt_def(tcx.map.local_def_id(it.id), ty::AdtKind::Enum, variants)\n }\n \n /// Ensures that the super-predicates of the trait with def-id\n@@ -1260,19 +1275,19 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n \n     debug!(\"ensure_super_predicates_step(trait_def_id={:?})\", trait_def_id);\n \n-    if trait_def_id.krate != LOCAL_CRATE {\n+    let trait_node_id = if let Some(n) = tcx.map.as_local_node_id(trait_def_id) {\n+        n\n+    } else {\n         // If this trait comes from an external crate, then all of the\n         // supertraits it may depend on also must come from external\n         // crates, and hence all of them already have their\n         // super-predicates \"converted\" (and available from crate\n         // meta-data), so there is no need to transitively test them.\n         return Vec::new();\n-    }\n+    };\n \n     let superpredicates = tcx.super_predicates.borrow().get(&trait_def_id).cloned();\n     let superpredicates = superpredicates.unwrap_or_else(|| {\n-        let trait_node_id = trait_def_id.node;\n-\n         let item = match ccx.tcx.map.get(trait_node_id) {\n             hir_map::NodeItem(item) => item,\n             _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not an item\", trait_node_id))\n@@ -1315,7 +1330,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n             predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n         };\n         debug!(\"superpredicates for trait {:?} = {:?}\",\n-               DefId::local(item.id),\n+               tcx.map.local_def_id(item.id),\n                superpredicates);\n \n         tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n@@ -1338,7 +1353,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                it: &hir::Item)\n                                -> &'tcx ty::TraitDef<'tcx>\n {\n-    let def_id = DefId::local(it.id);\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n     let tcx = ccx.tcx;\n \n     if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n@@ -1402,7 +1417,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        param_id: def.lifetime.id,\n+                        def_id: tcx.map.local_def_id(def.lifetime.id),\n                         space: TypeSpace,\n                         index: i as u32,\n                         name: def.lifetime.name\n@@ -1452,7 +1467,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     let tcx = ccx.tcx;\n     let trait_def = trait_def_of_item(ccx, it);\n \n-    let def_id = DefId::local(it.id);\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n \n     let (generics, items) = match it.node {\n         hir::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n@@ -1526,23 +1541,23 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                   def_id: DefId)\n                                   -> ty::TypeScheme<'tcx>\n {\n-    if def_id.krate != LOCAL_CRATE {\n-        return ccx.tcx.lookup_item_type(def_id);\n-    }\n-\n-    match ccx.tcx.map.find(def_id.node) {\n-        Some(hir_map::NodeItem(item)) => {\n-            type_scheme_of_item(ccx, &*item)\n-        }\n-        Some(hir_map::NodeForeignItem(foreign_item)) => {\n-            let abi = ccx.tcx.map.get_foreign_abi(def_id.node);\n-            type_scheme_of_foreign_item(ccx, &*foreign_item, abi)\n-        }\n-        x => {\n-            ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n-                                            in get_item_type_scheme(): {:?}\",\n-                                       x));\n+    if let Some(node_id) = ccx.tcx.map.as_local_node_id(def_id) {\n+        match ccx.tcx.map.find(node_id) {\n+            Some(hir_map::NodeItem(item)) => {\n+                type_scheme_of_item(ccx, &*item)\n+            }\n+            Some(hir_map::NodeForeignItem(foreign_item)) => {\n+                let abi = ccx.tcx.map.get_foreign_abi(node_id);\n+                type_scheme_of_foreign_item(ccx, &*foreign_item, abi)\n+            }\n+            x => {\n+                ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n+                                           in get_item_type_scheme(): {:?}\",\n+                                          x));\n+            }\n         }\n+    } else {\n+        ccx.tcx.lookup_item_type(def_id)\n     }\n }\n \n@@ -1551,7 +1566,7 @@ fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                 -> ty::TypeScheme<'tcx>\n {\n     memoized(&ccx.tcx.tcache,\n-             DefId::local(it.id),\n+             ccx.tcx.map.local_def_id(it.id),\n              |_| compute_type_scheme_of_item(ccx, it))\n }\n \n@@ -1568,7 +1583,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n-            let ty = tcx.mk_fn(Some(DefId::local(it.id)), tcx.mk_bare_fn(tofd));\n+            let ty = tcx.mk_fn(Some(ccx.tcx.map.local_def_id(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         hir::ItemTy(ref t, ref generics) => {\n@@ -1643,12 +1658,12 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(DefId::local(it.id),\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n                                                              predicates.clone());\n     assert!(prev_predicates.is_none());\n \n     // Debugging aid.\n-    if tcx.has_attr(DefId::local(it.id), \"rustc_object_lifetime_default\") {\n+    if tcx.has_attr(ccx.tcx.map.local_def_id(it.id), \"rustc_object_lifetime_default\") {\n         let object_lifetime_default_reprs: String =\n             scheme.generics.types.iter()\n                                  .map(|t| match t.object_lifetime_default {\n@@ -1671,7 +1686,7 @@ fn type_scheme_of_foreign_item<'a, 'tcx>(\n     -> ty::TypeScheme<'tcx>\n {\n     memoized(&ccx.tcx.tcache,\n-             DefId::local(it.id),\n+             ccx.tcx.map.local_def_id(it.id),\n              |_| compute_type_scheme_of_foreign_item(ccx, it, abi))\n }\n \n@@ -1716,7 +1731,8 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(DefId::local(it.id), predicates);\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n+                                                             predicates);\n     assert!(prev_predicates.is_none());\n }\n \n@@ -1740,7 +1756,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    -> ty::Generics<'tcx>\n {\n     debug!(\"ty_generics_for_trait(trait_id={:?}, substs={:?})\",\n-           DefId::local(trait_id), substs);\n+           ccx.tcx.map.local_def_id(trait_id), substs);\n \n     let mut generics = ty_generics_for_type_or_impl(ccx, ast_generics);\n \n@@ -1756,8 +1772,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         space: SelfSpace,\n         index: 0,\n         name: special_idents::type_self.name,\n-        def_id: DefId::local(param_id),\n-        default_def_id: DefId::local(parent),\n+        def_id: ccx.tcx.map.local_def_id(param_id),\n+        default_def_id: ccx.tcx.map.local_def_id(parent),\n         default: None,\n         object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n     };\n@@ -1876,9 +1892,10 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n     for (index, param) in early_lifetimes.iter().enumerate() {\n         let index = index as u32;\n+        let def_id = tcx.map.local_def_id(param.lifetime.id);\n         let region =\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                param_id: param.lifetime.id,\n+                def_id: def_id,\n                 space: space,\n                 index: index,\n                 name: param.lifetime.name\n@@ -1964,7 +1981,7 @@ fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let def = ty::RegionParameterDef { name: l.lifetime.name,\n                                            space: space,\n                                            index: i as u32,\n-                                           def_id: DefId::local(l.lifetime.id),\n+                                           def_id: ccx.tcx.map.local_def_id(l.lifetime.id),\n                                            bounds: bounds };\n         result.regions.push(space, def);\n     }\n@@ -2032,8 +2049,8 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         space: space,\n         index: index,\n         name: param.name,\n-        def_id: DefId::local(param.id),\n-        default_def_id: DefId::local(parent),\n+        def_id: ccx.tcx.map.local_def_id(param.id),\n+        default_def_id: ccx.tcx.map.local_def_id(parent),\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n     };\n@@ -2376,9 +2393,10 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         tcx.fold_regions(value, &mut false, |region, _| {\n             match region {\n                 ty::ReEarlyBound(data) => {\n-                    let def_id = DefId::local(data.param_id);\n-                    ty::ReFree(ty::FreeRegion { scope: scope,\n-                                                bound_region: ty::BrNamed(def_id, data.name) })\n+                    ty::ReFree(ty::FreeRegion {\n+                        scope: scope,\n+                        bound_region: ty::BrNamed(data.def_id, data.name)\n+                    })\n                 }\n                 _ => region\n             }\n@@ -2423,7 +2441,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let lifetimes_in_associated_types: HashSet<_> =\n         impl_items.iter()\n-                  .map(|item| tcx.impl_or_trait_item(DefId::local(item.id)))\n+                  .map(|item| tcx.impl_or_trait_item(tcx.map.local_def_id(item.id)))\n                   .filter_map(|item| match item {\n                       ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n                       ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n@@ -2436,7 +2454,8 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   .collect();\n \n     for (index, lifetime_def) in ast_generics.lifetimes.iter().enumerate() {\n-        let region = ty::EarlyBoundRegion { param_id: lifetime_def.lifetime.id,\n+        let def_id = tcx.map.local_def_id(lifetime_def.lifetime.id);\n+        let region = ty::EarlyBoundRegion { def_id: def_id,\n                                             space: TypeSpace,\n                                             index: index as u32,\n                                             name: lifetime_def.lifetime.name };"}, {"sha": "7156c9c6091a7b4fb9810b55fe271fc008f4906b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -98,20 +98,20 @@ extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_front;\n \n+pub use rustc::front;\n pub use rustc::lint;\n pub use rustc::metadata;\n pub use rustc::middle;\n pub use rustc::session;\n pub use rustc::util;\n \n+use front::map as hir_map;\n use middle::def;\n-use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n use middle::ty::{self, Ty, HasTypeFlags};\n use session::config;\n use util::common::time;\n-use rustc::front::map as hir_map;\n use rustc_front::hir;\n \n use syntax::codemap::Span;\n@@ -239,7 +239,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 }\n                 _ => ()\n             }\n-            let se_ty = tcx.mk_fn(Some(DefId::local(main_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let main_def_id = tcx.map.local_def_id(main_id);\n+            let se_ty = tcx.mk_fn(Some(main_def_id), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n@@ -285,7 +286,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let se_ty = tcx.mk_fn(Some(DefId::local(start_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let se_ty = tcx.mk_fn(Some(ccx.tcx.map.local_def_id(start_id)),\n+                                  tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {"}, {"sha": "8152e685d8d831819bf6cff30884061247cf2ced", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -266,7 +266,7 @@ use self::ParamKind::*;\n \n use arena;\n use arena::TypedArena;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use middle::subst;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n@@ -403,10 +403,10 @@ fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n \n         ];\n \n-    all.into_iter()\n+    all.into_iter() // iterating over (Option<DefId>, Variance)\n        .filter(|&(ref d,_)| d.is_some())\n-       .filter(|&(ref d,_)| d.as_ref().unwrap().is_local())\n-       .map(|(d, v)| (d.unwrap().node, v))\n+       .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n+       .filter_map(|(d, v)| tcx.map.as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n        .collect()\n }\n \n@@ -451,9 +451,10 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         // \"invalid item id\" from \"item id with no\n         // parameters\".\n         if self.num_inferred() == inferreds_on_entry {\n+            let item_def_id = self.tcx.map.local_def_id(item_id);\n             let newly_added =\n                 self.tcx.item_variance_map.borrow_mut().insert(\n-                    DefId::local(item_id),\n+                    item_def_id,\n                     self.empty_variances.clone()).is_none();\n             assert!(newly_added);\n         }\n@@ -486,7 +487,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n-               self.tcx.item_path_str(DefId::local(item_id)),\n+               self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n                item_id, kind, space, index, param_id, inf_index,\n                initial_variance);\n     }\n@@ -596,8 +597,8 @@ fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let did = DefId::local(item.id);\n         let tcx = self.terms_cx.tcx;\n+        let did = tcx.map.local_def_id(item.id);\n \n         debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n \n@@ -739,11 +740,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n \n-        if param_def_id.is_local() {\n+        if let Some(param_node_id) = self.tcx().map.as_local_node_id(param_def_id) {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n-            let InferredIndex(index) = self.inferred_index(param_def_id.node);\n+            let InferredIndex(index) = self.inferred_index(param_node_id);\n             self.terms_cx.inferred_infos[index].term\n         } else {\n             // Parameter on an item defined within another crate:\n@@ -922,8 +923,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyParam(ref data) => {\n                 let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n-                assert_eq!(def_id.krate, LOCAL_CRATE);\n-                match self.terms_cx.inferred_map.get(&def_id.node) {\n+                let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n+                match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n                         self.add_constraint(index, variance);\n                     }\n@@ -1011,8 +1012,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n             ty::ReEarlyBound(ref data) => {\n-                if self.is_to_be_inferred(data.param_id) {\n-                    let index = self.inferred_index(data.param_id);\n+                let node_id = self.tcx().map.as_local_node_id(data.def_id).unwrap();\n+                if self.is_to_be_inferred(node_id) {\n+                    let index = self.inferred_index(node_id);\n                     self.add_constraint(index, variance);\n                 }\n             }\n@@ -1163,7 +1165,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                     item_id,\n                     item_variances);\n \n-            let item_def_id = DefId::local(item_id);\n+            let item_def_id = tcx.map.local_def_id(item_id);\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found."}, {"sha": "3492635a20be420996ccb52854496cdeee57849f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -39,7 +39,7 @@ use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n-use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n+use rustc::middle::def_id::{DefId, DefIndex};\n use rustc::middle::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::middle::ty;\n use rustc::middle::stability;\n@@ -188,7 +188,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     attrs: child.attrs.clone(),\n                     visibility: Some(hir::Public),\n                     stability: None,\n-                    def_id: DefId::local(prim.to_node_id()),\n+                    def_id: DefId::local(prim.to_def_index()),\n                     inner: PrimitiveItem(prim),\n                 });\n             }\n@@ -419,7 +419,7 @@ impl Clean<Item> for doctree::Module {\n             source: whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n                items: items\n@@ -495,7 +495,7 @@ impl Clean<TyParam> for hir::TyParam {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         TyParam {\n             name: self.name.clean(cx),\n-            did: DefId { krate: LOCAL_CRATE, node: self.id },\n+            did: cx.map.local_def_id(self.id),\n             bounds: self.bounds.clean(cx),\n             default: self.default.clean(cx),\n         }\n@@ -1087,7 +1087,7 @@ impl Clean<Item> for doctree::Function {\n             source: self.whence.clean(cx),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(cx),\n                 generics: self.generics.clean(cx),\n@@ -1137,10 +1137,10 @@ impl<'tcx> Clean<Type> for ty::FnOutput<'tcx> {\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if did.node != 0 {\n-            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).into_iter()\n+        let mut names = if let Some(_) = cx.map.as_local_node_id(did) {\n+            vec![].into_iter()\n         } else {\n-            Vec::new().into_iter()\n+            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).into_iter()\n         }.peekable();\n         if names.peek().map(|s| &**s) == Some(\"self\") {\n             let _ = names.next();\n@@ -1210,7 +1210,7 @@ impl Clean<Item> for doctree::Trait {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: TraitItem(Trait {\n@@ -1260,9 +1260,9 @@ impl Clean<Item> for hir::TraitItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: None,\n-            stability: get_stability(cx, DefId::local(self.id)),\n+            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1293,9 +1293,9 @@ impl Clean<Item> for hir::ImplItem {\n             name: Some(self.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, DefId::local(self.id)),\n+            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1559,8 +1559,9 @@ impl PrimitiveType {\n     /// Creates a rustdoc-specific node id for primitive types.\n     ///\n     /// These node ids are generally never used by the AST itself.\n-    pub fn to_node_id(&self) -> ast::NodeId {\n-        u32::MAX - 1 - (*self as u32)\n+    pub fn to_def_index(&self) -> DefIndex {\n+        let x = u32::MAX - 1 - (*self as u32);\n+        DefIndex::new(x as usize)\n     }\n }\n \n@@ -1659,7 +1660,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     type_params: Vec::new(),\n                     where_predicates: Vec::new()\n                 },\n-                decl: (DefId::local(0), &fty.sig).clean(cx),\n+                decl: (cx.map.local_def_id(0), &fty.sig).clean(cx),\n                 abi: fty.abi.to_string(),\n             }),\n             ty::TyStruct(def, substs) |\n@@ -1727,8 +1728,8 @@ impl Clean<Item> for hir::StructField {\n             attrs: self.node.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: Some(vis),\n-            stability: get_stability(cx, DefId::local(self.node.id)),\n-            def_id: DefId::local(self.node.id),\n+            stability: get_stability(cx, cx.map.local_def_id(self.node.id)),\n+            def_id: cx.map.local_def_id(self.node.id),\n             inner: StructFieldItem(TypedStructField(self.node.ty.clean(cx))),\n         }\n     }\n@@ -1744,7 +1745,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n         let (name, attrs) = if self.name == unnamed_field.name {\n             (None, None)\n         } else {\n-            (Some(self.name), Some(attr_map.get(&self.did.node).unwrap()))\n+            (Some(self.name), Some(attr_map.get(&self.did).unwrap()))\n         };\n \n         Item {\n@@ -1781,7 +1782,7 @@ impl Clean<Item> for doctree::Struct {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: StructItem(Struct {\n@@ -1827,7 +1828,7 @@ impl Clean<Item> for doctree::Enum {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: EnumItem(Enum {\n@@ -1852,7 +1853,7 @@ impl Clean<Item> for doctree::Variant {\n             source: self.whence.clean(cx),\n             visibility: None,\n             stability: self.stab.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             inner: VariantItem(Variant {\n                 kind: self.kind.clean(cx),\n             }),\n@@ -2082,7 +2083,7 @@ impl Clean<Item> for doctree::Typedef {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id.clone()),\n+            def_id: cx.map.local_def_id(self.id.clone()),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: TypedefItem(Typedef {\n@@ -2133,7 +2134,7 @@ impl Clean<Item> for doctree::Static {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: StaticItem(Static {\n@@ -2157,7 +2158,7 @@ impl Clean<Item> for doctree::Constant {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: ConstantItem(Constant {\n@@ -2231,7 +2232,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             inner: ImplItem(Impl {\n@@ -2313,7 +2314,7 @@ impl Clean<Item> for doctree::DefaultImpl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: Some(hir::Public),\n             stability: None,\n             inner: DefaultImplItem(DefaultImpl {\n@@ -2330,7 +2331,7 @@ impl Clean<Item> for doctree::ExternCrate {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(0),\n+            def_id: cx.map.local_def_id(0),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             inner: ExternCrateItem(self.name.clean(cx), self.path.clone())\n@@ -2395,7 +2396,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: DefId::local(0),\n+            def_id: cx.map.local_def_id(0),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             inner: ImportItem(inner)\n@@ -2481,9 +2482,9 @@ impl Clean<Item> for hir::ForeignItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, DefId::local(self.id)),\n+            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             inner: inner,\n         }\n     }\n@@ -2570,17 +2571,19 @@ fn name_from_pat(p: &hir::Pat) -> String {\n fn resolve_type(cx: &DocContext,\n                 path: Path,\n                 id: ast::NodeId) -> Type {\n+    debug!(\"resolve_type({:?},{:?})\", path, id);\n     let tcx = match cx.tcx_opt() {\n         Some(tcx) => tcx,\n         // If we're extracting tests, this return value doesn't matter.\n         None => return Primitive(Bool),\n     };\n-    debug!(\"searching for {} in defmap\", id);\n     let def = match tcx.def_map.borrow().get(&id) {\n         Some(k) => k.full_def(),\n         None => panic!(\"unresolved id not in defmap\")\n     };\n \n+    debug!(\"resolve_type: def={:?}\", def);\n+\n     let is_generic = match def {\n         def::DefPrimTy(p) => match p {\n             hir::TyStr => return Primitive(Str),\n@@ -2610,6 +2613,8 @@ fn resolve_type(cx: &DocContext,\n }\n \n fn register_def(cx: &DocContext, def: def::Def) -> DefId {\n+    debug!(\"register_def({:?})\", def);\n+\n     let (did, kind) = match def {\n         def::DefFn(i, _) => (i, TypeFunction),\n         def::DefTy(i, false) => (i, TypeTypedef),\n@@ -2619,6 +2624,8 @@ fn register_def(cx: &DocContext, def: def::Def) -> DefId {\n         def::DefMod(i) => (i, TypeModule),\n         def::DefStatic(i, _) => (i, TypeStatic),\n         def::DefVariant(i, _, _) => (i, TypeEnum),\n+        def::DefSelfTy(Some(def_id), _) => (def_id, TypeTrait),\n+        def::DefSelfTy(_, Some((impl_id, _))) => return cx.map.local_def_id(impl_id),\n         _ => return def.def_id()\n     };\n     if did.is_local() { return did }\n@@ -2661,7 +2668,7 @@ impl Clean<Item> for doctree::Macro {\n             source: self.whence.clean(cx),\n             visibility: hir::Public.clean(cx),\n             stability: self.stab.clean(cx),\n-            def_id: DefId::local(self.id),\n+            def_id: cx.map.local_def_id(self.id),\n             inner: MacroItem(Macro {\n                 source: self.whence.to_src(cx),\n                 imported_from: self.imported_from.clean(cx),"}, {"sha": "c84a7e7c560dd57bd5cd04d3750cb25d62598cee", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -13,13 +13,13 @@ use rustc_lint;\n use rustc_driver::{driver, target_features};\n use rustc::session::{self, config};\n use rustc::middle::def_id::DefId;\n-use rustc::middle::{privacy, ty};\n+use rustc::middle::ty;\n use rustc::front::map as hir_map;\n use rustc::lint;\n+use rustc::util::nodemap::DefIdSet;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_front::lowering::lower_crate;\n-use rustc_front::hir;\n \n use syntax::{ast, codemap, diagnostic};\n use syntax::feature_gate::UnstableFeatures;\n@@ -44,7 +44,7 @@ pub type ExternalPaths = RefCell<Option<HashMap<DefId,\n                                                 (Vec<String>, clean::TypeKind)>>>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n-    pub krate: &'tcx hir::Crate,\n+    pub map: &'a hir_map::Map<'tcx>,\n     pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n     pub external_paths: ExternalPaths,\n@@ -77,8 +77,8 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n }\n \n pub struct CrateAnalysis {\n-    pub exported_items: privacy::ExportedItems,\n-    pub public_items: privacy::PublicItems,\n+    pub exported_items: DefIdSet,\n+    pub public_items: DefIdSet,\n     pub external_paths: ExternalPaths,\n     pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n     pub inlined: RefCell<Option<HashSet<DefId>>>,\n@@ -147,8 +147,19 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n                                         |tcx, analysis| {\n         let ty::CrateAnalysis { exported_items, public_items, .. } = analysis;\n \n+        // Convert from a NodeId set to a DefId set since we don't always have easy access\n+        // to the map from defid -> nodeid\n+        let exported_items: DefIdSet =\n+            exported_items.into_iter()\n+                          .map(|n| tcx.map.local_def_id(n))\n+                          .collect();\n+        let public_items: DefIdSet =\n+            public_items.into_iter()\n+                        .map(|n| tcx.map.local_def_id(n))\n+                        .collect();\n+\n         let ctxt = DocContext {\n-            krate: tcx.map.krate(),\n+            map: &tcx.map,\n             maybe_typed: Typed(tcx),\n             input: input,\n             external_traits: RefCell::new(Some(HashMap::new())),\n@@ -158,7 +169,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n             populated_crate_impls: RefCell::new(HashSet::new()),\n             deref_trait_did: Cell::new(None),\n         };\n-        debug!(\"crate: {:?}\", ctxt.krate);\n+        debug!(\"crate: {:?}\", ctxt.map.krate());\n \n         let mut analysis = CrateAnalysis {\n             exported_items: exported_items,\n@@ -171,7 +182,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n \n         let krate = {\n             let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n-            v.visit(ctxt.krate);\n+            v.visit(ctxt.map.krate());\n             v.clean(&ctxt)\n         };\n "}, {"sha": "d12c5d2c6fb6b3a5350997c12cd385b7c3e9b5ac", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -18,9 +18,9 @@\n use std::fmt;\n use std::iter::repeat;\n \n-use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n+use rustc::metadata::cstore::LOCAL_CRATE;\n+use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use syntax::abi::Abi;\n-use syntax::ast;\n use rustc_front::hir;\n \n use clean;\n@@ -386,7 +386,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n         Some(&cnum) => {\n             let path = &m.paths[&DefId {\n                 krate: cnum,\n-                node: ast::CRATE_NODE_ID,\n+                index: CRATE_DEF_INDEX,\n             }];\n             let loc = match m.extern_locations[&cnum] {\n                 (_, render::Remote(ref s)) => Some(s.to_string()),"}, {"sha": "cf03482e18b8a902d541bdb8f2805313bfa7f1ab", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -53,8 +53,9 @@ use externalfiles::ExternalHtml;\n \n use serialize::json::{self, ToJson};\n use syntax::{abi, ast, attr};\n-use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n-use rustc::util::nodemap::NodeSet;\n+use rustc::metadata::cstore::LOCAL_CRATE;\n+use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::util::nodemap::DefIdSet;\n use rustc_front::hir;\n \n use clean::{self, SelfTy};\n@@ -205,15 +206,15 @@ pub struct Cache {\n     search_index: Vec<IndexItem>,\n     privmod: bool,\n     remove_priv: bool,\n-    public_items: NodeSet,\n+    public_items: DefIdSet,\n     deref_trait_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,\n     // then the fully qualified name of the structure isn't presented in `paths`\n     // yet when its implementation methods are being indexed. Caches such methods\n     // and their parent id here and indexes them at the end of crate parsing.\n-    orphan_methods: Vec<(ast::NodeId, clean::Item)>,\n+    orphan_methods: Vec<(DefId, clean::Item)>,\n }\n \n /// Helper struct to render all source code to HTML pages\n@@ -377,7 +378,7 @@ pub fn run(mut krate: clean::Crate,\n     let analysis = ::ANALYSISKEY.with(|a| a.clone());\n     let analysis = analysis.borrow();\n     let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n-    let public_items = public_items.unwrap_or(NodeSet());\n+    let public_items = public_items.unwrap_or(DefIdSet());\n     let paths: HashMap<DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take().unwrap();\n@@ -412,7 +413,7 @@ pub fn run(mut krate: clean::Crate,\n     for &(n, ref e) in &krate.externs {\n         cache.extern_locations.insert(n, (e.name.clone(),\n                                           extern_location(e, &cx.dst)));\n-        let did = DefId { krate: n, node: ast::CRATE_NODE_ID };\n+        let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n         cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n \n@@ -459,8 +460,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n \n         // Attach all orphan methods to the type's definition if the type\n         // has since been learned.\n-        for &(pid, ref item) in orphan_methods {\n-            let did = DefId::local(pid);\n+        for &(did, ref item) in orphan_methods {\n             match paths.get(&did) {\n                 Some(&(ref fqp, _)) => {\n                     // Needed to determine `self` type.\n@@ -968,7 +968,7 @@ impl DocFolder for Cache {\n                     if parent.is_local() {\n                         // We have a parent, but we don't know where they're\n                         // defined yet. Wait for later to index this item.\n-                        self.orphan_methods.push((parent.node, item.clone()))\n+                        self.orphan_methods.push((parent, item.clone()))\n                     }\n                 }\n                 _ => {}\n@@ -994,10 +994,11 @@ impl DocFolder for Cache {\n                 // `public_items` map, so we can skip inserting into the\n                 // paths map if there was already an entry present and we're\n                 // not a public item.\n-                let id = item.def_id.node;\n-                if !self.paths.contains_key(&item.def_id) ||\n-                   !item.def_id.is_local() ||\n-                   self.public_items.contains(&id) {\n+                if\n+                    !self.paths.contains_key(&item.def_id) ||\n+                    !item.def_id.is_local() ||\n+                    self.public_items.contains(&item.def_id)\n+                {\n                     self.paths.insert(item.def_id,\n                                       (self.stack.clone(), shortty(&item)));\n                 }\n@@ -1033,7 +1034,7 @@ impl DocFolder for Cache {\n                     ref t => {\n                         match t.primitive_type() {\n                             Some(prim) => {\n-                                let did = DefId::local(prim.to_node_id());\n+                                let did = DefId::local(prim.to_def_index());\n                                 self.parent_stack.push(did);\n                                 true\n                             }\n@@ -1078,8 +1079,8 @@ impl DocFolder for Cache {\n                             ref t => {\n                                 t.primitive_type().and_then(|t| {\n                                     self.primitive_locations.get(&t).map(|n| {\n-                                        let id = t.to_node_id();\n-                                        DefId { krate: *n, node: id }\n+                                        let id = t.to_def_index();\n+                                        DefId { krate: *n, index: id }\n                                     })\n                                 })\n                             }\n@@ -1420,7 +1421,7 @@ impl<'a> Item<'a> {\n                          root = root,\n                          path = path[..path.len() - 1].join(\"/\"),\n                          file = item_path(self.item),\n-                         goto = self.item.def_id.node))\n+                         goto = self.item.def_id.index.as_usize()))\n         }\n     }\n }\n@@ -1480,7 +1481,7 @@ impl<'a> fmt::Display for Item<'a> {\n                 Some(l) => {\n                     try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n                                        href='{}' title='{}'>[src]</a>\",\n-                                self.item.def_id.node, l, \"goto source code\"));\n+                                self.item.def_id.index.as_usize(), l, \"goto source code\"));\n                 }\n                 None => {}\n             }\n@@ -2336,7 +2337,7 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl) -> f\n         _ => {\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n-                    let did = DefId { krate: *c, node: prim.to_node_id() };\n+                    let did = DefId { krate: *c, index: prim.to_def_index() };\n                     try!(render_assoc_items(w, cx, did, what));\n                 }\n             }"}, {"sha": "e7e38220825f7dc042a45714e12c1c62749b0932", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::collections::HashSet;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::DefIdSet;\n use std::cmp;\n use std::string::String;\n use std::usize;\n-use syntax::ast;\n use rustc_front::hir;\n \n use clean;\n@@ -24,18 +22,18 @@ use fold::DocFolder;\n \n /// Strip items marked `#[doc(hidden)]`\n pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut stripped = HashSet::new();\n+    let mut stripped = DefIdSet();\n \n     // strip all #[doc(hidden)] items\n     let krate = {\n         struct Stripper<'a> {\n-            stripped: &'a mut HashSet<ast::NodeId>\n+            stripped: &'a mut DefIdSet\n         };\n         impl<'a> fold::DocFolder for Stripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n                 if i.is_hidden_from_doc() {\n                     debug!(\"found one in strip_hidden; removing\");\n-                    self.stripped.insert(i.def_id.node);\n+                    self.stripped.insert(i.def_id);\n \n                     // use a dedicated hidden item for given item type if any\n                     match i.inner {\n@@ -61,7 +59,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n     // strip any traits implemented on stripped items\n     let krate = {\n         struct ImplStripper<'a> {\n-            stripped: &'a mut HashSet<ast::NodeId>\n+            stripped: &'a mut DefIdSet\n         };\n         impl<'a> fold::DocFolder for ImplStripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n@@ -70,12 +68,12 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n                            ref trait_, ..\n                 }) = i.inner {\n                     // Impls for stripped types don't need to exist\n-                    if self.stripped.contains(&did.node) {\n+                    if self.stripped.contains(&did) {\n                         return None;\n                     }\n                     // Impls of stripped traits also don't need to exist\n                     if let Some(clean::ResolvedPath { did, .. }) = *trait_ {\n-                        if self.stripped.contains(&did.node) {\n+                        if self.stripped.contains(&did) {\n                             return None;\n                         }\n                     }\n@@ -94,7 +92,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n /// crate, specified by the `xcrate` flag.\n pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n-    let mut retained = HashSet::new();\n+    let mut retained = DefIdSet();\n     let analysis = super::ANALYSISKEY.with(|a| a.clone());\n     let analysis = analysis.borrow();\n     let analysis = analysis.as_ref().unwrap();\n@@ -118,8 +116,8 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n }\n \n struct Stripper<'a> {\n-    retained: &'a mut HashSet<ast::NodeId>,\n-    exported_items: &'a NodeSet,\n+    retained: &'a mut DefIdSet,\n+    exported_items: &'a DefIdSet,\n }\n \n impl<'a> fold::DocFolder for Stripper<'a> {\n@@ -132,7 +130,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::VariantItem(..) | clean::MethodItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n                 if i.def_id.is_local() {\n-                    if !self.exported_items.contains(&i.def_id.node) {\n+                    if !self.exported_items.contains(&i.def_id) {\n                         return None;\n                     }\n                     // Traits are in exported_items even when they're totally private.\n@@ -143,8 +141,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             }\n \n             clean::ConstantItem(..) => {\n-                if i.def_id.is_local() &&\n-                   !self.exported_items.contains(&i.def_id.node) {\n+                if i.def_id.is_local() && !self.exported_items.contains(&i.def_id) {\n                     return None;\n                 }\n             }\n@@ -171,8 +168,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::ImplItem(clean::Impl{\n                 for_: clean::ResolvedPath{ did, .. }, ..\n             }) => {\n-                if did.is_local() &&\n-                   !self.exported_items.contains(&did.node) {\n+                if did.is_local() && !self.exported_items.contains(&did) {\n                     return None;\n                 }\n             }\n@@ -205,7 +201,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n         };\n \n         let i = if fastreturn {\n-            self.retained.insert(i.def_id.node);\n+            self.retained.insert(i.def_id);\n             return Some(i);\n         } else {\n             self.fold_item_recur(i)\n@@ -220,7 +216,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                            i.doc_value().is_none() => None,\n                     clean::ImplItem(ref i) if i.items.is_empty() => None,\n                     _ => {\n-                        self.retained.insert(i.def_id.node);\n+                        self.retained.insert(i.def_id);\n                         Some(i)\n                     }\n                 }\n@@ -231,14 +227,13 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n }\n \n // This stripper discards all private impls of traits\n-struct ImplStripper<'a>(&'a HashSet<ast::NodeId>);\n+struct ImplStripper<'a>(&'a DefIdSet);\n impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n             match imp.trait_ {\n                 Some(clean::ResolvedPath{ did, .. }) => {\n-                    let ImplStripper(s) = *self;\n-                    if did.is_local() && !s.contains(&did.node) {\n+                    if did.is_local() && !self.0.contains(&did) {\n                         return None;\n                     }\n                 }"}, {"sha": "387e1a8cc07273f857b22da06456b61b513b603f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -22,6 +22,7 @@ use std::sync::{Arc, Mutex};\n \n use testing;\n use rustc_lint;\n+use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n use rustc::session::config::get_unstable_features_setting;\n use rustc::session::search_paths::{SearchPaths, PathKind};\n@@ -86,8 +87,11 @@ pub fn run(input: &str,\n \n     let opts = scrape_test_config(&krate);\n \n+    let mut forest = hir_map::Forest::new(krate);\n+    let map = hir_map::map_crate(&mut forest);\n+\n     let ctx = core::DocContext {\n-        krate: &krate,\n+        map: &map,\n         maybe_typed: core::NotTyped(sess),\n         input: input,\n         external_paths: RefCell::new(Some(HashMap::new())),\n@@ -99,7 +103,7 @@ pub fn run(input: &str,\n     };\n \n     let mut v = RustdocVisitor::new(&ctx, None);\n-    v.visit(ctx.krate);\n+    v.visit(ctx.map.krate());\n     let mut krate = v.clean(&ctx);\n     match crate_name {\n         Some(name) => krate.name = name,"}, {"sha": "264656835a384a649e7f1a157f94c70c1ab6df9a", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -21,7 +21,6 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n use rustc::front::map as hir_map;\n-use rustc::middle::def_id::DefId;\n use rustc::middle::stability;\n \n use rustc_front::hir;\n@@ -63,8 +62,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        self.cx.tcx_opt().and_then(\n-            |tcx| stability::lookup(tcx, DefId::local(id)).map(|x| x.clone()))\n+        self.cx.tcx_opt().and_then(|tcx| {\n+            self.cx.map.opt_local_def_id(id)\n+                       .and_then(|def_id| stability::lookup(tcx, def_id))\n+                       .cloned()\n+        })\n     }\n \n     pub fn visit(&mut self, krate: &hir::Crate) {\n@@ -206,16 +208,18 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => return false\n         };\n         let def = tcx.def_map.borrow()[&id].def_id();\n-        if !def.is_local() { return false }\n+        let def_node_id = match tcx.map.as_local_node_id(def) {\n+            Some(n) => n, None => return false\n+        };\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false\n         };\n-        if !please_inline && analysis.public_items.contains(&def.node) {\n+        if !please_inline && analysis.public_items.contains(&def) {\n             return false\n         }\n-        if !self.view_item_stack.insert(def.node) { return false }\n+        if !self.view_item_stack.insert(def_node_id) { return false }\n \n-        let ret = match tcx.map.get(def.node) {\n+        let ret = match tcx.map.get(def_node_id) {\n             hir_map::NodeItem(it) => {\n                 if glob {\n                     let prev = mem::replace(&mut self.inlining_from_glob, true);\n@@ -236,7 +240,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        self.view_item_stack.remove(&id);\n+        self.view_item_stack.remove(&def_node_id);\n         return ret;\n     }\n "}, {"sha": "d186918f44aaae4925b1604b9243183b80c35a8e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -167,13 +167,13 @@ impl fmt::Display for Ident {\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.name.as_str())\n+        self.name.encode(s)\n     }\n }\n \n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(str_to_ident(&try!(d.read_str())[..]))\n+        Ok(Ident::with_empty_ctxt(try!(Name::decode(d))))\n     }\n }\n "}, {"sha": "16b0e8638de3916bb720e9e8ebb5f3a751d42cdd", "filename": "src/test/compile-fail/borrowck-in-static.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Ftest%2Fcompile-fail%2Fborrowck-in-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Ftest%2Fcompile-fail%2Fborrowck-in-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-in-static.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that borrowck looks inside consts/statics\n+\n+static FN : &'static (Fn() -> (Box<Fn()->Box<i32>>) + Sync) = &|| {\n+    let x = Box::new(0);\n+    Box::new(|| x) //~ ERROR cannot move out of captured outer variable\n+};\n+\n+fn main() {\n+    let f = (FN)();\n+    f();\n+    f();\n+}"}, {"sha": "c5c4fb070178a1f85d63d3030e25ae8b71084761", "filename": "src/test/compile-fail/issue-28113.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const X: u8 =\n+    || -> u8 { 5 }() //~ ERROR function calls in constants are limited\n+;\n+\n+fn main() {}"}, {"sha": "a33882a8331858e890934be1b262944105ab4212", "filename": "src/test/run-pass/issue-27890.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Ftest%2Frun-pass%2Fissue-27890.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d35f12ae7a73fcef1c59b5b2cc0142a557934c/src%2Ftest%2Frun-pass%2Fissue-27890.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27890.rs?ref=55d35f12ae7a73fcef1c59b5b2cc0142a557934c", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static PLUS_ONE: &'static (Fn(i32) -> i32 + Sync) = (&|x: i32| { x + 1 })\n+    as &'static (Fn(i32) -> i32 + Sync);\n+\n+fn main() {\n+    assert_eq!(PLUS_ONE(2), 3);\n+}"}]}