{"sha": "f79719b8ae4d1929acaa940802a1e293f7dd7a6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3OTcxOWI4YWU0ZDE5MjlhY2FhOTQwODAyYTFlMjkzZjdkZDdhNmI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-04T11:14:48Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-04T11:22:47Z"}, "message": "Move find_refs_to_def", "tree": {"sha": "a793e25b0037d61df3470ec59f09ea823d56d593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a793e25b0037d61df3470ec59f09ea823d56d593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f79719b8ae4d1929acaa940802a1e293f7dd7a6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f79719b8ae4d1929acaa940802a1e293f7dd7a6b", "html_url": "https://github.com/rust-lang/rust/commit/f79719b8ae4d1929acaa940802a1e293f7dd7a6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2638bec66cb05ff51a0804181a47546a0f55afbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2638bec66cb05ff51a0804181a47546a0f55afbf", "html_url": "https://github.com/rust-lang/rust/commit/2638bec66cb05ff51a0804181a47546a0f55afbf"}], "stats": {"total": 295, "additions": 153, "deletions": 142}, "files": [{"sha": "4ad436b2c95fa0a40618ebf995ca584a3795989d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f79719b8ae4d1929acaa940802a1e293f7dd7a6b", "patch": "@@ -1060,6 +1060,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"fst\",\n  \"log\",\n+ \"once_cell\",\n  \"ra_db\",\n  \"ra_hir\",\n  \"ra_prof\","}, {"sha": "adee7c493ccad36774b71272b7a0eb12afd8d51c", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=f79719b8ae4d1929acaa940802a1e293f7dd7a6b", "patch": "@@ -19,6 +19,7 @@ join_to_string = \"0.1.3\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n rand = { version = \"0.7.3\", features = [\"small_rng\"] }\n+# TODO: check if can remove\n once_cell = \"1.3.1\"\n \n ra_syntax = { path = \"../ra_syntax\" }"}, {"sha": "abecca2bb848daba80a95097094b23f32ca3ec3e", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 4, "deletions": 139, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=f79719b8ae4d1929acaa940802a1e293f7dd7a6b", "patch": "@@ -13,8 +13,6 @@ mod rename;\n mod search_scope;\n \n use hir::Semantics;\n-use once_cell::unsync::Lazy;\n-use ra_db::SourceDatabaseExt;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n     RootDatabase,\n@@ -23,15 +21,16 @@ use ra_prof::profile;\n use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n-    match_ast, AstNode, SyntaxKind, SyntaxNode, TextRange, TextUnit, TokenAtOffset,\n+    AstNode, SyntaxKind, SyntaxNode, TextRange, TokenAtOffset,\n };\n-use test_utils::tested_by;\n \n use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeInfo};\n \n pub(crate) use self::rename::rename;\n \n-pub use ra_ide_db::search::{Reference, ReferenceAccess, ReferenceKind, SearchScope};\n+pub use ra_ide_db::search::{\n+    find_refs_to_def, Reference, ReferenceAccess, ReferenceKind, SearchScope,\n+};\n \n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n@@ -122,84 +121,6 @@ pub(crate) fn find_all_refs(\n     Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }))\n }\n \n-pub(crate) fn find_refs_to_def(\n-    db: &RootDatabase,\n-    def: &Definition,\n-    search_scope: Option<SearchScope>,\n-) -> Vec<Reference> {\n-    let _p = profile(\"find_refs_to_def\");\n-\n-    let search_scope = {\n-        let base = SearchScope::for_def(&def, db);\n-        match search_scope {\n-            None => base,\n-            Some(scope) => base.intersection(&scope),\n-        }\n-    };\n-\n-    let name = match def.name(db) {\n-        None => return Vec::new(),\n-        Some(it) => it.to_string(),\n-    };\n-\n-    let pat = name.as_str();\n-    let mut refs = vec![];\n-\n-    for (file_id, search_range) in search_scope {\n-        let text = db.file_text(file_id);\n-        let search_range =\n-            search_range.unwrap_or(TextRange::offset_len(0.into(), TextUnit::of_str(&text)));\n-\n-        let sema = Semantics::new(db);\n-        let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n-\n-        for (idx, _) in text.match_indices(pat) {\n-            let offset = TextUnit::from_usize(idx);\n-            if !search_range.contains_inclusive(offset) {\n-                tested_by!(search_filters_by_range);\n-                continue;\n-            }\n-\n-            let name_ref =\n-                if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&tree, offset) {\n-                    name_ref\n-                } else {\n-                    // Handle macro token cases\n-                    let token = match tree.token_at_offset(offset) {\n-                        TokenAtOffset::None => continue,\n-                        TokenAtOffset::Single(t) => t,\n-                        TokenAtOffset::Between(_, t) => t,\n-                    };\n-                    let expanded = sema.descend_into_macros(token);\n-                    match ast::NameRef::cast(expanded.parent()) {\n-                        Some(name_ref) => name_ref,\n-                        _ => continue,\n-                    }\n-                };\n-\n-            if let Some(d) = classify_name_ref(&sema, &name_ref) {\n-                let d = d.definition();\n-                if &d == def {\n-                    let kind =\n-                        if is_record_lit_name_ref(&name_ref) || is_call_expr_name_ref(&name_ref) {\n-                            ReferenceKind::StructLiteral\n-                        } else {\n-                            ReferenceKind::Other\n-                        };\n-\n-                    let file_range = sema.original_range(name_ref.syntax());\n-                    refs.push(Reference {\n-                        file_range,\n-                        kind,\n-                        access: reference_access(&d, &name_ref),\n-                    });\n-                }\n-            }\n-        }\n-    }\n-    refs\n-}\n-\n fn find_name(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n@@ -236,48 +157,6 @@ fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Optio\n     None\n }\n \n-fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n-    // Only Locals and Fields have accesses for now.\n-    match def {\n-        Definition::Local(_) | Definition::StructField(_) => {}\n-        _ => return None,\n-    };\n-\n-    let mode = name_ref.syntax().ancestors().find_map(|node| {\n-        match_ast! {\n-            match (node) {\n-                ast::BinExpr(expr) => {\n-                    if expr.op_kind()?.is_assignment() {\n-                        // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n-                        // FIXME: This is not terribly accurate.\n-                        if let Some(lhs) = expr.lhs() {\n-                            if lhs.syntax().text_range().end() == name_ref.syntax().text_range().end() {\n-                                return Some(ReferenceAccess::Write);\n-                            }\n-                        }\n-                    }\n-                    Some(ReferenceAccess::Read)\n-                },\n-                _ => {None}\n-            }\n-        }\n-    });\n-\n-    // Default Locals and Fields to read\n-    mode.or(Some(ReferenceAccess::Read))\n-}\n-\n-fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::RecordLit::cast)\n-        .and_then(|l| l.path())\n-        .and_then(|p| p.segment())\n-        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n-        .unwrap_or(false)\n-}\n-\n fn get_struct_def_name_for_struc_litetal_search(\n     syntax: &SyntaxNode,\n     position: FilePosition,\n@@ -296,20 +175,6 @@ fn get_struct_def_name_for_struc_litetal_search(\n     None\n }\n \n-fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::CallExpr::cast)\n-        .and_then(|c| match c.expr()? {\n-            ast::Expr::PathExpr(p) => {\n-                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n-            }\n-            _ => None,\n-        })\n-        .unwrap_or(false)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test_utils::covers;"}, {"sha": "52f0f23df50c8b3d61f25653046f0dae8d21220e", "filename": "crates/ra_ide_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/crates%2Fra_ide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/crates%2Fra_ide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2FCargo.toml?ref=f79719b8ae4d1929acaa940802a1e293f7dd7a6b", "patch": "@@ -16,6 +16,7 @@ rayon = \"1.3.0\"\n fst = { version = \"0.3.5\", default-features = false }\n rustc-hash = \"1.1.0\"\n superslice = \"1.0.0\"\n+once_cell = \"1.3.1\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "efd43f4c150589a9663e6a6cf5beb08afff85980", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 146, "deletions": 3, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79719b8ae4d1929acaa940802a1e293f7dd7a6b/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=f79719b8ae4d1929acaa940802a1e293f7dd7a6b", "patch": "@@ -4,13 +4,19 @@\n //! e.g. for things like local variables.\n use std::mem;\n \n-use hir::{DefWithBody, HasSource, ModuleSource};\n+use hir::{DefWithBody, HasSource, ModuleSource, Semantics};\n+use once_cell::unsync::Lazy;\n use ra_db::{FileId, FileRange, SourceDatabaseExt};\n use ra_prof::profile;\n-use ra_syntax::{AstNode, TextRange};\n+use ra_syntax::{\n+    algo::find_node_at_offset, ast, match_ast, AstNode, TextRange, TextUnit, TokenAtOffset,\n+};\n use rustc_hash::FxHashMap;\n \n-use crate::{defs::Definition, RootDatabase};\n+use crate::{\n+    defs::{classify_name_ref, Definition},\n+    RootDatabase,\n+};\n \n #[derive(Debug, Clone)]\n pub struct Reference {\n@@ -164,3 +170,140 @@ impl IntoIterator for SearchScope {\n         self.entries.into_iter()\n     }\n }\n+\n+pub fn find_refs_to_def(\n+    db: &RootDatabase,\n+    def: &Definition,\n+    search_scope: Option<SearchScope>,\n+) -> Vec<Reference> {\n+    let _p = profile(\"find_refs_to_def\");\n+\n+    let search_scope = {\n+        let base = SearchScope::for_def(&def, db);\n+        match search_scope {\n+            None => base,\n+            Some(scope) => base.intersection(&scope),\n+        }\n+    };\n+\n+    let name = match def.name(db) {\n+        None => return Vec::new(),\n+        Some(it) => it.to_string(),\n+    };\n+\n+    let pat = name.as_str();\n+    let mut refs = vec![];\n+\n+    for (file_id, search_range) in search_scope {\n+        let text = db.file_text(file_id);\n+        let search_range =\n+            search_range.unwrap_or(TextRange::offset_len(0.into(), TextUnit::of_str(&text)));\n+\n+        let sema = Semantics::new(db);\n+        let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n+\n+        for (idx, _) in text.match_indices(pat) {\n+            let offset = TextUnit::from_usize(idx);\n+            if !search_range.contains_inclusive(offset) {\n+                // tested_by!(search_filters_by_range);\n+                continue;\n+            }\n+\n+            let name_ref =\n+                if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&tree, offset) {\n+                    name_ref\n+                } else {\n+                    // Handle macro token cases\n+                    let token = match tree.token_at_offset(offset) {\n+                        TokenAtOffset::None => continue,\n+                        TokenAtOffset::Single(t) => t,\n+                        TokenAtOffset::Between(_, t) => t,\n+                    };\n+                    let expanded = sema.descend_into_macros(token);\n+                    match ast::NameRef::cast(expanded.parent()) {\n+                        Some(name_ref) => name_ref,\n+                        _ => continue,\n+                    }\n+                };\n+\n+            // FIXME: reuse sb\n+            // See https://github.com/rust-lang/rust/pull/68198#issuecomment-574269098\n+\n+            if let Some(d) = classify_name_ref(&sema, &name_ref) {\n+                let d = d.definition();\n+                if &d == def {\n+                    let kind =\n+                        if is_record_lit_name_ref(&name_ref) || is_call_expr_name_ref(&name_ref) {\n+                            ReferenceKind::StructLiteral\n+                        } else {\n+                            ReferenceKind::Other\n+                        };\n+\n+                    let file_range = sema.original_range(name_ref.syntax());\n+                    refs.push(Reference {\n+                        file_range,\n+                        kind,\n+                        access: reference_access(&d, &name_ref),\n+                    });\n+                }\n+            }\n+        }\n+    }\n+    refs\n+}\n+\n+fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n+    // Only Locals and Fields have accesses for now.\n+    match def {\n+        Definition::Local(_) | Definition::StructField(_) => {}\n+        _ => return None,\n+    };\n+\n+    let mode = name_ref.syntax().ancestors().find_map(|node| {\n+        match_ast! {\n+            match (node) {\n+                ast::BinExpr(expr) => {\n+                    if expr.op_kind()?.is_assignment() {\n+                        // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n+                        // FIXME: This is not terribly accurate.\n+                        if let Some(lhs) = expr.lhs() {\n+                            if lhs.syntax().text_range().end() == name_ref.syntax().text_range().end() {\n+                                return Some(ReferenceAccess::Write);\n+                            }\n+                        }\n+                    }\n+                    Some(ReferenceAccess::Read)\n+                },\n+                _ => {None}\n+            }\n+        }\n+    });\n+\n+    // Default Locals and Fields to read\n+    mode.or(Some(ReferenceAccess::Read))\n+}\n+\n+fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::CallExpr::cast)\n+        .and_then(|c| match c.expr()? {\n+            ast::Expr::PathExpr(p) => {\n+                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or(false)\n+}\n+\n+fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::RecordLit::cast)\n+        .and_then(|l| l.path())\n+        .and_then(|p| p.segment())\n+        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n+        .unwrap_or(false)\n+}"}]}