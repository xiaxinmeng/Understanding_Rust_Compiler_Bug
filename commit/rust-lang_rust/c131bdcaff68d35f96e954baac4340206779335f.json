{"sha": "c131bdcaff68d35f96e954baac4340206779335f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMzFiZGNhZmY2OGQzNWY5NmU5NTRiYWFjNDM0MDIwNjc3OTMzNWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-06T22:24:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-06T22:24:07Z"}, "message": "Auto merge of #50699 - Zoxc:blocking-queries, r=mw\n\nBlocking Rayon queries\n\nr? @michaelwoerister", "tree": {"sha": "86ef6439322763109ce503ca30d0c71b23897d7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86ef6439322763109ce503ca30d0c71b23897d7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c131bdcaff68d35f96e954baac4340206779335f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c131bdcaff68d35f96e954baac4340206779335f", "html_url": "https://github.com/rust-lang/rust/commit/c131bdcaff68d35f96e954baac4340206779335f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c131bdcaff68d35f96e954baac4340206779335f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19d0b539aa295468a3fde57a02413244f03ab6f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/19d0b539aa295468a3fde57a02413244f03ab6f6", "html_url": "https://github.com/rust-lang/rust/commit/19d0b539aa295468a3fde57a02413244f03ab6f6"}, {"sha": "f273f285b887e84471eaae5d841e125eec197186", "url": "https://api.github.com/repos/rust-lang/rust/commits/f273f285b887e84471eaae5d841e125eec197186", "html_url": "https://github.com/rust-lang/rust/commit/f273f285b887e84471eaae5d841e125eec197186"}], "stats": {"total": 666, "additions": 617, "deletions": 49}, "files": [{"sha": "ed6f51093a757bce0b351544c814c7d796c7164a", "filename": "src/Cargo.lock", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -1786,12 +1786,16 @@ dependencies = [\n  \"jobserver 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"polonius-engine 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n+ \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n+ \"scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -1828,7 +1832,7 @@ dependencies = [\n  \"rustc-ap-rustc_cratesio_shim 147.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-serialize 147.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1911,16 +1915,16 @@ dependencies = [\n \n [[package]]\n name = \"rustc-rayon\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon-core 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-rayon-core\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2044,8 +2048,8 @@ dependencies = [\n  \"parking_lot 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon-core 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n  \"serialize 0.0.0\",\n  \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2061,7 +2065,7 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n@@ -3215,8 +3219,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-ap-syntax_pos 147.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fb707a229093791dc3fc35aca61d9bf0e3708f23da4536683527857bc624b061\"\n \"checksum rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11fb43a206a04116ffd7cfcf9bcb941f8eb6cc7ff667272246b0a1c74259a3cb\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n-\"checksum rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1aa5cd8c3a706edb19b6ec6aa7b056bdc635b6e99c5cf7014f9af9d92f15e99\"\n-\"checksum rustc-rayon-core 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d69983f8613a9c3ba1a3bbf5e8bdf2fd5c42317b1d8dd8623ca8030173bf8a6b\"\n+\"checksum rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c6d5a683c6ba4ed37959097e88d71c9e8e26659a3cb5be8b389078e7ad45306\"\n+\"checksum rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40f06724db71e18d68b3b946fdf890ca8c921d9edccc1404fdfdb537b0d12649\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \"checksum rustc_version 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a54aa04a10c68c1c4eacb4337fd883b435997ede17a9385784b990777686b09a\"\n \"checksum rustfix 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9da3cf9b79dc889a2c9879643f26d7a53e37e9361c7566b7d2787d5ace0d8396\""}, {"sha": "0ff4dc2eace816f45e55c43f1a380339108ba511", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -15,9 +15,12 @@ fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n lazy_static = \"1.0.0\"\n+scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n polonius-engine = \"0.5.0\"\n proc_macro = { path = \"../libproc_macro\" }\n+rustc-rayon = \"0.1.1\"\n+rustc-rayon-core = \"0.1.1\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n@@ -26,6 +29,7 @@ serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n backtrace = \"0.3.3\"\n+parking_lot = \"0.5.5\"\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n chalk-engine = { version = \"0.6.0\", default-features=false }\n "}, {"sha": "a006856f58b7dac16624f573b1b253a06b9380cf", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -67,6 +67,7 @@\n #![feature(unboxed_closures)]\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n+#![feature(vec_remove_item)]\n #![feature(catch_expr)]\n #![feature(integer_atomics)]\n #![feature(test)]\n@@ -83,13 +84,17 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n #[macro_use] extern crate lazy_static;\n+#[macro_use] extern crate scoped_tls;\n #[cfg(windows)]\n extern crate libc;\n extern crate polonius_engine;\n extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n extern crate serialize;\n+extern crate parking_lot;\n extern crate rustc_errors as errors;\n+extern crate rustc_rayon as rayon;\n+extern crate rustc_rayon_core as rayon_core;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;"}, {"sha": "e66ad24231094967b43876bf1fa448ae996d8c30", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -1699,16 +1699,21 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<CanonicalVarInfo> {\n pub mod tls {\n     use super::{GlobalCtxt, TyCtxt};\n \n-    use std::cell::Cell;\n     use std::fmt;\n     use std::mem;\n     use syntax_pos;\n     use ty::maps;\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n     use rustc_data_structures::OnDrop;\n-    use rustc_data_structures::sync::{self, Lrc};\n+    use rustc_data_structures::sync::{self, Lrc, Lock};\n     use dep_graph::OpenTask;\n \n+    #[cfg(not(parallel_queries))]\n+    use std::cell::Cell;\n+\n+    #[cfg(parallel_queries)]\n+    use rayon_core;\n+\n     /// This is the implicit state of rustc. It contains the current\n     /// TyCtxt and query. It is updated when creating a local interner or\n     /// executing a new query. Whenever there's a TyCtxt value available\n@@ -1732,16 +1737,38 @@ pub mod tls {\n         pub task: &'a OpenTask,\n     }\n \n-    // A thread local value which stores a pointer to the current ImplicitCtxt\n+    /// Sets Rayon's thread local variable which is preserved for Rayon jobs\n+    /// to `value` during the call to `f`. It is restored to its previous value after.\n+    /// This is used to set the pointer to the new ImplicitCtxt.\n+    #[cfg(parallel_queries)]\n+    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n+        rayon_core::tlv::with(value, f)\n+    }\n+\n+    /// Gets Rayon's thread local variable which is preserved for Rayon jobs.\n+    /// This is used to get the pointer to the current ImplicitCtxt.\n+    #[cfg(parallel_queries)]\n+    fn get_tlv() -> usize {\n+        rayon_core::tlv::get()\n+    }\n+\n+    /// A thread local variable which stores a pointer to the current ImplicitCtxt\n+    #[cfg(not(parallel_queries))]\n     thread_local!(static TLV: Cell<usize> = Cell::new(0));\n \n+    /// Sets TLV to `value` during the call to `f`.\n+    /// It is restored to its previous value after.\n+    /// This is used to set the pointer to the new ImplicitCtxt.\n+    #[cfg(not(parallel_queries))]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         let old = get_tlv();\n         let _reset = OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n         TLV.with(|tlv| tlv.set(value));\n         f()\n     }\n \n+    /// This is used to get the pointer to the current ImplicitCtxt.\n+    #[cfg(not(parallel_queries))]\n     fn get_tlv() -> usize {\n         TLV.with(|tlv| tlv.get())\n     }\n@@ -1810,6 +1837,15 @@ pub mod tls {\n         where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n     {\n         with_thread_locals(|| {\n+            // Update GCX_PTR to indicate there's a GlobalCtxt available\n+            GCX_PTR.with(|lock| {\n+                *lock.lock() = gcx as *const _ as usize;\n+            });\n+            // Set GCX_PTR back to 0 when we exit\n+            let _on_drop = OnDrop(move || {\n+                GCX_PTR.with(|lock| *lock.lock() = 0);\n+            });\n+\n             let tcx = TyCtxt {\n                 gcx,\n                 interners: &gcx.global_interners,\n@@ -1826,6 +1862,32 @@ pub mod tls {\n         })\n     }\n \n+    /// Stores a pointer to the GlobalCtxt if one is available.\n+    /// This is used to access the GlobalCtxt in the deadlock handler\n+    /// given to Rayon.\n+    scoped_thread_local!(pub static GCX_PTR: Lock<usize>);\n+\n+    /// Creates a TyCtxt and ImplicitCtxt based on the GCX_PTR thread local.\n+    /// This is used in the deadlock handler.\n+    pub unsafe fn with_global<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        let gcx = GCX_PTR.with(|lock| *lock.lock());\n+        assert!(gcx != 0);\n+        let gcx = &*(gcx as *const GlobalCtxt<'_>);\n+        let tcx = TyCtxt {\n+            gcx,\n+            interners: &gcx.global_interners,\n+        };\n+        let icx = ImplicitCtxt {\n+            query: None,\n+            tcx,\n+            layout_depth: 0,\n+            task: &OpenTask::Ignore,\n+        };\n+        enter_context(&icx, |_| f(tcx))\n+    }\n+\n     /// Allows access to the current ImplicitCtxt in a closure if one is available\n     pub fn with_context_opt<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'gcx, 'tcx>>) -> R"}, {"sha": "3da73d47a0bf5d9a7cd4d6d7b3513d653d4c5f98", "filename": "src/librustc/ty/maps/job.rs", "status": "modified", "additions": 430, "deletions": 2, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -8,13 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::sync::{Lock, Lrc};\n+#![allow(warnings)]\n+\n+use std::mem;\n+use rustc_data_structures::sync::{Lock, LockGuard, Lrc, Weak};\n+use rustc_data_structures::OnDrop;\n use syntax_pos::Span;\n use ty::tls;\n use ty::maps::Query;\n use ty::maps::plumbing::CycleError;\n use ty::context::TyCtxt;\n use errors::Diagnostic;\n+use std::process;\n+use std::fmt;\n+use std::collections::HashSet;\n+#[cfg(parallel_queries)]\n+use {\n+    rayon_core,\n+    parking_lot::{Mutex, Condvar},\n+    std::sync::atomic::Ordering,\n+    std::thread,\n+    std::iter,\n+    std::iter::FromIterator,\n+    syntax_pos::DUMMY_SP,\n+    rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher, HashStable},\n+};\n \n /// Indicates the state of a query for a given key in a query map\n pub(super) enum QueryResult<'tcx> {\n@@ -42,6 +60,10 @@ pub struct QueryJob<'tcx> {\n \n     /// Diagnostic messages which are emitted while the query executes\n     pub diagnostics: Lock<Vec<Diagnostic>>,\n+\n+    /// The latch which is used to wait on this job\n+    #[cfg(parallel_queries)]\n+    latch: QueryLatch<'tcx>,\n }\n \n impl<'tcx> QueryJob<'tcx> {\n@@ -51,6 +73,8 @@ impl<'tcx> QueryJob<'tcx> {\n             diagnostics: Lock::new(Vec::new()),\n             info,\n             parent,\n+            #[cfg(parallel_queries)]\n+            latch: QueryLatch::new(),\n         }\n     }\n \n@@ -62,6 +86,36 @@ impl<'tcx> QueryJob<'tcx> {\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n+    ) -> Result<(), CycleError<'tcx>> {\n+        #[cfg(not(parallel_queries))]\n+        {\n+            self.find_cycle_in_stack(tcx, span)\n+        }\n+\n+        #[cfg(parallel_queries)]\n+        {\n+            tls::with_related_context(tcx, move |icx| {\n+                let mut waiter = Lrc::new(QueryWaiter {\n+                    query: icx.query.clone(),\n+                    span,\n+                    cycle: Lock::new(None),\n+                    condvar: Condvar::new(),\n+                });\n+                self.latch.await(&waiter);\n+\n+                match Lrc::get_mut(&mut waiter).unwrap().cycle.get_mut().take() {\n+                    None => Ok(()),\n+                    Some(cycle) => Err(cycle)\n+                }\n+            })\n+        }\n+    }\n+\n+    #[cfg(not(parallel_queries))]\n+    fn find_cycle_in_stack<'lcx>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        span: Span,\n     ) -> Result<(), CycleError<'tcx>> {\n         // Get the current executing query (waiter) and find the waitee amongst its parents\n         let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n@@ -93,5 +147,379 @@ impl<'tcx> QueryJob<'tcx> {\n     ///\n     /// This does nothing for single threaded rustc,\n     /// as there are no concurrent jobs which could be waiting on us\n-    pub fn signal_complete(&self) {}\n+    pub fn signal_complete(&self) {\n+        #[cfg(parallel_queries)]\n+        self.latch.set();\n+    }\n+\n+    fn as_ptr(&self) -> *const QueryJob<'tcx> {\n+        self as *const _\n+    }\n+}\n+\n+#[cfg(parallel_queries)]\n+struct QueryWaiter<'tcx> {\n+    query: Option<Lrc<QueryJob<'tcx>>>,\n+    condvar: Condvar,\n+    span: Span,\n+    cycle: Lock<Option<CycleError<'tcx>>>,\n+}\n+\n+#[cfg(parallel_queries)]\n+impl<'tcx> QueryWaiter<'tcx> {\n+    fn notify(&self, registry: &rayon_core::Registry) {\n+        rayon_core::mark_unblocked(registry);\n+        self.condvar.notify_one();\n+    }\n+}\n+\n+#[cfg(parallel_queries)]\n+struct QueryLatchInfo<'tcx> {\n+    complete: bool,\n+    waiters: Vec<Lrc<QueryWaiter<'tcx>>>,\n+}\n+\n+#[cfg(parallel_queries)]\n+struct QueryLatch<'tcx> {\n+    info: Mutex<QueryLatchInfo<'tcx>>,\n+}\n+\n+#[cfg(parallel_queries)]\n+impl<'tcx> QueryLatch<'tcx> {\n+    fn new() -> Self {\n+        QueryLatch {\n+            info: Mutex::new(QueryLatchInfo {\n+                complete: false,\n+                waiters: Vec::new(),\n+            }),\n+        }\n+    }\n+\n+    /// Awaits the caller on this latch by blocking the current thread.\n+    fn await(&self, waiter: &Lrc<QueryWaiter<'tcx>>) {\n+        let mut info = self.info.lock();\n+        if !info.complete {\n+            // We push the waiter on to the `waiters` list. It can be accessed inside\n+            // the `wait` call below, by 1) the `set` method or 2) by deadlock detection.\n+            // Both of these will remove it from the `waiters` list before resuming\n+            // this thread.\n+            info.waiters.push(waiter.clone());\n+\n+            // If this detects a deadlock and the deadlock handler wants to resume this thread\n+            // we have to be in the `wait` call. This is ensured by the deadlock handler\n+            // getting the self.info lock.\n+            rayon_core::mark_blocked();\n+            waiter.condvar.wait(&mut info);\n+        }\n+    }\n+\n+    /// Sets the latch and resumes all waiters on it\n+    fn set(&self) {\n+        let mut info = self.info.lock();\n+        debug_assert!(!info.complete);\n+        info.complete = true;\n+        let registry = rayon_core::Registry::current();\n+        for waiter in info.waiters.drain(..) {\n+            waiter.notify(&registry);\n+        }\n+    }\n+\n+    /// Remove a single waiter from the list of waiters.\n+    /// This is used to break query cycles.\n+    fn extract_waiter(\n+        &self,\n+        waiter: usize,\n+    ) -> Lrc<QueryWaiter<'tcx>> {\n+        let mut info = self.info.lock();\n+        debug_assert!(!info.complete);\n+        // Remove the waiter from the list of waiters\n+        info.waiters.remove(waiter)\n+    }\n+}\n+\n+/// A resumable waiter of a query. The usize is the index into waiters in the query's latch\n+#[cfg(parallel_queries)]\n+type Waiter<'tcx> = (Lrc<QueryJob<'tcx>>, usize);\n+\n+/// Visits all the non-resumable and resumable waiters of a query.\n+/// Only waiters in a query are visited.\n+/// `visit` is called for every waiter and is passed a query waiting on `query_ref`\n+/// and a span indicating the reason the query waited on `query_ref`.\n+/// If `visit` returns Some, this function returns.\n+/// For visits of non-resumable waiters it returns the return value of `visit`.\n+/// For visits of resumable waiters it returns Some(Some(Waiter)) which has the\n+/// required information to resume the waiter.\n+/// If all `visit` calls returns None, this function also returns None.\n+#[cfg(parallel_queries)]\n+fn visit_waiters<'tcx, F>(query: Lrc<QueryJob<'tcx>>, mut visit: F) -> Option<Option<Waiter<'tcx>>>\n+where\n+    F: FnMut(Span, Lrc<QueryJob<'tcx>>) -> Option<Option<Waiter<'tcx>>>\n+{\n+    // Visit the parent query which is a non-resumable waiter since it's on the same stack\n+    if let Some(ref parent) = query.parent {\n+        if let Some(cycle) = visit(query.info.span, parent.clone()) {\n+            return Some(cycle);\n+        }\n+    }\n+\n+    // Visit the explict waiters which use condvars and are resumable\n+    for (i, waiter) in query.latch.info.lock().waiters.iter().enumerate() {\n+        if let Some(ref waiter_query) = waiter.query {\n+            if visit(waiter.span, waiter_query.clone()).is_some() {\n+                // Return a value which indicates that this waiter can be resumed\n+                return Some(Some((query.clone(), i)));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+/// Look for query cycles by doing a depth first search starting at `query`.\n+/// `span` is the reason for the `query` to execute. This is initially DUMMY_SP.\n+/// If a cycle is detected, this initial value is replaced with the span causing\n+/// the cycle.\n+#[cfg(parallel_queries)]\n+fn cycle_check<'tcx>(query: Lrc<QueryJob<'tcx>>,\n+                     span: Span,\n+                     stack: &mut Vec<(Span, Lrc<QueryJob<'tcx>>)>,\n+                     visited: &mut HashSet<*const QueryJob<'tcx>>\n+) -> Option<Option<Waiter<'tcx>>> {\n+    if visited.contains(&query.as_ptr()) {\n+        return if let Some(p) = stack.iter().position(|q| q.1.as_ptr() == query.as_ptr()) {\n+            // We detected a query cycle, fix up the initial span and return Some\n+\n+            // Remove previous stack entries\n+            stack.splice(0..p, iter::empty());\n+            // Replace the span for the first query with the cycle cause\n+            stack[0].0 = span;\n+            Some(None)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // Mark this query is visited and add it to the stack\n+    visited.insert(query.as_ptr());\n+    stack.push((span, query.clone()));\n+\n+    // Visit all the waiters\n+    let r = visit_waiters(query, |span, successor| {\n+        cycle_check(successor, span, stack, visited)\n+    });\n+\n+    // Remove the entry in our stack if we didn't find a cycle\n+    if r.is_none() {\n+        stack.pop();\n+    }\n+\n+    r\n+}\n+\n+/// Finds out if there's a path to the compiler root (aka. code which isn't in a query)\n+/// from `query` without going through any of the queries in `visited`.\n+/// This is achieved with a depth first search.\n+#[cfg(parallel_queries)]\n+fn connected_to_root<'tcx>(\n+    query: Lrc<QueryJob<'tcx>>,\n+    visited: &mut HashSet<*const QueryJob<'tcx>>\n+) -> bool {\n+    // We already visited this or we're deliberately ignoring it\n+    if visited.contains(&query.as_ptr()) {\n+        return false;\n+    }\n+\n+    // This query is connected to the root (it has no query parent), return true\n+    if query.parent.is_none() {\n+        return true;\n+    }\n+\n+    visited.insert(query.as_ptr());\n+\n+    let mut connected = false;\n+\n+    visit_waiters(query, |_, successor| {\n+        if connected_to_root(successor, visited) {\n+            Some(None)\n+        } else {\n+            None\n+        }\n+    }).is_some()\n+}\n+\n+/// Looks for query cycles starting from the last query in `jobs`.\n+/// If a cycle is found, all queries in the cycle is removed from `jobs` and\n+/// the function return true.\n+/// If a cycle was not found, the starting query is removed from `jobs` and\n+/// the function returns false.\n+#[cfg(parallel_queries)]\n+fn remove_cycle<'tcx>(\n+    jobs: &mut Vec<Lrc<QueryJob<'tcx>>>,\n+    wakelist: &mut Vec<Lrc<QueryWaiter<'tcx>>>,\n+    tcx: TyCtxt<'_, 'tcx, '_>\n+) -> bool {\n+    let mut visited = HashSet::new();\n+    let mut stack = Vec::new();\n+    // Look for a cycle starting with the last query in `jobs`\n+    if let Some(waiter) = cycle_check(jobs.pop().unwrap(),\n+                                      DUMMY_SP,\n+                                      &mut stack,\n+                                      &mut visited) {\n+        // Reverse the stack so earlier entries require later entries\n+        stack.reverse();\n+\n+        // Extract the spans and queries into separate arrays\n+        let mut spans: Vec<_> = stack.iter().map(|e| e.0).collect();\n+        let queries = stack.into_iter().map(|e| e.1);\n+\n+        // Shift the spans so that queries are matched with the span for their waitee\n+        let last = spans.pop().unwrap();\n+        spans.insert(0, last);\n+\n+        // Zip them back together\n+        let mut stack: Vec<_> = spans.into_iter().zip(queries).collect();\n+\n+        // Remove the queries in our cycle from the list of jobs to look at\n+        for r in &stack {\n+            if let Some(pos) = jobs.iter().position(|j| j.as_ptr() == r.1.as_ptr()) {\n+                jobs.remove(pos);\n+            }\n+        }\n+\n+        // Find the queries in the cycle which are\n+        // connected to queries outside the cycle\n+        let entry_points: Vec<Lrc<QueryJob<'tcx>>> = stack.iter().filter_map(|query| {\n+            // Mark all the other queries in the cycle as already visited\n+            let mut visited = HashSet::from_iter(stack.iter().filter_map(|q| {\n+                if q.1.as_ptr() != query.1.as_ptr() {\n+                    Some(q.1.as_ptr())\n+                } else {\n+                    None\n+                }\n+            }));\n+\n+            if connected_to_root(query.1.clone(), &mut visited) {\n+                Some(query.1.clone())\n+            } else {\n+                None\n+            }\n+        }).collect();\n+\n+        // Deterministically pick an entry point\n+        // FIXME: Sort this instead\n+        let mut hcx = tcx.create_stable_hashing_context();\n+        let entry_point = entry_points.iter().min_by_key(|q| {\n+            let mut stable_hasher = StableHasher::<u64>::new();\n+            q.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n+            stable_hasher.finish()\n+        }).unwrap().as_ptr();\n+\n+        // Shift the stack until our entry point is first\n+        while stack[0].1.as_ptr() != entry_point {\n+            let last = stack.pop().unwrap();\n+            stack.insert(0, last);\n+        }\n+\n+        // Create the cycle error\n+        let mut error = CycleError {\n+            usage: None,\n+            cycle: stack.iter().map(|&(s, ref q)| QueryInfo {\n+                span: s,\n+                query: q.info.query.clone(),\n+            } ).collect(),\n+        };\n+\n+        // We unwrap `waiter` here since there must always be one\n+        // edge which is resumeable / waited using a query latch\n+        let (waitee_query, waiter_idx) = waiter.unwrap();\n+\n+        // Extract the waiter we want to resume\n+        let waiter = waitee_query.latch.extract_waiter(waiter_idx);\n+\n+        // Set the cycle error so it will be picked up when resumed\n+        *waiter.cycle.lock() = Some(error);\n+\n+        // Put the waiter on the list of things to resume\n+        wakelist.push(waiter);\n+\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Creates a new thread and forwards information in thread locals to it.\n+/// The new thread runs the deadlock handler.\n+/// Must only be called when a deadlock is about to happen.\n+#[cfg(parallel_queries)]\n+pub unsafe fn handle_deadlock() {\n+    use syntax;\n+    use syntax_pos;\n+\n+    let registry = rayon_core::Registry::current();\n+\n+    let gcx_ptr = tls::GCX_PTR.with(|gcx_ptr| {\n+        gcx_ptr as *const _\n+    });\n+    let gcx_ptr = &*gcx_ptr;\n+\n+    let syntax_globals = syntax::GLOBALS.with(|syntax_globals| {\n+        syntax_globals as *const _\n+    });\n+    let syntax_globals = &*syntax_globals;\n+\n+    let syntax_pos_globals = syntax_pos::GLOBALS.with(|syntax_pos_globals| {\n+        syntax_pos_globals as *const _\n+    });\n+    let syntax_pos_globals = &*syntax_pos_globals;\n+    thread::spawn(move || {\n+        tls::GCX_PTR.set(gcx_ptr, || {\n+            syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n+                syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n+                    tls::with_thread_locals(|| {\n+                        tls::with_global(|tcx| deadlock(tcx, &registry))\n+                    })\n+                })\n+            })\n+        })\n+    });\n+}\n+\n+/// Detects query cycles by using depth first search over all active query jobs.\n+/// If a query cycle is found it will break the cycle by finding an edge which\n+/// uses a query latch and then resuming that waiter.\n+/// There may be multiple cycles involved in a deadlock, so this searches\n+/// all active queries for cycles before finally resuming all the waiters at once.\n+#[cfg(parallel_queries)]\n+fn deadlock(tcx: TyCtxt<'_, '_, '_>, registry: &rayon_core::Registry) {\n+    let on_panic = OnDrop(|| {\n+        eprintln!(\"deadlock handler panicked, aborting process\");\n+        process::abort();\n+    });\n+\n+    let mut wakelist = Vec::new();\n+    let mut jobs: Vec<_> = tcx.maps.collect_active_jobs();\n+\n+    let mut found_cycle = false;\n+\n+    while jobs.len() > 0 {\n+        if remove_cycle(&mut jobs, &mut wakelist, tcx) {\n+            found_cycle = true;\n+        }\n+    }\n+\n+    // Check that a cycle was found. It is possible for a deadlock to occur without\n+    // a query cycle if a query which can be waited on uses Rayon to do multithreading\n+    // internally. Such a query (X) may be executing on 2 threads (A and B) and A may\n+    // wait using Rayon on B. Rayon may then switch to executing another query (Y)\n+    // which in turn will wait on X causing a deadlock. We have a false dependency from\n+    // X to Y due to Rayon waiting and a true dependency from Y to X. The algorithm here\n+    // only considers the true dependency and won't detect a cycle.\n+    assert!(found_cycle);\n+\n+    // FIXME: Ensure this won't cause a deadlock before we return\n+    for waiter in wakelist.into_iter() {\n+        waiter.notify(registry);\n+    }\n+\n+    on_panic.disable();\n }"}, {"sha": "b50b43aace760d2797f3821fa54321358eda0bbb", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -63,10 +63,12 @@ use syntax::symbol::Symbol;\n #[macro_use]\n mod plumbing;\n use self::plumbing::*;\n-pub use self::plumbing::force_from_dep_node;\n+pub use self::plumbing::{force_from_dep_node, CycleError};\n \n mod job;\n pub use self::job::{QueryJob, QueryInfo};\n+#[cfg(parallel_queries)]\n+pub use self::job::handle_deadlock;\n \n mod keys;\n pub use self::keys::Key;"}, {"sha": "13d2a13e5ddc519e3e8ac193f8dccca02221d362", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n }\n \n #[derive(Clone)]\n-pub(super) struct CycleError<'tcx> {\n+pub struct CycleError<'tcx> {\n     /// The query and related span which uses the cycle\n     pub(super) usage: Option<(Span, Query<'tcx>)>,\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n@@ -632,7 +632,15 @@ macro_rules! define_maps {\n      $($(#[$attr:meta])*\n        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n+        use std::mem;\n+        use ty::maps::job::QueryResult;\n         use rustc_data_structures::sync::Lock;\n+        use {\n+            rustc_data_structures::stable_hasher::HashStable,\n+            rustc_data_structures::stable_hasher::StableHasherResult,\n+            rustc_data_structures::stable_hasher::StableHasher,\n+            ich::StableHashingContext\n+        };\n \n         define_map_struct! {\n             tcx: $tcx,\n@@ -647,10 +655,25 @@ macro_rules! define_maps {\n                     $($name: Lock::new(QueryMap::new())),*\n                 }\n             }\n+\n+            pub fn collect_active_jobs(&self) -> Vec<Lrc<QueryJob<$tcx>>> {\n+                let mut jobs = Vec::new();\n+\n+                // We use try_lock here since we are only called from the\n+                // deadlock handler, and this shouldn't be locked\n+                $(for v in self.$name.try_lock().unwrap().active.values() {\n+                    match *v {\n+                        QueryResult::Started(ref job) => jobs.push(job.clone()),\n+                        _ => (),\n+                    }\n+                })*\n+\n+                return jobs;\n+            }\n         }\n \n         #[allow(bad_style)]\n-        #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n         pub enum Query<$tcx> {\n             $($(#[$attr])* $name($K)),*\n         }\n@@ -692,6 +715,17 @@ macro_rules! define_maps {\n             }\n         }\n \n+        impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n+            fn hash_stable<W: StableHasherResult>(&self,\n+                                                hcx: &mut StableHashingContext<'a>,\n+                                                hasher: &mut StableHasher<W>) {\n+                mem::discriminant(self).hash_stable(hcx, hasher);\n+                match *self {\n+                    $(Query::$name(key) => key.hash_stable(hcx, hasher),)*\n+                }\n+            }\n+        }\n+\n         pub mod queries {\n             use std::marker::PhantomData;\n "}, {"sha": "fc5fe91c977d410057d189a3bd9ab425e9ed5b47", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -16,8 +16,8 @@ serialize = { path = \"../libserialize\" }\n cfg-if = \"0.1.2\"\n stable_deref_trait = \"1.0.0\"\n parking_lot_core = \"0.2.8\"\n-rustc-rayon = \"0.1.0\"\n-rustc-rayon-core = \"0.1.0\"\n+rustc-rayon = \"0.1.1\"\n+rustc-rayon-core = \"0.1.1\"\n rustc-hash = \"1.0.1\"\n \n [dependencies.parking_lot]"}, {"sha": "5844edf000a8b7837ea8a1d781fd63fa0677e667", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -80,6 +80,14 @@ pub mod sorted_map;\n \n pub struct OnDrop<F: Fn()>(pub F);\n \n+impl<F: Fn()> OnDrop<F> {\n+      /// Forgets the function which prevents it from running.\n+      /// Ensure that the function owns no memory, otherwise it will be leaked.\n+      pub fn disable(self) {\n+            std::mem::forget(self);\n+      }\n+}\n+\n impl<F: Fn()> Drop for OnDrop<F> {\n       fn drop(&mut self) {\n             (self.0)();"}, {"sha": "33f6eda2a8753696658b61c3951cb5682df09d03", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -519,6 +519,18 @@ impl<T> Lock<T> {\n         self.0.get_mut()\n     }\n \n+    #[cfg(parallel_queries)]\n+    #[inline(always)]\n+    pub fn try_lock(&self) -> Option<LockGuard<T>> {\n+        self.0.try_lock()\n+    }\n+\n+    #[cfg(not(parallel_queries))]\n+    #[inline(always)]\n+    pub fn try_lock(&self) -> Option<LockGuard<T>> {\n+        self.0.try_borrow_mut().ok()\n+    }\n+\n     #[cfg(parallel_queries)]\n     #[inline(always)]\n     pub fn lock(&self) -> LockGuard<T> {"}, {"sha": "5b75912c18f50dac3973bcff7df157ac66213bee", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -13,7 +13,7 @@ arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n env_logger = { version = \"0.5\", default-features = false }\n-rustc-rayon = \"0.1.0\"\n+rustc-rayon = \"0.1.1\"\n scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }"}, {"sha": "37f8bff964f5b1e880ae08684b17e67c133f9453", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -49,7 +49,7 @@ use std::fs;\n use std::io::{self, Write};\n use std::iter;\n use std::path::{Path, PathBuf};\n-use rustc_data_structures::sync::{self, Lrc};\n+use rustc_data_structures::sync::{self, Lrc, Lock};\n use std::sync::mpsc;\n use syntax::{self, ast, attr, diagnostics, visit};\n use syntax::ext::base::ExtCtxt;\n@@ -69,7 +69,9 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n     opts: config::Options,\n     f: F\n ) -> R {\n-    f(opts)\n+    ty::tls::GCX_PTR.set(&Lock::new(0), || {\n+        f(opts)\n+    })\n }\n \n #[cfg(parallel_queries)]\n@@ -81,8 +83,12 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n     use syntax_pos;\n     use rayon::{ThreadPoolBuilder, ThreadPool};\n \n-    let config = ThreadPoolBuilder::new().num_threads(Session::query_threads_from_opts(&opts))\n-                                         .stack_size(16 * 1024 * 1024);\n+    let gcx_ptr = &Lock::new(0);\n+\n+    let config = ThreadPoolBuilder::new()\n+        .num_threads(Session::query_threads_from_opts(&opts))\n+        .deadlock_handler(|| unsafe { ty::maps::handle_deadlock() })\n+        .stack_size(16 * 1024 * 1024);\n \n     let with_pool = move |pool: &ThreadPool| {\n         pool.install(move || f(opts))\n@@ -98,7 +104,9 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n                 syntax::GLOBALS.set(syntax_globals, || {\n                     syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n                         ty::tls::with_thread_locals(|| {\n-                            worker()\n+                            ty::tls::GCX_PTR.set(gcx_ptr, || {\n+                                worker()\n+                            })\n                         })\n                     })\n                 })"}, {"sha": "6f5e2affdbd3c3d33726a441350d7223ce98090e", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c131bdcaff68d35f96e954baac4340206779335f/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c131bdcaff68d35f96e954baac4340206779335f/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=c131bdcaff68d35f96e954baac4340206779335f", "patch": "@@ -19,9 +19,9 @@ extern crate rustc_codegen_utils;\n extern crate syntax;\n \n use rustc::session::{build_session, Session};\n-use rustc::session::config::{basic_options, Input,\n+use rustc::session::config::{basic_options, Input, Options,\n                              OutputType, OutputTypes};\n-use rustc_driver::driver::{compile_input, CompileController};\n+use rustc_driver::driver::{self, compile_input, CompileController};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n use syntax::codemap::FileName;\n@@ -52,14 +52,7 @@ fn main() {\n     compile(src.to_string(), tmpdir.join(\"out\"), sysroot.clone());\n }\n \n-fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>, Box<CodegenBackend>) {\n-    let mut opts = basic_options();\n-    opts.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n-    opts.maybe_sysroot = Some(sysroot);\n-    if let Ok(linker) = std::env::var(\"RUSTC_LINKER\") {\n-        opts.cg.linker = Some(linker.into());\n-    }\n-\n+fn basic_sess(opts: Options) -> (Session, Rc<CStore>, Box<CodegenBackend>) {\n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let sess = build_session(opts, None, descriptions);\n     let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n@@ -70,19 +63,27 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>, Box<CodegenBackend>) {\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     syntax::with_globals(|| {\n-        let (sess, cstore, codegen_backend) = basic_sess(sysroot);\n-        let control = CompileController::basic();\n-        let input = Input::Str { name: FileName::Anon, input: code };\n-        let _ = compile_input(\n-            codegen_backend,\n-            &sess,\n-            &cstore,\n-            &None,\n-            &input,\n-            &None,\n-            &Some(output),\n-            None,\n-            &control\n-        );\n+        let mut opts = basic_options();\n+        opts.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n+        opts.maybe_sysroot = Some(sysroot);\n+        if let Ok(linker) = std::env::var(\"RUSTC_LINKER\") {\n+            opts.cg.linker = Some(linker.into());\n+        }\n+        driver::spawn_thread_pool(opts, |opts| {\n+            let (sess, cstore, codegen_backend) = basic_sess(opts);\n+            let control = CompileController::basic();\n+            let input = Input::Str { name: FileName::Anon, input: code };\n+            let _ = compile_input(\n+                codegen_backend,\n+                &sess,\n+                &cstore,\n+                &None,\n+                &input,\n+                &None,\n+                &Some(output),\n+                None,\n+                &control\n+            );\n+        });\n     });\n }"}]}