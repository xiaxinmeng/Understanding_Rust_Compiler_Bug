{"sha": "68af077e8192a6a1b18778b97449ad695a4ecffb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YWYwNzdlODE5MmE2YTFiMTg3NzhiOTc0NDlhZDY5NWE0ZWNmZmI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-08T22:50:47Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-08T22:50:47Z"}, "message": "Implement binop= forms. Un-XFAIL bitwise.rs.", "tree": {"sha": "d5a7bb274b328239429bdb0c40cf1675f01c3d1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5a7bb274b328239429bdb0c40cf1675f01c3d1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68af077e8192a6a1b18778b97449ad695a4ecffb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68af077e8192a6a1b18778b97449ad695a4ecffb", "html_url": "https://github.com/rust-lang/rust/commit/68af077e8192a6a1b18778b97449ad695a4ecffb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68af077e8192a6a1b18778b97449ad695a4ecffb/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b971d6312e76fb592bf46bd7369837fa78e86893", "url": "https://api.github.com/repos/rust-lang/rust/commits/b971d6312e76fb592bf46bd7369837fa78e86893", "html_url": "https://github.com/rust-lang/rust/commit/b971d6312e76fb592bf46bd7369837fa78e86893"}], "stats": {"total": 241, "additions": 128, "deletions": 113}, "files": [{"sha": "cb950eb7b3bf7b863fd1cb48fb3c4a9a2f842481", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=68af077e8192a6a1b18778b97449ad695a4ecffb", "patch": "@@ -522,6 +522,7 @@ TEST_XFAILS_SELF := $(filter-out \\\n                         arith-0.rs \\\n                         arith-1.rs \\\n                         arith-2.rs \\\n+                        bitwise.rs \\\n                         bool-not.rs \\\n                         box.rs \\\n                         box-in-tup.rs \\"}, {"sha": "a37fd191c66edcc1d1e0b5355601f59cf0984a94", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=68af077e8192a6a1b18778b97449ad695a4ecffb", "patch": "@@ -145,6 +145,7 @@ tag expr_ {\n     expr_alt(@expr, vec[arm], ann);\n     expr_block(block, ann);\n     expr_assign(@expr /* TODO: @expr|is_lval */, @expr, ann);\n+    expr_assign_op(binop, @expr /* TODO: @expr|is_lval */, @expr, ann);\n     expr_field(@expr, ident, ann);\n     expr_index(@expr, @expr, ann);\n     expr_name(name, option.t[def], ann);"}, {"sha": "42a5e610e0558a1c14174dedb4957d2f05e07c72", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=68af077e8192a6a1b18778b97449ad695a4ecffb", "patch": "@@ -426,7 +426,7 @@ impure fn next_token(reader rdr) -> token.token {\n \n     impure fn binop(reader rdr, token.binop op) -> token.token {\n         rdr.bump();\n-        if (rdr.next() == '=') {\n+        if (rdr.curr() == '=') {\n             rdr.bump();\n             ret token.BINOPEQ(op);\n         } else {"}, {"sha": "d8d7ca4e9b18eecf85e4c96693d1dff622bf2698", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=68af077e8192a6a1b18778b97449ad695a4ecffb", "patch": "@@ -714,6 +714,26 @@ impure fn parse_assign_expr(parser p) -> @ast.expr {\n             ret @spanned(lo, rhs.span,\n                          ast.expr_assign(lhs, rhs, ast.ann_none));\n         }\n+        case (token.BINOPEQ(?op)) {\n+            p.bump();\n+            auto rhs = parse_expr(p);\n+            auto aop = ast.add;\n+            alt (op) {\n+                case (token.PLUS) { aop = ast.add; }\n+                case (token.MINUS) { aop = ast.sub; }\n+                case (token.STAR) { aop = ast.mul; }\n+                case (token.SLASH) { aop = ast.div; }\n+                case (token.PERCENT) { aop = ast.rem; }\n+                case (token.CARET) { aop = ast.bitxor; }\n+                case (token.AND) { aop = ast.bitand; }\n+                case (token.OR) { aop = ast.bitor; }\n+                case (token.LSL) { aop = ast.lsl; }\n+                case (token.LSR) { aop = ast.lsr; }\n+                case (token.ASR) { aop = ast.asr; }\n+            }\n+            ret @spanned(lo, rhs.span,\n+                         ast.expr_assign_op(aop, lhs, rhs, ast.ann_none));\n+        }\n         case (_) { /* fall through */ }\n     }\n     ret lhs;\n@@ -1080,6 +1100,8 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_alt(_,_,_))      { ret false; }\n                 case (ast.expr_block(_,_))      { ret false; }\n                 case (ast.expr_assign(_,_,_))   { ret true; }\n+                case (ast.expr_assign_op(_,_,_,_))\n+                                                { ret true; }\n                 case (ast.expr_field(_,_,_))    { ret true; }\n                 case (ast.expr_index(_,_,_))    { ret true; }\n                 case (ast.expr_name(_,_,_))     { ret true; }"}, {"sha": "1fc19e5c370c87cba7968b35e5569118dcb8e390", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=68af077e8192a6a1b18778b97449ad695a4ecffb", "patch": "@@ -45,16 +45,16 @@ const uint LLVMX86FastcallCallConv = 65u;\n // Consts for the LLVM IntPredicate type, pre-cast to uint.\n // FIXME: as above.\n \n-const uint LLVMIntEQ = 32;\n-const uint LLVMIntNE = 33;\n-const uint LLVMIntUGT = 34;\n-const uint LLVMIntUGE = 35;\n-const uint LLVMIntULT = 36;\n-const uint LLVMIntULE = 37;\n-const uint LLVMIntSGT = 38;\n-const uint LLVMIntSGE = 39;\n-const uint LLVMIntSLT = 40;\n-const uint LLVMIntSLE = 41;\n+const uint LLVMIntEQ = 32u;\n+const uint LLVMIntNE = 33u;\n+const uint LLVMIntUGT = 34u;\n+const uint LLVMIntUGE = 35u;\n+const uint LLVMIntULT = 36u;\n+const uint LLVMIntULE = 37u;\n+const uint LLVMIntSGT = 38u;\n+const uint LLVMIntSGE = 39u;\n+const uint LLVMIntSLT = 40u;\n+const uint LLVMIntSLE = 41u;\n \n \n native mod llvm = llvm_lib {"}, {"sha": "54492305c4b1c236a1490d468772c1a5605f415d", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=68af077e8192a6a1b18778b97449ad695a4ecffb", "patch": "@@ -114,6 +114,11 @@ type ast_fold[ENV] =\n          @expr lhs, @expr rhs,\n          ann a) -> @expr)                         fold_expr_assign,\n \n+     (fn(&ENV e, &span sp,\n+         ast.binop,\n+         @expr lhs, @expr rhs,\n+         ann a) -> @expr)                         fold_expr_assign_op,\n+\n      (fn(&ENV e, &span sp,\n          @expr e, ident i,\n          ann a) -> @expr)                         fold_expr_field,\n@@ -465,6 +470,12 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_assign(env_, e.span, llhs, rrhs, t);\n         }\n \n+        case (ast.expr_assign_op(?op, ?lhs, ?rhs, ?t)) {\n+            auto llhs = fold_expr(env_, fld, lhs);\n+            auto rrhs = fold_expr(env_, fld, rhs);\n+            ret fld.fold_expr_assign_op(env_, e.span, op, llhs, rrhs, t);\n+        }\n+\n         case (ast.expr_field(?e, ?i, ?t)) {\n             auto ee = fold_expr(env_, fld, e);\n             ret fld.fold_expr_field(env_, e.span, ee, i, t);\n@@ -790,6 +801,12 @@ fn identity_fold_expr_assign[ENV](&ENV env, &span sp,\n     ret @respan(sp, ast.expr_assign(lhs, rhs, a));\n }\n \n+fn identity_fold_expr_assign_op[ENV](&ENV env, &span sp, ast.binop op,\n+                                     @expr lhs, @expr rhs, ann a)\n+        -> @expr {\n+    ret @respan(sp, ast.expr_assign_op(op, lhs, rhs, a));\n+}\n+\n fn identity_fold_expr_field[ENV](&ENV env, &span sp,\n                                  @expr e, ident i, ann a) -> @expr {\n     ret @respan(sp, ast.expr_field(e, i, a));\n@@ -986,6 +1003,8 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_alt    = bind identity_fold_expr_alt[ENV](_,_,_,_,_),\n          fold_expr_block  = bind identity_fold_expr_block[ENV](_,_,_,_),\n          fold_expr_assign = bind identity_fold_expr_assign[ENV](_,_,_,_,_),\n+         fold_expr_assign_op\n+                       = bind identity_fold_expr_assign_op[ENV](_,_,_,_,_,_),\n          fold_expr_field  = bind identity_fold_expr_field[ENV](_,_,_,_,_),\n          fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_,_),\n          fold_expr_name   = bind identity_fold_expr_name[ENV](_,_,_,_,_),"}, {"sha": "c5cc20638d36f9473a81de3078c53ede2720e7d9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 53, "deletions": 102, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=68af077e8192a6a1b18778b97449ad695a4ecffb", "patch": "@@ -1031,6 +1031,42 @@ impure fn trans_unary(@block_ctxt cx, ast.unop op,\n     fail;\n }\n \n+fn trans_eager_binop(@block_ctxt cx, ast.binop op,\n+                     ValueRef lhs, ValueRef rhs) -> ValueRef {\n+\n+    alt (op) {\n+        case (ast.add) { ret cx.build.Add(lhs, rhs); }\n+        case (ast.sub) { ret cx.build.Sub(lhs, rhs); }\n+\n+        // FIXME: switch by signedness.\n+        case (ast.mul) { ret cx.build.Mul(lhs, rhs); }\n+        case (ast.div) { ret cx.build.SDiv(lhs, rhs); }\n+        case (ast.rem) { ret cx.build.SRem(lhs, rhs); }\n+\n+        case (ast.bitor) { ret cx.build.Or(lhs, rhs); }\n+        case (ast.bitand) { ret cx.build.And(lhs, rhs); }\n+        case (ast.bitxor) { ret cx.build.Xor(lhs, rhs); }\n+        case (ast.lsl) { ret cx.build.Shl(lhs, rhs); }\n+        case (ast.lsr) { ret cx.build.LShr(lhs, rhs); }\n+        case (ast.asr) { ret cx.build.AShr(lhs, rhs); }\n+        case (_) {\n+            auto cmp = lib.llvm.LLVMIntEQ;\n+            alt (op) {\n+                case (ast.eq) { cmp = lib.llvm.LLVMIntEQ; }\n+                case (ast.ne) { cmp = lib.llvm.LLVMIntNE; }\n+\n+                // FIXME: switch by signedness.\n+                case (ast.lt) { cmp = lib.llvm.LLVMIntSLT; }\n+                case (ast.le) { cmp = lib.llvm.LLVMIntSLE; }\n+                case (ast.ge) { cmp = lib.llvm.LLVMIntSGE; }\n+                case (ast.gt) { cmp = lib.llvm.LLVMIntSGT; }\n+            }\n+            ret cx.build.ICmp(cmp, lhs, rhs);\n+        }\n+    }\n+    fail;\n+}\n+\n impure fn trans_binary(@block_ctxt cx, ast.binop op,\n                        @ast.expr a, @ast.expr b) -> result {\n \n@@ -1073,109 +1109,12 @@ impure fn trans_binary(@block_ctxt cx, ast.binop op,\n                              vec(lhs_true_res, rhs_res));\n         }\n \n-        case (_) { /* fall through */ }\n-    }\n-\n-    // Remaining cases are eager:\n-\n-    auto lhs = trans_expr(cx, a);\n-    auto sub = trans_expr(lhs.bcx, b);\n-\n-    alt (op) {\n-        case (ast.add) {\n-            sub.val = cx.build.Add(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.sub) {\n-            sub.val = cx.build.Sub(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.mul) {\n-            // FIXME: switch by signedness.\n-            sub.val = cx.build.Mul(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.div) {\n-            // FIXME: switch by signedness.\n-            sub.val = cx.build.SDiv(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.rem) {\n-            // FIXME: switch by signedness.\n-            sub.val = cx.build.SRem(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.bitor) {\n-            sub.val = cx.build.Or(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.bitand) {\n-            sub.val = cx.build.And(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.bitxor) {\n-            sub.val = cx.build.Xor(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.lsl) {\n-            sub.val = cx.build.Shl(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.lsr) {\n-            sub.val = cx.build.LShr(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.asr) {\n-            sub.val = cx.build.AShr(lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.eq) {\n-            sub.val = cx.build.ICmp(lib.llvm.LLVMIntEQ, lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.ne) {\n-            sub.val = cx.build.ICmp(lib.llvm.LLVMIntNE, lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.lt) {\n-            // FIXME: switch by signedness.\n-            sub.val = cx.build.ICmp(lib.llvm.LLVMIntSLT, lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.le) {\n-            // FIXME: switch by signedness.\n-            sub.val = cx.build.ICmp(lib.llvm.LLVMIntSLE, lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.ge) {\n-            // FIXME: switch by signedness.\n-            sub.val = cx.build.ICmp(lib.llvm.LLVMIntSGE, lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n-        case (ast.gt) {\n-            // FIXME: switch by signedness.\n-            sub.val = cx.build.ICmp(lib.llvm.LLVMIntSGT, lhs.val, sub.val);\n-            ret sub;\n-        }\n-\n         case (_) {\n-            cx.fcx.ccx.sess.unimpl(\"operator in trans_binary\");\n+            // Remaining cases are eager:\n+            auto lhs = trans_expr(cx, a);\n+            auto sub = trans_expr(lhs.bcx, b);\n+            ret res(sub.bcx, trans_eager_binop(sub.bcx, op,\n+                                               lhs.val, sub.val));\n         }\n     }\n     fail;\n@@ -1551,6 +1490,18 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret copy_ty(rhs_res.bcx, false, lhs_res._0.val, rhs_res.val, t);\n         }\n \n+        case (ast.expr_assign_op(?op, ?dst, ?src, ?ann)) {\n+            auto t = node_ann_type(cx.fcx.ccx, ann);\n+            auto lhs_res = trans_lval(cx, dst);\n+            check (lhs_res._1);\n+            auto lhs_val = load_non_structural(lhs_res._0.bcx,\n+                                               lhs_res._0.val, t);\n+            auto rhs_res = trans_expr(lhs_res._0.bcx, src);\n+            auto v = trans_eager_binop(rhs_res.bcx, op, lhs_val, rhs_res.val);\n+            // FIXME: calculate copy init-ness in typestate.\n+            ret copy_ty(rhs_res.bcx, false, lhs_res._0.val, v, t);\n+        }\n+\n         case (ast.expr_call(?f, ?args, _)) {\n             ret trans_call(cx, f, args);\n         }"}, {"sha": "2ca20977145fc094af3ca2ff3f323b3b0cabc874", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68af077e8192a6a1b18778b97449ad695a4ecffb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=68af077e8192a6a1b18778b97449ad695a4ecffb", "patch": "@@ -684,6 +684,8 @@ fn expr_ty(@ast.expr expr) -> @ty {\n         case (ast.expr_do_while(_, _, ?ann))  { ret ann_to_type(ann); }\n         case (ast.expr_block(_, ?ann))        { ret ann_to_type(ann); }\n         case (ast.expr_assign(_, _, ?ann))    { ret ann_to_type(ann); }\n+        case (ast.expr_assign_op(_, _, _, ?ann))\n+                                              { ret ann_to_type(ann); }\n         case (ast.expr_field(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_index(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_name(_, _, ?ann))      { ret ann_to_type(ann); }\n@@ -1120,6 +1122,10 @@ fn demand_expr(&fn_ctxt fcx, @ty expected, @ast.expr e) -> @ast.expr {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             e_1 = ast.expr_assign(lhs, rhs, ast.ann_type(t));\n         }\n+        case (ast.expr_assign_op(?op, ?lhs, ?rhs, ?ann)) {\n+            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            e_1 = ast.expr_assign_op(op, lhs, rhs, ast.ann_type(t));\n+        }\n         case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             e_1 = ast.expr_field(lhs, rhs, ast.ann_type(t));\n@@ -1308,6 +1314,21 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                         ast.expr_assign(lhs_1, rhs_1, ann));\n         }\n \n+        case (ast.expr_assign_op(?op, ?lhs, ?rhs, _)) {\n+            auto lhs_0 = check_expr(fcx, lhs);\n+            auto rhs_0 = check_expr(fcx, rhs);\n+            auto lhs_t0 = expr_ty(lhs_0);\n+            auto rhs_t0 = expr_ty(rhs_0);\n+\n+            auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n+            auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n+\n+            auto ann = ast.ann_type(rhs_t0);\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_assign_op(op, lhs_1, rhs_1,\n+                                                           ann));\n+        }\n+\n         case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n             auto cond_1 = demand_expr(fcx, plain_ty(ty_bool), cond_0);"}]}