{"sha": "5c26509405681aa54d57577085810101ed6ac54e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMjY1MDk0MDU2ODFhYTU0ZDU3NTc3MDg1ODEwMTAxZWQ2YWM1NGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-08T13:58:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-16T21:32:21Z"}, "message": "restructure the public inhabitedness APIs and remove the cache\n\nThe cache was broken anyhow and this computation doesn't look that\nexpensive. These public accessors could potentially become queries,\nbut we'd have to add some more complex logic around lift. I'd prefer\nto have some test cases to profile with before doing that.\n\nFixes #44402.", "tree": {"sha": "15c0efbce126c94fdca744e9872243443e405aa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15c0efbce126c94fdca744e9872243443e405aa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c26509405681aa54d57577085810101ed6ac54e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c26509405681aa54d57577085810101ed6ac54e", "html_url": "https://github.com/rust-lang/rust/commit/5c26509405681aa54d57577085810101ed6ac54e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c26509405681aa54d57577085810101ed6ac54e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5673de454a330df075834732861080ad6f9c124", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5673de454a330df075834732861080ad6f9c124", "html_url": "https://github.com/rust-lang/rust/commit/a5673de454a330df075834732861080ad6f9c124"}], "stats": {"total": 111, "additions": 70, "deletions": 41}, "files": [{"sha": "c2e881255f24dc938eaa6c57bd07d514a6c08e99", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c26509405681aa54d57577085810101ed6ac54e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26509405681aa54d57577085810101ed6ac54e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5c26509405681aa54d57577085810101ed6ac54e", "patch": "@@ -43,7 +43,6 @@ use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n-use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n@@ -896,8 +895,6 @@ pub struct GlobalCtxt<'tcx> {\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n-    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -1179,7 +1176,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             mir_passes,\n             rcache: RefCell::new(FxHashMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n-            inhabitedness_cache: RefCell::new(FxHashMap()),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),"}, {"sha": "34e9084662ae54c4c172e1e34994c2d7b57e3a86", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5c26509405681aa54d57577085810101ed6ac54e/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26509405681aa54d57577085810101ed6ac54e/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=5c26509405681aa54d57577085810101ed6ac54e", "patch": "@@ -100,14 +100,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// This code should only compile in modules where the uninhabitedness of Foo is\n     /// visible.\n     pub fn is_ty_uninhabited_from(self, module: DefId, ty: Ty<'tcx>) -> bool {\n-        let forest = ty.uninhabited_from(&mut FxHashMap(), self);\n-\n         // To check whether this type is uninhabited at all (not just from the\n         // given node) you could check whether the forest is empty.\n         // ```\n         // forest.is_empty()\n         // ```\n-        forest.contains(self, module)\n+        self.ty_inhabitedness_forest(ty).contains(self, module)\n+    }\n+\n+    fn ty_inhabitedness_forest(self, ty: Ty<'tcx>) -> DefIdForest {\n+        ty.uninhabited_from(&mut FxHashMap(), self)\n     }\n \n     pub fn is_enum_variant_uninhabited_from(self,\n@@ -116,17 +118,25 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                             substs: &'tcx Substs<'tcx>)\n                                             -> bool\n     {\n-        let adt_kind = AdtKind::Enum;\n-        variant.uninhabited_from(&mut FxHashMap(), self, substs, adt_kind).contains(self, module)\n+        self.variant_inhabitedness_forest(variant, substs).contains(self, module)\n     }\n \n     pub fn is_variant_uninhabited_from_all_modules(self,\n                                                    variant: &'tcx VariantDef,\n-                                                   substs: &'tcx Substs<'tcx>,\n-                                                   adt_kind: AdtKind)\n+                                                   substs: &'tcx Substs<'tcx>)\n                                                    -> bool\n     {\n-        !variant.uninhabited_from(&mut FxHashMap(), self, substs, adt_kind).is_empty()\n+        !self.variant_inhabitedness_forest(variant, substs).is_empty()\n+    }\n+\n+    fn variant_inhabitedness_forest(self, variant: &'tcx VariantDef, substs: &'tcx Substs<'tcx>)\n+                                    -> DefIdForest {\n+        // Determine the ADT kind:\n+        let adt_def_id = self.adt_def_id_of_variant(variant);\n+        let adt_kind = self.adt_def(adt_def_id).adt_kind();\n+\n+        // Compute inhabitedness forest:\n+        variant.uninhabited_from(&mut FxHashMap(), self, substs, adt_kind)\n     }\n }\n \n@@ -210,31 +220,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         &self,\n         visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n-    {\n-        match tcx.lift_to_global(&self) {\n-            Some(global_ty) => {\n-                {\n-                    let cache = tcx.inhabitedness_cache.borrow();\n-                    if let Some(forest) = cache.get(&global_ty) {\n-                        return forest.clone();\n-                    }\n-                }\n-                let forest = global_ty.uninhabited_from_inner(visited, tcx);\n-                let mut cache = tcx.inhabitedness_cache.borrow_mut();\n-                cache.insert(global_ty, forest.clone());\n-                forest\n-            },\n-            None => {\n-                let forest = self.uninhabited_from_inner(visited, tcx);\n-                forest\n-            },\n-        }\n-    }\n-\n-    fn uninhabited_from_inner(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n             TyAdt(def, substs) => {"}, {"sha": "35969361544ee1163f99a8e28c44e1084ef38599", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5c26509405681aa54d57577085810101ed6ac54e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26509405681aa54d57577085810101ed6ac54e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5c26509405681aa54d57577085810101ed6ac54e", "patch": "@@ -18,6 +18,7 @@ pub use self::fold::TypeFoldable;\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use hir::map::DefPathData;\n use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n@@ -2232,6 +2233,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Given a `VariantDef`, returns the def-id of the `AdtDef` of which it is a part.\n+    pub fn adt_def_id_of_variant(self, variant_def: &'tcx VariantDef) -> DefId {\n+        let def_key = self.def_key(variant_def.did);\n+        match def_key.disambiguated_data.data {\n+            // for enum variants and tuple structs, the def-id of the ADT itself\n+            // is the *parent* of the variant\n+            DefPathData::EnumVariant(..) | DefPathData::StructCtor =>\n+                DefId { krate: variant_def.did.krate, index: def_key.parent.unwrap() },\n+\n+            // otherwise, for structs and unions, they share a def-id\n+            _ => variant_def.did,\n+        }\n+    }\n+\n     pub fn item_name(self, id: DefId) -> InternedString {\n         if let Some(id) = self.hir.as_local_node_id(id) {\n             self.hir.name(id).as_str()"}, {"sha": "9b3f16f1ab4326b06369a1301008912449f1bb50", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c26509405681aa54d57577085810101ed6ac54e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26509405681aa54d57577085810101ed6ac54e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=5c26509405681aa54d57577085810101ed6ac54e", "patch": "@@ -101,10 +101,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if self.hir.tcx().sess.features.borrow().never_type {\n                     let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n                         i == variant_index || {\n-                            let adt_kind = adt_def.adt_kind();\n-                            self.hir.tcx().is_variant_uninhabited_from_all_modules(v,\n-                                                                                   substs,\n-                                                                                   adt_kind)\n+                            self.hir.tcx().is_variant_uninhabited_from_all_modules(v, substs)\n                         }\n                     });\n                     if irrefutable {"}, {"sha": "244aa65a3d568e86a666eb28c000b0abc8618eb8", "filename": "src/test/run-pass/issue-44402.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c26509405681aa54d57577085810101ed6ac54e/src%2Ftest%2Frun-pass%2Fissue-44402.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c26509405681aa54d57577085810101ed6ac54e/src%2Ftest%2Frun-pass%2Fissue-44402.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-44402.rs?ref=5c26509405681aa54d57577085810101ed6ac54e", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+// Regression test for inhabitedness check. The old\n+// cache used to cause us to incorrectly decide\n+// that `test_b` was invalid.\n+\n+struct Foo {\n+    field1: !,\n+    field2: Option<&'static Bar>,\n+}\n+\n+struct Bar {\n+    field1: &'static Foo\n+}\n+\n+fn test_a() {\n+    let x: Option<Foo> = None;\n+    match x { None => () }\n+}\n+\n+fn test_b() {\n+    let x: Option<Bar> = None;\n+    match x { None => () }\n+}\n+\n+fn main() { }"}]}