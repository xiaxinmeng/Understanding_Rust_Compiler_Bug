{"sha": "e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZjlkN2ZmOTJmNjJjZGUzZWYxYjczMDFhYzRhYzNhZGFiOTkwZDk=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-23T11:07:30Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-19T17:31:14Z"}, "message": "BTreeMap: introduce marker::ValMut and reserve marker::Mut for unique access", "tree": {"sha": "e54d9449ed4e5b922ac1fc900882fda39e878369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e54d9449ed4e5b922ac1fc900882fda39e878369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9", "html_url": "https://github.com/rust-lang/rust/commit/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "443e177c7f0f94fc85b0e13e076b21e9eac60189", "url": "https://api.github.com/repos/rust-lang/rust/commits/443e177c7f0f94fc85b0e13e076b21e9eac60189", "html_url": "https://github.com/rust-lang/rust/commit/443e177c7f0f94fc85b0e13e076b21e9eac60189"}], "stats": {"total": 490, "additions": 319, "deletions": 171}, "files": [{"sha": "92f02fb60168b6da4b201de5a8bf1db1e59a66e5", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 10, "deletions": 124, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9", "patch": "@@ -5,7 +5,6 @@ use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n@@ -408,8 +407,8 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n /// [`range_mut`]: BTreeMap::range_mut\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n-    front: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n-    back: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    front: Option<Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n \n     // Be invariant in `K` and `V`\n     _marker: PhantomData<&'a mut (K, V)>,\n@@ -999,7 +998,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &self.root {\n-            let (f, b) = range_search(root.node_as_ref(), range);\n+            let (f, b) = root.node_as_ref().range_search(range);\n \n             Range { front: Some(f), back: Some(b) }\n         } else {\n@@ -1045,7 +1044,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &mut self.root {\n-            let (f, b) = range_search(root.node_as_mut(), range);\n+            let (f, b) = root.node_as_valmut().range_search(range);\n \n             RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n         } else {\n@@ -1478,7 +1477,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     fn into_iter(self) -> IntoIter<K, V> {\n         let mut me = ManuallyDrop::new(self);\n         if let Some(root) = me.root.take() {\n-            let (f, b) = full_range_search(root.into_ref());\n+            let (f, b) = root.into_ref().full_range();\n \n             IntoIter { front: Some(f), back: Some(b), length: me.length }\n         } else {\n@@ -1942,7 +1941,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n         self.front == self.back\n     }\n \n-    unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n         unsafe { unwrap_unchecked(self.front.as_mut()).next_unchecked() }\n     }\n }\n@@ -1963,7 +1962,7 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n-    unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n         unsafe { unwrap_unchecked(self.back.as_mut()).next_back_unchecked() }\n     }\n }\n@@ -2073,119 +2072,6 @@ where\n     }\n }\n \n-/// Finds the leaf edges delimiting a specified range in or underneath a node.\n-fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n-    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    range: R,\n-) -> (\n-    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n-    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n-)\n-where\n-    Q: Ord,\n-    K: Borrow<Q>,\n-{\n-    match (range.start_bound(), range.end_bound()) {\n-        (Excluded(s), Excluded(e)) if s == e => {\n-            panic!(\"range start and end are equal and excluded in BTreeMap\")\n-        }\n-        (Included(s) | Excluded(s), Included(e) | Excluded(e)) if s > e => {\n-            panic!(\"range start is greater than range end in BTreeMap\")\n-        }\n-        _ => {}\n-    };\n-\n-    // We duplicate the root NodeRef here -- we will never access it in a way\n-    // that overlaps references obtained from the root.\n-    let mut min_node = unsafe { ptr::read(&root) };\n-    let mut max_node = root;\n-    let mut min_found = false;\n-    let mut max_found = false;\n-\n-    loop {\n-        let front = match (min_found, range.start_bound()) {\n-            (false, Included(key)) => match search::search_node(min_node, key) {\n-                Found(kv) => {\n-                    min_found = true;\n-                    kv.left_edge()\n-                }\n-                GoDown(edge) => edge,\n-            },\n-            (false, Excluded(key)) => match search::search_node(min_node, key) {\n-                Found(kv) => {\n-                    min_found = true;\n-                    kv.right_edge()\n-                }\n-                GoDown(edge) => edge,\n-            },\n-            (true, Included(_)) => min_node.last_edge(),\n-            (true, Excluded(_)) => min_node.first_edge(),\n-            (_, Unbounded) => min_node.first_edge(),\n-        };\n-\n-        let back = match (max_found, range.end_bound()) {\n-            (false, Included(key)) => match search::search_node(max_node, key) {\n-                Found(kv) => {\n-                    max_found = true;\n-                    kv.right_edge()\n-                }\n-                GoDown(edge) => edge,\n-            },\n-            (false, Excluded(key)) => match search::search_node(max_node, key) {\n-                Found(kv) => {\n-                    max_found = true;\n-                    kv.left_edge()\n-                }\n-                GoDown(edge) => edge,\n-            },\n-            (true, Included(_)) => max_node.first_edge(),\n-            (true, Excluded(_)) => max_node.last_edge(),\n-            (_, Unbounded) => max_node.last_edge(),\n-        };\n-\n-        if front.partial_cmp(&back) == Some(Ordering::Greater) {\n-            panic!(\"Ord is ill-defined in BTreeMap range\");\n-        }\n-        match (front.force(), back.force()) {\n-            (Leaf(f), Leaf(b)) => {\n-                return (f, b);\n-            }\n-            (Internal(min_int), Internal(max_int)) => {\n-                min_node = min_int.descend();\n-                max_node = max_int.descend();\n-            }\n-            _ => unreachable!(\"BTreeMap has different depths\"),\n-        };\n-    }\n-}\n-\n-/// Equivalent to `range_search(k, v, ..)` without the `Ord` bound.\n-fn full_range_search<BorrowType, K, V>(\n-    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-) -> (\n-    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n-    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n-) {\n-    // We duplicate the root NodeRef here -- we will never access it in a way\n-    // that overlaps references obtained from the root.\n-    let mut min_node = unsafe { ptr::read(&root) };\n-    let mut max_node = root;\n-    loop {\n-        let front = min_node.first_edge();\n-        let back = max_node.last_edge();\n-        match (front.force(), back.force()) {\n-            (Leaf(f), Leaf(b)) => {\n-                return (f, b);\n-            }\n-            (Internal(min_int), Internal(max_int)) => {\n-                min_node = min_int.descend();\n-                max_node = max_int.descend();\n-            }\n-            _ => unreachable!(\"BTreeMap has different depths\"),\n-        };\n-    }\n-}\n-\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -2211,7 +2097,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         if let Some(root) = &self.root {\n-            let (f, b) = full_range_search(root.node_as_ref());\n+            let (f, b) = root.node_as_ref().full_range();\n \n             Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n         } else {\n@@ -2243,7 +2129,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n         if let Some(root) = &mut self.root {\n-            let (f, b) = full_range_search(root.node_as_mut());\n+            let (f, b) = root.node_as_valmut().full_range();\n \n             IterMut {\n                 range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },\n@@ -2826,7 +2712,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n                     if stole_from_left && at_leaf {\n                         // SAFETY: This is safe since we just added an element to our node.\n                         unsafe {\n-                            pos.next_unchecked();\n+                            pos.move_next_unchecked();\n                         }\n                     }\n                     break;"}, {"sha": "376060b3143de98661693a87526ca34f7d88318e", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 274, "deletions": 44, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9", "patch": "@@ -1,10 +1,210 @@\n+use core::borrow::Borrow;\n+use core::cmp::Ordering;\n use core::intrinsics;\n use core::mem;\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::RangeBounds;\n use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n+use super::search::{self, SearchResult};\n use super::unwrap_unchecked;\n \n+/// Finds the leaf edges delimiting a specified range in or underneath a node.\n+fn range_search<BorrowType, K, V, Q, R>(\n+    root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    range: R,\n+) -> (\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+)\n+where\n+    Q: ?Sized + Ord,\n+    K: Borrow<Q>,\n+    R: RangeBounds<Q>,\n+{\n+    match (range.start_bound(), range.end_bound()) {\n+        (Excluded(s), Excluded(e)) if s == e => {\n+            panic!(\"range start and end are equal and excluded in BTreeMap\")\n+        }\n+        (Included(s) | Excluded(s), Included(e) | Excluded(e)) if s > e => {\n+            panic!(\"range start is greater than range end in BTreeMap\")\n+        }\n+        _ => {}\n+    };\n+\n+    let mut min_node = root1;\n+    let mut max_node = root2;\n+    let mut min_found = false;\n+    let mut max_found = false;\n+\n+    loop {\n+        let front = match (min_found, range.start_bound()) {\n+            (false, Included(key)) => match search::search_node(min_node, key) {\n+                SearchResult::Found(kv) => {\n+                    min_found = true;\n+                    kv.left_edge()\n+                }\n+                SearchResult::GoDown(edge) => edge,\n+            },\n+            (false, Excluded(key)) => match search::search_node(min_node, key) {\n+                SearchResult::Found(kv) => {\n+                    min_found = true;\n+                    kv.right_edge()\n+                }\n+                SearchResult::GoDown(edge) => edge,\n+            },\n+            (true, Included(_)) => min_node.last_edge(),\n+            (true, Excluded(_)) => min_node.first_edge(),\n+            (_, Unbounded) => min_node.first_edge(),\n+        };\n+\n+        let back = match (max_found, range.end_bound()) {\n+            (false, Included(key)) => match search::search_node(max_node, key) {\n+                SearchResult::Found(kv) => {\n+                    max_found = true;\n+                    kv.right_edge()\n+                }\n+                SearchResult::GoDown(edge) => edge,\n+            },\n+            (false, Excluded(key)) => match search::search_node(max_node, key) {\n+                SearchResult::Found(kv) => {\n+                    max_found = true;\n+                    kv.left_edge()\n+                }\n+                SearchResult::GoDown(edge) => edge,\n+            },\n+            (true, Included(_)) => max_node.first_edge(),\n+            (true, Excluded(_)) => max_node.last_edge(),\n+            (_, Unbounded) => max_node.last_edge(),\n+        };\n+\n+        if front.partial_cmp(&back) == Some(Ordering::Greater) {\n+            panic!(\"Ord is ill-defined in BTreeMap range\");\n+        }\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            }\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            }\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n+/// Equivalent to `range_search(k, v, ..)` but without the `Ord` bound.\n+fn full_range<BorrowType, K, V>(\n+    root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+) -> (\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+) {\n+    let mut min_node = root1;\n+    let mut max_node = root2;\n+    loop {\n+        let front = min_node.first_edge();\n+        let back = max_node.last_edge();\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            }\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            }\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Creates a pair of leaf edges delimiting a specified range in or underneath a node.\n+    pub fn range_search<Q, R>(\n+        self,\n+        range: R,\n+    ) -> (\n+        Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    )\n+    where\n+        Q: ?Sized + Ord,\n+        K: Borrow<Q>,\n+        R: RangeBounds<Q>,\n+    {\n+        range_search(self, self, range)\n+    }\n+\n+    /// Returns (self.first_leaf_edge(), self.last_leaf_edge()), but more efficiently.\n+    pub fn full_range(\n+        self,\n+    ) -> (\n+        Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    ) {\n+        full_range(self, self)\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::ValMut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Splits a unique reference into a pair of leaf edges delimiting a specified range.\n+    /// The result are non-unique references allowing (some) mutation, which must be used\n+    /// carefully.\n+    pub fn range_search<Q, R>(\n+        self,\n+        range: R,\n+    ) -> (\n+        Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    )\n+    where\n+        Q: ?Sized + Ord,\n+        K: Borrow<Q>,\n+        R: RangeBounds<Q>,\n+    {\n+        // We duplicate the root NodeRef here -- we will never visit the same KV\n+        // twice, and never end up with overlapping value references.\n+        let self2 = unsafe { ptr::read(&self) };\n+        range_search(self, self2, range)\n+    }\n+\n+    /// Splits a unique reference into a pair of leaf edges delimiting the full range of the tree.\n+    /// The results are non-unique references allowing mutation (of values only), so must be used\n+    /// with care.\n+    pub fn full_range(\n+        self,\n+    ) -> (\n+        Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    ) {\n+        // We duplicate the root NodeRef here -- we will never visit the same KV\n+        // twice, and never end up with overlapping value references.\n+        let self2 = unsafe { ptr::read(&self) };\n+        full_range(self, self2)\n+    }\n+}\n+\n+impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n+    /// Splits a unique reference into a pair of leaf edges delimiting the full range of the tree.\n+    /// The results are non-unique references allowing massively destructive mutation, so must be\n+    /// used with the utmost care.\n+    pub fn full_range(\n+        self,\n+    ) -> (\n+        Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+        Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+    ) {\n+        // We duplicate the root NodeRef here -- we will never access it in a way\n+        // that overlaps references obtained from the root.\n+        let self2 = unsafe { ptr::read(&self) };\n+        full_range(self, self2)\n+    }\n+}\n+\n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n     /// on the right side, which is either in the same leaf node or in an ancestor node.\n@@ -75,12 +275,13 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n macro_rules! def_next_kv_uncheched_dealloc {\n     { unsafe fn $name:ident : $adjacent_kv:ident } => {\n         /// Given a leaf edge handle into an owned tree, returns a handle to the next KV,\n-        /// while deallocating any node left behind.\n-        /// Unsafe for two reasons:\n-        /// - The caller must ensure that the leaf edge is not the last one in the tree.\n-        /// - The node pointed at by the given handle, and its ancestors, may be deallocated,\n-        ///   while the reference to those nodes in the surviving ancestors is left dangling;\n-        ///   thus using the returned handle to navigate further is dangerous.\n+        /// while deallocating any node left behind yet leaving the corresponding edge\n+        /// in its parent node dangling.\n+        ///\n+        /// # Safety\n+        /// - The leaf edge must not be the last one in the direction travelled.\n+        /// - The node carrying the next KV returned must not have been deallocated by a\n+        ///   previous call on any handle obtained for this tree.\n         unsafe fn $name <K, V>(\n             leaf_edge: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n         ) -> Handle<NodeRef<marker::Owned, K, V, marker::LeafOrInternal>, marker::KV> {\n@@ -103,6 +304,15 @@ macro_rules! def_next_kv_uncheched_dealloc {\n def_next_kv_uncheched_dealloc! {unsafe fn next_kv_unchecked_dealloc: right_kv}\n def_next_kv_uncheched_dealloc! {unsafe fn next_back_kv_unchecked_dealloc: left_kv}\n \n+/// This replaces the value behind the `v` unique reference by calling the\n+/// relevant function.\n+///\n+/// If a panic occurs in the `change` closure, the entire process will be aborted.\n+#[inline]\n+fn take_mut<T>(v: &mut T, change: impl FnOnce(T) -> T) {\n+    replace(v, |value| (change(value), ()))\n+}\n+\n /// This replaces the value behind the `v` unique reference by calling the\n /// relevant function, and returns a result obtained along the way.\n ///\n@@ -128,7 +338,9 @@ fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns references to the\n     /// key and value in between.\n-    /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n+    ///\n+    /// # Safety\n+    /// There must be another KV in the direction travelled.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n         replace(self, |leaf_edge| {\n             let kv = leaf_edge.next_kv();\n@@ -139,7 +351,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n     /// key and value in between.\n-    /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n+    ///\n+    /// # Safety\n+    /// There must be another KV in the direction travelled.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n         replace(self, |leaf_edge| {\n             let kv = leaf_edge.next_back_kv();\n@@ -149,53 +363,69 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+impl<'a, K, V> Handle<NodeRef<marker::ValMut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns references to the\n     /// key and value in between.\n-    /// Unsafe for two reasons:\n-    /// - The caller must ensure that the leaf edge is not the last one in the tree.\n-    /// - Using the updated handle may well invalidate the returned references.\n-    pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+    /// The returned references might be invalidated when the updated handle is used again.\n+    ///\n+    /// # Safety\n+    /// There must be another KV in the direction travelled.\n+    pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n         let kv = replace(self, |leaf_edge| {\n             let kv = leaf_edge.next_kv();\n             let kv = unsafe { unwrap_unchecked(kv.ok()) };\n             (unsafe { ptr::read(&kv) }.next_leaf_edge(), kv)\n         });\n         // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_mut`, so we have to do this last.\n-        kv.into_kv_mut()\n+        // returned by `into_kv_valmut`, so we have to do this last.\n+        kv.into_kv_valmut()\n     }\n \n     /// Moves the leaf edge handle to the previous leaf and returns references to the\n     /// key and value in between.\n-    /// Unsafe for two reasons:\n-    /// - The caller must ensure that the leaf edge is not the first one in the tree.\n-    /// - Using the updated handle may well invalidate the returned references.\n-    pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+    /// The returned references might be invalidated when the updated handle is used again.\n+    ///\n+    /// # Safety\n+    /// There must be another KV in the direction travelled.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n         let kv = replace(self, |leaf_edge| {\n             let kv = leaf_edge.next_back_kv();\n             let kv = unsafe { unwrap_unchecked(kv.ok()) };\n             (unsafe { ptr::read(&kv) }.next_back_leaf_edge(), kv)\n         });\n         // Doing the descend (and perhaps another move) invalidates the references\n-        // returned by `into_kv_mut`, so we have to do this last.\n-        kv.into_kv_mut()\n+        // returned by `into_kv_valmut`, so we have to do this last.\n+        kv.into_kv_valmut()\n+    }\n+}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge.\n+    ///\n+    /// # Safety\n+    /// There must be another KV in the direction travelled.\n+    pub unsafe fn move_next_unchecked(&mut self) {\n+        take_mut(self, |leaf_edge| {\n+            let kv = leaf_edge.next_kv();\n+            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n+            kv.next_leaf_edge()\n+        })\n     }\n }\n \n impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns the key and value\n-    /// in between, while deallocating any node left behind.\n-    /// Unsafe for two reasons:\n-    /// - The caller must ensure that the leaf edge is not the last one in the tree\n-    ///   and is not a handle previously resulting from counterpart `next_back_unchecked`.\n-    /// - Further use of the updated leaf edge handle is very dangerous. In particular,\n-    ///   if the leaf edge is the last edge of a node, that node and possibly ancestors\n-    ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n-    ///   is left dangling.\n-    ///   The only safe way to proceed with the updated handle is to compare it, drop it,\n-    ///   call this method again subject to both preconditions listed in the first point,\n-    ///   or call counterpart `next_back_unchecked` subject to its preconditions.\n+    /// in between, deallocating any node left behind while leaving the corresponding\n+    /// edge in its parent node dangling.\n+    ///\n+    /// # Safety\n+    /// - There must be another KV in the direction travelled.\n+    /// - That KV was not previously returned by counterpart `next_back_unchecked`\n+    ///   on any copy of the handles being used to traverse the tree.\n+    ///\n+    /// The only safe way to proceed with the updated handle is to compare it, drop it,\n+    /// call this method again subject to its safety conditions, or call counterpart\n+    /// `next_back_unchecked` subject to its safety conditions.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n         replace(self, |leaf_edge| {\n             let kv = unsafe { next_kv_unchecked_dealloc(leaf_edge) };\n@@ -205,18 +435,18 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n         })\n     }\n \n-    /// Moves the leaf edge handle to the previous leaf edge and returns the key\n-    /// and value in between, while deallocating any node left behind.\n-    /// Unsafe for two reasons:\n-    /// - The caller must ensure that the leaf edge is not the first one in the tree\n-    ///   and is not a handle previously resulting from counterpart `next_unchecked`.\n-    /// - Further use of the updated leaf edge handle is very dangerous. In particular,\n-    ///   if the leaf edge is the first edge of a node, that node and possibly ancestors\n-    ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n-    ///   is left dangling.\n-    ///   The only safe way to proceed with the updated handle is to compare it, drop it,\n-    ///   call this method again subject to both preconditions listed in the first point,\n-    ///   or call counterpart `next_unchecked` subject to its preconditions.\n+    /// Moves the leaf edge handle to the previous leaf edge and returns the key and value\n+    /// in between, deallocating any node left behind while leaving the corresponding\n+    /// edge in its parent node dangling.\n+    ///\n+    /// # Safety\n+    /// - There must be another KV in the direction travelled.\n+    /// - That leaf edge was not previously returned by counterpart `next_unchecked`\n+    ///   on any copy of the handles being used to traverse the tree.\n+    ///\n+    /// The only safe way to proceed with the updated handle is to compare it, drop it,\n+    /// call this method again subject to its safety conditions, or call counterpart\n+    /// `next_unchecked` subject to its safety conditions.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n         replace(self, |leaf_edge| {\n             let kv = unsafe { next_back_kv_unchecked_dealloc(leaf_edge) };"}, {"sha": "772bdf357de7897b6abb484bd9a9f7a1aa9379e8", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=e5f9d7ff92f62cde3ef1b7301ac4ac3adab990d9", "patch": "@@ -186,6 +186,15 @@ impl<K, V> Root<K, V> {\n         }\n     }\n \n+    pub fn node_as_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, marker::LeafOrInternal> {\n+        NodeRef {\n+            height: self.height,\n+            node: self.node.as_ptr(),\n+            root: ptr::null(),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n     pub fn into_ref(self) -> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n@@ -253,9 +262,12 @@ impl<K, V> Root<K, V> {\n /// A reference to a node.\n ///\n /// This type has a number of parameters that controls how it acts:\n-/// - `BorrowType`: This can be `Immut<'a>` or `Mut<'a>` for some `'a` or `Owned`.\n+/// - `BorrowType`: This can be `Immut<'a>`, `Mut<'a>` or `ValMut<'a>' for some `'a`\n+///    or `Owned`.\n ///    When this is `Immut<'a>`, the `NodeRef` acts roughly like `&'a Node`,\n ///    when this is `Mut<'a>`, the `NodeRef` acts roughly like `&'a mut Node`,\n+///    when this is `ValMut<'a>`, the `NodeRef` acts as immutable with respect\n+///    to keys and tree structure, but allows mutable references to values,\n ///    and when this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`.\n /// - `K` and `V`: These control what types of things are stored in the nodes.\n /// - `Type`: This can be `Leaf`, `Internal`, or `LeafOrInternal`. When this is\n@@ -282,6 +294,7 @@ unsafe impl<BorrowType, K: Sync, V: Sync, Type> Sync for NodeRef<BorrowType, K,\n \n unsafe impl<'a, K: Sync + 'a, V: Sync + 'a, Type> Send for NodeRef<marker::Immut<'a>, K, V, Type> {}\n unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::Mut<'a>, K, V, Type> {}\n+unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::ValMut<'a>, K, V, Type> {}\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n@@ -515,6 +528,22 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n }\n \n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n+    /// Same as the marker::Mut method, but far more dangerous because ValMut-based iterators:\n+    /// - have front and back handles often refering to the same node, so `self` is not unique;\n+    /// - hand out mutable references to parts of these slices to the public.\n+    fn into_slices_mut(self) -> (&'a [K], &'a mut [V]) {\n+        let len = self.len();\n+        let leaf = self.node.as_ptr();\n+        // SAFETY: The keys and values of a node must always be initialized up to length.\n+        let keys = unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&(*leaf).keys), len) };\n+        let vals = unsafe {\n+            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len)\n+        };\n+        (keys, vals)\n+    }\n+}\n+\n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n@@ -1053,11 +1082,13 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n         let vals = self.node.into_val_slice_mut();\n         unsafe { vals.get_unchecked_mut(self.idx) }\n     }\n+}\n \n-    pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n+impl<'a, K, V, NodeType> Handle<NodeRef<marker::ValMut<'a>, K, V, NodeType>, marker::KV> {\n+    pub fn into_kv_valmut(self) -> (&'a K, &'a mut V) {\n         unsafe {\n             let (keys, vals) = self.node.into_slices_mut();\n-            (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n+            (keys.get_unchecked(self.idx), vals.get_unchecked_mut(self.idx))\n         }\n     }\n }\n@@ -1558,6 +1589,7 @@ pub mod marker {\n     pub enum Owned {}\n     pub struct Immut<'a>(PhantomData<&'a ()>);\n     pub struct Mut<'a>(PhantomData<&'a mut ()>);\n+    pub struct ValMut<'a>(PhantomData<&'a mut ()>);\n \n     pub enum KV {}\n     pub enum Edge {}"}]}