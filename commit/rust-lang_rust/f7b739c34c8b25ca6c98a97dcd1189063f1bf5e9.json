{"sha": "f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YjczOWMzNGM4YjI1Y2E2Yzk4YTk3ZGNkMTE4OTA2M2YxYmY1ZTk=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-11-29T19:11:52Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-11-29T19:19:19Z"}, "message": "extra: Rename json constructors into *::init", "tree": {"sha": "24ef4aae0d0bb198be7f2233b78507e9fe0db940", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ef4aae0d0bb198be7f2233b78507e9fe0db940"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "html_url": "https://github.com/rust-lang/rust/commit/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b41df4ca027421a86aeb8d2e96f3754b213c1d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b41df4ca027421a86aeb8d2e96f3754b213c1d5", "html_url": "https://github.com/rust-lang/rust/commit/5b41df4ca027421a86aeb8d2e96f3754b213c1d5"}], "stats": {"total": 164, "additions": 86, "deletions": 78}, "files": [{"sha": "e0792014c77f1076abef43eaabb38fb821e098f6", "filename": "src/libextra/json.rs", "status": "modified", "additions": 77, "deletions": 69, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "patch": "@@ -88,10 +88,12 @@ pub struct Encoder {\n     priv wr: @mut io::Writer,\n }\n \n-/// Creates a new JSON encoder whose output will be written to the writer\n-/// specified.\n-pub fn Encoder(wr: @mut io::Writer) -> Encoder {\n-    Encoder { wr: wr }\n+impl Encoder {\n+    /// Creates a new JSON encoder whose output will be written to the writer\n+    /// specified.\n+    pub fn init(wr: @mut io::Writer) -> Encoder {\n+        Encoder { wr: wr }\n+    }\n }\n \n impl serialize::Encoder for Encoder {\n@@ -243,11 +245,13 @@ pub struct PrettyEncoder {\n     priv indent: uint,\n }\n \n-/// Creates a new encoder whose output will be written to the specified writer\n-pub fn PrettyEncoder(wr: @mut io::Writer) -> PrettyEncoder {\n-    PrettyEncoder {\n-        wr: wr,\n-        indent: 0,\n+impl PrettyEncoder {\n+    /// Creates a new encoder whose output will be written to the specified writer\n+    pub fn init(wr: @mut io::Writer) -> PrettyEncoder {\n+        PrettyEncoder {\n+            wr: wr,\n+            indent: 0,\n+        }\n     }\n }\n \n@@ -445,14 +449,14 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n impl Json{\n     /// Encodes a json value into a io::writer.  Uses a single line.\n     pub fn to_writer(&self, wr: @mut io::Writer) {\n-        let mut encoder = Encoder(wr);\n+        let mut encoder = Encoder::init(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n     pub fn to_pretty_writer(&self, wr: @mut io::Writer) {\n-        let mut encoder = PrettyEncoder(wr);\n+        let mut encoder = PrettyEncoder::init(wr);\n         self.encode(&mut encoder)\n     }\n \n@@ -465,22 +469,24 @@ impl Json{\n }\n \n pub struct Parser<T> {\n-    priv rdr: ~T,\n+    priv rdr: T,\n     priv ch: char,\n     priv line: uint,\n     priv col: uint,\n }\n \n-/// Decode a json value from an Iterator<char>\n-pub fn Parser<T : Iterator<char>>(rdr: ~T) -> Parser<T> {\n-    let mut p = Parser {\n-        rdr: rdr,\n-        ch: '\\x00',\n-        line: 1,\n-        col: 0,\n-    };\n-    p.bump();\n-    p\n+impl<T: Iterator<char>> Parser<T> {\n+    /// Decode a json value from an Iterator<char>\n+    pub fn init(rdr: T) -> Parser<T> {\n+        let mut p = Parser {\n+            rdr: rdr,\n+            ch: '\\x00',\n+            line: 1,\n+            col: 0,\n+        };\n+        p.bump();\n+        p\n+    }\n }\n \n impl<T: Iterator<char>> Parser<T> {\n@@ -842,13 +848,13 @@ impl<T : Iterator<char>> Parser<T> {\n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n     let s = str::from_utf8(rdr.read_to_end());\n-    let mut parser = Parser(~s.chars());\n+    let mut parser = Parser::init(s.chars());\n     parser.parse()\n }\n \n /// Decodes a json value from a string\n pub fn from_str(s: &str) -> Result<Json, Error> {\n-    let mut parser = Parser(~s.chars());\n+    let mut parser = Parser::init(s.chars());\n     parser.parse()\n }\n \n@@ -857,10 +863,12 @@ pub struct Decoder {\n     priv stack: ~[Json],\n }\n \n-/// Creates a new decoder instance for decoding the specified JSON value.\n-pub fn Decoder(json: Json) -> Decoder {\n-    Decoder {\n-        stack: ~[json]\n+impl Decoder {\n+    /// Creates a new decoder instance for decoding the specified JSON value.\n+    pub fn init(json: Json) -> Decoder {\n+        Decoder {\n+            stack: ~[json]\n+        }\n     }\n }\n \n@@ -1514,14 +1522,14 @@ mod tests {\n         let animal = Dog;\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = Encoder(wr);\n+                let mut encoder = Encoder::init(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder(wr);\n+                let mut encoder = PrettyEncoder::init(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\"Dog\\\"\"\n@@ -1530,14 +1538,14 @@ mod tests {\n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = Encoder(wr);\n+                let mut encoder = Encoder::init(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder(wr);\n+                let mut encoder = PrettyEncoder::init(wr);\n                 animal.encode(&mut encoder);\n             }),\n             ~\"\\\n@@ -1553,14 +1561,14 @@ mod tests {\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder(wr);\n+            let mut encoder = Encoder::init(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n-            let mut encoder = PrettyEncoder(wr);\n+            let mut encoder = PrettyEncoder::init(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n@@ -1570,13 +1578,13 @@ mod tests {\n     fn test_write_none() {\n         let value: Option<~str> = None;\n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder(wr);\n+            let mut encoder = Encoder::init(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"null\");\n \n         let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder(wr);\n+            let mut encoder = Encoder::init(wr);\n             value.encode(&mut encoder);\n         });\n         assert_eq!(s, ~\"null\");\n@@ -1625,15 +1633,15 @@ mod tests {\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let mut decoder = Decoder(from_str(\"null\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"null\").unwrap());\n         let v: () = Decodable::decode(&mut decoder);\n         assert_eq!(v, ());\n \n-        let mut decoder = Decoder(from_str(\"true\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"true\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, true);\n \n-        let mut decoder = Decoder(from_str(\"false\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"false\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, false);\n     }\n@@ -1668,31 +1676,31 @@ mod tests {\n \n     #[test]\n     fn test_decode_numbers() {\n-        let mut decoder = Decoder(from_str(\"3\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"3\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.0);\n \n-        let mut decoder = Decoder(from_str(\"3.1\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"3.1\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.1);\n \n-        let mut decoder = Decoder(from_str(\"-1.2\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"-1.2\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, -1.2);\n \n-        let mut decoder = Decoder(from_str(\"0.4\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"0.4\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4);\n \n-        let mut decoder = Decoder(from_str(\"0.4e5\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"0.4e5\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e5);\n \n-        let mut decoder = Decoder(from_str(\"0.4e15\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"0.4e15\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e15);\n \n-        let mut decoder = Decoder(from_str(\"0.4e-01\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"0.4e-01\").unwrap());\n         let v: f64 = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e-01);\n     }\n@@ -1720,39 +1728,39 @@ mod tests {\n \n     #[test]\n     fn test_decode_str() {\n-        let mut decoder = Decoder(from_str(\"\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"foo\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"foo\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"foo\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\\"\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\b\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\b\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\x08\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\n\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\n\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\n\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\r\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\r\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\r\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\t\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\t\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\t\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\u12ab\");\n \n-        let mut decoder = Decoder(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\uAB12\");\n     }\n@@ -1785,27 +1793,27 @@ mod tests {\n \n     #[test]\n     fn test_decode_list() {\n-        let mut decoder = Decoder(from_str(\"[]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[]);\n \n-        let mut decoder = Decoder(from_str(\"[null]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[null]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[()]);\n \n-        let mut decoder = Decoder(from_str(\"[true]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder(from_str(\"[true]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder(from_str(\"[3, 1]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[3, 1]\").unwrap());\n         let v: ~[int] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[3, 1]);\n \n-        let mut decoder = Decoder(from_str(\"[[3], [1, 2]]\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"[[3], [1, 2]]\").unwrap());\n         let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[~[3], ~[1, 2]]);\n     }\n@@ -1907,7 +1915,7 @@ mod tests {\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n         }\";\n-        let mut decoder = Decoder(from_str(s).unwrap());\n+        let mut decoder = Decoder::init(from_str(s).unwrap());\n         let v: Outer = Decodable::decode(&mut decoder);\n         assert_eq!(\n             v,\n@@ -1921,31 +1929,31 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let mut decoder = Decoder(from_str(\"null\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"null\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, None);\n \n-        let mut decoder = Decoder(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let mut decoder = Decoder(from_str(\"\\\"Dog\\\"\").unwrap());\n+        let mut decoder = Decoder::init(from_str(\"\\\"Dog\\\"\").unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Dog);\n \n-        let mut decoder =\n-            Decoder(from_str(\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\").unwrap());\n+        let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n+        let mut decoder = Decoder::init(from_str(s).unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut decoder = Decoder(from_str(s).unwrap());\n+        let mut decoder = Decoder::init(from_str(s).unwrap());\n         let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder);\n \n         assert_eq!(map.pop(&~\"a\"), Some(Dog));\n@@ -1982,7 +1990,7 @@ mod tests {\n             match from_str(to_parse) {\n                 Err(e) => Some(e.to_str()),\n                 Ok(json) => {\n-                    let _: T = Decodable::decode(&mut Decoder(json));\n+                    let _: T = Decodable::decode(&mut Decoder::init(json));\n                     None\n                 }\n             }"}, {"sha": "ba9478e4448f2cccdebb176a7fce0dfd70afdf5f", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "patch": "@@ -946,7 +946,7 @@ impl MetricMap {\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(p.exists());\n         let f = @mut File::open(p) as @mut io::Reader;\n-        let mut decoder = json::Decoder(json::from_reader(f).unwrap());\n+        let mut decoder = json::Decoder::init(json::from_reader(f).unwrap());\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n "}, {"sha": "27a0f51559778c0c771fecd98432a6c38f9868fa", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "patch": "@@ -191,7 +191,7 @@ impl Database {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n-                        let mut decoder = json::Decoder(r);\n+                        let mut decoder = json::Decoder::init(r);\n                         self.db_cache = Decodable::decode(&mut decoder);\n                     }\n             }\n@@ -258,7 +258,7 @@ enum Work<'self, T> {\n \n fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n     let writer = @mut MemWriter::new();\n-    let mut encoder = json::Encoder(writer as @mut io::Writer);\n+    let mut encoder = json::Encoder::init(writer as @mut io::Writer);\n     t.encode(&mut encoder);\n     str::from_utf8(writer.inner_ref().as_slice())\n }\n@@ -267,7 +267,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     debug!(\"json decoding: {}\", s);\n     let j = json::from_str(s).unwrap();\n-    let mut decoder = json::Decoder(j);\n+    let mut decoder = json::Decoder::init(j);\n     Decodable::decode(&mut decoder)\n }\n "}, {"sha": "5edafa1b1f69b0932f7fd4403cab1f8125a9d88e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "patch": "@@ -283,7 +283,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n             }\n             let crate = match obj.pop(&~\"crate\") {\n                 Some(json) => {\n-                    let mut d = json::Decoder(json);\n+                    let mut d = json::Decoder::init(json);\n                     Decodable::decode(&mut d)\n                 }\n                 None => return Err(~\"malformed json\"),\n@@ -313,7 +313,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     // straight to the Rust JSON representation.\n     let crate_json_str = {\n         let w = @mut MemWriter::new();\n-        crate.encode(&mut json::Encoder(w as @mut io::Writer));\n+        crate.encode(&mut json::Encoder::init(w as @mut io::Writer));\n         str::from_utf8(*w.inner_ref())\n     };\n     let crate_json = match json::from_str(crate_json_str) {"}, {"sha": "c932c188279dd6b99237ed61f48db531c535b019", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "patch": "@@ -343,7 +343,7 @@ mod test {\n \n     #[cfg(test)] fn to_json_str<E : Encodable<extra::json::Encoder>>(val: @E) -> ~str {\n         let writer = @mut MemWriter::new();\n-        let mut encoder = extra::json::Encoder(writer as @mut io::Writer);\n+        let mut encoder = extra::json::Encoder::init(writer as @mut io::Writer);\n         val.encode(&mut encoder);\n         str::from_utf8(*writer.inner_ref())\n     }"}, {"sha": "578d210a6fc3f179f9e4d780f1d7f3994a197175", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "patch": "@@ -18,7 +18,7 @@ trait JD : Decodable<json::Decoder> { }\n \n fn exec<T: JD>() {\n     let doc = json::from_str(\"\").unwrap();\n-    let mut decoder = json::Decoder(doc);\n+    let mut decoder = json::Decoder::init(doc);\n     let _v: T = Decodable::decode(&mut decoder);\n     fail!()\n }"}, {"sha": "bd3ca844263510ce261b9f7f1e68abd68d9a7104", "filename": "src/test/run-pass/issue-4036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4036.rs?ref=f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "patch": "@@ -17,6 +17,6 @@ use self::extra::serialize;\n \n pub fn main() {\n     let json = json::from_str(\"[1]\").unwrap();\n-    let mut decoder = json::Decoder(json);\n+    let mut decoder = json::Decoder::init(json);\n     let _x: ~[int] = serialize::Decodable::decode(&mut decoder);\n }"}]}