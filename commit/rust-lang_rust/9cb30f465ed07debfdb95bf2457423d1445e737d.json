{"sha": "9cb30f465ed07debfdb95bf2457423d1445e737d", "node_id": "C_kwDOAAsO6NoAKDljYjMwZjQ2NWVkMDdkZWJmZGI5NWJmMjQ1NzQyM2QxNDQ1ZTczN2Q", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2021-09-28T04:10:33Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2021-10-04T06:49:49Z"}, "message": "Move generic error message to separate branches\n\nThis decomposes an error message in generic constants into more specific branches, for better\nreadability.", "tree": {"sha": "f2a395362454eca0f680516f8543ff8ba80931c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2a395362454eca0f680516f8543ff8ba80931c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cb30f465ed07debfdb95bf2457423d1445e737d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb30f465ed07debfdb95bf2457423d1445e737d", "html_url": "https://github.com/rust-lang/rust/commit/9cb30f465ed07debfdb95bf2457423d1445e737d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cb30f465ed07debfdb95bf2457423d1445e737d/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a12be741290b16c29293f87bdb3e8e5129bd4a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a12be741290b16c29293f87bdb3e8e5129bd4a9", "html_url": "https://github.com/rust-lang/rust/commit/8a12be741290b16c29293f87bdb3e8e5129bd4a9"}], "stats": {"total": 163, "additions": 111, "deletions": 52}, "files": [{"sha": "25ec9682d84070f2ce4255ce051ba5df9ecf4c58", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 94, "deletions": 43, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9cb30f465ed07debfdb95bf2457423d1445e737d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb30f465ed07debfdb95bf2457423d1445e737d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=9cb30f465ed07debfdb95bf2457423d1445e737d", "patch": "@@ -236,16 +236,27 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         self.body.exprs[self.body_id].span\n     }\n \n-    fn error(&mut self, span: Option<Span>, msg: &str) -> Result<!, ErrorReported> {\n+    fn error(&mut self, span: Span, msg: &str) -> Result<!, ErrorReported> {\n         self.tcx\n             .sess\n             .struct_span_err(self.root_span(), \"overly complex generic constant\")\n-            .span_label(span.unwrap_or(self.root_span()), msg)\n+            .span_label(span, msg)\n             .help(\"consider moving this anonymous constant into a `const` function\")\n             .emit();\n \n         Err(ErrorReported)\n     }\n+    fn maybe_supported_error(&mut self, span: Span, msg: &str) -> Result<!, ErrorReported> {\n+        self.tcx\n+            .sess\n+            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n+            .span_label(span, msg)\n+            .help(\"consider moving this anonymous constant into a `const` function\")\n+            .note(\"this operation may be supported in the future\")\n+            .emit();\n+\n+        Err(ErrorReported)\n+    }\n \n     fn new(\n         tcx: TyCtxt<'tcx>,\n@@ -337,14 +348,14 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Ok(match &node.kind {\n             // I dont know if handling of these 3 is correct\n             &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n-            &ExprKind::PlaceTypeAscription { source, .. } |\n-            &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n+            &ExprKind::PlaceTypeAscription { source, .. }\n+            | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n \n             // subtle: associated consts are literals this arm handles\n             // `<T as Trait>::ASSOC` as well as `12`\n             &ExprKind::Literal { literal, .. } => self.nodes.push(Node::Leaf(literal)),\n \n-            ExprKind::Call { fun, args,  .. } => {\n+            ExprKind::Call { fun, args, .. } => {\n                 let fun = self.recurse_build(*fun)?;\n \n                 let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n@@ -353,7 +364,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 }\n                 let new_args = self.tcx.arena.alloc_slice(&new_args);\n                 self.nodes.push(Node::FunctionCall(fun, new_args))\n-            },\n+            }\n             &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n                 let lhs = self.recurse_build(lhs)?;\n                 let rhs = self.recurse_build(rhs)?;\n@@ -362,68 +373,108 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n                 let arg = self.recurse_build(arg)?;\n                 self.nodes.push(Node::UnaryOp(op, arg))\n-            },\n+            }\n             // This is necessary so that the following compiles:\n             //\n             // ```\n             // fn foo<const N: usize>(a: [(); N + 1]) {\n             //     bar::<{ N + 1 }>();\n             // }\n             // ```\n-            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. }} => self.recurse_build(*e)?,\n+            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. } } => {\n+                self.recurse_build(*e)?\n+            }\n             // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n             // \"coercion cast\" i.e. using a coercion or is a no-op.\n             // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n             &ExprKind::Use { source } => {\n                 let arg = self.recurse_build(source)?;\n                 self.nodes.push(Node::Cast(abstract_const::CastKind::Use, arg, node.ty))\n-            },\n+            }\n             &ExprKind::Cast { source } => {\n                 let arg = self.recurse_build(source)?;\n                 self.nodes.push(Node::Cast(abstract_const::CastKind::As, arg, node.ty))\n-            },\n+            }\n \n             // FIXME(generic_const_exprs): We may want to support these.\n             ExprKind::AddressOf { .. }\n             | ExprKind::Borrow { .. }\n-            | ExprKind::Deref { .. }\n-            | ExprKind::Repeat { .. }\n-            | ExprKind::Array { .. }\n-            | ExprKind::Block { .. }\n-            | ExprKind::NeverToAny { .. }\n-            | ExprKind::Tuple { .. }\n-            | ExprKind::Index { .. }\n-            | ExprKind::Field { .. }\n-            | ExprKind::ConstBlock { .. }\n-            | ExprKind::Adt(_) => self.error(\n-                    Some(node.span),\n-                    \"unsupported operation in generic constant, this may be supported in the future\",\n+            | ExprKind::Deref { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"dereferencing is not supported in generic constants\",\n+            )?,\n+            ExprKind::Repeat { .. } | ExprKind::Array { .. } =>  self.maybe_supported_error(\n+                node.span,\n+                \"array construction is not supported in generic constants\",\n+            )?,\n+            ExprKind::Block { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"blocks are not supported in generic constant\",\n+            )?,\n+            ExprKind::NeverToAny { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"converting nevers to any is not supported in generic constant\",\n+            )?,\n+            ExprKind::Tuple { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"tuple construction is not supported in generic constants\",\n+            )?,\n+            ExprKind::Index { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"indexing is not supported in generic constant\",\n+            )?,\n+            ExprKind::Field { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"field access is not supported in generic constant\",\n+            )?,\n+            ExprKind::ConstBlock { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"const blocks are not supported in generic constant\",\n+            )?,\n+            ExprKind::Adt(_) => self.maybe_supported_error(\n+                node.span,\n+                \"struct/enum construction is not supported in generic constants\",\n+            )?,\n+            // dont know if this is correct\n+            ExprKind::Pointer { .. } =>\n+                self.error(node.span, \"pointer casts are not allowed in generic constants\")?,\n+            ExprKind::Yield { .. } =>\n+                self.error(node.span, \"generator control flow is not allowed in generic constants\")?,\n+            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => self\n+                .error(\n+                    node.span,\n+                    \"loops and loop control flow are not supported in generic constants\",\n                 )?,\n+            ExprKind::Box { .. } =>\n+                self.error(node.span, \"allocations are not allowed in generic constants\")?,\n+\n+            ExprKind::Unary { .. } => unreachable!(),\n+            // we handle valid unary/binary ops above\n+            ExprKind::Binary { .. } =>\n+                self.error(node.span, \"unsupported binary operation in generic constants\")?,\n+            ExprKind::LogicalOp { .. } =>\n+                self.error(node.span, \"unsupported operation in generic constants, short-circuiting operations would imply control flow\")?,\n+            ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n+                self.error(node.span, \"assignment is not supported in generic constants\")?\n+            }\n+            ExprKind::Closure { .. } | ExprKind::Return { .. } => self.error(\n+                node.span,\n+                \"closures and function keywords are not supported in generic constants\",\n+            )?,\n+            // let expressions imply control flow\n+            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } =>\n+                self.error(node.span, \"control flow is not supported in generic constants\")?,\n+            ExprKind::LlvmInlineAsm { .. } | ExprKind::InlineAsm { .. } => {\n+                self.error(node.span, \"assembly is not supported in generic constants\")?\n+            }\n \n-            ExprKind::Match { .. }\n             // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n-            | ExprKind::VarRef { .. }\n+            ExprKind::VarRef { .. }\n             | ExprKind::UpvarRef { .. }\n-            | ExprKind::Closure { .. }\n-            | ExprKind::Let { .. } // let expressions imply control flow\n-            | ExprKind::Loop { .. }\n-            | ExprKind::Assign { .. }\n             | ExprKind::StaticRef { .. }\n-            | ExprKind::LogicalOp { .. }\n-            // we handle valid unary/binary ops above\n-            | ExprKind::Unary { .. }\n-            | ExprKind::Binary { .. }\n-            | ExprKind::Break { .. }\n-            | ExprKind::Continue { .. }\n-            | ExprKind::If { .. }\n-            | ExprKind::Pointer { .. } // dont know if this is correct\n-            | ExprKind::ThreadLocalRef(_)\n-            | ExprKind::LlvmInlineAsm { .. }\n-            | ExprKind::Return { .. }\n-            | ExprKind::Box { .. } // allocations not allowed in constants\n-            | ExprKind::AssignOp { .. }\n-            | ExprKind::InlineAsm { .. }\n-            | ExprKind::Yield { .. } => self.error(Some(node.span), \"unsupported operation in generic constant\")?,\n+            | ExprKind::ThreadLocalRef(_) => {\n+                self.error(node.span, \"unsupported operation in generic constant\")?\n+            }\n         })\n     }\n }"}, {"sha": "041232e86907954a2e70142110fd1070dad440ca", "filename": "src/test/ui/const-generics/generic_const_exprs/array-size-in-generic-struct-param.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr?ref=9cb30f465ed07debfdb95bf2457423d1445e737d", "patch": "@@ -10,9 +10,10 @@ error: overly complex generic constant\n   --> $DIR/array-size-in-generic-struct-param.rs:19:15\n    |\n LL |     arr: [u8; CFG.arr_size],\n-   |               ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |               ^^^^^^^^^^^^ field access is not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0dfd804be41b48a0c44c0cae1a396c1d0c9b249f", "filename": "src/test/ui/const-generics/generic_const_exprs/closures.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr?ref=9cb30f465ed07debfdb95bf2457423d1445e737d", "patch": "@@ -4,9 +4,10 @@ error: overly complex generic constant\n LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n    |                                   ^^^^-------^^\n    |                                       |\n-   |                                       unsupported operation in generic constant, this may be supported in the future\n+   |                                       dereferencing is not supported in generic constants\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to previous error\n "}, {"sha": "5ebb4c3999c365478c09af2842e91a67e7650ac0", "filename": "src/test/ui/const-generics/generic_const_exprs/let-bindings.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr?ref=9cb30f465ed07debfdb95bf2457423d1445e737d", "patch": "@@ -2,17 +2,19 @@ error: overly complex generic constant\n   --> $DIR/let-bindings.rs:6:68\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                                                    ^^^^^^^^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                                                    ^^^^^^^^^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: overly complex generic constant\n   --> $DIR/let-bindings.rs:6:35\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                   ^^^^^^^^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                   ^^^^^^^^^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to 2 previous errors\n "}, {"sha": "df73acf53de65f27be074845c9c0684c74628d06", "filename": "src/test/ui/const-generics/generic_const_exprs/unused_expr.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr?ref=9cb30f465ed07debfdb95bf2457423d1445e737d", "patch": "@@ -2,25 +2,28 @@ error: overly complex generic constant\n   --> $DIR/unused_expr.rs:4:34\n    |\n LL | fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n-   |                                  ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                  ^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:9:34\n    |\n LL | fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n-   |                                  ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                  ^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:16:38\n    |\n LL | fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n-   |                                      ^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                      ^^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2ee5b6a5870407d3048008222f9acb86e965fac0", "filename": "src/test/ui/const-generics/issues/issue-67375.full.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr?ref=9cb30f465ed07debfdb95bf2457423d1445e737d", "patch": "@@ -4,7 +4,7 @@ error: overly complex generic constant\n LL |     inner: [(); { [|_: &T| {}; 0].len() }],\n    |                 ^^---------------^^^^^^^^\n    |                   |\n-   |                   unsupported operation in generic constant\n+   |                   pointer casts are not allowed in generic constants\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "cce85772aa4daab36009c35920a5a90c32bfbdc7", "filename": "src/test/ui/const-generics/issues/issue-67945-2.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb30f465ed07debfdb95bf2457423d1445e737d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr?ref=9cb30f465ed07debfdb95bf2457423d1445e737d", "patch": "@@ -8,9 +8,10 @@ LL | |         let x: Option<Box<Self>> = None;\n LL | |\n LL | |         0\n LL | |     }],\n-   | |_____^ unsupported operation in generic constant, this may be supported in the future\n+   | |_____^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to previous error\n "}]}