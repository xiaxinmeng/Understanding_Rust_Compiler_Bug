{"sha": "69f0dc69a45889f58c5e13fabdd8c8eabfd604a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZjBkYzY5YTQ1ODg5ZjU4YzVlMTNmYWJkZDhjOGVhYmZkNjA0YTE=", "commit": {"author": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-02T01:15:12Z"}, "committer": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-18T22:24:35Z"}, "message": "deindent unsized suggestions\n\nMove stuff out of loops. Use early returns.", "tree": {"sha": "1e3d8570652333e80fb66d83e909dc9a2fbbf81a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e3d8570652333e80fb66d83e909dc9a2fbbf81a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69f0dc69a45889f58c5e13fabdd8c8eabfd604a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69f0dc69a45889f58c5e13fabdd8c8eabfd604a1", "html_url": "https://github.com/rust-lang/rust/commit/69f0dc69a45889f58c5e13fabdd8c8eabfd604a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69f0dc69a45889f58c5e13fabdd8c8eabfd604a1/comments", "author": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "437b2026e1bfcb1f28d838f3a2a24b23f0401b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/437b2026e1bfcb1f28d838f3a2a24b23f0401b53", "html_url": "https://github.com/rust-lang/rust/commit/437b2026e1bfcb1f28d838f3a2a24b23f0401b53"}], "stats": {"total": 126, "additions": 63, "deletions": 63}, "files": [{"sha": "1ebdb8ac26cb8a7fb2917d62f9f3561b1a9f224b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/69f0dc69a45889f58c5e13fabdd8c8eabfd604a1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f0dc69a45889f58c5e13fabdd8c8eabfd604a1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=69f0dc69a45889f58c5e13fabdd8c8eabfd604a1", "patch": "@@ -1803,51 +1803,51 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             Some(generics) => generics,\n             None => return,\n         };\n-        debug!(\"suggest_unsized_bound_if_applicable: generics.params={:?}\", generics.params);\n-        debug!(\n-            \"suggest_unsized_bound_if_applicable: generics.where_clause={:?}\",\n-            generics.where_clause\n-        );\n-        for param in generics.params {\n-            if param.span != span\n-                || param.bounds.iter().any(|bound| {\n-                    bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n-                        == self.tcx.lang_items().sized_trait()\n-                })\n-            {\n-                continue;\n-            }\n-            debug!(\"maybe_suggest_unsized_generics: param={:?}\", param);\n-            match node {\n-                hir::Node::Item(\n-                    item\n-                    @\n-                    hir::Item {\n-                        kind:\n-                            hir::ItemKind::Enum(..)\n-                            | hir::ItemKind::Struct(..)\n-                            | hir::ItemKind::Union(..),\n-                        ..\n-                    },\n-                ) => {\n-                    if self.maybe_indirection_for_unsized(err, item, param) {\n-                        return;\n-                    }\n+        let sized_trait = self.tcx.lang_items().sized_trait();\n+        debug!(\"maybe_suggest_unsized_generics: generics.params={:?}\", generics.params);\n+        debug!(\"maybe_suggest_unsized_generics: generics.where_clause={:?}\", generics.where_clause);\n+        let param = generics\n+            .params\n+            .iter()\n+            .filter(|param| param.span == span)\n+            .filter(|param| {\n+                param\n+                    .bounds\n+                    .iter()\n+                    .all(|bound| bound.trait_ref().and_then(|tr| tr.trait_def_id()) != sized_trait)\n+            })\n+            .next();\n+        let param = match param {\n+            Some(param) => param,\n+            _ => return,\n+        };\n+        debug!(\"maybe_suggest_unsized_generics: param={:?}\", param);\n+        match node {\n+            hir::Node::Item(\n+                item\n+                @\n+                hir::Item {\n+                    kind:\n+                        hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) | hir::ItemKind::Union(..),\n+                    ..\n+                },\n+            ) => {\n+                if self.maybe_indirection_for_unsized(err, item, param) {\n+                    return;\n                 }\n-                _ => {}\n             }\n-            let (span, separator) = match param.bounds {\n-                [] => (span.shrink_to_hi(), \":\"),\n-                [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n-            };\n-            err.span_suggestion_verbose(\n-                span,\n-                \"consider relaxing the implicit `Sized` restriction\",\n-                format!(\"{} ?Sized\", separator),\n-                Applicability::MachineApplicable,\n-            );\n-            return;\n-        }\n+            _ => {}\n+        };\n+        let (span, separator) = match param.bounds {\n+            [] => (span.shrink_to_hi(), \":\"),\n+            [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n+        };\n+        err.span_suggestion_verbose(\n+            span,\n+            \"consider relaxing the implicit `Sized` restriction\",\n+            format!(\"{} ?Sized\", separator),\n+            Applicability::MachineApplicable,\n+        );\n     }\n \n     fn maybe_indirection_for_unsized(\n@@ -1862,29 +1862,29 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut visitor =\n             FindTypeParam { param: param.name.ident().name, invalid_spans: vec![], nested: false };\n         visitor.visit_item(item);\n-        if !visitor.invalid_spans.is_empty() {\n-            let mut multispan: MultiSpan = param.span.into();\n+        if visitor.invalid_spans.is_empty() {\n+            return false;\n+        }\n+        let mut multispan: MultiSpan = param.span.into();\n+        multispan.push_span_label(\n+            param.span,\n+            format!(\"this could be changed to `{}: ?Sized`...\", param.name.ident()),\n+        );\n+        for sp in visitor.invalid_spans {\n             multispan.push_span_label(\n-                param.span,\n-                format!(\"this could be changed to `{}: ?Sized`...\", param.name.ident()),\n+                sp,\n+                format!(\"...if indirection were used here: `Box<{}>`\", param.name.ident()),\n             );\n-            for sp in visitor.invalid_spans {\n-                multispan.push_span_label(\n-                    sp,\n-                    format!(\"...if indirection were used here: `Box<{}>`\", param.name.ident()),\n-                );\n-            }\n-            err.span_help(\n-                multispan,\n-                &format!(\n-                    \"you could relax the implicit `Sized` bound on `{T}` if it were \\\n-                    used through indirection like `&{T}` or `Box<{T}>`\",\n-                    T = param.name.ident(),\n-                ),\n-            );\n-            return true;\n         }\n-        false\n+        err.span_help(\n+            multispan,\n+            &format!(\n+                \"you could relax the implicit `Sized` bound on `{T}` if it were \\\n+                used through indirection like `&{T}` or `Box<{T}>`\",\n+                T = param.name.ident(),\n+            ),\n+        );\n+        true\n     }\n \n     fn is_recursive_obligation("}]}