{"sha": "bfefb4d74cbd1520afaa97db1eba59c06283c696", "node_id": "C_kwDOAAsO6NoAKGJmZWZiNGQ3NGNiZDE1MjBhZmFhOTdkYjFlYmE1OWMwNjI4M2M2OTY", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-26T08:58:45Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-26T16:40:15Z"}, "message": "account for custom DSTs in valtree -> constvalue conversion", "tree": {"sha": "3bc8e0ed4f06aa3f5bf61b641973f3b3b9fe0c6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bc8e0ed4f06aa3f5bf61b641973f3b3b9fe0c6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfefb4d74cbd1520afaa97db1eba59c06283c696", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfefb4d74cbd1520afaa97db1eba59c06283c696", "html_url": "https://github.com/rust-lang/rust/commit/bfefb4d74cbd1520afaa97db1eba59c06283c696", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfefb4d74cbd1520afaa97db1eba59c06283c696/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fc3e630fb98cc6200f60ebbb7c7f826b2d48407", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc3e630fb98cc6200f60ebbb7c7f826b2d48407", "html_url": "https://github.com/rust-lang/rust/commit/6fc3e630fb98cc6200f60ebbb7c7f826b2d48407"}], "stats": {"total": 132, "additions": 123, "deletions": 9}, "files": [{"sha": "6112c4ffbfa6df84121d03d127ea175f45089af4", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfefb4d74cbd1520afaa97db1eba59c06283c696/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfefb4d74cbd1520afaa97db1eba59c06283c696/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=bfefb4d74cbd1520afaa97db1eba59c06283c696", "patch": "@@ -215,17 +215,17 @@ fn turn_into_const_value<'tcx>(\n         \"the `eval_to_const_value_raw` query should not be used for statics, use `eval_to_allocation` instead\"\n     );\n \n+    // Turn this into a proper constant.\n+    let const_val = op_to_const(&ecx, &mplace.into());\n+    debug!(?const_val);\n+\n     if cfg!(debug_assertions) {\n         if let Some(valtree) = const_to_valtree(tcx, key.param_env, constant) {\n             let const_val = tcx.valtree_to_const_val((constant.ty, valtree));\n             debug!(?const_val);\n         }\n     }\n \n-    // Turn this into a proper constant.\n-    let const_val = op_to_const(&ecx, &mplace.into());\n-    debug!(?const_val);\n-\n     const_val\n }\n "}, {"sha": "389301300ea1519c446ba44f5a35f26ad6b242b8", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 113, "deletions": 5, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/bfefb4d74cbd1520afaa97db1eba59c06283c696/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfefb4d74cbd1520afaa97db1eba59c06283c696/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=bfefb4d74cbd1520afaa97db1eba59c06283c696", "patch": "@@ -1,13 +1,13 @@\n use super::eval_queries::{mk_eval_cx, op_to_const};\n use super::machine::CompileTimeEvalContext;\n use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemoryKind, PlaceTy,\n-    Scalar, ScalarMaybeUninit,\n+    intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemPlaceMeta,\n+    MemoryKind, PlaceTy, Scalar, ScalarMaybeUninit,\n };\n use rustc_middle::mir::interpret::ConstAlloc;\n use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{Align, VariantIdx};\n \n use crate::interpret::MPlaceTy;\n use crate::interpret::Value;\n@@ -108,7 +108,9 @@ fn const_to_valtree_inner<'tcx>(\n         ty::Tuple(substs) => branches(ecx, place, substs.len(), None),\n \n         ty::Adt(def, _) => {\n-            if def.variants().is_empty() {\n+            if def.is_union() {\n+                return None\n+            } else if def.variants().is_empty() {\n                 bug!(\"uninhabited types should have errored and never gotten converted to valtree\")\n             }\n \n@@ -149,6 +151,41 @@ fn create_mplace_from_layout<'tcx>(\n     ecx.allocate(layout, MemoryKind::Stack).unwrap()\n }\n \n+// Walks custom DSTs and gets the type of the unsized field and the number of elements\n+// in the unsized field.\n+fn get_info_on_unsized_field<'tcx>(\n+    ty: Ty<'tcx>,\n+    valtree: ty::ValTree<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+) -> (Ty<'tcx>, usize) {\n+    let mut last_valtree = valtree;\n+    let tail = tcx.struct_tail_with_normalize(\n+        ty,\n+        |ty| ty,\n+        || {\n+            let branches = last_valtree.unwrap_branch();\n+            last_valtree = branches[branches.len() - 1];\n+            debug!(?branches, ?last_valtree);\n+        },\n+    );\n+    let unsized_inner_ty = match tail.kind() {\n+        ty::Slice(t) => *t,\n+        ty::Str => tail,\n+        _ => bug!(\"expected Slice or Str\"),\n+    };\n+\n+    // Have to adjust type for ty::Str\n+    let unsized_inner_ty = match unsized_inner_ty.kind() {\n+        ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n+        _ => unsized_inner_ty,\n+    };\n+\n+    // Get the number of elements in the unsized field\n+    let num_elems = last_valtree.unwrap_branch().len();\n+\n+    (unsized_inner_ty, num_elems)\n+}\n+\n #[instrument(skip(ecx), level = \"debug\")]\n fn create_pointee_place<'tcx>(\n     ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n@@ -173,6 +210,33 @@ fn create_pointee_place<'tcx>(\n \n             place\n         }\n+        ty::Adt(_, _) if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) => {\n+            // We need to create `Allocation`s for custom DSTs\n+\n+            let layout = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap();\n+            let sized_fields_size = layout.layout.size();\n+            let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n+            let unsized_inner_ty_size =\n+                tcx.layout_of(ty::ParamEnv::empty().and(unsized_inner_ty)).unwrap().layout.size();\n+            debug!(?unsized_inner_ty, ?unsized_inner_ty_size, ?num_elems);\n+\n+            // Get the size of the array behind the DST\n+            let dst_size = unsized_inner_ty_size.checked_mul(num_elems as u64, &tcx).unwrap();\n+\n+            let ptr = ecx\n+                .allocate_ptr(\n+                    sized_fields_size.checked_add(dst_size, &tcx).unwrap(),\n+                    Align::from_bytes(1).unwrap(),\n+                    MemoryKind::Stack,\n+                )\n+                .unwrap();\n+            debug!(?ptr);\n+\n+            let place = MPlaceTy::from_aligned_ptr(ptr.into(), layout);\n+            debug!(?place);\n+\n+            place\n+        }\n         _ => create_mplace_from_layout(ecx, ty),\n     }\n }\n@@ -270,6 +334,13 @@ fn fill_place_recursively<'tcx>(\n     let ty = place.layout.ty;\n \n     match ty.kind() {\n+        ty::FnDef(_, _) => {\n+            ecx.write_immediate(\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::ZST)),\n+                &(*place).into(),\n+            )\n+            .unwrap();\n+        }\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n             let scalar_int = valtree.unwrap_leaf();\n             debug!(\"writing trivial valtree {:?} to place {:?}\", scalar_int, place);\n@@ -306,6 +377,9 @@ fn fill_place_recursively<'tcx>(\n         ty::Adt(_, _) | ty::Tuple(_) | ty::Array(_, _) | ty::Str => {\n             let branches = valtree.unwrap_branch();\n \n+            // Need to collect the length of the unsized field for meta info\n+            let mut unsized_meta_info = None;\n+\n             // Need to downcast place for enums\n             let (place_adjusted, branches, variant_idx) = match ty.kind() {\n                 ty::Adt(def, _) if def.is_enum() => {\n@@ -329,6 +403,35 @@ fn fill_place_recursively<'tcx>(\n             for (i, inner_valtree) in branches.iter().enumerate() {\n                 debug!(?i, ?inner_valtree);\n \n+                if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) && i == branches.len() - 1 {\n+                    // Note: For custom DSTs we need to manually process the last unsized field.\n+                    // We created a `Pointer` for the `Allocation` of the complete sized version of\n+                    // the Adt in `create_pointee_place` and now we fill that `Allocation` with the\n+                    // values in the ValTree. For the unsized field we have to additionally add the meta\n+                    // data.\n+\n+                    let offset = place.layout.fields.offset(i);\n+                    let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n+                    unsized_meta_info = Some(num_elems);\n+\n+                    // We create an array type to allow the recursive call to fill the place\n+                    // corresponding to the array\n+                    let arr_ty = tcx.mk_array(unsized_inner_ty, num_elems as u64);\n+                    debug!(?arr_ty);\n+                    let arr_layout = tcx.layout_of(ty::ParamEnv::empty().and(arr_ty)).unwrap();\n+                    let mut place_arr =\n+                        place.offset(offset, MemPlaceMeta::None, arr_layout, &tcx).unwrap();\n+                    debug!(?place_arr);\n+\n+                    fill_place_recursively(ecx, &mut place_arr, *inner_valtree);\n+                    dump_place(&ecx, place_arr.into());\n+\n+                    // Add the meta information for the unsized type\n+                    place_arr.meta = MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64));\n+\n+                    break;\n+                }\n+\n                 let mut place_inner = match *ty.kind() {\n                     ty::Adt(_, _) | ty::Tuple(_) => ecx.mplace_field(&place_adjusted, i).unwrap(),\n                     ty::Array(_, _) | ty::Str => {\n@@ -338,7 +441,6 @@ fn fill_place_recursively<'tcx>(\n                 };\n                 debug!(?place_inner);\n \n-                // insert valtree corresponding to tuple element into place\n                 fill_place_recursively(ecx, &mut place_inner, *inner_valtree);\n                 dump_place(&ecx, place_inner.into());\n             }\n@@ -351,6 +453,12 @@ fn fill_place_recursively<'tcx>(\n                 ecx.write_discriminant(variant_idx, &(*place).into()).unwrap();\n             }\n \n+            // add meta information for unsized type\n+            if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) {\n+                place.meta =\n+                    MemPlaceMeta::Meta(Scalar::from_u64(unsized_meta_info.unwrap() as u64));\n+            }\n+\n             dump_place(ecx, (*place).into());\n         }\n         _ => bug!(\"shouldn't have created a ValTree for {:?}\", ty),"}, {"sha": "380eb5263618b5f26b6bba3681e4d44c770d5704", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfefb4d74cbd1520afaa97db1eba59c06283c696/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfefb4d74cbd1520afaa97db1eba59c06283c696/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=bfefb4d74cbd1520afaa97db1eba59c06283c696", "patch": "@@ -115,6 +115,12 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n     }\n }\n \n+impl<'tcx, Tag: Provenance> std::ops::DerefMut for MPlaceTy<'tcx, Tag> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.mplace\n+    }\n+}\n+\n impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {"}]}