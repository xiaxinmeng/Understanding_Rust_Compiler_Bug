{"sha": "ff055e2135574a0b795c0bc03144a89b54351af7", "node_id": "C_kwDOAAsO6NoAKGZmMDU1ZTIxMzU1NzRhMGI3OTVjMGJjMDMxNDRhODliNTQzNTFhZjc", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-10-03T22:14:33Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-07T04:00:34Z"}, "message": "Ensure closure requirements are proven for inline const", "tree": {"sha": "ce737142c055aadbe4503c803c6bf664ec8373ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce737142c055aadbe4503c803c6bf664ec8373ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff055e2135574a0b795c0bc03144a89b54351af7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff055e2135574a0b795c0bc03144a89b54351af7", "html_url": "https://github.com/rust-lang/rust/commit/ff055e2135574a0b795c0bc03144a89b54351af7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff055e2135574a0b795c0bc03144a89b54351af7/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d32b201707ce6327c0ab322c4e06d8e0367f563", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d32b201707ce6327c0ab322c4e06d8e0367f563", "html_url": "https://github.com/rust-lang/rust/commit/1d32b201707ce6327c0ab322c4e06d8e0367f563"}], "stats": {"total": 132, "additions": 127, "deletions": 5}, "files": [{"sha": "890f1235a9d43c0d6cc5c60cf012099c80d70a27", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 79, "deletions": 5, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ff055e2135574a0b795c0bc03144a89b54351af7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff055e2135574a0b795c0bc03144a89b54351af7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=ff055e2135574a0b795c0bc03144a89b54351af7", "patch": "@@ -10,6 +10,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -1532,6 +1533,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n+                self.check_operand(discr, term_location);\n+\n                 let discr_ty = discr.ty(body, tcx);\n                 if let Err(terr) = self.sub_types(\n                     discr_ty,\n@@ -1554,6 +1557,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // FIXME: check the values\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, from_hir_call, .. } => {\n+                self.check_operand(func, term_location);\n+                for arg in args {\n+                    self.check_operand(arg, term_location);\n+                }\n+\n                 let func_ty = func.ty(body, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.kind() {\n@@ -1598,6 +1606,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_inputs(body, term, &sig, args, term_location, from_hir_call);\n             }\n             TerminatorKind::Assert { ref cond, ref msg, .. } => {\n+                self.check_operand(cond, term_location);\n+\n                 let cond_ty = cond.ty(body, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n@@ -1613,6 +1623,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Yield { ref value, .. } => {\n+                self.check_operand(value, term_location);\n+\n                 let value_ty = value.ty(body, tcx);\n                 match body.yield_ty() {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n@@ -1941,15 +1953,51 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n+    fn check_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n+        if let Operand::Constant(constant) = op {\n+            let maybe_uneval = match constant.literal {\n+                ConstantKind::Ty(ct) => match ct.val {\n+                    ty::ConstKind::Unevaluated(uv) => Some(uv),\n+                    _ => None,\n+                },\n+                _ => None,\n+            };\n+            if let Some(uv) = maybe_uneval {\n+                if uv.promoted.is_none() {\n+                    let tcx = self.tcx();\n+                    let def_id = uv.def.def_id_for_type_of();\n+                    if tcx.def_kind(def_id) == DefKind::InlineConst {\n+                        let predicates = self.prove_closure_bounds(\n+                            tcx,\n+                            def_id.expect_local(),\n+                            uv.substs(tcx),\n+                            location,\n+                        );\n+                        self.normalize_and_prove_instantiated_predicates(\n+                            def_id,\n+                            predicates,\n+                            location.to_locations(),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn check_rvalue(&mut self, body: &Body<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         let tcx = self.tcx();\n \n         match rvalue {\n             Rvalue::Aggregate(ak, ops) => {\n+                for op in ops {\n+                    self.check_operand(op, location);\n+                }\n                 self.check_aggregate_rvalue(&body, rvalue, ak, ops, location)\n             }\n \n             Rvalue::Repeat(operand, len) => {\n+                self.check_operand(operand, location);\n+\n                 // If the length cannot be evaluated we must assume that the length can be larger\n                 // than 1.\n                 // If the length is larger than 1, the repeat expression will need to copy the\n@@ -2000,7 +2048,22 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n \n-            Rvalue::NullaryOp(_, ty) | Rvalue::ShallowInitBox(_, ty) => {\n+            Rvalue::NullaryOp(_, ty) => {\n+                let trait_ref = ty::TraitRef {\n+                    def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n+                    substs: tcx.mk_substs_trait(ty, &[]),\n+                };\n+\n+                self.prove_trait_ref(\n+                    trait_ref,\n+                    location.to_locations(),\n+                    ConstraintCategory::SizedBound,\n+                );\n+            }\n+\n+            Rvalue::ShallowInitBox(operand, ty) => {\n+                self.check_operand(operand, location);\n+\n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n                     substs: tcx.mk_substs_trait(ty, &[]),\n@@ -2014,6 +2077,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             Rvalue::Cast(cast_kind, op, ty) => {\n+                self.check_operand(op, location);\n+\n                 match cast_kind {\n                     CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n                         let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n@@ -2260,6 +2325,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge,\n                 box (left, right),\n             ) => {\n+                self.check_operand(left, location);\n+                self.check_operand(right, location);\n+\n                 let ty_left = left.ty(body, tcx);\n                 match ty_left.kind() {\n                     // Types with regions are comparable if they have a common super-type.\n@@ -2310,13 +2378,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n \n+            Rvalue::Use(operand) | Rvalue::UnaryOp(_, operand) => {\n+                self.check_operand(operand, location);\n+            }\n+\n+            Rvalue::BinaryOp(_, box (left, right))\n+            | Rvalue::CheckedBinaryOp(_, box (left, right)) => {\n+                self.check_operand(left, location);\n+                self.check_operand(right, location);\n+            }\n+\n             Rvalue::AddressOf(..)\n             | Rvalue::ThreadLocalRef(..)\n-            | Rvalue::Use(..)\n             | Rvalue::Len(..)\n-            | Rvalue::BinaryOp(..)\n-            | Rvalue::CheckedBinaryOp(..)\n-            | Rvalue::UnaryOp(..)\n             | Rvalue::Discriminant(..) => {}\n         }\n     }"}, {"sha": "e56cbc94038a01c3fe8774f65e4a2186c23dd34c", "filename": "src/test/ui/inline-const/const-expr-lifetime-err.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ff055e2135574a0b795c0bc03144a89b54351af7/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-lifetime-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff055e2135574a0b795c0bc03144a89b54351af7/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-lifetime-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-lifetime-err.rs?ref=ff055e2135574a0b795c0bc03144a89b54351af7", "patch": "@@ -0,0 +1,30 @@\n+#![allow(incomplete_features)]\n+#![feature(const_mut_refs)]\n+#![feature(inline_const)]\n+\n+use std::marker::PhantomData;\n+\n+#[derive(PartialEq, Eq)]\n+pub struct InvariantRef<'a, T: ?Sized>(&'a T, PhantomData<&'a mut &'a T>);\n+\n+impl<'a, T: ?Sized> InvariantRef<'a, T> {\n+    pub const fn new(r: &'a T) -> Self {\n+        InvariantRef(r, PhantomData)\n+    }\n+}\n+\n+impl<'a> InvariantRef<'a, ()> {\n+    pub const NEW: Self = InvariantRef::new(&());\n+}\n+\n+fn equate<T>(x: T, y: T){}\n+\n+fn foo<'a>() {\n+    let y = ();\n+    equate(InvariantRef::new(&y), const { InvariantRef::<'a>::NEW });\n+    //~^ ERROR `y` does not live long enough [E0597]\n+}\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "30ecd338a856d7c93cc9acf2fc5420b8039b24b4", "filename": "src/test/ui/inline-const/const-expr-lifetime-err.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff055e2135574a0b795c0bc03144a89b54351af7/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-lifetime-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff055e2135574a0b795c0bc03144a89b54351af7/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-lifetime-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-lifetime-err.stderr?ref=ff055e2135574a0b795c0bc03144a89b54351af7", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: `y` does not live long enough\n+  --> $DIR/const-expr-lifetime-err.rs:24:30\n+   |\n+LL | fn foo<'a>() {\n+   |        -- lifetime `'a` defined here\n+LL |     let y = ();\n+LL |     equate(InvariantRef::new(&y), const { InvariantRef::<'a>::NEW });\n+   |            ------------------^^-\n+   |            |                 |\n+   |            |                 borrowed value does not live long enough\n+   |            argument requires that `y` is borrowed for `'a`\n+LL |\n+LL | }\n+   | - `y` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}]}