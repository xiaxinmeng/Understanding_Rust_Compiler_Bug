{"sha": "7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMTQzYjE1NGU3YzQ3YjFmNWJkYzU1OGJiMGI1ZDFmMmJmNzRmOGQ=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-21T12:32:02Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-21T12:32:02Z"}, "message": "Merge branch 'master' of github.com:rust-analyzer/rust-analyzer", "tree": {"sha": "571b7d5bdfc84bdaeaa8235221fd96a87453fe05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/571b7d5bdfc84bdaeaa8235221fd96a87453fe05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "html_url": "https://github.com/rust-lang/rust/commit/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c3a1385a587f0713908c0ae888ffad31f13de11", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c3a1385a587f0713908c0ae888ffad31f13de11", "html_url": "https://github.com/rust-lang/rust/commit/1c3a1385a587f0713908c0ae888ffad31f13de11"}, {"sha": "a88887df0726cc3d390db4bfbbc1274195d87f91", "url": "https://api.github.com/repos/rust-lang/rust/commits/a88887df0726cc3d390db4bfbbc1274195d87f91", "html_url": "https://github.com/rust-lang/rust/commit/a88887df0726cc3d390db4bfbbc1274195d87f91"}], "stats": {"total": 1498, "additions": 1076, "deletions": 422}, "files": [{"sha": "37455bc57ba41f9e6cda1a7e9956710b670b1087", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -114,7 +114,7 @@ checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -125,7 +125,7 @@ dependencies = [\n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n dependencies = [\n  \"chalk-macros\",\n  \"rustc-hash\",\n@@ -134,7 +134,7 @@ dependencies = [\n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -144,15 +144,15 @@ dependencies = [\n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n dependencies = [\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -163,7 +163,7 @@ dependencies = [\n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=2c072cc830d04af5f10b390e6643327f85108282#2c072cc830d04af5f10b390e6643327f85108282\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -1288,9 +1288,9 @@ checksum = \"2439c63f3f6139d1b57529d16bc3b8bb855230c8efcc5d3a896c8bea7c3b1e84\"\n \n [[package]]\n name = \"regex\"\n-version = \"1.3.6\"\n+version = \"1.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7f6946991529684867e47d86474e3a6d0c0ab9b82d5821e314b1ede31fa3a4b3\"\n+checksum = \"a6020f034922e3194c711b82a627453881bc4682166cabb07134a10c26ba7692\"\n dependencies = [\n  \"aho-corasick\",\n  \"memchr\","}, {"sha": "0621487e8f7e97666cacef033f5f6e0b2fd32b74", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -98,7 +98,7 @@ fn already_has_from_impl(\n     };\n     let var_ty = hir_enum_var.fields(sema.db)[0].signature_ty(sema.db);\n \n-    e_ty.impls_trait(sema.db, from_trait, &[var_ty.clone()])\n+    e_ty.impls_trait(sema.db, from_trait, &[var_ty])\n }\n \n #[cfg(test)]"}, {"sha": "8c09e6bcd063ae40fa848c2648f3d6562fca8340", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -124,7 +124,7 @@ fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n             }\n         }\n \n-        if ast::Stmt::cast(node.clone().into()).is_some() {\n+        if ast::Stmt::cast(node.clone()).is_some() {\n             return Some((node, false));\n         }\n "}, {"sha": "4be1238f146d2b3cb00bb485dbde6cfdad478276", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n             .filter_map(|dir| neighbor(&use_item, dir))\n             .filter_map(|it| Some((it.clone(), it.use_tree()?)))\n             .find_map(|(use_item, use_tree)| {\n-                Some((try_merge_trees(&tree, &use_tree)?, use_item.clone()))\n+                Some((try_merge_trees(&tree, &use_tree)?, use_item))\n             })?;\n \n         rewriter.replace_ast(&tree, &merged);"}, {"sha": "f25826796317ef3412f62ca184c397d89aa5afed", "filename": "crates/ra_assists/src/handlers/split_import.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -37,7 +37,7 @@ pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_target};\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n \n@@ -63,4 +63,9 @@ mod tests {\n     fn split_import_target() {\n         check_assist_target(split_import, \"use crate::<|>db::{RootDatabase, FileSymbol}\", \"::\");\n     }\n+\n+    #[test]\n+    fn issue4044() {\n+        check_assist_not_applicable(split_import, \"use crate::<|>:::self;\")\n+    }\n }"}, {"sha": "8248684eeac172822032e362a8677af2d61b894f", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -235,7 +235,7 @@ fn parse_meta(meta: &str) -> ParsedMeta {\n             \"env\" => {\n                 for key in value.split(',') {\n                     if let Some((k, v)) = split1(key, '=') {\n-                        env.set(k.into(), v.into());\n+                        env.set(k, v.into());\n                     }\n                 }\n             }"}, {"sha": "ab14e2d5e64d5d771c193324003617f6a7b26fbf", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -327,7 +327,7 @@ impl ExternSource {\n         self.extern_paths.iter().find_map(|(root_path, id)| {\n             if let Ok(rel_path) = path.strip_prefix(root_path) {\n                 let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n-                Some((id.clone(), rel_path))\n+                Some((*id, rel_path))\n             } else {\n                 None\n             }"}, {"sha": "6e0d89466bdbf14424fbbb8680301e9521b4f51c", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -759,6 +759,17 @@ impl MacroDef {\n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         self.source(db).value.name().map(|it| it.as_name())\n     }\n+\n+    /// Indicate it is a proc-macro\n+    pub fn is_proc_macro(&self) -> bool {\n+        match self.id.kind {\n+            hir_expand::MacroDefKind::Declarative => false,\n+            hir_expand::MacroDefKind::BuiltIn(_) => false,\n+            hir_expand::MacroDefKind::BuiltInDerive(_) => false,\n+            hir_expand::MacroDefKind::BuiltInEager(_) => false,\n+            hir_expand::MacroDefKind::CustomDerive(_) => true,\n+        }\n+    }\n }\n \n /// Invariant: `inner.as_assoc_item(db).is_some()`"}, {"sha": "5d6edc45c8ce37695fad6ae5a07acb9941ebf646", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -195,6 +195,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.analyze(field.syntax()).resolve_record_field(self.db, field)\n     }\n \n+    pub fn resolve_record_field_pat(&self, field: &ast::RecordFieldPat) -> Option<StructField> {\n+        self.analyze(field.syntax()).resolve_record_field_pat(self.db, field)\n+    }\n+\n     pub fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<MacroDef> {\n         let sa = self.analyze(macro_call.syntax());\n         let macro_call = self.find_file(macro_call.syntax().clone()).with_value(macro_call);"}, {"sha": "0ed6d0958065e46ded351dd21fa4a22799326c57", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -95,6 +95,7 @@ impl SourceAnalyzer {\n     }\n \n     fn pat_id(&self, pat: &ast::Pat) -> Option<PatId> {\n+        // FIXME: macros, see `expr_id`\n         let src = InFile { file_id: self.file_id, value: pat };\n         self.body_source_map.as_ref()?.node_pat(src)\n     }\n@@ -167,6 +168,16 @@ impl SourceAnalyzer {\n         Some((struct_field.into(), local))\n     }\n \n+    pub(crate) fn resolve_record_field_pat(\n+        &self,\n+        _db: &dyn HirDatabase,\n+        field: &ast::RecordFieldPat,\n+    ) -> Option<StructField> {\n+        let pat_id = self.pat_id(&field.pat()?)?;\n+        let struct_field = self.infer.as_ref()?.record_field_pat_resolution(pat_id)?;\n+        Some(struct_field.into())\n+    }\n+\n     pub(crate) fn resolve_macro_call(\n         &self,\n         db: &dyn HirDatabase,"}, {"sha": "0caedd8d852e0e69ef64eaf5dd04c3003aa5b424", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -473,16 +473,14 @@ impl ExprCollector<'_> {\n         self.collect_block_items(&block);\n         let statements = block\n             .statements()\n-            .filter_map(|s| match s {\n+            .map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    Some(Statement::Let { pat, type_ref, initializer })\n-                }\n-                ast::Stmt::ExprStmt(stmt) => {\n-                    Some(Statement::Expr(self.collect_expr_opt(stmt.expr())))\n+                    Statement::Let { pat, type_ref, initializer }\n                 }\n+                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));"}, {"sha": "fe4137176f14bad599fbbfa6817124a9586bf2e4", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -157,6 +157,10 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             for arm in arms {\n                 let scope = scopes.new_scope(scope);\n                 scopes.add_bindings(body, scope, arm.pat);\n+                if let Some(guard) = arm.guard {\n+                    scopes.set_scope(guard, scope);\n+                    compute_expr_scopes(guard, body, scopes, scope);\n+                }\n                 scopes.set_scope(arm.expr, scope);\n                 compute_expr_scopes(arm.expr, body, scopes, scope);\n             }"}, {"sha": "d19569245e0b387483ebaf4ef4367c9d06880539", "filename": "crates/ra_hir_expand/src/ast_id_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -66,7 +66,7 @@ impl AstIdMap {\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching.\n         bfs(node, |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it.clone()) {\n+            if let Some(module_item) = ast::ModuleItem::cast(it) {\n                 res.alloc(module_item.syntax());\n             }\n         });"}, {"sha": "3da137f2e65f8a8a137ed0121c39c99c08a9015e", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -301,7 +301,7 @@ fn relative_file(db: &dyn AstDatabase, call_id: MacroCallId, path: &str) -> Opti\n     }\n \n     // Extern paths ?\n-    let krate = db.relevant_crates(call_site).get(0)?.clone();\n+    let krate = *db.relevant_crates(call_site).get(0)?;\n     let (extern_source_id, relative_file) =\n         db.crate_graph()[krate].extern_source.extern_path(path)?;\n \n@@ -329,7 +329,7 @@ fn include_expand(\n \n     // FIXME:\n     // Handle include as expression\n-    let res = parse_to_token_tree(&db.file_text(file_id.into()))\n+    let res = parse_to_token_tree(&db.file_text(file_id))\n         .ok_or_else(|| mbe::ExpandError::ConversionError)?\n         .0;\n \n@@ -340,7 +340,7 @@ fn get_env_inner(db: &dyn AstDatabase, arg_id: EagerMacroId, key: &str) -> Optio\n     let call_id: MacroCallId = arg_id.into();\n     let original_file = call_id.as_file().original_file(db);\n \n-    let krate = db.relevant_crates(original_file).get(0)?.clone();\n+    let krate = *db.relevant_crates(original_file).get(0)?;\n     db.crate_graph()[krate].env.get(key)\n }\n \n@@ -447,7 +447,7 @@ mod tests {\n                     file_id: file_id.into(),\n                 };\n \n-                let id: MacroCallId = db.intern_eager_expansion(eager.into()).into();\n+                let id: MacroCallId = db.intern_eager_expansion(eager).into();\n                 id.as_file()\n             }\n         };"}, {"sha": "04d3cd6a2795ca4e03a2ee19ee793714a8e700dd", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -27,9 +27,9 @@ test_utils = { path = \"../test_utils\" }\n \n scoped-tls = \"1\"\n \n-chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\" }\n-chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\" }\n+chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"2c072cc830d04af5f10b390e6643327f85108282\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"2c072cc830d04af5f10b390e6643327f85108282\" }\n+chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"2c072cc830d04af5f10b390e6643327f85108282\" }\n \n [dev-dependencies]\n insta = \"0.16.0\""}, {"sha": "779e7857458a476a81588821a90b0300e2f46fb2", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 304, "deletions": 32, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -235,10 +235,19 @@ impl From<PatId> for PatIdOrWild {\n     }\n }\n \n+impl From<&PatId> for PatIdOrWild {\n+    fn from(pat_id: &PatId) -> Self {\n+        Self::PatId(*pat_id)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq)]\n pub enum MatchCheckErr {\n     NotImplemented,\n     MalformedMatchArm,\n+    /// Used when type inference cannot resolve the type of\n+    /// a pattern or expression.\n+    Unknown,\n }\n \n /// The return type of `is_useful` is either an indication of usefulness\n@@ -290,10 +299,14 @@ impl PatStack {\n         Self::from_slice(&self.0[1..])\n     }\n \n-    fn replace_head_with<T: Into<PatIdOrWild> + Copy>(&self, pat_ids: &[T]) -> PatStack {\n+    fn replace_head_with<I, T>(&self, pats: I) -> PatStack\n+    where\n+        I: Iterator<Item = T>,\n+        T: Into<PatIdOrWild>,\n+    {\n         let mut patterns: PatStackInner = smallvec![];\n-        for pat in pat_ids {\n-            patterns.push((*pat).into());\n+        for pat in pats {\n+            patterns.push(pat.into());\n         }\n         for pat in &self.0[1..] {\n             patterns.push(*pat);\n@@ -330,7 +343,7 @@ impl PatStack {\n                     return Err(MatchCheckErr::NotImplemented);\n                 }\n \n-                Some(self.replace_head_with(pat_ids))\n+                Some(self.replace_head_with(pat_ids.iter()))\n             }\n             (Pat::Lit(lit_expr), Constructor::Bool(constructor_val)) => {\n                 match cx.body.exprs[lit_expr] {\n@@ -382,21 +395,49 @@ impl PatStack {\n                                 new_patterns.push((*pat_id).into());\n                             }\n \n-                            Some(self.replace_head_with(&new_patterns))\n+                            Some(self.replace_head_with(new_patterns.into_iter()))\n                         } else {\n                             return Err(MatchCheckErr::MalformedMatchArm);\n                         }\n                     } else {\n                         // If there is no ellipsis in the tuple pattern, the number\n                         // of patterns must equal the constructor arity.\n                         if pat_ids.len() == constructor_arity {\n-                            Some(self.replace_head_with(pat_ids))\n+                            Some(self.replace_head_with(pat_ids.into_iter()))\n                         } else {\n                             return Err(MatchCheckErr::MalformedMatchArm);\n                         }\n                     }\n                 }\n             }\n+            (Pat::Record { args: ref arg_patterns, .. }, Constructor::Enum(e)) => {\n+                let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n+                if !enum_variant_matches(cx, pat_id, *e) {\n+                    None\n+                } else {\n+                    match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n+                        VariantData::Record(struct_field_arena) => {\n+                            // Here we treat any missing fields in the record as the wild pattern, as\n+                            // if the record has ellipsis. We want to do this here even if the\n+                            // record does not contain ellipsis, because it allows us to continue\n+                            // enforcing exhaustiveness for the rest of the match statement.\n+                            //\n+                            // Creating the diagnostic for the missing field in the pattern\n+                            // should be done in a different diagnostic.\n+                            let patterns = struct_field_arena.iter().map(|(_, struct_field)| {\n+                                arg_patterns\n+                                    .iter()\n+                                    .find(|pat| pat.name == struct_field.name)\n+                                    .map(|pat| PatIdOrWild::from(pat.pat))\n+                                    .unwrap_or(PatIdOrWild::Wild)\n+                            });\n+\n+                            Some(self.replace_head_with(patterns))\n+                        }\n+                        _ => return Err(MatchCheckErr::Unknown),\n+                    }\n+                }\n+            }\n             (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n             (_, _) => return Err(MatchCheckErr::NotImplemented),\n         };\n@@ -655,8 +696,8 @@ impl Constructor {\n             Constructor::Enum(e) => {\n                 match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n                     VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n+                    VariantData::Record(struct_field_data) => struct_field_data.len(),\n                     VariantData::Unit => 0,\n-                    _ => return Err(MatchCheckErr::NotImplemented),\n                 }\n             }\n         };\n@@ -695,10 +736,10 @@ fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Opt\n             Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n             _ => return Err(MatchCheckErr::NotImplemented),\n         },\n-        Pat::TupleStruct { .. } | Pat::Path(_) => {\n+        Pat::TupleStruct { .. } | Pat::Path(_) | Pat::Record { .. } => {\n             let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n             let variant_id =\n-                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckErr::NotImplemented)?;\n+                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckErr::Unknown)?;\n             match variant_id {\n                 VariantId::EnumVariantId(enum_variant_id) => {\n                     Some(Constructor::Enum(enum_variant_id))\n@@ -759,20 +800,22 @@ mod tests {\n     pub(super) use insta::assert_snapshot;\n     pub(super) use ra_db::fixture::WithFixture;\n \n-    pub(super) use crate::test_db::TestDB;\n+    pub(super) use crate::{diagnostics::MissingMatchArms, test_db::TestDB};\n \n     pub(super) fn check_diagnostic_message(content: &str) -> String {\n-        TestDB::with_single_file(content).0.diagnostics().0\n+        TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().0\n     }\n \n     pub(super) fn check_diagnostic(content: &str) {\n-        let diagnostic_count = TestDB::with_single_file(content).0.diagnostics().1;\n+        let diagnostic_count =\n+            TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().1;\n \n         assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n     }\n \n     pub(super) fn check_no_diagnostic(content: &str) {\n-        let diagnostic_count = TestDB::with_single_file(content).0.diagnostics().1;\n+        let diagnostic_count =\n+            TestDB::with_single_file(content).0.diagnostic::<MissingMatchArms>().1;\n \n         assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one\");\n     }\n@@ -1531,6 +1574,236 @@ mod tests {\n         check_no_diagnostic(content);\n     }\n \n+    #[test]\n+    fn enum_record_no_arms() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_missing_arms() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { foo: true } => (),\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { foo: true } => (),\n+                    Either::A { foo: false } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_missing_field_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::B;\n+                match a {\n+                    Either::A { } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        // When `Either::A` is missing a struct member, we don't want\n+        // to fire the missing match arm diagnostic. This should fire\n+        // some other diagnostic.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_missing_field_missing_match_arm() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::B;\n+                match a {\n+                    Either::A { } => (),\n+                }\n+            }\n+        \";\n+\n+        // Even though `Either::A` is missing fields, we still want to fire\n+        // the missing arm diagnostic here, since we know `Either::B` is missing.\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_no_diagnostic_wild() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { foo: _ } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_fields_out_of_order_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool, bar: () },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { bar: (), foo: false } => (),\n+                    Either::A { foo: true, bar: () } => (),\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_fields_out_of_order_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: bool, bar: () },\n+                B,\n+            }\n+            fn test_fn() {\n+                let a = Either::A { foo: true };\n+                match a {\n+                    Either::A { bar: (), foo: false } => (),\n+                    Either::A { foo: true, bar: () } => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis_missing_arm() {\n+        let content = r\"\n+             enum Either {\n+                 A { foo: bool, bar: bool },\n+                 B,\n+             }\n+             fn test_fn() {\n+                 match Either::B {\n+                     Either::A { foo: true, .. } => (),\n+                     Either::B => (),\n+                 }\n+             }\n+         \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis_no_diagnostic() {\n+        let content = r\"\n+             enum Either {\n+                 A { foo: bool, bar: bool },\n+                 B,\n+             }\n+             fn test_fn() {\n+                 let a = Either::A { foo: true };\n+                 match a {\n+                     Either::A { foo: true, .. } => (),\n+                     Either::A { foo: false, .. } => (),\n+                     Either::B => (),\n+                 }\n+             }\n+         \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis_all_fields_missing_arm() {\n+        let content = r\"\n+             enum Either {\n+                 A { foo: bool, bar: bool },\n+                 B,\n+             }\n+             fn test_fn() {\n+                 let a = Either::B;\n+                 match a {\n+                     Either::A { .. } => (),\n+                 }\n+             }\n+         \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis_all_fields_no_diagnostic() {\n+        let content = r\"\n+             enum Either {\n+                 A { foo: bool, bar: bool },\n+                 B,\n+             }\n+             fn test_fn() {\n+                 let a = Either::B;\n+                 match a {\n+                     Either::A { .. } => (),\n+                     Either::B => (),\n+                 }\n+             }\n+         \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn enum_tuple_partial_ellipsis_no_diagnostic() {\n         let content = r\"\n@@ -1688,25 +1961,6 @@ mod false_negatives {\n         check_no_diagnostic(content);\n     }\n \n-    #[test]\n-    fn enum_record() {\n-        let content = r\"\n-            enum Either {\n-                A { foo: u32 },\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A { foo: 5 } => (),\n-                }\n-            }\n-        \";\n-\n-        // This is a false negative.\n-        // We don't currently handle enum record types.\n-        check_no_diagnostic(content);\n-    }\n-\n     #[test]\n     fn internal_or() {\n         let content = r\"\n@@ -1796,4 +2050,22 @@ mod false_negatives {\n         // We don't currently handle tuple patterns with ellipsis.\n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn struct_missing_arm() {\n+        let content = r\"\n+            struct Foo {\n+                a: bool,\n+            }\n+            fn test_fn(f: Foo) {\n+                match f {\n+                    Foo { a: true } => {},\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently handle structs.\n+        check_no_diagnostic(content);\n+    }\n }"}, {"sha": "9e5dfeab3cddb5686cbf7fb018a7349324f6bace", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -107,6 +107,13 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n         krate: CrateId,\n         goal: crate::Canonical<crate::InEnvironment<crate::Obligation>>,\n     ) -> Option<crate::traits::Solution>;\n+\n+    #[salsa::invoke(crate::traits::chalk::program_clauses_for_chalk_env_query)]\n+    fn program_clauses_for_chalk_env(\n+        &self,\n+        krate: CrateId,\n+        env: chalk_ir::Environment<chalk::Interner>,\n+    ) -> chalk_ir::ProgramClauses<chalk::Interner>;\n }\n \n fn infer_wait(db: &impl HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {"}, {"sha": "dfb6a435fff1e33da376a895bd2397f8241bfa10", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -127,6 +127,7 @@ pub struct InferenceResult {\n     field_resolutions: FxHashMap<ExprId, StructFieldId>,\n     /// For each field in record literal, records the field it resolves to.\n     record_field_resolutions: FxHashMap<ExprId, StructFieldId>,\n+    record_field_pat_resolutions: FxHashMap<PatId, StructFieldId>,\n     /// For each struct literal, records the variant it resolves to.\n     variant_resolutions: FxHashMap<ExprOrPatId, VariantId>,\n     /// For each associated item record what it resolves to\n@@ -147,6 +148,9 @@ impl InferenceResult {\n     pub fn record_field_resolution(&self, expr: ExprId) -> Option<StructFieldId> {\n         self.record_field_resolutions.get(&expr).copied()\n     }\n+    pub fn record_field_pat_resolution(&self, pat: PatId) -> Option<StructFieldId> {\n+        self.record_field_pat_resolutions.get(&pat).copied()\n+    }\n     pub fn variant_resolution_for_expr(&self, id: ExprId) -> Option<VariantId> {\n         self.variant_resolutions.get(&id.into()).copied()\n     }"}, {"sha": "7c2ad4384165ac1c3e45c037a45f95b12a8d5fed", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -7,6 +7,7 @@ use hir_def::{\n     expr::{BindingAnnotation, Pat, PatId, RecordFieldPat},\n     path::Path,\n     type_ref::Mutability,\n+    StructFieldId,\n };\n use hir_expand::name::Name;\n use test_utils::tested_by;\n@@ -67,6 +68,11 @@ impl<'a> InferenceContext<'a> {\n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         for subpat in subpats {\n             let matching_field = var_data.as_ref().and_then(|it| it.field(&subpat.name));\n+            if let Some(local_id) = matching_field {\n+                let field_def = StructFieldId { parent: def.unwrap(), local_id };\n+                self.result.record_field_pat_resolutions.insert(subpat.pat, field_def);\n+            }\n+\n             let expected_ty =\n                 matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone().subst(&substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);"}, {"sha": "8498d3d966d0270e47f764fd3f4527ecf2e9bf2c", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -12,7 +12,7 @@ use ra_db::{\n };\n use stdx::format_to;\n \n-use crate::{db::HirDatabase, expr::ExprValidator};\n+use crate::{db::HirDatabase, diagnostics::Diagnostic, expr::ExprValidator};\n \n #[salsa::database(\n     ra_db::SourceDatabaseExtStorage,\n@@ -104,10 +104,7 @@ impl TestDB {\n         panic!(\"Can't find module for file\")\n     }\n \n-    // FIXME: don't duplicate this\n-    pub fn diagnostics(&self) -> (String, u32) {\n-        let mut buf = String::new();\n-        let mut count = 0;\n+    fn diag<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {\n             let crate_def_map = self.crate_def_map(krate);\n@@ -132,15 +129,36 @@ impl TestDB {\n \n             for f in fns {\n                 let infer = self.infer(f.into());\n-                let mut sink = DiagnosticSink::new(|d| {\n-                    format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-                    count += 1;\n-                });\n+                let mut sink = DiagnosticSink::new(&mut cb);\n                 infer.add_diagnostics(self, f, &mut sink);\n                 let mut validator = ExprValidator::new(f, infer, &mut sink);\n                 validator.validate_body(self);\n             }\n         }\n+    }\n+\n+    pub fn diagnostics(&self) -> (String, u32) {\n+        let mut buf = String::new();\n+        let mut count = 0;\n+        self.diag(|d| {\n+            format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+            count += 1;\n+        });\n+        (buf, count)\n+    }\n+\n+    /// Like `diagnostics`, but filtered for a single diagnostic.\n+    pub fn diagnostic<D: Diagnostic>(&self) -> (String, u32) {\n+        let mut buf = String::new();\n+        let mut count = 0;\n+        self.diag(|d| {\n+            // We want to filter diagnostics by the particular one we are testing for, to\n+            // avoid surprising results in tests.\n+            if d.downcast_ref::<D>().is_some() {\n+                format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                count += 1;\n+            };\n+        });\n         (buf, count)\n     }\n }"}, {"sha": "6ea51d5d314e52a3e2239e768f15ca68334e35aa", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -455,3 +455,29 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn infer_guard() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S;\n+impl S { fn foo(&self) -> bool { false } }\n+\n+fn main() {\n+    match S {\n+        s if s.foo() => (),\n+    }\n+}\n+    \"#), @\"\n+        [28; 32) 'self': &S\n+        [42; 51) '{ false }': bool\n+        [44; 49) 'false': bool\n+        [65; 116) '{     ...   } }': ()\n+        [71; 114) 'match ...     }': ()\n+        [77; 78) 'S': S\n+        [89; 90) 's': S\n+        [94; 95) 's': S\n+        [94; 101) 's.foo()': bool\n+        [105; 107) '()': ()\n+    \")\n+}"}, {"sha": "6bc6d474c9783f0438f2e6c7c2e035159b2045b2", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -225,7 +225,7 @@ fn solution_from_chalk(\n                 None => unimplemented!(),\n             })\n             .collect();\n-        let result = Canonical { value, num_vars: subst.binders.len() };\n+        let result = Canonical { value, num_vars: subst.binders.len(&Interner) };\n         SolutionVariables(result)\n     };\n     match solution {"}, {"sha": "1ccb7c3b4ab8a62379912a955c87b6d597402187", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 123, "deletions": 22, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -4,8 +4,8 @@ use std::{fmt, sync::Arc};\n use log::debug;\n \n use chalk_ir::{\n-    cast::Cast, fold::shift::Shift, Goal, GoalData, Parameter, PlaceholderIndex, TypeName,\n-    UniverseIndex,\n+    cast::Cast, fold::shift::Shift, interner::HasInterner, Goal, GoalData, Parameter,\n+    PlaceholderIndex, TypeName, UniverseIndex,\n };\n \n use hir_def::{AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId};\n@@ -33,8 +33,10 @@ impl chalk_ir::interner::Interner for Interner {\n     type InternedGoals = Vec<Goal<Self>>;\n     type InternedSubstitution = Vec<Parameter<Self>>;\n     type InternedProgramClause = chalk_ir::ProgramClauseData<Self>;\n-    type InternedProgramClauses = Vec<chalk_ir::ProgramClause<Self>>;\n+    type InternedProgramClauses = Arc<[chalk_ir::ProgramClause<Self>]>;\n     type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n+    type InternedParameterKinds = Vec<chalk_ir::ParameterKind<()>>;\n+    type InternedCanonicalVarKinds = Vec<chalk_ir::ParameterKind<UniverseIndex>>;\n     type Identifier = TypeAliasId;\n     type DefId = InternId;\n \n@@ -60,6 +62,27 @@ impl chalk_ir::interner::Interner for Interner {\n         tls::with_current_program(|prog| Some(prog?.debug_alias(alias, fmt)))\n     }\n \n+    fn debug_projection_ty(\n+        proj: &chalk_ir::ProjectionTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_projection_ty(proj, fmt)))\n+    }\n+\n+    fn debug_opaque_ty(\n+        opaque_ty: &chalk_ir::OpaqueTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_opaque_ty(opaque_ty, fmt)))\n+    }\n+\n+    fn debug_opaque_ty_id(\n+        opaque_ty_id: chalk_ir::OpaqueTyId<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_opaque_ty_id(opaque_ty_id, fmt)))\n+    }\n+\n     fn debug_ty(ty: &chalk_ir::Ty<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n         tls::with_current_program(|prog| Some(prog?.debug_ty(ty, fmt)))\n     }\n@@ -202,15 +225,15 @@ impl chalk_ir::interner::Interner for Interner {\n     fn intern_program_clauses(\n         &self,\n         data: impl IntoIterator<Item = chalk_ir::ProgramClause<Self>>,\n-    ) -> Vec<chalk_ir::ProgramClause<Self>> {\n+    ) -> Arc<[chalk_ir::ProgramClause<Self>]> {\n         data.into_iter().collect()\n     }\n \n     fn program_clauses_data<'a>(\n         &self,\n-        clauses: &'a Vec<chalk_ir::ProgramClause<Self>>,\n+        clauses: &'a Arc<[chalk_ir::ProgramClause<Self>]>,\n     ) -> &'a [chalk_ir::ProgramClause<Self>] {\n-        clauses\n+        &clauses\n     }\n \n     fn intern_quantified_where_clauses(\n@@ -226,6 +249,34 @@ impl chalk_ir::interner::Interner for Interner {\n     ) -> &'a [chalk_ir::QuantifiedWhereClause<Self>] {\n         clauses\n     }\n+\n+    fn intern_parameter_kinds(\n+        &self,\n+        data: impl IntoIterator<Item = chalk_ir::ParameterKind<()>>,\n+    ) -> Self::InternedParameterKinds {\n+        data.into_iter().collect()\n+    }\n+\n+    fn parameter_kinds_data<'a>(\n+        &self,\n+        parameter_kinds: &'a Self::InternedParameterKinds,\n+    ) -> &'a [chalk_ir::ParameterKind<()>] {\n+        &parameter_kinds\n+    }\n+\n+    fn intern_canonical_var_kinds(\n+        &self,\n+        data: impl IntoIterator<Item = chalk_ir::ParameterKind<UniverseIndex>>,\n+    ) -> Self::InternedCanonicalVarKinds {\n+        data.into_iter().collect()\n+    }\n+\n+    fn canonical_var_kinds_data<'a>(\n+        &self,\n+        canonical_var_kinds: &'a Self::InternedCanonicalVarKinds,\n+    ) -> &'a [chalk_ir::ParameterKind<UniverseIndex>] {\n+        &canonical_var_kinds\n+    }\n }\n \n impl chalk_ir::interner::HasInterner for Interner {\n@@ -268,9 +319,12 @@ impl ToChalk for Ty {\n             Ty::Projection(proj_ty) => {\n                 let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n                 let substitution = proj_ty.parameters.to_chalk(db);\n-                chalk_ir::AliasTy { associated_ty_id, substitution }\n-                    .cast(&Interner)\n-                    .intern(&Interner)\n+                chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n+                    associated_ty_id,\n+                    substitution,\n+                })\n+                .cast(&Interner)\n+                .intern(&Interner)\n             }\n             Ty::Placeholder(id) => {\n                 let interned_id = db.intern_type_param_id(id);\n@@ -314,16 +368,17 @@ impl ToChalk for Ty {\n                 );\n                 Ty::Placeholder(db.lookup_intern_type_param_id(interned_id))\n             }\n-            chalk_ir::TyData::Alias(proj) => {\n+            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n                 let associated_ty = from_chalk(db, proj.associated_ty_id);\n                 let parameters = from_chalk(db, proj.substitution);\n                 Ty::Projection(ProjectionTy { associated_ty, parameters })\n             }\n+            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(_)) => unimplemented!(),\n             chalk_ir::TyData::Function(_) => unimplemented!(),\n             chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx),\n             chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n             chalk_ir::TyData::Dyn(where_clauses) => {\n-                assert_eq!(where_clauses.bounds.binders.len(), 1);\n+                assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n                 let predicates = where_clauses\n                     .bounds\n                     .skip_binders()\n@@ -404,6 +459,7 @@ impl ToChalk for TypeCtor {\n         match type_name {\n             TypeName::Struct(struct_id) => db.lookup_intern_type_ctor(struct_id.into()),\n             TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n+            TypeName::OpaqueType(_) => unreachable!(),\n             TypeName::Error => {\n                 // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n                 unreachable!()\n@@ -460,7 +516,8 @@ impl ToChalk for GenericPredicate {\n             }\n             GenericPredicate::Projection(projection_pred) => {\n                 let ty = projection_pred.ty.to_chalk(db).shifted_in(&Interner);\n-                let alias = projection_pred.projection_ty.to_chalk(db).shifted_in(&Interner);\n+                let projection = projection_pred.projection_ty.to_chalk(db).shifted_in(&Interner);\n+                let alias = chalk_ir::AliasTy::Projection(projection);\n                 make_binders(chalk_ir::WhereClause::AliasEq(chalk_ir::AliasEq { alias, ty }), 0)\n             }\n             GenericPredicate::Error => panic!(\"tried passing GenericPredicate::Error to Chalk\"),\n@@ -481,7 +538,13 @@ impl ToChalk for GenericPredicate {\n                 GenericPredicate::Implemented(from_chalk(db, tr))\n             }\n             chalk_ir::WhereClause::AliasEq(projection_eq) => {\n-                let projection_ty = from_chalk(db, projection_eq.alias);\n+                let projection_ty = from_chalk(\n+                    db,\n+                    match projection_eq.alias {\n+                        chalk_ir::AliasTy::Projection(p) => p,\n+                        _ => unimplemented!(),\n+                    },\n+                );\n                 let ty = from_chalk(db, projection_eq.ty);\n                 GenericPredicate::Projection(super::ProjectionPredicate { projection_ty, ty })\n             }\n@@ -490,18 +553,18 @@ impl ToChalk for GenericPredicate {\n }\n \n impl ToChalk for ProjectionTy {\n-    type Chalk = chalk_ir::AliasTy<Interner>;\n+    type Chalk = chalk_ir::ProjectionTy<Interner>;\n \n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::AliasTy<Interner> {\n-        chalk_ir::AliasTy {\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::ProjectionTy<Interner> {\n+        chalk_ir::ProjectionTy {\n             associated_ty_id: self.associated_ty.to_chalk(db),\n             substitution: self.parameters.to_chalk(db),\n         }\n     }\n \n     fn from_chalk(\n         db: &dyn HirDatabase,\n-        projection_ty: chalk_ir::AliasTy<Interner>,\n+        projection_ty: chalk_ir::ProjectionTy<Interner>,\n     ) -> ProjectionTy {\n         ProjectionTy {\n             associated_ty: from_chalk(db, projection_ty.associated_ty_id),\n@@ -514,7 +577,10 @@ impl ToChalk for super::ProjectionPredicate {\n     type Chalk = chalk_ir::AliasEq<Interner>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::AliasEq<Interner> {\n-        chalk_ir::AliasEq { alias: self.projection_ty.to_chalk(db), ty: self.ty.to_chalk(db) }\n+        chalk_ir::AliasEq {\n+            alias: chalk_ir::AliasTy::Projection(self.projection_ty.to_chalk(db)),\n+            ty: self.ty.to_chalk(db),\n+        }\n     }\n \n     fn from_chalk(_db: &dyn HirDatabase, _normalize: chalk_ir::AliasEq<Interner>) -> Self {\n@@ -540,17 +606,24 @@ impl ToChalk for Obligation {\n impl<T> ToChalk for Canonical<T>\n where\n     T: ToChalk,\n+    T::Chalk: HasInterner<Interner = Interner>,\n {\n     type Chalk = chalk_ir::Canonical<T::Chalk>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n         let parameter = chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::ROOT);\n         let value = self.value.to_chalk(db);\n-        chalk_ir::Canonical { value, binders: vec![parameter; self.num_vars] }\n+        chalk_ir::Canonical {\n+            value,\n+            binders: chalk_ir::CanonicalVarKinds::from(&Interner, vec![parameter; self.num_vars]),\n+        }\n     }\n \n     fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n-        Canonical { num_vars: canonical.binders.len(), value: from_chalk(db, canonical.value) }\n+        Canonical {\n+            num_vars: canonical.binders.len(&Interner),\n+            value: from_chalk(db, canonical.value),\n+        }\n     }\n }\n \n@@ -649,9 +722,15 @@ impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n     }\n }\n \n-fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n+fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T>\n+where\n+    T: HasInterner<Interner = Interner>,\n+{\n     chalk_ir::Binders::new(\n-        std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars).collect(),\n+        chalk_ir::ParameterKinds::from(\n+            &Interner,\n+            std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars),\n+        ),\n         value,\n     )\n }\n@@ -799,6 +878,28 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // FIXME tell Chalk about well-known traits (here and in trait_datum)\n         None\n     }\n+\n+    fn program_clauses_for_env(\n+        &self,\n+        environment: &chalk_ir::Environment<Interner>,\n+    ) -> chalk_ir::ProgramClauses<Interner> {\n+        self.db.program_clauses_for_chalk_env(self.krate, environment.clone())\n+    }\n+\n+    fn opaque_ty_data(\n+        &self,\n+        _id: chalk_ir::OpaqueTyId<Interner>,\n+    ) -> Arc<chalk_rust_ir::OpaqueTyDatum<Interner>> {\n+        unimplemented!()\n+    }\n+}\n+\n+pub(crate) fn program_clauses_for_chalk_env_query(\n+    db: &dyn HirDatabase,\n+    krate: CrateId,\n+    environment: chalk_ir::Environment<Interner>,\n+) -> chalk_ir::ProgramClauses<Interner> {\n+    chalk_solve::program_clauses_for_env(&ChalkContext { db, krate }, &environment)\n }\n \n pub(crate) fn associated_ty_data_query("}, {"sha": "4867cb17ed1ec4a04d3ba10d5ba7b3e2f93baa45", "filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -121,19 +121,38 @@ impl DebugContext<'_> {\n         write!(fmt, \"{}::{}\", trait_data.name, type_alias_data.name)\n     }\n \n+    pub fn debug_opaque_ty_id(\n+        &self,\n+        opaque_ty_id: chalk_ir::OpaqueTyId<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        fmt.debug_struct(\"OpaqueTyId\").field(\"index\", &opaque_ty_id.0).finish()\n+    }\n+\n     pub fn debug_alias(\n         &self,\n-        alias: &AliasTy<Interner>,\n+        alias_ty: &AliasTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        match alias_ty {\n+            AliasTy::Projection(projection_ty) => self.debug_projection_ty(projection_ty, fmt),\n+            AliasTy::Opaque(opaque_ty) => self.debug_opaque_ty(opaque_ty, fmt),\n+        }\n+    }\n+\n+    pub fn debug_projection_ty(\n+        &self,\n+        projection_ty: &chalk_ir::ProjectionTy<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Result<(), fmt::Error> {\n-        let type_alias: TypeAliasId = from_chalk(self.0, alias.associated_ty_id);\n+        let type_alias: TypeAliasId = from_chalk(self.0, projection_ty.associated_ty_id);\n         let type_alias_data = self.0.type_alias_data(type_alias);\n         let trait_ = match type_alias.lookup(self.0.upcast()).container {\n             AssocContainerId::TraitId(t) => t,\n             _ => panic!(\"associated type not in trait\"),\n         };\n         let trait_data = self.0.trait_data(trait_);\n-        let params = alias.substitution.parameters(&Interner);\n+        let params = projection_ty.substitution.parameters(&Interner);\n         write!(fmt, \"<{:?} as {}\", &params[0], trait_data.name,)?;\n         if params.len() > 1 {\n             write!(\n@@ -145,6 +164,14 @@ impl DebugContext<'_> {\n         write!(fmt, \">::{}\", type_alias_data.name)\n     }\n \n+    pub fn debug_opaque_ty(\n+        &self,\n+        opaque_ty: &chalk_ir::OpaqueTy<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Result<(), fmt::Error> {\n+        write!(fmt, \"{:?}\", opaque_ty.opaque_ty_id)\n+    }\n+\n     pub fn debug_ty(\n         &self,\n         ty: &chalk_ir::Ty<Interner>,"}, {"sha": "f8dac1d54178aecc3363382d8224be267766ecb7", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -161,6 +161,12 @@ impl Completions {\n         name: Option<String>,\n         macro_: hir::MacroDef,\n     ) {\n+        // FIXME: Currently proc-macro do not have ast-node,\n+        // such that it does not have source\n+        if macro_.is_proc_macro() {\n+            return;\n+        }\n+\n         let name = match name {\n             Some(it) => it,\n             None => return,"}, {"sha": "753d2ef6a0a014f59c7fca8f5e914634e872ff59", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -96,7 +96,7 @@ fn try_extend_selection(\n         return Some(node.text_range());\n     }\n \n-    let node = shallowest_node(&node.into());\n+    let node = shallowest_node(&node);\n \n     if node.parent().map(|n| list_kinds.contains(&n.kind())) == Some(true) {\n         if let Some(range) = extend_list_item(&node) {"}, {"sha": "9998ca5a3d351962737feed0f7d2f8b5205a8454", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -62,10 +62,9 @@ pub(crate) enum ReferenceResult {\n \n impl ReferenceResult {\n     fn to_vec(self) -> Vec<NavigationTarget> {\n-        use self::ReferenceResult::*;\n         match self {\n-            Exact(target) => vec![target],\n-            Approximate(vec) => vec,\n+            ReferenceResult::Exact(target) => vec![target],\n+            ReferenceResult::Approximate(vec) => vec,\n         }\n     }\n }\n@@ -74,8 +73,6 @@ pub(crate) fn reference_definition(\n     sema: &Semantics<RootDatabase>,\n     name_ref: &ast::NameRef,\n ) -> ReferenceResult {\n-    use self::ReferenceResult::*;\n-\n     let name_kind = classify_name_ref(sema, name_ref);\n     if let Some(def) = name_kind {\n         let def = def.definition();\n@@ -91,7 +88,7 @@ pub(crate) fn reference_definition(\n         .into_iter()\n         .map(|s| s.to_nav(sema.db))\n         .collect();\n-    Approximate(navs)\n+    ReferenceResult::Approximate(navs)\n }\n \n #[cfg(test)]\n@@ -398,6 +395,25 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn goto_def_for_record_pat_fields() {\n+        covers!(ra_ide_db::goto_def_for_record_field_pats);\n+        check_goto(\n+            r\"\n+            //- /lib.rs\n+            struct Foo {\n+                spam: u32,\n+            }\n+\n+            fn bar(foo: Foo) -> Foo {\n+                let Foo { spam<|>: _, } = foo\n+            }\n+            \",\n+            \"spam RECORD_FIELD_DEF FileId(1) [17; 26) [17; 21)\",\n+            \"spam: u32|spam\",\n+        );\n+    }\n+\n     #[test]\n     fn goto_def_for_record_fields_macros() {\n         check_goto("}, {"sha": "ccb1fc7516c989f928ab464bbf615f0729a544e6", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -50,12 +50,12 @@\n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span>() {\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello, {}!\"</span>, <span class=\"numeric_literal\">92</span>);\n \n-    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">vec</span> = Vec::new();\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">vec</span> = <span class=\"unresolved_reference\">Vec</span>::<span class=\"unresolved_reference\">new</span>();\n     <span class=\"keyword control\">if</span> <span class=\"keyword\">true</span> {\n         <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> = <span class=\"numeric_literal\">92</span>;\n-        <span class=\"variable mutable\">vec</span>.push(<span class=\"struct\">Foo</span> { <span class=\"field\">x</span>, <span class=\"field\">y</span>: <span class=\"numeric_literal\">1</span> });\n+        <span class=\"variable mutable\">vec</span>.<span class=\"unresolved_reference\">push</span>(<span class=\"struct\">Foo</span> { <span class=\"field\">x</span>, <span class=\"field\">y</span>: <span class=\"numeric_literal\">1</span> });\n     }\n-    <span class=\"keyword unsafe\">unsafe</span> { <span class=\"variable mutable\">vec</span>.set_len(<span class=\"numeric_literal\">0</span>); }\n+    <span class=\"keyword unsafe\">unsafe</span> { <span class=\"variable mutable\">vec</span>.<span class=\"unresolved_reference\">set_len</span>(<span class=\"numeric_literal\">0</span>); }\n \n     <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">x</span> = <span class=\"numeric_literal\">42</span>;\n     <span class=\"keyword\">let</span> <span class=\"variable declaration mutable\">y</span> = &<span class=\"keyword\">mut</span> <span class=\"variable mutable\">x</span>;"}, {"sha": "3df82c45fbe9885ddc7a12a7a8d835edfc32c50e", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -28,11 +28,11 @@\n </style>\n <pre><code><span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span>() {\n     <span class=\"keyword\">let</span> <span class=\"variable declaration\" data-binding-hash=\"8121853618659664005\" style=\"color: hsl(261,57%,61%);\">hello</span> = <span class=\"string_literal\">\"hello\"</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable declaration\" data-binding-hash=\"2705725358298919760\" style=\"color: hsl(17,51%,74%);\">x</span> = <span class=\"variable\" data-binding-hash=\"8121853618659664005\" style=\"color: hsl(261,57%,61%);\">hello</span>.to_string();\n-    <span class=\"keyword\">let</span> <span class=\"variable declaration\" data-binding-hash=\"3365759661443752373\" style=\"color: hsl(127,76%,66%);\">y</span> = <span class=\"variable\" data-binding-hash=\"8121853618659664005\" style=\"color: hsl(261,57%,61%);\">hello</span>.to_string();\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\" data-binding-hash=\"2705725358298919760\" style=\"color: hsl(17,51%,74%);\">x</span> = <span class=\"variable\" data-binding-hash=\"8121853618659664005\" style=\"color: hsl(261,57%,61%);\">hello</span>.<span class=\"unresolved_reference\">to_string</span>();\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\" data-binding-hash=\"3365759661443752373\" style=\"color: hsl(127,76%,66%);\">y</span> = <span class=\"variable\" data-binding-hash=\"8121853618659664005\" style=\"color: hsl(261,57%,61%);\">hello</span>.<span class=\"unresolved_reference\">to_string</span>();\n \n     <span class=\"keyword\">let</span> <span class=\"variable declaration\" data-binding-hash=\"794745962933817518\" style=\"color: hsl(19,74%,76%);\">x</span> = <span class=\"string_literal\">\"other color please!\"</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable declaration\" data-binding-hash=\"6717528807933952652\" style=\"color: hsl(85,49%,84%);\">y</span> = <span class=\"variable\" data-binding-hash=\"794745962933817518\" style=\"color: hsl(19,74%,76%);\">x</span>.to_string();\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\" data-binding-hash=\"6717528807933952652\" style=\"color: hsl(85,49%,84%);\">y</span> = <span class=\"variable\" data-binding-hash=\"794745962933817518\" style=\"color: hsl(19,74%,76%);\">x</span>.<span class=\"unresolved_reference\">to_string</span>();\n }\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span>() {"}, {"sha": "93d50287561281e579c758937fa9944ae421c40d", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -239,20 +239,21 @@ fn highlight_element(\n         NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => return None,\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n-            let name_kind = classify_name_ref(sema, &name_ref)?;\n-\n-            match name_kind {\n-                NameRefClass::Definition(def) => {\n-                    if let Definition::Local(local) = &def {\n-                        if let Some(name) = local.name(db) {\n-                            let shadow_count =\n-                                bindings_shadow_count.entry(name.clone()).or_default();\n-                            binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n-                        }\n-                    };\n-                    highlight_name(db, def)\n-                }\n-                NameRefClass::FieldShorthand { .. } => HighlightTag::Field.into(),\n+            match classify_name_ref(sema, &name_ref) {\n+                Some(name_kind) => match name_kind {\n+                    NameRefClass::Definition(def) => {\n+                        if let Definition::Local(local) = &def {\n+                            if let Some(name) = local.name(db) {\n+                                let shadow_count =\n+                                    bindings_shadow_count.entry(name.clone()).or_default();\n+                                binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+                            }\n+                        };\n+                        highlight_name(db, def)\n+                    }\n+                    NameRefClass::FieldShorthand { .. } => HighlightTag::Field.into(),\n+                },\n+                None => HighlightTag::UnresolvedReference.into(),\n             }\n         }\n "}, {"sha": "f2c42165454e0408d54c174c57626416bc9f5835", "filename": "crates/ra_ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -38,6 +38,7 @@ pub enum HighlightTag {\n     TypeParam,\n     Union,\n     Local,\n+    UnresolvedReference,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n@@ -79,6 +80,7 @@ impl HighlightTag {\n             HighlightTag::TypeParam => \"type_param\",\n             HighlightTag::Union => \"union\",\n             HighlightTag::Local => \"variable\",\n+            HighlightTag::UnresolvedReference => \"unresolved_reference\",\n         }\n     }\n }"}, {"sha": "785613b82c10ab5f7927a036f4237907ad00f7fd", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -180,6 +180,7 @@ fn classify_name_inner(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Opti\n     }\n }\n \n+#[derive(Debug)]\n pub enum NameRefClass {\n     Definition(Definition),\n     FieldShorthand { local: Local, field: Definition },\n@@ -229,6 +230,14 @@ pub fn classify_name_ref(\n         }\n     }\n \n+    if let Some(record_field_pat) = ast::RecordFieldPat::cast(parent.clone()) {\n+        tested_by!(goto_def_for_record_field_pats; force);\n+        if let Some(field) = sema.resolve_record_field_pat(&record_field_pat) {\n+            let field = Definition::StructField(field);\n+            return Some(NameRefClass::Definition(field));\n+        }\n+    }\n+\n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_def_for_macros; force);\n         if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {"}, {"sha": "03b4be21c974b7698115164b7356f834704e4e6d", "filename": "crates/ra_ide_db/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -6,5 +6,6 @@ test_utils::marks![\n     goto_def_for_fields\n     goto_def_for_record_fields\n     goto_def_for_field_init_shorthand\n+    goto_def_for_record_field_pats\n     search_filters_by_range\n ];"}, {"sha": "78f9efa1b6926eb5d1150b6655704b3a67631637", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -187,7 +187,11 @@ impl<'a> TtIter<'a> {\n                 _ => false,\n             },\n             Separator::Literal(lhs) => match fork.expect_literal() {\n-                Ok(rhs) => rhs.text == lhs.text,\n+                Ok(rhs) => match rhs {\n+                    tt::Leaf::Literal(rhs) => rhs.text == lhs.text,\n+                    tt::Leaf::Ident(rhs) => rhs.text == lhs.text,\n+                    tt::Leaf::Punct(_) => false,\n+                },\n                 _ => false,\n             },\n             Separator::Puncts(lhss) => lhss.iter().all(|lhs| match fork.expect_punct() {\n@@ -202,6 +206,13 @@ impl<'a> TtIter<'a> {\n     }\n \n     pub(crate) fn expect_tt(&mut self) -> Result<tt::TokenTree, ()> {\n+        match self.peek_n(0) {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '\\'' => {\n+                return self.expect_lifetime();\n+            }\n+            _ => (),\n+        }\n+\n         let tt = self.next().ok_or_else(|| ())?.clone();\n         let punct = match tt {\n             tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if punct.spacing == tt::Spacing::Joint => {\n@@ -255,13 +266,21 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n-    pub(crate) fn expect_lifetime(&mut self) -> Result<&tt::Ident, ()> {\n-        let ident = self.expect_ident()?;\n-        // check if it start from \"`\"\n-        if !ident.text.starts_with('\\'') {\n+    pub(crate) fn expect_lifetime(&mut self) -> Result<tt::TokenTree, ()> {\n+        let punct = self.expect_punct()?;\n+        if punct.char != '\\'' {\n             return Err(());\n         }\n-        Ok(ident)\n+        let ident = self.expect_ident()?;\n+\n+        Ok(tt::Subtree {\n+            delimiter: None,\n+            token_trees: vec![\n+                tt::Leaf::Punct(punct.clone()).into(),\n+                tt::Leaf::Ident(ident.clone()).into(),\n+            ],\n+        }\n+        .into())\n     }\n \n     pub(crate) fn expect_fragment(\n@@ -274,7 +293,10 @@ impl<'a> TtIter<'a> {\n         }\n \n         impl<'a> TreeSink for OffsetTokenSink<'a> {\n-            fn token(&mut self, _kind: SyntaxKind, n_tokens: u8) {\n+            fn token(&mut self, kind: SyntaxKind, mut n_tokens: u8) {\n+                if kind == SyntaxKind::LIFETIME {\n+                    n_tokens = 2;\n+                }\n                 for _ in 0..n_tokens {\n                     self.cursor = self.cursor.bump_subtree();\n                 }\n@@ -286,7 +308,7 @@ impl<'a> TtIter<'a> {\n             }\n         }\n \n-        let buffer = TokenBuffer::new(self.inner.as_slice());\n+        let buffer = TokenBuffer::new(&self.inner.as_slice());\n         let mut src = SubtreeTokenSource::new(&buffer);\n         let mut sink = OffsetTokenSink { cursor: buffer.begin(), error: false };\n \n@@ -422,7 +444,7 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragmen\n                 \"tt\" => input.expect_tt().map(Some).map_err(|()| err!()),\n                 \"lifetime\" => input\n                     .expect_lifetime()\n-                    .map(|ident| Some(tt::Leaf::Ident(ident.clone()).into()))\n+                    .map(|tt| Some(tt))\n                     .map_err(|()| err!(\"expected lifetime\")),\n                 \"literal\" => input\n                     .expect_literal()"}, {"sha": "d7866452dd94e6e7c846fde24c61fcb390464600", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -50,6 +50,26 @@ impl<'a> SubtreeTokenSource<'a> {\n     }\n \n     fn get(&self, pos: usize) -> Ref<Option<TtToken>> {\n+        fn is_lifetime(c: Cursor) -> Option<(Cursor, SmolStr)> {\n+            let tkn = c.token_tree();\n+\n+            if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = tkn {\n+                if punct.char == '\\'' {\n+                    let next = c.bump();\n+                    if let Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) = next.token_tree() {\n+                        let res_cursor = next.bump();\n+                        let text = SmolStr::new(\"'\".to_string() + &ident.to_string());\n+\n+                        return Some((res_cursor, text));\n+                    } else {\n+                        panic!(\"Next token must be ident : {:#?}\", next.token_tree());\n+                    }\n+                }\n+            }\n+\n+            None\n+        }\n+\n         if pos < self.cached.borrow().len() {\n             return Ref::map(self.cached.borrow(), |c| &c[pos]);\n         }\n@@ -63,6 +83,12 @@ impl<'a> SubtreeTokenSource<'a> {\n                     continue;\n                 }\n \n+                if let Some((curr, text)) = is_lifetime(cursor) {\n+                    cached.push(Some(TtToken { kind: LIFETIME, is_joint_to_next: false, text }));\n+                    self.cached_cursor.set(curr);\n+                    continue;\n+                }\n+\n                 match cursor.token_tree() {\n                     Some(tt::TokenTree::Leaf(leaf)) => {\n                         cached.push(Some(convert_leaf(&leaf)));\n@@ -132,27 +158,28 @@ fn convert_literal(l: &tt::Literal) -> TtToken {\n     let kind = lex_single_syntax_kind(&l.text)\n         .map(|(kind, _error)| kind)\n         .filter(|kind| kind.is_literal())\n-        .unwrap_or_else(|| match l.text.as_ref() {\n-            \"true\" => T![true],\n-            \"false\" => T![false],\n-            _ => panic!(\"Fail to convert given literal {:#?}\", &l),\n-        });\n+        .unwrap_or_else(|| panic!(\"Fail to convert given literal {:#?}\", &l));\n \n     TtToken { kind, is_joint_to_next: false, text: l.text.clone() }\n }\n \n fn convert_ident(ident: &tt::Ident) -> TtToken {\n-    let kind = if ident.text.starts_with('\\'') {\n-        LIFETIME\n-    } else {\n-        SyntaxKind::from_keyword(ident.text.as_str()).unwrap_or(IDENT)\n+    let kind = match ident.text.as_ref() {\n+        \"true\" => T![true],\n+        \"false\" => T![false],\n+        i if i.starts_with('\\'') => LIFETIME,\n+        _ => SyntaxKind::from_keyword(ident.text.as_str()).unwrap_or(IDENT),\n     };\n \n     TtToken { kind, is_joint_to_next: false, text: ident.text.clone() }\n }\n \n fn convert_punct(p: tt::Punct) -> TtToken {\n-    let kind = SyntaxKind::from_char(p.char).unwrap();\n+    let kind = match SyntaxKind::from_char(p.char) {\n+        None => panic!(\"{:#?} is not a valid punct\", p),\n+        Some(kind) => kind,\n+    };\n+\n     let text = {\n         let mut buf = [0u8; 4];\n         let s: &str = p.char.encode_utf8(&mut buf);"}, {"sha": "2b4390eb26ed08fdab854e7f53ce2dfcde12a7af", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -271,7 +271,7 @@ struct RawConvertor<'a> {\n     inner: std::slice::Iter<'a, RawToken>,\n }\n \n-trait SrcToken {\n+trait SrcToken: std::fmt::Debug {\n     fn kind(&self) -> SyntaxKind;\n \n     fn to_char(&self) -> Option<char>;\n@@ -361,8 +361,12 @@ trait TokenConvertor {\n                     Some(next) if next.kind().is_punct() => tt::Spacing::Joint,\n                     _ => tt::Spacing::Alone,\n                 };\n-                let char = token.to_char().expect(\"Token from lexer must be single char\");\n-\n+                let char = match token.to_char() {\n+                    Some(c) => c,\n+                    None => {\n+                        panic!(\"Token from lexer must be single char: token = {:#?}\", token);\n+                    }\n+                };\n                 tt::Leaf::from(tt::Punct { char, spacing, id: self.id_alloc().alloc(range) }).into()\n             }\n         } else {\n@@ -372,10 +376,29 @@ trait TokenConvertor {\n                 };\n             }\n             let leaf: tt::Leaf = match k {\n-                T![true] | T![false] => make_leaf!(Literal),\n-                IDENT | LIFETIME => make_leaf!(Ident),\n+                T![true] | T![false] => make_leaf!(Ident),\n+                IDENT => make_leaf!(Ident),\n                 k if k.is_keyword() => make_leaf!(Ident),\n                 k if k.is_literal() => make_leaf!(Literal),\n+                LIFETIME => {\n+                    let char_unit = TextUnit::from_usize(1);\n+                    let r = TextRange::offset_len(range.start(), char_unit);\n+                    let apostrophe = tt::Leaf::from(tt::Punct {\n+                        char: '\\'',\n+                        spacing: tt::Spacing::Joint,\n+                        id: self.id_alloc().alloc(r),\n+                    });\n+                    result.push(apostrophe.into());\n+\n+                    let r =\n+                        TextRange::offset_len(range.start() + char_unit, range.len() - char_unit);\n+                    let ident = tt::Leaf::from(tt::Ident {\n+                        text: SmolStr::new(&token.to_text()[1..]),\n+                        id: self.id_alloc().alloc(r),\n+                    });\n+                    result.push(ident.into());\n+                    return;\n+                }\n                 _ => return,\n             };\n \n@@ -455,6 +478,7 @@ impl Convertor {\n     }\n }\n \n+#[derive(Debug)]\n enum SynToken {\n     Ordiniary(SyntaxToken),\n     Punch(SyntaxToken, TextUnit),\n@@ -592,11 +616,14 @@ fn delim_to_str(d: Option<tt::DelimiterKind>, closing: bool) -> SmolStr {\n }\n \n impl<'a> TreeSink for TtTreeSink<'a> {\n-    fn token(&mut self, kind: SyntaxKind, n_tokens: u8) {\n+    fn token(&mut self, kind: SyntaxKind, mut n_tokens: u8) {\n         if kind == L_DOLLAR || kind == R_DOLLAR {\n             self.cursor = self.cursor.bump_subtree();\n             return;\n         }\n+        if kind == LIFETIME {\n+            n_tokens = 2;\n+        }\n \n         let mut last = self.cursor;\n         for _ in 0..n_tokens {"}, {"sha": "100ed41f234a2bb67d9ce9a5a65750ed89fbe36d", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -214,6 +214,33 @@ SUBTREE $\n     );\n }\n \n+#[test]\n+fn test_lifetime_split() {\n+    parse_macro(\n+        r#\"\n+macro_rules! foo {\n+    ($($t:tt)*) => { $($t)*}\n+}\n+\"#,\n+    )\n+    .assert_expand(\n+        r#\"foo!(static bar: &'static str = \"hello\";);\"#,\n+        r#\"\n+SUBTREE $\n+  IDENT   static 17\n+  IDENT   bar 18\n+  PUNCH   : [alone] 19\n+  PUNCH   & [alone] 20\n+  PUNCH   ' [joint] 21\n+  IDENT   static 22\n+  IDENT   str 23\n+  PUNCH   = [alone] 24\n+  LITERAL \"hello\" 25\n+  PUNCH   ; [joint] 26\n+\"#,\n+    );\n+}\n+\n #[test]\n fn test_expr_order() {\n     let expanded = parse_macro(\n@@ -988,6 +1015,36 @@ fn test_literal() {\n     .assert_expand_items(r#\"foo!(u8 0);\"#, r#\"const VALUE : u8 = 0 ;\"#);\n }\n \n+#[test]\n+fn test_boolean_is_ident() {\n+    parse_macro(\n+        r#\"\n+        macro_rules! foo {\n+              ($lit0:literal, $lit1:literal) => { const VALUE: (bool,bool) = ($lit0,$lit1); };\n+        }\n+\"#,\n+    )\n+    .assert_expand(\n+        r#\"foo!(true,false);\"#,\n+        r#\"\n+SUBTREE $\n+  IDENT   const 14\n+  IDENT   VALUE 15\n+  PUNCH   : [alone] 16\n+  SUBTREE () 17\n+    IDENT   bool 18\n+    PUNCH   , [alone] 19\n+    IDENT   bool 20\n+  PUNCH   = [alone] 21\n+  SUBTREE () 22\n+    IDENT   true 29\n+    PUNCH   , [joint] 25\n+    IDENT   false 31\n+  PUNCH   ; [alone] 28\n+\"#,\n+    );\n+}\n+\n #[test]\n fn test_vis() {\n     parse_macro("}, {"sha": "46c4207185f603fbb00c13b09d0278e74b53de8f", "filename": "crates/ra_mbe/src/tt_iter.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_mbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_iter.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -40,9 +40,11 @@ impl<'a> TtIter<'a> {\n         }\n     }\n \n-    pub(crate) fn expect_literal(&mut self) -> Result<&'a tt::Literal, ()> {\n-        match self.expect_leaf()? {\n-            tt::Leaf::Literal(it) => Ok(it),\n+    pub(crate) fn expect_literal(&mut self) -> Result<&'a tt::Leaf, ()> {\n+        let it = self.expect_leaf()?;\n+        match it {\n+            tt::Leaf::Literal(_) => Ok(it),\n+            tt::Leaf::Ident(ident) if ident.text == \"true\" || ident.text == \"false\" => Ok(it),\n             _ => Err(()),\n         }\n     }"}, {"sha": "004943b9e0653becfe6b1daa7970624068178b9e", "filename": "crates/ra_proc_macro/src/lib.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Flib.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -2,7 +2,7 @@\n //!\n //! We separate proc-macro expanding logic to an extern program to allow\n //! different implementations (e.g. wasm or dylib loading). And this crate\n-//! is used to provide basic infrastructure  for communication between two\n+//! is used to provide basic infrastructure for communication between two\n //! processes: Client (RA itself), Server (the external program)\n \n mod rpc;\n@@ -13,6 +13,7 @@ use process::{ProcMacroProcessSrv, ProcMacroProcessThread};\n use ra_tt::{SmolStr, Subtree};\n use std::{\n     ffi::OsStr,\n+    io,\n     path::{Path, PathBuf},\n     sync::Arc,\n };\n@@ -57,14 +58,10 @@ pub struct ProcMacroClient {\n }\n \n impl ProcMacroClient {\n-    pub fn extern_process<I, S>(\n-        process_path: &Path,\n-        args: I,\n-    ) -> Result<ProcMacroClient, std::io::Error>\n-    where\n-        I: IntoIterator<Item = S>,\n-        S: AsRef<OsStr>,\n-    {\n+    pub fn extern_process(\n+        process_path: PathBuf,\n+        args: impl IntoIterator<Item = impl AsRef<OsStr>>,\n+    ) -> io::Result<ProcMacroClient> {\n         let (thread, process) = ProcMacroProcessSrv::run(process_path, args)?;\n         Ok(ProcMacroClient {\n             kind: ProcMacroClientKind::Process { process: Arc::new(process), thread },\n@@ -84,7 +81,7 @@ impl ProcMacroClient {\n             ProcMacroClientKind::Process { process, .. } => {\n                 let macros = match process.find_proc_macros(dylib_path) {\n                     Err(err) => {\n-                        eprintln!(\"Fail to find proc macro. Error: {:#?}\", err);\n+                        eprintln!(\"Failed to find proc macros. Error: {:#?}\", err);\n                         return vec![];\n                     }\n                     Ok(macros) => macros,"}, {"sha": "95d9b8804e1481615e64383e26dbd29ba56760bb", "filename": "crates/ra_proc_macro/src/msg.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -1,4 +1,4 @@\n-//! Defines messages for cross-process message based on `ndjson` wire protocol\n+//! Defines messages for cross-process message passing based on `ndjson` wire protocol\n \n use std::{\n     convert::TryFrom,\n@@ -31,7 +31,7 @@ macro_rules! impl_try_from_response {\n             fn try_from(value: Response) -> Result<Self, Self::Error> {\n                 match value {\n                     Response::$tag(res) => Ok(res),\n-                    _ => Err(\"Fail to convert from response\"),\n+                    _ => Err(concat!(\"Failed to convert response to \", stringify!($tag))),\n                 }\n             }\n         }\n@@ -53,18 +53,16 @@ pub enum ErrorCode {\n     ExpansionError,\n }\n \n-pub trait Message: Sized + Serialize + DeserializeOwned {\n-    fn read(r: &mut impl BufRead) -> io::Result<Option<Self>> {\n-        let text = match read_json(r)? {\n-            None => return Ok(None),\n-            Some(text) => text,\n-        };\n-        let msg = serde_json::from_str(&text)?;\n-        Ok(Some(msg))\n+pub trait Message: Serialize + DeserializeOwned {\n+    fn read(inp: &mut impl BufRead) -> io::Result<Option<Self>> {\n+        Ok(match read_json(inp)? {\n+            None => None,\n+            Some(text) => Some(serde_json::from_str(&text)?),\n+        })\n     }\n-    fn write(self, w: &mut impl Write) -> io::Result<()> {\n+    fn write(self, out: &mut impl Write) -> io::Result<()> {\n         let text = serde_json::to_string(&self)?;\n-        write_json(w, &text)\n+        write_json(out, &text)\n     }\n }\n \n@@ -73,15 +71,12 @@ impl Message for Response {}\n \n fn read_json(inp: &mut impl BufRead) -> io::Result<Option<String>> {\n     let mut buf = String::new();\n-    if inp.read_line(&mut buf)? == 0 {\n-        return Ok(None);\n-    }\n-    // Remove ending '\\n'\n-    let buf = &buf[..buf.len() - 1];\n-    if buf.is_empty() {\n-        return Ok(None);\n-    }\n-    Ok(Some(buf.to_string()))\n+    inp.read_line(&mut buf)?;\n+    buf.pop(); // Remove traling '\\n'\n+    Ok(match buf.len() {\n+        0 => None,\n+        _ => Some(buf),\n+    })\n }\n \n fn write_json(out: &mut impl Write, msg: &str) -> io::Result<()> {"}, {"sha": "673f80a7ab02aed8aedb0c79bbe14194cf60de00", "filename": "crates/ra_proc_macro/src/process.rs", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -9,7 +9,7 @@ use crate::rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTas\n use io::{BufRead, BufReader};\n use std::{\n     convert::{TryFrom, TryInto},\n-    ffi::OsStr,\n+    ffi::{OsStr, OsString},\n     io::{self, Write},\n     path::{Path, PathBuf},\n     process::{Child, Command, Stdio},\n@@ -28,66 +28,11 @@ pub(crate) struct ProcMacroProcessThread {\n     handle: jod_thread::JoinHandle<()>,\n }\n \n-struct Task {\n-    req: Request,\n-    result_tx: Sender<Option<Response>>,\n-}\n-\n-struct Process {\n-    path: PathBuf,\n-    child: Child,\n-}\n-\n-impl Drop for Process {\n-    fn drop(&mut self) {\n-        let _ = self.child.kill();\n-    }\n-}\n-\n-impl Process {\n-    fn run<I, S>(process_path: &Path, args: I) -> Result<Process, io::Error>\n-    where\n-        I: IntoIterator<Item = S>,\n-        S: AsRef<OsStr>,\n-    {\n-        let child = Command::new(process_path.clone())\n-            .args(args)\n-            .stdin(Stdio::piped())\n-            .stdout(Stdio::piped())\n-            .stderr(Stdio::null())\n-            .spawn()?;\n-\n-        Ok(Process { path: process_path.into(), child })\n-    }\n-\n-    fn restart(&mut self) -> Result<(), io::Error> {\n-        let _ = self.child.kill();\n-        self.child = Command::new(self.path.clone())\n-            .stdin(Stdio::piped())\n-            .stdout(Stdio::piped())\n-            .stderr(Stdio::null())\n-            .spawn()?;\n-        Ok(())\n-    }\n-\n-    fn stdio(&mut self) -> Option<(impl Write, impl BufRead)> {\n-        let stdin = self.child.stdin.take()?;\n-        let stdout = self.child.stdout.take()?;\n-        let read = BufReader::new(stdout);\n-\n-        Some((stdin, read))\n-    }\n-}\n-\n impl ProcMacroProcessSrv {\n-    pub fn run<I, S>(\n-        process_path: &Path,\n-        args: I,\n-    ) -> Result<(ProcMacroProcessThread, ProcMacroProcessSrv), io::Error>\n-    where\n-        I: IntoIterator<Item = S>,\n-        S: AsRef<OsStr>,\n-    {\n+    pub fn run(\n+        process_path: PathBuf,\n+        args: impl IntoIterator<Item = impl AsRef<OsStr>>,\n+    ) -> io::Result<(ProcMacroProcessThread, ProcMacroProcessSrv)> {\n         let process = Process::run(process_path, args)?;\n \n         let (task_tx, task_rx) = bounded(0);\n@@ -197,11 +142,62 @@ fn client_loop(task_rx: Receiver<Task>, mut process: Process) {\n     }\n }\n \n+struct Task {\n+    req: Request,\n+    result_tx: Sender<Option<Response>>,\n+}\n+\n+struct Process {\n+    path: PathBuf,\n+    args: Vec<OsString>,\n+    child: Child,\n+}\n+\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        let _ = self.child.kill();\n+    }\n+}\n+\n+impl Process {\n+    fn run(\n+        path: PathBuf,\n+        args: impl IntoIterator<Item = impl AsRef<OsStr>>,\n+    ) -> io::Result<Process> {\n+        let args = args.into_iter().map(|s| s.as_ref().into()).collect();\n+        let child = mk_child(&path, &args)?;\n+        Ok(Process { path, args, child })\n+    }\n+\n+    fn restart(&mut self) -> io::Result<()> {\n+        let _ = self.child.kill();\n+        self.child = mk_child(&self.path, &self.args)?;\n+        Ok(())\n+    }\n+\n+    fn stdio(&mut self) -> Option<(impl Write, impl BufRead)> {\n+        let stdin = self.child.stdin.take()?;\n+        let stdout = self.child.stdout.take()?;\n+        let read = BufReader::new(stdout);\n+\n+        Some((stdin, read))\n+    }\n+}\n+\n+fn mk_child(path: &Path, args: impl IntoIterator<Item = impl AsRef<OsStr>>) -> io::Result<Child> {\n+    Command::new(&path)\n+        .args(args)\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .stderr(Stdio::null())\n+        .spawn()\n+}\n+\n fn send_request(\n     mut writer: &mut impl Write,\n     mut reader: &mut impl BufRead,\n     req: Request,\n-) -> Result<Option<Response>, io::Error> {\n+) -> io::Result<Option<Response>> {\n     req.write(&mut writer)?;\n     Ok(Response::read(&mut reader)?)\n }"}, {"sha": "4ce485926369ed23f21a06492e9f991c57d1c845", "filename": "crates/ra_proc_macro/src/rpc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -1,9 +1,9 @@\n-//! Data struture serialization related stuffs for RPC\n+//! Data struture serialization related stuff for RPC\n //!\n-//! Define all necessary rpc serialization data structure,\n-//! which include ra_tt related data and some task messages.\n-//! Although adding Serialize and Deserialize trait to ra_tt directly seem to be much easier,\n-//! we deliberately duplicate the ra_tt struct with #[serde(with = \"XXDef\")]\n+//! Defines all necessary rpc serialization data structures,\n+//! which includes `ra_tt` related data and some task messages.\n+//! Although adding `Serialize` and `Deserialize` traits to `ra_tt` directly seems\n+//! to be much easier, we deliberately duplicate `ra_tt` structs with `#[serde(with = \"XXDef\")]`\n //! for separation of code responsibility.\n \n use ra_tt::{\n@@ -34,15 +34,15 @@ pub struct ListMacrosResult {\n pub struct ExpansionTask {\n     /// Argument of macro call.\n     ///\n-    /// In custom derive that would be a struct or enum; in attribute-like macro - underlying\n+    /// In custom derive this will be a struct or enum; in attribute-like macro - underlying\n     /// item; in function-like macro - the macro body.\n     #[serde(with = \"SubtreeDef\")]\n     pub macro_body: Subtree,\n \n-    /// Names of macros to expand.\n+    /// Name of macro to expand.\n     ///\n-    /// In custom derive those are names of derived traits (`Serialize`, `Getters`, etc.). In\n-    /// attribute-like and functiona-like macros - single name of macro itself (`show_streams`).\n+    /// In custom derive this is the name of the derived trait (`Serialize`, `Getters`, etc.).\n+    /// In attribute-like and function-like macros - single name of macro itself (`show_streams`).\n     pub macro_name: String,\n \n     /// Possible attributes for the attribute-like macros."}, {"sha": "5f1f3ba3c7d8582483555518bf7911575310aeec", "filename": "crates/ra_proc_macro_srv/src/cli.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -2,55 +2,43 @@\n \n use crate::{expand_task, list_macros};\n use ra_proc_macro::msg::{self, Message};\n-\n use std::io;\n \n-fn read_request() -> Result<Option<msg::Request>, io::Error> {\n-    let stdin = io::stdin();\n-    let mut stdin = stdin.lock();\n-    msg::Request::read(&mut stdin)\n-}\n-\n-fn write_response(res: Result<msg::Response, String>) -> Result<(), io::Error> {\n-    let msg: msg::Response = match res {\n-        Ok(res) => res,\n-        Err(err) => msg::Response::Error(msg::ResponseError {\n-            code: msg::ErrorCode::ExpansionError,\n-            message: err,\n-        }),\n-    };\n-\n-    let stdout = io::stdout();\n-    let mut stdout = stdout.lock();\n-    msg.write(&mut stdout)\n-}\n-\n pub fn run() {\n     loop {\n         let req = match read_request() {\n             Err(err) => {\n-                eprintln!(\"Read message error on ra_proc_macro_srv: {}\", err.to_string());\n+                eprintln!(\"Read message error on ra_proc_macro_srv: {}\", err);\n                 continue;\n             }\n             Ok(None) => continue,\n             Ok(Some(req)) => req,\n         };\n \n-        match req {\n-            msg::Request::ListMacro(task) => {\n-                if let Err(err) =\n-                    write_response(list_macros(&task).map(|it| msg::Response::ListMacro(it)))\n-                {\n-                    eprintln!(\"Write message error on list macro: {}\", err);\n-                }\n-            }\n+        let res = match req {\n+            msg::Request::ListMacro(task) => Ok(msg::Response::ListMacro(list_macros(&task))),\n             msg::Request::ExpansionMacro(task) => {\n-                if let Err(err) =\n-                    write_response(expand_task(&task).map(|it| msg::Response::ExpansionMacro(it)))\n-                {\n-                    eprintln!(\"Write message error on expansion macro: {}\", err);\n-                }\n+                expand_task(&task).map(msg::Response::ExpansionMacro)\n             }\n+        };\n+\n+        let msg = res.unwrap_or_else(|err| {\n+            msg::Response::Error(msg::ResponseError {\n+                code: msg::ErrorCode::ExpansionError,\n+                message: err,\n+            })\n+        });\n+\n+        if let Err(err) = write_response(msg) {\n+            eprintln!(\"Write message error: {}\", err);\n         }\n     }\n }\n+\n+fn read_request() -> io::Result<Option<msg::Request>> {\n+    msg::Request::read(&mut io::stdin().lock())\n+}\n+\n+fn write_response(msg: msg::Response) -> io::Result<()> {\n+    msg.write(&mut io::stdout().lock())\n+}"}, {"sha": "d202eb0fde42fb21d5fd7ba81d8453f9c2896823", "filename": "crates/ra_proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 45, "deletions": 58, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -9,43 +9,37 @@ use libloading::Library;\n use memmap::Mmap;\n use ra_proc_macro::ProcMacroKind;\n \n-use std::io::Error as IoError;\n-use std::io::ErrorKind as IoErrorKind;\n+use std::io;\n \n const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n \n-fn invalid_data_err(e: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> IoError {\n-    IoError::new(IoErrorKind::InvalidData, e)\n+fn invalid_data_err(e: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> io::Error {\n+    io::Error::new(io::ErrorKind::InvalidData, e)\n }\n \n fn is_derive_registrar_symbol(symbol: &str) -> bool {\n     symbol.contains(NEW_REGISTRAR_SYMBOL)\n }\n \n-fn find_registrar_symbol(file: &Path) -> Result<Option<String>, IoError> {\n+fn find_registrar_symbol(file: &Path) -> io::Result<Option<String>> {\n     let file = File::open(file)?;\n     let buffer = unsafe { Mmap::map(&file)? };\n     let object = Object::parse(&buffer).map_err(invalid_data_err)?;\n \n-    match object {\n+    let name = match object {\n         Object::Elf(elf) => {\n             let symbols = elf.dynstrtab.to_vec().map_err(invalid_data_err)?;\n-            let name =\n-                symbols.iter().find(|s| is_derive_registrar_symbol(s)).map(|s| s.to_string());\n-            Ok(name)\n-        }\n-        Object::PE(pe) => {\n-            let name = pe\n-                .exports\n-                .iter()\n-                .flat_map(|s| s.name)\n-                .find(|s| is_derive_registrar_symbol(s))\n-                .map(|s| s.to_string());\n-            Ok(name)\n+            symbols.into_iter().find(|s| is_derive_registrar_symbol(s)).map(&str::to_owned)\n         }\n+        Object::PE(pe) => pe\n+            .exports\n+            .iter()\n+            .flat_map(|s| s.name)\n+            .find(|s| is_derive_registrar_symbol(s))\n+            .map(&str::to_owned),\n         Object::Mach(Mach::Binary(binary)) => {\n             let exports = binary.exports().map_err(invalid_data_err)?;\n-            let name = exports\n+            exports\n                 .iter()\n                 .map(|s| {\n                     // In macos doc:\n@@ -59,11 +53,11 @@ fn find_registrar_symbol(file: &Path) -> Result<Option<String>, IoError> {\n                     }\n                 })\n                 .find(|s| is_derive_registrar_symbol(s))\n-                .map(|s| s.to_string());\n-            Ok(name)\n+                .map(&str::to_owned)\n         }\n-        _ => Ok(None),\n-    }\n+        _ => return Ok(None),\n+    };\n+    return Ok(name);\n }\n \n /// Loads dynamic library in platform dependent manner.\n@@ -93,15 +87,16 @@ fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n }\n \n struct ProcMacroLibraryLibloading {\n-    // Hold the dylib to prevent it for unloadeding\n+    // Hold the dylib to prevent it from unloading\n     _lib: Library,\n     exported_macros: Vec<bridge::client::ProcMacro>,\n }\n \n impl ProcMacroLibraryLibloading {\n-    fn open(file: &Path) -> Result<Self, IoError> {\n-        let symbol_name = find_registrar_symbol(file)?\n-            .ok_or(invalid_data_err(format!(\"Cannot find registrar symbol in file {:?}\", file)))?;\n+    fn open(file: &Path) -> io::Result<Self> {\n+        let symbol_name = find_registrar_symbol(file)?.ok_or_else(|| {\n+            invalid_data_err(format!(\"Cannot find registrar symbol in file {}\", file.display()))\n+        })?;\n \n         let lib = load_library(file).map_err(invalid_data_err)?;\n         let exported_macros = {\n@@ -121,18 +116,16 @@ pub struct Expander {\n }\n \n impl Expander {\n-    pub fn new<P: AsRef<Path>>(lib: &P) -> Result<Expander, String> {\n-        let mut libs = vec![];\n-        /* Some libraries for dynamic loading require canonicalized path (even when it is\n-        already absolute\n-        */\n-        let lib =\n-            lib.as_ref().canonicalize().expect(&format!(\"Cannot canonicalize {:?}\", lib.as_ref()));\n+    pub fn new(lib: &Path) -> Result<Expander, String> {\n+        // Some libraries for dynamic loading require canonicalized path even when it is\n+        // already absolute\n+        let lib = lib\n+            .canonicalize()\n+            .unwrap_or_else(|err| panic!(\"Cannot canonicalize {}: {:?}\", lib.display(), err));\n \n         let library = ProcMacroLibraryImpl::open(&lib).map_err(|e| e.to_string())?;\n-        libs.push(library);\n \n-        Ok(Expander { libs })\n+        Ok(Expander { libs: vec![library] })\n     }\n \n     pub fn expand(\n@@ -176,7 +169,6 @@ impl Expander {\n                             parsed_attributes,\n                             parsed_body,\n                         );\n-\n                         return res.map(|it| it.subtree);\n                     }\n                     _ => continue,\n@@ -187,26 +179,21 @@ impl Expander {\n         Err(bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n     }\n \n-    pub fn list_macros(&self) -> Result<Vec<(String, ProcMacroKind)>, bridge::PanicMessage> {\n-        let mut result = vec![];\n-\n-        for lib in &self.libs {\n-            for proc_macro in &lib.exported_macros {\n-                let res = match proc_macro {\n-                    bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n-                        (trait_name.to_string(), ProcMacroKind::CustomDerive)\n-                    }\n-                    bridge::client::ProcMacro::Bang { name, .. } => {\n-                        (name.to_string(), ProcMacroKind::FuncLike)\n-                    }\n-                    bridge::client::ProcMacro::Attr { name, .. } => {\n-                        (name.to_string(), ProcMacroKind::Attr)\n-                    }\n-                };\n-                result.push(res);\n-            }\n-        }\n-\n-        Ok(result)\n+    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n+        self.libs\n+            .iter()\n+            .flat_map(|it| &it.exported_macros)\n+            .map(|proc_macro| match proc_macro {\n+                bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n+                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n+                }\n+                bridge::client::ProcMacro::Bang { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::FuncLike)\n+                }\n+                bridge::client::ProcMacro::Attr { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::Attr)\n+                }\n+            })\n+            .collect()\n     }\n }"}, {"sha": "3aca859db34b03e089c5fc8c7e9524556bc54a26", "filename": "crates/ra_proc_macro_srv/src/lib.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -3,10 +3,10 @@\n //! This library is able to call compiled Rust custom derive dynamic libraries on arbitrary code.\n //! The general idea here is based on https://github.com/fedochet/rust-proc-macro-expander.\n //!\n-//! But we change some several design for fitting RA needs:\n+//! But we adapt it to better fit RA needs:\n //!\n-//! * We use `ra_tt` for proc-macro `TokenStream` server, it is easy to manipute and interact with\n-//!   RA then proc-macro2 token stream.\n+//! * We use `ra_tt` for proc-macro `TokenStream` server, it is easier to manipulate and interact with\n+//!   RA than `proc-macro2` token stream.\n //! * By **copying** the whole rustc `lib_proc_macro` code, we are able to build this with `stable`\n //!   rustc rather than `unstable`. (Although in gerenal ABI compatibility is still an issue)\n \n@@ -21,36 +21,28 @@ mod dylib;\n \n use proc_macro::bridge::client::TokenStream;\n use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n+use std::path::Path;\n \n pub(crate) fn expand_task(task: &ExpansionTask) -> Result<ExpansionResult, String> {\n-    let expander = dylib::Expander::new(&task.lib)\n-        .expect(&format!(\"Cannot expand with provided libraries: ${:?}\", &task.lib));\n+    let expander = create_expander(&task.lib);\n \n     match expander.expand(&task.macro_name, &task.macro_body, task.attributes.as_ref()) {\n         Ok(expansion) => Ok(ExpansionResult { expansion }),\n         Err(msg) => {\n-            let reason = format!(\n-                \"Cannot perform expansion for {}: error {:?}!\",\n-                &task.macro_name,\n-                msg.as_str()\n-            );\n-            Err(reason)\n+            Err(format!(\"Cannot perform expansion for {}: error {:?}\", &task.macro_name, msg))\n         }\n     }\n }\n \n-pub(crate) fn list_macros(task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n-    let expander = dylib::Expander::new(&task.lib)\n-        .expect(&format!(\"Cannot expand with provided libraries: ${:?}\", &task.lib));\n+pub(crate) fn list_macros(task: &ListMacrosTask) -> ListMacrosResult {\n+    let expander = create_expander(&task.lib);\n \n-    match expander.list_macros() {\n-        Ok(macros) => Ok(ListMacrosResult { macros }),\n-        Err(msg) => {\n-            let reason =\n-                format!(\"Cannot perform expansion for {:?}: error {:?}!\", &task.lib, msg.as_str());\n-            Err(reason)\n-        }\n-    }\n+    ListMacrosResult { macros: expander.list_macros() }\n+}\n+\n+fn create_expander(lib: &Path) -> dylib::Expander {\n+    dylib::Expander::new(lib)\n+        .unwrap_or_else(|err| panic!(\"Cannot create expander for {}: {:?}\", lib.display(), err))\n }\n \n pub mod cli;"}, {"sha": "f481d70b22f51de03b2bf44510b379cedccd147f", "filename": "crates/ra_proc_macro_srv/src/rustc_server.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Frustc_server.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -6,7 +6,7 @@\n //! The original idea from fedochet is using proc-macro2 as backend,\n //! we use ra_tt instead for better intergation with RA.\n //!\n-//! FIXME: No span and source file informatin is implemented yet\n+//! FIXME: No span and source file information is implemented yet\n \n use crate::proc_macro::bridge::{self, server};\n use ra_tt as tt;\n@@ -76,7 +76,16 @@ impl Extend<TokenTree> for TokenStream {\n impl Extend<TokenStream> for TokenStream {\n     fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n         for item in streams {\n-            self.subtree.token_trees.extend(&mut item.into_iter())\n+            for tkn in item {\n+                match tkn {\n+                    tt::TokenTree::Subtree(subtree) if subtree.delimiter.is_none() => {\n+                        self.subtree.token_trees.extend(subtree.token_trees);\n+                    }\n+                    _ => {\n+                        self.subtree.token_trees.push(tkn);\n+                    }\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "1f5d940fa0bcfc844de88bb845626d43948bb94d", "filename": "crates/ra_proc_macro_srv/src/tests/fixtures/test_serialize_proc_macro.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -25,8 +25,7 @@ SUBTREE $\n       SUBTREE () 4294967295\n         IDENT   feature 4294967295\n         PUNCH   = [alone] 4294967295\n-        SUBTREE $\n-          LITERAL \"cargo-clippy\" 0\n+        LITERAL \"cargo-clippy\" 0\n         PUNCH   , [alone] 4294967295\n         IDENT   allow 4294967295\n         SUBTREE () 4294967295"}, {"sha": "2139ec7a4dac87a960b255da09a67c265cfb2a71", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -60,6 +60,6 @@ pub fn list(crate_name: &str, version: &str) -> Vec<String> {\n     let path = fixtures::dylib_path(crate_name, version);\n     let task = ListMacrosTask { lib: path };\n \n-    let res = list_macros(&task).unwrap();\n+    let res = list_macros(&task);\n     res.macros.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()\n }"}, {"sha": "84008b2e344d671759fdf4979f9eaf64c94ad95c", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -303,8 +303,7 @@ pub fn load_extern_resources(\n                     if message.target.kind.contains(&\"proc-macro\".to_string()) {\n                         let package_id = message.package_id;\n                         // Skip rmeta file\n-                        if let Some(filename) =\n-                            message.filenames.iter().filter(|name| is_dylib(name)).next()\n+                        if let Some(filename) = message.filenames.iter().find(|name| is_dylib(name))\n                         {\n                             res.proc_dylib_paths.insert(package_id, filename.clone());\n                         }"}, {"sha": "06df8495c9688ab1740c7a5054eda50f818637f8", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -10,8 +10,8 @@ use ra_text_edit::TextEditBuilder;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxNodePtr, SyntaxToken,\n-    TextRange, TextUnit,\n+    AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxNodePtr,\n+    SyntaxToken, TextRange, TextUnit,\n };\n \n /// Returns ancestors of the node at the offset, sorted by length. This should\n@@ -90,6 +90,10 @@ pub fn neighbor<T: AstNode>(me: &T, direction: Direction) -> Option<T> {\n     me.syntax().siblings(direction).skip(1).find_map(T::cast)\n }\n \n+pub fn has_errors(node: &SyntaxNode) -> bool {\n+    node.children().any(|it| it.kind() == SyntaxKind::ERROR)\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub enum InsertPosition<T> {\n     First,"}, {"sha": "26e4576ffe9929d362895e441e46c4c5b3ded8e1", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -307,7 +307,11 @@ impl ast::UseTree {\n \n         fn split_path_prefix(prefix: &ast::Path) -> Option<ast::Path> {\n             let parent = prefix.parent_path()?;\n-            let mut res = make::path_unqualified(parent.segment()?);\n+            let segment = parent.segment()?;\n+            if algo::has_errors(segment.syntax()) {\n+                return None;\n+            }\n+            let mut res = make::path_unqualified(segment);\n             for p in iter::successors(parent.parent_path(), |it| it.parent_path()) {\n                 res = make::path_qualified(res, p.segment()?);\n             }"}, {"sha": "b14409c39c034589585616f90dc5e781602243e8", "filename": "crates/rust-analyzer/src/bin/args.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -84,7 +84,7 @@ impl Args {\n                 if matches.contains([\"-h\", \"--help\"]) {\n                     eprintln!(\n                         \"\\\n-ra-cli-parse\n+rust-analyzer parse\n \n USAGE:\n     rust-analyzer parse [FLAGS]\n@@ -104,7 +104,7 @@ FLAGS:\n                 if matches.contains([\"-h\", \"--help\"]) {\n                     eprintln!(\n                         \"\\\n-ra-cli-symbols\n+rust-analyzer symbols\n \n USAGE:\n     rust-analyzer highlight [FLAGS]\n@@ -123,7 +123,7 @@ FLAGS:\n                 if matches.contains([\"-h\", \"--help\"]) {\n                     eprintln!(\n                         \"\\\n-ra-cli-highlight\n+rust-analyzer highlight\n \n USAGE:\n     rust-analyzer highlight [FLAGS]\n@@ -143,7 +143,7 @@ FLAGS:\n                 if matches.contains([\"-h\", \"--help\"]) {\n                     eprintln!(\n                         \"\\\n-ra-cli-analysis-stats\n+rust-analyzer analysis-stats\n \n USAGE:\n     rust-analyzer analysis-stats [FLAGS] [OPTIONS] [PATH]\n@@ -193,7 +193,7 @@ ARGS:\n                 if matches.contains([\"-h\", \"--help\"]) {\n                     eprintln!(\n                         \"\\\n-rust-analyzer-analysis-bench\n+rust-analyzer analysis-bench\n \n USAGE:\n     rust-analyzer analysis-bench [FLAGS] [OPTIONS]\n@@ -236,7 +236,7 @@ ARGS:\n                 if matches.contains([\"-h\", \"--help\"]) {\n                     eprintln!(\n                         \"\\\n-ra-cli-diagnostics\n+rust-analyzer diagnostics\n \n USAGE:\n     rust-analyzer diagnostics [FLAGS] [PATH]\n@@ -269,7 +269,7 @@ ARGS:\n             _ => {\n                 eprintln!(\n                     \"\\\n-ra-cli\n+rust-analyzer\n \n USAGE:\n     rust-analyzer <SUBCOMMAND>\n@@ -281,6 +281,8 @@ SUBCOMMANDS:\n     analysis-bench\n     analysis-stats\n     highlight\n+    diagnostics\n+    proc-macro\n     parse\n     symbols\"\n                 );"}, {"sha": "e8d5dad6577c84945fe01043cbf859167e564403", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -51,7 +51,7 @@ fn main() -> Result<()> {\n             cli::diagnostics(path.as_ref(), load_output_dirs, with_proc_macro, all)?\n         }\n \n-        args::Command::ProcMacro => run_proc_macro_sv()?,\n+        args::Command::ProcMacro => run_proc_macro_srv()?,\n         args::Command::RunServer => run_server()?,\n         args::Command::Version => println!(\"rust-analyzer {}\", env!(\"REV\")),\n     }\n@@ -65,7 +65,7 @@ fn setup_logging() -> Result<()> {\n     Ok(())\n }\n \n-fn run_proc_macro_sv() -> Result<()> {\n+fn run_proc_macro_srv() -> Result<()> {\n     ra_proc_macro_srv::cli::run();\n     Ok(())\n }"}, {"sha": "d0a71120aafb390fb73ee45647fd5f7884a9d153", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -76,7 +76,7 @@ pub(crate) fn load_cargo(\n         ProcMacroClient::dummy()\n     } else {\n         let path = std::env::current_exe()?;\n-        ProcMacroClient::extern_process(&path, &[\"proc-macro\"]).unwrap()\n+        ProcMacroClient::extern_process(path, &[\"proc-macro\"]).unwrap()\n     };\n     let host = load(&source_roots, ws, &mut vfs, receiver, extern_dirs, &proc_macro_client);\n     Ok((host, source_roots))"}, {"sha": "d0218dcbf78b0a1092e61660dde3b079753d8a75", "filename": "crates/rust-analyzer/src/conv.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -24,7 +24,9 @@ use crate::{\n     world::WorldSnapshot,\n     Result,\n };\n-use semantic_tokens::{ATTRIBUTE, BUILTIN_TYPE, ENUM_MEMBER, LIFETIME, TYPE_ALIAS, UNION};\n+use semantic_tokens::{\n+    ATTRIBUTE, BUILTIN_TYPE, ENUM_MEMBER, LIFETIME, TYPE_ALIAS, UNION, UNRESOLVED_REFERENCE,\n+};\n \n pub trait Conv {\n     type Output;\n@@ -381,6 +383,7 @@ impl Conv for Highlight {\n             HighlightTag::Comment => SemanticTokenType::COMMENT,\n             HighlightTag::Attribute => ATTRIBUTE,\n             HighlightTag::Keyword => SemanticTokenType::KEYWORD,\n+            HighlightTag::UnresolvedReference => UNRESOLVED_REFERENCE,\n         };\n \n         for modifier in self.modifiers.iter() {"}, {"sha": "10fe696f6f108bad64fdf25471f75b97fe34e24e", "filename": "crates/rust-analyzer/src/semantic_tokens.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -10,6 +10,8 @@ pub(crate) const ENUM_MEMBER: SemanticTokenType = SemanticTokenType::new(\"enumMe\n pub(crate) const LIFETIME: SemanticTokenType = SemanticTokenType::new(\"lifetime\");\n pub(crate) const TYPE_ALIAS: SemanticTokenType = SemanticTokenType::new(\"typeAlias\");\n pub(crate) const UNION: SemanticTokenType = SemanticTokenType::new(\"union\");\n+pub(crate) const UNRESOLVED_REFERENCE: SemanticTokenType =\n+    SemanticTokenType::new(\"unresolvedReference\");\n \n pub(crate) const CONSTANT: SemanticTokenModifier = SemanticTokenModifier::new(\"constant\");\n pub(crate) const CONTROL_FLOW: SemanticTokenModifier = SemanticTokenModifier::new(\"controlFlow\");\n@@ -43,6 +45,7 @@ pub(crate) const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n     LIFETIME,\n     TYPE_ALIAS,\n     UNION,\n+    UNRESOLVED_REFERENCE,\n ];\n \n pub(crate) const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &["}, {"sha": "8e1744bf9026b30bd6e719119ae6f77f3aba945e", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -148,20 +148,17 @@ impl WorldState {\n \n         let proc_macro_client = match &config.proc_macro_srv {\n             None => ProcMacroClient::dummy(),\n-            Some((path, args)) => {\n-                let path = std::path::Path::new(path);\n-                match ProcMacroClient::extern_process(path, args) {\n-                    Ok(it) => it,\n-                    Err(err) => {\n-                        log::error!(\n-                            \"Fail to run ra_proc_macro_srv from path {}, error : {}\",\n-                            path.to_string_lossy(),\n-                            err\n-                        );\n-                        ProcMacroClient::dummy()\n-                    }\n+            Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n+                Ok(it) => it,\n+                Err(err) => {\n+                    log::error!(\n+                        \"Fail to run ra_proc_macro_srv from path {}, error: {:?}\",\n+                        path,\n+                        err\n+                    );\n+                    ProcMacroClient::dummy()\n                 }\n-            }\n+            },\n         };\n \n         workspaces\n@@ -184,7 +181,7 @@ impl WorldState {\n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n         WorldState {\n-            config: config,\n+            config,\n             roots: folder_roots,\n             workspaces: Arc::new(workspaces),\n             analysis_host,"}, {"sha": "13ab2acc21f3e63d8467a5b7a9d2c68959ce4ad7", "filename": "docs/user/readme.adoc", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/docs%2Fuser%2Freadme.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/docs%2Fuser%2Freadme.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Freadme.adoc?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -14,9 +14,9 @@\n // Master copy of this document lives in the https://github.com/rust-analyzer/rust-analyzer repository\n \n At its core, rust-analyzer is a *library* for semantic analysis of Rust code as it changes over time.\n-This manual focuses on a specific usage of the library -- the implementation of\n-https://microsoft.github.io/language-server-protocol/[Language Server Protocol].\n-LSP allows various code editors, like VS Code, Emacs or Vim, to implement semantic features like completion or goto definition by talking to an external language server process.\n+This manual focuses on a specific usage of the library -- running it as part of a server that implements the\n+https://microsoft.github.io/language-server-protocol/[Language Server Protocol] (LSP).\n+The LSP allows various code editors, like VS Code, Emacs or Vim, to implement semantic features like completion or goto definition by talking to an external language server process.\n \n To improve this document, send a pull request against\n https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/readme.adoc[this file].\n@@ -26,7 +26,7 @@ https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/readme.adoc\n In theory, one should be able to just install the server binary and have it automatically work with any editor.\n We are not there yet, so some editor specific setup is required.\n \n-Additionally, rust-analyzer needs sources of the standard library.\n+Additionally, rust-analyzer needs the sources of the standard library.\n If the source code is not present, rust-analyzer will attempt to install it automatically.\n \n To add the sources manually, run the following command:\n@@ -38,7 +38,7 @@ $ rustup component add rust-src\n === VS Code\n \n This is the best supported editor at the moment.\n-rust-analyzer plugin for VS Code is maintained\n+The rust-analyzer plugin for VS Code is maintained\n https://github.com/rust-analyzer/rust-analyzer/tree/master/editors/code[in tree].\n \n You can install the latest release of the plugin from\n@@ -74,7 +74,7 @@ We ship nightly releases for VS Code. To help us out with testing the newest cod\n { \"rust-analyzer.updates.channel\": \"nightly\" }\n ----\n \n-You will be prompted to install the `nightly` extension version. Just click `Download now` and from that moment you will get automatic updates each 24 hours.\n+You will be prompted to install the `nightly` extension version. Just click `Download now` and from that moment you will get automatic updates every 24 hours.\n \n If you don't want to be asked for `Download now` every day when the new nightly version is released add the following to your `settings.json`:\n [source,json]\n@@ -110,19 +110,21 @@ Here are some useful self-diagnostic commands:\n \n === Language Server Binary\n \n-Other editors generally require `rust-analyzer` binary to be in `$PATH`.\n-You can download the pre-built binary from\n-https://github.com/rust-analyzer/rust-analyzer/releases[releases]\n-page, or you can install it from source using the following command:\n+Other editors generally require the `rust-analyzer` binary to be in `$PATH`.\n+You can download the pre-built binary from the https://github.com/rust-analyzer/rust-analyzer/releases[releases] page. Typically, you then need to rename the binary for your platform, e.g. `rust-analyzer-mac` if you're on Mac OS, to `rust-analzyer` and make it executable in addition to moving it into a directory in your `$PATH`.\n+\n+Alternatively, you can install it from source using the following command:\n \n [source,bash]\n ----\n $ cargo xtask install --server\n ----\n \n+If your editor can't find the binary even though the binary is on your `$PATH`, the likely explanation is that it doesn't see the same `$PATH` as the shell, see https://github.com/rust-analyzer/rust-analyzer/issues/1811[this issue]. On Unix, running the editor from a shell or changing the `.desktop` file to set the environment should help.\n+\n ==== Arch Linux\n \n-`rust-analyzer` binary can be installed from AUR (Arch User Repository):\n+The `rust-analyzer` binary can be installed from AUR (Arch User Repository):\n \n - https://aur.archlinux.org/packages/rust-analyzer-bin[`rust-analyzer-bin`] (binary from GitHub releases)\n - https://aur.archlinux.org/packages/rust-analyzer[`rust-analyzer`] (built from latest tagged source)\n@@ -156,8 +158,8 @@ The are several LSP client implementations for vim:\n 2. Run `:CocInstall coc-rust-analyzer` to install\n    https://github.com/fannheyward/coc-rust-analyzer[coc-rust-analyzer],\n    this extension implements _most_ of the features supported in the VSCode extension:\n-   * same configurations as VSCode extension, `rust-analyzer.serverPath`, `rust-analyzer.enableCargoWatchOnStartup` etc.\n-   * same commands too, `rust-analyzer.analyzerStatus`, `rust-analyzer.startCargoWatch` etc.\n+   * same configurations as VSCode extension, `rust-analyzer.serverPath`, `rust-analyzer.cargo.features` etc.\n+   * same commands too, `rust-analyzer.analyzerStatus`, `rust-analyzer.ssr` etc.\n    * highlighting and inlay_hints are not implemented yet\n \n ==== LanguageClient-neovim\n@@ -183,11 +185,20 @@ Once `neovim/nvim-lsp` is installed, use `+lua require'nvim_lsp'.rust_analyzer.s\n \n === Sublime Text 3\n \n-Prerequisites:\n+Prerequisites: You have installed the <<language-server-binary,`rust-analyzer` binary>>.\n+\n+You also need the `LSP` package. To install it:\n+\n+1. If you've never installed a Sublime Text package, install Package Control:\n+   * Open the command palette (Win/Linux: `ctrl+shift+p`, Mac: `cmd+shift+p`)\n+   * Type `Install Package Control`, press enter\n+2. In the command palette, run `Package control: Install package`, and in the list that pops up, type `LSP` and press enter.\n+\n+Finally, with your Rust project open, in the command palette, run `LSP: Enable Language Server In Project` or `LSP: Enable Language Server Globally`, then select `rust-analyzer` in the list that pops up to enable the rust-analyzer LSP. The latter means that rust-analzyer is enabled by default in Rust projects.\n \n-`LSP` package.\n+If it worked, you should see \"rust-analzyer, Line X, Column Y\" on the left side of the bottom bar, and after waiting a bit, functionality like tooltips on hovering over variables should become available.\n \n-Invoke the command palette (`ctrl+shift+p`) and type LSP enable to locally/globally enable the rust-analyzer LSP (type LSP enable, then choose either locally or globally, then select rust-analyzer)\n+If you get an error saying `No such file or directory: 'rust-analyzer'`, see the <<language-server-binary,section on installing the language server binary>>.\n \n == Usage\n "}, {"sha": "79410ad1094d9f17f2c636de3725995c04bb30ca", "filename": "editors/code/package.json", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -517,6 +517,10 @@\n                 \"id\": \"union\",\n                 \"description\": \"Style for C-style untagged unions\",\n                 \"superType\": \"type\"\n+            },\n+            {\n+                \"id\": \"unresolvedReference\",\n+                \"description\": \"Style for names which can not be resolved due to compilation errors\"\n             }\n         ],\n         \"semanticTokenModifiers\": ["}, {"sha": "0e4dcb95a2dfea35cb3defc3a2aeb3b08271bdb2", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=7f143b154e7c47b1f5bdc558bb0b5d1f2bf74f8d", "patch": "@@ -9,9 +9,9 @@ mod gen_syntax;\n mod gen_parser_tests;\n mod gen_assists_docs;\n \n-use std::{fs, mem, path::Path};\n+use std::{mem, path::Path};\n \n-use crate::Result;\n+use crate::{not_bash::fs2, Result};\n \n pub use self::{\n     gen_assists_docs::generate_assists_docs, gen_parser_tests::generate_parser_tests,\n@@ -39,7 +39,7 @@ pub enum Mode {\n /// A helper to update file on disk if it has changed.\n /// With verify = false,\n fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n-    match fs::read_to_string(path) {\n+    match fs2::read_to_string(path) {\n         Ok(ref old_contents) if normalize(old_contents) == normalize(contents) => {\n             return Ok(());\n         }\n@@ -49,7 +49,7 @@ fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n         anyhow::bail!(\"`{}` is not up-to-date\", path.display());\n     }\n     eprintln!(\"updating {}\", path.display());\n-    fs::write(path, contents)?;\n+    fs2::write(path, contents)?;\n     return Ok(());\n \n     fn normalize(s: &str) -> String {\n@@ -65,15 +65,15 @@ fn extract_comment_blocks_with_empty_lines(text: &str) -> Vec<Vec<String>> {\n     do_extract_comment_blocks(text, true)\n }\n \n-fn do_extract_comment_blocks(text: &str, allow_blocks_with_empty_lins: bool) -> Vec<Vec<String>> {\n+fn do_extract_comment_blocks(text: &str, allow_blocks_with_empty_lines: bool) -> Vec<Vec<String>> {\n     let mut res = Vec::new();\n \n     let prefix = \"// \";\n     let lines = text.lines().map(str::trim_start);\n \n     let mut block = vec![];\n     for line in lines {\n-        if line == \"//\" && allow_blocks_with_empty_lins {\n+        if line == \"//\" && allow_blocks_with_empty_lines {\n             block.push(String::new());\n             continue;\n         }"}]}