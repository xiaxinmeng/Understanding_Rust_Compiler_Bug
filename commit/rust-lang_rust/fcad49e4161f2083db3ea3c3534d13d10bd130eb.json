{"sha": "fcad49e4161f2083db3ea3c3534d13d10bd130eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjYWQ0OWU0MTYxZjIwODNkYjNlYTNjMzUzNGQxM2QxMGJkMTMwZWI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-01T17:37:05Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-03T09:23:56Z"}, "message": "remove totally useless struct-field index", "tree": {"sha": "5f1a128a00c6c485835ecea0a2e52d813421b359", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f1a128a00c6c485835ecea0a2e52d813421b359"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcad49e4161f2083db3ea3c3534d13d10bd130eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcad49e4161f2083db3ea3c3534d13d10bd130eb", "html_url": "https://github.com/rust-lang/rust/commit/fcad49e4161f2083db3ea3c3534d13d10bd130eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcad49e4161f2083db3ea3c3534d13d10bd130eb/comments", "author": null, "committer": null, "parents": [{"sha": "1661947014fc2ecbbb7a30b1604499500dcf767e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1661947014fc2ecbbb7a30b1604499500dcf767e", "html_url": "https://github.com/rust-lang/rust/commit/1661947014fc2ecbbb7a30b1604499500dcf767e"}], "stats": {"total": 80, "additions": 34, "deletions": 46}, "files": [{"sha": "563cb1cbe736b1a0b6daf11f8788961b4441c2b3", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 34, "deletions": 46, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fcad49e4161f2083db3ea3c3534d13d10bd130eb/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcad49e4161f2083db3ea3c3534d13d10bd130eb/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fcad49e4161f2083db3ea3c3534d13d10bd130eb", "patch": "@@ -287,6 +287,15 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     for variant in &def.variants {\n         let vid = variant.did;\n         assert!(vid.is_local());\n+\n+        if let ty::VariantKind::Dict = variant.kind() {\n+            // tuple-like enum variant fields aren't really items so\n+            // don't try to encode them.\n+            for field in &variant.fields {\n+                encode_field(ecx, rbml_w, field, index);\n+            }\n+        }\n+\n         index.push(entry {\n             val: vid.node as i64,\n             pos: rbml_w.mark_stable_position(),\n@@ -308,11 +317,6 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         let stab = stability::lookup(ecx.tcx, vid);\n         encode_stability(rbml_w, stab);\n \n-        if let ty::VariantKind::Dict = variant.kind() {\n-            let idx = encode_info_for_struct(ecx, rbml_w, variant, index);\n-            encode_index(rbml_w, idx, write_i64);\n-        }\n-\n         encode_struct_fields(rbml_w, variant, vid);\n \n         let specified_disr_val = variant.disr_val;\n@@ -618,41 +622,29 @@ fn encode_provided_source(rbml_w: &mut Encoder,\n     }\n }\n \n-/* Returns an index of items in this class */\n-fn encode_info_for_struct<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                    rbml_w: &mut Encoder,\n-                                    variant: ty::VariantDef<'tcx>,\n-                                    global_index: &mut Vec<entry<i64>>)\n-                                    -> Vec<entry<i64>> {\n-    /* Each class has its own index, since different classes\n-       may have fields with the same name */\n-    let mut index = Vec::new();\n-     /* We encode both private and public fields -- need to include\n-        private fields to get the offsets right */\n-    for field in &variant.fields {\n-        let nm = field.name;\n-        let id = field.did.node;\n-\n-        let pos = rbml_w.mark_stable_position();\n-        index.push(entry {val: id as i64, pos: pos});\n-        global_index.push(entry {\n-            val: id as i64,\n-            pos: pos,\n-        });\n-        rbml_w.start_tag(tag_items_data_item);\n-        debug!(\"encode_info_for_struct: doing {} {}\",\n-               nm, id);\n-        encode_struct_field_family(rbml_w, field.vis);\n-        encode_name(rbml_w, nm);\n-        encode_bounds_and_type_for_item(rbml_w, ecx, id);\n-        encode_def_id(rbml_w, DefId::local(id));\n-\n-        let stab = stability::lookup(ecx.tcx, field.did);\n-        encode_stability(rbml_w, stab);\n+fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                          rbml_w: &mut Encoder,\n+                          field: ty::FieldDef<'tcx>,\n+                          global_index: &mut Vec<entry<i64>>) {\n+    let nm = field.name;\n+    let id = field.did.node;\n \n-        rbml_w.end_tag();\n-    }\n-    index\n+    let pos = rbml_w.mark_stable_position();\n+    global_index.push(entry {\n+        val: id as i64,\n+        pos: pos,\n+    });\n+    rbml_w.start_tag(tag_items_data_item);\n+    debug!(\"encode_field: encoding {} {}\", nm, id);\n+    encode_struct_field_family(rbml_w, field.vis);\n+    encode_name(rbml_w, nm);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, id);\n+    encode_def_id(rbml_w, DefId::local(id));\n+\n+    let stab = stability::lookup(ecx.tcx, field.did);\n+    encode_stability(rbml_w, stab);\n+\n+    rbml_w.end_tag();\n }\n \n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n@@ -1146,11 +1138,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let def = ecx.tcx.lookup_adt_def(def_id);\n         let variant = def.struct_variant();\n \n-        /* First, encode the fields\n-           These come first because we need to write them to make\n-           the index, and the index needs to be in the item for the\n-           class itself */\n-        let idx = encode_info_for_struct(ecx, rbml_w, variant, index);\n+        for field in &variant.fields {\n+            encode_field(ecx, rbml_w, field, index);\n+        }\n \n         /* Index the class*/\n         add_to_index(item, rbml_w, index);\n@@ -1179,8 +1169,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n \n-        /* Each class has its own index -- encode it */\n-        encode_index(rbml_w, idx, write_i64);\n         rbml_w.end_tag();\n \n         // If this is a tuple-like struct, encode the type of the constructor."}]}