{"sha": "7dd0f3459f558c1b557223a042f549b378cacae9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkZDBmMzQ1OWY1NThjMWI1NTcyMjNhMDQyZjU0OWIzNzhjYWNhZTk=", "commit": {"author": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-04-27T06:47:24Z"}, "committer": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-04-27T06:47:24Z"}, "message": "Refactor `if` to use `else` and iterator combinators", "tree": {"sha": "017ebe29cec3fdd2dfcebcb1b5c5c80f766a588e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/017ebe29cec3fdd2dfcebcb1b5c5c80f766a588e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dd0f3459f558c1b557223a042f549b378cacae9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dd0f3459f558c1b557223a042f549b378cacae9", "html_url": "https://github.com/rust-lang/rust/commit/7dd0f3459f558c1b557223a042f549b378cacae9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dd0f3459f558c1b557223a042f549b378cacae9/comments", "author": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c94f0f49f8e025aae11534f9f2b4c59c34b1edb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c94f0f49f8e025aae11534f9f2b4c59c34b1edb8", "html_url": "https://github.com/rust-lang/rust/commit/c94f0f49f8e025aae11534f9f2b4c59c34b1edb8"}], "stats": {"total": 50, "additions": 22, "deletions": 28}, "files": [{"sha": "3dd3a79b2873cd57c124a108856e1ab824219e70", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7dd0f3459f558c1b557223a042f549b378cacae9/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dd0f3459f558c1b557223a042f549b378cacae9/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=7dd0f3459f558c1b557223a042f549b378cacae9", "patch": "@@ -779,11 +779,11 @@ fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -\n         // our variable!\n         if local_id == var;\n         then {\n-            return true;\n+            true\n+        } else {\n+            false\n         }\n     }\n-\n-    false\n }\n \n struct Offset {\n@@ -853,13 +853,7 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, v\n                 BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n                 _ => None,\n             },\n-            ExprKind::Path(..) => {\n-                if same_var(cx, idx, var) {\n-                    Some(Offset::positive(\"0\".into()))\n-                } else {\n-                    None\n-                }\n-            },\n+            ExprKind::Path(..) if same_var(cx, idx, var) => Some(Offset::positive(\"0\".into())),\n             _ => None,\n         };\n \n@@ -883,11 +877,11 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n         then {\n-            return get_fixed_offset_var(cx, arg, var);\n+            get_fixed_offset_var(cx, arg, var)\n+        } else {\n+            get_fixed_offset_var(cx, expr, var)\n         }\n     }\n-\n-    get_fixed_offset_var(cx, expr, var)\n }\n \n fn get_indexed_assignments<'a, 'tcx>(\n@@ -925,12 +919,12 @@ fn get_indexed_assignments<'a, 'tcx>(\n \n         stmts\n             .iter()\n-            .map(|stmt| match stmt.kind {\n+            .filter_map(|stmt| match stmt.kind {\n                 StmtKind::Local(..) | StmtKind::Item(..) => None,\n-                StmtKind::Expr(e) | StmtKind::Semi(e) => Some(get_assignment(cx, e, var)),\n+                StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n             })\n-            .chain(expr.as_ref().into_iter().map(|e| Some(get_assignment(cx, &*e, var))))\n-            .filter_map(|op| op)\n+            .chain(expr.into_iter())\n+            .map(|op| get_assignment(cx, op, var))\n             .collect::<Option<Vec<_>>>()\n             .unwrap_or_default()\n     } else {\n@@ -996,23 +990,23 @@ fn detect_manual_memcpy<'a, 'tcx>(\n                     if let Some(arg) = len_args.get(0);\n                     if snippet(cx, arg.span, \"??\") == var_name;\n                     then {\n-                        return if offset.negate {\n+                        if offset.negate {\n                             format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value)\n                         } else {\n                             String::new()\n+                        }\n+                    } else {\n+                        let end_str = match limits {\n+                            ast::RangeLimits::Closed => {\n+                                let end = sugg::Sugg::hir(cx, end, \"<count>\");\n+                                format!(\"{}\", end + sugg::ONE)\n+                            },\n+                            ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n                         };\n+\n+                        print_sum(&Offset::positive(end_str), &offset)\n                     }\n                 }\n-\n-                let end_str = match limits {\n-                    ast::RangeLimits::Closed => {\n-                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n-                        format!(\"{}\", end + sugg::ONE)\n-                    },\n-                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n-                };\n-\n-                print_sum(&Offset::positive(end_str), &offset)\n             };\n \n             // The only statements in the for loops can be indexed assignments from"}]}