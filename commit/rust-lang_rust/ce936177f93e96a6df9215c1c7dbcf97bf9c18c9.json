{"sha": "ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "node_id": "C_kwDOAAsO6NoAKGNlOTM2MTc3ZjkzZTk2YTZkZjkyMTVjMWM3ZGJjZjk3YmY5YzE4Yzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-19T11:25:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-19T11:25:40Z"}, "message": "Auto merge of #14851 - HKalbasi:mir, r=HKalbasi\n\nHandle match scrutinee in closure captures\n\nfix #14754", "tree": {"sha": "3612de4d4c23ad9cd66796a52e991ab4ed803a20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3612de4d4c23ad9cd66796a52e991ab4ed803a20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "html_url": "https://github.com/rust-lang/rust/commit/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8ae2d39763c7228314065c1374fbe06b2e234c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ae2d39763c7228314065c1374fbe06b2e234c0", "html_url": "https://github.com/rust-lang/rust/commit/e8ae2d39763c7228314065c1374fbe06b2e234c0"}, {"sha": "60379dabfb56c1f4cc0dc10c999d81240ed9d998", "url": "https://api.github.com/repos/rust-lang/rust/commits/60379dabfb56c1f4cc0dc10c999d81240ed9d998", "html_url": "https://github.com/rust-lang/rust/commit/60379dabfb56c1f4cc0dc10c999d81240ed9d998"}], "stats": {"total": 178, "additions": 166, "deletions": 12}, "files": [{"sha": "a387bdbc19ebaeb7b26d36d38457a3c4ea1f9389", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "patch": "@@ -221,15 +221,15 @@ impl Body {\n \n     pub fn walk_bindings_in_pat(&self, pat_id: PatId, mut f: impl FnMut(BindingId)) {\n         self.walk_pats(pat_id, &mut |pat| {\n-            if let Pat::Bind { id, .. } = pat {\n+            if let Pat::Bind { id, .. } = &self[pat] {\n                 f(*id);\n             }\n         });\n     }\n \n-    pub fn walk_pats(&self, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n+    pub fn walk_pats(&self, pat_id: PatId, f: &mut impl FnMut(PatId)) {\n         let pat = &self[pat_id];\n-        f(pat);\n+        f(pat_id);\n         match pat {\n             Pat::Range { .. }\n             | Pat::Lit(..)"}, {"sha": "2b78e7e14fd869b997a0b9b7f386f36b40e13f48", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "patch": "@@ -147,7 +147,7 @@ impl<'a> PatCtxt<'a> {\n             }\n \n             hir_def::hir::Pat::Bind { id, subpat, .. } => {\n-                let bm = self.infer.pat_binding_modes[&pat];\n+                let bm = self.infer.binding_modes[id];\n                 ty = &self.infer[id];\n                 let name = &self.body.bindings[id].name;\n                 match (bm, ty.kind(Interner)) {"}, {"sha": "f01ee1b4e600bc38e702a52e0931d5fb2e39bcb6", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "patch": "@@ -389,7 +389,7 @@ pub struct InferenceResult {\n     standard_types: InternedStandardTypes,\n     /// Stores the types which were implicitly dereferenced in pattern binding modes.\n     pub pat_adjustments: FxHashMap<PatId, Vec<Ty>>,\n-    pub pat_binding_modes: FxHashMap<PatId, BindingMode>,\n+    pub binding_modes: ArenaMap<BindingId, BindingMode>,\n     pub expr_adjustments: FxHashMap<ExprId, Vec<Adjustment>>,\n     pub(crate) closure_info: FxHashMap<ClosureId, (Vec<CapturedItem>, FnTrait)>,\n     // FIXME: remove this field"}, {"sha": "a7d9246b7cff87f4972a71a0915c0d92752c9a59", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "patch": "@@ -504,9 +504,27 @@ impl InferenceContext<'_> {\n                 self.consume_exprs(args.iter().copied());\n             }\n             Expr::Match { expr, arms } => {\n-                self.consume_expr(*expr);\n                 for arm in arms.iter() {\n                     self.consume_expr(arm.expr);\n+                    if let Some(guard) = arm.guard {\n+                        self.consume_expr(guard);\n+                    }\n+                }\n+                self.walk_expr(*expr);\n+                if let Some(discr_place) = self.place_of_expr(*expr) {\n+                    if self.is_upvar(&discr_place) {\n+                        let mut capture_mode = None;\n+                        for arm in arms.iter() {\n+                            self.walk_pat(&mut capture_mode, arm.pat);\n+                        }\n+                        if let Some(c) = capture_mode {\n+                            self.push_capture(CapturedItemWithoutTy {\n+                                place: discr_place,\n+                                kind: c,\n+                                span: (*expr).into(),\n+                            })\n+                        }\n+                    }\n                 }\n             }\n             Expr::Break { expr, label: _ }\n@@ -618,6 +636,57 @@ impl InferenceContext<'_> {\n         }\n     }\n \n+    fn walk_pat(&mut self, result: &mut Option<CaptureKind>, pat: PatId) {\n+        let mut update_result = |ck: CaptureKind| match result {\n+            Some(r) => {\n+                *r = cmp::max(*r, ck);\n+            }\n+            None => *result = Some(ck),\n+        };\n+        self.body.walk_pats(pat, &mut |p| match &self.body[p] {\n+            Pat::Ref { .. }\n+            | Pat::Box { .. }\n+            | Pat::Missing\n+            | Pat::Wild\n+            | Pat::Tuple { .. }\n+            | Pat::Or(_) => (),\n+            Pat::TupleStruct { .. } | Pat::Record { .. } => {\n+                if let Some(variant) = self.result.variant_resolution_for_pat(p) {\n+                    let adt = variant.adt_id();\n+                    let is_multivariant = match adt {\n+                        hir_def::AdtId::EnumId(e) => self.db.enum_data(e).variants.len() != 1,\n+                        _ => false,\n+                    };\n+                    if is_multivariant {\n+                        update_result(CaptureKind::ByRef(BorrowKind::Shared));\n+                    }\n+                }\n+            }\n+            Pat::Slice { .. }\n+            | Pat::ConstBlock(_)\n+            | Pat::Path(_)\n+            | Pat::Lit(_)\n+            | Pat::Range { .. } => {\n+                update_result(CaptureKind::ByRef(BorrowKind::Shared));\n+            }\n+            Pat::Bind { id, .. } => match self.result.binding_modes[*id] {\n+                crate::BindingMode::Move => {\n+                    if self.is_ty_copy(self.result.type_of_binding[*id].clone()) {\n+                        update_result(CaptureKind::ByRef(BorrowKind::Shared));\n+                    } else {\n+                        update_result(CaptureKind::ByValue);\n+                    }\n+                }\n+                crate::BindingMode::Ref(r) => match r {\n+                    Mutability::Mut => update_result(CaptureKind::ByRef(BorrowKind::Mut {\n+                        allow_two_phase_borrow: false,\n+                    })),\n+                    Mutability::Not => update_result(CaptureKind::ByRef(BorrowKind::Shared)),\n+                },\n+            },\n+        });\n+    }\n+\n     fn expr_ty(&self, expr: ExprId) -> Ty {\n         self.result[expr].clone()\n     }\n@@ -641,14 +710,14 @@ impl InferenceContext<'_> {\n         false\n     }\n \n-    fn is_ty_copy(&self, ty: Ty) -> bool {\n+    fn is_ty_copy(&mut self, ty: Ty) -> bool {\n         if let TyKind::Closure(id, _) = ty.kind(Interner) {\n             // FIXME: We handle closure as a special case, since chalk consider every closure as copy. We\n             // should probably let chalk know which closures are copy, but I don't know how doing it\n             // without creating query cycles.\n             return self.result.closure_info.get(id).map(|x| x.1 == FnTrait::Fn).unwrap_or(true);\n         }\n-        ty.is_copy(self.db, self.owner)\n+        self.table.resolve_completely(ty).is_copy(self.db, self.owner)\n     }\n \n     fn select_from_expr(&mut self, expr: ExprId) {"}, {"sha": "05f6fcaead26f3f8c5e07580c27641d19e956fd9", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "patch": "@@ -340,7 +340,7 @@ impl<'a> InferenceContext<'a> {\n         } else {\n             BindingMode::convert(mode)\n         };\n-        self.result.pat_binding_modes.insert(pat, mode);\n+        self.result.binding_modes.insert(binding, mode);\n \n         let inner_ty = match subpat {\n             Some(subpat) => self.infer_pat(subpat, &expected, default_bm),\n@@ -439,7 +439,7 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {\n     let mut res = false;\n     body.walk_pats(pat_id, &mut |pat| {\n-        res |= matches!(pat, Pat::Bind { id, .. } if body.bindings[*id].mode == BindingAnnotation::Ref);\n+        res |= matches!(body[pat], Pat::Bind { id, .. } if body.bindings[id].mode == BindingAnnotation::Ref);\n     });\n     res\n }"}, {"sha": "811d60888074e56a0d467e8ea2db05171e4fa97b", "filename": "crates/hir-ty/src/layout/tests/closure.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs?ref=ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "patch": "@@ -182,6 +182,43 @@ fn capture_specific_fields() {\n     }\n }\n \n+#[test]\n+fn match_pattern() {\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            match y {\n+                _ => x,\n+            }\n+        }\n+    }\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            struct X(i64, i32, (u8, i128));\n+            let y: X = X(2, 5, (7, 3));\n+        ]\n+        |x: i64| {\n+            match y {\n+                X(_a, _b, _c) => x,\n+            }\n+        }\n+    }\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            struct X(i64, i32, (u8, i128));\n+            let y: X = X(2, 5, (7, 3));\n+        ]\n+        |x: i64| {\n+            match y {\n+                _y => x,\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn ellipsis_pattern() {\n     size_and_align_expr! {"}, {"sha": "1374fa332c6483514d70a758840bf89103cc10fc", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "patch": "@@ -236,9 +236,9 @@ impl SourceAnalyzer {\n         _db: &dyn HirDatabase,\n         pat: &ast::IdentPat,\n     ) -> Option<BindingMode> {\n-        let pat_id = self.pat_id(&pat.clone().into())?;\n+        let binding_id = self.binding_id_of_pat(pat)?;\n         let infer = self.infer.as_ref()?;\n-        infer.pat_binding_modes.get(&pat_id).map(|bm| match bm {\n+        infer.binding_modes.get(binding_id).map(|bm| match bm {\n             hir_ty::BindingMode::Move => BindingMode::Move,\n             hir_ty::BindingMode::Ref(hir_ty::Mutability::Mut) => BindingMode::Ref(Mutability::Mut),\n             hir_ty::BindingMode::Ref(hir_ty::Mutability::Not) => {"}, {"sha": "32e321107e6f377ead44155d0fb9e7fc92887ee6", "filename": "crates/ide-diagnostics/src/handlers/moved_out_of_ref.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmoved_out_of_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmoved_out_of_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmoved_out_of_ref.rs?ref=ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "patch": "@@ -151,4 +151,25 @@ fn f(x: &mut X<'_>) {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn no_false_positive_match_and_closure_capture() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: copy, fn\n+enum X {\n+    Foo(u16),\n+    Bar,\n+}\n+\n+fn main() {\n+    let x = &X::Bar;\n+    let c = || match *x {\n+        X::Foo(t) => t,\n+        _ => 5,\n+    };\n+}\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "ca6c169348d76e27a7eb55ec2e68a139a6c8b0f0", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce936177f93e96a6df9215c1c7dbcf97bf9c18c9/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=ce936177f93e96a6df9215c1c7dbcf97bf9c18c9", "patch": "@@ -301,6 +301,33 @@ fn main() {\n             * `(*x.f2.0.0).f` by mutable borrow\n         \"#]],\n     );\n+    check(\n+        r#\"\n+//- minicore: copy, option\n+\n+fn do_char(c: char) {}\n+\n+fn main() {\n+    let x = None;\n+    let y = |$0| {\n+        match x {\n+            Some(c) => do_char(c),\n+            None => x = None,\n+        }\n+    };\n+}\n+\"#,\n+        expect![[r#\"\n+            *|*\n+            ```rust\n+            {closure#0} // size = 8, align = 8\n+            impl FnMut()\n+            ```\n+\n+            ## Captures\n+            * `x` by mutable borrow\n+        \"#]],\n+    );\n }\n \n #[test]"}]}