{"sha": "4b62a77e4d76f2f29cd46812e6d7400636790723", "node_id": "C_kwDOAAsO6NoAKDRiNjJhNzdlNGQ3NmYyZjI5Y2Q0NjgxMmU2ZDc0MDA2MzY3OTA3MjM", "commit": {"author": {"name": "AngelicosPhosphoros", "email": "xuzin.timur@gmail.com", "date": "2021-12-20T12:57:47Z"}, "committer": {"name": "AngelicosPhosphoros", "email": "xuzin.timur@gmail.com", "date": "2021-12-27T09:26:30Z"}, "message": "Little improves in CString `new` when creating from slice\n\nOld code already contain optimization for cases with `&str` and `&[u8]` args. This commit adds a specialization for `&mut[u8]` too.\n\nAlso, I added usage of old slice in search for zero bytes instead of new buffer because it produce better code for Windows on LTO builds. For other platforms, this wouldn't cause any difference because it calls `libc` anyway.\n\nInlined `_new` method into spec trait to reduce amount of code generated to `CString::new` callers.", "tree": {"sha": "0d1e50b7ffcfcf153d606f271eb6cba7bd29ca03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d1e50b7ffcfcf153d606f271eb6cba7bd29ca03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b62a77e4d76f2f29cd46812e6d7400636790723", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b62a77e4d76f2f29cd46812e6d7400636790723", "html_url": "https://github.com/rust-lang/rust/commit/4b62a77e4d76f2f29cd46812e6d7400636790723", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b62a77e4d76f2f29cd46812e6d7400636790723/comments", "author": {"login": "AngelicosPhosphoros", "id": 13154246, "node_id": "MDQ6VXNlcjEzMTU0MjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/13154246?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AngelicosPhosphoros", "html_url": "https://github.com/AngelicosPhosphoros", "followers_url": "https://api.github.com/users/AngelicosPhosphoros/followers", "following_url": "https://api.github.com/users/AngelicosPhosphoros/following{/other_user}", "gists_url": "https://api.github.com/users/AngelicosPhosphoros/gists{/gist_id}", "starred_url": "https://api.github.com/users/AngelicosPhosphoros/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AngelicosPhosphoros/subscriptions", "organizations_url": "https://api.github.com/users/AngelicosPhosphoros/orgs", "repos_url": "https://api.github.com/users/AngelicosPhosphoros/repos", "events_url": "https://api.github.com/users/AngelicosPhosphoros/events{/privacy}", "received_events_url": "https://api.github.com/users/AngelicosPhosphoros/received_events", "type": "User", "site_admin": false}, "committer": {"login": "AngelicosPhosphoros", "id": 13154246, "node_id": "MDQ6VXNlcjEzMTU0MjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/13154246?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AngelicosPhosphoros", "html_url": "https://github.com/AngelicosPhosphoros", "followers_url": "https://api.github.com/users/AngelicosPhosphoros/followers", "following_url": "https://api.github.com/users/AngelicosPhosphoros/following{/other_user}", "gists_url": "https://api.github.com/users/AngelicosPhosphoros/gists{/gist_id}", "starred_url": "https://api.github.com/users/AngelicosPhosphoros/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AngelicosPhosphoros/subscriptions", "organizations_url": "https://api.github.com/users/AngelicosPhosphoros/orgs", "repos_url": "https://api.github.com/users/AngelicosPhosphoros/repos", "events_url": "https://api.github.com/users/AngelicosPhosphoros/events{/privacy}", "received_events_url": "https://api.github.com/users/AngelicosPhosphoros/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f540619007c1aa62dfc915409d881f52f21dc84", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f540619007c1aa62dfc915409d881f52f21dc84", "html_url": "https://github.com/rust-lang/rust/commit/8f540619007c1aa62dfc915409d881f52f21dc84"}], "stats": {"total": 67, "additions": 45, "deletions": 22}, "files": [{"sha": "d859bff1a45fa0f348d049adfe84097abc5d49ac", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4b62a77e4d76f2f29cd46812e6d7400636790723/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b62a77e4d76f2f29cd46812e6d7400636790723/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=4b62a77e4d76f2f29cd46812e6d7400636790723", "patch": "@@ -373,38 +373,61 @@ impl CString {\n     /// the position of the nul byte.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n-        trait SpecIntoVec {\n-            fn into_vec(self) -> Vec<u8>;\n+        trait SpecNewImpl {\n+            fn spec_new_impl(self) -> Result<CString, NulError>;\n         }\n-        impl<T: Into<Vec<u8>>> SpecIntoVec for T {\n-            default fn into_vec(self) -> Vec<u8> {\n-                self.into()\n+\n+        impl<T: Into<Vec<u8>>> SpecNewImpl for T {\n+            default fn spec_new_impl(self) -> Result<CString, NulError> {\n+                let bytes: Vec<u8> = self.into();\n+                match memchr::memchr(0, &bytes) {\n+                    Some(i) => Err(NulError(i, bytes)),\n+                    None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+                }\n             }\n         }\n-        // Specialization for avoiding reallocation.\n-        impl SpecIntoVec for &'_ [u8] {\n-            fn into_vec(self) -> Vec<u8> {\n-                let mut v = Vec::with_capacity(self.len() + 1);\n-                v.extend(self);\n-                v\n+\n+        // Specialization for avoiding reallocation\n+        #[inline(always)] // Without that it is not inlined into specializations\n+        fn spec_new_impl_bytes(bytes: &[u8]) -> Result<CString, NulError> {\n+            // We cannot have such large slice that we would overflow here\n+            // but using `checked_add` allows LLVM to assume that capacity never overflows\n+            // and generate twice shorter code.\n+            // `saturating_add` doesn't help for some reason.\n+            let capacity = bytes.len().checked_add(1).unwrap();\n+\n+            // Allocate before validation to avoid duplication of allocation code.\n+            // We still need to allocate and copy memory even if we get an error.\n+            let mut buffer = Vec::with_capacity(capacity);\n+            buffer.extend(bytes);\n+\n+            // Check memory of self instead of new buffer.\n+            // This allows better optimizations if lto enabled.\n+            match memchr::memchr(0, bytes) {\n+                Some(i) => Err(NulError(i, buffer)),\n+                None => Ok(unsafe { CString::from_vec_unchecked(buffer) }),\n             }\n         }\n-        impl SpecIntoVec for &'_ str {\n-            fn into_vec(self) -> Vec<u8> {\n-                let mut v = Vec::with_capacity(self.len() + 1);\n-                v.extend(self.as_bytes());\n-                v\n+\n+        impl SpecNewImpl for &'_ [u8] {\n+            fn spec_new_impl(self) -> Result<CString, NulError> {\n+                spec_new_impl_bytes(self)\n             }\n         }\n \n-        Self::_new(SpecIntoVec::into_vec(t))\n-    }\n+        impl SpecNewImpl for &'_ str {\n+            fn spec_new_impl(self) -> Result<CString, NulError> {\n+                spec_new_impl_bytes(self.as_bytes())\n+            }\n+        }\n \n-    fn _new(bytes: Vec<u8>) -> Result<CString, NulError> {\n-        match memchr::memchr(0, &bytes) {\n-            Some(i) => Err(NulError(i, bytes)),\n-            None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+        impl SpecNewImpl for &'_ mut [u8] {\n+            fn spec_new_impl(self) -> Result<CString, NulError> {\n+                spec_new_impl_bytes(self)\n+            }\n         }\n+\n+        t.spec_new_impl()\n     }\n \n     /// Creates a C-compatible string by consuming a byte vector,"}]}