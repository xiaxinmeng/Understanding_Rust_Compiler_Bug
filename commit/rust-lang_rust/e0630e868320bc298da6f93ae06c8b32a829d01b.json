{"sha": "e0630e868320bc298da6f93ae06c8b32a829d01b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNjMwZTg2ODMyMGJjMjk4ZGE2ZjkzYWUwNmM4YjMyYTgyOWQwMWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-03T22:03:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-15T21:49:22Z"}, "message": "refactor how we extract outlives bounds from trait definitions\n\nThis new way is **slightly** less expressive (I would be shocked if it\naffects any code, though) when it comes to higher-ranked bounds or a\nfew other weird tricks. But we don't handle those consistently\nregardless, and the new way does not require normalization and is just\nwildly simpler.", "tree": {"sha": "b6465f2e6ace255f8d5eeff6a1ca312ea5d690ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6465f2e6ace255f8d5eeff6a1ca312ea5d690ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0630e868320bc298da6f93ae06c8b32a829d01b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0630e868320bc298da6f93ae06c8b32a829d01b", "html_url": "https://github.com/rust-lang/rust/commit/e0630e868320bc298da6f93ae06c8b32a829d01b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0630e868320bc298da6f93ae06c8b32a829d01b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22cd041ba0747e680e3faea7b6db2bbd40b41198", "url": "https://api.github.com/repos/rust-lang/rust/commits/22cd041ba0747e680e3faea7b6db2bbd40b41198", "html_url": "https://github.com/rust-lang/rust/commit/22cd041ba0747e680e3faea7b6db2bbd40b41198"}], "stats": {"total": 298, "additions": 132, "deletions": 166}, "files": [{"sha": "4cd9c3f9ae39cd80c5b3e8861303af0943ef4c73", "filename": "src/librustc/infer/region_obligations.rs", "status": "modified", "additions": 92, "deletions": 142, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/e0630e868320bc298da6f93ae06c8b32a829d01b/src%2Flibrustc%2Finfer%2Fregion_obligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0630e868320bc298da6f93ae06c8b32a829d01b/src%2Flibrustc%2Finfer%2Fregion_obligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_obligations.rs?ref=e0630e868320bc298da6f93ae06c8b32a829d01b", "patch": "@@ -55,13 +55,13 @@\n //!   *may* be able to sidestep this. Regardless, once the NLL\n //!   transition is complete, this concern will be gone. -nmatsakis\n \n-use infer::{self, GenericKind, InferCtxt, InferOk, RegionObligation, SubregionOrigin, VerifyBound};\n-use traits::{self, ObligationCause, ObligationCauseCode, PredicateObligations};\n+use hir::def_id::DefId;\n+use infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n+use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::subst::Subst;\n+use ty::subst::{Subst, Substs};\n use ty::outlives::Component;\n use syntax::ast;\n-use syntax_pos::Span;\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Registers that the given region obligation must be resolved\n@@ -120,19 +120,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: ast::NodeId,\n-    ) -> InferOk<'tcx, ()> {\n+    ) {\n         let region_obligations = match self.region_obligations.borrow_mut().remove(&body_id) {\n             None => vec![],\n             Some(vec) => vec,\n         };\n \n-        let mut outlives = TypeOutlives::new(\n-            self,\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n-            body_id,\n-        );\n+        let outlives =\n+            TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n \n         for RegionObligation {\n             sup_type,\n@@ -147,11 +142,6 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n             outlives.type_must_outlive(origin, sup_type, sub_region);\n         }\n-\n-        InferOk {\n-            value: (),\n-            obligations: outlives.into_accrued_obligations(),\n-        }\n     }\n \n     /// Processes a single ad-hoc region obligation that was not\n@@ -161,23 +151,13 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: ast::NodeId,\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n-    ) -> InferOk<'tcx, ()> {\n-        let mut outlives = TypeOutlives::new(\n-            self,\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n-            body_id,\n-        );\n+    ) {\n+        let outlives =\n+            TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n         outlives.type_must_outlive(origin, ty, region);\n-        InferOk {\n-            value: (),\n-            obligations: outlives.into_accrued_obligations(),\n-        }\n     }\n \n     /// Ignore the region obligations for a given `body_id`, not bothering to\n@@ -196,11 +176,6 @@ struct TypeOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_id: ast::NodeId,\n-\n-    /// These are sub-obligations that we accrue as we go; they result\n-    /// from any normalizations we had to do.\n-    obligations: PredicateObligations<'tcx>,\n }\n \n impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n@@ -209,24 +184,15 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: ast::NodeId,\n     ) -> Self {\n         Self {\n             infcx,\n             region_bound_pairs,\n             implicit_region_bound,\n             param_env,\n-            body_id,\n-            obligations: vec![],\n         }\n     }\n \n-    /// Returns the obligations that accrued as a result of the\n-    /// `type_must_outlive` calls.\n-    fn into_accrued_obligations(self) -> PredicateObligations<'tcx> {\n-        self.obligations\n-    }\n-\n     /// Adds constraints to inference such that `T: 'a` holds (or\n     /// reports an error if it cannot).\n     ///\n@@ -236,7 +202,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n     fn type_must_outlive(\n-        &mut self,\n+        &self,\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n@@ -261,7 +227,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     }\n \n     fn components_must_outlive(\n-        &mut self,\n+        &self,\n         origin: infer::SubregionOrigin<'tcx>,\n         components: Vec<Component<'tcx>>,\n         region: ty::Region<'tcx>,\n@@ -295,7 +261,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     }\n \n     fn param_ty_must_outlive(\n-        &mut self,\n+        &self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         param_ty: ty::ParamTy,\n@@ -314,7 +280,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     }\n \n     fn projection_must_outlive(\n-        &mut self,\n+        &self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n@@ -343,7 +309,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         // Compute the bounds we can derive from the environment or trait\n         // definition.  We know that the projection outlives all the\n         // regions in this list.\n-        let env_bounds = self.projection_declared_bounds(origin.span(), projection_ty);\n+        let env_bounds = self.projection_declared_bounds(projection_ty);\n \n         debug!(\"projection_must_outlive: env_bounds={:?}\", env_bounds);\n \n@@ -413,24 +379,24 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         // projection outlive; in some cases, this may add insufficient\n         // edges into the inference graph, leading to inference failures\n         // even though a satisfactory solution exists.\n-        let verify_bound = self.projection_bound(origin.span(), env_bounds, projection_ty);\n+        let verify_bound = self.projection_bound(env_bounds, projection_ty);\n         let generic = GenericKind::Projection(projection_ty);\n         self.infcx\n             .verify_generic_bound(origin, generic.clone(), region, verify_bound);\n     }\n \n-    fn type_bound(&mut self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+    fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n         match ty.sty {\n             ty::TyParam(p) => self.param_bound(p),\n             ty::TyProjection(data) => {\n-                let declared_bounds = self.projection_declared_bounds(span, data);\n-                self.projection_bound(span, declared_bounds, data)\n+                let declared_bounds = self.projection_declared_bounds(data);\n+                self.projection_bound(declared_bounds, data)\n             }\n-            _ => self.recursive_type_bound(span, ty),\n+            _ => self.recursive_type_bound(ty),\n         }\n     }\n \n-    fn param_bound(&mut self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n+    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n         debug!(\"param_bound(param_ty={:?})\", param_ty);\n \n         let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n@@ -443,8 +409,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     }\n \n     fn projection_declared_bounds(\n-        &mut self,\n-        span: Span,\n+        &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n     ) -> Vec<ty::Region<'tcx>> {\n         // First assemble bounds from where clauses and traits.\n@@ -453,14 +418,13 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n             self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n \n         declared_bounds\n-            .extend_from_slice(&mut self.declared_projection_bounds_from_trait(span, projection_ty));\n+            .extend_from_slice(&self.declared_projection_bounds_from_trait(projection_ty));\n \n         declared_bounds\n     }\n \n     fn projection_bound(\n-        &mut self,\n-        span: Span,\n+        &self,\n         declared_bounds: Vec<ty::Region<'tcx>>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n     ) -> VerifyBound<'tcx> {\n@@ -474,16 +438,16 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         let ty = self.infcx\n             .tcx\n             .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_type_bound(span, ty);\n+        let recursive_bound = self.recursive_type_bound(ty);\n \n         VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n     }\n \n-    fn recursive_type_bound(&mut self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+    fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n         let mut bounds = vec![];\n \n         for subty in ty.walk_shallow() {\n-            bounds.push(self.type_bound(span, subty));\n+            bounds.push(self.type_bound(subty));\n         }\n \n         let mut regions = ty.regions();\n@@ -501,7 +465,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     }\n \n     fn declared_generic_bounds_from_env(\n-        &mut self,\n+        &self,\n         generic: GenericKind<'tcx>,\n     ) -> Vec<ty::Region<'tcx>> {\n         let tcx = self.tcx();\n@@ -531,89 +495,75 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         param_bounds\n     }\n \n+    /// Given a projection like `<T as Foo<'x>>::Bar`, returns any bounds\n+    /// declared in the trait definition. For example, if the trait were\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// then this function would return `'x`. This is subject to the\n+    /// limitations around higher-ranked bounds described in\n+    /// `region_bounds_declared_on_associated_item`.\n     fn declared_projection_bounds_from_trait(\n-        &mut self,\n-        span: Span,\n+        &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n     ) -> Vec<ty::Region<'tcx>> {\n         debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n-        let ty = self.tcx()\n-            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-\n-        // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n-        // in looking for a trait definition like:\n-        //\n-        // ```\n-        // trait SomeTrait<'a> {\n-        //     type SomeType : 'a;\n-        // }\n-        // ```\n-        //\n-        // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-        let trait_predicates = self.tcx()\n-            .predicates_of(projection_ty.trait_ref(self.tcx()).def_id);\n-        assert_eq!(trait_predicates.parent, None);\n-        let predicates = trait_predicates.predicates.as_slice().to_vec();\n-        traits::elaborate_predicates(self.tcx(), predicates)\n-            .filter_map(|predicate| {\n-                // we're only interesting in `T : 'a` style predicates:\n-                let outlives = match predicate {\n-                    ty::Predicate::TypeOutlives(data) => data,\n-                    _ => {\n-                        return None;\n-                    }\n-                };\n-\n-                debug!(\"projection_bounds: outlives={:?} (1)\", outlives);\n-\n-                // apply the substitutions (and normalize any projected types)\n-                let outlives = outlives.subst(self.tcx(), projection_ty.substs);\n-                let outlives = self.infcx.partially_normalize_associated_types_in(\n-                    span,\n-                    self.body_id,\n-                    self.param_env,\n-                    &outlives,\n-                );\n-                let outlives = self.register_infer_ok_obligations(outlives);\n-\n-                debug!(\"projection_bounds: outlives={:?} (2)\", outlives);\n-\n-                let region_result = self.infcx\n-                    .commit_if_ok(|_| {\n-                        let (outlives, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n-                            span,\n-                            infer::AssocTypeProjection(projection_ty.item_def_id),\n-                            &outlives,\n-                        );\n-\n-                        debug!(\"projection_bounds: outlives={:?} (3)\", outlives);\n-\n-                        // check whether this predicate applies to our current projection\n-                        let cause = ObligationCause::new(\n-                            span,\n-                            self.body_id,\n-                            ObligationCauseCode::MiscObligation,\n-                        );\n-                        match self.infcx.at(&cause, self.param_env).eq(outlives.0, ty) {\n-                            Ok(ok) => Ok((ok, outlives.1)),\n-                            Err(_) => Err(()),\n-                        }\n-                    })\n-                    .map(|(ok, result)| {\n-                        self.register_infer_ok_obligations(ok);\n-                        result\n-                    });\n-\n-                debug!(\"projection_bounds: region_result={:?}\", region_result);\n-\n-                region_result.ok()\n-            })\n-            .collect()\n+        let mut bounds = self.region_bounds_declared_on_associated_item(projection_ty.item_def_id);\n+        for r in &mut bounds {\n+            *r = r.subst(self.tcx(), projection_ty.substs);\n+        }\n+        bounds\n     }\n \n-    fn register_infer_ok_obligations<T>(&mut self, infer_ok: InferOk<'tcx, T>) -> T {\n-        let InferOk { value, obligations } = infer_ok;\n-        self.obligations.extend(obligations);\n-        value\n+    /// Given the def-id of an associated item, returns any region\n+    /// bounds attached to that associated item from the trait definition.\n+    ///\n+    /// For example:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a> {\n+    ///     type Bar: 'a;\n+    /// }\n+    /// ```\n+    ///\n+    /// If we were given the def-id of `Foo::Bar`, we would return\n+    /// `'a`. You could then apply the substitutions from the\n+    /// projection to convert this into your namespace. This also\n+    /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on\n+    /// the trait. In fact, it works by searching for just such a\n+    /// where-clause.\n+    ///\n+    /// It will not, however, work for higher-ranked bounds like:\n+    ///\n+    /// ```rust\n+    /// trait Foo<'a, 'b>\n+    /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n+    /// {\n+    ///     type Bar;\n+    /// }\n+    /// ```\n+    ///\n+    /// This is for simplicity, and because we are not really smart\n+    /// enough to cope with such bounds anywhere.\n+    fn region_bounds_declared_on_associated_item(\n+        &self,\n+        assoc_item_def_id: DefId,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        let tcx = self.tcx();\n+        let assoc_item = tcx.associated_item(assoc_item_def_id);\n+        let trait_def_id = assoc_item.container.assert_trait();\n+        let trait_predicates = tcx.predicates_of(trait_def_id);\n+        let identity_substs = Substs::identity_for_item(tcx, assoc_item_def_id);\n+        let identity_proj = tcx.mk_projection(assoc_item_def_id, identity_substs);\n+        traits::elaborate_predicates(tcx, trait_predicates.predicates)\n+            .filter_map(|p| p.to_opt_type_outlives())\n+            .filter_map(|p| tcx.no_late_bound_regions(&p))\n+            .filter(|p| p.0 == identity_proj)\n+            .map(|p| p.1)\n+            .collect()\n     }\n }"}, {"sha": "8973d1e0c5a5be024e41854e901ccd46f124435c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0630e868320bc298da6f93ae06c8b32a829d01b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0630e868320bc298da6f93ae06c8b32a829d01b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e0630e868320bc298da6f93ae06c8b32a829d01b", "patch": "@@ -144,6 +144,15 @@ pub enum AssociatedItemContainer {\n }\n \n impl AssociatedItemContainer {\n+    /// Asserts that this is the def-id of an associated item declared\n+    /// in a trait, and returns the trait def-id.\n+    pub fn assert_trait(&self) -> DefId {\n+        match *self {\n+            TraitContainer(id) => id,\n+            _ => bug!(\"associated item has wrong container type: {:?}\", self)\n+        }\n+    }\n+\n     pub fn id(&self) -> DefId {\n         match *self {\n             TraitContainer(id) => id,\n@@ -1200,6 +1209,25 @@ impl<'tcx> Predicate<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn to_opt_type_outlives(&self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n+        match *self {\n+            Predicate::TypeOutlives(data) => {\n+                Some(data)\n+            }\n+            Predicate::Trait(..) |\n+            Predicate::Projection(..) |\n+            Predicate::Equate(..) |\n+            Predicate::Subtype(..) |\n+            Predicate::RegionOutlives(..) |\n+            Predicate::WellFormed(..) |\n+            Predicate::ObjectSafe(..) |\n+            Predicate::ClosureKind(..) |\n+            Predicate::ConstEvaluatable(..) => {\n+                None\n+            }\n+        }\n+    }\n }\n \n /// Represents the bounds declared on a particular set of type"}, {"sha": "7f1547c0c44d306a0f9fdf2221d769e3e634ffd8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e0630e868320bc298da6f93ae06c8b32a829d01b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0630e868320bc298da6f93ae06c8b32a829d01b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e0630e868320bc298da6f93ae06c8b32a829d01b", "patch": "@@ -91,7 +91,7 @@ use middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::infer::{self, InferOk, GenericKind};\n+use rustc::infer::{self, GenericKind};\n use rustc::ty::adjustment;\n use rustc::ty::outlives::Component;\n use rustc::ty::wf;\n@@ -357,21 +357,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // obligations. So make sure we process those.\n         self.select_all_obligations_or_error();\n \n-        let InferOk { value: (), obligations }  =\n-            self.infcx.process_registered_region_obligations(\n-                &self.region_bound_pairs,\n-                self.implicit_region_bound,\n-                self.param_env,\n-                self.body_id);\n-\n-        // TODO -- It feels like we ought to loop here; these new\n-        // obligations, when selected, could cause the list of region\n-        // obligations to grow further. Fortunately, I believe that if\n-        // that happens it will at least lead to an ICE today, because\n-        // `resolve_regions_and_report_errors` (which runs after *all*\n-        // obligations have been selected) will assert that there are\n-        // no unsolved region obligations.\n-        self.register_predicates(obligations);\n+        self.infcx.process_registered_region_obligations(\n+            &self.region_bound_pairs,\n+            self.implicit_region_bound,\n+            self.param_env,\n+            self.body_id);\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n@@ -1137,14 +1127,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                              ty: Ty<'tcx>,\n                              region: ty::Region<'tcx>)\n     {\n-        let infer_ok = self.infcx.type_must_outlive(&self.region_bound_pairs,\n-                                                    self.implicit_region_bound,\n-                                                    self.param_env,\n-                                                    self.body_id,\n-                                                    origin,\n-                                                    ty,\n-                                                    region);\n-        self.register_infer_ok_obligations(infer_ok)\n+        self.infcx.type_must_outlive(&self.region_bound_pairs,\n+                                     self.implicit_region_bound,\n+                                     self.param_env,\n+                                     origin,\n+                                     ty,\n+                                     region);\n     }\n \n     /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the"}]}