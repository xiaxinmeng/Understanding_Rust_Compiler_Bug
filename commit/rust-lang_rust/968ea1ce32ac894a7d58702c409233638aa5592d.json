{"sha": "968ea1ce32ac894a7d58702c409233638aa5592d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2OGVhMWNlMzJhYzg5NGE3ZDU4NzAyYzQwOTIzMzYzOGFhNTU5MmQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-04-04T20:25:08Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-04-04T20:25:08Z"}, "message": "Mark variables captured by reference as mutable correctly", "tree": {"sha": "a96497ed8c5c6b6b04c65c787323ea4c33f93c70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a96497ed8c5c6b6b04c65c787323ea4c33f93c70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/968ea1ce32ac894a7d58702c409233638aa5592d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/968ea1ce32ac894a7d58702c409233638aa5592d", "html_url": "https://github.com/rust-lang/rust/commit/968ea1ce32ac894a7d58702c409233638aa5592d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/968ea1ce32ac894a7d58702c409233638aa5592d/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8673e0ad85e98997faa76fa7edc99c5825f46ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8673e0ad85e98997faa76fa7edc99c5825f46ee", "html_url": "https://github.com/rust-lang/rust/commit/f8673e0ad85e98997faa76fa7edc99c5825f46ee"}], "stats": {"total": 115, "additions": 87, "deletions": 28}, "files": [{"sha": "ab3239820e3a2aa65576f581bb80ab1e2b22951a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 76, "deletions": 20, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/968ea1ce32ac894a7d58702c409233638aa5592d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968ea1ce32ac894a7d58702c409233638aa5592d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=968ea1ce32ac894a7d58702c409233638aa5592d", "patch": "@@ -28,7 +28,7 @@ use std::collections::BTreeMap;\n use syntax_pos::Span;\n \n use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n-use crate::dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MoveError};\n+use crate::dataflow::move_paths::{HasMoveData, InitLocation, LookupResult, MoveData, MoveError};\n use crate::dataflow::Borrows;\n use crate::dataflow::DataflowResultsConsumer;\n use crate::dataflow::FlowAtLocation;\n@@ -1206,25 +1206,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         } = self.infcx.tcx.mir_borrowck(def_id);\n                         debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n                         for field in used_mut_upvars {\n-                            // This relies on the current way that by-value\n-                            // captures of a closure are copied/moved directly\n-                            // when generating MIR.\n-                            match operands[field.index()] {\n-                                Operand::Move(Place::Base(PlaceBase::Local(local)))\n-                                | Operand::Copy(Place::Base(PlaceBase::Local(local))) => {\n-                                    self.used_mut.insert(local);\n-                                }\n-                                Operand::Move(ref place @ Place::Projection(_))\n-                                | Operand::Copy(ref place @ Place::Projection(_)) => {\n-                                    if let Some(field) = place.is_upvar_field_projection(\n-                                            self.mir, &self.infcx.tcx) {\n-                                        self.used_mut_upvars.push(field);\n-                                    }\n-                                }\n-                                Operand::Move(Place::Base(PlaceBase::Static(..)))\n-                                | Operand::Copy(Place::Base(PlaceBase::Static(..)))\n-                                | Operand::Constant(..) => {}\n-                            }\n+                            self.propagate_closure_used_mut_upvar(&operands[field.index()]);\n                         }\n                     }\n                     AggregateKind::Adt(..)\n@@ -1239,6 +1221,80 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n+        let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n+            match *place {\n+                Place::Projection { .. } => {\n+                    if let Some(field) = place.is_upvar_field_projection(\n+                            this.mir, &this.infcx.tcx) {\n+                        this.used_mut_upvars.push(field);\n+                    }\n+                }\n+                Place::Base(PlaceBase::Local(local)) => {\n+                    this.used_mut.insert(local);\n+                }\n+                Place::Base(PlaceBase::Static(_)) => {}\n+            }\n+        };\n+\n+        // This relies on the current way that by-value\n+        // captures of a closure are copied/moved directly\n+        // when generating MIR.\n+        match *operand {\n+            Operand::Move(Place::Base(PlaceBase::Local(local)))\n+            | Operand::Copy(Place::Base(PlaceBase::Local(local)))\n+                if self.mir.local_decls[local].is_user_variable.is_none() =>\n+            {\n+                if self.mir.local_decls[local].ty.is_mutable_pointer() {\n+                    // The variable will be marked as mutable by the borrow.\n+                    return;\n+                }\n+                // This is an edge case where we have a `move` closure\n+                // inside a non-move closure, and the inner closure\n+                // contains a mutation:\n+                //\n+                // let mut i = 0;\n+                // || { move || { i += 1; }; };\n+                //\n+                // In this case our usual strategy of assuming that the\n+                // variable will be captured by mutable reference is\n+                // wrong, since `i` can be copied into the inner\n+                // closure from a shared reference.\n+                //\n+                // As such we have to search for the local that this\n+                // capture comes from and mark it as being used as mut.\n+\n+                let temp_mpi = self.move_data.rev_lookup.find_local(local);\n+                let init = if let [init_index] = *self.move_data.init_path_map[temp_mpi] {\n+                    &self.move_data.inits[init_index]\n+                } else {\n+                    bug!(\"temporary should be initialized exactly once\")\n+                };\n+\n+                let loc = match init.location {\n+                    InitLocation::Statement(stmt) => stmt,\n+                    _ => bug!(\"temporary initialized in arguments\"),\n+                };\n+\n+                let bbd = &self.mir[loc.block];\n+                let stmt = &bbd.statements[loc.statement_index];\n+                debug!(\"temporary assigned in: stmt={:?}\", stmt);\n+\n+                if let StatementKind::Assign(_, box Rvalue::Ref(_, _, ref source)) = stmt.kind {\n+                    propagate_closure_used_mut_place(self, source);\n+                } else {\n+                    bug!(\"closures should only capture user variables \\\n+                        or references to user variables\");\n+                }\n+            }\n+            Operand::Move(ref place)\n+            | Operand::Copy(ref place) => {\n+                propagate_closure_used_mut_place(self, place);\n+            }\n+            Operand::Constant(..) => {}\n+        }\n+    }\n+\n     fn consume_operand(\n         &mut self,\n         context: Context,"}, {"sha": "6d0d6e16a677588fc15e8c568fa32a5bf2ab083b", "filename": "src/test/ui/nll/extra-unused-mut.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/968ea1ce32ac894a7d58702c409233638aa5592d/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968ea1ce32ac894a7d58702c409233638aa5592d/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs?ref=968ea1ce32ac894a7d58702c409233638aa5592d", "patch": "@@ -1,6 +1,6 @@\n // extra unused mut lint tests for #51918\n \n-// run-pass\n+// compile-pass\n \n #![feature(generators, nll)]\n #![deny(unused_mut)]\n@@ -53,11 +53,14 @@ fn if_guard(x: Result<i32, i32>) {\n     }\n }\n \n-fn main() {\n-    ref_argument(0);\n-    mutable_upvar();\n-    generator_mutable_upvar();\n-    ref_closure_argument();\n-    parse_dot_or_call_expr_with(Vec::new());\n-    if_guard(Ok(0));\n+// #59620\n+fn nested_closures() {\n+    let mut i = 0;\n+    [].iter().for_each(|_: &i32| {\n+        [].iter().for_each(move |_: &i32| {\n+            i += 1;\n+        });\n+    });\n }\n+\n+fn main() {}"}]}