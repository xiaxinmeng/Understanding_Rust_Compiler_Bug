{"sha": "dabbac1d6c06c00f24148ffc58b42455496fdd3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYmJhYzFkNmMwNmMwMGYyNDE0OGZmYzU4YjQyNDU1NDk2ZmRkM2M=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-16T06:54:54Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:57Z"}, "message": "std: working tests for low-level libuv open, write and close operations", "tree": {"sha": "06a67dbb456e735015310faaea41709249ff31d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06a67dbb456e735015310faaea41709249ff31d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dabbac1d6c06c00f24148ffc58b42455496fdd3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dabbac1d6c06c00f24148ffc58b42455496fdd3c", "html_url": "https://github.com/rust-lang/rust/commit/dabbac1d6c06c00f24148ffc58b42455496fdd3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dabbac1d6c06c00f24148ffc58b42455496fdd3c/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a901b166901601c6b132c2036882ad9754722f1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a901b166901601c6b132c2036882ad9754722f1c", "html_url": "https://github.com/rust-lang/rust/commit/a901b166901601c6b132c2036882ad9754722f1c"}], "stats": {"total": 205, "additions": 174, "deletions": 31}, "files": [{"sha": "2a16a34070d241b67845f4d39384c95a636d0396", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 107, "deletions": 12, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/dabbac1d6c06c00f24148ffc58b42455496fdd3c/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabbac1d6c06c00f24148ffc58b42455496fdd3c/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=dabbac1d6c06c00f24148ffc58b42455496fdd3c", "patch": "@@ -11,8 +11,9 @@\n use prelude::*;\n use ptr::null;\n use libc::c_void;\n-use rt::uv::{Request, NativeHandle, Loop, FsCallback,\n-             status_to_maybe_uv_error_with_loop};\n+use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n+             status_to_maybe_uv_error_with_loop,\n+             vec_to_uv_buf};//, vec_from_uv_buf};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use path::Path;\n@@ -30,6 +31,14 @@ pub enum UvFileFlag {\n     O_CREAT,\n     O_TRUNC\n }\n+// just want enough to get 0644\n+#[allow(non_camel_case_types)]\n+pub enum UvFileMode {\n+    S_IWUSR,\n+    S_IRUSR,\n+    S_IRGRP,\n+    S_IROTH\n+}\n pub fn map_flag(v: UvFileFlag) -> int {\n     unsafe {\n         match v {\n@@ -41,9 +50,21 @@ pub fn map_flag(v: UvFileFlag) -> int {\n         }\n     }\n }\n+pub fn map_mode(v: UvFileMode) -> int {\n+    unsafe {\n+        match v {\n+            S_IWUSR => uvll::get_S_IWUSR() as int,\n+            S_IRUSR => uvll::get_S_IRUSR() as int,\n+            S_IRGRP => uvll::get_S_IRGRP() as int,\n+            S_IROTH => uvll::get_S_IROTH() as int\n+        }\n+    }\n+}\n \n pub struct RequestData {\n-    complete_cb: Option<FsCallback>\n+    complete_cb: Option<FsCallback>,\n+    buf: Option<Buf>,\n+    raw_fd: Option<c_int>\n }\n \n impl FsRequest {\n@@ -58,7 +79,9 @@ impl FsRequest {\n     pub fn install_req_data(&self, cb: Option<FsCallback>) {\n         let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n         let data = ~RequestData {\n-            complete_cb: cb\n+            complete_cb: cb,\n+            buf: None,\n+            raw_fd: None\n         };\n         unsafe {\n             let data = transmute::<~RequestData, *c_void>(data);\n@@ -86,10 +109,10 @@ impl FsRequest {\n \n     fn cleanup_and_delete(self) {\n         unsafe {\n-            uvll::fs_req_cleanup(self.native_handle());\n-            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let data = uvll::get_data_for_req(self.native_handle());\n             let _data = transmute::<*c_void, ~RequestData>(data);\n-            uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n+            uvll::set_data_for_req(self.native_handle(), null::<()>());\n+            uvll::fs_req_cleanup(self.native_handle());\n             free_req(self.native_handle() as *c_void)\n         }\n     }\n@@ -121,10 +144,24 @@ impl FileDescriptor {\n             uvll::fs_open(loop_.native_handle(),\n                           req.native_handle(), p, flags, mode, complete_cb) as int\n         })\n+    }\n \n+    pub fn write(&self, loop_: Loop, buf: ~[u8], offset: i64, cb: FsCallback)\n+          -> int {\n+        let mut req = FsRequest::new(Some(cb));\n+        let len = buf.len();\n+        let buf = vec_to_uv_buf(buf);\n+        let base_ptr = buf.base as *c_void;\n+        req.get_req_data().buf = Some(buf);\n+        req.get_req_data().raw_fd = Some(self.native_handle());\n+        unsafe {\n+            uvll::fs_write(loop_.native_handle(), req.native_handle(),\n+                           self.native_handle(), base_ptr,\n+                           len, offset, complete_cb) as int\n+        }\n     }\n \n-    fn close(self, loop_: Loop, cb: FsCallback) -> int {\n+    pub fn close(self, loop_: Loop, cb: FsCallback) -> int {\n         let req = FsRequest::new(Some(cb));\n         unsafe {\n             uvll::fs_close(loop_.native_handle(), req.native_handle(),\n@@ -170,17 +207,22 @@ mod test {\n     //use rt::test::*;\n     use unstable::run_in_bare_thread;\n     use path::Path;\n-    use rt::uv::Loop;\n+    use rt::uv::{Loop};//, slice_to_uv_buf};\n \n     // this is equiv to touch, i guess?\n     fn file_test_touch_impl() {\n         debug!(\"hello?\")\n         do run_in_bare_thread {\n             debug!(\"In bare thread\")\n-            let loop_ = Loop::new();\n+            let mut loop_ = Loop::new();\n             let flags = map_flag(O_RDWR) |\n-                map_flag(O_CREAT) | map_flag(O_TRUNC);\n-            do FileDescriptor::open(loop_, Path(\"./foo.txt\"), flags, 0644)\n+                map_flag(O_CREAT);\n+            // 0644\n+            let mode = map_mode(S_IWUSR) |\n+                map_mode(S_IRUSR) |\n+                map_mode(S_IRGRP) |\n+                map_mode(S_IROTH);\n+            do FileDescriptor::open(loop_, Path(\"./foo.txt\"), flags, mode)\n             |req, uverr| {\n                 let loop_ = req.get_loop();\n                 assert!(uverr.is_none());\n@@ -189,11 +231,64 @@ mod test {\n                     assert!(uverr.is_none());\n                 };\n             };\n+            loop_.run();\n         }\n     }\n \n     #[test]\n     fn file_test_touch() {\n         file_test_touch_impl();\n     }\n+\n+    fn file_test_tee_impl() {\n+        debug!(\"hello?\")\n+        do run_in_bare_thread {\n+            debug!(\"In bare thread\")\n+            let mut loop_ = Loop::new();\n+            let flags = map_flag(O_RDWR) |\n+                map_flag(O_CREAT);\n+            // 0644\n+            let mode = map_mode(S_IWUSR) |\n+                map_mode(S_IRUSR) |\n+                map_mode(S_IRGRP) |\n+                map_mode(S_IROTH);\n+            do FileDescriptor::open(loop_, Path(\"./file_tee_test.txt\"), flags, mode)\n+            |req, uverr| {\n+                let loop_ = req.get_loop();\n+                assert!(uverr.is_none());\n+                let fd = FileDescriptor::from_open_req(req);\n+                let msg: ~[u8] = \"hello world\".as_bytes().to_owned();\n+                let raw_fd = fd.native_handle();\n+                do fd.write(loop_, msg, -1) |_, uverr| {\n+                    let fd = FileDescriptor(raw_fd);\n+                    do fd.close(loop_) |_, _| {\n+                        assert!(uverr.is_none());\n+                    };\n+                };\n+            };\n+            loop_.run();\n+        }\n+    }\n+\n+    #[test]\n+    fn file_test_tee() {\n+        file_test_tee_impl();\n+    }\n+\n+    fn naive_print(input: ~str) {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let stdout = FileDescriptor(1);\n+            let msg = input.as_bytes().to_owned();\n+            do stdout.write(loop_, msg, -1) |_, uverr| {\n+                assert!(uverr.is_none());\n+            };\n+            loop_.run();\n+        }\n+    }\n+\n+    #[test]\n+    fn file_test_println() {\n+        naive_print(~\"oh yeah.\\n\");\n+    }\n }"}, {"sha": "0fbf45fca970287132223475871bdb8028363d5b", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dabbac1d6c06c00f24148ffc58b42455496fdd3c/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dabbac1d6c06c00f24148ffc58b42455496fdd3c/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=dabbac1d6c06c00f24148ffc58b42455496fdd3c", "patch": "@@ -621,6 +621,10 @@ pub unsafe fn fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, flags:\n                 cb: *u8) -> c_int {\n     rust_uv_fs_open(loop_ptr, req, path, flags as c_int, mode as c_int, cb)\n }\n+pub unsafe fn fs_write(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                       len: uint, offset: i64, cb: *u8) -> c_int {\n+    rust_uv_fs_write(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n+}\n pub unsafe fn fs_close(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n                 cb: *u8) -> c_int {\n     rust_uv_fs_close(loop_ptr, req, fd, cb)\n@@ -630,21 +634,15 @@ pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n }\n \n // data access helpers\n-pub unsafe fn get_O_RDONLY() -> c_int {\n-    rust_uv_get_O_RDONLY()\n-}\n-pub unsafe fn get_O_WRONLY() -> c_int {\n-    rust_uv_get_O_WRONLY()\n-}\n-pub unsafe fn get_O_RDWR() -> c_int {\n-    rust_uv_get_O_RDWR()\n-}\n-pub unsafe fn get_O_CREAT() -> c_int {\n-    rust_uv_get_O_CREAT()\n-}\n-pub unsafe fn get_O_TRUNC() -> c_int {\n-    rust_uv_get_O_TRUNC()\n-}\n+pub unsafe fn get_O_RDONLY() -> c_int { rust_uv_get_O_RDONLY() }\n+pub unsafe fn get_O_WRONLY() -> c_int { rust_uv_get_O_WRONLY() }\n+pub unsafe fn get_O_RDWR() -> c_int { rust_uv_get_O_RDWR() }\n+pub unsafe fn get_O_CREAT() -> c_int { rust_uv_get_O_CREAT() }\n+pub unsafe fn get_O_TRUNC() -> c_int { rust_uv_get_O_TRUNC() }\n+pub unsafe fn get_S_IWUSR() -> c_int { rust_uv_get_S_IWUSR() }\n+pub unsafe fn get_S_IRUSR() -> c_int { rust_uv_get_S_IRUSR() }\n+pub unsafe fn get_S_IRGRP() -> c_int { rust_uv_get_S_IRGRP() }\n+pub unsafe fn get_S_IROTH() -> c_int { rust_uv_get_S_IROTH() }\n pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n     rust_uv_get_result_from_fs_req(req)\n }\n@@ -819,6 +817,8 @@ extern {\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n     fn rust_uv_fs_open(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n                        flags: c_int, mode: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_write(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n+                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n     fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n                         cb: *u8) -> c_int;\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n@@ -827,6 +827,10 @@ extern {\n     fn rust_uv_get_O_RDWR() -> c_int;\n     fn rust_uv_get_O_CREAT() -> c_int;\n     fn rust_uv_get_O_TRUNC() -> c_int;\n+    fn rust_uv_get_S_IWUSR() -> c_int;\n+    fn rust_uv_get_S_IRUSR() -> c_int;\n+    fn rust_uv_get_S_IRGRP() -> c_int;\n+    fn rust_uv_get_S_IROTH() -> c_int;\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n "}, {"sha": "a788b0f71a4a5fcc2ce2c300d64cbce3c00fa6df", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dabbac1d6c06c00f24148ffc58b42455496fdd3c/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/dabbac1d6c06c00f24148ffc58b42455496fdd3c/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=dabbac1d6c06c00f24148ffc58b42455496fdd3c", "patch": "@@ -18,16 +18,13 @@\n #include <signal.h>\n #endif\n \n+#include <fcntl.h>\n #include \"uv.h\"\n \n #include \"rust_globals.h\"\n \n extern \"C\" void*\n rust_uv_loop_new() {\n-// XXX libuv doesn't always ignore SIGPIPE even though we don't need it.\n-#ifndef __WIN32__\n-    signal(SIGPIPE, SIG_IGN);\n-#endif\n     return (void*)uv_loop_new();\n }\n \n@@ -517,3 +514,45 @@ extern \"C\" uintptr_t\n rust_uv_req_type_max() {\n   return UV_REQ_TYPE_MAX;\n }\n+\n+extern \"C\" int\n+rust_uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n+                int mode, uv_fs_cb cb) {\n+  return uv_fs_open(loop, req, path, flags, mode, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {\n+  return uv_fs_close(loop, req, fd, cb);\n+}\n+extern \"C\" void\n+rust_uv_fs_req_cleanup(uv_fs_t* req) {\n+  uv_fs_req_cleanup(req);\n+}\n+extern \"C\" int\n+rust_uv_get_O_RDONLY() {\n+  return O_RDONLY;\n+}\n+extern \"C\" int\n+rust_uv_get_O_WRONLY() {\n+  return O_WRONLY;\n+}\n+extern \"C\" int\n+rust_uv_get_O_RDWR() {\n+  return O_RDWR;\n+}\n+extern \"C\" int\n+rust_uv_get_O_CREAT() {\n+  return O_CREAT;\n+}\n+extern \"C\" int\n+rust_uv_get_O_TRUNC() {\n+  return O_TRUNC;\n+}\n+extern \"C\" int\n+rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n+  return req->result;\n+}\n+extern \"C\" uv_loop_t*\n+rust_uv_get_loop_from_fs_req(uv_fs_t* req) {\n+  return req->loop;\n+}"}, {"sha": "d342ffa194ae1602834c7b2814e7bfbbf8e76e85", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dabbac1d6c06c00f24148ffc58b42455496fdd3c/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/dabbac1d6c06c00f24148ffc58b42455496fdd3c/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=dabbac1d6c06c00f24148ffc58b42455496fdd3c", "patch": "@@ -109,12 +109,17 @@ rust_uv_idle_init\n rust_uv_idle_start\n rust_uv_idle_stop\n rust_uv_fs_open\n+rust_uv_fs_write\n rust_uv_fs_close\n rust_uv_get_O_RDONLY\n rust_uv_get_O_WRONLY\n rust_uv_get_O_RDWR\n rust_uv_get_O_CREAT\n rust_uv_get_O_TRUNC\n+rust_uv_get_S_IRUSR\n+rust_uv_get_S_IWUSR\n+rust_uv_get_S_IROTH\n+rust_uv_get_S_IRGRP\n rust_uv_get_result_from_fs_req\n rust_uv_get_loop_from_fs_req\n rust_uv_fs_req_cleanup"}]}