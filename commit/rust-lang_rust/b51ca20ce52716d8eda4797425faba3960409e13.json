{"sha": "b51ca20ce52716d8eda4797425faba3960409e13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MWNhMjBjZTUyNzE2ZDhlZGE0Nzk3NDI1ZmFiYTM5NjA0MDllMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-05T00:22:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-05T00:22:14Z"}, "message": "Auto merge of #51964 - matthewjasper:unused-mut-mir-generation, r=nikomatsakis\n\n[NLL] Fix various unused mut errors\n\nCloses #51801\nCloses #50897\nCloses #51830\nCloses #51904\ncc #51918 - keeping this one open in case there are any more issues\n\nThis PR contains multiple changes. List of changes with examples of what they fix:\n\n* Change mir generation so that the parameter variable doesn't get a name when a `ref` pattern is used as an argument\n```rust\nfn f(ref y: i32) {} // doesn't trigger lint\n```\n* Change mir generation so that by-move closure captures don't get first moved into a temporary.\n```rust\nlet mut x = 0; // doesn't trigger lint\nmove || {\n    x = 1;\n};\n```\n* Treat generator upvars the same as closure upvars\n```rust\nlet mut x = 0; // This mut is now necessary and is not linted against.\nmove || {\n    x = 1;\n    yield;\n};\n```\n\nr? @nikomatsakis", "tree": {"sha": "5259c7e9bbbc8ac21120301d4e311aa47bfea9fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5259c7e9bbbc8ac21120301d4e311aa47bfea9fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b51ca20ce52716d8eda4797425faba3960409e13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b51ca20ce52716d8eda4797425faba3960409e13", "html_url": "https://github.com/rust-lang/rust/commit/b51ca20ce52716d8eda4797425faba3960409e13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b51ca20ce52716d8eda4797425faba3960409e13/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afaa40646542ca1e8fadb7e1d34197237e0fcd19", "url": "https://api.github.com/repos/rust-lang/rust/commits/afaa40646542ca1e8fadb7e1d34197237e0fcd19", "html_url": "https://github.com/rust-lang/rust/commit/afaa40646542ca1e8fadb7e1d34197237e0fcd19"}, {"sha": "125c9d99e58466b27f2b01f3865e6668d4c196ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/125c9d99e58466b27f2b01f3865e6668d4c196ff", "html_url": "https://github.com/rust-lang/rust/commit/125c9d99e58466b27f2b01f3865e6668d4c196ff"}], "stats": {"total": 260, "additions": 212, "deletions": 48}, "files": [{"sha": "83738d4ffd5cb16c957761ea991e22df6ae59517", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -1182,26 +1182,37 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // We need to report back the list of mutable upvars that were\n                 // moved into the closure and subsequently used by the closure,\n                 // in order to populate our used_mut set.\n-                if let AggregateKind::Closure(def_id, _) = &**aggregate_kind {\n-                    let BorrowCheckResult {\n-                        used_mut_upvars, ..\n-                    } = self.tcx.mir_borrowck(*def_id);\n-                    debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n-                    for field in used_mut_upvars {\n-                        match operands[field.index()] {\n-                            Operand::Move(Place::Local(local)) => {\n-                                self.used_mut.insert(local);\n-                            }\n-                            Operand::Move(ref place @ Place::Projection(_)) => {\n-                                if let Some(field) = self.is_upvar_field_projection(place) {\n-                                    self.used_mut_upvars.push(field);\n+                match **aggregate_kind {\n+                    AggregateKind::Closure(def_id, _)\n+                    | AggregateKind::Generator(def_id, _, _) => {\n+                        let BorrowCheckResult {\n+                            used_mut_upvars, ..\n+                        } = self.tcx.mir_borrowck(def_id);\n+                        debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n+                        for field in used_mut_upvars {\n+                            // This relies on the current way that by-value\n+                            // captures of a closure are copied/moved directly\n+                            // when generating MIR.\n+                            match operands[field.index()] {\n+                                Operand::Move(Place::Local(local))\n+                                | Operand::Copy(Place::Local(local)) => {\n+                                    self.used_mut.insert(local);\n+                                }\n+                                Operand::Move(ref place @ Place::Projection(_))\n+                                | Operand::Copy(ref place @ Place::Projection(_)) => {\n+                                    if let Some(field) = self.is_upvar_field_projection(place) {\n+                                        self.used_mut_upvars.push(field);\n+                                    }\n                                 }\n+                                Operand::Move(Place::Static(..))\n+                                | Operand::Copy(Place::Static(..))\n+                                | Operand::Constant(..) => {}\n                             }\n-                            Operand::Move(Place::Static(..))\n-                            | Operand::Copy(..)\n-                            | Operand::Constant(..) => {}\n                         }\n                     }\n+                    AggregateKind::Adt(..)\n+                    | AggregateKind::Array(..)\n+                    | AggregateKind::Tuple { .. } => (),\n                 }\n \n                 for operand in operands {\n@@ -1940,6 +1951,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            RootPlace {\n+                place: _,\n+                is_local_mutation_allowed: LocalMutationIsAllowed::Yes,\n+            } => {}\n             RootPlace {\n                 place: place @ Place::Projection(_),\n                 is_local_mutation_allowed: _,\n@@ -2115,13 +2130,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match *place {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _ty) => {\n-                    let is_projection_from_ty_closure = proj\n-                        .base\n-                        .ty(self.mir, self.tcx)\n-                        .to_ty(self.tcx)\n-                        .is_closure();\n+                    let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n-                    if is_projection_from_ty_closure {\n+                    if  base_ty.is_closure() || base_ty.is_generator() {\n                         Some(field)\n                     } else {\n                         None"}, {"sha": "9a756cdfb418e1dc49938a3a53e2c3d26937bd14", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -186,10 +186,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Closure { closure_id, substs, upvars, movability } => {\n                 // see (*) above\n-                let mut operands: Vec<_> =\n-                    upvars.into_iter()\n-                          .map(|upvar| unpack!(block = this.as_operand(block, scope, upvar)))\n-                          .collect();\n+                let mut operands: Vec<_> = upvars\n+                    .into_iter()\n+                    .map(|upvar| {\n+                        let upvar = this.hir.mirror(upvar);\n+                        match Category::of(&upvar.kind) {\n+                            // Use as_place to avoid creating a temporary when\n+                            // moving a variable into a closure, so that\n+                            // borrowck knows which variables to mark as being\n+                            // used as mut. This is OK here because the upvar\n+                            // expressions have no side effects and act on\n+                            // disjoint places.\n+                            // This occurs when capturing by copy/move, while\n+                            // by reference captures use as_operand\n+                            Some(Category::Place) => {\n+                                let place = unpack!(block = this.as_place(block, upvar));\n+                                this.consume_by_copy_or_move(place)\n+                            }\n+                            _ => {\n+                                unpack!(block = this.as_operand(block, scope, upvar))\n+                            }\n+                        }\n+                    })\n+                    .collect();\n                 let result = match substs {\n                     UpvarSubsts::Generator(substs) => {\n                         let movability = movability.unwrap();"}, {"sha": "c0821cdd3ba5d010f4fd6c9ca365129282962463", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -672,11 +672,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, pattern, _) in arguments.iter() {\n-            // If this is a simple binding pattern, give the local a nice name for debuginfo.\n+            // If this is a simple binding pattern, give the local a name for\n+            // debuginfo and so that error reporting knows that this is a user\n+            // variable. For any other pattern the pattern introduces new\n+            // variables which will be named instead.\n             let mut name = None;\n             if let Some(pat) = pattern {\n-                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n-                    name = Some(ident.name);\n+                match pat.node {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _)\n+                    | hir::PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, _) => {\n+                        name = Some(ident.name);\n+                    }\n+                    _ => (),\n                 }\n             }\n "}, {"sha": "59261ec968740f3e2ea422005b4f5cd6f6b1529e", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -34,38 +34,31 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     ...\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(22) d:D];\n-//     let mut _4: D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         StorageLive(_3);\n-//         StorageLive(_4);\n-//         _4 = move _1;\n-//         _3 = [closure@NodeId(22)] { d: move _4 };\n-//         drop(_4) -> [return: bb4, unwind: bb3];\n+//         _3 = [closure@NodeId(22)] { d: move _1 };\n+//         _2 = const foo(move _3) -> [return: bb2, unwind: bb4];\n //     }\n //     bb1: {\n //         resume;\n //     }\n //     bb2: {\n-//         drop(_1) -> bb1;\n+//         drop(_3) -> [return: bb5, unwind: bb3];\n //     }\n //     bb3: {\n-//         drop(_3) -> bb2;\n+//         drop(_1) -> bb1;\n //     }\n //     bb4: {\n-//         StorageDead(_4);\n-//         _2 = const foo(move _3) -> [return: bb5, unwind: bb3];\n+//         drop(_3) -> bb3;\n //     }\n //     bb5: {\n-//         drop(_3) -> [return: bb6, unwind: bb2];\n-//     }\n-//     bb6: {\n //         StorageDead(_3);\n //         _0 = ();\n-//         drop(_1) -> [return: bb7, unwind: bb1];\n+//         drop(_1) -> [return: bb6, unwind: bb1];\n //     }\n-//     bb7: {\n+//     bb6: {\n //         StorageDead(_1);\n //         return;\n //     }"}, {"sha": "a49913a62d9d0bdef2445a7408798469a4c57c57", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -37,17 +37,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //    ...\n //    let mut _3: ();\n //    let mut _4: [closure@NodeId(22) r:&'19s D];\n-//    let mut _5: &'21_1rs D;\n //    bb0: {\n //        StorageLive(_1);\n //        _1 = D::{{constructor}}(const 0i32,);\n //        StorageLive(_2);\n //        _2 = &'21_1rs _1;\n //        StorageLive(_4);\n-//        StorageLive(_5);\n-//        _5 = _2;\n-//        _4 = [closure@NodeId(22)] { r: move _5 };\n-//        StorageDead(_5);\n+//        _4 = [closure@NodeId(22)] { r: _2 };\n //        _3 = const foo(move _4) -> [return: bb2, unwind: bb3];\n //    }\n //    bb1: {"}, {"sha": "c3c5053af0c178de9941d17c45d885d751cd384b", "filename": "src/test/ui/nll/capture-mut-ref.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fcapture-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fcapture-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-mut-ref.rs?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that capturing a mutable reference by move and assigning to its\n+// referent doesn't make the unused mut lint think that it is mutable.\n+\n+#![feature(nll)]\n+#![deny(unused_mut)]\n+\n+fn mutable_upvar() {\n+    let mut x = &mut 0;\n+    //~^ ERROR\n+    move || {\n+        *x = 1;\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "50a77ee10e5b010b5b8819945c304c50c8cf3940", "filename": "src/test/ui/nll/capture-mut-ref.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fcapture-mut-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fcapture-mut-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-mut-ref.stderr?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -0,0 +1,16 @@\n+error: variable does not need to be mutable\n+  --> $DIR/capture-mut-ref.rs:18:9\n+   |\n+LL |     let mut x = &mut 0;\n+   |         ----^\n+   |         |\n+   |         help: remove this `mut`\n+   |\n+note: lint level defined here\n+  --> $DIR/capture-mut-ref.rs:15:9\n+   |\n+LL | #![deny(unused_mut)]\n+   |         ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ce07e2b0e2184aeed096b59ed3735d3082cc190a", "filename": "src/test/ui/nll/extra-unused-mut.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// extra unused mut lint tests for #51918\n+\n+// run-pass\n+\n+#![feature(generators, nll)]\n+#![deny(unused_mut)]\n+\n+fn ref_argument(ref _y: i32) {}\n+\n+// #51801\n+fn mutable_upvar() {\n+    let mut x = 0;\n+    move || {\n+        x = 1;\n+    };\n+}\n+\n+// #50897\n+fn generator_mutable_upvar() {\n+    let mut x = 0;\n+    move || {\n+        x = 1;\n+        yield;\n+    };\n+}\n+\n+// #51830\n+fn ref_closure_argument() {\n+    let _ = Some(0).as_ref().map(|ref _a| true);\n+}\n+\n+struct Expr {\n+    attrs: Vec<u32>,\n+}\n+\n+// #51904\n+fn parse_dot_or_call_expr_with(mut attrs: Vec<u32>) {\n+    let x = Expr { attrs: vec![] };\n+    Some(Some(x)).map(|expr|\n+        expr.map(|mut expr| {\n+            attrs.push(666);\n+            expr.attrs = attrs;\n+            expr\n+        })\n+    );\n+}\n+\n+fn main() {\n+    ref_argument(0);\n+    mutable_upvar();\n+    generator_mutable_upvar();\n+    ref_closure_argument();\n+    parse_dot_or_call_expr_with(Vec::new());\n+}"}, {"sha": "a32e076cb93a5d06994daa201e1851bd4a243841", "filename": "src/test/ui/nll/generator-upvar-mutability.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fgenerator-upvar-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fgenerator-upvar-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fgenerator-upvar-mutability.rs?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that generators respect the muatability of their upvars.\n+\n+#![feature(generators, nll)]\n+\n+fn mutate_upvar() {\n+    let x = 0;\n+    move || {\n+        x = 1;\n+        //~^ ERROR\n+        yield;\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "9c5c57687a2ea23d11bf26f459bc3c991873d8a5", "filename": "src/test/ui/nll/generator-upvar-mutability.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fgenerator-upvar-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b51ca20ce52716d8eda4797425faba3960409e13/src%2Ftest%2Fui%2Fnll%2Fgenerator-upvar-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fgenerator-upvar-mutability.stderr?ref=b51ca20ce52716d8eda4797425faba3960409e13", "patch": "@@ -0,0 +1,9 @@\n+error[E0594]: cannot assign to immutable item `x`\n+  --> $DIR/generator-upvar-mutability.rs:18:9\n+   |\n+LL |         x = 1;\n+   |         ^^^^^ cannot assign\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0594`."}]}