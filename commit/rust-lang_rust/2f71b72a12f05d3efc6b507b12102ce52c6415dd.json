{"sha": "2f71b72a12f05d3efc6b507b12102ce52c6415dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNzFiNzJhMTJmMDVkM2VmYzZiNTA3YjEyMTAyY2U1MmM2NDE1ZGQ=", "commit": {"author": {"name": "Florian Zeitz", "email": "florob@babelmonkeys.de", "date": "2014-05-12T19:53:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-14T00:24:07Z"}, "message": "core: Use appropriately sized integers for codepoints and bytes", "tree": {"sha": "b24e06781e4b9df129d6cb959501ead7653e077d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b24e06781e4b9df129d6cb959501ead7653e077d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f71b72a12f05d3efc6b507b12102ce52c6415dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f71b72a12f05d3efc6b507b12102ce52c6415dd", "html_url": "https://github.com/rust-lang/rust/commit/2f71b72a12f05d3efc6b507b12102ce52c6415dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f71b72a12f05d3efc6b507b12102ce52c6415dd/comments", "author": {"login": "Florob", "id": 133684, "node_id": "MDQ6VXNlcjEzMzY4NA==", "avatar_url": "https://avatars.githubusercontent.com/u/133684?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Florob", "html_url": "https://github.com/Florob", "followers_url": "https://api.github.com/users/Florob/followers", "following_url": "https://api.github.com/users/Florob/following{/other_user}", "gists_url": "https://api.github.com/users/Florob/gists{/gist_id}", "starred_url": "https://api.github.com/users/Florob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Florob/subscriptions", "organizations_url": "https://api.github.com/users/Florob/orgs", "repos_url": "https://api.github.com/users/Florob/repos", "events_url": "https://api.github.com/users/Florob/events{/privacy}", "received_events_url": "https://api.github.com/users/Florob/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74ad0236747469f9646916d1916dee2598076161", "url": "https://api.github.com/repos/rust-lang/rust/commits/74ad0236747469f9646916d1916dee2598076161", "html_url": "https://github.com/rust-lang/rust/commit/74ad0236747469f9646916d1916dee2598076161"}], "stats": {"total": 95, "additions": 45, "deletions": 50}, "files": [{"sha": "ca5e56f0649cc8ffd23f87b1721c6cf0156da32a", "filename": "src/libcore/char.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2f71b72a12f05d3efc6b507b12102ce52c6415dd/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f71b72a12f05d3efc6b507b12102ce52c6415dd/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=2f71b72a12f05d3efc6b507b12102ce52c6415dd", "patch": "@@ -33,13 +33,14 @@ use unicode::{derived_property, property, general_category, decompose, conversio\n #[cfg(not(test))] use default::Default;\n \n // UTF-8 ranges and tags for encoding characters\n-static TAG_CONT: uint = 128u;\n-static MAX_ONE_B: uint = 128u;\n-static TAG_TWO_B: uint = 192u;\n-static MAX_TWO_B: uint = 2048u;\n-static TAG_THREE_B: uint = 224u;\n-static MAX_THREE_B: uint = 65536u;\n-static TAG_FOUR_B: uint = 240u;\n+static TAG_CONT: u8    = 0b1000_0000u8;\n+static TAG_TWO_B: u8   = 0b1100_0000u8;\n+static TAG_THREE_B: u8 = 0b1110_0000u8;\n+static TAG_FOUR_B: u8  = 0b1111_0000u8;\n+static MAX_ONE_B: u32   =     0x80u32;\n+static MAX_TWO_B: u32   =    0x800u32;\n+static MAX_THREE_B: u32 =  0x10000u32;\n+static MAX_FOUR_B:  u32 = 0x200000u32;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -285,37 +286,37 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n }\n \n // Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n-static S_BASE: uint = 0xAC00;\n-static L_BASE: uint = 0x1100;\n-static V_BASE: uint = 0x1161;\n-static T_BASE: uint = 0x11A7;\n-static L_COUNT: uint = 19;\n-static V_COUNT: uint = 21;\n-static T_COUNT: uint = 28;\n-static N_COUNT: uint = (V_COUNT * T_COUNT);\n-static S_COUNT: uint = (L_COUNT * N_COUNT);\n+static S_BASE: u32 = 0xAC00;\n+static L_BASE: u32 = 0x1100;\n+static V_BASE: u32 = 0x1161;\n+static T_BASE: u32 = 0x11A7;\n+static L_COUNT: u32 = 19;\n+static V_COUNT: u32 = 21;\n+static T_COUNT: u32 = 28;\n+static N_COUNT: u32 = (V_COUNT * T_COUNT);\n+static S_COUNT: u32 = (L_COUNT * N_COUNT);\n \n // Decompose a precomposed Hangul syllable\n fn decompose_hangul(s: char, f: |char|) {\n-    let si = s as uint - S_BASE;\n+    let si = s as u32 - S_BASE;\n \n     let li = si / N_COUNT;\n     unsafe {\n-        f(transmute((L_BASE + li) as u32));\n+        f(transmute(L_BASE + li));\n \n         let vi = (si % N_COUNT) / T_COUNT;\n-        f(transmute((V_BASE + vi) as u32));\n+        f(transmute(V_BASE + vi));\n \n         let ti = si % T_COUNT;\n         if ti > 0 {\n-            f(transmute((T_BASE + ti) as u32));\n+            f(transmute(T_BASE + ti));\n         }\n     }\n }\n \n /// Returns the canonical decomposition of a character\n pub fn decompose_canonical(c: char, f: |char|) {\n-    if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n+    if (c as u32) < S_BASE || (c as u32) >= (S_BASE + S_COUNT) {\n         decompose::canonical(c, f);\n     } else {\n         decompose_hangul(c, f);\n@@ -324,7 +325,7 @@ pub fn decompose_canonical(c: char, f: |char|) {\n \n /// Returns the compatibility decomposition of a character\n pub fn decompose_compatible(c: char, f: |char|) {\n-    if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n+    if (c as u32) < S_BASE || (c as u32) >= (S_BASE + S_COUNT) {\n         decompose::compatibility(c, f);\n     } else {\n         decompose_hangul(c, f);\n@@ -386,12 +387,7 @@ pub fn escape_default(c: char, f: |char|) {\n \n /// Returns the amount of bytes this `char` would need if encoded in UTF-8\n pub fn len_utf8_bytes(c: char) -> uint {\n-    static MAX_ONE_B:   uint = 128u;\n-    static MAX_TWO_B:   uint = 2048u;\n-    static MAX_THREE_B: uint = 65536u;\n-    static MAX_FOUR_B:  uint = 2097152u;\n-\n-    let code = c as uint;\n+    let code = c as u32;\n     match () {\n         _ if code < MAX_ONE_B   => 1u,\n         _ if code < MAX_TWO_B   => 2u,\n@@ -606,41 +602,40 @@ impl Char for char {\n \n     fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n \n-    fn encode_utf8(&self, dst: &mut [u8]) -> uint {\n-        let code = *self as uint;\n+    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> uint {\n+        let code = *self as u32;\n         if code < MAX_ONE_B {\n             dst[0] = code as u8;\n-            return 1;\n+            1\n         } else if code < MAX_TWO_B {\n-            dst[0] = (code >> 6u & 31u | TAG_TWO_B) as u8;\n-            dst[1] = (code & 63u | TAG_CONT) as u8;\n-            return 2;\n+            dst[0] = (code >> 6u & 0x1F_u32) as u8 | TAG_TWO_B;\n+            dst[1] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+            2\n         } else if code < MAX_THREE_B {\n-            dst[0] = (code >> 12u & 15u | TAG_THREE_B) as u8;\n-            dst[1] = (code >> 6u & 63u | TAG_CONT) as u8;\n-            dst[2] = (code & 63u | TAG_CONT) as u8;\n-            return 3;\n+            dst[0] = (code >> 12u & 0x0F_u32) as u8 | TAG_THREE_B;\n+            dst[1] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n+            dst[2] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+            3\n         } else {\n-            dst[0] = (code >> 18u & 7u | TAG_FOUR_B) as u8;\n-            dst[1] = (code >> 12u & 63u | TAG_CONT) as u8;\n-            dst[2] = (code >> 6u & 63u | TAG_CONT) as u8;\n-            dst[3] = (code & 63u | TAG_CONT) as u8;\n-            return 4;\n+            dst[0] = (code >> 18u & 0x07_u32) as u8 | TAG_FOUR_B;\n+            dst[1] = (code >> 12u & 0x3F_u32) as u8 | TAG_CONT;\n+            dst[2] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n+            dst[3] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+            4\n         }\n     }\n \n     fn encode_utf16(&self, dst: &mut [u16]) -> uint {\n-        let mut ch = *self as uint;\n-        if (ch & 0xFFFF_u) == ch {\n-            // The BMP falls through (assuming non-surrogate, as it\n-            // should)\n-            assert!(ch <= 0xD7FF_u || ch >= 0xE000_u);\n+        let mut ch = *self as u32;\n+        if (ch & 0xFFFF_u32) == ch {\n+            // The BMP falls through (assuming non-surrogate, as it should)\n+            assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n             dst[0] = ch as u16;\n             1\n         } else {\n             // Supplementary planes break into surrogates.\n-            assert!(ch >= 0x1_0000_u && ch <= 0x10_FFFF_u);\n-            ch -= 0x1_0000_u;\n+            assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n+            ch -= 0x1_0000_u32;\n             dst[0] = 0xD800_u16 | ((ch >> 10) as u16);\n             dst[1] = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n             2"}]}