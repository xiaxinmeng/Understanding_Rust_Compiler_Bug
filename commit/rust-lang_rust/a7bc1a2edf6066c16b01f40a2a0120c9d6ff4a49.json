{"sha": "a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YmMxYTJlZGY2MDY2YzE2YjAxZjQwYTJhMDEyMGM5ZDZmZjRhNDk=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-10-23T18:41:56Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-10-23T19:00:30Z"}, "message": "Make codegen coverage_context optional, and check\n\nAddresses Issue #78286\n\nLibraries compiled with coverage and linked with out enabling coverage\nwould fail when attempting to add the library's coverage statements to\nthe codegen coverage context (None).\n\nNow, if coverage statements are encountered while compiling / linking\nwith `-Z instrument-coverage` disabled, codegen will *not* attempt to\nadd code regions to a coverage map, and it will not inject the LLVM\ninstrprof_increment intrinsic calls.", "tree": {"sha": "590bba8c1ef866aede93e3e8293f35e74fb10ff7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/590bba8c1ef866aede93e3e8293f35e74fb10ff7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49", "html_url": "https://github.com/rust-lang/rust/commit/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9", "html_url": "https://github.com/rust-lang/rust/commit/07a63e6d1fabf3560e8e1e17c1d56b10a06152d9"}], "stats": {"total": 124, "additions": 74, "deletions": 50}, "files": [{"sha": "56ff580b43b5989ba293e3ab31381dd17d22a194", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49", "patch": "@@ -324,8 +324,8 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn coverage_context(&'a self) -> &'a coverageinfo::CrateCoverageContext<'tcx> {\n-        self.coverage_cx.as_ref().unwrap()\n+    pub fn coverage_context(&'a self) -> Option<&'a coverageinfo::CrateCoverageContext<'tcx>> {\n+        self.coverage_cx.as_ref()\n     }\n }\n "}, {"sha": "94ef33ac5b4671e151ead49526662b069716656a", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49", "patch": "@@ -26,7 +26,10 @@ use tracing::debug;\n /// undocumented details in Clang's implementation (that may or may not be important) were also\n /// replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n-    let function_coverage_map = cx.coverage_context().take_function_coverage_map();\n+    if cx.coverage_context().is_none() {\n+        return;\n+    }\n+    let function_coverage_map = cx.coverage_context().unwrap().take_function_coverage_map();\n     if function_coverage_map.is_empty() {\n         // This module has no functions with coverage instrumentation\n         return;"}, {"sha": "7fdbe1a55128ae2f438b5afc5a1c03baa12ab559", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49", "patch": "@@ -64,17 +64,22 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         function_source_hash: u64,\n         id: CounterValueReference,\n         region: CodeRegion,\n-    ) {\n-        debug!(\n-            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={:?}, \\\n-             at {:?}\",\n-            instance, function_source_hash, id, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter(function_source_hash, id, region);\n+    ) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={:?}, \\\n+                at {:?}\",\n+                instance, function_source_hash, id, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_counter(function_source_hash, id, region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     fn add_counter_expression_region(\n@@ -85,29 +90,39 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         op: Op,\n         rhs: ExpressionOperandId,\n         region: CodeRegion,\n-    ) {\n-        debug!(\n-            \"adding counter expression to coverage_regions: instance={:?}, id={:?}, {:?} {:?} {:?}, \\\n-             at {:?}\",\n-            instance, id, lhs, op, rhs, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter_expression(id, lhs, op, rhs, region);\n+    ) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding counter expression to coverage_regions: instance={:?}, id={:?}, {:?} {:?} {:?}, \\\n+                at {:?}\",\n+                instance, id, lhs, op, rhs, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_counter_expression(id, lhs, op, rhs, region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) {\n-        debug!(\n-            \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n-            instance, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_unreachable_region(region);\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n+                instance, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_unreachable_region(region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n "}, {"sha": "4811adea9ec060851466bddf3a9256c9d2958f42", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49", "patch": "@@ -10,19 +10,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let Coverage { kind, code_region } = coverage;\n         match kind {\n             CoverageKind::Counter { function_source_hash, id } => {\n-                bx.add_counter_region(self.instance, function_source_hash, id, code_region);\n+                if bx.add_counter_region(self.instance, function_source_hash, id, code_region) {\n+                    let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n \n-                let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n-\n-                let fn_name = bx.create_pgo_func_name_var(self.instance);\n-                let hash = bx.const_u64(function_source_hash);\n-                let num_counters = bx.const_u32(coverageinfo.num_counters);\n-                let id = bx.const_u32(u32::from(id));\n-                debug!(\n-                    \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    fn_name, hash, num_counters, id,\n-                );\n-                bx.instrprof_increment(fn_name, hash, num_counters, id);\n+                    let fn_name = bx.create_pgo_func_name_var(self.instance);\n+                    let hash = bx.const_u64(function_source_hash);\n+                    let num_counters = bx.const_u32(coverageinfo.num_counters);\n+                    let id = bx.const_u32(u32::from(id));\n+                    debug!(\n+                        \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n+                        fn_name, hash, num_counters, id,\n+                    );\n+                    bx.instrprof_increment(fn_name, hash, num_counters, id);\n+                }\n             }\n             CoverageKind::Expression { id, lhs, op, rhs } => {\n                 bx.add_counter_expression_region(self.instance, id, lhs, op, rhs, code_region);"}, {"sha": "3b1654f3ad4fc94681bc0eff9f5821538afc2d47", "filename": "compiler/rustc_codegen_ssa/src/traits/coverageinfo.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs?ref=a7bc1a2edf6066c16b01f40a2a0120c9d6ff4a49", "patch": "@@ -9,14 +9,18 @@ pub trait CoverageInfoMethods: BackendTypes {\n pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n     fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value;\n \n+    /// Returns true if the counter was added to the coverage map; false if `-Z instrument-coverage`\n+    /// is not enabled (a coverage map is not being generated).\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n         id: CounterValueReference,\n         region: CodeRegion,\n-    );\n+    ) -> bool;\n \n+    /// Returns true if the expression was added to the coverage map; false if\n+    /// `-Z instrument-coverage` is not enabled (a coverage map is not being generated).\n     fn add_counter_expression_region(\n         &mut self,\n         instance: Instance<'tcx>,\n@@ -25,7 +29,9 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         op: Op,\n         rhs: ExpressionOperandId,\n         region: CodeRegion,\n-    );\n+    ) -> bool;\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion);\n+    /// Returns true if the region was added to the coverage map; false if `-Z instrument-coverage`\n+    /// is not enabled (a coverage map is not being generated).\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) -> bool;\n }"}]}