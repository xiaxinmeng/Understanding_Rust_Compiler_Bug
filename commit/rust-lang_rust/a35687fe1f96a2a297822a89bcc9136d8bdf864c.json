{"sha": "a35687fe1f96a2a297822a89bcc9136d8bdf864c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNTY4N2ZlMWY5NmEyYTI5NzgyMmE4OWJjYzkxMzZkOGJkZjg2NGM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-20T15:41:10Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-20T15:41:10Z"}, "message": "Minor cleanups", "tree": {"sha": "1899863c249420e38ee25c205b7c0b79ea4889df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1899863c249420e38ee25c205b7c0b79ea4889df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a35687fe1f96a2a297822a89bcc9136d8bdf864c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a35687fe1f96a2a297822a89bcc9136d8bdf864c", "html_url": "https://github.com/rust-lang/rust/commit/a35687fe1f96a2a297822a89bcc9136d8bdf864c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a35687fe1f96a2a297822a89bcc9136d8bdf864c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb7b4a5d5bb93bda26694667a9bede827196d864", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7b4a5d5bb93bda26694667a9bede827196d864", "html_url": "https://github.com/rust-lang/rust/commit/cb7b4a5d5bb93bda26694667a9bede827196d864"}], "stats": {"total": 104, "additions": 50, "deletions": 54}, "files": [{"sha": "ca97d67268c7399dcbbce7c6305074687453614c", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 50, "deletions": 54, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a35687fe1f96a2a297822a89bcc9136d8bdf864c/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a35687fe1f96a2a297822a89bcc9136d8bdf864c/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=a35687fe1f96a2a297822a89bcc9136d8bdf864c", "patch": "@@ -255,35 +255,21 @@ fn get_doc_link(db: &RootDatabase, definition: Definition) -> Option<String> {\n             };\n             (def, Some(format!(\"structfield.{}\", field.name(db))))\n         }\n-        Definition::Macro(_) => todo!(),\n-        Definition::SelfType(_) => todo!(),\n+        // FIXME macros\n+        Definition::Macro(_) => return None,\n+        // FIXME impls\n+        Definition::SelfType(_) => return None,\n         Definition::Local(_) | Definition::GenericParam(_) | Definition::Label(_) => return None,\n     };\n \n-    let krate = match definition {\n-        // Definition::module gives back the parent module, we don't want that as it fails for root modules\n-        Definition::ModuleDef(ModuleDef::Module(module)) => module.krate(),\n-        _ => definition.module(db)?.krate(),\n-    };\n+    let krate = crate_of_def(db, target)?;\n+    let mut url = get_doc_base_url(db, &krate)?;\n \n-    let mut base = krate.display_name(db)?.to_string();\n-    let is_non_root_module = !matches!(\n-        definition,\n-        Definition::ModuleDef(ModuleDef::Module(module)) if krate.root_module(db) == module\n-    );\n-    if is_non_root_module {\n-        target\n-            .canonical_module_path(db)?\n-            .flat_map(|it| it.name(db))\n-            .for_each(|name| format_to!(base, \"/{}\", name));\n+    if let Some(path) = mod_path_of_def(db, target) {\n+        url = url.join(&path).ok()?;\n     }\n-    base += \"/\";\n \n-    let mut url = get_doc_base_url(db, &krate)?\n-        .join(&base)\n-        .ok()?\n-        .join(&get_symbol_filename(db, &target)?)\n-        .ok()?;\n+    url = url.join(&get_symbol_filename(db, &target)?).ok()?;\n     url.set_fragment(frag.as_deref());\n \n     Some(url.into())\n@@ -296,31 +282,29 @@ fn rewrite_intra_doc_link(\n     title: &str,\n ) -> Option<(String, String)> {\n     let (link, ns) = parse_intra_doc_link(target);\n+\n     let resolved = resolve_doc_path_for_def(db, def, link, ns)?;\n-    let krate = resolved.module(db)?.krate();\n-    let mut mod_path = String::new();\n-    resolved\n-        .canonical_module_path(db)?\n-        .flat_map(|it| it.name(db))\n-        .for_each(|name| format_to!(mod_path, \"{}/\", name));\n-    let mut new_url = get_doc_base_url(db, &krate)?\n-        .join(&format!(\"{}/\", krate.display_name(db)?))\n-        .ok()?\n-        .join(&mod_path)\n-        .ok()?;\n-    if let Some(assoc_item) = resolved.as_assoc_item(db) {\n+    let krate = crate_of_def(db, resolved)?;\n+    let mut url = get_doc_base_url(db, &krate)?;\n+\n+    if let Some(path) = mod_path_of_def(db, resolved) {\n+        url = url.join(&path).ok()?;\n+    }\n+\n+    let (resolved, frag) = if let Some(assoc_item) = resolved.as_assoc_item(db) {\n         let resolved = match assoc_item.container(db) {\n             AssocItemContainer::Trait(t) => t.into(),\n             AssocItemContainer::Impl(i) => i.self_ty(db).as_adt()?.into(),\n         };\n-        new_url = new_url.join(&get_symbol_filename(db, &resolved)?).ok()?;\n         let frag = get_assoc_item_fragment(db, assoc_item)?;\n-        new_url.set_fragment(Some(&frag));\n+        (resolved, Some(frag))\n     } else {\n-        new_url = new_url.join(&get_symbol_filename(db, &resolved)?).ok()?;\n+        (resolved, None)\n     };\n+    url = url.join(&get_symbol_filename(db, &resolved)?).ok()?;\n+    url.set_fragment(frag.as_deref());\n \n-    Some((new_url.into(), strip_prefixes_suffixes(title).to_string()))\n+    Some((url.into(), strip_prefixes_suffixes(title).to_string()))\n }\n \n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n@@ -329,21 +313,32 @@ fn rewrite_url_link(db: &RootDatabase, def: ModuleDef, target: &str) -> Option<S\n         return None;\n     }\n \n-    let module = def.module(db)?;\n-    let krate = module.krate();\n-    let mut base = krate.display_name(db)?.to_string();\n-    let is_non_root_module = !matches!(\n-        def,\n-        ModuleDef::Module(module) if krate.root_module(db) == module\n-    );\n-    if is_non_root_module {\n-        def.canonical_module_path(db)?\n-            .flat_map(|it| it.name(db))\n-            .for_each(|name| format_to!(base, \"/{}\", name));\n+    let krate = crate_of_def(db, def)?;\n+    let mut url = get_doc_base_url(db, &krate)?;\n+\n+    if let Some(path) = mod_path_of_def(db, def) {\n+        url = url.join(&path).ok()?;\n     }\n-    base += \"/\";\n \n-    get_doc_base_url(db, &krate)?.join(&base).ok()?.join(target).ok().map(Into::into)\n+    url = url.join(&get_symbol_filename(db, &def)?).ok()?;\n+    url.join(target).ok().map(Into::into)\n+}\n+\n+fn crate_of_def(db: &RootDatabase, def: ModuleDef) -> Option<Crate> {\n+    let krate = match def {\n+        // Definition::module gives back the parent module, we don't want that as it fails for root modules\n+        ModuleDef::Module(module) => module.krate(),\n+        _ => def.module(db)?.krate(),\n+    };\n+    Some(krate)\n+}\n+\n+fn mod_path_of_def(db: &RootDatabase, def: ModuleDef) -> Option<String> {\n+    def.canonical_module_path(db).map(|it| {\n+        let mut path = String::new();\n+        it.flat_map(|it| it.name(db)).for_each(|name| format_to!(path, \"{}/\", name));\n+        path\n+    })\n }\n \n /// Rewrites a markdown document, applying 'callback' to each link.\n@@ -389,6 +384,7 @@ fn map_links<'e>(\n /// ^^^^^^^^^^^^^^^^^^^^^^^^^^\n /// ```\n fn get_doc_base_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n+    let display_name = krate.display_name(db)?;\n     krate\n         .get_html_root_url(db)\n         .or_else(|| {\n@@ -397,9 +393,9 @@ fn get_doc_base_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n             //\n             // FIXME: clicking on the link should just open the file in the editor,\n             // instead of falling back to external urls.\n-            Some(format!(\"https://docs.rs/{}/*/\", krate.display_name(db)?))\n+            Some(format!(\"https://docs.rs/{krate}/*/\", krate = display_name))\n         })\n-        .and_then(|s| Url::parse(&s).ok())\n+        .and_then(|s| Url::parse(&s).ok()?.join(&format!(\"{}/\", display_name)).ok())\n }\n \n /// Get the filename and extension generated for a symbol by rustdoc."}]}