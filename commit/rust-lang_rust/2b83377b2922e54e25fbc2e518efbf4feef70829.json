{"sha": "2b83377b2922e54e25fbc2e518efbf4feef70829", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiODMzNzdiMjkyMmU1NGUyNWZiYzJlNTE4ZWZiZjRmZWVmNzA4Mjk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-27T21:32:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:01:57Z"}, "message": "libsyntax: De-`@mut` `TtReader::stack`", "tree": {"sha": "0faf058d0e64df316980a4565e8db97272975e77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0faf058d0e64df316980a4565e8db97272975e77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b83377b2922e54e25fbc2e518efbf4feef70829", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b83377b2922e54e25fbc2e518efbf4feef70829", "html_url": "https://github.com/rust-lang/rust/commit/2b83377b2922e54e25fbc2e518efbf4feef70829", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b83377b2922e54e25fbc2e518efbf4feef70829/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b597207cedbea8aafddd1938589849137d5bc468", "url": "https://api.github.com/repos/rust-lang/rust/commits/b597207cedbea8aafddd1938589849137d5bc468", "html_url": "https://github.com/rust-lang/rust/commit/b597207cedbea8aafddd1938589849137d5bc468"}], "stats": {"total": 48, "additions": 24, "deletions": 24}, "files": [{"sha": "02094ff3d6ad7f3f0211c948c1223597a80e7d61", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2b83377b2922e54e25fbc2e518efbf4feef70829/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b83377b2922e54e25fbc2e518efbf4feef70829/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=2b83377b2922e54e25fbc2e518efbf4feef70829", "patch": "@@ -33,7 +33,7 @@ struct TtFrame {\n pub struct TtReader {\n     sp_diag: @mut SpanHandler,\n     // the unzipped tree:\n-    stack: @mut TtFrame,\n+    priv stack: RefCell<@mut TtFrame>,\n     /* for MBE-style macro transcription */\n     priv interpolations: RefCell<HashMap<Ident, @named_match>>,\n     priv repeat_idx: RefCell<~[uint]>,\n@@ -52,13 +52,13 @@ pub fn new_tt_reader(sp_diag: @mut SpanHandler,\n                   -> @mut TtReader {\n     let r = @mut TtReader {\n         sp_diag: sp_diag,\n-        stack: @mut TtFrame {\n+        stack: RefCell::new(@mut TtFrame {\n             forest: @src,\n             idx: 0u,\n             dotdotdoted: false,\n             sep: None,\n             up: option::None\n-        },\n+        }),\n         interpolations: match interp { /* just a convienience */\n             None => RefCell::new(HashMap::new()),\n             Some(x) => RefCell::new(x),\n@@ -89,7 +89,7 @@ fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n     @mut TtReader {\n         sp_diag: r.sp_diag,\n-        stack: dup_tt_frame(r.stack),\n+        stack: RefCell::new(dup_tt_frame(r.stack.get())),\n         repeat_idx: r.repeat_idx.clone(),\n         repeat_len: r.repeat_len.clone(),\n         cur_tok: r.cur_tok.clone(),\n@@ -181,26 +181,26 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     };\n     loop {\n         {\n-            let stack = &mut *r.stack;\n-            if stack.idx < stack.forest.len() {\n+            let mut stack = r.stack.borrow_mut();\n+            if stack.get().idx < stack.get().forest.len() {\n                 break;\n             }\n         }\n \n         /* done with this set; pop or repeat? */\n-        if ! r.stack.dotdotdoted || {\n+        if !r.stack.get().dotdotdoted || {\n                 let repeat_idx = r.repeat_idx.borrow();\n                 let repeat_len = r.repeat_len.borrow();\n                 *repeat_idx.get().last() == *repeat_len.get().last() - 1\n             } {\n \n-            match r.stack.up {\n+            match r.stack.get().up {\n               None => {\n                 r.cur_tok.set(EOF);\n                 return ret_val;\n               }\n               Some(tt_f) => {\n-                if r.stack.dotdotdoted {\n+                if r.stack.get().dotdotdoted {\n                     {\n                         let mut repeat_idx = r.repeat_idx.borrow_mut();\n                         let mut repeat_len = r.repeat_len.borrow_mut();\n@@ -209,18 +209,18 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                     }\n                 }\n \n-                r.stack = tt_f;\n-                r.stack.idx += 1u;\n+                r.stack.set(tt_f);\n+                r.stack.get().idx += 1u;\n               }\n             }\n \n         } else { /* repeat */\n-            r.stack.idx = 0u;\n+            r.stack.get().idx = 0u;\n             {\n                 let mut repeat_idx = r.repeat_idx.borrow_mut();\n                 repeat_idx.get()[repeat_idx.get().len() - 1u] += 1u;\n             }\n-            match r.stack.sep.clone() {\n+            match r.stack.get().sep.clone() {\n               Some(tk) => {\n                 r.cur_tok.set(tk); /* repeat same span, I guess */\n                 return ret_val;\n@@ -232,21 +232,21 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         // XXX(pcwalton): Bad copy.\n-        match r.stack.forest[r.stack.idx].clone() {\n+        match r.stack.get().forest[r.stack.get().idx].clone() {\n           tt_delim(tts) => {\n-            r.stack = @mut TtFrame {\n+            r.stack.set(@mut TtFrame {\n                 forest: tts,\n                 idx: 0u,\n                 dotdotdoted: false,\n                 sep: None,\n-                up: option::Some(r.stack)\n-            };\n+                up: option::Some(r.stack.get())\n+            });\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n           tt_tok(sp, tok) => {\n             r.cur_span.set(sp);\n             r.cur_tok.set(tok);\n-            r.stack.idx += 1u;\n+            r.stack.get().idx += 1u;\n             return ret_val;\n           }\n           tt_seq(sp, tts, sep, zerok) => {\n@@ -273,21 +273,21 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                                               once\");\n                           }\n \n-                    r.stack.idx += 1u;\n+                    r.stack.get().idx += 1u;\n                     return tt_next_token(r);\n                 } else {\n                     {\n                         let mut repeat_idx = r.repeat_idx.borrow_mut();\n                         let mut repeat_len = r.repeat_len.borrow_mut();\n                         repeat_len.get().push(len);\n                         repeat_idx.get().push(0u);\n-                        r.stack = @mut TtFrame {\n+                        r.stack.set(@mut TtFrame {\n                             forest: tts,\n                             idx: 0u,\n                             dotdotdoted: true,\n                             sep: sep,\n-                            up: Some(r.stack)\n-                        };\n+                            up: Some(r.stack.get())\n+                        });\n                     }\n                 }\n               }\n@@ -302,14 +302,14 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n               matched_nonterminal(nt_ident(~sn,b)) => {\n                 r.cur_span.set(sp);\n                 r.cur_tok.set(IDENT(sn,b));\n-                r.stack.idx += 1u;\n+                r.stack.get().idx += 1u;\n                 return ret_val;\n               }\n               matched_nonterminal(ref other_whole_nt) => {\n                 // XXX(pcwalton): Bad copy.\n                 r.cur_span.set(sp);\n                 r.cur_tok.set(INTERPOLATED((*other_whole_nt).clone()));\n-                r.stack.idx += 1u;\n+                r.stack.get().idx += 1u;\n                 return ret_val;\n               }\n               matched_seq(..) => {"}]}