{"sha": "cf5d28083dc25ae9a395b7e55e98af9c621574dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNWQyODA4M2RjMjVhZTlhMzk1YjdlNTVlOThhZjljNjIxNTc0ZGM=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-08-14T19:49:26Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-08-21T01:02:24Z"}, "message": "libgreen: use FFI-safe types", "tree": {"sha": "80d4722b567eea10449c921dfb9d0d3a1d83261b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80d4722b567eea10449c921dfb9d0d3a1d83261b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf5d28083dc25ae9a395b7e55e98af9c621574dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5d28083dc25ae9a395b7e55e98af9c621574dc", "html_url": "https://github.com/rust-lang/rust/commit/cf5d28083dc25ae9a395b7e55e98af9c621574dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf5d28083dc25ae9a395b7e55e98af9c621574dc/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dc2ac1e6b382b8c658071f61c3f95ae444dcc16", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dc2ac1e6b382b8c658071f61c3f95ae444dcc16", "html_url": "https://github.com/rust-lang/rust/commit/2dc2ac1e6b382b8c658071f61c3f95ae444dcc16"}], "stats": {"total": 76, "additions": 45, "deletions": 31}, "files": [{"sha": "42418ccbc1a6fad0b11e4498a703752529c830fb", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf5d28083dc25ae9a395b7e55e98af9c621574dc/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5d28083dc25ae9a395b7e55e98af9c621574dc/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=cf5d28083dc25ae9a395b7e55e98af9c621574dc", "patch": "@@ -40,6 +40,7 @@\n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n@@ -48,22 +49,26 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n@@ -72,25 +77,30 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n #[experimental]\n #[simd]\n #[deriving(Show)]\n+#[repr(C)]\n pub struct f64x2(pub f64, pub f64);"}, {"sha": "dfed121b3cee1c3735a702c68ed2167388119ac8", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cf5d28083dc25ae9a395b7e55e98af9c621574dc/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5d28083dc25ae9a395b7e55e98af9c621574dc/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=cf5d28083dc25ae9a395b7e55e98af9c621574dc", "patch": "@@ -15,6 +15,7 @@ use std::rt::stack;\n use std::raw;\n #[cfg(target_arch = \"x86_64\")]\n use std::simd;\n+use libc;\n \n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n@@ -69,7 +70,7 @@ impl Context {\n         // overflow). Additionally, their coroutine stacks are listed as being\n         // zero-length, so that's how we detect what's what here.\n         let stack_base: *const uint = stack.start();\n-        let bounds = if sp as uint == stack_base as uint {\n+        let bounds = if sp as libc::uintptr_t == stack_base as libc::uintptr_t {\n             None\n         } else {\n             Some((stack_base as uint, sp as uint))\n@@ -165,16 +166,16 @@ fn new_regs() -> Box<Registers> {\n \n #[cfg(target_arch = \"x86\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n-                         procedure: raw::Procedure, sp: *mut uint) {\n+                         procedure: raw::Procedure, sp: *mut libc::uintptr_t) {\n \n     // x86 has interesting stack alignment requirements, so do some alignment\n     // plus some offsetting to figure out what the actual stack should be.\n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -4);\n \n-    unsafe { *mut_offset(sp, 2) = procedure.env as uint };\n-    unsafe { *mut_offset(sp, 1) = procedure.code as uint };\n-    unsafe { *mut_offset(sp, 0) = arg as uint };\n+    unsafe { *mut_offset(sp, 2) = procedure.env as libc::uintptr_t };\n+    unsafe { *mut_offset(sp, 1) = procedure.code as libc::uintptr_t };\n+    unsafe { *mut_offset(sp, 0) = arg as libc::uintptr_t };\n     let sp = mut_offset(sp, -1);\n     unsafe { *sp = 0 }; // The final return address\n \n@@ -188,13 +189,15 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n // windows requires saving more registers (both general and XMM), so the windows\n // register context must be larger.\n #[cfg(windows, target_arch = \"x86_64\")]\n+#[repr(C)]\n struct Registers {\n-    gpr:[uint, ..14],\n+    gpr:[libc::uintptr_t, ..14],\n     _xmm:[simd::u32x4, ..10]\n }\n #[cfg(not(windows), target_arch = \"x86_64\")]\n+#[repr(C)]\n struct Registers {\n-    gpr:[uint, ..10],\n+    gpr:[libc::uintptr_t, ..10],\n     _xmm:[simd::u32x4, ..6]\n }\n \n@@ -234,30 +237,30 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n     unsafe { *sp = 0; }\n \n     rtdebug!(\"creating call frame\");\n-    rtdebug!(\"fptr {:#x}\", fptr as uint);\n+    rtdebug!(\"fptr {:#x}\", fptr as libc::uintptr_t);\n     rtdebug!(\"arg {:#x}\", arg);\n     rtdebug!(\"sp {}\", sp);\n \n     // These registers are frobbed by rust_bootstrap_green_task into the right\n     // location so we can invoke the \"real init function\", `fptr`.\n-    regs.gpr[RUSTRT_R12] = arg as uint;\n-    regs.gpr[RUSTRT_R13] = procedure.code as uint;\n-    regs.gpr[RUSTRT_R14] = procedure.env as uint;\n-    regs.gpr[RUSTRT_R15] = fptr as uint;\n+    regs.gpr[RUSTRT_R12] = arg as libc::uintptr_t;\n+    regs.gpr[RUSTRT_R13] = procedure.code as libc::uintptr_t;\n+    regs.gpr[RUSTRT_R14] = procedure.env as libc::uintptr_t;\n+    regs.gpr[RUSTRT_R15] = fptr as libc::uintptr_t;\n \n     // These registers are picked up by the regular context switch paths. These\n     // will put us in \"mostly the right context\" except for frobbing all the\n     // arguments to the right place. We have the small trampoline code inside of\n     // rust_bootstrap_green_task to do that.\n-    regs.gpr[RUSTRT_RSP] = sp as uint;\n-    regs.gpr[RUSTRT_IP] = rust_bootstrap_green_task as uint;\n+    regs.gpr[RUSTRT_RSP] = sp as libc::uintptr_t;\n+    regs.gpr[RUSTRT_IP] = rust_bootstrap_green_task as libc::uintptr_t;\n \n     // Last base pointer on the stack should be 0\n     regs.gpr[RUSTRT_RBP] = 0;\n }\n \n #[cfg(target_arch = \"arm\")]\n-type Registers = [uint, ..32];\n+type Registers = [libc::uintptr_t, ..32];\n \n #[cfg(target_arch = \"arm\")]\n fn new_regs() -> Box<Registers> { box {[0, .. 32]} }\n@@ -277,17 +280,17 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n     // ARM uses the same technique as x86_64 to have a landing pad for the start\n     // of all new green tasks. Neither r1/r2 are saved on a context switch, so\n     // the shim will copy r3/r4 into r1/r2 and then execute the function in r5\n-    regs[0] = arg as uint;              // r0\n-    regs[3] = procedure.code as uint;   // r3\n-    regs[4] = procedure.env as uint;    // r4\n-    regs[5] = fptr as uint;             // r5\n-    regs[13] = sp as uint;                          // #52 sp, r13\n-    regs[14] = rust_bootstrap_green_task as uint;   // #56 pc, r14 --> lr\n+    regs[0] = arg as libc::uintptr_t;              // r0\n+    regs[3] = procedure.code as libc::uintptr_t;   // r3\n+    regs[4] = procedure.env as libc::uintptr_t;    // r4\n+    regs[5] = fptr as libc::uintptr_t;             // r5\n+    regs[13] = sp as libc::uintptr_t;                          // #52 sp, r13\n+    regs[14] = rust_bootstrap_green_task as libc::uintptr_t;   // #56 pc, r14 --> lr\n }\n \n #[cfg(target_arch = \"mips\")]\n #[cfg(target_arch = \"mipsel\")]\n-type Registers = [uint, ..32];\n+type Registers = [libc::uintptr_t, ..32];\n \n #[cfg(target_arch = \"mips\")]\n #[cfg(target_arch = \"mipsel\")]\n@@ -304,16 +307,16 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n     // The final return address. 0 indicates the bottom of the stack\n     unsafe { *sp = 0; }\n \n-    regs[4] = arg as uint;\n-    regs[5] = procedure.code as uint;\n-    regs[6] = procedure.env as uint;\n-    regs[29] = sp as uint;\n-    regs[25] = fptr as uint;\n-    regs[31] = fptr as uint;\n+    regs[4] = arg as libc::uintptr_t;\n+    regs[5] = procedure.code as libc::uintptr_t;\n+    regs[6] = procedure.env as libc::uintptr_t;\n+    regs[29] = sp as libc::uintptr_t;\n+    regs[25] = fptr as libc::uintptr_t;\n+    regs[31] = fptr as libc::uintptr_t;\n }\n \n fn align_down(sp: *mut uint) -> *mut uint {\n-    let sp = (sp as uint) & !(16 - 1);\n+    let sp = (sp as libc::uintptr_t) & !(16 - 1);\n     sp as *mut uint\n }\n "}, {"sha": "eea5105de8c728463acc7862ee7bc895647bae3d", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf5d28083dc25ae9a395b7e55e98af9c621574dc/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5d28083dc25ae9a395b7e55e98af9c621574dc/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=cf5d28083dc25ae9a395b7e55e98af9c621574dc", "patch": "@@ -68,7 +68,7 @@ impl Stack {\n \n         // FIXME: Using the FFI to call a C macro. Slow\n         stk.valgrind_id = unsafe {\n-            rust_valgrind_stack_register(stk.start(), stk.end())\n+            rust_valgrind_stack_register(stk.start() as *const libc::uintptr_t, stk.end() as *const libc::uintptr_t)\n         };\n         return stk;\n     }"}, {"sha": "fa7da1de914b4489a380faac44e0e6c08386221c", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf5d28083dc25ae9a395b7e55e98af9c621574dc/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf5d28083dc25ae9a395b7e55e98af9c621574dc/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=cf5d28083dc25ae9a395b7e55e98af9c621574dc", "patch": "@@ -107,13 +107,14 @@ mod select {\n #[cfg(target_os = \"linux\")]\n mod select {\n     use std::uint;\n+    use libc;\n \n     pub static FD_SETSIZE: uint = 1024;\n \n     #[repr(C)]\n     pub struct fd_set {\n         // FIXME: shouldn't this be a c_ulong?\n-        fds_bits: [uint, ..(FD_SETSIZE / uint::BITS)]\n+        fds_bits: [libc::uintptr_t, ..(FD_SETSIZE / uint::BITS)]\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {"}]}