{"sha": "6bbb7fd26532682051f8d74db954ac1a8650b22c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYmI3ZmQyNjUzMjY4MjA1MWY4ZDc0ZGI5NTRhYzFhODY1MGIyMmM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-10-29T10:42:30Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-10-29T10:43:21Z"}, "message": "Change a bit how the first doc comment lines are handled", "tree": {"sha": "ba204b3e7846ffe734ac1bcdf29067cc1c82dce1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba204b3e7846ffe734ac1bcdf29067cc1c82dce1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bbb7fd26532682051f8d74db954ac1a8650b22c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bbb7fd26532682051f8d74db954ac1a8650b22c", "html_url": "https://github.com/rust-lang/rust/commit/6bbb7fd26532682051f8d74db954ac1a8650b22c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bbb7fd26532682051f8d74db954ac1a8650b22c/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4c35368f41c36484cfa7679acb53d40ffbcce35", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c35368f41c36484cfa7679acb53d40ffbcce35", "html_url": "https://github.com/rust-lang/rust/commit/b4c35368f41c36484cfa7679acb53d40ffbcce35"}], "stats": {"total": 71, "additions": 33, "deletions": 38}, "files": [{"sha": "4f7297c90c5c98faee5caad6472a27afb158707b", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6bbb7fd26532682051f8d74db954ac1a8650b22c/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bbb7fd26532682051f8d74db954ac1a8650b22c/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=6bbb7fd26532682051f8d74db954ac1a8650b22c", "patch": "@@ -34,9 +34,18 @@ impl clean::Attributes {\n }\n \n fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n-    let mut saw_first_line = false;\n-    let mut saw_second_line = false;\n-\n+    // `add` is used in case the most common sugared doc syntax is used (\"/// \"). The other\n+    // fragments kind's lines are never starting with a whitespace unless they are using some\n+    // markdown formatting requiring it. Therefore, if the doc block have a mix between the two,\n+    // we need to take into account the fact that the minimum indent minus one (to take this\n+    // whitespace into account).\n+    //\n+    // For example:\n+    //\n+    // /// hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In this case, you want \"hello! another\" and not \"hello!  another\".\n     let add = if !docs.windows(2).all(|arr| arr[0].kind == arr[1].kind)\n         && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n     {\n@@ -47,27 +56,22 @@ fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n         0\n     };\n \n+    // `min_indent` is used to know how much whitespaces from the start of each lines must be\n+    // removed. Example:\n+    //\n+    // ///     hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In here, the `min_indent` is 1 (because non-sugared fragment are always counted with minimum\n+    // 1 whitespace), meaning that \"hello!\" will be considered a codeblock because it starts with 4\n+    // (5 - 1) whitespaces.\n     let min_indent = match docs\n         .iter()\n         .map(|fragment| {\n             fragment.doc.lines().fold(usize::MAX, |min_indent, line| {\n-                // After we see the first non-whitespace line, look at\n-                // the line we have. If it is not whitespace, and therefore\n-                // part of the first paragraph, then ignore the indentation\n-                // level of the first line\n-                let ignore_previous_indents =\n-                    saw_first_line && !saw_second_line && !line.chars().all(|c| c.is_whitespace());\n-\n-                let min_indent = if ignore_previous_indents { usize::MAX } else { min_indent };\n-\n-                if saw_first_line {\n-                    saw_second_line = true;\n-                }\n-\n                 if line.chars().all(|c| c.is_whitespace()) {\n                     min_indent\n                 } else {\n-                    saw_first_line = true;\n                     // Compare against either space or tab, ignoring whether they are\n                     // mixed or not.\n                     let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n@@ -82,7 +86,6 @@ fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n         None => return,\n     };\n \n-    let mut first_ignored = false;\n     for fragment in docs {\n         let lines: Vec<_> = fragment.doc.lines().collect();\n \n@@ -93,26 +96,18 @@ fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n                 min_indent\n             };\n \n-            let mut iter = lines.iter();\n-            let mut result = if !first_ignored {\n-                first_ignored = true;\n-                vec![iter.next().unwrap().trim_start().to_string()]\n-            } else {\n-                Vec::new()\n-            };\n-            result.extend_from_slice(\n-                &iter\n-                    .map(|&line| {\n-                        if line.chars().all(|c| c.is_whitespace()) {\n-                            line.to_string()\n-                        } else {\n-                            assert!(line.len() >= min_indent);\n-                            line[min_indent..].to_string()\n-                        }\n-                    })\n-                    .collect::<Vec<_>>(),\n-            );\n-            fragment.doc = result.join(\"\\n\");\n+            fragment.doc = lines\n+                .iter()\n+                .map(|&line| {\n+                    if line.chars().all(|c| c.is_whitespace()) {\n+                        line.to_string()\n+                    } else {\n+                        assert!(line.len() >= min_indent);\n+                        line[min_indent..].to_string()\n+                    }\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n         }\n     }\n }"}]}