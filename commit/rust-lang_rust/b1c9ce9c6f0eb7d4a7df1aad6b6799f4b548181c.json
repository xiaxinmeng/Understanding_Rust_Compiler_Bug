{"sha": "b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYzljZTljNmYwZWI3ZDRhN2RmMWFhZDZiNjc5OWY0YjU0ODE4MWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-07T18:13:26Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-11T17:00:43Z"}, "message": "sync: Move underneath libstd\n\nThis commit is the final step in the libstd facade, #13851. The purpose of this\ncommit is to move libsync underneath the standard library, behind the facade.\nThis will allow core primitives like channels, queues, and atomics to all live\nin the same location.\n\nThere were a few notable changes and a few breaking changes as part of this\nmovement:\n\n* The `Vec` and `String` types are reexported at the top level of libcollections\n* The `unreachable!()` macro was copied to libcore\n* The `std::rt::thread` module was moved to librustrt, but it is still\n  reexported at the same location.\n* The `std::comm` module was moved to libsync\n* The `sync::comm` module was moved under `sync::comm`, and renamed to `duplex`.\n  It is now a private module with types/functions being reexported under\n  `sync::comm`. This is a breaking change for any existing users of duplex\n  streams.\n* All concurrent queues/deques were moved directly under libsync. They are also\n  all marked with #![experimental] for now if they are public.\n* The `task_pool` and `future` modules no longer live in libsync, but rather\n  live under `std::sync`. They will forever live at this location, but they may\n  move to libsync if the `std::task` module moves as well.\n\n[breaking-change]", "tree": {"sha": "219196013c141f0f2110ac1df21db05433a71e4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/219196013c141f0f2110ac1df21db05433a71e4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "html_url": "https://github.com/rust-lang/rust/commit/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c690191a84728c289a4b3dc17b07934a66311d9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c690191a84728c289a4b3dc17b07934a66311d9d", "html_url": "https://github.com/rust-lang/rust/commit/c690191a84728c289a4b3dc17b07934a66311d9d"}], "stats": {"total": 743, "additions": 382, "deletions": 361}, "files": [{"sha": "6c309f7c90a66a8ab21abffde1da720a085f0039", "filename": "mk/crates.mk", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -61,16 +61,16 @@ DEPS_rlibc :=\n DEPS_alloc := core libc native:jemalloc\n DEPS_debug := std\n DEPS_rustrt := alloc core libc collections native:rustrt_native\n-DEPS_std := core libc rand alloc collections rustrt \\\n+DEPS_std := core libc rand alloc collections rustrt sync \\\n \tnative:rust_builtin native:backtrace\n DEPS_graphviz := std\n DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n DEPS_syntax := std term serialize log fmt_macros debug\n-DEPS_rustc := syntax native:rustllvm flate arena serialize sync getopts \\\n+DEPS_rustc := syntax native:rustllvm flate arena serialize getopts \\\n               time log graphviz debug\n-DEPS_rustdoc := rustc native:hoedown serialize sync getopts \\\n+DEPS_rustdoc := rustc native:hoedown serialize getopts \\\n                 test time debug\n DEPS_flate := std native:miniz\n DEPS_arena := std\n@@ -80,17 +80,17 @@ DEPS_serialize := std log\n DEPS_term := std log\n DEPS_semver := std\n DEPS_uuid := std serialize\n-DEPS_sync := std alloc\n+DEPS_sync := core alloc rustrt collections\n DEPS_getopts := std\n DEPS_collections := core alloc\n DEPS_fourcc := rustc syntax std\n DEPS_hexfloat := rustc syntax std\n DEPS_num := std\n DEPS_test := std getopts serialize term time regex native:rust_test_helpers\n-DEPS_time := std serialize sync\n+DEPS_time := std serialize\n DEPS_rand := core\n DEPS_url := std\n-DEPS_log := std sync\n+DEPS_log := std\n DEPS_regex := std\n DEPS_regex_macros = rustc syntax std regex\n DEPS_fmt_macros = std"}, {"sha": "81d7f37d6fbcc45c796900d41a45e51ad894c1f9", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -269,7 +269,7 @@ later.\n The basic example below illustrates this.\n \n ~~~\n-extern crate sync;\n+use std::sync::Future;\n \n # fn main() {\n # fn make_a_sandwich() {};\n@@ -278,7 +278,7 @@ fn fib(n: u64) -> u64 {\n     12586269025\n }\n \n-let mut delayed_fib = sync::Future::spawn(proc() fib(50));\n+let mut delayed_fib = Future::spawn(proc() fib(50));\n make_a_sandwich();\n println!(\"fib(50) = {}\", delayed_fib.get())\n # }\n@@ -294,7 +294,7 @@ Here is another example showing how futures allow you to background computations\n be distributed on the available cores.\n \n ~~~\n-# extern crate sync;\n+# use std::sync::Future;\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n     for num in range(start*100000, (start+1)*100000) {\n@@ -304,7 +304,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = Vec::from_fn(1000, |ind| sync::Future::spawn( proc() { partial_sum(ind) }));\n+    let mut futures = Vec::from_fn(1000, |ind| Future::spawn( proc() { partial_sum(ind) }));\n \n     let mut final_res = 0f64;\n     for ft in futures.mut_iter()  {\n@@ -329,10 +329,8 @@ Here is a small example showing how to use Arcs. We wish to run concurrently sev\n a single large vector of floats. Each task needs the full vector to perform its duty.\n \n ~~~\n-extern crate sync;\n-\n-use sync::Arc;\n use std::rand;\n+use std::sync::Arc;\n \n fn pnorm(nums: &[f64], p: uint) -> f64 {\n     nums.iter().fold(0.0, |a, b| a + b.powf(p as f64)).powf(1.0 / (p as f64))\n@@ -357,9 +355,8 @@ at the power given as argument and takes the inverse power of this value). The A\n created by the line\n \n ~~~\n-# extern crate sync;\n # use std::rand;\n-# use sync::Arc;\n+# use std::sync::Arc;\n # fn main() {\n # let numbers = Vec::from_fn(1000000, |_| rand::random::<f64>());\n let numbers_arc=Arc::new(numbers);\n@@ -371,9 +368,8 @@ it's contents. Within the task's procedure, the captured Arc reference can be us\n reference to the underlying vector as if it were local.\n \n ~~~\n-# extern crate sync;\n # use std::rand;\n-# use sync::Arc;\n+# use std::sync::Arc;\n # fn pnorm(nums: &[f64], p: uint) -> f64 { 4.0 }\n # fn main() {\n # let numbers=Vec::from_fn(1000000, |_| rand::random::<f64>());\n@@ -461,9 +457,9 @@ the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:\n \n ~~~\n-extern crate sync;\n+use std::comm::DuplexStream;\n # fn main() {\n-fn stringifier(channel: &sync::DuplexStream<String, uint>) {\n+fn stringifier(channel: &DuplexStream<String, uint>) {\n     let mut value: uint;\n     loop {\n         value = channel.recv();\n@@ -485,10 +481,10 @@ response itself is simply the stringified version of the received value,\n Here is the code for the parent task:\n \n ~~~\n-extern crate sync;\n+use std::comm::duplex;\n # use std::task::spawn;\n-# use sync::DuplexStream;\n-# fn stringifier(channel: &sync::DuplexStream<String, uint>) {\n+# use std::comm::DuplexStream;\n+# fn stringifier(channel: &DuplexStream<String, uint>) {\n #     let mut value: uint;\n #     loop {\n #         value = channel.recv();\n@@ -498,7 +494,7 @@ extern crate sync;\n # }\n # fn main() {\n \n-let (from_child, to_child) = sync::duplex();\n+let (from_child, to_child) = duplex();\n \n spawn(proc() {\n     stringifier(&to_child);"}, {"sha": "886528e867216b6bfb66d5872eab576ab3009107", "filename": "src/doc/intro.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -297,8 +297,7 @@ an atomically reference counted box (\"A.R.C.\" == \"atomically reference counted\")\n Here's some code:\n \n ```\n-extern crate sync;\n-use sync::Arc;\n+use std::sync::Arc;\n \n fn main() {\n     let numbers = vec![1,2,3];\n@@ -344,8 +343,7 @@ Let's take the same example yet again,\n and modify it to mutate the shared state:\n \n ```\n-extern crate sync;\n-use sync::{Arc, Mutex};\n+use std::sync::{Arc, Mutex};\n \n fn main() {\n     let numbers = vec![1,2,3];"}, {"sha": "a79a46c41eaec773a075ff53d47e8c12cd4e7ece", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -38,9 +38,9 @@\n     \"rt/isaac/randport.cpp\", # public domain\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n-    \"libstd/sync/mpsc_queue.rs\", # BSD\n-    \"libstd/sync/spsc_queue.rs\", # BSD\n-    \"libstd/sync/mpmc_bounded_queue.rs\", # BSD\n+    \"libsync/mpsc_queue.rs\", # BSD\n+    \"libsync/spsc_queue.rs\", # BSD\n+    \"libsync/mpmc_bounded_queue.rs\", # BSD\n     \"libsync/mpsc_intrusive.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD\n     \"test/bench/shootout-meteor.rs\", # BSD"}, {"sha": "94bf3368a0aaf2273d6b184fd27d59bc92a7db87", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -33,9 +33,7 @@ use heap::deallocate;\n /// task.\n ///\n /// ```rust\n-/// extern crate sync;\n-///\n-/// use sync::Arc;\n+/// use std::sync::Arc;\n ///\n /// fn main() {\n ///     let numbers = Vec::from_fn(100, |i| i as f32);\n@@ -276,7 +274,7 @@ mod tests {\n     use std::task;\n     use std::vec::Vec;\n     use super::{Arc, Weak};\n-    use sync::Mutex;\n+    use std::sync::Mutex;\n \n     struct Canary(*mut atomics::AtomicUint);\n "}, {"sha": "fe9fe57bdbd17ea4403c925206ef2c1dbd1640b1", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -84,7 +84,6 @@ extern crate libc;\n // Allow testing this library\n \n #[cfg(test)] extern crate debug;\n-#[cfg(test)] extern crate sync;\n #[cfg(test)] extern crate native;\n #[cfg(test, stage0)] #[phase(syntax, link)] extern crate std;\n #[cfg(test, stage0)] #[phase(syntax, link)] extern crate log;"}, {"sha": "185ca6e361b3aca3671a980e843480bf13b91cfc", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -52,8 +52,10 @@ pub use enum_set::EnumSet;\n pub use priority_queue::PriorityQueue;\n pub use ringbuf::RingBuf;\n pub use smallintmap::SmallIntMap;\n+pub use string::String;\n pub use treemap::{TreeMap, TreeSet};\n pub use trie::{TrieMap, TrieSet};\n+pub use vec::Vec;\n \n mod macros;\n "}, {"sha": "65ba11f89adc61f8501541d0480a34b2eca200fb", "filename": "src/libcore/atomics.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibcore%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibcore%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomics.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -121,16 +121,14 @@ impl AtomicBool {\n     ///\n     /// # Examples\n     ///\n-    /// ```ignore\n-    /// # // FIXME: Needs PR #12430\n-    /// extern crate sync;\n-    ///\n-    /// use sync::Arc;\n+    /// ```rust\n+    /// use std::sync::Arc;\n     /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    /// use std::task::deschedule;\n     ///\n     /// fn main() {\n     ///     let spinlock = Arc::new(AtomicBool::new(false));\n-    ///     let spinlock_clone = spin_lock.clone();\n+    ///     let spinlock_clone = spinlock.clone();\n     ///\n     ///     spawn(proc() {\n     ///         with_lock(&spinlock, || println!(\"task 1 in lock\"));\n@@ -155,7 +153,7 @@ impl AtomicBool {\n     ///     f();\n     ///\n     ///     // Release the lock\n-    ///     spinlock.store(false);\n+    ///     spinlock.store(false, SeqCst);\n     /// }\n     /// ```\n     #[inline]"}, {"sha": "a62bc10d8abc654c7b6d49ee597b8dd45f64edab", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -131,3 +131,6 @@ macro_rules! write(\n         format_args_method!($dst, write_fmt, $($arg)*)\n     })\n )\n+\n+#[macro_export]\n+macro_rules! unreachable( () => (fail!(\"unreachable code\")) )"}, {"sha": "19f55c59491d814fc52658408063ee3c2cd7df24", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -117,17 +117,14 @@ if logging is disabled, none of the components of the log will be executed.\n #![feature(macro_rules)]\n #![deny(missing_doc, deprecated_owned_vector)]\n \n-extern crate sync;\n-\n use std::fmt;\n use std::io::LineBufferedWriter;\n use std::io;\n use std::mem;\n use std::os;\n use std::rt;\n use std::slice;\n-\n-use sync::one::{Once, ONCE_INIT};\n+use std::sync::{Once, ONCE_INIT};\n \n use directive::LOG_LEVEL_NAMES;\n "}, {"sha": "55998f254ed4a41c15867a45fea261e2bdd92c1c", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -386,7 +386,7 @@ pub mod write {\n     }\n \n     unsafe fn configure_llvm(sess: &Session) {\n-        use sync::one::{Once, ONCE_INIT};\n+        use std::sync::{Once, ONCE_INIT};\n         static mut INIT: Once = ONCE_INIT;\n \n         // Copy what clang does by turning on loop vectorization at O2 and"}, {"sha": "297d55edec8407430a9856675c82c9f60c5f7964", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -38,7 +38,6 @@ extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n extern crate serialize;\n-extern crate sync;\n extern crate syntax;\n extern crate time;\n "}, {"sha": "638390038f380865ec081b550b3e23eb5abd3d18", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -2296,7 +2296,7 @@ pub fn trans_crate(krate: ast::Crate,\n \n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n-        use sync::one::{Once, ONCE_INIT};\n+        use std::sync::{Once, ONCE_INIT};\n         static mut INIT: Once = ONCE_INIT;\n         static mut POISONED: bool = false;\n         INIT.doit(|| {"}, {"sha": "872c957dbb3924efe982ffe0d2af0fc931a34120", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -39,8 +39,8 @@ use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n use std::io;\n use std::str;\n use std::string::String;\n+use std::sync::Arc;\n \n-use sync::Arc;\n use serialize::json::ToJson;\n use syntax::ast;\n use syntax::ast_util;"}, {"sha": "05755f4bf6c8ed850ca0d793dae7649b74127d0f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -21,7 +21,6 @@ extern crate getopts;\n extern crate libc;\n extern crate rustc;\n extern crate serialize;\n-extern crate sync;\n extern crate syntax;\n extern crate testing = \"test\";\n extern crate time;"}, {"sha": "76cbeef443eaefa4be1194fb1599dbc90c6e31c0", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -15,7 +15,8 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")]\n-#![feature(macro_rules, phase, globs, thread_local, managed_boxes, asm)]\n+#![feature(macro_rules, phase, globs, thread_local, managed_boxes, asm,\n+           linkage)]\n #![no_std]\n #![experimental]\n \n@@ -58,6 +59,7 @@ mod libunwind;\n \n pub mod args;\n pub mod bookkeeping;\n+pub mod c_str;\n pub mod exclusive;\n pub mod local;\n pub mod local_data;\n@@ -66,8 +68,8 @@ pub mod mutex;\n pub mod rtio;\n pub mod stack;\n pub mod task;\n+pub mod thread;\n pub mod unwind;\n-pub mod c_str;\n \n /// The interface to the current runtime.\n ///"}, {"sha": "4ef2cec19db9b01d21618d12d2947d2e06b7453e", "filename": "src/librustrt/thread.rs", "status": "renamed", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -15,15 +15,15 @@\n //! which are not used for scheduling in any way.\n \n #![allow(non_camel_case_types)]\n-#![allow(unsigned_negate)]\n \n-use kinds::Send;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::mem;\n+use core::uint;\n use libc;\n-use mem;\n-use ops::Drop;\n-use option::{Option, Some, None};\n-use owned::Box;\n-use uint;\n+\n+use stack;\n \n type StartFn = extern \"C\" fn(*libc::c_void) -> imp::rust_thread_return;\n \n@@ -43,7 +43,6 @@ static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n // and invoke it.\n #[no_split_stack]\n extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {\n-    use rt::stack;\n     unsafe {\n         stack::record_stack_bounds(0, uint::MAX);\n         let f: Box<proc()> = mem::transmute(main);\n@@ -146,16 +145,16 @@ impl<T: Send> Drop for Thread<T> {\n \n #[cfg(windows)]\n mod imp {\n-    use mem;\n-    use cmp;\n-    use kinds::Send;\n+    use core::prelude::*;\n+\n+    use alloc::owned::Box;\n+    use core::cmp;\n+    use core::mem;\n+    use core::ptr;\n     use libc;\n     use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n                                        LPVOID, DWORD, LPDWORD, HANDLE};\n-    use os;\n-    use owned::Box;\n-    use ptr;\n-    use rt::stack::RED_ZONE;\n+    use stack::RED_ZONE;\n \n     pub type rust_thread = HANDLE;\n     pub type rust_thread_return = DWORD;\n@@ -178,7 +177,7 @@ mod imp {\n         if ret as uint == 0 {\n             // be sure to not leak the closure\n             let _p: Box<proc():Send> = mem::transmute(arg);\n-            fail!(\"failed to spawn native thread: {}\", os::last_os_error());\n+            fail!(\"failed to spawn native thread: {}\", ret);\n         }\n         return ret;\n     }\n@@ -214,15 +213,16 @@ mod imp {\n \n #[cfg(unix)]\n mod imp {\n-    use cmp;\n-    use kinds::Send;\n+    use core::prelude::*;\n+\n+    use alloc::owned::Box;\n+    use core::cmp;\n+    use core::mem;\n+    use core::ptr;\n     use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n     use libc;\n-    use mem;\n-    use os;\n-    use owned::Box;\n-    use ptr;\n-    use rt::stack::RED_ZONE;\n+\n+    use stack::RED_ZONE;\n \n     pub type rust_thread = libc::pthread_t;\n     pub type rust_thread_return = *u8;\n@@ -243,14 +243,15 @@ mod imp {\n                 // EINVAL means |stack_size| is either too small or not a\n                 // multiple of the system page size.  Because it's definitely\n                 // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-                // Round up to the nearest page and try again.\n-                let page_size = os::page_size();\n-                let stack_size = (stack_size + page_size - 1) & (-(page_size - 1) - 1);\n+                // Round up to the neareast page and try again.\n+                let page_size = libc::sysconf(libc::_SC_PAGESIZE) as uint;\n+                let stack_size = (stack_size + page_size - 1) &\n+                                 (-(page_size as int - 1) as uint - 1);\n                 assert_eq!(pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t), 0);\n             },\n             errno => {\n                 // This cannot really happen.\n-                fail!(\"pthread_attr_setstacksize() error: {} ({})\", os::last_os_error(), errno);\n+                fail!(\"pthread_attr_setstacksize() error: {}\", errno);\n             },\n         };\n \n@@ -261,7 +262,7 @@ mod imp {\n         if ret != 0 {\n             // be sure to not leak the closure\n             let _p: Box<proc():Send> = mem::transmute(arg);\n-            fail!(\"failed to spawn native thread: {}\", os::last_os_error());\n+            fail!(\"failed to spawn native thread: {}\", ret);\n         }\n         native\n     }\n@@ -288,7 +289,6 @@ mod imp {\n     // is non-null before calling it!\n     #[cfg(target_os = \"linux\")]\n     fn min_stack_size(attr: *libc::pthread_attr_t) -> libc::size_t {\n-        use ptr::RawPtr;\n         type F = unsafe extern \"C\" fn(*libc::pthread_attr_t) -> libc::size_t;\n         extern {\n             #[linkage = \"extern_weak\"]", "previous_filename": "src/libstd/rt/thread.rs"}, {"sha": "523c94649879c7c59bc0bfcfccb009a4ec7c3a4f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -126,6 +126,7 @@ extern crate alloc;\n extern crate core;\n extern crate core_collections = \"collections\";\n extern crate core_rand = \"rand\";\n+extern crate core_sync = \"sync\";\n extern crate libc;\n extern crate rustrt;\n \n@@ -172,6 +173,8 @@ pub use core_collections::vec;\n pub use rustrt::c_str;\n pub use rustrt::local_data;\n \n+pub use core_sync::comm;\n+\n // Run tests with libgreen instead of libnative.\n //\n // FIXME: This egregiously hacks around starting the test runner in a different\n@@ -234,10 +237,8 @@ pub mod collections;\n /* Tasks and communication */\n \n pub mod task;\n-pub mod comm;\n pub mod sync;\n \n-\n /* Runtime and platform support */\n \n pub mod c_vec;"}, {"sha": "66e7059422b36f69cb786ceb33a5518e44cfd2eb", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -63,13 +63,10 @@ pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n // Reexport functionality from librustrt and other crates underneath the\n // standard library which work together to create the entire runtime.\n pub use alloc::{heap, libc_heap};\n-pub use rustrt::{task, local, mutex, exclusive, stack, args, rtio};\n+pub use rustrt::{task, local, mutex, exclusive, stack, args, rtio, thread};\n pub use rustrt::{Stdio, Stdout, Stderr, begin_unwind, begin_unwind_fmt};\n pub use rustrt::{bookkeeping, at_exit, unwind, DEFAULT_ERROR_CODE, Runtime};\n \n-// Bindings to system threading libraries.\n-pub mod thread;\n-\n // Simple backtrace functionality (to print on failure)\n pub mod backtrace;\n "}, {"sha": "bc748324fcd2b3ebffb40ab94a516aa4668d2a36", "filename": "src/libstd/sync/future.rs", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -15,7 +15,7 @@\n  * # Example\n  *\n  * ```rust\n- * use sync::Future;\n+ * use std::sync::Future;\n  * # fn fib(n: uint) -> uint {42};\n  * # fn make_a_sandwich() {};\n  * let mut delayed_fib = Future::spawn(proc() { fib(5000) });\n@@ -26,7 +26,11 @@\n \n #![allow(missing_doc)]\n \n-use std::mem::replace;\n+use core::prelude::*;\n+use core::mem::replace;\n+\n+use comm::{Receiver, channel};\n+use task::spawn;\n \n /// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n@@ -137,9 +141,9 @@ impl<A:Send> Future<A> {\n \n #[cfg(test)]\n mod test {\n-    use future::Future;\n-\n-    use std::task;\n+    use prelude::*;\n+    use sync::Future;\n+    use task;\n \n     #[test]\n     fn test_from_value() {", "previous_filename": "src/libsync/future.rs"}, {"sha": "5f45ce25502231d710191657f90ff51c5a98858d", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -15,8 +15,14 @@\n //! and/or blocking at all, but rather provide the necessary tools to build\n //! other types of concurrent primitives.\n \n-pub mod atomics;\n-pub mod deque;\n-pub mod mpmc_bounded_queue;\n-pub mod mpsc_queue;\n-pub mod spsc_queue;\n+pub use core_sync::{atomics, deque, mpmc_bounded_queue, mpsc_queue, spsc_queue};\n+pub use core_sync::{Arc, Weak, Mutex, MutexGuard, Condvar, Barrier};\n+pub use core_sync::{RWLock, RWLockReadGuard, RWLockWriteGuard};\n+pub use core_sync::{Semaphore, SemaphoreGuard};\n+pub use core_sync::one::{Once, ONCE_INIT};\n+\n+pub use self::future::Future;\n+pub use self::task_pool::TaskPool;\n+\n+mod future;\n+mod task_pool;"}, {"sha": "7667badf0e7c7cff9f7271672fec8fb2f099172a", "filename": "src/libstd/sync/task_pool.rs", "status": "renamed", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -13,7 +13,12 @@\n /// A task pool abstraction. Useful for achieving predictable CPU\n /// parallelism.\n \n-use std::task;\n+use core::prelude::*;\n+\n+use task;\n+use task::spawn;\n+use vec::Vec;\n+use comm::{channel, Sender};\n \n enum Msg<T> {\n     Execute(proc(&T):Send),", "previous_filename": "src/libsync/task_pool.rs"}, {"sha": "7d9a18cfbdaa23961dfa4a03ee4123605f656906", "filename": "src/libsync/atomics.rs", "status": "renamed", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fatomics.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -40,9 +40,7 @@\n //! A simple spinlock:\n //!\n //! ```\n-//! extern crate sync;\n-//!\n-//! use sync::Arc;\n+//! use std::sync::Arc;\n //! use std::sync::atomics::{AtomicUint, SeqCst};\n //! use std::task::deschedule;\n //!\n@@ -68,9 +66,7 @@\n //! Transferring a heap object with `AtomicOption`:\n //!\n //! ```\n-//! extern crate sync;\n-//!\n-//! use sync::Arc;\n+//! use std::sync::Arc;\n //! use std::sync::atomics::{AtomicOption, SeqCst};\n //!\n //! fn main() {\n@@ -105,10 +101,10 @@\n //! }\n //! ```\n \n-use mem;\n-use ops::Drop;\n-use option::{Option,Some,None};\n-use owned::Box;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::mem;\n \n pub use core::atomics::{AtomicBool, AtomicInt, AtomicUint, AtomicPtr};\n pub use core::atomics::{Ordering, Relaxed, Release, Acquire, AcqRel, SeqCst};\n@@ -188,7 +184,7 @@ impl<T> Drop for AtomicOption<T> {\n \n #[cfg(test)]\n mod test {\n-    use option::*;\n+    use std::prelude::*;\n     use super::*;\n \n     #[test]", "previous_filename": "src/libstd/sync/atomics.rs"}, {"sha": "3840e55bb424de8751e13b3f3a4220cb71237b3a", "filename": "src/libsync/comm/duplex.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fduplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fduplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fduplex.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -16,7 +16,10 @@ Higher level communication abstractions.\n \n #![allow(missing_doc)]\n \n-use std::comm;\n+use core::prelude::*;\n+\n+use comm;\n+use comm::{Sender, Receiver, channel};\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<S, R> {\n@@ -53,11 +56,11 @@ impl<S:Send,R:Send> DuplexStream<S, R> {\n \n #[cfg(test)]\n mod test {\n+    use std::prelude::*;\n     use comm::{duplex};\n \n-\n     #[test]\n-    pub fn DuplexStream1() {\n+    pub fn duplex_stream_1() {\n         let (left, right) = duplex();\n \n         left.send(\"abc\".to_string());", "previous_filename": "src/libsync/comm.rs"}, {"sha": "a7523eff04fec2a3d9cd13f1d9cf077c329d607a", "filename": "src/libsync/comm/mod.rs", "status": "renamed", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -271,36 +271,32 @@\n // And now that you've seen all the races that I found and attempted to fix,\n // here's the code for you to find some more!\n \n-use alloc::arc::Arc;\n+use core::prelude::*;\n \n-use cell::Cell;\n-use clone::Clone;\n-use iter::Iterator;\n-use kinds::Send;\n-use kinds::marker;\n-use mem;\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use owned::Box;\n-use result::{Ok, Err, Result};\n-use rt::local::Local;\n-use rt::task::{Task, BlockedTask};\n-use ty::Unsafe;\n+use alloc::arc::Arc;\n+use alloc::owned::Box;\n+use core::cell::Cell;\n+use core::kinds::marker;\n+use core::mem;\n+use core::ty::Unsafe;\n+use rustrt::local::Local;\n+use rustrt::task::{Task, BlockedTask};\n \n pub use comm::select::{Select, Handle};\n+pub use comm::duplex::{DuplexStream, duplex};\n \n macro_rules! test (\n     { fn $name:ident() $b:block $(#[$a:meta])*} => (\n         mod $name {\n             #![allow(unused_imports)]\n \n+            use std::prelude::*;\n+\n             use native;\n             use comm::*;\n-            use prelude::*;\n             use super::*;\n             use super::super::*;\n-            use owned::Box;\n-            use task;\n+            use std::task;\n \n             fn f() $b\n \n@@ -315,10 +311,11 @@ macro_rules! test (\n     )\n )\n \n-mod select;\n+mod duplex;\n mod oneshot;\n-mod stream;\n+mod select;\n mod shared;\n+mod stream;\n mod sync;\n \n // Use a power of 2 to allow LLVM to optimize to something that's not a\n@@ -984,10 +981,10 @@ impl<T: Send> Drop for Receiver<T> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use std::prelude::*;\n \n     use native;\n-    use os;\n+    use std::os;\n     use super::*;\n \n     pub fn stress_factor() -> uint {\n@@ -1480,7 +1477,7 @@ mod test {\n     })\n \n     test!(fn sends_off_the_runtime() {\n-        use rt::thread::Thread;\n+        use std::rt::thread::Thread;\n \n         let (tx, rx) = channel();\n         let t = Thread::start(proc() {\n@@ -1495,7 +1492,7 @@ mod test {\n     })\n \n     test!(fn try_recvs_off_the_runtime() {\n-        use rt::thread::Thread;\n+        use std::rt::thread::Thread;\n \n         let (tx, rx) = channel();\n         let (cdone, pdone) = channel();\n@@ -1520,8 +1517,8 @@ mod test {\n \n #[cfg(test)]\n mod sync_tests {\n-    use prelude::*;\n-    use os;\n+    use std::prelude::*;\n+    use std::os;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {", "previous_filename": "src/libstd/comm/mod.rs"}, {"sha": "bf2d9aa52fd24bd9bfd9a8f1272c94a569746e5a", "filename": "src/libsync/comm/oneshot.rs", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Foneshot.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -32,16 +32,15 @@\n /// The one caveat to consider is that when a port sees a disconnected channel\n /// it must check for data because there is no \"data plus upgrade\" state.\n \n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::mem;\n+use rustrt::local::Local;\n+use rustrt::task::{Task, BlockedTask};\n+\n+use atomics;\n use comm::Receiver;\n-use kinds::Send;\n-use mem;\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use owned::Box;\n-use result::{Result, Ok, Err};\n-use rt::local::Local;\n-use rt::task::{Task, BlockedTask};\n-use sync::atomics;\n \n // Various states you can find a port in.\n static EMPTY: uint = 0;", "previous_filename": "src/libstd/comm/oneshot.rs"}, {"sha": "0cb230644df917beaad87b46a55bdeea50c632aa", "filename": "src/libsync/comm/select.rs", "status": "renamed", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fselect.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -45,20 +45,17 @@\n \n #![allow(dead_code)]\n \n-use cell::Cell;\n-use iter::Iterator;\n-use kinds::Send;\n-use kinds::marker;\n-use mem;\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use owned::Box;\n-use ptr::RawPtr;\n-use result::{Ok, Err, Result};\n-use rt::local::Local;\n-use rt::task::{Task, BlockedTask};\n-use super::Receiver;\n-use uint;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::cell::Cell;\n+use core::kinds::marker;\n+use core::mem;\n+use core::uint;\n+use rustrt::local::Local;\n+use rustrt::task::{Task, BlockedTask};\n+\n+use comm::Receiver;\n \n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n@@ -321,8 +318,27 @@ impl Iterator<*mut Handle<'static, ()>> for Packets {\n #[cfg(test)]\n #[allow(unused_imports)]\n mod test {\n+    use std::prelude::*;\n+\n     use super::super::*;\n-    use prelude::*;\n+\n+    // Don't use the libstd version so we can pull in the right Select structure\n+    // (std::comm points at the wrong one)\n+    macro_rules! select {\n+        (\n+            $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n+        ) => ({\n+            use comm::Select;\n+            let sel = Select::new();\n+            $( let mut $rx = sel.handle(&$rx); )+\n+            unsafe {\n+                $( $rx.add(); )+\n+            }\n+            let ret = sel.wait();\n+            $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n+            { unreachable!() }\n+        })\n+    }\n \n     test!(fn smoke() {\n         let (tx1, rx1) = channel::<int>();", "previous_filename": "src/libstd/comm/select.rs"}, {"sha": "a50a6bbc8d31fcd6d4ee09c9db00347ff58f7294", "filename": "src/libsync/comm/shared.rs", "status": "renamed", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fshared.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -18,21 +18,18 @@\n /// module. You'll also note that the implementation of the shared and stream\n /// channels are quite similar, and this is no coincidence!\n \n-use cmp;\n-use int;\n-use iter::Iterator;\n-use kinds::Send;\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use owned::Box;\n-use result::{Ok, Err, Result};\n-use rt::local::Local;\n-use rt::mutex::NativeMutex;\n-use rt::task::{Task, BlockedTask};\n-use rt::thread::Thread;\n-use sync::atomics;\n-\n-use mpsc = sync::mpsc_queue;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::cmp;\n+use core::int;\n+use rustrt::local::Local;\n+use rustrt::mutex::NativeMutex;\n+use rustrt::task::{Task, BlockedTask};\n+use rustrt::thread::Thread;\n+\n+use atomics;\n+use mpsc = mpsc_queue;\n \n static DISCONNECTED: int = int::MIN;\n static FUDGE: int = 1024;", "previous_filename": "src/libstd/comm/shared.rs"}, {"sha": "6f337f1730950d3cfb9288d32e76c028fe4c1fa4", "filename": "src/libsync/comm/stream.rs", "status": "renamed", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fstream.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -17,20 +17,18 @@\n /// High level implementation details can be found in the comment of the parent\n /// module.\n \n-use cmp;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::cmp;\n+use core::int;\n+use rustrt::local::Local;\n+use rustrt::task::{Task, BlockedTask};\n+use rustrt::thread::Thread;\n+\n+use atomics;\n use comm::Receiver;\n-use int;\n-use iter::Iterator;\n-use kinds::Send;\n-use ops::Drop;\n-use option::{Some, None};\n-use owned::Box;\n-use result::{Ok, Err, Result};\n-use rt::local::Local;\n-use rt::task::{Task, BlockedTask};\n-use rt::thread::Thread;\n-use spsc = sync::spsc_queue;\n-use sync::atomics;\n+use spsc = spsc_queue;\n \n static DISCONNECTED: int = int::MIN;\n #[cfg(test)]", "previous_filename": "src/libstd/comm/stream.rs"}, {"sha": "4d54df2fc19e58e5544efc09fb9340895bdccd4f", "filename": "src/libsync/comm/sync.rs", "status": "renamed", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fsync.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -33,21 +33,18 @@\n /// of a synchronous channel. There are a few branches for the unbuffered case,\n /// but they're mostly just relevant to blocking senders.\n \n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use collections::Vec;\n use collections::Collection;\n-use iter::Iterator;\n-use kinds::Send;\n-use mem;\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use owned::Box;\n-use ptr::RawPtr;\n-use result::{Result, Ok, Err};\n-use rt::local::Local;\n-use rt::mutex::{NativeMutex, LockGuard};\n-use rt::task::{Task, BlockedTask};\n-use sync::atomics;\n-use ty::Unsafe;\n-use vec::Vec;\n+use core::mem;\n+use core::ty::Unsafe;\n+use rustrt::local::Local;\n+use rustrt::mutex::{NativeMutex, LockGuard};\n+use rustrt::task::{Task, BlockedTask};\n+\n+use atomics;\n \n pub struct Packet<T> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because", "previous_filename": "src/libstd/comm/sync.rs"}, {"sha": "36ccf2d51782be01dac7bd8ec5df4e7b5975bb23", "filename": "src/libsync/deque.rs", "status": "renamed", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -42,29 +42,26 @@\n //!     let mut stealer2 = stealer.clone();\n //!     stealer2.steal();\n \n+#![experimental]\n+\n // NB: the \"buffer pool\" strategy is not done for speed, but rather for\n //     correctness. For more info, see the comment on `swap_buffer`\n \n // FIXME: all atomic operations in this module use a SeqCst ordering. That is\n //      probably overkill\n \n+use core::prelude::*;\n+\n use alloc::arc::Arc;\n+use alloc::heap::{allocate, deallocate};\n+use alloc::owned::Box;\n+use collections::Vec;\n+use core::kinds::marker;\n+use core::mem::{forget, min_align_of, size_of, transmute};\n+use core::ptr;\n+use rustrt::exclusive::Exclusive;\n \n-use clone::Clone;\n-use iter::{range, Iterator};\n-use kinds::Send;\n-use kinds::marker;\n-use mem::{forget, min_align_of, size_of, transmute, overwrite};\n-use ops::Drop;\n-use option::{Option, Some, None};\n-use owned::Box;\n-use ptr::RawPtr;\n-use ptr;\n-use rt::heap::{allocate, deallocate};\n-use slice::ImmutableVector;\n-use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n-use rt::exclusive::Exclusive;\n-use vec::Vec;\n+use atomics::{AtomicInt, AtomicPtr, SeqCst};\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that\n // the deque requires that this number be less than 2.\n@@ -148,7 +145,7 @@ impl<T: Send> BufferPool<T> {\n     /// Allocates a new buffer pool which in turn can be used to allocate new\n     /// deques.\n     pub fn new() -> BufferPool<T> {\n-        BufferPool { pool: Arc::new(Exclusive::new(vec!())) }\n+        BufferPool { pool: Arc::new(Exclusive::new(Vec::new())) }\n     }\n \n     /// Allocates a new work-stealing deque which will send/receiving memory to\n@@ -380,7 +377,7 @@ impl<T: Send> Buffer<T> {\n     // Unsafe because this unsafely overwrites possibly uninitialized or\n     // initialized data.\n     unsafe fn put(&self, i: int, t: T) {\n-        overwrite(self.elem(i) as *mut T, t);\n+        ptr::write(self.elem(i) as *mut T, t);\n     }\n \n     // Again, unsafe because this has incredibly dubious ownership violations.\n@@ -405,17 +402,16 @@ impl<T: Send> Drop for Buffer<T> {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use std::prelude::*;\n     use super::{Data, BufferPool, Abort, Empty, Worker, Stealer};\n \n-    use mem;\n-    use owned::Box;\n-    use rt::thread::Thread;\n-    use rand;\n-    use rand::Rng;\n-    use sync::atomics::{AtomicBool, INIT_ATOMIC_BOOL, SeqCst,\n-                        AtomicUint, INIT_ATOMIC_UINT};\n-    use vec;\n+    use std::mem;\n+    use std::rt::thread::Thread;\n+    use std::rand;\n+    use std::rand::Rng;\n+    use atomics::{AtomicBool, INIT_ATOMIC_BOOL, SeqCst,\n+                  AtomicUint, INIT_ATOMIC_UINT};\n+    use std::vec;\n \n     #[test]\n     fn smoke() {\n@@ -631,7 +627,6 @@ mod tests {\n \n         let mut rng = rand::task_rng();\n         let mut myhit = false;\n-        let mut iter = 0;\n         'outer: loop {\n             for _ in range(0, rng.gen_range(0, AMT)) {\n                 if !myhit && rng.gen_range(0, 3) == 2 {\n@@ -644,12 +639,9 @@ mod tests {\n                     w.push((1, 2));\n                 }\n             }\n-            iter += 1;\n \n-            debug!(\"loop iteration {}\", iter);\n-            for (i, slot) in hits.iter().enumerate() {\n+            for slot in hits.iter() {\n                 let amt = slot.load(SeqCst);\n-                debug!(\"thread {}: {}\", i, amt);\n                 if amt == 0 { continue 'outer; }\n             }\n             if myhit {", "previous_filename": "src/libstd/sync/deque.rs"}, {"sha": "9f0109282564293db77e4ac8b5939202c344d0e2", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -8,9 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * Concurrency-enabled mechanisms and primitives.\n- */\n+//! Core concurrency-enabled mechanisms and primitives.\n+//!\n+//! This crate contains the implementations of Rust's core synchronization\n+//! primitives. This includes channels, mutexes, condition variables, etc.\n+//!\n+//! The interface of this crate is experimental, and it is not recommended to\n+//! use this crate specifically. Instead, its functionality is reexported\n+//! through `std::sync`.\n \n #![crate_id = \"sync#0.11.0-pre\"]\n #![crate_type = \"rlib\"]\n@@ -20,35 +25,58 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(phase)]\n+#![feature(phase, globs, macro_rules)]\n #![deny(deprecated_owned_vector)]\n-\n #![deny(missing_doc)]\n+#![no_std]\n \n-#[cfg(test, stage0)]\n-#[phase(syntax, link)] extern crate log;\n-\n-#[cfg(test, not(stage0))]\n-#[phase(plugin, link)] extern crate log;\n-\n+#[cfg(stage0)]\n+#[phase(syntax, link)] extern crate core;\n+#[cfg(not(stage0))]\n+#[phase(plugin, link)] extern crate core;\n extern crate alloc;\n+extern crate collections;\n+extern crate rustrt;\n+\n+#[cfg(test)] extern crate test;\n+#[cfg(test)] extern crate native;\n+#[cfg(test, stage0)] #[phase(syntax, link)] extern crate std;\n+#[cfg(test, not(stage0))] #[phase(plugin, link)] extern crate std;\n \n-pub use comm::{DuplexStream, duplex};\n-pub use task_pool::TaskPool;\n-pub use future::Future;\n pub use alloc::arc::{Arc, Weak};\n pub use lock::{Mutex, MutexGuard, Condvar, Barrier,\n                RWLock, RWLockReadGuard, RWLockWriteGuard};\n \n // The mutex/rwlock in this module are not meant for reexport\n pub use raw::{Semaphore, SemaphoreGuard};\n \n-mod comm;\n-mod future;\n-mod lock;\n+// Core building blocks for all primitives in this crate\n+\n+pub mod atomics;\n+\n+// Concurrent data structures\n+\n mod mpsc_intrusive;\n-mod task_pool;\n+pub mod spsc_queue;\n+pub mod mpsc_queue;\n+pub mod mpmc_bounded_queue;\n+pub mod deque;\n+\n+// Low-level concurrency primitives\n \n pub mod raw;\n pub mod mutex;\n pub mod one;\n+\n+// Message-passing based communication\n+\n+pub mod comm;\n+\n+// Higher level primitives based on those above\n+\n+mod lock;\n+\n+#[cfg(not(test))]\n+mod std {\n+    pub use core::{fmt, option, cmp, clone};\n+}"}, {"sha": "d7990068d5eb7174148b46b97418add571d217e9", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -19,8 +19,11 @@\n //! after grabbing the lock, the second task will immediately fail because the\n //! lock is now poisoned.\n \n-use std::task;\n-use std::ty::Unsafe;\n+use core::prelude::*;\n+\n+use core::ty::Unsafe;\n+use rustrt::local::Local;\n+use rustrt::task::Task;\n \n use raw;\n \n@@ -33,6 +36,10 @@ struct PoisonOnFail<'a> {\n     failed: bool,\n }\n \n+fn failing() -> bool {\n+    Local::borrow(None::<Task>).unwinder.unwinding()\n+}\n+\n impl<'a> PoisonOnFail<'a> {\n     fn check(flag: bool, name: &str) {\n         if flag {\n@@ -44,15 +51,15 @@ impl<'a> PoisonOnFail<'a> {\n         PoisonOnFail::check(*flag, name);\n         PoisonOnFail {\n             flag: flag,\n-            failed: task::failing()\n+            failed: failing()\n         }\n     }\n }\n \n #[unsafe_destructor]\n impl<'a> Drop for PoisonOnFail<'a> {\n     fn drop(&mut self) {\n-        if !self.failed && task::failing() {\n+        if !self.failed && failing() {\n             *self.flag = true;\n         }\n     }\n@@ -449,6 +456,7 @@ impl Barrier {\n \n #[cfg(test)]\n mod tests {\n+    use std::prelude::*;\n     use std::comm::Empty;\n     use std::task;\n     use std::task::TaskBuilder;"}, {"sha": "b700d57bc033df1b2323fad022fdd15d75619a45", "filename": "src/libsync/mpmc_bounded_queue.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpmc_bounded_queue.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -25,19 +25,19 @@\n  * policies, either expressed or implied, of Dmitry Vyukov.\n  */\n \n+#![experimental]\n #![allow(missing_doc, dead_code)]\n \n // http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue\n \n+use core::prelude::*;\n+\n use alloc::arc::Arc;\n+use collections::Vec;\n+use core::num::next_power_of_two;\n+use core::ty::Unsafe;\n \n-use clone::Clone;\n-use kinds::Send;\n-use num::next_power_of_two;\n-use option::{Option, Some, None};\n-use sync::atomics::{AtomicUint,Relaxed,Release,Acquire};\n-use vec::Vec;\n-use ty::Unsafe;\n+use atomics::{AtomicUint,Relaxed,Release,Acquire};\n \n struct Node<T> {\n     sequence: AtomicUint,\n@@ -165,7 +165,7 @@ impl<T: Send> Clone for Queue<T> {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use std::prelude::*;\n     use super::Queue;\n     use native;\n ", "previous_filename": "src/libstd/sync/mpmc_bounded_queue.rs"}, {"sha": "6af733ddb4b44628c991a247bcc21d5732ce37f5", "filename": "src/libsync/mpsc_intrusive.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fmpsc_intrusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fmpsc_intrusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_intrusive.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -30,12 +30,16 @@\n //! This module implements an intrusive MPSC queue. This queue is incredibly\n //! unsafe (due to use of unsafe pointers for nodes), and hence is not public.\n \n+#![experimental]\n+\n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/intrusive-mpsc-node-based-queue\n \n-use std::mem;\n-use std::sync::atomics;\n-use std::ty::Unsafe;\n+use core::prelude::*;\n+\n+use core::atomics;\n+use core::mem;\n+use core::ty::Unsafe;\n \n // NB: all links are done as AtomicUint instead of AtomicPtr to allow for static\n // initialization."}, {"sha": "4bb0acf580c570162ac3032b542c7f165abe4426", "filename": "src/libsync/mpsc_queue.rs", "status": "renamed", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_queue.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -35,17 +35,18 @@\n //! method, and see the method for more information about it. Due to this\n //! caveat, this queue may not be appropriate for all use-cases.\n \n+#![experimental]\n+\n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/non-intrusive-mpsc-node-based-queue\n \n-use kinds::Send;\n-use mem;\n-use ops::Drop;\n-use option::{Option, None, Some};\n-use owned::Box;\n-use ptr::RawPtr;\n-use sync::atomics::{AtomicPtr, Release, Acquire, AcqRel, Relaxed};\n-use ty::Unsafe;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::mem;\n+use core::ty::Unsafe;\n+\n+use atomics::{AtomicPtr, Release, Acquire, AcqRel, Relaxed};\n \n /// A result of the `pop` function.\n pub enum PopResult<T> {\n@@ -156,7 +157,7 @@ impl<T: Send> Drop for Queue<T> {\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use std::prelude::*;\n \n     use alloc::arc::Arc;\n ", "previous_filename": "src/libstd/sync/mpsc_queue.rs"}, {"sha": "6b9ff3cf0527cf4602424f6abcde74fb64d7616c", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -57,14 +57,17 @@\n // times in order to manage a few flags about who's blocking where and whether\n // it's locked or not.\n \n-use std::kinds::marker;\n-use std::mem;\n-use std::rt::local::Local;\n-use std::rt::task::{BlockedTask, Task};\n-use std::rt::thread::Thread;\n-use std::sync::atomics;\n-use std::ty::Unsafe;\n-use std::rt::mutex;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::atomics;\n+use core::kinds::marker;\n+use core::mem;\n+use core::ty::Unsafe;\n+use rustrt::local::Local;\n+use rustrt::mutex;\n+use rustrt::task::{BlockedTask, Task};\n+use rustrt::thread::Thread;\n \n use q = mpsc_intrusive;\n \n@@ -402,7 +405,7 @@ impl StaticMutex {\n                         GreenAcquisition => { self.green_unlock(); }\n                         NativeAcquisition => { self.native_unlock(); }\n                         TryLockAcquisition => {}\n-                        Unlocked => unreachable!()\n+                        Unlocked => unreachable!(),\n                     }\n                     unlocked = true;\n                 }\n@@ -417,7 +420,7 @@ impl StaticMutex {\n                 GreenAcquisition => { self.green_unlock(); }\n                 NativeAcquisition => { self.native_unlock(); }\n                 TryLockAcquisition => {}\n-                Unlocked => unreachable!()\n+                Unlocked => unreachable!(),\n             }\n         }\n \n@@ -517,8 +520,9 @@ impl Drop for Mutex {\n \n #[cfg(test)]\n mod test {\n-    extern crate native;\n+    use std::prelude::*;\n     use super::{Mutex, StaticMutex, MUTEX_INIT};\n+    use native;\n \n     #[test]\n     fn smoke() {"}, {"sha": "2f6caa1d6ff881b29fe18f2668ed0a7cd02513d6", "filename": "src/libsync/one.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fone.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -13,8 +13,10 @@\n //! This primitive is meant to be used to run one-time initialization. An\n //! example use case would be for initializing an FFI library.\n \n-use std::int;\n-use std::sync::atomics;\n+use core::prelude::*;\n+\n+use core::int;\n+use core::atomics;\n \n use mutex::{StaticMutex, MUTEX_INIT};\n \n@@ -124,8 +126,9 @@ impl Once {\n \n #[cfg(test)]\n mod test {\n-    use super::{ONCE_INIT, Once};\n+    use std::prelude::*;\n     use std::task;\n+    use super::{ONCE_INIT, Once};\n \n     #[test]\n     fn smoke_once() {"}, {"sha": "5df08790c41d299d3d48a7141312276543d14043", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -15,13 +15,17 @@\n //! `sync` crate which wrap values directly and provide safer abstractions for\n //! containing data.\n \n-use std::kinds::marker;\n-use std::mem;\n-use std::sync::atomics;\n-use std::ty::Unsafe;\n-use std::finally::Finally;\n+use core::prelude::*;\n+\n+use core::atomics;\n+use core::finally::Finally;\n+use core::kinds::marker;\n+use core::mem;\n+use core::ty::Unsafe;\n+use collections::Vec;\n \n use mutex;\n+use comm::{Receiver, Sender, channel};\n \n /****************************************************************************\n  * Internals\n@@ -608,6 +612,8 @@ impl<'a> Drop for RWLockReadGuard<'a> {\n \n #[cfg(test)]\n mod tests {\n+    use std::prelude::*;\n+\n     use Arc;\n     use super::{Semaphore, Mutex, RWLock, Condvar};\n "}, {"sha": "55d2f3062baea48a6ef393f624e5a6106ada997f", "filename": "src/libsync/spsc_queue.rs", "status": "renamed", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fspsc_queue.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -33,14 +33,15 @@\n //! concurrently between two tasks. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n-use kinds::Send;\n-use mem;\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use owned::Box;\n-use ptr::RawPtr;\n-use sync::atomics::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n-use ty::Unsafe;\n+#![experimental]\n+\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::mem;\n+use core::ty::Unsafe;\n+\n+use atomics::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n \n // Node within the linked list queue of messages to send\n struct Node<T> {\n@@ -226,7 +227,7 @@ impl<T: Send> Drop for Queue<T> {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n+    use std::prelude::*;\n \n     use alloc::arc::Arc;\n     use native;", "previous_filename": "src/libstd/sync/spsc_queue.rs"}, {"sha": "c13cce36c0a915e035c45abb9923b565dd68415f", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -29,8 +29,6 @@\n \n extern crate serialize;\n extern crate libc;\n-#[cfg(target_os = \"macos\")]\n-extern crate sync;\n \n use std::io::BufReader;\n use std::num;\n@@ -168,7 +166,7 @@ pub fn precise_time_ns() -> u64 {\n     fn os_precise_time_ns() -> u64 {\n         static mut TIMEBASE: libc::mach_timebase_info = libc::mach_timebase_info { numer: 0,\n                                                                                    denom: 0 };\n-        static mut ONCE: sync::one::Once = sync::one::ONCE_INIT;\n+        static mut ONCE: std::sync::Once = std::sync::ONCE_INIT;\n         unsafe {\n             ONCE.doit(|| {\n                 imp::mach_timebase_info(&mut TIMEBASE);"}, {"sha": "eda8cf9efc1b098b343d2311fc5e953818d6c686", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -15,10 +15,9 @@\n \n // This also serves as a pipes test, because Arcs are implemented with pipes.\n \n-extern crate sync;\n extern crate time;\n \n-use sync::{Arc, Future, Mutex};\n+use std::sync::{Arc, Future, Mutex};\n use std::os;\n use std::uint;\n "}, {"sha": "f36e8ad147d2cd16d764b0aa1de1adc7a1cdb964", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -15,11 +15,9 @@\n \n // This also serves as a pipes test, because Arcs are implemented with pipes.\n \n-extern crate sync;\n extern crate time;\n \n-use sync::{RWLock, Arc};\n-use sync::Future;\n+use std::sync::{RWLock, Arc, Future};\n use std::os;\n use std::uint;\n "}, {"sha": "9a9194a38c268e69758298e494a5b78bd1901be3", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate sync;\n extern crate arena;\n \n use std::iter::range_step;\n-use sync::Future;\n+use std::sync::Future;\n use arena::TypedArena;\n \n enum Tree<'a> {"}, {"sha": "9b2b46d0a5a1de3f254ee99edd25e37d14137d9c", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -10,12 +10,9 @@\n \n // ignore-android see #10393 #13206\n \n-extern crate sync;\n-\n use std::string::String;\n use std::slice;\n-use sync::Arc;\n-use sync::Future;\n+use std::sync::{Arc, Future};\n \n static TABLE: [u8, ..4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n static TABLE_SIZE: uint = 2 << 16;"}, {"sha": "0cb21807f92f9cc4513d9dbc7efa3d22d558dfdd", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -13,13 +13,10 @@\n \n // ignore-pretty very bad with line comments\n \n-extern crate sync;\n-\n use std::io;\n use std::os;\n use std::simd::f64x2;\n-use sync::Future;\n-use sync::Arc;\n+use std::sync::{Arc, Future};\n \n static ITER: int = 50;\n static LIMIT: f64 = 2.0;"}, {"sha": "87805c4d4bcdb1cb40488e4b04343c1a0950b8c3", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -40,9 +40,8 @@\n \n #![feature(phase)]\n #[phase(plugin)] extern crate green;\n-extern crate sync;\n \n-use sync::Arc;\n+use std::sync::Arc;\n \n green_start!(main)\n "}, {"sha": "64f3e633d034c4d3a719fb81fde7cb30cb189cb8", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -47,11 +47,10 @@\n \n extern crate regex;\n #[phase(plugin)]extern crate regex_macros;\n-extern crate sync;\n \n use std::io;\n use regex::{NoExpand, Regex};\n-use sync::Arc;\n+use std::sync::{Arc, Future};\n \n fn count_matches(seq: &str, variant: &Regex) -> int {\n     let mut n = 0;\n@@ -75,7 +74,7 @@ fn main() {\n     let seq_arc = Arc::new(seq.clone()); // copy before it moves\n     let clen = seq.len();\n \n-    let mut seqlen = sync::Future::spawn(proc() {\n+    let mut seqlen = Future::spawn(proc() {\n         let substs = ~[\n             (regex!(\"B\"), \"(c|g|t)\"),\n             (regex!(\"D\"), \"(a|g|t)\"),\n@@ -111,7 +110,7 @@ fn main() {\n     for variant in variants.move_iter() {\n         let seq_arc_copy = seq_arc.clone();\n         variant_strs.push(variant.to_str().to_owned());\n-        counts.push(sync::Future::spawn(proc() {\n+        counts.push(Future::spawn(proc() {\n             count_matches(seq_arc_copy.as_slice(), &variant)\n         }));\n     }"}, {"sha": "d5f55458ec4182a41cd30a65abfdd22058f7428a", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -11,13 +11,12 @@\n #![feature(phase)]\n #![allow(non_snake_case_functions)]\n #[phase(plugin)] extern crate green;\n-extern crate sync;\n \n use std::from_str::FromStr;\n use std::iter::count;\n use std::cmp::min;\n use std::os;\n-use sync::{Arc, RWLock};\n+use std::sync::{Arc, RWLock};\n \n green_start!(main)\n "}, {"sha": "da246f85c43e309ba3af26fe375d585014f09a1a", "filename": "src/test/compile-fail/functional-struct-update-noncopyable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-noncopyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-noncopyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-noncopyable.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -10,9 +10,7 @@\n \n // issue 7327\n \n-extern crate sync;\n-\n-use sync::Arc;\n+use std::sync::Arc;\n \n struct A { y: Arc<int>, x: Arc<int> }\n "}, {"sha": "da56792ec882099c4eb6104b3ec402de38dbac06", "filename": "src/test/compile-fail/future_not_copyable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate sync;\n-\n-use sync::Future;\n+use std::sync::Future;\n \n fn main() {\n     let f = Future::from_value(());"}, {"sha": "80aa0392918128cf8fd7788a47ae1f6fbbc1cf7c", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -10,9 +10,7 @@\n \n // error-pattern: use of moved value\n \n-extern crate sync;\n-use sync::Arc;\n-\n+use std::sync::Arc;\n use std::task;\n \n fn main() {"}, {"sha": "8f488747bb90d6bbaffcaccd86ba8b5f9aa55a12", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate sync;\n-use sync::Arc;\n-\n+use std::sync::Arc;\n use std::task;\n \n fn main() {"}, {"sha": "68687773f278fd361121d3c5deeba369b006e2ee", "filename": "src/test/compile-fail/once-cant-call-twice-on-heap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -12,8 +12,7 @@\n // This program would segfault if it were legal.\n \n #![feature(once_fns)]\n-extern crate sync;\n-use sync::Arc;\n+use std::sync::Arc;\n \n fn foo(blk: proc()) {\n     blk();"}, {"sha": "17968195280a10d1eed9fc9c0c67f77d5b8ede06", "filename": "src/test/compile-fail/once-cant-call-twice-on-stack.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -12,8 +12,7 @@\n // This program would segfault if it were legal.\n \n #![feature(once_fns)]\n-extern crate sync;\n-use sync::Arc;\n+use std::sync::Arc;\n \n fn foo(blk: once ||) {\n     blk();"}, {"sha": "3efebf6184406f06bf916688639b6274b87830d1", "filename": "src/test/compile-fail/once-cant-move-out-of-non-once-on-stack.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -11,8 +11,7 @@\n // Testing guarantees provided by once functions.\n // This program would segfault if it were legal.\n \n-extern crate sync;\n-use sync::Arc;\n+use std::sync::Arc;\n \n fn foo(blk: ||) {\n     blk();"}, {"sha": "dbe2a9e9229d2224fe24fe4500c8c2a19b79e69b", "filename": "src/test/run-fail/issue-2444.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2444.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -10,8 +10,7 @@\n \n // error-pattern:explicit failure\n \n-extern crate sync;\n-use sync::Arc;\n+use std::sync::Arc;\n \n enum e<T> { e(Arc<T>) }\n "}, {"sha": "a7d3d99e45892f33829761d569e797ec304ad0d5", "filename": "src/test/run-pass/bind-by-move.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-pass%2Fbind-by-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-pass%2Fbind-by-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-by-move.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate sync;\n-\n-use sync::Arc;\n+use std::sync::Arc;\n fn dispose(_x: Arc<bool>) { }\n \n pub fn main() {"}, {"sha": "dfd5992a40675b0d10171d5bfbbd27309d651d05", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -12,8 +12,7 @@\n \n \n #![feature(once_fns)]\n-extern crate sync;\n-use sync::Arc;\n+use std::sync::Arc;\n \n fn foo(blk: proc()) {\n     blk();"}, {"sha": "0419fc54add15b6e14a07ae4320308ed34435c2b", "filename": "src/test/run-pass/once-move-out-on-stack.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -12,8 +12,7 @@\n \n \n #![feature(once_fns)]\n-extern crate sync;\n-use sync::Arc;\n+use std::sync::Arc;\n \n fn foo(blk: once ||) {\n     blk();"}, {"sha": "4ca67811982d1c93c1c6278bfbe7566bdae27967", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=b1c9ce9c6f0eb7d4a7df1aad6b6799f4b548181c", "patch": "@@ -12,9 +12,7 @@\n // and shared between tasks as long as all types fulfill Send.\n \n \n-extern crate sync;\n-\n-use sync::Arc;\n+use std::sync::Arc;\n use std::task;\n \n trait Pet {"}]}