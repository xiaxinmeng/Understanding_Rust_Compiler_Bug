{"sha": "042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "node_id": "C_kwDOAAsO6NoAKDA0MmFhMzc5YTVjZjZmNjE0ODY2NGI3NGM5ZWJkZjg4YWQ4YTVjMWQ", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-01-10T14:48:05Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-01-17T17:06:30Z"}, "message": "Pass target_features set instead of has_feature closure\n\nThis avoids unnecessary monomorphizations in codegen backends", "tree": {"sha": "f9cb7a7c415e9a360fe8eea6a039979408e2dfc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9cb7a7c415e9a360fe8eea6a039979408e2dfc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "html_url": "https://github.com/rust-lang/rust/commit/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "991cbd15034798e86de6823800b13c87fb3e904c", "url": "https://api.github.com/repos/rust-lang/rust/commits/991cbd15034798e86de6823800b13c87fb3e904c", "html_url": "https://github.com/rust-lang/rust/commit/991cbd15034798e86de6823800b13c87fb3e904c"}], "stats": {"total": 125, "additions": 63, "deletions": 62}, "files": [{"sha": "89d411d4b36fe78a2f60e5bac14f7417e56bb5d3", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             for (abi_name, abi_span) in &asm.clobber_abis {\n                 match asm::InlineAsmClobberAbi::parse(\n                     asm_arch,\n-                    |feature| self.sess.target_features.contains(&feature),\n+                    &self.sess.target_features,\n                     &self.sess.target,\n                     *abi_name,\n                 ) {\n@@ -134,7 +134,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(\n                                 asm_arch,\n-                                |feature| sess.target_features.contains(&feature),\n+                                &sess.target_features,\n                                 &sess.target,\n                                 s,\n                             )"}, {"sha": "c242c75ed18ffcf9adb84a9284965fa23e6cb510", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "patch": "@@ -182,11 +182,7 @@ struct InlineAssemblyGenerator<'a, 'tcx> {\n impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n     fn allocate_registers(&mut self) {\n         let sess = self.tcx.sess;\n-        let map = allocatable_registers(\n-            self.arch,\n-            |feature| sess.target_features.contains(&feature),\n-            &sess.target,\n-        );\n+        let map = allocatable_registers(self.arch, &sess.target_features, &sess.target);\n         let mut allocated = FxHashMap::<_, (bool, bool)>::default();\n         let mut regs = vec![None; self.operands.len()];\n \n@@ -319,7 +315,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for saving clobbered registers\n         let abi_clobber = InlineAsmClobberAbi::parse(\n             self.arch,\n-            |feature| self.tcx.sess.target_features.contains(&feature),\n+            &self.tcx.sess.target_features,\n             &self.tcx.sess.target,\n             sym::C,\n         )"}, {"sha": "da875508676d4cd489234aaec7c282bd02a82dac", "filename": "compiler/rustc_target/src/asm/aarch64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs?ref=042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::Target;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n use std::fmt;\n@@ -74,7 +75,7 @@ impl AArch64InlineAsmRegClass {\n \n pub fn reserved_x18(\n     _arch: InlineAsmArch,\n-    _has_feature: impl FnMut(Symbol) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     target: &Target,\n ) -> Result<(), &'static str> {\n     if target.os == \"android\""}, {"sha": "e3615b43c70eba508b11cc8e903a5f044117a327", "filename": "compiler/rustc_target/src/asm/arm.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs?ref=042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::Target;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n use std::fmt;\n@@ -60,16 +61,16 @@ impl ArmInlineAsmRegClass {\n }\n \n // This uses the same logic as useR7AsFramePointer in LLVM\n-fn frame_pointer_is_r7(mut has_feature: impl FnMut(Symbol) -> bool, target: &Target) -> bool {\n-    target.is_like_osx || (!target.is_like_windows && has_feature(sym::thumb_mode))\n+fn frame_pointer_is_r7(target_features: &FxHashSet<Symbol>, target: &Target) -> bool {\n+    target.is_like_osx || (!target.is_like_windows && target_features.contains(&sym::thumb_mode))\n }\n \n fn frame_pointer_r11(\n     _arch: InlineAsmArch,\n-    has_feature: impl FnMut(Symbol) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     target: &Target,\n ) -> Result<(), &'static str> {\n-    if !frame_pointer_is_r7(has_feature, target) {\n+    if !frame_pointer_is_r7(target_features, target) {\n         Err(\"the frame pointer (r11) cannot be used as an operand for inline asm\")\n     } else {\n         Ok(())\n@@ -78,10 +79,10 @@ fn frame_pointer_r11(\n \n fn frame_pointer_r7(\n     _arch: InlineAsmArch,\n-    has_feature: impl FnMut(Symbol) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     target: &Target,\n ) -> Result<(), &'static str> {\n-    if frame_pointer_is_r7(has_feature, target) {\n+    if frame_pointer_is_r7(target_features, target) {\n         Err(\"the frame pointer (r7) cannot be used as an operand for inline asm\")\n     } else {\n         Ok(())\n@@ -90,10 +91,10 @@ fn frame_pointer_r7(\n \n fn not_thumb1(\n     _arch: InlineAsmArch,\n-    mut has_feature: impl FnMut(Symbol) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n-    if has_feature(sym::thumb_mode) && !has_feature(sym::thumb2) {\n+    if target_features.contains(&sym::thumb_mode) && !target_features.contains(&sym::thumb2) {\n         Err(\"high registers (r8+) cannot be used in Thumb-1 code\")\n     } else {\n         Ok(())\n@@ -102,14 +103,14 @@ fn not_thumb1(\n \n fn reserved_r9(\n     arch: InlineAsmArch,\n-    mut has_feature: impl FnMut(Symbol) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     target: &Target,\n ) -> Result<(), &'static str> {\n-    not_thumb1(arch, &mut has_feature, target)?;\n+    not_thumb1(arch, target_features, target)?;\n \n     // We detect this using the reserved-r9 feature instead of using the target\n     // because the relocation model can be changed with compiler options.\n-    if has_feature(sym::reserved_r9) {\n+    if target_features.contains(&sym::reserved_r9) {\n         Err(\"the RWPI static base register (r9) cannot be used as an operand for inline asm\")\n     } else {\n         Ok(())"}, {"sha": "d94fcb53e24c9fcd62930cb3da118856ac4eba44", "filename": "compiler/rustc_target/src/asm/bpf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs?ref=042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "patch": "@@ -1,4 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType, Target};\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n use std::fmt;\n@@ -44,10 +45,10 @@ impl BpfInlineAsmRegClass {\n \n fn only_alu32(\n     _arch: InlineAsmArch,\n-    mut has_feature: impl FnMut(Symbol) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n-    if !has_feature(sym::alu32) {\n+    if !target_features.contains(&sym::alu32) {\n         Err(\"register can't be used without the `alu32` target feature\")\n     } else {\n         Ok(())"}, {"sha": "6b82bb337e6c1fd68a70876ecbccf31b79f89c1a", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "patch": "@@ -81,14 +81,14 @@ macro_rules! def_regs {\n \n             pub fn parse(\n                 _arch: super::InlineAsmArch,\n-                mut _has_feature: impl FnMut(rustc_span::Symbol) -> bool,\n+                _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n                 _target: &crate::spec::Target,\n                 name: &str,\n             ) -> Result<Self, &'static str> {\n                 match name {\n                     $(\n                         $($alias)|* | $reg_name => {\n-                            $($filter(_arch, &mut _has_feature, _target)?;)?\n+                            $($filter(_arch, _target_features, _target)?;)?\n                             Ok(Self::$reg)\n                         }\n                     )*\n@@ -102,7 +102,7 @@ macro_rules! def_regs {\n \n         pub(super) fn fill_reg_map(\n             _arch: super::InlineAsmArch,\n-            mut _has_feature: impl FnMut(rustc_span::Symbol) -> bool,\n+            _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n             _target: &crate::spec::Target,\n             _map: &mut rustc_data_structures::fx::FxHashMap<\n                 super::InlineAsmRegClass,\n@@ -112,7 +112,7 @@ macro_rules! def_regs {\n             #[allow(unused_imports)]\n             use super::{InlineAsmReg, InlineAsmRegClass};\n             $(\n-                if $($filter(_arch, &mut _has_feature, _target).is_ok() &&)? true {\n+                if $($filter(_arch, _target_features, _target).is_ok() &&)? true {\n                     if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n                         set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                     }\n@@ -289,7 +289,7 @@ impl InlineAsmReg {\n \n     pub fn parse(\n         arch: InlineAsmArch,\n-        has_feature: impl FnMut(Symbol) -> bool,\n+        target_features: &FxHashSet<Symbol>,\n         target: &Target,\n         name: Symbol,\n     ) -> Result<Self, &'static str> {\n@@ -298,43 +298,43 @@ impl InlineAsmReg {\n         let name = name.as_str();\n         Ok(match arch {\n             InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::X86(X86InlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Arm => {\n-                Self::Arm(ArmInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Arm(ArmInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::AArch64 => {\n-                Self::AArch64(AArch64InlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::AArch64(AArch64InlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n-                Self::RiscV(RiscVInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::RiscV(RiscVInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Nvptx64 => {\n-                Self::Nvptx(NvptxInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Nvptx(NvptxInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n-                Self::PowerPC(PowerPCInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::PowerPC(PowerPCInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Hexagon => {\n-                Self::Hexagon(HexagonInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Hexagon(HexagonInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n-                Self::Mips(MipsInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Mips(MipsInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::S390x => {\n-                Self::S390x(S390xInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::S390x(S390xInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::SpirV => {\n-                Self::SpirV(SpirVInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::SpirV(SpirVInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n-                Self::Wasm(WasmInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Wasm(WasmInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Bpf => {\n-                Self::Bpf(BpfInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Bpf(BpfInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n             InlineAsmArch::Avr => {\n-                Self::Avr(AvrInlineAsmReg::parse(arch, has_feature, target, name)?)\n+                Self::Avr(AvrInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n         })\n     }\n@@ -695,73 +695,73 @@ impl fmt::Display for InlineAsmType {\n // falling back to an external assembler.\n pub fn allocatable_registers(\n     arch: InlineAsmArch,\n-    has_feature: impl FnMut(Symbol) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     target: &crate::spec::Target,\n ) -> FxHashMap<InlineAsmRegClass, FxHashSet<InlineAsmReg>> {\n     match arch {\n         InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n             let mut map = x86::regclass_map();\n-            x86::fill_reg_map(arch, has_feature, target, &mut map);\n+            x86::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Arm => {\n             let mut map = arm::regclass_map();\n-            arm::fill_reg_map(arch, has_feature, target, &mut map);\n+            arm::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::AArch64 => {\n             let mut map = aarch64::regclass_map();\n-            aarch64::fill_reg_map(arch, has_feature, target, &mut map);\n+            aarch64::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n             let mut map = riscv::regclass_map();\n-            riscv::fill_reg_map(arch, has_feature, target, &mut map);\n+            riscv::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Nvptx64 => {\n             let mut map = nvptx::regclass_map();\n-            nvptx::fill_reg_map(arch, has_feature, target, &mut map);\n+            nvptx::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n             let mut map = powerpc::regclass_map();\n-            powerpc::fill_reg_map(arch, has_feature, target, &mut map);\n+            powerpc::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Hexagon => {\n             let mut map = hexagon::regclass_map();\n-            hexagon::fill_reg_map(arch, has_feature, target, &mut map);\n+            hexagon::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n             let mut map = mips::regclass_map();\n-            mips::fill_reg_map(arch, has_feature, target, &mut map);\n+            mips::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::S390x => {\n             let mut map = s390x::regclass_map();\n-            s390x::fill_reg_map(arch, has_feature, target, &mut map);\n+            s390x::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::SpirV => {\n             let mut map = spirv::regclass_map();\n-            spirv::fill_reg_map(arch, has_feature, target, &mut map);\n+            spirv::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n             let mut map = wasm::regclass_map();\n-            wasm::fill_reg_map(arch, has_feature, target, &mut map);\n+            wasm::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Bpf => {\n             let mut map = bpf::regclass_map();\n-            bpf::fill_reg_map(arch, has_feature, target, &mut map);\n+            bpf::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Avr => {\n             let mut map = avr::regclass_map();\n-            avr::fill_reg_map(arch, has_feature, target, &mut map);\n+            avr::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n     }\n@@ -794,7 +794,7 @@ impl InlineAsmClobberAbi {\n     /// clobber ABIs for the target.\n     pub fn parse(\n         arch: InlineAsmArch,\n-        has_feature: impl FnMut(Symbol) -> bool,\n+        target_features: &FxHashSet<Symbol>,\n         target: &Target,\n         name: Symbol,\n     ) -> Result<Self, &'static [&'static str]> {\n@@ -819,7 +819,7 @@ impl InlineAsmClobberAbi {\n             },\n             InlineAsmArch::AArch64 => match name {\n                 \"C\" | \"system\" | \"efiapi\" => {\n-                    Ok(if aarch64::reserved_x18(arch, has_feature, target).is_err() {\n+                    Ok(if aarch64::reserved_x18(arch, target_features, target).is_err() {\n                         InlineAsmClobberAbi::AArch64NoX18\n                     } else {\n                         InlineAsmClobberAbi::AArch64"}, {"sha": "39644d232badbfc923c5328fe6f5b5af90b12ea4", "filename": "compiler/rustc_target/src/asm/riscv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs?ref=042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::Target;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n use std::fmt;\n@@ -53,10 +54,10 @@ impl RiscVInlineAsmRegClass {\n \n fn not_e(\n     _arch: InlineAsmArch,\n-    mut has_feature: impl FnMut(Symbol) -> bool,\n+    target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n-    if has_feature(sym::e) {\n+    if target_features.contains(&sym::e) {\n         Err(\"register can't be used with the `e` target feature\")\n     } else {\n         Ok(())"}, {"sha": "01d32570f78a2cc28b2c6200ffea4d57adec5c7d", "filename": "compiler/rustc_target/src/asm/x86.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs?ref=042aa379a5cf6f6148664b74c9ebdf88ad8a5c1d", "patch": "@@ -1,5 +1,6 @@\n use super::{InlineAsmArch, InlineAsmType};\n use crate::spec::Target;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n use std::fmt;\n@@ -138,7 +139,7 @@ impl X86InlineAsmRegClass {\n \n fn x86_64_only(\n     arch: InlineAsmArch,\n-    _has_feature: impl FnMut(Symbol) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n     match arch {\n@@ -150,7 +151,7 @@ fn x86_64_only(\n \n fn high_byte(\n     arch: InlineAsmArch,\n-    _has_feature: impl FnMut(Symbol) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n     match arch {\n@@ -161,7 +162,7 @@ fn high_byte(\n \n fn rbx_reserved(\n     arch: InlineAsmArch,\n-    _has_feature: impl FnMut(Symbol) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n     match arch {\n@@ -175,7 +176,7 @@ fn rbx_reserved(\n \n fn esi_reserved(\n     arch: InlineAsmArch,\n-    _has_feature: impl FnMut(Symbol) -> bool,\n+    _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n ) -> Result<(), &'static str> {\n     match arch {"}]}