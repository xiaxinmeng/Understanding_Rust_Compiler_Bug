{"sha": "57a593fcbb6af3db567c27b70b3a03c5a244705f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YTU5M2ZjYmI2YWYzZGI1NjdjMjdiNzBiM2EwM2M1YTI0NDcwNWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-16T12:32:21Z"}, "committer": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-01T15:04:26Z"}, "message": "store type values in the unification table directly", "tree": {"sha": "faba766090badffabf41305331fb12d6b0448225", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faba766090badffabf41305331fb12d6b0448225"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57a593fcbb6af3db567c27b70b3a03c5a244705f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57a593fcbb6af3db567c27b70b3a03c5a244705f", "html_url": "https://github.com/rust-lang/rust/commit/57a593fcbb6af3db567c27b70b3a03c5a244705f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57a593fcbb6af3db567c27b70b3a03c5a244705f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7953bb6d67dead45033434161be2ed8cdd6cd31", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7953bb6d67dead45033434161be2ed8cdd6cd31", "html_url": "https://github.com/rust-lang/rust/commit/c7953bb6d67dead45033434161be2ed8cdd6cd31"}], "stats": {"total": 274, "additions": 176, "deletions": 98}, "files": [{"sha": "959fefbe6b6e4c960c4b3f7de90cb5f08a567ae1", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=57a593fcbb6af3db567c27b70b3a03c5a244705f", "patch": "@@ -402,7 +402,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                     // `vid` are related via subtyping.\n                     return Err(TypeError::CyclicTy(self.root_ty));\n                 } else {\n-                    match variables.probe_root(vid) {\n+                    match variables.probe(vid) {\n                         Some(u) => {\n                             drop(variables);\n                             self.relate(&u, &u)\n@@ -423,7 +423,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                                 ty::Covariant | ty::Contravariant => (),\n                             }\n \n-                            let origin = variables.origin(vid);\n+                            let origin = *variables.var_origin(vid);\n                             let new_var_id = variables.new_var(false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\","}, {"sha": "a317e0699b4bba29e755138815ef2036b24fcbd6", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=57a593fcbb6af3db567c27b70b3a03c5a244705f", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                              span: Span,\n-                                             snapshot: &CombinedSnapshot,\n+                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n                                              a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                              span: Span,\n-                                             snapshot: &CombinedSnapshot,\n+                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n                                              a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n@@ -479,7 +479,7 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn tainted_regions(&self,\n-                       snapshot: &CombinedSnapshot,\n+                       snapshot: &CombinedSnapshot<'a, 'tcx>,\n                        r: ty::Region<'tcx>,\n                        directions: TaintDirections)\n                        -> FxHashSet<ty::Region<'tcx>> {\n@@ -491,7 +491,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn region_vars_confined_to_snapshot(&self,\n-                                        snapshot: &CombinedSnapshot)\n+                                        snapshot: &CombinedSnapshot<'a, 'tcx>)\n                                         -> Vec<ty::RegionVid>\n     {\n         /*!\n@@ -583,7 +583,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// See `README.md` for more details.\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            binder: &ty::Binder<T>,\n-                                           snapshot: &CombinedSnapshot)\n+                                           snapshot: &CombinedSnapshot<'a, 'tcx>)\n                                            -> (T, SkolemizationMap<'tcx>)\n         where T : TypeFoldable<'tcx>\n     {\n@@ -609,7 +609,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                       overly_polymorphic: bool,\n                       _span: Span,\n                       skol_map: &SkolemizationMap<'tcx>,\n-                      snapshot: &CombinedSnapshot)\n+                      snapshot: &CombinedSnapshot<'a, 'tcx>)\n                       -> RelateResult<'tcx, ()>\n     {\n         debug!(\"leak_check: skol_map={:?}\",\n@@ -684,7 +684,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// predicate is `for<'a> &'a int : Clone`.\n     pub fn plug_leaks<T>(&self,\n                          skol_map: SkolemizationMap<'tcx>,\n-                         snapshot: &CombinedSnapshot,\n+                         snapshot: &CombinedSnapshot<'a, 'tcx>,\n                          value: T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n@@ -770,8 +770,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Note: popping also occurs implicitly as part of `leak_check`.\n     pub fn pop_skolemized(&self,\n                           skol_map: SkolemizationMap<'tcx>,\n-                          snapshot: &CombinedSnapshot)\n-    {\n+                          snapshot: &CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n         let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n         self.borrow_region_constraints()"}, {"sha": "fa224b575a31231508ec22a7c72afe5fd5bcd08e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=57a593fcbb6af3db567c27b70b3a03c5a244705f", "patch": "@@ -475,7 +475,7 @@ impl<'tcx, T> InferOk<'tcx, T> {\n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n-    type_snapshot: type_variable::Snapshot,\n+    type_snapshot: type_variable::Snapshot<'tcx>,\n     int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n     float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n     region_constraints_snapshot: RegionSnapshot,\n@@ -765,7 +765,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn start_snapshot<'b>(&'b self) -> CombinedSnapshot<'b, 'tcx> {\n+    fn start_snapshot(&self) -> CombinedSnapshot<'a, 'tcx> {\n         debug!(\"start_snapshot()\");\n \n         let in_snapshot = self.in_snapshot.get();\n@@ -787,7 +787,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot) {\n+    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"rollback_to(cause={})\", cause);\n         let CombinedSnapshot { projection_cache_snapshot,\n                                type_snapshot,\n@@ -819,7 +819,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .rollback_to(region_constraints_snapshot);\n     }\n \n-    fn commit_from(&self, snapshot: CombinedSnapshot) {\n+    fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n         let CombinedSnapshot { projection_cache_snapshot,\n                                type_snapshot,\n@@ -861,7 +861,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>\n     {\n         debug!(\"commit_if_ok()\");\n         let snapshot = self.start_snapshot();\n@@ -876,7 +876,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     // Execute `f` in a snapshot, and commit the bindings it creates\n     pub fn in_snapshot<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&CombinedSnapshot) -> T\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T\n     {\n         debug!(\"in_snapshot()\");\n         let snapshot = self.start_snapshot();\n@@ -887,7 +887,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n-        F: FnOnce(&CombinedSnapshot) -> R,\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();"}, {"sha": "261cd396fced782c498238496c3e53e00fee718b", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 151, "deletions": 72, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=57a593fcbb6af3db567c27b70b3a03c5a244705f", "patch": "@@ -8,25 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::TypeVariableValue::*;\n use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n \n use std::cmp::min;\n use std::marker::PhantomData;\n-use std::mem;\n use std::u32;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n \n pub struct TypeVariableTable<'tcx> {\n-    values: sv::SnapshotVec<Delegate<'tcx>>,\n+    values: sv::SnapshotVec<Delegate>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n-    /// constraint `?X == ?Y`.\n-    eq_relations: ut::UnificationTable<ut::InPlace<ty::TyVid>>,\n+    /// constraint `?X == ?Y`. This table also stores, for each key,\n+    /// the known value.\n+    eq_relations: ut::UnificationTable<ut::InPlace<TyVidEqKey<'tcx>>>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n     /// constraint `?X <: ?Y` *or* a constraint `?Y <: ?X`. This second\n@@ -71,30 +70,28 @@ pub enum TypeVariableOrigin {\n \n pub type TypeVariableMap = FxHashMap<ty::TyVid, TypeVariableOrigin>;\n \n-struct TypeVariableData<'tcx> {\n-    value: TypeVariableValue<'tcx>,\n+struct TypeVariableData {\n     origin: TypeVariableOrigin,\n     diverging: bool\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum TypeVariableValue<'tcx> {\n-    Known {\n-        value: Ty<'tcx>\n-    },\n+    Known { value: Ty<'tcx> },\n     Unknown,\n }\n \n-pub struct Snapshot {\n+pub struct Snapshot<'tcx> {\n     snapshot: sv::Snapshot,\n-    eq_snapshot: ut::Snapshot<ut::InPlace<ty::TyVid>>,\n+    eq_snapshot: ut::Snapshot<ut::InPlace<TyVidEqKey<'tcx>>>,\n     sub_snapshot: ut::Snapshot<ut::InPlace<ty::TyVid>>,\n }\n \n struct Instantiate {\n     vid: ty::TyVid,\n }\n \n-struct Delegate<'tcx>(PhantomData<&'tcx ()>);\n+struct Delegate;\n \n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n@@ -105,10 +102,18 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         }\n     }\n \n+    /// Returns the diverges flag given when `vid` was created.\n+    ///\n+    /// Note that this function does not return care whether\n+    /// `vid` has been unified with something else or not.\n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n         self.values.get(vid.index as usize).diverging\n     }\n \n+    /// Returns the origin that was given when `vid` was created.\n+    ///\n+    /// Note that this function does not return care whether\n+    /// `vid` has been unified with something else or not.\n     pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n         &self.values.get(vid.index as usize).origin\n     }\n@@ -137,41 +142,49 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// Precondition: `vid` must not have been previously instantiated.\n     pub fn instantiate(&mut self, vid: ty::TyVid, ty: Ty<'tcx>) {\n         let vid = self.root_var(vid);\n-        debug_assert!(self.probe_root(vid).is_none());\n-\n-        let old_value = {\n-            let vid_data = &mut self.values[vid.index as usize];\n-            mem::replace(&mut vid_data.value, TypeVariableValue::Known { value: ty })\n-        };\n-\n-        match old_value {\n-            TypeVariableValue::Unknown => {\n-                self.values.record(Instantiate { vid: vid });\n-            }\n-            TypeVariableValue::Known { value: old_ty } => {\n-                bug!(\"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n-                     vid, ty, old_ty)\n-            }\n-        }\n+        debug_assert!(self.probe(vid).is_none());\n+        debug_assert!(self.eq_relations.probe_value(vid) == TypeVariableValue::Unknown,\n+                      \"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n+                      vid, ty, self.eq_relations.probe_value(vid));\n+        self.eq_relations.union_value(vid, TypeVariableValue::Known { value: ty });\n+\n+        // Hack: we only need this so that `types_escaping_snapshot`\n+        // can see what has been unified; see the Delegate impl for\n+        // more details.\n+        self.values.record(Instantiate { vid: vid });\n     }\n \n+    /// Creates a new type variable.\n+    ///\n+    /// - `diverging`: indicates if this is a \"diverging\" type\n+    ///   variable, e.g.  one created as the type of a `return`\n+    ///   expression. The code in this module doesn't care if a\n+    ///   variable is diverging, but the main Rust type-checker will\n+    ///   sometimes \"unify\" such variables with the `!` or `()` types.\n+    /// - `origin`: indicates *why* the type variable was created.\n+    ///   The code in this module doesn't care, but it can be useful\n+    ///   for improving error messages.\n     pub fn new_var(&mut self,\n                    diverging: bool,\n                    origin: TypeVariableOrigin)\n                    -> ty::TyVid {\n-        debug!(\"new_var(diverging={:?}, origin={:?})\", diverging, origin);\n-        self.eq_relations.new_key(());\n-        self.sub_relations.new_key(());\n+        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown);\n+\n+        let sub_key = self.sub_relations.new_key(());\n+        assert_eq!(eq_key.vid, sub_key);\n+\n         let index = self.values.push(TypeVariableData {\n-            value: Unknown,\n             origin,\n             diverging,\n         });\n-        let v = ty::TyVid { index: index as u32 };\n-        debug!(\"new_var: diverging={:?} index={:?}\", diverging, v);\n-        v\n+        assert_eq!(eq_key.vid.index, index as u32);\n+\n+        debug!(\"new_var(index={:?}, diverging={:?}, origin={:?}\", eq_key.vid, diverging, origin);\n+\n+        eq_key.vid\n     }\n \n+    /// Returns the number of type variables created thus far.\n     pub fn num_vars(&self) -> usize {\n         self.values.len()\n     }\n@@ -182,7 +195,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// algorithm), so `root_var(a) == root_var(b)` implies that `a ==\n     /// b` (transitively).\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n-        self.eq_relations.find(vid)\n+        self.eq_relations.find(vid).vid\n     }\n \n     /// Returns the \"root\" variable of `vid` in the `sub_relations`\n@@ -202,24 +215,19 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.sub_root_var(a) == self.sub_root_var(b)\n     }\n \n+    /// Retrieves the type to which `vid` has been instantiated, if\n+    /// any.\n     pub fn probe(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n         let vid = self.root_var(vid);\n-        self.probe_root(vid)\n-    }\n-\n-    pub fn origin(&self, vid: ty::TyVid) -> TypeVariableOrigin {\n-        self.values.get(vid.index as usize).origin.clone()\n-    }\n-\n-    /// Retrieves the type of `vid` given that it is currently a root in the unification table\n-    pub fn probe_root(&mut self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        debug_assert!(self.root_var(vid) == vid);\n-        match self.values.get(vid.index as usize).value {\n-            Unknown => None,\n-            Known { value } => Some(value)\n+        match self.eq_relations.probe_value(vid) {\n+            TypeVariableValue::Unknown => None,\n+            TypeVariableValue::Known { value } => Some(value)\n         }\n     }\n \n+    /// If `t` is a type-inference variable, and it has been\n+    /// instantiated, then return the with which it was\n+    /// instantiated. Otherwise, returns `t`.\n     pub fn replace_if_possible(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n             ty::TyInfer(ty::TyVar(v)) => {\n@@ -232,15 +240,22 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         }\n     }\n \n-    pub fn snapshot(&mut self) -> Snapshot {\n+    /// Creates a snapshot of the type variable state.  This snapshot\n+    /// must later be committed (`commit()`) or rolled back\n+    /// (`rollback_to()`).  Nested snapshots are permitted, but must\n+    /// be processed in a stack-like fashion.\n+    pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n         Snapshot {\n             snapshot: self.values.start_snapshot(),\n             eq_snapshot: self.eq_relations.snapshot(),\n             sub_snapshot: self.sub_relations.snapshot(),\n         }\n     }\n \n-    pub fn rollback_to(&mut self, s: Snapshot) {\n+    /// Undoes all changes since the snapshot was created. Any\n+    /// snapshots created since that point must already have been\n+    /// committed or rolled back.\n+    pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n         debug!(\"rollback_to{:?}\", {\n             for action in self.values.actions_since_snapshot(&s.snapshot) {\n                 match *action {\n@@ -258,7 +273,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.sub_relations.rollback_to(sub_snapshot);\n     }\n \n-    pub fn commit(&mut self, s: Snapshot) {\n+    /// Commits all changes since the snapshot was created, making\n+    /// them permanent (unless this snapshot was created within\n+    /// another snapshot). Any snapshots created since that point\n+    /// must already have been committed or rolled back.\n+    pub fn commit(&mut self, s: Snapshot<'tcx>) {\n         let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n         self.values.commit(snapshot);\n         self.eq_relations.commit(eq_snapshot);\n@@ -269,7 +288,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// ty-variables created during the snapshot, and the values\n     /// `{V2}` are the root variables that they were unified with,\n     /// along with their origin.\n-    pub fn types_created_since_snapshot(&mut self, s: &Snapshot) -> TypeVariableMap {\n+    pub fn types_created_since_snapshot(&mut self, s: &Snapshot<'tcx>) -> TypeVariableMap {\n         let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n \n         actions_since_snapshot\n@@ -285,16 +304,13 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             .collect()\n     }\n \n-    pub fn types_escaping_snapshot(&mut self, s: &Snapshot) -> Vec<Ty<'tcx>> {\n-        /*!\n-         * Find the set of type variables that existed *before* `s`\n-         * but which have only been unified since `s` started, and\n-         * return the types with which they were unified. So if we had\n-         * a type variable `V0`, then we started the snapshot, then we\n-         * created a type variable `V1`, unifed `V0` with `T0`, and\n-         * unified `V1` with `T1`, this function would return `{T0}`.\n-         */\n-\n+    /// Find the set of type variables that existed *before* `s`\n+    /// but which have only been unified since `s` started, and\n+    /// return the types with which they were unified. So if we had\n+    /// a type variable `V0`, then we started the snapshot, then we\n+    /// created a type variable `V1`, unifed `V0` with `T0`, and\n+    /// unified `V1` with `T1`, this function would return `{T0}`.\n+    pub fn types_escaping_snapshot(&mut self, s: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n         let mut new_elem_threshold = u32::MAX;\n         let mut escaping_types = Vec::new();\n         let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n@@ -315,9 +331,9 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n-                        let escaping_type = match self.values.get(vid.index as usize).value {\n-                            Unknown => bug!(),\n-                            Known { value } => value,\n+                        let escaping_type = match self.eq_relations.probe_value(vid) {\n+                            TypeVariableValue::Unknown => bug!(),\n+                            TypeVariableValue::Known { value } => value,\n                         };\n                         escaping_types.push(escaping_type);\n                     }\n@@ -331,6 +347,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         escaping_types\n     }\n \n+    /// Returns indices of all variables that are not yet\n+    /// instantiated.\n     pub fn unsolved_variables(&mut self) -> Vec<ty::TyVid> {\n         (0..self.values.len())\n             .filter_map(|i| {\n@@ -345,19 +363,80 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n }\n \n-impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n-    type Value = TypeVariableData<'tcx>;\n+impl sv::SnapshotVecDelegate for Delegate {\n+    type Value = TypeVariableData;\n     type Undo = Instantiate;\n \n-    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: Instantiate) {\n-        let Instantiate { vid } = action;\n-        values[vid.index as usize].value = Unknown;\n+    fn reverse(_values: &mut Vec<TypeVariableData>, _action: Instantiate) {\n+        // We don't actually have to *do* anything to reverse an\n+        // instanation; the value for a variable is stored in the\n+        // `eq_relations` and hence its rollback code will handle\n+        // it. In fact, we could *almost* just remove the\n+        // `SnapshotVec` entirely, except that we would have to\n+        // reproduce *some* of its logic, since we want to know which\n+        // type variables have been instantiated since the snapshot\n+        // was started, so we can implement `types_escaping_snapshot`.\n+        //\n+        // (If we extended the `UnificationTable` to let us see which\n+        // values have been unified and so forth, that might also\n+        // suffice.)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// These structs (a newtyped TyVid) are used as the unification key\n+/// for the `eq_relations`; they carry a `TypeVariableValue` along\n+/// with them.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+struct TyVidEqKey<'tcx> {\n+    vid: ty::TyVid,\n+\n+    // in the table, we map each ty-vid to one of these:\n+    phantom: PhantomData<TypeVariableValue<'tcx>>,\n+}\n+\n+impl<'tcx> From<ty::TyVid> for TyVidEqKey<'tcx> {\n+    fn from(vid: ty::TyVid) -> Self {\n+        TyVidEqKey { vid, phantom: PhantomData }\n+    }\n+}\n+\n+impl<'tcx> ut::UnifyKey for TyVidEqKey<'tcx> {\n+    type Value = TypeVariableValue<'tcx>;\n+    fn index(&self) -> u32 { self.vid.index }\n+    fn from_index(i: u32) -> Self { TyVidEqKey::from(ty::TyVid { index: i }) }\n+    fn tag() -> &'static str { \"TyVidEqKey\" }\n+}\n+\n+impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n+    type Error = ut::NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, ut::NoError> {\n+        match (value1, value2) {\n+            // We never equate two type variables, both of which\n+            // have known types.  Instead, we recursively equate\n+            // those types.\n+            (&TypeVariableValue::Known { .. }, &TypeVariableValue::Known { .. }) => {\n+                bug!(\"equating two type variables, both of which have known types\")\n+            }\n+\n+            // If one side is known, prefer that one.\n+            (&TypeVariableValue::Known { .. }, &TypeVariableValue::Unknown { .. }) => Ok(*value1),\n+            (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),\n+\n+            // If both sides are *unknown*, it hardly matters, does it?\n+            (&TypeVariableValue::Unknown, &TypeVariableValue::Unknown) => Ok(*value1),\n+        }\n     }\n }\n \n+/// Raw `TyVid` are used as the unification key for `sub_relations`;\n+/// they carry no values.\n impl ut::UnifyKey for ty::TyVid {\n     type Value = ();\n     fn index(&self) -> u32 { self.index }\n     fn from_index(i: u32) -> ty::TyVid { ty::TyVid { index: i } }\n     fn tag() -> &'static str { \"TyVid\" }\n }\n+"}, {"sha": "e5f05f30fd8a81b3b63d96031a06acd9b9c67dfc", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a593fcbb6af3db567c27b70b3a03c5a244705f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=57a593fcbb6af3db567c27b70b3a03c5a244705f", "patch": "@@ -496,7 +496,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n     /// context's self.\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n-        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n         // The irrefutable nature of the operation means we don't need to snapshot the\n         // inferred_obligations vector.\n@@ -506,7 +506,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// Wraps a probe s.t. obligations collected during it are ignored and old obligations are\n     /// retained.\n     fn probe<R, F>(&mut self, f: F) -> R\n-        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n         let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n         let result = self.infcx.probe(|snapshot| f(self, snapshot));\n@@ -1478,7 +1478,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &infer::CombinedSnapshot)\n+        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n         -> bool\n     {\n         let poly_trait_predicate =\n@@ -1549,7 +1549,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         trait_bound: ty::PolyTraitRef<'tcx>,\n                         skol_trait_ref: ty::TraitRef<'tcx>,\n                         skol_map: &infer::SkolemizationMap<'tcx>,\n-                        snapshot: &infer::CombinedSnapshot)\n+                        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n@@ -2587,7 +2587,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                    recursion_depth: usize,\n                    param_env: ty::ParamEnv<'tcx>,\n                    skol_map: infer::SkolemizationMap<'tcx>,\n-                   snapshot: &infer::CombinedSnapshot)\n+                   snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n         debug!(\"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={}, skol_map={:?})\",\n@@ -3076,7 +3076,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn rematch_impl(&mut self,\n                     impl_def_id: DefId,\n                     obligation: &TraitObligation<'tcx>,\n-                    snapshot: &infer::CombinedSnapshot)\n+                    snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                     -> (Normalized<'tcx, &'tcx Substs<'tcx>>,\n                         infer::SkolemizationMap<'tcx>)\n     {\n@@ -3093,7 +3093,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn match_impl(&mut self,\n                   impl_def_id: DefId,\n                   obligation: &TraitObligation<'tcx>,\n-                  snapshot: &infer::CombinedSnapshot)\n+                  snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                   -> Result<(Normalized<'tcx, &'tcx Substs<'tcx>>,\n                              infer::SkolemizationMap<'tcx>), ()>\n     {\n@@ -3288,7 +3288,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                  def_id: DefId, // of impl or trait\n                                  substs: &Substs<'tcx>, // for impl or trait\n                                  skol_map: infer::SkolemizationMap<'tcx>,\n-                                 snapshot: &infer::CombinedSnapshot)\n+                                 snapshot: &infer::CombinedSnapshot<'cx, 'tcx>)\n                                  -> Vec<PredicateObligation<'tcx>>\n     {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);"}]}