{"sha": "602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "node_id": "C_kwDOAAsO6NoAKDYwMmQzY2JjZTNlNjIyN2FkN2NkNWMwMDljODY4YzllNDA1YTlmMzI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-16T18:24:08Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-20T16:29:33Z"}, "message": "Invoke callbacks from rustc_middle.", "tree": {"sha": "c0abedc5c75054147fdf5c4a1feda287dae4958c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0abedc5c75054147fdf5c4a1feda287dae4958c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "html_url": "https://github.com/rust-lang/rust/commit/602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b09de95fab42d3afbcb74185ea1f8a2d200a6353", "url": "https://api.github.com/repos/rust-lang/rust/commits/b09de95fab42d3afbcb74185ea1f8a2d200a6353", "html_url": "https://github.com/rust-lang/rust/commit/b09de95fab42d3afbcb74185ea1f8a2d200a6353"}], "stats": {"total": 89, "additions": 42, "deletions": 47}, "files": [{"sha": "8385f1a18e5cd86a5a5cafaae67bc3f36a840df0", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "patch": "@@ -4319,7 +4319,6 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"tracing\",\n ]\n \n [[package]]"}, {"sha": "8ac3cef9040f7389611a3a7f5397bd09dde3f2a6", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "patch": "@@ -99,4 +99,34 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     fn is_eval_always(&self, kind: DepKind) -> bool {\n         self.query_kind(kind).is_eval_always\n     }\n+\n+    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n+        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n+\n+        // We must avoid ever having to call `force_from_dep_node()` for a\n+        // `DepNode::codegen_unit`:\n+        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+        // would always end up having to evaluate the first caller of the\n+        // `codegen_unit` query that *is* reconstructible. This might very well be\n+        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+        // to re-trigger calling the `codegen_unit` query with the right key. At\n+        // that point we would already have re-done all the work we are trying to\n+        // avoid doing in the first place.\n+        // The solution is simple: Just explicitly call the `codegen_unit` query for\n+        // each CGU, right after partitioning. This way `try_mark_green` will always\n+        // hit the cache instead of having to go through `force_from_dep_node`.\n+        // This assertion makes sure, we actually keep applying the solution above.\n+        debug_assert!(\n+            dep_node.kind != DepKind::codegen_unit,\n+            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+        );\n+\n+        let cb = self.query_kind(dep_node.kind);\n+        (cb.force_from_dep_node)(*self, dep_node)\n+    }\n+\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n+        let cb = self.query_kind(dep_node.kind);\n+        (cb.try_load_from_on_disk_cache)(*self, dep_node)\n+    }\n }"}, {"sha": "f984bb1872b2842ea21538bd86a57566c4ceed6a", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "patch": "@@ -9,7 +9,6 @@ doctest = false\n [dependencies]\n measureme = \"10.0.0\"\n rustc-rayon-core = \"0.3.1\"\n-tracing = \"0.1\"\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "d86d1bb8af427be64f3df6200853a7928427b378", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "patch": "@@ -13,8 +13,6 @@\n extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_middle;\n-#[macro_use]\n-extern crate tracing;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};"}, {"sha": "86b12b3586a9be142dbd58c27ee34a191dd1f8e7", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "patch": "@@ -219,7 +219,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n         // Do this *before* we clone 'latest_foreign_def_path_hashes', since\n         // loading existing queries may cause us to create new DepNodes, which\n         // may in turn end up invoking `store_foreign_def_id_hash`\n-        tcx.dep_graph.exec_cache_promotions(QueryCtxt::from_tcx(tcx));\n+        tcx.dep_graph.exec_cache_promotions(tcx);\n \n         *self.serialized_data.write() = None;\n     }"}, {"sha": "be704b75b2b068979a501b303ad744900c31f67c", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "patch": "@@ -3,7 +3,7 @@\n //! manage the caches, and so forth.\n \n use crate::{on_disk_cache, queries, Queries};\n-use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use rustc_middle::dep_graph::{DepKind, DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::ty::tls::{self, ImplicitCtxt};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_query_system::dep_graph::HasDepContext;\n@@ -53,36 +53,6 @@ impl QueryContext for QueryCtxt<'tcx> {\n         self.queries.try_collect_active_jobs(**self)\n     }\n \n-    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n-        let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n-        (cb.try_load_from_on_disk_cache)(**self, dep_node)\n-    }\n-\n-    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n-        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-\n-        // We must avoid ever having to call `force_from_dep_node()` for a\n-        // `DepNode::codegen_unit`:\n-        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-        // would always end up having to evaluate the first caller of the\n-        // `codegen_unit` query that *is* reconstructible. This might very well be\n-        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-        // to re-trigger calling the `codegen_unit` query with the right key. At\n-        // that point we would already have re-done all the work we are trying to\n-        // avoid doing in the first place.\n-        // The solution is simple: Just explicitly call the `codegen_unit` query for\n-        // each CGU, right after partitioning. This way `try_mark_green` will always\n-        // hit the cache instead of having to go through `force_from_dep_node`.\n-        // This assertion makes sure, we actually keep applying the solution above.\n-        debug_assert!(\n-            dep_node.kind != DepKind::codegen_unit,\n-            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-        );\n-\n-        let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n-        (cb.force_from_dep_node)(**self, dep_node)\n-    }\n-\n     // Interactions with on_disk_cache\n     fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects {\n         self.queries"}, {"sha": "228b405496719eaa74b7b163d9174ecb4128d7f9", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "patch": "@@ -576,7 +576,7 @@ impl<K: DepKind> DepGraph<K> {\n             \"try_mark_previous_green({:?}) --- trying to force dependency {:?}\",\n             dep_node, dep_dep_node\n         );\n-        if !tcx.try_force_from_dep_node(dep_dep_node) {\n+        if !tcx.dep_context().try_force_from_dep_node(dep_dep_node) {\n             // The DepNode could not be forced.\n             debug!(\n                 \"try_mark_previous_green({:?}) - END - dependency {:?} could not be forced\",\n@@ -741,16 +741,15 @@ impl<K: DepKind> DepGraph<K> {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<Ctxt: QueryContext<DepKind = K>>(&self, qcx: Ctxt) {\n-        let tcx = qcx.dep_context();\n+    pub fn exec_cache_promotions<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n         let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n         let data = self.data.as_ref().unwrap();\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n                     let dep_node = data.previous.index_to_node(prev_index);\n-                    qcx.try_load_from_on_disk_cache(&dep_node);\n+                    tcx.try_load_from_on_disk_cache(&dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {\n                     // We can skip red nodes because a node can only be marked"}, {"sha": "d7f7758d02cd2ed8423afc3ec429649dfb3e00a0", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "patch": "@@ -37,6 +37,12 @@ pub trait DepContext: Copy {\n     fn is_eval_always(&self, kind: Self::DepKind) -> bool;\n \n     fn fingerprint_style(&self, kind: Self::DepKind) -> FingerprintStyle;\n+\n+    /// Try to force a dep node to execute and see if it's green.\n+    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n+\n+    /// Load data from the on-disk cache.\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n }\n \n pub trait HasDepContext: Copy {"}, {"sha": "e2b0a65ab77b17e013cc3c088aa87efb13474955", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602d3cbce3e6227ad7cd5c009c868c9e405a9f32/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=602d3cbce3e6227ad7cd5c009c868c9e405a9f32", "patch": "@@ -14,7 +14,7 @@ pub use self::caches::{\n mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};\n \n-use crate::dep_graph::{DepNode, DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n \n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -122,12 +122,6 @@ pub trait QueryContext: HasDepContext {\n \n     fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind>>;\n \n-    /// Load data from the on-disk cache.\n-    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n-\n-    /// Try to force a dep node to execute and see if it's green.\n-    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n-\n     /// Load side effects associated to the node in the previous session.\n     fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects;\n "}]}