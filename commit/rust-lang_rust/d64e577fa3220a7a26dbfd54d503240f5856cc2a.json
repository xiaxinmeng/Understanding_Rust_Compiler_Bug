{"sha": "d64e577fa3220a7a26dbfd54d503240f5856cc2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NGU1NzdmYTMyMjBhN2EyNmRiZmQ1NGQ1MDMyNDBmNTg1NmNjMmE=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-06-19T04:18:10Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-06-22T05:38:05Z"}, "message": "Async methods", "tree": {"sha": "1ee76c45da9aab30c7c67c6156b0bf68c6c4d4b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee76c45da9aab30c7c67c6156b0bf68c6c4d4b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d64e577fa3220a7a26dbfd54d503240f5856cc2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d64e577fa3220a7a26dbfd54d503240f5856cc2a", "html_url": "https://github.com/rust-lang/rust/commit/d64e577fa3220a7a26dbfd54d503240f5856cc2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d64e577fa3220a7a26dbfd54d503240f5856cc2a/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d02631d3dfd71b446648fa1c8a41c9f099cf89f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d02631d3dfd71b446648fa1c8a41c9f099cf89f8", "html_url": "https://github.com/rust-lang/rust/commit/d02631d3dfd71b446648fa1c8a41c9f099cf89f8"}], "stats": {"total": 201, "additions": 122, "deletions": 79}, "files": [{"sha": "e694dc64ab3ce9e5d65901cc6d41e7cbd8001eac", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d64e577fa3220a7a26dbfd54d503240f5856cc2a", "patch": "@@ -2932,7 +2932,7 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::PassThrough,\n                     |this| {\n                         hir::TraitItemKind::Method(\n-                            this.lower_method_sig(sig, trait_item_def_id, false),\n+                            this.lower_method_sig(sig, trait_item_def_id, false, false),\n                             hir::TraitMethod::Required(names),\n                         )\n                     },\n@@ -2950,7 +2950,7 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::PassThrough,\n                     |this| {\n                         hir::TraitItemKind::Method(\n-                            this.lower_method_sig(sig, trait_item_def_id, false),\n+                            this.lower_method_sig(sig, trait_item_def_id, false, false),\n                             hir::TraitMethod::Provided(body_id),\n                         )\n                     },\n@@ -3021,8 +3021,18 @@ impl<'a> LoweringContext<'a> {\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n                 let body_id = self.lower_body(Some(&sig.decl), |this| {\n-                    let body = this.lower_block(body, false);\n-                    this.expr_block(body, ThinVec::new())\n+                    if let IsAsync::Async(async_node_id) = sig.header.asyncness {\n+                        let async_expr = this.make_async_expr(\n+                            CaptureBy::Value, async_node_id, None,\n+                            |this| {\n+                                let body = this.lower_block(body, false);\n+                                this.expr_block(body, ThinVec::new())\n+                            });\n+                        this.expr(body.span, async_expr, ThinVec::new())\n+                    } else {\n+                        let body = this.lower_block(body, false);\n+                        this.expr_block(body, ThinVec::new())\n+                    }\n                 });\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n \n@@ -3036,6 +3046,7 @@ impl<'a> LoweringContext<'a> {\n                                 sig,\n                                 impl_item_def_id,\n                                 impl_trait_return_allow,\n+                                sig.header.asyncness.is_async(),\n                             ),\n                             body_id,\n                         )\n@@ -3201,10 +3212,11 @@ impl<'a> LoweringContext<'a> {\n         sig: &MethodSig,\n         fn_def_id: DefId,\n         impl_trait_return_allow: bool,\n+        is_async: bool,\n     ) -> hir::MethodSig {\n         hir::MethodSig {\n             header: self.lower_fn_header(sig.header),\n-            decl: self.lower_fn_decl(&sig.decl, Some(fn_def_id), impl_trait_return_allow, false),\n+            decl: self.lower_fn_decl(&sig.decl, Some(fn_def_id), impl_trait_return_allow, is_async),\n         }\n     }\n "}, {"sha": "7c71401c8b2e8cbc6f54a734a70322ddcf9f303d", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d64e577fa3220a7a26dbfd54d503240f5856cc2a", "patch": "@@ -73,6 +73,27 @@ impl<'a> DefCollector<'a> {\n         self.parent_def = parent;\n     }\n \n+    fn visit_async_fn(\n+        &mut self,\n+        id: NodeId,\n+        async_node_id: NodeId,\n+        name: Name,\n+        span: Span,\n+        visit_fn: impl FnOnce(&mut DefCollector<'a>)\n+    ) {\n+        // For async functions, we need to create their inner defs inside of a\n+        // closure to match their desugared representation.\n+        let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n+        let fn_def = self.create_def(id, fn_def_data, ITEM_LIKE_SPACE, span);\n+        return self.with_parent(fn_def, |this| {\n+            let closure_def = this.create_def(async_node_id,\n+                                  DefPathData::ClosureExpr,\n+                                  REGULAR_SPACE,\n+                                  span);\n+            this.with_parent(closure_def, visit_fn)\n+        })\n+    }\n+\n     fn visit_macro_invoc(&mut self, id: NodeId) {\n         if let Some(ref mut visit) = self.visit_macro_invoc {\n             visit(MacroInvocationData {\n@@ -100,19 +121,13 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 return visit::walk_item(self, i);\n             }\n             ItemKind::Fn(_, FnHeader { asyncness: IsAsync::Async(async_node_id), .. }, ..) => {\n-                // For async functions, we need to create their inner defs inside of a\n-                // closure to match their desugared representation.\n-                let fn_def_data = DefPathData::ValueNs(i.ident.name.as_interned_str());\n-                let fn_def = self.create_def(i.id, fn_def_data, ITEM_LIKE_SPACE, i.span);\n-                return self.with_parent(fn_def, |this| {\n-                    let closure_def = this.create_def(async_node_id,\n-                                          DefPathData::ClosureExpr,\n-                                          REGULAR_SPACE,\n-                                          i.span);\n-                    this.with_parent(closure_def, |this| {\n-                        visit::walk_item(this, i);\n-                    })\n-                });\n+                return self.visit_async_fn(\n+                    i.id,\n+                    async_node_id,\n+                    i.ident.name,\n+                    i.span,\n+                    |this| visit::walk_item(this, i)\n+                )\n             }\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_interned_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n@@ -212,6 +227,17 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n+            ImplItemKind::Method(MethodSig {\n+                header: FnHeader { asyncness: IsAsync::Async(async_node_id), .. }, ..\n+            }, ..) => {\n+                return self.visit_async_fn(\n+                    ii.id,\n+                    async_node_id,\n+                    ii.ident.name,\n+                    ii.span,\n+                    |this| visit::walk_impl_item(this, ii)\n+                )\n+            }\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name.as_interned_str()),\n             ImplItemKind::Type(..) => DefPathData::AssocTypeInImpl(ii.ident.name.as_interned_str()),"}, {"sha": "7cdcdf4f0d109ccd579585b1182acb7b6492503a", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=d64e577fa3220a7a26dbfd54d503240f5856cc2a", "patch": "@@ -87,6 +87,13 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n+    fn check_trait_fn_not_async(&self, span: Span, asyncness: IsAsync) {\n+        if asyncness.is_async() {\n+            struct_span_err!(self.session, span, E0706,\n+                             \"trait fns cannot be declared `async`\").emit()\n+        }\n+    }\n+\n     fn check_trait_fn_not_const(&self, constness: Spanned<Constness>) {\n         match constness.node {\n             Constness::Const => {\n@@ -309,6 +316,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n+                        self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness);\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         if block.is_none() {\n                             self.check_decl_no_pat(&sig.decl, |span, mut_ident| {"}, {"sha": "f1ec3371c3b9ab0400bd0b3a60daecff1497dcd3", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=d64e577fa3220a7a26dbfd54d503240f5856cc2a", "patch": "@@ -310,4 +310,5 @@ register_diagnostics! {\n     E0666, // nested `impl Trait` is illegal\n     E0667, // `impl Trait` in projections\n     E0696, // `continue` pointing to a labeled block\n+    E0706, // `async fn` in trait\n }"}, {"sha": "26e6e80ce1861bd6b49a2d8eeb45d15cd8abdbb7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 52, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d64e577fa3220a7a26dbfd54d503240f5856cc2a", "patch": "@@ -746,15 +746,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 function_kind: FnKind<'tcx>,\n                 declaration: &'tcx FnDecl,\n                 _: Span,\n-                node_id: NodeId) {\n-        let rib_kind = match function_kind {\n-            FnKind::ItemFn(..) => {\n-                ItemRibKind\n-            }\n-            FnKind::Method(_, _, _, _) => {\n-                TraitOrImplItemRibKind\n-            }\n-            FnKind::Closure(_) => ClosureRibKind(node_id),\n+                node_id: NodeId)\n+    {\n+        let (rib_kind, asyncness) = match function_kind {\n+            FnKind::ItemFn(_, ref header, ..) =>\n+                (ItemRibKind, header.asyncness),\n+            FnKind::Method(_, ref sig, _, _) =>\n+                (TraitOrImplItemRibKind, sig.header.asyncness),\n+            FnKind::Closure(_) =>\n+                // Async closures aren't resolved through `visit_fn`-- they're\n+                // processed separately\n+                (ClosureRibKind(node_id), IsAsync::NotAsync),\n         };\n \n         // Create a value rib for the function.\n@@ -774,7 +776,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         }\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n-        // Resolve the function body.\n+        // Resolve the function body, potentially inside the body of an async closure\n+        if let IsAsync::Async(async_closure_id) = asyncness {\n+            let rib_kind = ClosureRibKind(async_closure_id);\n+            self.ribs[ValueNS].push(Rib::new(rib_kind));\n+            self.label_ribs.push(Rib::new(rib_kind));\n+        }\n+\n         match function_kind {\n             FnKind::ItemFn(.., body) |\n             FnKind::Method(.., body) => {\n@@ -785,6 +793,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             }\n         };\n \n+        // Leave the body of the async closure\n+        if asyncness.is_async() {\n+            self.label_ribs.pop();\n+            self.ribs[ValueNS].pop();\n+        }\n+\n         debug!(\"(resolving function) leaving function\");\n \n         self.label_ribs.pop();\n@@ -2054,47 +2068,6 @@ impl<'a> Resolver<'a> {\n         self.check_proc_macro_attrs(&item.attrs);\n \n         match item.node {\n-            ItemKind::Fn(ref declaration,\n-                         FnHeader { asyncness: IsAsync::Async(async_closure_id), .. },\n-                         ref generics,\n-                         ref body) => {\n-                // Async functions are desugared from `async fn foo() { .. }`\n-                // to `fn foo() { future_from_generator(move || ... ) }`,\n-                // so we have to visit the body inside the closure scope\n-                self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n-                    this.visit_vis(&item.vis);\n-                    this.visit_ident(item.ident);\n-                    this.visit_generics(generics);\n-                    let rib_kind = ItemRibKind;\n-                    this.ribs[ValueNS].push(Rib::new(rib_kind));\n-                    this.label_ribs.push(Rib::new(rib_kind));\n-                    let mut bindings_list = FxHashMap();\n-                    for argument in &declaration.inputs {\n-                        this.resolve_pattern(\n-                            &argument.pat, PatternSource::FnParam, &mut bindings_list);\n-                        this.visit_ty(&*argument.ty);\n-                    }\n-                    visit::walk_fn_ret_ty(this, &declaration.output);\n-\n-                    // Now resolve the inner closure\n-                    {\n-                        let rib_kind = ClosureRibKind(async_closure_id);\n-                        this.ribs[ValueNS].push(Rib::new(rib_kind));\n-                        this.label_ribs.push(Rib::new(rib_kind));\n-                        // No need to resolve either arguments nor return type,\n-                        // as this closure has neither\n-\n-                        // Resolve the body\n-                        this.visit_block(body);\n-                        this.label_ribs.pop();\n-                        this.ribs[ValueNS].pop();\n-                    }\n-                    this.label_ribs.pop();\n-                    this.ribs[ValueNS].pop();\n-\n-                    walk_list!(this, visit_attribute, &item.attrs);\n-                })\n-            }\n             ItemKind::Enum(_, ref generics) |\n             ItemKind::Ty(_, ref generics) |\n             ItemKind::Struct(_, ref generics) |\n@@ -2415,7 +2388,7 @@ impl<'a> Resolver<'a> {\n                                                 visit::walk_impl_item(this, impl_item)\n                                             );\n                                         }\n-                                        ImplItemKind::Method(_, _) => {\n+                                        ImplItemKind::Method(..) => {\n                                             // If this is a trait impl, ensure the method\n                                             // exists in trait\n                                             this.check_trait_item(impl_item.ident,"}, {"sha": "e59efcd68575ff8642b72163386ca5176b44f3a5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d64e577fa3220a7a26dbfd54d503240f5856cc2a", "patch": "@@ -1293,6 +1293,15 @@ impl<'a> Parser<'a> {\n         })))\n     }\n \n+    /// Parse asyncness: `async` or nothing\n+    fn parse_asyncness(&mut self) -> IsAsync {\n+        if self.eat_keyword(keywords::Async) {\n+            IsAsync::Async(ast::DUMMY_NODE_ID)\n+        } else {\n+            IsAsync::NotAsync\n+        }\n+    }\n+\n     /// Parse unsafety: `unsafe` or nothing.\n     fn parse_unsafety(&mut self) -> Unsafety {\n         if self.eat_keyword(keywords::Unsafe) {\n@@ -1342,7 +1351,7 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n         } else {\n-            let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n \n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n@@ -1360,7 +1369,7 @@ impl<'a> Parser<'a> {\n                     unsafety,\n                     constness,\n                     abi,\n-                    asyncness: IsAsync::NotAsync,\n+                    asyncness,\n                 },\n                 decl: d,\n             };\n@@ -5425,10 +5434,18 @@ impl<'a> Parser<'a> {\n     /// - `const unsafe fn`\n     /// - `extern fn`\n     /// - etc\n-    fn parse_fn_front_matter(&mut self) -> PResult<'a, (Spanned<Constness>, Unsafety, Abi)> {\n+    fn parse_fn_front_matter(&mut self)\n+        -> PResult<'a, (\n+            Spanned<Constness>,\n+            Unsafety,\n+            IsAsync,\n+            Abi\n+        )>\n+    {\n         let is_const_fn = self.eat_keyword(keywords::Const);\n         let const_span = self.prev_span;\n         let unsafety = self.parse_unsafety();\n+        let asyncness = self.parse_asyncness();\n         let (constness, unsafety, abi) = if is_const_fn {\n             (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n         } else {\n@@ -5440,7 +5457,7 @@ impl<'a> Parser<'a> {\n             (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n         };\n         self.expect_keyword(keywords::Fn)?;\n-        Ok((constness, unsafety, abi))\n+        Ok((constness, unsafety, asyncness, abi))\n     }\n \n     /// Parse an impl item.\n@@ -5575,14 +5592,14 @@ impl<'a> Parser<'a> {\n             Ok((keywords::Invalid.ident(), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n             let decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n             generics.where_clause = self.parse_where_clause()?;\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-            let header = ast::FnHeader { abi, unsafety, constness, asyncness: IsAsync::NotAsync };\n+            let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n             Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(\n                 ast::MethodSig { header, decl },\n                 body"}, {"sha": "817db4bb79ec3a4a586b49cea88bef37731fc259", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=d64e577fa3220a7a26dbfd54d503240f5856cc2a", "patch": "@@ -104,10 +104,16 @@ unsafe async fn unsafe_async_fn(x: u8) -> u8 {\n     x\n }\n \n-struct Foo {\n+struct Foo;\n+\n+trait Bar {\n+    fn foo() {}\n+}\n+\n+impl Foo {\n     async fn async_method(x: u8) -> u8 {\n         unsafe {\n-            await!(unsafe_async_fn())\n+            await!(unsafe_async_fn(x))\n         }\n     }\n }"}, {"sha": "085b9499a416bd2ca347365d2bbcaa21cbf78864", "filename": "src/test/ui/async-fn-multiple-lifetimes.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d64e577fa3220a7a26dbfd54d503240f5856cc2a/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr?ref=d64e577fa3220a7a26dbfd54d503240f5856cc2a", "patch": "@@ -6,7 +6,7 @@ LL | async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n    |                                               |\n    |                                               first lifetime here\n    |\n-   = help: `async fn` can only accept borrowed values identical lifetimes\n+   = help: `async fn` can only accept borrowed values with identical lifetimes\n \n error[E0704]: multiple elided lifetimes used in arguments of `async fn`\n   --> $DIR/async-fn-multiple-lifetimes.rs:26:39"}]}