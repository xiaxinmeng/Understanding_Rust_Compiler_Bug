{"sha": "6d99a2f8a99baedab90fb8bd6cb6e1507fad736b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkOTlhMmY4YTk5YmFlZGFiOTBmYjhiZDZjYjZlMTUwN2ZhZDczNmI=", "commit": {"author": {"name": "Jesse Jones", "email": "jesse9jones@gmail.com", "date": "2012-11-17T18:13:11Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-18T21:25:26Z"}, "message": "Made more stuff pure.\n\nescape functions in char, io.with_str_reader, base64 and md5sum, cell.empty_cell\nand is_empty.", "tree": {"sha": "543df1adb01550cf549166c515312cf04c168b24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/543df1adb01550cf549166c515312cf04c168b24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b", "html_url": "https://github.com/rust-lang/rust/commit/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/comments", "author": {"login": "jesse99", "id": 425055, "node_id": "MDQ6VXNlcjQyNTA1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/425055?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jesse99", "html_url": "https://github.com/jesse99", "followers_url": "https://api.github.com/users/jesse99/followers", "following_url": "https://api.github.com/users/jesse99/following{/other_user}", "gists_url": "https://api.github.com/users/jesse99/gists{/gist_id}", "starred_url": "https://api.github.com/users/jesse99/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jesse99/subscriptions", "organizations_url": "https://api.github.com/users/jesse99/orgs", "repos_url": "https://api.github.com/users/jesse99/repos", "events_url": "https://api.github.com/users/jesse99/events{/privacy}", "received_events_url": "https://api.github.com/users/jesse99/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15989ecb139a4ee4a53e6657fd4fc8cee9d729de", "url": "https://api.github.com/repos/rust-lang/rust/commits/15989ecb139a4ee4a53e6657fd4fc8cee9d729de", "html_url": "https://github.com/rust-lang/rust/commit/15989ecb139a4ee4a53e6657fd4fc8cee9d729de"}], "stats": {"total": 206, "additions": 105, "deletions": 101}, "files": [{"sha": "802aaf12bdd48586813dc5776c40e411fe8b7e3a", "filename": "src/libcore/char.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=6d99a2f8a99baedab90fb8bd6cb6e1507fad736b", "patch": "@@ -126,16 +126,18 @@ pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n  *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n  *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n  */\n-pub fn escape_unicode(c: char) -> ~str {\n+pub pure fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n                     else { ('U', 8u) });\n     assert str::len(s) <= pad;\n     let mut out = ~\"\\\\\";\n-    str::push_str(&mut out, str::from_char(c));\n-    for uint::range(str::len(s), pad) |_i| { str::push_str(&mut out, ~\"0\"); }\n-    str::push_str(&mut out, s);\n+    unsafe {\n+        str::push_str(&mut out, str::from_char(c));\n+        for uint::range(str::len(s), pad) |_i| { str::push_str(&mut out, ~\"0\"); }\n+        str::push_str(&mut out, s);\n+    }\n     move out\n }\n \n@@ -151,7 +153,7 @@ pub fn escape_unicode(c: char) -> ~str {\n  *   - Any other chars in the range [0x20,0x7e] are not escaped.\n  *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n  */\n-pub fn escape_default(c: char) -> ~str {\n+pub pure fn escape_default(c: char) -> ~str {\n     match c {\n       '\\t' => ~\"\\\\t\",\n       '\\r' => ~\"\\\\r\","}, {"sha": "535ab883581bb72a53fca6d9d580e23c68c258a7", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=6d99a2f8a99baedab90fb8bd6cb6e1507fad736b", "patch": "@@ -512,7 +512,7 @@ pub pure fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n     f(BytesReader { bytes: bytes, pos: 0u } as Reader)\n }\n \n-pub fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n+pub pure fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n     str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\n }\n "}, {"sha": "177074de8f65a0a5b6905a317256aba1bbf29b5b", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 88, "deletions": 86, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=6d99a2f8a99baedab90fb8bd6cb6e1507fad736b", "patch": "@@ -2,72 +2,73 @@\n use io::Reader;\n \n pub trait ToBase64 {\n-    fn to_base64() -> ~str;\n+    pure fn to_base64() -> ~str;\n }\n \n impl &[u8]: ToBase64 {\n-    fn to_base64() -> ~str {\n+    pure fn to_base64() -> ~str {\n         let chars = str::chars(\n           ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n         );\n \n-        let len = self.len();\n         let mut s = ~\"\";\n-        str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n-\n-        let mut i = 0u;\n-\n-        while i < len - (len % 3u) {\n-            let n = (self[i] as uint) << 16u |\n-                    (self[i + 1u] as uint) << 8u |\n-                    (self[i + 2u] as uint);\n-\n-            // This 24-bit number gets separated into four 6-bit numbers.\n-            str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n-            str::push_char(&mut s, chars[n & 63u]);\n-\n-            i += 3u;\n-        }\n-\n-        // Heh, would be cool if we knew this was exhaustive\n-        // (the dream of bounded integer types)\n-        match len % 3 {\n-          0 => (),\n-          1 => {\n-            let n = (self[i] as uint) << 16u;\n-            str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, '=');\n-            str::push_char(&mut s, '=');\n-          }\n-          2 => {\n-            let n = (self[i] as uint) << 16u | (self[i + 1u] as uint) << 8u;\n-            str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n-            str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n-            str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n-            str::push_char(&mut s, '=');\n-          }\n-          _ => fail ~\"Algebra is broken, please alert the math police\"\n+        unsafe {\n+            let len = self.len();\n+            str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n+    \n+            let mut i = 0u;\n+    \n+            while i < len - (len % 3u) {\n+                let n = (self[i] as uint) << 16u |\n+                        (self[i + 1u] as uint) << 8u |\n+                        (self[i + 2u] as uint);\n+    \n+                // This 24-bit number gets separated into four 6-bit numbers.\n+                str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n+                str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n+                str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n+                str::push_char(&mut s, chars[n & 63u]);\n+    \n+                i += 3u;\n+            }\n+    \n+            // Heh, would be cool if we knew this was exhaustive\n+            // (the dream of bounded integer types)\n+            match len % 3 {\n+              0 => (),\n+              1 => {\n+                let n = (self[i] as uint) << 16u;\n+                str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n+                str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n+                str::push_char(&mut s, '=');\n+                str::push_char(&mut s, '=');\n+              }\n+              2 => {\n+                let n = (self[i] as uint) << 16u | (self[i + 1u] as uint) << 8u;\n+                str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n+                str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n+                str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n+                str::push_char(&mut s, '=');\n+              }\n+              _ => fail ~\"Algebra is broken, please alert the math police\"\n+            }\n         }\n-\n         s\n     }\n }\n \n impl &str: ToBase64 {\n-    fn to_base64() -> ~str {\n+    pure fn to_base64() -> ~str {\n         str::to_bytes(self).to_base64()\n     }\n }\n \n pub trait FromBase64 {\n-    fn from_base64() -> ~[u8];\n+    pure fn from_base64() -> ~[u8];\n }\n \n impl ~[u8]: FromBase64 {\n-    fn from_base64() -> ~[u8] {\n+    pure fn from_base64() -> ~[u8] {\n         if self.len() % 4u != 0u { fail ~\"invalid base64 length\"; }\n \n         let len = self.len();\n@@ -80,55 +81,56 @@ impl ~[u8]: FromBase64 {\n \n         let mut r = vec::with_capacity((len / 4u) * 3u - padding);\n \n-        let mut i = 0u;\n-        while i < len {\n-            let mut n = 0u;\n-\n-            for iter::repeat(4u) {\n-                let ch = self[i] as char;\n-                n <<= 6u;\n-\n-                if ch >= 'A' && ch <= 'Z' {\n-                    n |= (ch as uint) - 0x41u;\n-                } else if ch >= 'a' && ch <= 'z' {\n-                    n |= (ch as uint) - 0x47u;\n-                } else if ch >= '0' && ch <= '9' {\n-                    n |= (ch as uint) + 0x04u;\n-                } else if ch == '+' {\n-                    n |= 0x3Eu;\n-                } else if ch == '/' {\n-                    n |= 0x3Fu;\n-                } else if ch == '=' {\n-                    match len - i {\n-                      1u => {\n-                        r.push(((n >> 16u) & 0xFFu) as u8);\n-                        r.push(((n >> 8u ) & 0xFFu) as u8);\n-                        return copy r;\n-                      }\n-                      2u => {\n-                        r.push(((n >> 10u) & 0xFFu) as u8);\n-                        return copy r;\n-                      }\n-                      _ => fail ~\"invalid base64 padding\"\n+        unsafe {\n+            let mut i = 0u;\n+            while i < len {\n+                let mut n = 0u;\n+    \n+                for iter::repeat(4u) {\n+                    let ch = self[i] as char;\n+                    n <<= 6u;\n+    \n+                    if ch >= 'A' && ch <= 'Z' {\n+                        n |= (ch as uint) - 0x41u;\n+                    } else if ch >= 'a' && ch <= 'z' {\n+                        n |= (ch as uint) - 0x47u;\n+                    } else if ch >= '0' && ch <= '9' {\n+                        n |= (ch as uint) + 0x04u;\n+                    } else if ch == '+' {\n+                        n |= 0x3Eu;\n+                    } else if ch == '/' {\n+                        n |= 0x3Fu;\n+                    } else if ch == '=' {\n+                        match len - i {\n+                          1u => {\n+                            r.push(((n >> 16u) & 0xFFu) as u8);\n+                            r.push(((n >> 8u ) & 0xFFu) as u8);\n+                            return copy r;\n+                          }\n+                          2u => {\n+                            r.push(((n >> 10u) & 0xFFu) as u8);\n+                            return copy r;\n+                          }\n+                          _ => fail ~\"invalid base64 padding\"\n+                        }\n+                    } else {\n+                        fail ~\"invalid base64 character\";\n                     }\n-                } else {\n-                    fail ~\"invalid base64 character\";\n-                }\n-\n-                i += 1u;\n-            };\n-\n-            r.push(((n >> 16u) & 0xFFu) as u8);\n-            r.push(((n >> 8u ) & 0xFFu) as u8);\n-            r.push(((n       ) & 0xFFu) as u8);\n+    \n+                    i += 1u;\n+                };\n+    \n+                r.push(((n >> 16u) & 0xFFu) as u8);\n+                r.push(((n >> 8u ) & 0xFFu) as u8);\n+                r.push(((n       ) & 0xFFu) as u8);\n+            }\n         }\n-\n         r\n     }\n }\n \n impl ~str: FromBase64 {\n-    fn from_base64() -> ~[u8] {\n+    pure fn from_base64() -> ~[u8] {\n         str::to_bytes(self).from_base64()\n     }\n }"}, {"sha": "78027aa8907601621b0bd3f3b1370766e7e704c7", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=6d99a2f8a99baedab90fb8bd6cb6e1507fad736b", "patch": "@@ -12,7 +12,7 @@ pub fn Cell<T>(value: T) -> Cell<T> {\n     Cell { value: Some(move value) }\n }\n \n-pub fn empty_cell<T>() -> Cell<T> {\n+pub pure fn empty_cell<T>() -> Cell<T> {\n     Cell { value: None }\n }\n \n@@ -37,7 +37,7 @@ impl<T> Cell<T> {\n     }\n \n     /// Returns true if the cell is empty and false if the cell is full.\n-    fn is_empty() -> bool {\n+    pure fn is_empty() -> bool {\n         self.value.is_none()\n     }\n "}, {"sha": "d9bc03c311de724dd5ad12e324d5fa299dc432d6", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d99a2f8a99baedab90fb8bd6cb6e1507fad736b/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=6d99a2f8a99baedab90fb8bd6cb6e1507fad736b", "patch": "@@ -1,6 +1,6 @@\n #[forbid(deprecated_mode)];\n \n-pub fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n+pub pure fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     // subtle: if orig_len is merely uint, then the code below\n     // which performs shifts by 32 bits or more has undefined\n     // results.\n@@ -10,14 +10,14 @@ pub fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     let mut msg = vec::append(vec::from_slice(msg), ~[0x80u8]);\n     let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n-        msg.push(0u8);\n+        unsafe {msg.push(0u8);}\n         bitlen += 8u64;\n     }\n \n     // append length\n     let mut i = 0u64;\n     while i < 8u64 {\n-        msg.push((orig_len >> (i * 8u64)) as u8);\n+        unsafe {msg.push((orig_len >> (i * 8u64)) as u8);}\n         i += 1u64;\n     }\n \n@@ -26,7 +26,7 @@ pub fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     let mut c = 0x98badcfeu32;\n     let mut d = 0x10325476u32;\n \n-    fn rot(r: int, x: u32) -> u32 {\n+    pure fn rot(r: int, x: u32) -> u32 {\n         let r = r as u32;\n         (x << r) | (x >> (32u32 - r))\n     }\n@@ -84,9 +84,9 @@ pub fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     return {a: a, b: b, c: c, d: d};\n }\n \n-pub fn md4_str(msg: &[u8]) -> ~str {\n+pub pure fn md4_str(msg: &[u8]) -> ~str {\n     let {a, b, c, d} = md4(msg);\n-    fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n+    pure fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n         f(a); f(b); f(c); f(d);\n     }\n     let mut result = ~\"\";\n@@ -102,7 +102,7 @@ pub fn md4_str(msg: &[u8]) -> ~str {\n     result\n }\n \n-pub fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n+pub pure fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {"}]}