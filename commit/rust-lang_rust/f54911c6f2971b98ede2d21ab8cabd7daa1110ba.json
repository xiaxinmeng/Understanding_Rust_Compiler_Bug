{"sha": "f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NDkxMWM2ZjI5NzFiOThlZGUyZDIxYWI4Y2FiZDdkYWExMTEwYmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-15T23:09:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-15T23:09:33Z"}, "message": "Auto merge of #65454 - tmandry:rollup-0k6jiik, r=tmandry\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #64603 (Reducing spurious unused lifetime warnings.)\n - #64623 (Remove last uses of gensyms)\n - #65235 (don't assume we can *always* find a return type hint in async fn)\n - #65242 (Fix suggestion to constrain trait for method to be found)\n - #65265 (Cleanup librustc mir err codes)\n - #65293 (Optimize `try_expand_impl_trait_type`)\n - #65307 (Try fix incorrect \"explicit lifetime name needed\")\n - #65308 (Add long error explanation for E0574)\n - #65353 (save-analysis: Don't ICE when resolving qualified type paths in struct members)\n - #65389 (Return `false` from `needs_drop` for all zero-sized arrays.)\n - #65402 (Add troubleshooting section to PGO chapter in rustc book.)\n - #65425 (Optimize `BitIter`)\n - #65438 (Organize `never_type`  tests)\n - #65444 (Implement AsRef<[T]> for List<T>)\n\nFailed merges:\n\n - #65390 (Add long error explanation for E0576)\n\nr? @ghost", "tree": {"sha": "0bfed6eb4c88f90e5fb9d035e08890279a903b0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bfed6eb4c88f90e5fb9d035e08890279a903b0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "html_url": "https://github.com/rust-lang/rust/commit/f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "237d54ff6c4fb3577e02d4c5af02813c11b63d01", "url": "https://api.github.com/repos/rust-lang/rust/commits/237d54ff6c4fb3577e02d4c5af02813c11b63d01", "html_url": "https://github.com/rust-lang/rust/commit/237d54ff6c4fb3577e02d4c5af02813c11b63d01"}, {"sha": "3182f73e8dcce702bbfd330a28c9a35610d0af8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3182f73e8dcce702bbfd330a28c9a35610d0af8e", "html_url": "https://github.com/rust-lang/rust/commit/3182f73e8dcce702bbfd330a28c9a35610d0af8e"}], "stats": {"total": 1602, "additions": 1095, "deletions": 507}, "files": [{"sha": "d066f4a9cf59c1040c8691b803b3d650f399944c", "filename": "src/doc/rustc/src/profile-guided-optimization.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -125,6 +125,17 @@ RUSTFLAGS=\"-Cprofile-use=/tmp/pgo-data/merged.profdata\" \\\n     cargo build --release --target=x86_64-unknown-linux-gnu\n ```\n \n+### Troubleshooting\n+\n+- It is recommended to pass `-Cllvm-args=-pgo-warn-missing-function` during the\n+  `-Cprofile-use` phase. LLVM by default does not warn if it cannot find\n+  profiling data for a given function. Enabling this warning will make it\n+  easier to spot errors in your setup.\n+\n+- There is a [known issue](https://github.com/rust-lang/cargo/issues/7416) in\n+  Cargo prior to version 1.39 that will prevent PGO from working correctly. Be\n+  sure to use Cargo 1.39 or newer when doing PGO.\n+\n ## Further Reading\n \n `rustc`'s PGO support relies entirely on LLVM's implementation of the feature"}, {"sha": "e9788a558124ac0bd952159829b358af3276fce3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -3291,10 +3291,14 @@ impl<'a> LoweringContext<'a> {\n                 let id = self.sess.next_node_id();\n                 self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n             }\n-            // This is the normal case.\n-            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n-\n-            AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n+            // `PassThrough` is the normal case.\n+            // `new_error_lifetime`, which would usually be used in the case of `ReportError`,\n+            // is unsuitable here, as these can occur from missing lifetime parameters in a\n+            // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n+            // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n+            // later, at which point a suitable error will be emitted.\n+          | AnonymousLifetimeMode::PassThrough\n+          | AnonymousLifetimeMode::ReportError => self.new_implicit_lifetime(span),\n         }\n     }\n "}, {"sha": "a122d84a5aa7ec84481f8a675d758075cb36723c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -708,15 +708,22 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (name, reg) = Region::early(&self.tcx.hir(), &mut index, &param);\n+                            let def_id = if let Region::EarlyBound(_ ,def_id , _) = reg {\n+                                def_id\n+                            } else {\n+                                bug!();\n+                            };\n                             if let hir::ParamName::Plain(param_name) = name {\n                                 if param_name.name == kw::UnderscoreLifetime {\n                                     // Pick the elided lifetime \"definition\" if one exists\n                                     // and use it to make an elision scope.\n+                                    self.lifetime_uses.insert(def_id.clone(), LifetimeUseSet::Many);\n                                     elision = Some(reg);\n                                 } else {\n                                     lifetimes.insert(name, reg);\n                                 }\n                             } else {\n+                                self.lifetime_uses.insert(def_id.clone(), LifetimeUseSet::Many);\n                                 lifetimes.insert(name, reg);\n                             }\n                         }\n@@ -1615,7 +1622,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         _ => None,\n                     } {\n                         debug!(\"id = {:?} span = {:?} name = {:?}\", id, span, name);\n-\n                         if name.name == kw::UnderscoreLifetime {\n                             continue;\n                         }"}, {"sha": "65aea7b459f83f908bf31c612479a5f58e21972c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -701,6 +701,13 @@ impl<T> Deref for List<T> {\n     type Target = [T];\n     #[inline(always)]\n     fn deref(&self) -> &[T] {\n+        self.as_ref()\n+    }\n+}\n+\n+impl<T> AsRef<[T]> for List<T> {\n+    #[inline(always)]\n+    fn as_ref(&self) -> &[T] {\n         unsafe {\n             slice::from_raw_parts(self.data.as_ptr(), self.len)\n         }"}, {"sha": "363109a0582df603c46fcea2c271505dabd1cfe6", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1483,7 +1483,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         }\n \n         // Replace any anonymous late-bound regions with named\n-        // variants, using gensym'd identifiers, so that we can\n+        // variants, using new unique identifiers, so that we can\n         // clearly differentiate between named and unnamed regions in\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give."}, {"sha": "e1eab2c6579e1892df943f0629e79e34541b7220", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -697,6 +697,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             // that type, and when we finish expanding that type we remove the\n             // its DefId.\n             seen_opaque_tys: FxHashSet<DefId>,\n+            // Cache of all expansions we've seen so far. This is a critical\n+            // optimization for some large types produced by async fn trees.\n+            expanded_cache: FxHashMap<(DefId, SubstsRef<'tcx>), Ty<'tcx>>,\n             primary_def_id: DefId,\n             found_recursion: bool,\n             tcx: TyCtxt<'tcx>,\n@@ -713,9 +716,16 @@ impl<'tcx> TyCtxt<'tcx> {\n                 }\n                 let substs = substs.fold_with(self);\n                 if self.seen_opaque_tys.insert(def_id) {\n-                    let generic_ty = self.tcx.type_of(def_id);\n-                    let concrete_ty = generic_ty.subst(self.tcx, substs);\n-                    let expanded_ty = self.fold_ty(concrete_ty);\n+                    let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n+                        Some(expanded_ty) => expanded_ty,\n+                        None => {\n+                            let generic_ty = self.tcx.type_of(def_id);\n+                            let concrete_ty = generic_ty.subst(self.tcx, substs);\n+                            let expanded_ty = self.fold_ty(concrete_ty);\n+                            self.expanded_cache.insert((def_id, substs), expanded_ty);\n+                            expanded_ty\n+                        }\n+                    };\n                     self.seen_opaque_tys.remove(&def_id);\n                     Some(expanded_ty)\n                 } else {\n@@ -735,14 +745,17 @@ impl<'tcx> TyCtxt<'tcx> {\n             fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Opaque(def_id, substs) = t.kind {\n                     self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n-                } else {\n+                } else if t.has_projections() {\n                     t.super_fold_with(self)\n+                } else {\n+                    t\n                 }\n             }\n         }\n \n         let mut visitor = OpaqueTypeExpander {\n             seen_opaque_tys: FxHashSet::default(),\n+            expanded_cache: FxHashMap::default(),\n             primary_def_id: def_id,\n             found_recursion: false,\n             tcx: self,\n@@ -1096,6 +1109,9 @@ fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>\n \n         ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n \n+        // Zero-length arrays never contain anything to drop.\n+        ty::Array(_, len) if len.try_eval_usize(tcx, param_env) == Some(0) => false,\n+\n         // Structural recursion.\n         ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n "}, {"sha": "d8c6e4c33e2faaad6b57a25ebe60846d32ed32f3", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -168,11 +168,7 @@ impl<T: Idx> BitSet<T> {\n     /// Iterates over the indices of set bits in a sorted order.\n     #[inline]\n     pub fn iter(&self) -> BitIter<'_, T> {\n-        BitIter {\n-            cur: None,\n-            iter: self.words.iter().enumerate(),\n-            marker: PhantomData,\n-        }\n+        BitIter::new(&self.words)\n     }\n \n     /// Duplicates the set as a hybrid set.\n@@ -291,26 +287,55 @@ impl<T: Idx> ToString for BitSet<T> {\n }\n \n pub struct BitIter<'a, T: Idx> {\n-    cur: Option<(Word, usize)>,\n-    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n+    /// A copy of the current word, but with any already-visited bits cleared.\n+    /// (This lets us use `trailing_zeros()` to find the next set bit.) When it\n+    /// is reduced to 0, we move onto the next word.\n+    word: Word,\n+\n+    /// The offset (measured in bits) of the current word.\n+    offset: usize,\n+\n+    /// Underlying iterator over the words.\n+    iter: slice::Iter<'a, Word>,\n+\n     marker: PhantomData<T>\n }\n \n+impl<'a, T: Idx> BitIter<'a, T> {\n+    #[inline]\n+    fn new(words: &'a [Word]) -> BitIter<'a, T> {\n+        // We initialize `word` and `offset` to degenerate values. On the first\n+        // call to `next()` we will fall through to getting the first word from\n+        // `iter`, which sets `word` to the first word (if there is one) and\n+        // `offset` to 0. Doing it this way saves us from having to maintain\n+        // additional state about whether we have started.\n+        BitIter {\n+            word: 0,\n+            offset: std::usize::MAX - (WORD_BITS - 1),\n+            iter: words.iter(),\n+            marker: PhantomData,\n+        }\n+    }\n+}\n+\n impl<'a, T: Idx> Iterator for BitIter<'a, T> {\n     type Item = T;\n     fn next(&mut self) -> Option<T> {\n         loop {\n-            if let Some((ref mut word, offset)) = self.cur {\n-                let bit_pos = word.trailing_zeros() as usize;\n-                if bit_pos != WORD_BITS {\n-                    let bit = 1 << bit_pos;\n-                    *word ^= bit;\n-                    return Some(T::new(bit_pos + offset))\n-                }\n+            if self.word != 0 {\n+                // Get the position of the next set bit in the current word,\n+                // then clear the bit.\n+                let bit_pos = self.word.trailing_zeros() as usize;\n+                let bit = 1 << bit_pos;\n+                self.word ^= bit;\n+                return Some(T::new(bit_pos + self.offset))\n             }\n \n-            let (i, word) = self.iter.next()?;\n-            self.cur = Some((*word, WORD_BITS * i));\n+            // Move onto the next word. `wrapping_add()` is needed to handle\n+            // the degenerate initial value given to `offset` in `new()`.\n+            let word = self.iter.next()?;\n+            self.word = *word;\n+            self.offset = self.offset.wrapping_add(WORD_BITS);\n         }\n     }\n }\n@@ -851,11 +876,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     pub fn iter(&self, row: R) -> BitIter<'_, C> {\n         assert!(row.index() < self.num_rows);\n         let (start, end) = self.range(row);\n-        BitIter {\n-            cur: None,\n-            iter: self.words[start..end].iter().enumerate(),\n-            marker: PhantomData,\n-        }\n+        BitIter::new(&self.words[start..end])\n     }\n \n     /// Returns the number of elements in `row`."}, {"sha": "bc09e327179268e12f351bae0c8030252497fee5", "filename": "src/librustc_mir/dataflow/impls/indirect_mutation.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -104,25 +104,16 @@ impl<'tcx> TransferFunction<'_, '_, 'tcx> {\n         kind: mir::BorrowKind,\n         borrowed_place: &mir::Place<'tcx>,\n     ) -> bool {\n-        let borrowed_ty = borrowed_place.ty(self.body, self.tcx).ty;\n-\n-        // Zero-sized types cannot be mutated, since there is nothing inside to mutate.\n-        //\n-        // FIXME: For now, we only exempt arrays of length zero. We need to carefully\n-        // consider the effects before extending this to all ZSTs.\n-        if let ty::Array(_, len) = borrowed_ty.kind {\n-            if len.try_eval_usize(self.tcx, self.param_env) == Some(0) {\n-                return false;\n-            }\n-        }\n-\n         match kind {\n             mir::BorrowKind::Mut { .. } => true,\n \n             | mir::BorrowKind::Shared\n             | mir::BorrowKind::Shallow\n             | mir::BorrowKind::Unique\n-            => !borrowed_ty.is_freeze(self.tcx, self.param_env, DUMMY_SP),\n+            => !borrowed_place\n+                .ty(self.body, self.tcx)\n+                .ty\n+                .is_freeze(self.tcx, self.param_env, DUMMY_SP),\n         }\n     }\n }"}, {"sha": "419c905cb5127a070530064f1b056b4630f7cb21", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 275, "deletions": 230, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -64,7 +64,9 @@ E0004: r##\"\n This error indicates that the compiler cannot guarantee a matching pattern for\n one or more possible inputs to a match expression. Guaranteed matches are\n required in order to assign values to match expressions, or alternatively,\n-determine the flow of execution. Erroneous code example:\n+determine the flow of execution.\n+\n+Erroneous code example:\n \n ```compile_fail,E0004\n enum Terminator {\n@@ -109,7 +111,9 @@ match x {\n \n E0005: r##\"\n Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases. Erroneous code example:\n+that a name will be extracted in all cases.\n+\n+Erroneous code example:\n \n ```compile_fail,E0005\n let x = Some(1);\n@@ -145,6 +149,8 @@ like the following is invalid as it requires the entire `Option<String>` to be\n moved into a variable called `op_string` while simultaneously requiring the\n inner `String` to be moved into a variable called `s`.\n \n+Erroneous code example:\n+\n ```compile_fail,E0007\n let x = Some(\"s\".to_string());\n \n@@ -208,15 +214,130 @@ match x {\n ```\n \"##,\n \n+E0010: r##\"\n+The value of statics and constants must be known at compile time, and they live\n+for the entire lifetime of a program. Creating a boxed value allocates memory on\n+the heap at runtime, and therefore cannot be done at compile time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0010\n+#![feature(box_syntax)]\n+\n+const CON : Box<i32> = box 0;\n+```\n+\"##,\n+\n+E0013: r##\"\n+Static and const variables can refer to other const variables. But a const\n+variable cannot refer to a static variable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0013\n+static X: i32 = 42;\n+const Y: i32 = X;\n+```\n+\n+In this example, `Y` cannot refer to `X` here. To fix this, the value can be\n+extracted as a const and then used:\n+\n+```\n+const A: i32 = 42;\n+static X: i32 = A;\n+const Y: i32 = A;\n+```\n+\"##,\n+\n+// FIXME(#57563) Change the language here when const fn stabilizes\n+E0015: r##\"\n+The only functions that can be called in static or constant expressions are\n+`const` functions, and struct/enum constructors. `const` functions are only\n+available on a nightly compiler. Rust currently does not support more general\n+compile-time function execution.\n+\n+```\n+const FOO: Option<u8> = Some(1); // enum constructor\n+struct Bar {x: u8}\n+const BAR: Bar = Bar {x: 1}; // struct constructor\n+```\n+\n+See [RFC 911] for more details on the design of `const fn`s.\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n+\"##,\n+\n+E0017: r##\"\n+References in statics and constants may only refer to immutable values.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0017\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`.\n+\"##,\n+\n+E0019: r##\"\n+A function call isn't allowed in the const's initialization expression\n+because the expression's value must be known at compile-time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0019\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    struct MyOwned;\n+\n+    static STATIC11: Box<MyOwned> = box MyOwned; // error!\n+}\n+```\n+\n+Remember: you can't use a function call inside a const's initialization\n+expression! However, you can totally use it anywhere else:\n+\n+```\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn func(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    FOO.func(); // here is good\n+    let x = FOO.func(); // or even here!\n+}\n+```\n+\"##,\n+\n E0030: r##\"\n When matching against a range, the compiler verifies that the range is\n-non-empty.  Range patterns include both end-points, so this is equivalent to\n+non-empty. Range patterns include both end-points, so this is equivalent to\n requiring the start of the range to be less than or equal to the end of the\n range.\n \n-For example:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0030\n match 5u32 {\n     // This range is ok, albeit pointless.\n     1 ..= 1 => {}\n@@ -226,7 +347,61 @@ match 5u32 {\n ```\n \"##,\n \n+E0133: r##\"\n+Unsafe code was used outside of an unsafe function or block.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0133\n+unsafe fn f() { return; } // This is the unsafe code\n+\n+fn main() {\n+    f(); // error: call to unsafe function requires unsafe function or block\n+}\n+```\n+\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n+\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n+\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n+\n+```\n+unsafe fn f() { return; }\n+\n+fn main() {\n+    unsafe { f(); } // ok!\n+}\n+```\n+\n+See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n+\"##,\n+\n E0158: r##\"\n+An associated const has been referenced in a pattern.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0158\n+enum EFoo { A, B, C, D }\n+\n+trait Foo {\n+    const X: EFoo;\n+}\n+\n+fn test<A: Foo>(arg: EFoo) {\n+    match arg {\n+        A::X => { // error!\n+            println!(\"A::X\");\n+        }\n+    }\n+}\n+```\n+\n `const` and `static` mean different things. A `const` is a compile-time\n constant, an alias for a literal value. This property means you can match it\n directly within a pattern.\n@@ -247,6 +422,39 @@ match Some(42) {\n ```\n \"##,\n \n+E0161: r##\"\n+A value was moved. However, its size was not known at compile time, and only\n+values of a known size can be moved.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0161\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<[isize]> = box *array;\n+    // error: cannot move a value of type [isize]: the size of [isize] cannot\n+    //        be statically determined\n+}\n+```\n+\n+In Rust, you can only move a value when its size is known at compile time.\n+\n+To work around this restriction, consider \"hiding\" the value behind a reference:\n+either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n+it around as usual. Example:\n+\n+```\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<&[isize]> = box array; // ok!\n+}\n+```\n+\"##,\n+\n E0162: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -468,158 +676,6 @@ The `op_string_ref` binding has type `&Option<&String>` in both cases.\n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n \n-E0010: r##\"\n-The value of statics and constants must be known at compile time, and they live\n-for the entire lifetime of a program. Creating a boxed value allocates memory on\n-the heap at runtime, and therefore cannot be done at compile time. Erroneous\n-code example:\n-\n-```compile_fail,E0010\n-#![feature(box_syntax)]\n-\n-const CON : Box<i32> = box 0;\n-```\n-\"##,\n-\n-E0013: r##\"\n-Static and const variables can refer to other const variables. But a const\n-variable cannot refer to a static variable. For example, `Y` cannot refer to\n-`X` here:\n-\n-```compile_fail,E0013\n-static X: i32 = 42;\n-const Y: i32 = X;\n-```\n-\n-To fix this, the value can be extracted as a const and then used:\n-\n-```\n-const A: i32 = 42;\n-static X: i32 = A;\n-const Y: i32 = A;\n-```\n-\"##,\n-\n-// FIXME(#57563) Change the language here when const fn stabilizes\n-E0015: r##\"\n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors. `const` functions are only\n-available on a nightly compiler. Rust currently does not support more general\n-compile-time function execution.\n-\n-```\n-const FOO: Option<u8> = Some(1); // enum constructor\n-struct Bar {x: u8}\n-const BAR: Bar = Bar {x: 1}; // struct constructor\n-```\n-\n-See [RFC 911] for more details on the design of `const fn`s.\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0017: r##\"\n-References in statics and constants may only refer to immutable values.\n-Erroneous code example:\n-\n-```compile_fail,E0017\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-// these three are not allowed:\n-const CR: &mut i32 = &mut C;\n-static STATIC_REF: &'static mut i32 = &mut X;\n-static CONST_REF: &'static mut i32 = &mut C;\n-```\n-\n-Statics are shared everywhere, and if they refer to mutable data one might\n-violate memory safety since holding multiple mutable references to shared data\n-is not allowed.\n-\n-If you really want global mutable state, try using `static mut` or a global\n-`UnsafeCell`.\n-\"##,\n-\n-E0019: r##\"\n-A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time. Erroneous code\n-example:\n-\n-```compile_fail\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn test(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    const A: i32 = FOO.test(); // You can't call Test::func() here!\n-}\n-```\n-\n-Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it anywhere else:\n-\n-```\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn func(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    FOO.func(); // here is good\n-    let x = FOO.func(); // or even here!\n-}\n-```\n-\"##,\n-\n-E0133: r##\"\n-Unsafe code was used outside of an unsafe function or block.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0133\n-unsafe fn f() { return; } // This is the unsafe code\n-\n-fn main() {\n-    f(); // error: call to unsafe function requires unsafe function or block\n-}\n-```\n-\n-Using unsafe functionality is potentially dangerous and disallowed by safety\n-checks. Examples:\n-\n-* Dereferencing raw pointers\n-* Calling functions via FFI\n-* Calling functions marked unsafe\n-\n-These safety checks can be relaxed for a section of the code by wrapping the\n-unsafe instructions with an `unsafe` block. For instance:\n-\n-```\n-unsafe fn f() { return; }\n-\n-fn main() {\n-    unsafe { f(); } // ok!\n-}\n-```\n-\n-See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n-\"##,\n-\n E0373: r##\"\n This error occurs when an attempt is made to use data captured by a closure,\n when that data may no longer exist. It's most commonly seen when attempting to\n@@ -672,7 +728,9 @@ about safety.\n \"##,\n \n E0381: r##\"\n-It is not allowed to use or capture an uninitialized variable. For example:\n+It is not allowed to use or capture an uninitialized variable.\n+\n+Erroneous code example:\n \n ```compile_fail,E0381\n fn main() {\n@@ -694,7 +752,9 @@ fn main() {\n \n E0382: r##\"\n This error occurs when an attempt is made to use a variable after its contents\n-have been moved elsewhere. For example:\n+have been moved elsewhere.\n+\n+Erroneous code example:\n \n ```compile_fail,E0382\n struct MyStruct { s: u32 }\n@@ -842,7 +902,8 @@ x = Foo { a: 2 };\n \n E0384: r##\"\n This error occurs when an attempt is made to reassign an immutable variable.\n-For example:\n+\n+Erroneous code example:\n \n ```compile_fail,E0384\n fn main() {\n@@ -862,13 +923,15 @@ fn main() {\n ```\n \"##,\n \n-/*E0386: r##\"\n+E0386: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n This error occurs when an attempt is made to mutate the target of a mutable\n reference stored inside an immutable container.\n \n For example, this can happen when storing a `&mut` inside an immutable `Box`:\n \n-```compile_fail,E0386\n+```\n let mut x: i64 = 1;\n let y: Box<_> = Box::new(&mut x);\n **y = 2; // error, cannot assign to data in an immutable container\n@@ -892,13 +955,15 @@ let x: i64 = 1;\n let y: Box<Cell<_>> = Box::new(Cell::new(x));\n y.set(2);\n ```\n-\"##,*/\n+\"##,\n \n E0387: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n This error occurs when an attempt is made to mutate or mutably reference data\n-that a closure has captured immutably. Examples of this error are shown below:\n+that a closure has captured immutably.\n+\n+Erroneous code example:\n \n ```compile_fail\n // Accepts a function or a closure that captures its environment immutably.\n@@ -963,7 +1028,7 @@ An attempt was made to mutate data using a non-mutable reference. This\n commonly occurs when attempting to assign to a non-mutable reference of a\n mutable reference (`&(&mut T)`).\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail\n struct FancyNum {\n@@ -1022,43 +1087,11 @@ fn main() {\n ```\n \"##,\n \n-E0161: r##\"\n-A value was moved. However, its size was not known at compile time, and only\n-values of a known size can be moved.\n+E0492: r##\"\n+A borrow of a constant containing interior mutability was attempted.\n \n Erroneous code example:\n \n-```compile_fail\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<[isize]> = box *array;\n-    // error: cannot move a value of type [isize]: the size of [isize] cannot\n-    //        be statically determined\n-}\n-```\n-\n-In Rust, you can only move a value when its size is known at compile time.\n-\n-To work around this restriction, consider \"hiding\" the value behind a reference:\n-either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n-it around as usual. Example:\n-\n-```\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<&[isize]> = box array; // ok!\n-}\n-```\n-\"##,\n-\n-E0492: r##\"\n-A borrow of a constant containing interior mutability was attempted. Erroneous\n-code example:\n-\n ```compile_fail,E0492\n use std::sync::atomic::AtomicUsize;\n \n@@ -1174,7 +1207,9 @@ static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields\n \"##,\n \n E0499: r##\"\n-A variable was borrowed as mutable more than once. Erroneous code example:\n+A variable was borrowed as mutable more than once.\n+\n+Erroneous code example:\n \n ```compile_fail,E0499\n let mut i = 0;\n@@ -1205,7 +1240,9 @@ a;\n \"##,\n \n E0500: r##\"\n-A borrowed variable was used by a closure. Example of erroneous code:\n+A borrowed variable was used by a closure.\n+\n+Erroneous code example:\n \n ```compile_fail,E0500\n fn you_know_nothing(jon_snow: &mut i32) {\n@@ -1256,7 +1293,7 @@ situation, the closure is borrowing the variable. Take a look at\n http://rustbyexample.com/fn/closures/capture.html for more information about\n capturing.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0501\n fn inside_closure(x: &mut i32) {\n@@ -1329,7 +1366,7 @@ E0502: r##\"\n This error indicates that you are trying to borrow a variable as mutable when it\n has already been borrowed as immutable.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0502\n fn bar(x: &mut i32) {}\n@@ -1360,7 +1397,7 @@ https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.\n E0503: r##\"\n A value was used after it was mutably borrowed.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0503\n fn main() {\n@@ -1418,7 +1455,7 @@ E0504: r##\"\n This error occurs when an attempt is made to move a borrowed variable into a\n closure.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail\n struct FancyNum {\n@@ -1609,7 +1646,7 @@ http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n E0506: r##\"\n This error occurs when an attempt is made to assign to a borrowed value.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0506\n struct FancyNum {\n@@ -1827,7 +1864,7 @@ http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n E0508: r##\"\n A value was moved out of a non-copy fixed-size array.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0508\n struct NonCopy;\n@@ -1872,7 +1909,7 @@ E0509: r##\"\n This error occurs when an attempt is made to move out of a value whose type\n implements the `Drop` trait.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0509\n struct FancyNum {\n@@ -1982,30 +2019,14 @@ Here executing `x = None` would modify the value being matched and require us\n to go \"back in time\" to the `None` arm.\n \"##,\n \n-E0579: r##\"\n-When matching against an exclusive range, the compiler verifies that the range\n-is non-empty. Exclusive range patterns include the start point but not the end\n-point, so this is equivalent to requiring the start of the range to be less\n-than the end of the range.\n-\n-For example:\n-\n-```compile_fail\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 .. 2 => {}\n-    // This range is empty, and the compiler can tell.\n-    5 .. 5 => {}\n-}\n-```\n-\"##,\n-\n E0515: r##\"\n Cannot return value that references local variable\n \n Local variables, function parameters and temporaries are all dropped before the\n end of the function body. So a reference to them cannot be returned.\n \n+Erroneous code example:\n+\n ```compile_fail,E0515\n fn get_dangling_reference() -> &'static i32 {\n     let x = 0;\n@@ -2101,6 +2122,28 @@ fn dragoooon(x: &mut isize) {\n ```\n \"##,\n \n+E0579: r##\"\n+When matching against an exclusive range, the compiler verifies that the range\n+is non-empty. Exclusive range patterns include the start point but not the end\n+point, so this is equivalent to requiring the start of the range to be less\n+than the end of the range.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0579\n+#![feature(exclusive_range_pattern)]\n+\n+fn main() {\n+    match 5u32 {\n+        // This range is ok, albeit pointless.\n+        1 .. 2 => {}\n+        // This range is empty, and the compiler can tell.\n+        5 .. 5 => {} // error!\n+    }\n+}\n+```\n+\"##,\n+\n E0595: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -2124,7 +2167,7 @@ let mut c = || { x += 1 };\n E0596: r##\"\n This error occurs because you tried to mutably borrow a non-mutable variable.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0596\n let x = 1;\n@@ -2143,7 +2186,7 @@ let y = &mut x; // ok!\n E0597: r##\"\n This error occurs because a value was dropped while it was still borrowed\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0597\n struct Foo<'a> {\n@@ -2180,6 +2223,8 @@ E0626: r##\"\n This error occurs because a borrow in a generator persists across a\n yield point.\n \n+Erroneous code example:\n+\n ```compile_fail,E0626\n # #![feature(generators, generator_trait, pin)]\n # use std::ops::Generator;\n@@ -2271,7 +2316,7 @@ E0712: r##\"\n This error occurs because a borrow of a thread-local variable was made inside a\n function which outlived the lifetime of the function.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0712\n #![feature(thread_local)]\n@@ -2293,7 +2338,7 @@ E0713: r##\"\n This error occurs when an attempt is made to borrow state past the end of the\n lifetime of a type that implements the `Drop` trait.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0713\n #![feature(nll)]"}, {"sha": "0d5361fe8d84b599283ccec09dee95acf0bb6db3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -94,7 +94,8 @@ impl<'a> Resolver<'a> {\n         where T: ToNameBinding<'a>,\n     {\n         let binding = def.to_name_binding(self.arenas);\n-        if let Err(old_binding) = self.try_define(parent, ident, ns, binding) {\n+        let key = self.new_key(ident, ns);\n+        if let Err(old_binding) = self.try_define(parent, key, binding) {\n             self.report_conflict(parent, ident, ns, old_binding, &binding);\n         }\n     }\n@@ -349,9 +350,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n         self.r.indeterminate_imports.push(directive);\n         match directive.subclass {\n+            // Don't add unresolved underscore imports to modules\n+            SingleImport { target: Ident { name: kw::Underscore, .. }, .. } => {}\n             SingleImport { target, type_ns_only, .. } => {\n                 self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n+                    let key = this.new_key(target, ns);\n+                    let mut resolution = this.resolution(current_module, key).borrow_mut();\n                     resolution.add_single_import(directive);\n                 });\n             }\n@@ -407,7 +411,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         };\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n-                let mut ident = use_tree.ident().gensym_if_underscore();\n+                let mut ident = use_tree.ident();\n                 let mut module_path = prefix;\n                 let mut source = module_path.pop().unwrap();\n                 let mut type_ns_only = false;\n@@ -585,7 +589,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let parent_scope = &self.parent_scope;\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n-        let ident = item.ident.gensym_if_underscore();\n+        let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n@@ -851,10 +855,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<NodeId>) {\n         let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n-        // FIXME: We shouldn't create the gensym here, it should come from metadata,\n-        // but metadata cannot encode gensyms currently, so we create it here.\n-        // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n-        let ident = ident.gensym_if_underscore();\n         let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n         // Record primary definitions.\n         match res {"}, {"sha": "de8758086709f16111abc78acae82dd618502330", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -80,11 +80,11 @@ impl<'a> Resolver<'a> {\n         names: &mut Vec<TypoSuggestion>,\n         filter_fn: &impl Fn(Res) -> bool,\n     ) {\n-        for (&(ident, _), resolution) in self.resolutions(module).borrow().iter() {\n+        for (key, resolution) in self.resolutions(module).borrow().iter() {\n             if let Some(binding) = resolution.borrow().binding {\n                 let res = binding.res();\n                 if filter_fn(res) {\n-                    names.push(TypoSuggestion::from_res(ident.name, res));\n+                    names.push(TypoSuggestion::from_res(key.ident.name, res));\n                 }\n             }\n         }\n@@ -849,7 +849,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         let resolutions = self.r.resolutions(crate_module).borrow();\n-        let resolution = resolutions.get(&(ident, MacroNS))?;\n+        let resolution = resolutions.get(&self.r.new_key(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();"}, {"sha": "1e65cbada069d8f785a2507c2aaef1013f57c9ec", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1611,6 +1611,56 @@ fn print_on_failure(state: &State) {\n ```\n \"##,\n \n+E0574: r##\"\n+Something other than a struct, variant or union has been used when one was\n+expected.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0574\n+mod Mordor {}\n+\n+let sauron = Mordor { x: () }; // error!\n+\n+enum Jak {\n+    Daxter { i: isize },\n+}\n+\n+let eco = Jak::Daxter { i: 1 };\n+match eco {\n+    Jak { i } => {} // error!\n+}\n+```\n+\n+In all these errors, a type was expected. For example, in the first error,\n+we tried to instantiate the `Mordor` module, which is impossible. If you want\n+to instantiate a type inside a module, you can do it as follow:\n+\n+```\n+mod Mordor {\n+    pub struct TheRing {\n+        pub x: usize,\n+    }\n+}\n+\n+let sauron = Mordor::TheRing { x: 1 }; // ok!\n+```\n+\n+In the second error, we tried to bind the `Jak` enum directly, which is not\n+possible: you can only bind one of its variants. To do so:\n+\n+```\n+enum Jak {\n+    Daxter { i: isize },\n+}\n+\n+let eco = Jak::Daxter { i: 1 };\n+match eco {\n+    Jak::Daxter { i } => {} // ok!\n+}\n+```\n+\"##,\n+\n E0603: r##\"\n A private item was used outside its scope.\n \n@@ -1739,7 +1789,6 @@ struct Foo<X = Box<Self>> {\n //  E0467, removed\n //  E0470, removed\n     E0573,\n-    E0574,\n     E0575,\n     E0576,\n     E0577,"}, {"sha": "e5b0ef89a417f042ac06a7e1ded6438ece4c3f91", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -432,7 +432,22 @@ impl ModuleKind {\n     }\n }\n \n-type Resolutions<'a> = RefCell<FxIndexMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>;\n+/// A key that identifies a binding in a given `Module`.\n+///\n+/// Multiple bindings in the same module can have the same key (in a valid\n+/// program) if all but one of them come from glob imports.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+struct BindingKey {\n+    /// The identifier for the binding, aways the `modern` version of the\n+    /// identifier.\n+    ident: Ident,\n+    ns: Namespace,\n+    /// 0 if ident is not `_`, otherwise a value that's unique to the specific\n+    /// `_` in the expanded AST that introduced this binding.\n+    disambiguator: u32,\n+}\n+\n+type Resolutions<'a> = RefCell<FxIndexMap<BindingKey, &'a RefCell<NameResolution<'a>>>>;\n \n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n@@ -492,8 +507,8 @@ impl<'a> ModuleData<'a> {\n     fn for_each_child<R, F>(&'a self, resolver: &mut R, mut f: F)\n         where R: AsMut<Resolver<'a>>, F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>)\n     {\n-        for (&(ident, ns), name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(resolver, ident, ns, binding));\n+        for (key, name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(resolver, key.ident, key.ns, binding));\n         }\n     }\n \n@@ -882,6 +897,7 @@ pub struct Resolver<'a> {\n     module_map: FxHashMap<DefId, Module<'a>>,\n     extern_module_map: FxHashMap<DefId, Module<'a>>,\n     binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n+    underscore_disambiguator: u32,\n \n     /// Maps glob imports to the names of items actually imported.\n     pub glob_map: GlobMap,\n@@ -1160,6 +1176,7 @@ impl<'a> Resolver<'a> {\n             extern_crate_map: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n+            underscore_disambiguator: 0,\n             empty_module,\n             module_map,\n             block_map: Default::default(),\n@@ -1284,6 +1301,17 @@ impl<'a> Resolver<'a> {\n         self.arenas.alloc_module(module)\n     }\n \n+    fn new_key(&mut self, ident: Ident, ns: Namespace) -> BindingKey {\n+        let ident = ident.modern();\n+        let disambiguator = if ident.name == kw::Underscore {\n+            self.underscore_disambiguator += 1;\n+            self.underscore_disambiguator\n+        } else {\n+            0\n+        };\n+        BindingKey { ident, ns, disambiguator }\n+    }\n+\n     fn resolutions(&mut self, module: Module<'a>) -> &'a Resolutions<'a> {\n         if module.populate_on_access.get() {\n             module.populate_on_access.set(false);\n@@ -1292,9 +1320,9 @@ impl<'a> Resolver<'a> {\n         &module.lazy_resolutions\n     }\n \n-    fn resolution(&mut self, module: Module<'a>, ident: Ident, ns: Namespace)\n+    fn resolution(&mut self, module: Module<'a>, key: BindingKey)\n                   -> &'a RefCell<NameResolution<'a>> {\n-        *self.resolutions(module).borrow_mut().entry((ident.modern(), ns))\n+        *self.resolutions(module).borrow_mut().entry(key)\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n "}, {"sha": "56fd2da2576fbf8c68745cf0c7b5068816fb7bb7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -7,7 +7,7 @@ use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolver, ResolutionError, Segment, ModuleKind};\n+use crate::{Resolver, ResolutionError, BindingKey, Segment, ModuleKind};\n use crate::{names_to_string, module_to_string};\n use crate::diagnostics::Suggestion;\n \n@@ -235,7 +235,8 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let resolution = self.resolution(module, ident, ns)\n+        let key = self.new_key(ident, ns);\n+        let resolution = self.resolution(module, key)\n             .try_borrow_mut()\n             .map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n@@ -447,17 +448,16 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define(\n+    crate fn try_define(\n         &mut self,\n         module: Module<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n+        key: BindingKey,\n         binding: &'a NameBinding<'a>,\n     ) -> Result<(), &'a NameBinding<'a>> {\n         let res = binding.res();\n-        self.check_reserved_macro_name(ident, res);\n+        self.check_reserved_macro_name(key.ident, res);\n         self.set_binding_parent_module(binding, module);\n-        self.update_resolution(module, ident, ns, |this, resolution| {\n+        self.update_resolution(module, key, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if res == Res::Err {\n                     // Do not override real bindings with `Res::Err`s from error recovery.\n@@ -479,8 +479,9 @@ impl<'a> Resolver<'a> {\n                         } else {\n                             (binding, old_binding)\n                         };\n-                        if glob_binding.res() != nonglob_binding.res() &&\n-                           ns == MacroNS && nonglob_binding.expansion != ExpnId::root() {\n+                        if glob_binding.res() != nonglob_binding.res()\n+                            && key.ns == MacroNS && nonglob_binding.expansion != ExpnId::root()\n+                        {\n                             resolution.binding = Some(this.ambiguity(\n                                 AmbiguityKind::GlobVsExpanded,\n                                 nonglob_binding,\n@@ -499,9 +500,9 @@ impl<'a> Resolver<'a> {\n                                 DUPLICATE_MACRO_EXPORTS,\n                                 CRATE_NODE_ID,\n                                 binding.span,\n-                                &format!(\"a macro named `{}` has already been exported\", ident),\n+                                &format!(\"a macro named `{}` has already been exported\", key.ident),\n                                 BuiltinLintDiagnostics::DuplicatedMacroExports(\n-                                    ident, old_binding.span, binding.span));\n+                                    key.ident, old_binding.span, binding.span));\n \n                             resolution.binding = Some(binding);\n                         } else {\n@@ -531,17 +532,17 @@ impl<'a> Resolver<'a> {\n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(\n-        &mut self, module: Module<'a>,\n-        ident: Ident,\n-        ns: Namespace,\n+        &mut self,\n+        module: Module<'a>,\n+        key: BindingKey,\n         f: F,\n     ) -> T\n         where F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T\n     {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n         let (binding, t) = {\n-            let resolution = &mut *self.resolution(module, ident, ns).borrow_mut();\n+            let resolution = &mut *self.resolution(module, key).borrow_mut();\n             let old_binding = resolution.binding();\n \n             let t = f(self, resolution);\n@@ -558,15 +559,16 @@ impl<'a> Resolver<'a> {\n \n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n-            let mut ident = ident.modern();\n+            let mut ident = key.ident;\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n             if self.is_accessible_from(binding.vis, scope) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n+                let key = BindingKey { ident, ..key };\n+                let _ = self.try_define(directive.parent_scope.module, key, imported_binding);\n             }\n         }\n \n@@ -580,7 +582,8 @@ impl<'a> Resolver<'a> {\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n             self.per_ns(|this, ns| {\n-                let _ = this.try_define(directive.parent_scope.module, target, ns, dummy_binding);\n+                let key = this.new_key(target, ns);\n+                let _ = this.try_define(directive.parent_scope.module, key, dummy_binding);\n                 // Consider erroneous imports used to avoid duplicate diagnostics.\n                 this.record_use(target, ns, dummy_binding, false);\n             });\n@@ -820,8 +823,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             let parent = directive.parent_scope.module;\n             match source_bindings[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n+                // Don't update the resolution, because it was never added.\n+                Err(Determined) if target.name == kw::Underscore => {}\n                 Err(Determined) => {\n-                    this.update_resolution(parent, target, ns, |_, resolution| {\n+                    let key = this.new_key(target, ns);\n+                    this.update_resolution(parent, key, |_, resolution| {\n                         resolution.single_imports.remove(&PtrKey(directive));\n                     });\n                 }\n@@ -1052,7 +1058,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n-                let names = resolutions.filter_map(|(&(ref i, _), resolution)| {\n+                let names = resolutions.filter_map(|(BindingKey { ident: i, .. }, resolution)| {\n                     if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n                         NameResolution { binding: Some(name_binding), .. } => {\n@@ -1301,19 +1307,18 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(ident, resolution)| {\n-            resolution.borrow().binding().map(|binding| (*ident, binding))\n+        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(key, resolution)| {\n+            resolution.borrow().binding().map(|binding| (*key, binding))\n         }).collect::<Vec<_>>();\n-        for ((mut ident, ns), binding) in bindings {\n-            let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n+        for (mut key, binding) in bindings {\n+            let scope = match key.ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n                 Some(Some(def)) => self.r.macro_def_scope(def),\n                 Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n             if self.r.is_accessible_from(binding.pseudo_vis(), scope) {\n                 let imported_binding = self.r.import(binding, directive);\n-                let _ =\n-                    self.r.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n+                let _ = self.r.try_define(directive.parent_scope.module, key, imported_binding);\n             }\n         }\n \n@@ -1329,29 +1334,23 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n \n-        for (&(ident, ns), resolution) in self.r.resolutions(module).borrow().iter() {\n-            let resolution = &mut *resolution.borrow_mut();\n-            let binding = match resolution.binding {\n-                Some(binding) => binding,\n-                None => continue,\n-            };\n-\n+        module.for_each_child(self.r, |this, ident, ns, binding| {\n             // Filter away ambiguous imports and anything that has def-site\n             // hygiene.\n             // FIXME: Implement actual cross-crate hygiene.\n             let is_good_import = binding.is_import() && !binding.is_ambiguity()\n-                && !ident.span.modern().from_expansion();\n+                && !ident.span.from_expansion();\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {\n                     if let Some(def_id) = res.opt_def_id() {\n                         if !def_id.is_local() {\n-                            self.r.cstore.export_macros_untracked(def_id.krate);\n+                            this.cstore.export_macros_untracked(def_id.krate);\n                         }\n                     }\n                     reexports.push(Export {\n-                        ident: ident.modern(),\n-                        res: res,\n+                        ident,\n+                        res,\n                         span: binding.span,\n                         vis: binding.vis,\n                     });\n@@ -1360,7 +1359,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n                 if ns == TypeNS && orig_binding.is_variant() &&\n-                    !orig_binding.vis.is_at_least(binding.vis, &*self) {\n+                    !orig_binding.vis.is_at_least(binding.vis, &*this) {\n                         let msg = match directive.subclass {\n                             ImportDirectiveSubclass::SingleImport { .. } => {\n                                 format!(\"variant `{}` is private and cannot be re-exported\",\n@@ -1372,41 +1371,42 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n                                                 Some(binding.span),\n                                                 msg.clone());\n-                                let fresh = self.r.session.one_time_diagnostics\n+                                let fresh = this.session.one_time_diagnostics\n                                     .borrow_mut().insert(error_id);\n                                 if !fresh {\n-                                    continue;\n+                                    return;\n                                 }\n                                 msg\n                             },\n                             ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n                         };\n-                        let mut err = self.r.session.struct_span_err(binding.span, &msg);\n+                        let mut err = this.session.struct_span_err(binding.span, &msg);\n \n                         let imported_module = match directive.imported_module.get() {\n                             Some(ModuleOrUniformRoot::Module(module)) => module,\n                             _ => bug!(\"module should exist\"),\n                         };\n                         let parent_module = imported_module.parent.expect(\"parent should exist\");\n-                        let resolutions = self.r.resolutions(parent_module).borrow();\n+                        let resolutions = this.resolutions(parent_module).borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n                         let enum_ident = directive.module_path[enum_path_segment_index].ident;\n \n-                        let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n+                        let key = this.new_key(enum_ident, TypeNS);\n+                        let enum_resolution = resolutions.get(&key)\n                             .expect(\"resolution should exist\");\n                         let enum_span = enum_resolution.borrow()\n                             .binding.expect(\"binding should exist\")\n                             .span;\n-                        let enum_def_span = self.r.session.source_map().def_span(enum_span);\n-                        let enum_def_snippet = self.r.session.source_map()\n+                        let enum_def_span = this.session.source_map().def_span(enum_span);\n+                        let enum_def_snippet = this.session.source_map()\n                             .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n                         // potentially need to strip extant `crate`/`pub(path)` for suggestion\n                         let after_vis_index = enum_def_snippet.find(\"enum\")\n                             .expect(\"`enum` keyword should exist in snippet\");\n                         let suggestion = format!(\"pub {}\",\n                                                  &enum_def_snippet[after_vis_index..]);\n \n-                        self.r.session\n+                        this.session\n                             .diag_span_suggestion_once(&mut err,\n                                                        DiagnosticMessageId::ErrorId(0),\n                                                        enum_def_span,\n@@ -1415,7 +1415,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         err.emit();\n                 }\n             }\n-        }\n+        });\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {"}, {"sha": "502ae337b52768b3b68ea2978d98229fd6b07d18", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -115,15 +115,17 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         F: FnOnce(&mut Self),\n     {\n         let item_def_id = self.tcx.hir().local_def_id_from_node_id(item_id);\n-        if self.tcx.has_typeck_tables(item_def_id) {\n-            let tables = self.tcx.typeck_tables_of(item_def_id);\n-            let old_tables = self.save_ctxt.tables;\n-            self.save_ctxt.tables = tables;\n-            f(self);\n-            self.save_ctxt.tables = old_tables;\n+\n+        let tables = if self.tcx.has_typeck_tables(item_def_id) {\n+            self.tcx.typeck_tables_of(item_def_id)\n         } else {\n-            f(self);\n-        }\n+            self.save_ctxt.empty_tables\n+        };\n+\n+        let old_tables = self.save_ctxt.tables;\n+        self.save_ctxt.tables = tables;\n+        f(self);\n+        self.save_ctxt.tables = old_tables;\n     }\n \n     fn span_from_span(&self, span: Span) -> SpanData {\n@@ -530,12 +532,14 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             );\n         }\n \n-        for field in def.fields() {\n-            self.process_struct_field_def(field, item.id);\n-            self.visit_ty(&field.ty);\n-        }\n+        self.nest_tables(item.id, |v| {\n+            for field in def.fields() {\n+                v.process_struct_field_def(field, item.id);\n+                v.visit_ty(&field.ty);\n+            }\n \n-        self.process_generic_params(ty_params, &qualname, item.id);\n+            v.process_generic_params(ty_params, &qualname, item.id);\n+        });\n     }\n \n     fn process_enum("}, {"sha": "1cfb84bb511e4b4ca5c8c16d73235790f35b4db8", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -48,6 +48,9 @@ use log::{debug, error, info};\n pub struct SaveContext<'l, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'l ty::TypeckTables<'tcx>,\n+    /// Used as a fallback when nesting the typeck tables during item processing\n+    /// (if these are not available for that item, e.g. don't own a body)\n+    empty_tables: &'l ty::TypeckTables<'tcx>,\n     access_levels: &'l AccessLevels,\n     span_utils: SpanUtils<'tcx>,\n     config: Config,\n@@ -1114,6 +1117,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n         let save_ctxt = SaveContext {\n             tcx,\n             tables: &ty::TypeckTables::empty(None),\n+            empty_tables: &ty::TypeckTables::empty(None),\n             access_levels: &access_levels,\n             span_utils: SpanUtils::new(&tcx.sess),\n             config: find_config(config),"}, {"sha": "4f4133954cf1d359e7b51f33bab81c980f77f0af", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -611,6 +611,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn)) => {\n                     debug!(\"supplied_sig_of_closure: closure is async fn body\");\n                     self.deduce_future_output_from_obligations(expr_def_id)\n+                        .unwrap_or_else(|| {\n+                            // AFAIK, deducing the future output\n+                            // always succeeds *except* in error cases\n+                            // like #65159. I'd like to return Error\n+                            // here, but I can't because I can't\n+                            // easily (and locally) prove that we\n+                            // *have* reported an\n+                            // error. --nikomatsakis\n+                            astconv.ty_infer(None, decl.output.span())\n+                        })\n                 }\n \n                 _ => astconv.ty_infer(None, decl.output.span()),\n@@ -645,7 +655,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn deduce_future_output_from_obligations(\n         &self,\n         expr_def_id: DefId,\n-    ) -> Ty<'tcx> {\n+    ) -> Option<Ty<'tcx>> {\n         debug!(\"deduce_future_output_from_obligations(expr_def_id={:?})\", expr_def_id);\n \n         let ret_coercion =\n@@ -688,8 +698,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     None\n                 }\n-            })\n-            .unwrap();\n+            });\n \n         debug!(\"deduce_future_output_from_obligations: output_ty={:?}\", output_ty);\n         output_ty"}, {"sha": "f2d001eadedde1cf9c543479a9795b38185d8b6d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 70, "deletions": 43, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -777,19 +777,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 \"items from traits can only be used if the trait is implemented and in scope\"\n             });\n-            let mut msg = format!(\n+            let message = |action| format!(\n                 \"the following {traits_define} an item `{name}`, perhaps you need to {action} \\\n                  {one_of_them}:\",\n                 traits_define = if candidates.len() == 1 {\n                     \"trait defines\"\n                 } else {\n                     \"traits define\"\n                 },\n-                action = if let Some(param) = param_type {\n-                    format!(\"restrict type parameter `{}` with\", param)\n-                } else {\n-                    \"implement\".to_string()\n-                },\n+                action = action,\n                 one_of_them = if candidates.len() == 1 {\n                     \"it\"\n                 } else {\n@@ -809,50 +805,81 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // Get the `hir::Param` to verify whether it already has any bounds.\n                         // We do this to avoid suggesting code that ends up as `T: FooBar`,\n                         // instead we suggest `T: Foo + Bar` in that case.\n-                        let mut has_bounds = None;\n-                        let mut impl_trait = false;\n-                        if let Node::GenericParam(ref param) = hir.get(id) {\n-                            let kind = &param.kind;\n-                            if let hir::GenericParamKind::Type { synthetic: Some(_), .. } = kind {\n-                                // We've found `fn foo(x: impl Trait)` instead of\n-                                // `fn foo<T>(x: T)`. We want to suggest the correct\n-                                // `fn foo(x: impl Trait + TraitBound)` instead of\n-                                // `fn foo<T: TraitBound>(x: T)`. (See #63706.)\n-                                impl_trait = true;\n-                                has_bounds = param.bounds.get(1);\n-                            } else {\n-                                has_bounds = param.bounds.get(0);\n+                        match hir.get(id) {\n+                            Node::GenericParam(ref param) => {\n+                                let mut impl_trait = false;\n+                                let has_bounds = if let hir::GenericParamKind::Type {\n+                                    synthetic: Some(_), ..\n+                                } = &param.kind {\n+                                    // We've found `fn foo(x: impl Trait)` instead of\n+                                    // `fn foo<T>(x: T)`. We want to suggest the correct\n+                                    // `fn foo(x: impl Trait + TraitBound)` instead of\n+                                    // `fn foo<T: TraitBound>(x: T)`. (#63706)\n+                                    impl_trait = true;\n+                                    param.bounds.get(1)\n+                                } else {\n+                                    param.bounds.get(0)\n+                                };\n+                                let sp = hir.span(id);\n+                                let sp = if let Some(first_bound) = has_bounds {\n+                                    // `sp` only covers `T`, change it so that it covers\n+                                    // `T:` when appropriate\n+                                    sp.until(first_bound.span())\n+                                } else {\n+                                    sp\n+                                };\n+                                // FIXME: contrast `t.def_id` against `param.bounds` to not suggest\n+                                // traits already there. That can happen when the cause is that\n+                                // we're in a const scope or associated function used as a method.\n+                                err.span_suggestions(\n+                                    sp,\n+                                    &message(format!(\n+                                        \"restrict type parameter `{}` with\",\n+                                        param.name.ident().as_str(),\n+                                    )),\n+                                    candidates.iter().map(|t| format!(\n+                                        \"{}{} {}{}\",\n+                                        param.name.ident().as_str(),\n+                                        if impl_trait { \" +\" } else { \":\" },\n+                                        self.tcx.def_path_str(t.def_id),\n+                                        if has_bounds.is_some() { \" + \"} else { \"\" },\n+                                    )),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                suggested = true;\n+                            }\n+                            Node::Item(hir::Item {\n+                                kind: hir::ItemKind::Trait(.., bounds, _), ident, ..\n+                            }) => {\n+                                let (sp, sep, article) = if bounds.is_empty() {\n+                                    (ident.span.shrink_to_hi(), \":\", \"a\")\n+                                } else {\n+                                    (bounds.last().unwrap().span().shrink_to_hi(), \" +\", \"another\")\n+                                };\n+                                err.span_suggestions(\n+                                    sp,\n+                                    &message(format!(\"add {} supertrait for\", article)),\n+                                    candidates.iter().map(|t| format!(\n+                                        \"{} {}\",\n+                                        sep,\n+                                        self.tcx.def_path_str(t.def_id),\n+                                    )),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                suggested = true;\n                             }\n+                            _ => {}\n                         }\n-                        let sp = hir.span(id);\n-                        // `sp` only covers `T`, change it so that it covers `T:` when appropriate.\n-                        let sp = if let Some(first_bound) = has_bounds {\n-                            sp.until(first_bound.span())\n-                        } else {\n-                            sp\n-                        };\n-\n-                        // FIXME: contrast `t.def_id` against `param.bounds` to not suggest traits\n-                        // already there. That can happen when the cause is that we're in a const\n-                        // scope or associated function used as a method.\n-                        err.span_suggestions(\n-                            sp,\n-                            &msg[..],\n-                            candidates.iter().map(|t| format!(\n-                                \"{}{} {}{}\",\n-                                param,\n-                                if impl_trait { \" +\" } else { \":\" },\n-                                self.tcx.def_path_str(t.def_id),\n-                                if has_bounds.is_some() { \" + \" } else { \"\" },\n-                            )),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        suggested = true;\n                     }\n                 };\n             }\n \n             if !suggested {\n+                let mut msg = message(if let Some(param) = param_type {\n+                    format!(\"restrict type parameter `{}` with\", param)\n+                } else {\n+                    \"implement\".to_string()\n+                });\n                 for (i, trait_info) in candidates.iter().enumerate() {\n                     msg.push_str(&format!(\n                         \"\\ncandidate #{}: `{}`\","}, {"sha": "e0e1a1c468c90f3a1291c92a9d6569e93552ccf8", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -334,8 +334,7 @@ impl Ident {\n         if !Self::is_valid(&string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        // Get rid of gensyms to conservatively check rawness on the string contents only.\n-        if is_raw && !sym.as_interned_str().as_symbol().can_be_raw() {\n+        if is_raw && !sym.can_be_raw() {\n             panic!(\"`{}` cannot be a raw identifier\", string);\n         }\n         Ident { sym, is_raw, span }"}, {"sha": "8845b66a7cefd8cf5342c26e5f39d4d17e6b3e41", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 9, "deletions": 81, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -808,25 +808,13 @@ impl Ident {\n         Ident::new(self.name, self.span.modern_and_legacy())\n     }\n \n-    /// Transforms an underscore identifier into one with the same name, but\n-    /// gensymed. Leaves non-underscore identifiers unchanged.\n-    pub fn gensym_if_underscore(self) -> Ident {\n-        if self.name == kw::Underscore {\n-            let name = with_interner(|interner| interner.gensymed(self.name));\n-            Ident::new(name, self.span)\n-        } else {\n-            self\n-        }\n-    }\n-\n     /// Convert the name to a `LocalInternedString`. This is a slowish\n     /// operation because it requires locking the symbol interner.\n     pub fn as_str(self) -> LocalInternedString {\n         self.name.as_str()\n     }\n \n-    /// Convert the name to an `InternedString`. This is a slowish operation\n-    /// because it requires locking the symbol interner.\n+    /// Convert the name to an `InternedString`.\n     pub fn as_interned_str(self) -> InternedString {\n         self.name.as_interned_str()\n     }\n@@ -881,26 +869,9 @@ impl UseSpecializedDecodable for Ident {\n     }\n }\n \n-/// A symbol is an interned or gensymed string. A gensym is a symbol that is\n-/// never equal to any other symbol.\n+/// An interned string.\n ///\n-/// Conceptually, a gensym can be thought of as a normal symbol with an\n-/// invisible unique suffix. Gensyms are useful when creating new identifiers\n-/// that must not match any existing identifiers, e.g. during macro expansion\n-/// and syntax desugaring. Because gensyms should always be identifiers, all\n-/// gensym operations are on `Ident` rather than `Symbol`. (Indeed, in the\n-/// future the gensym-ness may be moved from `Symbol` to hygiene data.)\n-///\n-/// Examples:\n-/// ```\n-/// assert_eq!(Ident::from_str(\"_\"), Ident::from_str(\"_\"))\n-/// assert_ne!(Ident::from_str(\"_\").gensym_if_underscore(), Ident::from_str(\"_\"))\n-/// assert_ne!(\n-///     Ident::from_str(\"_\").gensym_if_underscore(),\n-///     Ident::from_str(\"_\").gensym_if_underscore(),\n-/// )\n-/// ```\n-/// Internally, a symbol is implemented as an index, and all operations\n+/// Internally, a `Symbol` is implemented as an index, and all operations\n /// (including hashing, equality, and ordering) operate on that index. The use\n /// of `rustc_index::newtype_index!` means that `Option<Symbol>` only takes up 4 bytes,\n /// because `rustc_index::newtype_index!` reserves the last 256 values for tagging purposes.\n@@ -951,12 +922,9 @@ impl Symbol {\n         })\n     }\n \n-    /// Convert to an `InternedString`. This is a slowish operation because it\n-    /// requires locking the symbol interner.\n+    /// Convert to an `InternedString`.\n     pub fn as_interned_str(self) -> InternedString {\n-        with_interner(|interner| InternedString {\n-            symbol: interner.interned(self)\n-        })\n+        InternedString { symbol: self }\n     }\n \n     pub fn as_u32(self) -> u32 {\n@@ -966,12 +934,7 @@ impl Symbol {\n \n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let is_gensymed = with_interner(|interner| interner.is_gensymed(*self));\n-        if is_gensymed {\n-            write!(f, \"{}({:?})\", self, self.0)\n-        } else {\n-            write!(f, \"{}\", self)\n-        }\n+        fmt::Display::fmt(self, f)\n     }\n }\n \n@@ -994,15 +957,11 @@ impl Decodable for Symbol {\n }\n \n // The `&'static str`s in this type actually point into the arena.\n-//\n-// Note that normal symbols are indexed upward from 0, and gensyms are indexed\n-// downward from SymbolIndex::MAX_AS_U32.\n #[derive(Default)]\n pub struct Interner {\n     arena: DroplessArena,\n     names: FxHashMap<&'static str, Symbol>,\n     strings: Vec<&'static str>,\n-    gensyms: Vec<Symbol>,\n }\n \n impl Interner {\n@@ -1035,34 +994,10 @@ impl Interner {\n         self.names.insert(string, name);\n         name\n     }\n-\n-    fn interned(&self, symbol: Symbol) -> Symbol {\n-        if (symbol.0.as_usize()) < self.strings.len() {\n-            symbol\n-        } else {\n-            self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize]\n-        }\n-    }\n-\n-    fn gensymed(&mut self, symbol: Symbol) -> Symbol {\n-        self.gensyms.push(symbol);\n-        Symbol::new(SymbolIndex::MAX_AS_U32 - self.gensyms.len() as u32 + 1)\n-    }\n-\n-    fn is_gensymed(&mut self, symbol: Symbol) -> bool {\n-        symbol.0.as_usize() >= self.strings.len()\n-    }\n-\n     // Get the symbol as a string. `Symbol::as_str()` should be used in\n     // preference to this function.\n     pub fn get(&self, symbol: Symbol) -> &str {\n-        match self.strings.get(symbol.0.as_usize()) {\n-            Some(string) => string,\n-            None => {\n-                let symbol = self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize];\n-                self.strings[symbol.0.as_usize()]\n-            }\n-        }\n+        self.strings[symbol.0.as_usize()]\n     }\n }\n \n@@ -1223,19 +1158,12 @@ impl fmt::Display for LocalInternedString {\n     }\n }\n \n-/// An alternative to `Symbol` that is focused on string contents. It has two\n-/// main differences to `Symbol`.\n+/// An alternative to `Symbol` that is focused on string contents.\n ///\n-/// First, its implementations of `Hash`, `PartialOrd` and `Ord` work with the\n+/// Its implementations of `Hash`, `PartialOrd` and `Ord` work with the\n /// string chars rather than the symbol integer. This is useful when hash\n /// stability is required across compile sessions, or a guaranteed sort\n /// ordering is required.\n-///\n-/// Second, gensym-ness is irrelevant. E.g.:\n-/// ```\n-/// assert_ne!(Symbol::gensym(\"x\"), Symbol::gensym(\"x\"))\n-/// assert_eq!(Symbol::gensym(\"x\").as_interned_str(), Symbol::gensym(\"x\").as_interned_str())\n-/// ```\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub struct InternedString {\n     symbol: Symbol,"}, {"sha": "f74b9a0cd1d1df0213739c04d1d389c9825ebe71", "filename": "src/libsyntax_pos/symbol/tests.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -14,13 +14,6 @@ fn interner_tests() {\n     assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n     // dog is still at zero\n     assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n-    let z = i.intern(\"zebra\");\n-    assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32));\n-    // gensym of same string gets new number:\n-    assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n-    // gensym of *existing* string gets new number:\n-    let d = i.intern(\"dog\");\n-    assert_eq!(i.gensymed(d), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n }\n \n #[test]"}, {"sha": "b5fee061f277e8a09316c359eaf0ac9a112ff740", "filename": "src/test/ui/async-await/issues/issue-65159.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,10 @@\n+// Regression test for #65159. We used to ICE.\n+//\n+// edition:2018\n+\n+async fn copy() -> Result<()> //~ ERROR wrong number of type arguments\n+{\n+    Ok(())\n+}\n+\n+fn main() { }"}, {"sha": "56d2c38b302e9319d2f3175d8095e697d42bc002", "filename": "src/test/ui/async-await/issues/issue-65159.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65159.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,9 @@\n+error[E0107]: wrong number of type arguments: expected 2, found 1\n+  --> $DIR/issue-65159.rs:5:20\n+   |\n+LL | async fn copy() -> Result<()>\n+   |                    ^^^^^^^^^^ expected 2 type arguments\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "1cf546bcb4266e0bf5d45f91991f842bcd5ed1cf", "filename": "src/test/ui/async-await/unused-lifetime.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,42 @@\n+// edition:2018\n+\n+// Avoid spurious warnings of unused lifetime. The below async functions\n+// are desugered to have an unused lifetime\n+// but we don't want to warn about that as there's nothing they can do about it.\n+\n+#![deny(unused_lifetimes)]\n+#![allow(dead_code)]\n+\n+pub async fn october(s: &str) {\n+    println!(\"{}\", s);\n+}\n+\n+pub async fn async_fn(&mut ref s: &mut[i32]) {\n+    println!(\"{:?}\", s);\n+}\n+\n+macro_rules! foo_macro {\n+    () => {\n+        pub async fn async_fn_in_macro(&mut ref _s: &mut[i32]) {}\n+    };\n+}\n+\n+foo_macro!();\n+\n+pub async fn func_with_unused_lifetime<'a>(s: &'a str) {\n+    //~^ ERROR lifetime parameter `'a` never used\n+    println!(\"{}\", s);\n+}\n+\n+pub async fn func_with_two_unused_lifetime<'a, 'b>(s: &'a str, t: &'b str) {\n+    //~^ ERROR lifetime parameter `'a` never used\n+    //~^^ ERROR lifetime parameter `'b` never used\n+    println!(\"{}\", s);\n+}\n+\n+pub async fn func_with_unused_lifetime_in_two_params<'c>(s: &'c str, t: &'c str) {\n+    //~^ ERROR lifetime parameter `'c` never used\n+    println!(\"{}\", s);\n+}\n+\n+fn main() {}"}, {"sha": "885cdc04cfa4c2892e8ec242b1b00e07242eea5a", "filename": "src/test/ui/async-await/unused-lifetime.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funused-lifetime.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,32 @@\n+error: lifetime parameter `'a` never used\n+  --> $DIR/unused-lifetime.rs:26:40\n+   |\n+LL | pub async fn func_with_unused_lifetime<'a>(s: &'a str) {\n+   |                                        ^^\n+   |\n+note: lint level defined here\n+  --> $DIR/unused-lifetime.rs:7:9\n+   |\n+LL | #![deny(unused_lifetimes)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: lifetime parameter `'a` never used\n+  --> $DIR/unused-lifetime.rs:31:44\n+   |\n+LL | pub async fn func_with_two_unused_lifetime<'a, 'b>(s: &'a str, t: &'b str) {\n+   |                                            ^^\n+\n+error: lifetime parameter `'b` never used\n+  --> $DIR/unused-lifetime.rs:31:48\n+   |\n+LL | pub async fn func_with_two_unused_lifetime<'a, 'b>(s: &'a str, t: &'b str) {\n+   |                                                ^^\n+\n+error: lifetime parameter `'c` never used\n+  --> $DIR/unused-lifetime.rs:37:54\n+   |\n+LL | pub async fn func_with_unused_lifetime_in_two_params<'c>(s: &'c str, t: &'c str) {\n+   |                                                      ^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "5038eb3ebf4583db98b83239ee4860f7a1a66581", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,4 +1,4 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n \n #![feature(never_type)]\n #![allow(unreachable_code)]"}, {"sha": "5eafa831d63174bfedcfd993a3032cbc7441ed5d", "filename": "src/test/ui/consts/issue-65348.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fconsts%2Fissue-65348.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fconsts%2Fissue-65348.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-65348.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+struct Generic<T>(T);\n+\n+impl<T> Generic<T> {\n+    const ARRAY: [T; 0] = [];\n+    const NEWTYPE_ARRAY: Generic<[T; 0]> = Generic([]);\n+    const ARRAY_FIELD: Generic<(i32, [T; 0])> = Generic((0, []));\n+}\n+\n+pub const fn array<T>() ->  &'static T {\n+    &Generic::<T>::ARRAY[0]\n+}\n+\n+pub const fn newtype_array<T>() ->  &'static T {\n+    &Generic::<T>::NEWTYPE_ARRAY.0[0]\n+}\n+\n+pub const fn array_field<T>() ->  &'static T {\n+    &(Generic::<T>::ARRAY_FIELD.0).1[0]\n+}\n+\n+fn main() {}"}, {"sha": "f0cc9ea70550e6a7cf8483d35a0869a48ff4282b", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,4 +1,5 @@\n #![feature(never_type)]\n+\n fn foo() -> Result<u32, !> {\n     Ok(123)\n }"}, {"sha": "08c36cece4cf9b42ebed048ddf39aaacc3e1c856", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,5 +1,5 @@\n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/feature-gate-exhaustive-patterns.rs:7:9\n+  --> $DIR/feature-gate-exhaustive-patterns.rs:8:9\n    |\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered"}, {"sha": "d7209fc4de867f168c5db50c403efc4ba33abf49", "filename": "src/test/ui/for-loop-while/loop-break-value.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ffor-loop-while%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ffor-loop-while%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor-loop-while%2Floop-break-value.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+\n #![allow(unreachable_code)]\n #![feature(never_type)]\n "}, {"sha": "54b483f53d4cba42064837b786cef3d42d12db8f", "filename": "src/test/ui/generics/issue-65285-incorrect-explicit-lifetime-name-needed.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,14 @@\n+#![crate_type=\"lib\"]\n+\n+struct Nested<K>(K);\n+\n+fn should_error<T>() where T : Into<&u32> {}\n+//~^ ERROR `&` without an explicit lifetime name cannot be used here [E0637]\n+\n+trait X<'a, K: 'a> {\n+    fn foo<'b, L: X<&'b Nested<K>>>();\n+    //~^ ERROR missing lifetime specifier [E0106]\n+}\n+\n+fn bar<'b, L: X<&'b Nested<i32>>>(){}\n+//~^ ERROR missing lifetime specifier [E0106]"}, {"sha": "8720288b53e58cc590e53627bb8dd7652ec0f3de", "filename": "src/test/ui/generics/issue-65285-incorrect-explicit-lifetime-name-needed.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,21 @@\n+error[E0637]: `&` without an explicit lifetime name cannot be used here\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:5:37\n+   |\n+LL | fn should_error<T>() where T : Into<&u32> {}\n+   |                                     ^ explicit lifetime name needed here\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:9:19\n+   |\n+LL |     fn foo<'b, L: X<&'b Nested<K>>>();\n+   |                   ^^^^^^^^^^^^^^^^ expected lifetime parameter\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:13:15\n+   |\n+LL | fn bar<'b, L: X<&'b Nested<i32>>>(){}\n+   |               ^^^^^^^^^^^^^^^^^^ expected lifetime parameter\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "d7e6069977b4e1e0ea13f38fe0c4dda50d208166", "filename": "src/test/ui/issues/issue-17001.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-17001.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-17001.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17001.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -6,3 +6,4 @@ LL |     let p = foo { x: () };\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0574`."}, {"sha": "37274e239ba0b1a1e03b56d22c8fd9dd380a8230", "filename": "src/test/ui/issues/issue-17405.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-17405.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-17405.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17405.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -6,3 +6,4 @@ LL |         Foo { i } => ()\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0574`."}, {"sha": "ecaf6faba429e160fa7f951863beb6eed6a1e775", "filename": "src/test/ui/issues/issue-21449.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-21449.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-21449.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21449.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -6,3 +6,4 @@ LL |     let myVar = MyMod { T: 0 };\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0574`."}, {"sha": "ed065212c560ba2808c31fda35b3e690b7aebde5", "filename": "src/test/ui/issues/issue-23189.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-23189.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-23189.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23189.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -6,3 +6,4 @@ LL |     let _ = module { x: 0 };\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0574`."}, {"sha": "187369263a44617563257fae3968c4b14cf173f6", "filename": "src/test/ui/issues/issue-26459.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-26459.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-26459.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26459.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -6,3 +6,4 @@ LL |         char{ch} => true\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0574`."}, {"sha": "43f78ccf6395aa882649074f3247c5748f53a720", "filename": "src/test/ui/issues/issue-27815.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-27815.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fissues%2Fissue-27815.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27815.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -24,3 +24,4 @@ LL |         u32 { x: 1 } => {}\n \n error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0574`."}, {"sha": "38c7393e136a604985c3d661da89df17129918fc", "filename": "src/test/ui/lexical-scopes.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Flexical-scopes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Flexical-scopes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flexical-scopes.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -16,4 +16,5 @@ LL |     Foo::f();\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0599`.\n+Some errors have detailed explanations: E0574, E0599.\n+For more information about an error, try `rustc --explain E0574`."}, {"sha": "4dd4798abb7ce890e9cca2a72188bf028fb9d6ef", "filename": "src/test/ui/lint/must_use-unit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Flint%2Fmust_use-unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Flint%2Fmust_use-unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_use-unit.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,5 +1,4 @@\n #![feature(never_type)]\n-\n #![deny(unused_must_use)]\n \n #[must_use]"}, {"sha": "0a9939b2015b7f14cc859b7c88238c27bc2745a7", "filename": "src/test/ui/lint/must_use-unit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Flint%2Fmust_use-unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Flint%2Fmust_use-unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmust_use-unit.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,17 +1,17 @@\n error: unused return value of `foo` that must be used\n-  --> $DIR/must_use-unit.rs:14:5\n+  --> $DIR/must_use-unit.rs:13:5\n    |\n LL |     foo();\n    |     ^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/must_use-unit.rs:3:9\n+  --> $DIR/must_use-unit.rs:2:9\n    |\n LL | #![deny(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n \n error: unused return value of `bar` that must be used\n-  --> $DIR/must_use-unit.rs:16:5\n+  --> $DIR/must_use-unit.rs:15:5\n    |\n LL |     bar();\n    |     ^^^^^^"}, {"sha": "3aa5866ebfbeb7ff0114f4910cda46cb63e7bb81", "filename": "src/test/ui/never_type/adjust_never.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fadjust_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fadjust_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fadjust_never.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,5 +1,6 @@\n // Test that a variable of type ! can coerce to another type.\n \n+// run-fail\n // error-pattern:explicit\n \n #![feature(never_type)]", "previous_filename": "src/test/run-fail/adjust_never.rs"}, {"sha": "d06637e74a2f26b9da61b538f2f89c8d0eead623", "filename": "src/test/ui/never_type/call-fn-never-arg-wrong-type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fcall-fn-never-arg-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fcall-fn-never-arg-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fcall-fn-never-arg-wrong-type.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/call-fn-never-arg-wrong-type.rs"}, {"sha": "7a50fd367d2d52e17a6950fb10cadfa1ac78de2b", "filename": "src/test/ui/never_type/call-fn-never-arg-wrong-type.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fcall-fn-never-arg-wrong-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fcall-fn-never-arg-wrong-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fcall-fn-never-arg-wrong-type.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/call-fn-never-arg-wrong-type.stderr"}, {"sha": "6218572f8a75651d27b009c6bc2ef8b99bb00c8a", "filename": "src/test/ui/never_type/call-fn-never-arg.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fcall-fn-never-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fcall-fn-never-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fcall-fn-never-arg.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,5 +1,6 @@\n // Test that we can use a ! for an argument of type !\n \n+// run-fail\n // error-pattern:wowzers!\n \n #![feature(never_type)]", "previous_filename": "src/test/run-fail/call-fn-never-arg.rs"}, {"sha": "46072e186e0f29e06f89a26fb2611af48918063c", "filename": "src/test/ui/never_type/cast-never.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fcast-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fcast-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fcast-never.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,5 +1,6 @@\n // Test that we can explicitly cast ! to another type\n \n+// run-fail\n // error-pattern:explicit\n \n #![feature(never_type)]", "previous_filename": "src/test/run-fail/cast-never.rs"}, {"sha": "d3fb8a09414ce1351f8f347ffb626320ac82c4a1", "filename": "src/test/ui/never_type/defaulted-never-note.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/defaulted-never-note.rs"}, {"sha": "28c9da059edaaa47d760948a20dedc08195f9ef6", "filename": "src/test/ui/never_type/defaulted-never-note.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/defaulted-never-note.stderr"}, {"sha": "764f58ce9e805e34328e1c467ddc91ba10be3bb4", "filename": "src/test/ui/never_type/dispatch_from_dyn_zst.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fdispatch_from_dyn_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fdispatch_from_dyn_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdispatch_from_dyn_zst.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/dispatch_from_dyn_zst.rs"}, {"sha": "c68e6364ed4069272b602cea96fb87a9f47dc623", "filename": "src/test/ui/never_type/diverging-fallback-control-flow.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -4,6 +4,7 @@\n #![allow(unused_assignments)]\n #![allow(unused_variables)]\n #![allow(unreachable_code)]\n+\n // Test various cases where we permit an unconstrained variable\n // to fallback based on control-flow.\n //", "previous_filename": "src/test/ui/diverging-fallback-control-flow.rs"}, {"sha": "9423f08858b9ba9622fd042c2c3cd827f684ed50", "filename": "src/test/ui/never_type/impl-for-never.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fimpl-for-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fimpl-for-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl-for-never.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,8 +1,9 @@\n // run-pass\n-// Test that we can call static methods on ! both directly and when it appears in a generic\n \n #![feature(never_type)]\n \n+// Test that we can call static methods on ! both directly and when it appears in a generic\n+\n trait StringifyType {\n     fn stringify_type() -> &'static str;\n }", "previous_filename": "src/test/ui/impl-for-never.rs"}, {"sha": "e6995be27d20e728c68b03c262bde9a259296077", "filename": "src/test/ui/never_type/issue-13352.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-13352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-13352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-13352.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/issues/issue-13352.rs"}, {"sha": "58ac74be3e3b7a9798ce675c3838bdaab0c7457c", "filename": "src/test/ui/never_type/issue-13352.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-13352.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-13352.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-13352.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/issues/issue-13352.stderr"}, {"sha": "d46f0e61793f35ce713c8d9246d0587cebdbcabb", "filename": "src/test/ui/never_type/issue-2149.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-2149.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/issues/issue-2149.rs"}, {"sha": "8ce2ba033321e2e28caec3836bea032654484492", "filename": "src/test/ui/never_type/issue-2149.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-2149.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-2149.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-2149.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/issues/issue-2149.stderr"}, {"sha": "699e480dfe7e53140d261d7e916f418243912c82", "filename": "src/test/ui/never_type/issue-44402.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-44402.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fissue-44402.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-44402.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,4 +1,5 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n+\n #![allow(dead_code)]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]", "previous_filename": "src/test/ui/issues/issue-44402.rs"}, {"sha": "7bb7c87097c503a790d517c905cdee80ecad8f11", "filename": "src/test/ui/never_type/never-assign-dead-code.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-dead-code.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,10 +1,10 @@\n // Test that an assignment of type ! makes the rest of the block dead code.\n \n+// check-pass\n+\n #![feature(never_type)]\n-// build-pass (FIXME(62277): could be check-pass?)\n #![warn(unused)]\n \n-\n fn main() {\n     let x: ! = panic!(\"aah\"); //~ WARN unused\n     drop(x); //~ WARN unreachable", "previous_filename": "src/test/ui/never-assign-dead-code.rs"}, {"sha": "1860150fa8bc6e2899a3c480c273b470965b40de", "filename": "src/test/ui/never_type/never-assign-dead-code.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-dead-code.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-dead-code.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-dead-code.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -7,7 +7,7 @@ LL |     drop(x);\n    |     ^^^^^^^^ unreachable statement\n    |\n note: lint level defined here\n-  --> $DIR/never-assign-dead-code.rs:5:9\n+  --> $DIR/never-assign-dead-code.rs:6:9\n    |\n LL | #![warn(unused)]\n    |         ^^^^^^\n@@ -29,7 +29,7 @@ LL |     let x: ! = panic!(\"aah\");\n    |         ^ help: consider prefixing with an underscore: `_x`\n    |\n note: lint level defined here\n-  --> $DIR/never-assign-dead-code.rs:5:9\n+  --> $DIR/never-assign-dead-code.rs:6:9\n    |\n LL | #![warn(unused)]\n    |         ^^^^^^", "previous_filename": "src/test/ui/never-assign-dead-code.stderr"}, {"sha": "67e26f5663f412ed5fd18167e7fcf3607ab82c43", "filename": "src/test/ui/never_type/never-assign-wrong-type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-wrong-type.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/never-assign-wrong-type.rs"}, {"sha": "da2e77d023d190ac93cd0029314d9a94cea794fa", "filename": "src/test/ui/never_type/never-assign-wrong-type.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-wrong-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-wrong-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-wrong-type.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/never-assign-wrong-type.stderr"}, {"sha": "7f0a3fef6a99a49c80fc40e747c13fb09e53e3c5", "filename": "src/test/ui/never_type/never-associated-type.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-associated-type.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,5 +1,6 @@\n // Test that we can use ! as an associated type.\n \n+// run-fail\n // error-pattern:kapow!\n \n #![feature(never_type)]", "previous_filename": "src/test/run-fail/never-associated-type.rs"}, {"sha": "9d16015bdc129bd5e0a5c43ccb674ca1727a98e0", "filename": "src/test/ui/never_type/never-from-impl-is-reserved.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-from-impl-is-reserved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-from-impl-is-reserved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-from-impl-is-reserved.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/never-from-impl-is-reserved.rs"}, {"sha": "8b8d0f4ea73bea6f27ca5e1e6efb48cd9d337e7f", "filename": "src/test/ui/never_type/never-from-impl-is-reserved.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-from-impl-is-reserved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-from-impl-is-reserved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-from-impl-is-reserved.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/never-from-impl-is-reserved.stderr"}, {"sha": "35af37910ef3e92f28039f0791df0f2eb689d2e0", "filename": "src/test/ui/never_type/never-result.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-result.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(unused_variables)]\n #![allow(unreachable_code)]\n+\n // Test that we can extract a ! through pattern matching then use it as several different types.\n \n #![feature(never_type)]", "previous_filename": "src/test/ui/never-result.rs"}, {"sha": "a82d351f6cf2b37b7873428fe3edf98cf2a92e0d", "filename": "src/test/ui/never_type/never-type-arg.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-type-arg.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,5 +1,6 @@\n // Test that we can use ! as an argument to a trait impl.\n \n+// run-fail\n // error-pattern:oh no!\n \n #![feature(never_type)]", "previous_filename": "src/test/run-fail/never-type-arg.rs"}, {"sha": "9ccc73dbf92d4c4449a43ea35e4e1e6bdeadfa9b", "filename": "src/test/ui/never_type/never-type-rvalues.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-type-rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever-type-rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-type-rvalues.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/never-type-rvalues.rs"}, {"sha": "105c38635331f1c87b013bf99842510e50cc1c4d", "filename": "src/test/ui/never_type/never_coercions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever_coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever_coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever_coercions.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/never_coercions.rs"}, {"sha": "fce3ced9aac7fc58f4e8bfcbfaae77559a177ed9", "filename": "src/test/ui/never_type/never_transmute_never.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever_transmute_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fnever_transmute_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever_transmute_never.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,4 +1,4 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n \n #![crate_type=\"lib\"]\n ", "previous_filename": "src/test/ui/never_transmute_never.rs"}, {"sha": "b0d6629561803077c5324c0c2d9d61e553657557", "filename": "src/test/ui/never_type/panic-uninitialized-zeroed.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fpanic-uninitialized-zeroed.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/panic-uninitialized-zeroed.rs"}, {"sha": "50451576f9c9771bb822754ee330bfbdde281278", "filename": "src/test/ui/never_type/try_from.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Ftry_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fnever_type%2Ftry_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ftry_from.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/try_from.rs"}, {"sha": "4e94a4b5ed8718d9d31570c35b2035dd0b0ba231", "filename": "src/test/ui/reachable/auxiliary/unreachable_variant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Fauxiliary%2Funreachable_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Fauxiliary%2Funreachable_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fauxiliary%2Funreachable_variant.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/auxiliary/unreachable_variant.rs"}, {"sha": "64c3896851669fc52f65503267f7d4d5794b70f0", "filename": "src/test/ui/reachable/unreachable-arm.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-arm.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unreachable-arm.rs"}, {"sha": "8e65745c7b099f9163fb200e7013602c8d615530", "filename": "src/test/ui/reachable/unreachable-arm.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-arm.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unreachable-arm.stderr"}, {"sha": "ad0dc8a8b9ccd4c710e20ac97fd8fd6236c9eca1", "filename": "src/test/ui/reachable/unreachable-code.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-code.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unreachable-code.rs"}, {"sha": "184440db5df4852cd231cb32d574bd1d84093a24", "filename": "src/test/ui/reachable/unreachable-code.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-code.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-code.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-code.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unreachable-code.stderr"}, {"sha": "dd94e79f4d84c717895f8821461dc716529374be", "filename": "src/test/ui/reachable/unreachable-in-call.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-in-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-in-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-in-call.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unreachable-in-call.rs"}, {"sha": "1d081d1c76228fb472a0a6b4ff8e4dbf27ded75b", "filename": "src/test/ui/reachable/unreachable-in-call.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-in-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-in-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-in-call.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unreachable-in-call.stderr"}, {"sha": "6f1d2efa1b200a9e517ba10c6483c1fd3c1c31ce", "filename": "src/test/ui/reachable/unreachable-loop-patterns.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,5 +1,3 @@\n-// compile-fail\n-\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]\n ", "previous_filename": "src/test/ui/unreachable/unreachable-loop-patterns.rs"}, {"sha": "bb5103320d2cf9f551c58c3d727b321cb16edcf3", "filename": "src/test/ui/reachable/unreachable-loop-patterns.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-loop-patterns.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,17 +1,17 @@\n error: unreachable pattern\n-  --> $DIR/unreachable-loop-patterns.rs:20:9\n+  --> $DIR/unreachable-loop-patterns.rs:18:9\n    |\n LL |     for _ in unimplemented!() as Void {}\n    |         ^\n    |\n note: lint level defined here\n-  --> $DIR/unreachable-loop-patterns.rs:7:9\n+  --> $DIR/unreachable-loop-patterns.rs:5:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/unreachable-loop-patterns.rs:20:14\n+  --> $DIR/unreachable-loop-patterns.rs:18:14\n    |\n LL |     for _ in unimplemented!() as Void {}\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/unreachable/unreachable-loop-patterns.stderr"}, {"sha": "23360e73f4a3a6870d616f2b7f4d84d868a02d6c", "filename": "src/test/ui/reachable/unreachable-try-pattern.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-try-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-try-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-try-pattern.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -1,4 +1,4 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n #![feature(never_type, exhaustive_patterns)]\n #![warn(unreachable_code)]\n #![warn(unreachable_patterns)]", "previous_filename": "src/test/ui/unreachable/unreachable-try-pattern.rs"}, {"sha": "707038442a2b62f5e12bafe28851585489121a0e", "filename": "src/test/ui/reachable/unreachable-try-pattern.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-try-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-try-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-try-pattern.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unreachable-try-pattern.stderr"}, {"sha": "008c2d476d750e992f101371678e5d079ea05523", "filename": "src/test/ui/reachable/unreachable-variant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-variant.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unreachable-variant.rs"}, {"sha": "276c77f9b4249e44c877d405225ac0e936c9f4f7", "filename": "src/test/ui/reachable/unreachable-variant.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funreachable-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-variant.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unreachable-variant.stderr"}, {"sha": "71f8fe3a783e2247ba69b35d8fea2865f6e588ec", "filename": "src/test/ui/reachable/unwarned-match-on-never.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funwarned-match-on-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funwarned-match-on-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funwarned-match-on-never.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unwarned-match-on-never.rs"}, {"sha": "6b2fb4a33c1e80c76c0b62743a4e504a20dd702c", "filename": "src/test/ui/reachable/unwarned-match-on-never.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funwarned-match-on-never.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Freachable%2Funwarned-match-on-never.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funwarned-match-on-never.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/unreachable/unwarned-match-on-never.stderr"}, {"sha": "9766f8f1412b6c4341018afbbb68f1d60c9364e2", "filename": "src/test/ui/resolve/issue-16058.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -14,3 +14,4 @@ LL | use std::thread::Result;\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0574`."}, {"sha": "a3d88a203778fbc8cda94e16648c117f48a582b2", "filename": "src/test/ui/save-analysis/issue-64659.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-64659.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-64659.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-64659.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+// compile-flags: -Zsave-analysis\n+\n+trait Trait { type Assoc; }\n+\n+fn main() {\n+    struct Data<T: Trait> {\n+        x: T::Assoc,\n+    }\n+}"}, {"sha": "dda9e931353b21be902616f225b67f3c112c7bfa", "filename": "src/test/ui/suggestions/constrain-trait.fixed", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.fixed?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,47 @@\n+// run-rustfix\n+// check-only\n+\n+#[derive(Debug)]\n+struct Demo {\n+    a: String\n+}\n+\n+trait GetString {\n+    fn get_a(&self) -> &String;\n+}\n+\n+trait UseString: std::fmt::Debug + GetString {\n+    fn use_string(&self) {\n+        println!(\"{:?}\", self.get_a()); //~ ERROR no method named `get_a` found for type `&Self`\n+    }\n+}\n+\n+trait UseString2: GetString {\n+    fn use_string(&self) {\n+        println!(\"{:?}\", self.get_a()); //~ ERROR no method named `get_a` found for type `&Self`\n+    }\n+}\n+\n+impl GetString for Demo {\n+    fn get_a(&self) -> &String {\n+        &self.a\n+    }\n+}\n+\n+impl UseString for Demo {}\n+impl UseString2 for Demo {}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{Demo, UseString};\n+\n+    #[test]\n+    fn it_works() {\n+        let d = Demo { a: \"test\".to_string() };\n+        d.use_string();\n+    }\n+}\n+\n+\n+fn main() {}"}, {"sha": "4ef0eff5bd7699b1417319c8b4c72ce203759043", "filename": "src/test/ui/suggestions/constrain-trait.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,47 @@\n+// run-rustfix\n+// check-only\n+\n+#[derive(Debug)]\n+struct Demo {\n+    a: String\n+}\n+\n+trait GetString {\n+    fn get_a(&self) -> &String;\n+}\n+\n+trait UseString: std::fmt::Debug {\n+    fn use_string(&self) {\n+        println!(\"{:?}\", self.get_a()); //~ ERROR no method named `get_a` found for type `&Self`\n+    }\n+}\n+\n+trait UseString2 {\n+    fn use_string(&self) {\n+        println!(\"{:?}\", self.get_a()); //~ ERROR no method named `get_a` found for type `&Self`\n+    }\n+}\n+\n+impl GetString for Demo {\n+    fn get_a(&self) -> &String {\n+        &self.a\n+    }\n+}\n+\n+impl UseString for Demo {}\n+impl UseString2 for Demo {}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{Demo, UseString};\n+\n+    #[test]\n+    fn it_works() {\n+        let d = Demo { a: \"test\".to_string() };\n+        d.use_string();\n+    }\n+}\n+\n+\n+fn main() {}"}, {"sha": "3cc351ac80aed245af906e9420278697274feeb1", "filename": "src/test/ui/suggestions/constrain-trait.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconstrain-trait.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,27 @@\n+error[E0599]: no method named `get_a` found for type `&Self` in the current scope\n+  --> $DIR/constrain-trait.rs:15:31\n+   |\n+LL |         println!(\"{:?}\", self.get_a());\n+   |                               ^^^^^ method not found in `&Self`\n+   |\n+   = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: the following trait defines an item `get_a`, perhaps you need to add another supertrait for it:\n+   |\n+LL | trait UseString: std::fmt::Debug + GetString {\n+   |                                  ^^^^^^^^^^^\n+\n+error[E0599]: no method named `get_a` found for type `&Self` in the current scope\n+  --> $DIR/constrain-trait.rs:21:31\n+   |\n+LL |         println!(\"{:?}\", self.get_a());\n+   |                               ^^^^^ method not found in `&Self`\n+   |\n+   = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: the following trait defines an item `get_a`, perhaps you need to add a supertrait for it:\n+   |\n+LL | trait UseString2: GetString {\n+   |                 ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "e1d54fbf8aa7b3b63d97b21b3db74fdf74752526", "filename": "src/test/ui/traits/trait-as-struct-constructor.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ftraits%2Ftrait-as-struct-constructor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ftraits%2Ftrait-as-struct-constructor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-as-struct-constructor.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -6,3 +6,4 @@ LL |     TraitNotAStruct{ value: 0 };\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0574`."}, {"sha": "c94e43131faf0090fd230ad132a964be792c9f70", "filename": "src/test/ui/try-block/try-block-in-edition2015.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-edition2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-edition2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-edition2015.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -21,3 +21,4 @@ LL |     let try_result: Option<_> = try {\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0574`."}, {"sha": "bea61eae6b51a38e64bd8ff92e4069177ff7b342", "filename": "src/test/ui/underscore-imports/hygiene-2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,33 @@\n+// Make sure that underscore imports with different contexts can exist in the\n+// same scope.\n+\n+// check-pass\n+\n+#![feature(decl_macro)]\n+\n+mod x {\n+    pub use std::ops::Deref as _;\n+}\n+\n+macro n() {\n+    pub use crate::x::*;\n+}\n+\n+#[macro_export]\n+macro_rules! p {\n+    () => { pub use crate::x::*; }\n+}\n+\n+macro m($y:ident) {\n+    mod $y {\n+        crate::n!(); // Reexport of `Deref` should not be imported in `main`\n+        crate::p!(); // Reexport of `Deref` should be imported into `main`\n+    }\n+}\n+\n+m!(y);\n+\n+fn main() {\n+    use crate::y::*;\n+    (&()).deref();\n+}"}, {"sha": "a254f6eaa59807ea0a2721f9698b918a0d58851a", "filename": "src/test/ui/underscore-imports/hygiene.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,40 @@\n+// Make sure that underscore imports have the same hygiene considerations as\n+// other imports.\n+\n+#![feature(decl_macro)]\n+\n+mod x {\n+    pub use std::ops::Deref as _;\n+}\n+\n+\n+macro glob_import() {\n+    pub use crate::x::*;\n+}\n+\n+macro underscore_import() {\n+    use std::ops::DerefMut as _;\n+}\n+\n+mod y {\n+    crate::glob_import!();\n+    crate::underscore_import!();\n+}\n+\n+macro create_module($y:ident) {\n+    mod $y {\n+        crate::glob_import!();\n+        crate::underscore_import!();\n+    }\n+}\n+\n+create_module!(z);\n+\n+fn main() {\n+    use crate::y::*;\n+    use crate::z::*;\n+    glob_import!();\n+    underscore_import!();\n+    (&()).deref();              //~ ERROR no method named `deref`\n+    (&mut ()).deref_mut();      //~ ERROR no method named `deref_mut`\n+}"}, {"sha": "44cfc5cc5d22e21cbb17df7860b34e732f38c667", "filename": "src/test/ui/underscore-imports/hygiene.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,27 @@\n+error[E0599]: no method named `deref` found for type `&()` in the current scope\n+  --> $DIR/hygiene.rs:38:11\n+   |\n+LL |     (&()).deref();\n+   |           ^^^^^ method not found in `&()`\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use std::ops::Deref;\n+   |\n+\n+error[E0599]: no method named `deref_mut` found for type `&mut ()` in the current scope\n+  --> $DIR/hygiene.rs:39:15\n+   |\n+LL |     (&mut ()).deref_mut();\n+   |               ^^^^^^^^^ method not found in `&mut ()`\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n+   |\n+LL | use std::ops::DerefMut;\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "43f527bc9a4087866163a38a59b61c10ba088d76", "filename": "src/test/ui/underscore-imports/macro-expanded.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funderscore-imports%2Fmacro-expanded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funderscore-imports%2Fmacro-expanded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fmacro-expanded.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -0,0 +1,45 @@\n+// Check that macro expanded underscore imports behave as expected\n+\n+// check-pass\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+mod x {\n+    pub use std::ops::Not as _;\n+}\n+\n+macro m() {\n+    mod w {\n+        mod y {\n+            pub use std::ops::Deref as _;\n+        }\n+        use crate::x::*;\n+        use self::y::*;\n+        use std::ops::DerefMut as _;\n+        fn f() {\n+            false.not();\n+            (&()).deref();\n+            (&mut ()).deref_mut();\n+        }\n+    }\n+}\n+\n+#[rustc_macro_transparency = \"transparent\"]\n+macro n() {\n+    mod z {\n+        pub use std::ops::Deref as _;\n+    }\n+    use crate::x::*;\n+    use crate::z::*;\n+    use std::ops::DerefMut as _;\n+    fn f() {\n+        false.not();\n+        (&()).deref();\n+        (&mut ()).deref_mut();\n+    }\n+}\n+\n+m!();\n+n!();\n+\n+fn main() {}"}, {"sha": "11eae2af9c95f74711ca9c4e0e5e9c0a316129ff", "filename": "src/test/ui/uninhabited/always-inhabited-union-ref.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funinhabited%2Falways-inhabited-union-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funinhabited%2Falways-inhabited-union-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Falways-inhabited-union-ref.rs?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/always-inhabited-union-ref.rs"}, {"sha": "792ab6f59a43966382f1b7c3d73610f2b19e2ddf", "filename": "src/test/ui/uninhabited/always-inhabited-union-ref.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funinhabited%2Falways-inhabited-union-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Funinhabited%2Falways-inhabited-union-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Falways-inhabited-union-ref.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "previous_filename": "src/test/ui/always-inhabited-union-ref.stderr"}, {"sha": "6c23178c700112f12f41a4a7272a4f57b8555d31", "filename": "src/test/ui/use/issue-18986.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fuse%2Fissue-18986.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f54911c6f2971b98ede2d21ab8cabd7daa1110ba/src%2Ftest%2Fui%2Fuse%2Fissue-18986.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fissue-18986.stderr?ref=f54911c6f2971b98ede2d21ab8cabd7daa1110ba", "patch": "@@ -6,3 +6,4 @@ LL |         Trait { x: 42 } => ()\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0574`."}]}