{"sha": "0362b40e44b52deaa302559ccdf5719c5c8acbec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNjJiNDBlNDRiNTJkZWFhMzAyNTU5Y2NkZjU3MTljNWM4YWNiZWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T00:25:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T00:25:48Z"}, "message": "rollup merge of #20115: gereeter/split-module-building\n\nThis also gets rid of a bunch of unnecessary `.clone`s.\n\ncc @eddyb", "tree": {"sha": "d27ddc2b004f9470c03d1c7b3a690808be12a4b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d27ddc2b004f9470c03d1c7b3a690808be12a4b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0362b40e44b52deaa302559ccdf5719c5c8acbec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0362b40e44b52deaa302559ccdf5719c5c8acbec", "html_url": "https://github.com/rust-lang/rust/commit/0362b40e44b52deaa302559ccdf5719c5c8acbec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0362b40e44b52deaa302559ccdf5719c5c8acbec/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "836bcb6ef41a5a347950893ae70fccbe26bca40e", "url": "https://api.github.com/repos/rust-lang/rust/commits/836bcb6ef41a5a347950893ae70fccbe26bca40e", "html_url": "https://github.com/rust-lang/rust/commit/836bcb6ef41a5a347950893ae70fccbe26bca40e"}, {"sha": "c7a8240f024830c35b247ad954fd2a29475c7c73", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7a8240f024830c35b247ad954fd2a29475c7c73", "html_url": "https://github.com/rust-lang/rust/commit/c7a8240f024830c35b247ad954fd2a29475c7c73"}], "stats": {"total": 2606, "additions": 1308, "deletions": 1298}, "files": [{"sha": "7dbcc810b571b521a0b1435ea109eef9df387e25", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "added", "additions": 1282, "deletions": 0, "changes": 1282, "blob_url": "https://github.com/rust-lang/rust/blob/0362b40e44b52deaa302559ccdf5719c5c8acbec/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0362b40e44b52deaa302559ccdf5719c5c8acbec/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0362b40e44b52deaa302559ccdf5719c5c8acbec", "patch": "@@ -0,0 +1,1282 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Reduced graph building\n+//!\n+//! Here we build the \"reduced graph\": the graph of the module tree without\n+//! any imports resolved.\n+\n+use {DefModifiers, PUBLIC, IMPORTABLE};\n+use ImportDirective;\n+use ImportDirectiveSubclass::{mod, SingleImport, GlobImport};\n+use ImportResolution;\n+use Module;\n+use ModuleKind::*;\n+use Namespace::{TypeNS, ValueNS};\n+use NameBindings;\n+use ParentLink::{mod, ModuleParentLink, BlockParentLink};\n+use Resolver;\n+use RibKind::*;\n+use Shadowable;\n+use TypeNsDef;\n+use TypeParameters::HasTypeParameters;\n+\n+use self::DuplicateCheckingMode::*;\n+use self::NamespaceError::*;\n+\n+use rustc::metadata::csearch;\n+use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n+use rustc::middle::def::*;\n+use rustc::middle::subst::FnSpace;\n+\n+use syntax::ast::{Block, Crate};\n+use syntax::ast::{DeclItem, DefId};\n+use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n+use syntax::ast::{Item, ItemConst, ItemEnum, ItemFn};\n+use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy};\n+use syntax::ast::{MethodImplItem, Name, NamedField, NodeId};\n+use syntax::ast::{PathListIdent, PathListMod};\n+use syntax::ast::{Public, SelfStatic};\n+use syntax::ast::StmtDecl;\n+use syntax::ast::StructVariantKind;\n+use syntax::ast::TupleVariantKind;\n+use syntax::ast::TyObjectSum;\n+use syntax::ast::{TypeImplItem, UnnamedField};\n+use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n+use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast::{Visibility};\n+use syntax::ast::TyPath;\n+use syntax::ast;\n+use syntax::ast_util::{mod, PostExpansionMethod, local_def};\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse::token::{mod, special_idents};\n+use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::visit::{mod, Visitor};\n+\n+use std::rc::Rc;\n+use std::mem::replace;\n+\n+// Specifies how duplicates should be handled when adding a child item if\n+// another item exists with the same name in some namespace.\n+#[deriving(Copy, PartialEq)]\n+enum DuplicateCheckingMode {\n+    ForbidDuplicateModules,\n+    ForbidDuplicateTypesAndModules,\n+    ForbidDuplicateValues,\n+    ForbidDuplicateTypesAndValues,\n+    OverwriteDuplicates\n+}\n+\n+#[deriving(Copy, PartialEq)]\n+enum NamespaceError {\n+    NoError,\n+    ModuleError,\n+    TypeError,\n+    ValueError\n+}\n+\n+fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n+    match ns {\n+        NoError                 => \"\",\n+        ModuleError | TypeError => \"type or module\",\n+        ValueError              => \"value\",\n+    }\n+}\n+\n+struct GraphBuilder<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>\n+}\n+\n+impl<'a, 'b:'a, 'tcx:'b> Deref<Resolver<'b, 'tcx>> for GraphBuilder<'a, 'b, 'tcx> {\n+    fn deref(&self) -> &Resolver<'b, 'tcx> {\n+        &*self.resolver\n+    }\n+}\n+\n+impl<'a, 'b:'a, 'tcx:'b> DerefMut<Resolver<'b, 'tcx>> for GraphBuilder<'a, 'b, 'tcx> {\n+    fn deref_mut(&mut self) -> &mut Resolver<'b, 'tcx> {\n+        &mut *self.resolver\n+    }\n+}\n+\n+impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n+    /// Constructs the reduced graph for the entire crate.\n+    fn build_reduced_graph(self, krate: &ast::Crate) {\n+        let parent = self.graph_root.get_module();\n+        let mut visitor = BuildReducedGraphVisitor {\n+            builder: self,\n+            parent: parent\n+        };\n+        visit::walk_crate(&mut visitor, krate);\n+    }\n+\n+    /// Adds a new child item to the module definition of the parent node and\n+    /// returns its corresponding name bindings as well as the current parent.\n+    /// Or, if we're inside a block, creates (or reuses) an anonymous module\n+    /// corresponding to the innermost block ID and returns the name bindings\n+    /// as well as the newly-created parent.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if this node does not have a module definition and we are not inside\n+    /// a block.\n+    fn add_child(&self,\n+                 name: Name,\n+                 parent: &Rc<Module>,\n+                 duplicate_checking_mode: DuplicateCheckingMode,\n+                 // For printing errors\n+                 sp: Span)\n+                 -> Rc<NameBindings> {\n+        // If this is the immediate descendant of a module, then we add the\n+        // child name directly. Otherwise, we create or reuse an anonymous\n+        // module and add the child to that.\n+\n+        self.check_for_conflicts_between_external_crates_and_items(&**parent,\n+                                                                   name,\n+                                                                   sp);\n+\n+        // Add or reuse the child.\n+        let child = parent.children.borrow().get(&name).cloned();\n+        match child {\n+            None => {\n+                let child = Rc::new(NameBindings::new());\n+                parent.children.borrow_mut().insert(name, child.clone());\n+                child\n+            }\n+            Some(child) => {\n+                // Enforce the duplicate checking mode:\n+                //\n+                // * If we're requesting duplicate module checking, check that\n+                //   there isn't a module in the module with the same name.\n+                //\n+                // * If we're requesting duplicate type checking, check that\n+                //   there isn't a type in the module with the same name.\n+                //\n+                // * If we're requesting duplicate value checking, check that\n+                //   there isn't a value in the module with the same name.\n+                //\n+                // * If we're requesting duplicate type checking and duplicate\n+                //   value checking, check that there isn't a duplicate type\n+                //   and a duplicate value with the same name.\n+                //\n+                // * If no duplicate checking was requested at all, do\n+                //   nothing.\n+\n+                let mut duplicate_type = NoError;\n+                let ns = match duplicate_checking_mode {\n+                    ForbidDuplicateModules => {\n+                        if child.get_module_if_available().is_some() {\n+                            duplicate_type = ModuleError;\n+                        }\n+                        Some(TypeNS)\n+                    }\n+                    ForbidDuplicateTypesAndModules => {\n+                        match child.def_for_namespace(TypeNS) {\n+                            None => {}\n+                            Some(_) if child.get_module_if_available()\n+                                            .map(|m| m.kind.get()) ==\n+                                       Some(ImplModuleKind) => {}\n+                            Some(_) => duplicate_type = TypeError\n+                        }\n+                        Some(TypeNS)\n+                    }\n+                    ForbidDuplicateValues => {\n+                        if child.defined_in_namespace(ValueNS) {\n+                            duplicate_type = ValueError;\n+                        }\n+                        Some(ValueNS)\n+                    }\n+                    ForbidDuplicateTypesAndValues => {\n+                        let mut n = None;\n+                        match child.def_for_namespace(TypeNS) {\n+                            Some(DefMod(_)) | None => {}\n+                            Some(_) => {\n+                                n = Some(TypeNS);\n+                                duplicate_type = TypeError;\n+                            }\n+                        };\n+                        if child.defined_in_namespace(ValueNS) {\n+                            duplicate_type = ValueError;\n+                            n = Some(ValueNS);\n+                        }\n+                        n\n+                    }\n+                    OverwriteDuplicates => None\n+                };\n+                if duplicate_type != NoError {\n+                    // Return an error here by looking up the namespace that\n+                    // had the duplicate.\n+                    let ns = ns.unwrap();\n+                    self.resolve_error(sp,\n+                        format!(\"duplicate definition of {} `{}`\",\n+                             namespace_error_to_string(duplicate_type),\n+                             token::get_name(name))[]);\n+                    {\n+                        let r = child.span_for_namespace(ns);\n+                        for sp in r.iter() {\n+                            self.session.span_note(*sp,\n+                                 format!(\"first definition of {} `{}` here\",\n+                                      namespace_error_to_string(duplicate_type),\n+                                      token::get_name(name))[]);\n+                        }\n+                    }\n+                }\n+                child\n+            }\n+        }\n+    }\n+\n+    fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n+        // If the block has view items, we need an anonymous module.\n+        if block.view_items.len() > 0 {\n+            return true;\n+        }\n+\n+        // Check each statement.\n+        for statement in block.stmts.iter() {\n+            match statement.node {\n+                StmtDecl(ref declaration, _) => {\n+                    match declaration.node {\n+                        DeclItem(_) => {\n+                            return true;\n+                        }\n+                        _ => {\n+                            // Keep searching.\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // Keep searching.\n+                }\n+            }\n+        }\n+\n+        // If we found neither view items nor items, we don't need to create\n+        // an anonymous module.\n+\n+        return false;\n+    }\n+\n+    fn get_parent_link(&mut self, parent: &Rc<Module>, name: Name) -> ParentLink {\n+        ModuleParentLink(parent.downgrade(), name)\n+    }\n+\n+    /// Constructs the reduced graph for one item.\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, parent: &Rc<Module>) -> Rc<Module> {\n+        let name = item.ident.name;\n+        let sp = item.span;\n+        let is_public = item.vis == ast::Public;\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+\n+        match item.node {\n+            ItemMod(..) => {\n+                let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n+\n+                let parent_link = self.get_parent_link(parent, name);\n+                let def_id = DefId { krate: 0, node: item.id };\n+                name_bindings.define_module(parent_link,\n+                                            Some(def_id),\n+                                            NormalModuleKind,\n+                                            false,\n+                                            item.vis == ast::Public,\n+                                            sp);\n+\n+                name_bindings.get_module()\n+            }\n+\n+            ItemForeignMod(..) => parent.clone(),\n+\n+            // These items live in the value namespace.\n+            ItemStatic(_, m, _) => {\n+                let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n+                let mutbl = m == ast::MutMutable;\n+\n+                name_bindings.define_value(DefStatic(local_def(item.id), mutbl), sp, modifiers);\n+                parent.clone()\n+            }\n+            ItemConst(_, _) => {\n+                self.add_child(name, parent, ForbidDuplicateValues, sp)\n+                    .define_value(DefConst(local_def(item.id)), sp, modifiers);\n+                parent.clone()\n+            }\n+            ItemFn(_, _, _, _, _) => {\n+                let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n+\n+                let def = DefFn(local_def(item.id), false);\n+                name_bindings.define_value(def, sp, modifiers);\n+                parent.clone()\n+            }\n+\n+            // These items live in the type namespace.\n+            ItemTy(..) => {\n+                let name_bindings =\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+\n+                name_bindings.define_type(DefTy(local_def(item.id), false), sp, modifiers);\n+                parent.clone()\n+            }\n+\n+            ItemEnum(ref enum_definition, _) => {\n+                let name_bindings =\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+\n+                name_bindings.define_type(DefTy(local_def(item.id), true), sp, modifiers);\n+\n+                let parent_link = self.get_parent_link(parent, name);\n+                // We want to make sure the module type is EnumModuleKind\n+                // even if there's already an ImplModuleKind module defined,\n+                // since that's how we prevent duplicate enum definitions\n+                name_bindings.set_module_kind(parent_link,\n+                                              Some(local_def(item.id)),\n+                                              EnumModuleKind,\n+                                              false,\n+                                              is_public,\n+                                              sp);\n+\n+                let module = name_bindings.get_module();\n+\n+                for variant in (*enum_definition).variants.iter() {\n+                    self.build_reduced_graph_for_variant(\n+                        &**variant,\n+                        local_def(item.id),\n+                        &module);\n+                }\n+                parent.clone()\n+            }\n+\n+            // These items live in both the type and value namespaces.\n+            ItemStruct(ref struct_def, _) => {\n+                // Adding to both Type and Value namespaces or just Type?\n+                let (forbid, ctor_id) = match struct_def.ctor_id {\n+                    Some(ctor_id)   => (ForbidDuplicateTypesAndValues, Some(ctor_id)),\n+                    None            => (ForbidDuplicateTypesAndModules, None)\n+                };\n+\n+                let name_bindings = self.add_child(name, parent, forbid, sp);\n+\n+                // Define a name in the type namespace.\n+                name_bindings.define_type(DefTy(local_def(item.id), false), sp, modifiers);\n+\n+                // If this is a newtype or unit-like struct, define a name\n+                // in the value namespace as well\n+                if let Some(cid) = ctor_id {\n+                    name_bindings.define_value(DefStruct(local_def(cid)), sp, modifiers);\n+                }\n+\n+                // Record the def ID and fields of this struct.\n+                let named_fields = struct_def.fields.iter().filter_map(|f| {\n+                    match f.node.kind {\n+                        NamedField(ident, _) => Some(ident.name),\n+                        UnnamedField(_) => None\n+                    }\n+                }).collect();\n+                self.structs.insert(local_def(item.id), named_fields);\n+\n+                parent.clone()\n+            }\n+\n+            ItemImpl(_, _, None, ref ty, ref impl_items) => {\n+                // If this implements an anonymous trait, then add all the\n+                // methods within to a new module, if the type was defined\n+                // within this module.\n+\n+                let mod_name = match ty.node {\n+                    TyPath(ref path, _) if path.segments.len() == 1 => {\n+                        // FIXME(18446) we should distinguish between the name of\n+                        // a trait and the name of an impl of that trait.\n+                        Some(path.segments.last().unwrap().identifier.name)\n+                    }\n+                    TyObjectSum(ref lhs_ty, _) => {\n+                        match lhs_ty.node {\n+                            TyPath(ref path, _) if path.segments.len() == 1 => {\n+                                Some(path.segments.last().unwrap().identifier.name)\n+                            }\n+                            _ => {\n+                                None\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        None\n+                    }\n+                };\n+\n+                match mod_name {\n+                    None => {\n+                        self.resolve_error(ty.span,\n+                                           \"inherent implementations may \\\n+                                            only be implemented in the same \\\n+                                            module as the type they are \\\n+                                            implemented for\")\n+                    }\n+                    Some(mod_name) => {\n+                        // Create the module and add all methods.\n+                        let parent_opt = parent.children.borrow().get(&mod_name).cloned();\n+                        let new_parent = match parent_opt {\n+                            // It already exists\n+                            Some(ref child) if child.get_module_if_available()\n+                                .is_some() &&\n+                                (child.get_module().kind.get() == ImplModuleKind ||\n+                                 child.get_module().kind.get() == TraitModuleKind) => {\n+                                    child.get_module()\n+                                }\n+                            Some(ref child) if child.get_module_if_available()\n+                                .is_some() &&\n+                                child.get_module().kind.get() ==\n+                                EnumModuleKind => child.get_module(),\n+                            // Create the module\n+                            _ => {\n+                                let name_bindings =\n+                                    self.add_child(mod_name, parent, ForbidDuplicateModules, sp);\n+\n+                                let parent_link = self.get_parent_link(parent, name);\n+                                let def_id = local_def(item.id);\n+                                let ns = TypeNS;\n+                                let is_public =\n+                                    !name_bindings.defined_in_namespace(ns) ||\n+                                    name_bindings.defined_in_public_namespace(ns);\n+\n+                                name_bindings.define_module(parent_link,\n+                                                            Some(def_id),\n+                                                            ImplModuleKind,\n+                                                            false,\n+                                                            is_public,\n+                                                            sp);\n+\n+                                name_bindings.get_module()\n+                            }\n+                        };\n+\n+                        // For each implementation item...\n+                        for impl_item in impl_items.iter() {\n+                            match *impl_item {\n+                                MethodImplItem(ref method) => {\n+                                    // Add the method to the module.\n+                                    let name = method.pe_ident().name;\n+                                    let method_name_bindings =\n+                                        self.add_child(name,\n+                                                       &new_parent,\n+                                                       ForbidDuplicateValues,\n+                                                       method.span);\n+                                    let def = match method.pe_explicit_self()\n+                                        .node {\n+                                            SelfStatic => {\n+                                                // Static methods become\n+                                                // `DefStaticMethod`s.\n+                                                DefStaticMethod(local_def(method.id),\n+                                                                FromImpl(local_def(item.id)))\n+                                            }\n+                                            _ => {\n+                                                // Non-static methods become\n+                                                // `DefMethod`s.\n+                                                DefMethod(local_def(method.id),\n+                                                          None,\n+                                                          FromImpl(local_def(item.id)))\n+                                            }\n+                                        };\n+\n+                                    // NB: not IMPORTABLE\n+                                    let modifiers = if method.pe_vis() == ast::Public {\n+                                        PUBLIC\n+                                    } else {\n+                                        DefModifiers::empty()\n+                                    };\n+                                    method_name_bindings.define_value(\n+                                        def,\n+                                        method.span,\n+                                        modifiers);\n+                                }\n+                                TypeImplItem(ref typedef) => {\n+                                    // Add the typedef to the module.\n+                                    let name = typedef.ident.name;\n+                                    let typedef_name_bindings =\n+                                        self.add_child(\n+                                            name,\n+                                            &new_parent,\n+                                            ForbidDuplicateTypesAndModules,\n+                                            typedef.span);\n+                                    let def = DefAssociatedTy(local_def(\n+                                        typedef.id));\n+                                    // NB: not IMPORTABLE\n+                                    let modifiers = if typedef.vis == ast::Public {\n+                                        PUBLIC\n+                                    } else {\n+                                        DefModifiers::empty()\n+                                    };\n+                                    typedef_name_bindings.define_type(\n+                                        def,\n+                                        typedef.span,\n+                                        modifiers);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                parent.clone()\n+            }\n+\n+            ItemImpl(_, _, Some(_), _, _) => parent.clone(),\n+\n+            ItemTrait(_, _, _, ref items) => {\n+                let name_bindings =\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+\n+                // Add all the items within to a new module.\n+                let parent_link = self.get_parent_link(parent, name);\n+                name_bindings.define_module(parent_link,\n+                                            Some(local_def(item.id)),\n+                                            TraitModuleKind,\n+                                            false,\n+                                            item.vis == ast::Public,\n+                                            sp);\n+                let module_parent = name_bindings.get_module();\n+\n+                let def_id = local_def(item.id);\n+\n+                // Add the names of all the items to the trait info.\n+                for trait_item in items.iter() {\n+                    let (name, kind) = match *trait_item {\n+                        ast::RequiredMethod(_) |\n+                        ast::ProvidedMethod(_) => {\n+                            let ty_m = ast_util::trait_item_to_ty_method(trait_item);\n+\n+                            let name = ty_m.ident.name;\n+\n+                            // Add it as a name in the trait module.\n+                            let (def, static_flag) = match ty_m.explicit_self\n+                                                               .node {\n+                                SelfStatic => {\n+                                    // Static methods become `DefStaticMethod`s.\n+                                    (DefStaticMethod(\n+                                            local_def(ty_m.id),\n+                                            FromTrait(local_def(item.id))),\n+                                     StaticMethodTraitItemKind)\n+                                }\n+                                _ => {\n+                                    // Non-static methods become `DefMethod`s.\n+                                    (DefMethod(local_def(ty_m.id),\n+                                               Some(local_def(item.id)),\n+                                               FromTrait(local_def(item.id))),\n+                                     NonstaticMethodTraitItemKind)\n+                                }\n+                            };\n+\n+                            let method_name_bindings =\n+                                self.add_child(name,\n+                                               &module_parent,\n+                                               ForbidDuplicateTypesAndValues,\n+                                               ty_m.span);\n+                            // NB: not IMPORTABLE\n+                            method_name_bindings.define_value(def,\n+                                                              ty_m.span,\n+                                                              PUBLIC);\n+\n+                            (name, static_flag)\n+                        }\n+                        ast::TypeTraitItem(ref associated_type) => {\n+                            let def = DefAssociatedTy(local_def(\n+                                    associated_type.ty_param.id));\n+\n+                            let name_bindings =\n+                                self.add_child(associated_type.ty_param.ident.name,\n+                                               &module_parent,\n+                                               ForbidDuplicateTypesAndValues,\n+                                               associated_type.ty_param.span);\n+                            // NB: not IMPORTABLE\n+                            name_bindings.define_type(def,\n+                                                      associated_type.ty_param.span,\n+                                                      PUBLIC);\n+\n+                            (associated_type.ty_param.ident.name, TypeTraitItemKind)\n+                        }\n+                    };\n+\n+                    self.trait_item_map.insert((name, def_id), kind);\n+                }\n+\n+                name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n+                parent.clone()\n+            }\n+            ItemMac(..) => parent.clone()\n+        }\n+    }\n+\n+    // Constructs the reduced graph for one variant. Variants exist in the\n+    // type and value namespaces.\n+    fn build_reduced_graph_for_variant(&mut self,\n+                                       variant: &Variant,\n+                                       item_id: DefId,\n+                                       parent: &Rc<Module>) {\n+        let name = variant.node.name.name;\n+        let is_exported = match variant.node.kind {\n+            TupleVariantKind(_) => false,\n+            StructVariantKind(_) => {\n+                // Not adding fields for variants as they are not accessed with a self receiver\n+                self.structs.insert(local_def(variant.node.id), Vec::new());\n+                true\n+            }\n+        };\n+\n+        let child = self.add_child(name, parent,\n+                                   ForbidDuplicateTypesAndValues,\n+                                   variant.span);\n+        // variants are always treated as importable to allow them to be glob\n+        // used\n+        child.define_value(DefVariant(item_id,\n+                                      local_def(variant.node.id), is_exported),\n+                           variant.span, PUBLIC | IMPORTABLE);\n+        child.define_type(DefVariant(item_id,\n+                                     local_def(variant.node.id), is_exported),\n+                          variant.span, PUBLIC | IMPORTABLE);\n+    }\n+\n+    /// Constructs the reduced graph for one 'view item'. View items consist\n+    /// of imports and use directives.\n+    fn build_reduced_graph_for_view_item(&mut self, view_item: &ViewItem, parent: &Rc<Module>) {\n+        match view_item.node {\n+            ViewItemUse(ref view_path) => {\n+                // Extract and intern the module part of the path. For\n+                // globs and lists, the path is found directly in the AST;\n+                // for simple paths we have to munge the path a little.\n+                let module_path = match view_path.node {\n+                    ViewPathSimple(_, ref full_path, _) => {\n+                        full_path.segments\n+                            .init()\n+                            .iter().map(|ident| ident.identifier.name)\n+                            .collect()\n+                    }\n+\n+                    ViewPathGlob(ref module_ident_path, _) |\n+                    ViewPathList(ref module_ident_path, _, _) => {\n+                        module_ident_path.segments\n+                            .iter().map(|ident| ident.identifier.name).collect()\n+                    }\n+                };\n+\n+                // Build up the import directives.\n+                let is_public = view_item.vis == ast::Public;\n+                let shadowable =\n+                    view_item.attrs\n+                             .iter()\n+                             .any(|attr| {\n+                                 attr.name() == token::get_name(\n+                                    special_idents::prelude_import.name)\n+                             });\n+                let shadowable = if shadowable {\n+                    Shadowable::Always\n+                } else {\n+                    Shadowable::Never\n+                };\n+\n+                match view_path.node {\n+                    ViewPathSimple(binding, ref full_path, id) => {\n+                        let source_name =\n+                            full_path.segments.last().unwrap().identifier.name;\n+                        if token::get_name(source_name).get() == \"mod\" {\n+                            self.resolve_error(view_path.span,\n+                                \"`mod` imports are only allowed within a { } list\");\n+                        }\n+\n+                        let subclass = SingleImport(binding.name,\n+                                                    source_name);\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    subclass,\n+                                                    view_path.span,\n+                                                    id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                    ViewPathList(_, ref source_items, _) => {\n+                        // Make sure there's at most one `mod` import in the list.\n+                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n+                            PathListMod { .. } => Some(item.span),\n+                            _ => None\n+                        }).collect::<Vec<Span>>();\n+                        if mod_spans.len() > 1 {\n+                            self.resolve_error(mod_spans[0],\n+                                \"`mod` import can only appear once in the list\");\n+                            for other_span in mod_spans.iter().skip(1) {\n+                                self.session.span_note(*other_span,\n+                                    \"another `mod` import appears here\");\n+                            }\n+                        }\n+\n+                        for source_item in source_items.iter() {\n+                            let (module_path, name) = match source_item.node {\n+                                PathListIdent { name, .. } =>\n+                                    (module_path.clone(), name.name),\n+                                PathListMod { .. } => {\n+                                    let name = match module_path.last() {\n+                                        Some(name) => *name,\n+                                        None => {\n+                                            self.resolve_error(source_item.span,\n+                                                \"`mod` import can only appear in an import list \\\n+                                                 with a non-empty prefix\");\n+                                            continue;\n+                                        }\n+                                    };\n+                                    let module_path = module_path.init();\n+                                    (module_path.to_vec(), name)\n+                                }\n+                            };\n+                            self.build_import_directive(\n+                                &**parent,\n+                                module_path,\n+                                SingleImport(name, name),\n+                                source_item.span,\n+                                source_item.node.id(),\n+                                is_public,\n+                                shadowable);\n+                        }\n+                    }\n+                    ViewPathGlob(_, id) => {\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    GlobImport,\n+                                                    view_path.span,\n+                                                    id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                }\n+            }\n+\n+            ViewItemExternCrate(name, _, node_id) => {\n+                // n.b. we don't need to look at the path option here, because cstore already did\n+                for &crate_id in self.session.cstore\n+                                     .find_extern_mod_stmt_cnum(node_id).iter() {\n+                    let def_id = DefId { krate: crate_id, node: 0 };\n+                    self.external_exports.insert(def_id);\n+                    let parent_link = ModuleParentLink(parent.downgrade(), name.name);\n+                    let external_module = Rc::new(Module::new(parent_link,\n+                                                              Some(def_id),\n+                                                              NormalModuleKind,\n+                                                              false,\n+                                                              true));\n+                    debug!(\"(build reduced graph for item) found extern `{}`\",\n+                            self.module_to_string(&*external_module));\n+                    self.check_for_conflicts_between_external_crates(\n+                        &**parent,\n+                        name.name,\n+                        view_item.span);\n+                    parent.external_module_children.borrow_mut()\n+                          .insert(name.name, external_module.clone());\n+                    self.build_reduced_graph_for_external_crate(&external_module);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Constructs the reduced graph for one foreign item.\n+    fn build_reduced_graph_for_foreign_item<F>(&mut self,\n+                                               foreign_item: &ForeignItem,\n+                                               parent: &Rc<Module>,\n+                                               f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n+        let name = foreign_item.ident.name;\n+        let is_public = foreign_item.vis == ast::Public;\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let name_bindings =\n+            self.add_child(name, parent, ForbidDuplicateValues,\n+                           foreign_item.span);\n+\n+        match foreign_item.node {\n+            ForeignItemFn(_, ref generics) => {\n+                let def = DefFn(local_def(foreign_item.id), false);\n+                name_bindings.define_value(def, foreign_item.span, modifiers);\n+\n+                self.with_type_parameter_rib(\n+                    HasTypeParameters(generics,\n+                                      FnSpace,\n+                                      foreign_item.id,\n+                                      NormalRibKind),\n+                    f);\n+            }\n+            ForeignItemStatic(_, m) => {\n+                let def = DefStatic(local_def(foreign_item.id), m);\n+                name_bindings.define_value(def, foreign_item.span, modifiers);\n+\n+                f(self.resolver)\n+            }\n+        }\n+    }\n+\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &Rc<Module>) -> Rc<Module> {\n+        if self.block_needs_anonymous_module(block) {\n+            let block_id = block.id;\n+\n+            debug!(\"(building reduced graph for block) creating a new \\\n+                    anonymous module for block {}\",\n+                   block_id);\n+\n+            let new_module = Rc::new(Module::new(\n+                BlockParentLink(parent.downgrade(), block_id),\n+                None,\n+                AnonymousModuleKind,\n+                false,\n+                false));\n+            parent.anonymous_children.borrow_mut().insert(block_id, new_module.clone());\n+            new_module\n+        } else {\n+            parent.clone()\n+        }\n+    }\n+\n+    fn handle_external_def(&mut self,\n+                           def: Def,\n+                           vis: Visibility,\n+                           child_name_bindings: &NameBindings,\n+                           final_ident: &str,\n+                           name: Name,\n+                           new_parent: &Rc<Module>) {\n+        debug!(\"(building reduced graph for \\\n+                external crate) building external def, priv {}\",\n+               vis);\n+        let is_public = vis == ast::Public;\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let is_exported = is_public && match new_parent.def_id.get() {\n+            None => true,\n+            Some(did) => self.external_exports.contains(&did)\n+        };\n+        if is_exported {\n+            self.external_exports.insert(def.def_id());\n+        }\n+\n+        let kind = match def {\n+            DefTy(_, true) => EnumModuleKind,\n+            DefStruct(..) | DefTy(..) => ImplModuleKind,\n+            _ => NormalModuleKind\n+        };\n+\n+        match def {\n+          DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n+          DefTy(def_id, _) => {\n+            let type_def = child_name_bindings.type_def.borrow().clone();\n+            match type_def {\n+              Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n+                debug!(\"(building reduced graph for external crate) \\\n+                        already created module\");\n+                module_def.def_id.set(Some(def_id));\n+              }\n+              Some(_) | None => {\n+                debug!(\"(building reduced graph for \\\n+                        external crate) building module \\\n+                        {}\", final_ident);\n+                let parent_link = self.get_parent_link(new_parent, name);\n+\n+                child_name_bindings.define_module(parent_link,\n+                                                  Some(def_id),\n+                                                  kind,\n+                                                  true,\n+                                                  is_public,\n+                                                  DUMMY_SP);\n+              }\n+            }\n+          }\n+          _ => {}\n+        }\n+\n+        match def {\n+          DefMod(_) | DefForeignMod(_) => {}\n+          DefVariant(_, variant_id, is_struct) => {\n+              debug!(\"(building reduced graph for external crate) building \\\n+                      variant {}\",\n+                      final_ident);\n+              // variants are always treated as importable to allow them to be\n+              // glob used\n+              let modifiers = PUBLIC | IMPORTABLE;\n+              if is_struct {\n+                  child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                  // Not adding fields for variants as they are not accessed with a self receiver\n+                  self.structs.insert(variant_id, Vec::new());\n+              } else {\n+                  child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+              }\n+          }\n+          DefFn(ctor_id, true) => {\n+            child_name_bindings.define_value(\n+                csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n+                    .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n+          }\n+          DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n+            debug!(\"(building reduced graph for external \\\n+                    crate) building value (fn/static) {}\", final_ident);\n+            // impl methods have already been defined with the correct importability modifier\n+            let mut modifiers = match *child_name_bindings.value_def.borrow() {\n+                Some(ref def) => (modifiers & !IMPORTABLE) | (def.modifiers & IMPORTABLE),\n+                None => modifiers\n+            };\n+            if new_parent.kind.get() != NormalModuleKind {\n+                modifiers = modifiers & !IMPORTABLE;\n+            }\n+            child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+          }\n+          DefTrait(def_id) => {\n+              debug!(\"(building reduced graph for external \\\n+                      crate) building type {}\", final_ident);\n+\n+              // If this is a trait, add all the trait item names to the trait\n+              // info.\n+\n+              let trait_item_def_ids =\n+                csearch::get_trait_item_def_ids(&self.session.cstore, def_id);\n+              for trait_item_def_id in trait_item_def_ids.iter() {\n+                  let (trait_item_name, trait_item_kind) =\n+                      csearch::get_trait_item_name_and_kind(\n+                          &self.session.cstore,\n+                          trait_item_def_id.def_id());\n+\n+                  debug!(\"(building reduced graph for external crate) ... \\\n+                          adding trait item '{}'\",\n+                         token::get_name(trait_item_name));\n+\n+                  self.trait_item_map.insert((trait_item_name, def_id), trait_item_kind);\n+\n+                  if is_exported {\n+                      self.external_exports\n+                          .insert(trait_item_def_id.def_id());\n+                  }\n+              }\n+\n+              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+\n+              // Define a module if necessary.\n+              let parent_link = self.get_parent_link(new_parent, name);\n+              child_name_bindings.set_module_kind(parent_link,\n+                                                  Some(def_id),\n+                                                  TraitModuleKind,\n+                                                  true,\n+                                                  is_public,\n+                                                  DUMMY_SP)\n+          }\n+          DefTy(..) | DefAssociatedTy(..) | DefAssociatedPath(..) => {\n+              debug!(\"(building reduced graph for external \\\n+                      crate) building type {}\", final_ident);\n+\n+              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+          }\n+          DefStruct(def_id) => {\n+            debug!(\"(building reduced graph for external \\\n+                    crate) building type and value for {}\",\n+                   final_ident);\n+            child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+            let fields = csearch::get_struct_fields(&self.session.cstore, def_id).iter().map(|f| {\n+                f.name\n+            }).collect::<Vec<_>>();\n+\n+            if fields.len() == 0 {\n+                child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+            }\n+\n+            // Record the def ID and fields of this struct.\n+            self.structs.insert(def_id, fields);\n+          }\n+          DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n+          DefUse(..) | DefUpvar(..) | DefRegion(..) |\n+          DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n+            panic!(\"didn't expect `{}`\", def);\n+          }\n+        }\n+    }\n+\n+    /// Builds the reduced graph for a single item in an external crate.\n+    fn build_reduced_graph_for_external_crate_def(&mut self,\n+                                                  root: &Rc<Module>,\n+                                                  def_like: DefLike,\n+                                                  name: Name,\n+                                                  visibility: Visibility) {\n+        match def_like {\n+            DlDef(def) => {\n+                // Add the new child item, if necessary.\n+                match def {\n+                    DefForeignMod(def_id) => {\n+                        // Foreign modules have no names. Recur and populate\n+                        // eagerly.\n+                        csearch::each_child_of_item(&self.session.cstore,\n+                                                    def_id,\n+                                                    |def_like,\n+                                                     child_name,\n+                                                     vis| {\n+                            self.build_reduced_graph_for_external_crate_def(\n+                                root,\n+                                def_like,\n+                                child_name,\n+                                vis)\n+                        });\n+                    }\n+                    _ => {\n+                        let child_name_bindings =\n+                            self.add_child(name,\n+                                           root,\n+                                           OverwriteDuplicates,\n+                                           DUMMY_SP);\n+\n+                        self.handle_external_def(def,\n+                                                 visibility,\n+                                                 &*child_name_bindings,\n+                                                 token::get_name(name).get(),\n+                                                 name,\n+                                                 root);\n+                    }\n+                }\n+            }\n+            DlImpl(def) => {\n+                match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n+                    None => {}\n+                    Some(final_name) => {\n+                        let methods_opt =\n+                            csearch::get_methods_if_impl(&self.session.cstore, def);\n+                        match methods_opt {\n+                            Some(ref methods) if\n+                                methods.len() >= 1 => {\n+                                debug!(\"(building reduced graph for \\\n+                                        external crate) processing \\\n+                                        static methods for type name {}\",\n+                                        token::get_name(final_name));\n+\n+                                let child_name_bindings =\n+                                    self.add_child(\n+                                        final_name,\n+                                        root,\n+                                        OverwriteDuplicates,\n+                                        DUMMY_SP);\n+\n+                                // Process the static methods. First,\n+                                // create the module.\n+                                let type_module;\n+                                let type_def = child_name_bindings.type_def.borrow().clone();\n+                                match type_def {\n+                                    Some(TypeNsDef {\n+                                        module_def: Some(module_def),\n+                                        ..\n+                                    }) => {\n+                                        // We already have a module. This\n+                                        // is OK.\n+                                        type_module = module_def;\n+\n+                                        // Mark it as an impl module if\n+                                        // necessary.\n+                                        type_module.kind.set(ImplModuleKind);\n+                                    }\n+                                    Some(_) | None => {\n+                                        let parent_link =\n+                                            self.get_parent_link(root, final_name);\n+                                        child_name_bindings.define_module(\n+                                            parent_link,\n+                                            Some(def),\n+                                            ImplModuleKind,\n+                                            true,\n+                                            true,\n+                                            DUMMY_SP);\n+                                        type_module =\n+                                            child_name_bindings.\n+                                                get_module();\n+                                    }\n+                                }\n+\n+                                // Add each static method to the module.\n+                                let new_parent = type_module;\n+                                for method_info in methods.iter() {\n+                                    let name = method_info.name;\n+                                    debug!(\"(building reduced graph for \\\n+                                             external crate) creating \\\n+                                             static method '{}'\",\n+                                           token::get_name(name));\n+\n+                                    let method_name_bindings =\n+                                        self.add_child(name,\n+                                                       &new_parent,\n+                                                       OverwriteDuplicates,\n+                                                       DUMMY_SP);\n+                                    let def = DefFn(method_info.def_id, false);\n+\n+                                    // NB: not IMPORTABLE\n+                                    let modifiers = if visibility == ast::Public {\n+                                        PUBLIC\n+                                    } else {\n+                                        DefModifiers::empty()\n+                                    };\n+                                    method_name_bindings.define_value(\n+                                        def, DUMMY_SP, modifiers);\n+                                }\n+                            }\n+\n+                            // Otherwise, do nothing.\n+                            Some(_) | None => {}\n+                        }\n+                    }\n+                }\n+            }\n+            DlField => {\n+                debug!(\"(building reduced graph for external crate) \\\n+                        ignoring field\");\n+            }\n+        }\n+    }\n+\n+    /// Builds the reduced graph rooted at the given external module.\n+    fn populate_external_module(&mut self, module: &Rc<Module>) {\n+        debug!(\"(populating external module) attempting to populate {}\",\n+               self.module_to_string(&**module));\n+\n+        let def_id = match module.def_id.get() {\n+            None => {\n+                debug!(\"(populating external module) ... no def ID!\");\n+                return\n+            }\n+            Some(def_id) => def_id,\n+        };\n+\n+        csearch::each_child_of_item(&self.session.cstore,\n+                                    def_id,\n+                                    |def_like, child_name, visibility| {\n+            debug!(\"(populating external module) ... found ident: {}\",\n+                   token::get_name(child_name));\n+            self.build_reduced_graph_for_external_crate_def(module,\n+                                                            def_like,\n+                                                            child_name,\n+                                                            visibility)\n+        });\n+        module.populated.set(true)\n+    }\n+\n+    /// Ensures that the reduced graph rooted at the given external module\n+    /// is built, building it if it is not.\n+    fn populate_module_if_necessary(&mut self, module: &Rc<Module>) {\n+        if !module.populated.get() {\n+            self.populate_external_module(module)\n+        }\n+        assert!(module.populated.get())\n+    }\n+\n+    /// Builds the reduced graph rooted at the 'use' directive for an external\n+    /// crate.\n+    fn build_reduced_graph_for_external_crate(&mut self, root: &Rc<Module>) {\n+        csearch::each_top_level_item_of_crate(&self.session.cstore,\n+                                              root.def_id\n+                                                  .get()\n+                                                  .unwrap()\n+                                                  .krate,\n+                                              |def_like, name, visibility| {\n+            self.build_reduced_graph_for_external_crate_def(root, def_like, name, visibility)\n+        });\n+    }\n+\n+    /// Creates and adds an import directive to the given module.\n+    fn build_import_directive(&mut self,\n+                              module_: &Module,\n+                              module_path: Vec<Name>,\n+                              subclass: ImportDirectiveSubclass,\n+                              span: Span,\n+                              id: NodeId,\n+                              is_public: bool,\n+                              shadowable: Shadowable) {\n+        module_.imports.borrow_mut().push(ImportDirective::new(module_path,\n+                                                               subclass,\n+                                                               span,\n+                                                               id,\n+                                                               is_public,\n+                                                               shadowable));\n+        self.unresolved_imports += 1;\n+        // Bump the reference count on the name. Or, if this is a glob, set\n+        // the appropriate flag.\n+\n+        match subclass {\n+            SingleImport(target, _) => {\n+                debug!(\"(building import directive) building import \\\n+                        directive: {}::{}\",\n+                       self.names_to_string(module_.imports.borrow().last().unwrap()\n+                                                 .module_path[]),\n+                       token::get_name(target));\n+\n+                let mut import_resolutions = module_.import_resolutions\n+                                                    .borrow_mut();\n+                match import_resolutions.get_mut(&target) {\n+                    Some(resolution) => {\n+                        debug!(\"(building import directive) bumping \\\n+                                reference\");\n+                        resolution.outstanding_references += 1;\n+\n+                        // the source of this name is different now\n+                        resolution.type_id = id;\n+                        resolution.value_id = id;\n+                        resolution.is_public = is_public;\n+                        return;\n+                    }\n+                    None => {}\n+                }\n+                debug!(\"(building import directive) creating new\");\n+                let mut resolution = ImportResolution::new(id, is_public);\n+                resolution.outstanding_references = 1;\n+                import_resolutions.insert(target, resolution);\n+            }\n+            GlobImport => {\n+                // Set the glob flag. This tells us that we don't know the\n+                // module's exports ahead of time.\n+\n+                module_.glob_count.set(module_.glob_count.get() + 1);\n+            }\n+        }\n+    }\n+}\n+\n+struct BuildReducedGraphVisitor<'a, 'b:'a, 'tcx:'b> {\n+    builder: GraphBuilder<'a, 'b, 'tcx>,\n+    parent: Rc<Module>\n+}\n+\n+impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n+        let p = self.builder.build_reduced_graph_for_item(item, &self.parent);\n+        let old_parent = replace(&mut self.parent, p);\n+        visit::walk_item(self, item);\n+        self.parent = old_parent;\n+    }\n+\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+        let parent = &self.parent;\n+        self.builder.build_reduced_graph_for_foreign_item(foreign_item,\n+                                                          parent,\n+                                                          |r| {\n+            let mut v = BuildReducedGraphVisitor {\n+                builder: GraphBuilder { resolver: r },\n+                parent: parent.clone()\n+            };\n+            visit::walk_foreign_item(&mut v, foreign_item);\n+        })\n+    }\n+\n+    fn visit_view_item(&mut self, view_item: &ViewItem) {\n+        self.builder.build_reduced_graph_for_view_item(view_item, &self.parent);\n+    }\n+\n+    fn visit_block(&mut self, block: &Block) {\n+        let np = self.builder.build_reduced_graph_for_block(block, &self.parent);\n+        let old_parent = replace(&mut self.parent, np);\n+        visit::walk_block(self, block);\n+        self.parent = old_parent;\n+    }\n+}\n+\n+pub fn build_reduced_graph(resolver: &mut Resolver, krate: &ast::Crate) {\n+    GraphBuilder {\n+        resolver: resolver\n+    }.build_reduced_graph(krate);\n+}\n+\n+pub fn populate_module_if_necessary(resolver: &mut Resolver, module: &Rc<Module>) {\n+    GraphBuilder {\n+        resolver: resolver\n+    }.populate_module_if_necessary(module);\n+}"}, {"sha": "6b504d6d16e98cbcaedbe8210b72c4fbd8618a90", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 23, "deletions": 1297, "changes": 1320, "blob_url": "https://github.com/rust-lang/rust/blob/0362b40e44b52deaa302559ccdf5719c5c8acbec/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0362b40e44b52deaa302559ccdf5719c5c8acbec/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0362b40e44b52deaa302559ccdf5719c5c8acbec", "patch": "@@ -26,11 +26,9 @@ extern crate rustc;\n \n use self::PatternBindingMode::*;\n use self::Namespace::*;\n-use self::NamespaceError::*;\n use self::NamespaceResult::*;\n use self::NameDefinition::*;\n use self::ImportDirectiveSubclass::*;\n-use self::ReducedGraphParent::*;\n use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n@@ -40,7 +38,6 @@ use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n-use self::DuplicateCheckingMode::*;\n use self::ParentLink::*;\n use self::ModuleKind::*;\n use self::TraitReferenceType::*;\n@@ -60,34 +57,31 @@ use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n-use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n+use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n-use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n+use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local, LOCAL_CRATE};\n-use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n+use syntax::ast::{MethodImplItem, Mod, Name, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n-use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n-use syntax::ast::{PolyTraitRef, PrimTy, Public, SelfExplicit, SelfStatic};\n-use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n-use syntax::ast::{StructVariantKind, TraitRef, TraitTyParamBound};\n-use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n+use syntax::ast::{PatRange, PatStruct, Path};\n+use syntax::ast::{PolyTraitRef, PrimTy, SelfExplicit};\n+use syntax::ast::{RegionTyParamBound, StructField};\n+use syntax::ast::{TraitRef, TraitTyParamBound};\n+use syntax::ast::{Ty, TyBool, TyChar, TyClosure, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt, TyObjectSum};\n use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyPolyTraitRef, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n-use syntax::ast::{TypeImplItem, UnnamedField};\n-use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n-use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use syntax::ast::{Visibility};\n+use syntax::ast::{TypeImplItem};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{mod, PostExpansionMethod, local_def, walk_pat};\n+use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::{mod, special_names, special_idents};\n-use syntax::codemap::{Span, DUMMY_SP, Pos};\n+use syntax::codemap::{Span, Pos};\n use syntax::owned_slice::OwnedSlice;\n use syntax::visit::{mod, Visitor};\n \n@@ -100,6 +94,7 @@ use std::uint;\n \n mod check_unused;\n mod record_exports;\n+mod build_reduced_graph;\n \n #[deriving(Copy)]\n struct BindingInfo {\n@@ -123,14 +118,6 @@ enum Namespace {\n     ValueNS\n }\n \n-#[deriving(Copy, PartialEq)]\n-enum NamespaceError {\n-    NoError,\n-    ModuleError,\n-    TypeError,\n-    ValueError\n-}\n-\n /// A NamespaceResult represents the result of resolving an import in\n /// a particular namespace. The result is either definitely-resolved,\n /// definitely- unresolved, or unknown.\n@@ -197,22 +184,6 @@ enum ImportDirectiveSubclass {\n     GlobImport\n }\n \n-/// The context that we thread through while building the reduced graph.\n-#[deriving(Clone)]\n-enum ReducedGraphParent {\n-    ModuleReducedGraphParent(Rc<Module>)\n-}\n-\n-impl ReducedGraphParent {\n-    fn module(&self) -> Rc<Module> {\n-        match *self {\n-            ModuleReducedGraphParent(ref m) => {\n-                m.clone()\n-            }\n-        }\n-    }\n-}\n-\n type ErrorMessage = Option<(Span, String)>;\n \n enum ResolveResult<T> {\n@@ -314,17 +285,6 @@ enum BareIdentifierPatternResolution {\n     BareIdentifierPatternUnresolved\n }\n \n-// Specifies how duplicates should be handled when adding a child item if\n-// another item exists with the same name in some namespace.\n-#[deriving(Copy, PartialEq)]\n-enum DuplicateCheckingMode {\n-    ForbidDuplicateModules,\n-    ForbidDuplicateTypesAndModules,\n-    ForbidDuplicateValues,\n-    ForbidDuplicateTypesAndValues,\n-    OverwriteDuplicates\n-}\n-\n /// One local scope.\n #[deriving(Show)]\n struct Rib {\n@@ -865,15 +825,6 @@ impl PrimitiveTypeTable {\n     }\n }\n \n-\n-fn namespace_error_to_string(ns: NamespaceError) -> &'static str {\n-    match ns {\n-        NoError                 => \"\",\n-        ModuleError | TypeError => \"type or module\",\n-        ValueError              => \"value\",\n-    }\n-}\n-\n /// The main resolver class.\n struct Resolver<'a, 'tcx:'a> {\n     session: &'a Session,\n@@ -939,46 +890,6 @@ struct Resolver<'a, 'tcx:'a> {\n     used_crates: HashSet<CrateNum>,\n }\n \n-struct BuildReducedGraphVisitor<'a, 'b:'a, 'tcx:'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>,\n-    parent: ReducedGraphParent\n-}\n-\n-impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n-\n-    fn visit_item(&mut self, item: &Item) {\n-        let p = self.resolver.build_reduced_graph_for_item(item, self.parent.clone());\n-        let old_parent = replace(&mut self.parent, p);\n-        visit::walk_item(self, item);\n-        self.parent = old_parent;\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        let parent = self.parent.clone();\n-        self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                           parent.clone(),\n-                                                           |r| {\n-            let mut v = BuildReducedGraphVisitor {\n-                resolver: r,\n-                parent: parent.clone()\n-            };\n-            visit::walk_foreign_item(&mut v, foreign_item);\n-        })\n-    }\n-\n-    fn visit_view_item(&mut self, view_item: &ViewItem) {\n-        self.resolver.build_reduced_graph_for_view_item(view_item, self.parent.clone());\n-    }\n-\n-    fn visit_block(&mut self, block: &Block) {\n-        let np = self.resolver.build_reduced_graph_for_block(block, self.parent.clone());\n-        let old_parent = replace(&mut self.parent, np);\n-        visit::walk_block(self, block);\n-        self.parent = old_parent;\n-    }\n-\n-}\n-\n #[deriving(PartialEq)]\n enum FallbackChecks {\n     Everything,\n@@ -1047,1191 +958,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    //\n-    // Reduced graph building\n-    //\n-    // Here we build the \"reduced graph\": the graph of the module tree without\n-    // any imports resolved.\n-    //\n-\n-    /// Constructs the reduced graph for the entire crate.\n-    fn build_reduced_graph(&mut self, krate: &ast::Crate) {\n-        let parent = ModuleReducedGraphParent(self.graph_root.get_module());\n-        let mut visitor = BuildReducedGraphVisitor {\n-            resolver: self,\n-            parent: parent\n-        };\n-        visit::walk_crate(&mut visitor, krate);\n-    }\n-\n-    /// Adds a new child item to the module definition of the parent node and\n-    /// returns its corresponding name bindings as well as the current parent.\n-    /// Or, if we're inside a block, creates (or reuses) an anonymous module\n-    /// corresponding to the innermost block ID and returns the name bindings\n-    /// as well as the newly-created parent.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if this node does not have a module definition and we are not inside\n-    /// a block.\n-    fn add_child(&self,\n-                 name: Name,\n-                 reduced_graph_parent: ReducedGraphParent,\n-                 duplicate_checking_mode: DuplicateCheckingMode,\n-                 // For printing errors\n-                 sp: Span)\n-                 -> Rc<NameBindings> {\n-        // If this is the immediate descendant of a module, then we add the\n-        // child name directly. Otherwise, we create or reuse an anonymous\n-        // module and add the child to that.\n-\n-        let module_ = reduced_graph_parent.module();\n-\n-        self.check_for_conflicts_between_external_crates_and_items(&*module_,\n-                                                                   name,\n-                                                                   sp);\n-\n-        // Add or reuse the child.\n-        let child = module_.children.borrow().get(&name).cloned();\n-        match child {\n-            None => {\n-                let child = Rc::new(NameBindings::new());\n-                module_.children.borrow_mut().insert(name, child.clone());\n-                child\n-            }\n-            Some(child) => {\n-                // Enforce the duplicate checking mode:\n-                //\n-                // * If we're requesting duplicate module checking, check that\n-                //   there isn't a module in the module with the same name.\n-                //\n-                // * If we're requesting duplicate type checking, check that\n-                //   there isn't a type in the module with the same name.\n-                //\n-                // * If we're requesting duplicate value checking, check that\n-                //   there isn't a value in the module with the same name.\n-                //\n-                // * If we're requesting duplicate type checking and duplicate\n-                //   value checking, check that there isn't a duplicate type\n-                //   and a duplicate value with the same name.\n-                //\n-                // * If no duplicate checking was requested at all, do\n-                //   nothing.\n-\n-                let mut duplicate_type = NoError;\n-                let ns = match duplicate_checking_mode {\n-                    ForbidDuplicateModules => {\n-                        if child.get_module_if_available().is_some() {\n-                            duplicate_type = ModuleError;\n-                        }\n-                        Some(TypeNS)\n-                    }\n-                    ForbidDuplicateTypesAndModules => {\n-                        match child.def_for_namespace(TypeNS) {\n-                            None => {}\n-                            Some(_) if child.get_module_if_available()\n-                                            .map(|m| m.kind.get()) ==\n-                                       Some(ImplModuleKind) => {}\n-                            Some(_) => duplicate_type = TypeError\n-                        }\n-                        Some(TypeNS)\n-                    }\n-                    ForbidDuplicateValues => {\n-                        if child.defined_in_namespace(ValueNS) {\n-                            duplicate_type = ValueError;\n-                        }\n-                        Some(ValueNS)\n-                    }\n-                    ForbidDuplicateTypesAndValues => {\n-                        let mut n = None;\n-                        match child.def_for_namespace(TypeNS) {\n-                            Some(DefMod(_)) | None => {}\n-                            Some(_) => {\n-                                n = Some(TypeNS);\n-                                duplicate_type = TypeError;\n-                            }\n-                        };\n-                        if child.defined_in_namespace(ValueNS) {\n-                            duplicate_type = ValueError;\n-                            n = Some(ValueNS);\n-                        }\n-                        n\n-                    }\n-                    OverwriteDuplicates => None\n-                };\n-                if duplicate_type != NoError {\n-                    // Return an error here by looking up the namespace that\n-                    // had the duplicate.\n-                    let ns = ns.unwrap();\n-                    self.resolve_error(sp,\n-                        format!(\"duplicate definition of {} `{}`\",\n-                             namespace_error_to_string(duplicate_type),\n-                             token::get_name(name))[]);\n-                    {\n-                        let r = child.span_for_namespace(ns);\n-                        for sp in r.iter() {\n-                            self.session.span_note(*sp,\n-                                 format!(\"first definition of {} `{}` here\",\n-                                      namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name))[]);\n-                        }\n-                    }\n-                }\n-                child\n-            }\n-        }\n-    }\n-\n-    fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        // If the block has view items, we need an anonymous module.\n-        if block.view_items.len() > 0 {\n-            return true;\n-        }\n-\n-        // Check each statement.\n-        for statement in block.stmts.iter() {\n-            match statement.node {\n-                StmtDecl(ref declaration, _) => {\n-                    match declaration.node {\n-                        DeclItem(_) => {\n-                            return true;\n-                        }\n-                        _ => {\n-                            // Keep searching.\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // Keep searching.\n-                }\n-            }\n-        }\n-\n-        // If we found neither view items nor items, we don't need to create\n-        // an anonymous module.\n-\n-        return false;\n-    }\n-\n-    fn get_parent_link(&mut self, parent: ReducedGraphParent, name: Name)\n-                       -> ParentLink {\n-        match parent {\n-            ModuleReducedGraphParent(module_) => {\n-                return ModuleParentLink(module_.downgrade(), name);\n-            }\n-        }\n-    }\n-\n-    /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self,\n-                                    item: &Item,\n-                                    parent: ReducedGraphParent)\n-                                    -> ReducedGraphParent\n-    {\n-        let name = item.ident.name;\n-        let sp = item.span;\n-        let is_public = item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n-\n-        match item.node {\n-            ItemMod(..) => {\n-                let name_bindings =\n-                    self.add_child(name, parent.clone(), ForbidDuplicateModules, sp);\n-\n-                let parent_link = self.get_parent_link(parent, name);\n-                let def_id = DefId { krate: 0, node: item.id };\n-                name_bindings.define_module(parent_link,\n-                                            Some(def_id),\n-                                            NormalModuleKind,\n-                                            false,\n-                                            item.vis == ast::Public,\n-                                            sp);\n-\n-                ModuleReducedGraphParent(name_bindings.get_module())\n-            }\n-\n-            ItemForeignMod(..) => parent,\n-\n-            // These items live in the value namespace.\n-            ItemStatic(_, m, _) => {\n-                let name_bindings =\n-                    self.add_child(name, parent.clone(), ForbidDuplicateValues, sp);\n-                let mutbl = m == ast::MutMutable;\n-\n-                name_bindings.define_value\n-                    (DefStatic(local_def(item.id), mutbl), sp, modifiers);\n-                parent\n-            }\n-            ItemConst(_, _) => {\n-                self.add_child(name, parent.clone(), ForbidDuplicateValues, sp)\n-                    .define_value(DefConst(local_def(item.id)),\n-                                  sp, modifiers);\n-                parent\n-            }\n-            ItemFn(_, _, _, _, _) => {\n-                let name_bindings =\n-                    self.add_child(name, parent.clone(), ForbidDuplicateValues, sp);\n-\n-                let def = DefFn(local_def(item.id), false);\n-                name_bindings.define_value(def, sp, modifiers);\n-                parent\n-            }\n-\n-            // These items live in the type namespace.\n-            ItemTy(..) => {\n-                let name_bindings =\n-                    self.add_child(name,\n-                                   parent.clone(),\n-                                   ForbidDuplicateTypesAndModules,\n-                                   sp);\n-\n-                name_bindings.define_type\n-                    (DefTy(local_def(item.id), false), sp, modifiers);\n-                parent\n-            }\n-\n-            ItemEnum(ref enum_definition, _) => {\n-                let name_bindings =\n-                    self.add_child(name,\n-                                   parent.clone(),\n-                                   ForbidDuplicateTypesAndModules,\n-                                   sp);\n-\n-                name_bindings.define_type\n-                    (DefTy(local_def(item.id), true), sp, modifiers);\n-\n-                let parent_link = self.get_parent_link(parent.clone(), name);\n-                // We want to make sure the module type is EnumModuleKind\n-                // even if there's already an ImplModuleKind module defined,\n-                // since that's how we prevent duplicate enum definitions\n-                name_bindings.set_module_kind(parent_link,\n-                                              Some(local_def(item.id)),\n-                                              EnumModuleKind,\n-                                              false,\n-                                              is_public,\n-                                              sp);\n-\n-                for variant in (*enum_definition).variants.iter() {\n-                    self.build_reduced_graph_for_variant(\n-                        &**variant,\n-                        local_def(item.id),\n-                        ModuleReducedGraphParent(name_bindings.get_module()));\n-                }\n-                parent\n-            }\n-\n-            // These items live in both the type and value namespaces.\n-            ItemStruct(ref struct_def, _) => {\n-                // Adding to both Type and Value namespaces or just Type?\n-                let (forbid, ctor_id) = match struct_def.ctor_id {\n-                    Some(ctor_id)   => (ForbidDuplicateTypesAndValues, Some(ctor_id)),\n-                    None            => (ForbidDuplicateTypesAndModules, None)\n-                };\n-\n-                let name_bindings = self.add_child(name, parent.clone(), forbid, sp);\n-\n-                // Define a name in the type namespace.\n-                name_bindings.define_type(DefTy(local_def(item.id), false), sp, modifiers);\n-\n-                // If this is a newtype or unit-like struct, define a name\n-                // in the value namespace as well\n-                match ctor_id {\n-                    Some(cid) => {\n-                        name_bindings.define_value(DefStruct(local_def(cid)),\n-                                                   sp, modifiers);\n-                    }\n-                    None => {}\n-                }\n-\n-                // Record the def ID and fields of this struct.\n-                let named_fields = struct_def.fields.iter().filter_map(|f| {\n-                    match f.node.kind {\n-                        NamedField(ident, _) => Some(ident.name),\n-                        UnnamedField(_) => None\n-                    }\n-                }).collect();\n-                self.structs.insert(local_def(item.id), named_fields);\n-\n-                parent\n-            }\n-\n-            ItemImpl(_, _, None, ref ty, ref impl_items) => {\n-                // If this implements an anonymous trait, then add all the\n-                // methods within to a new module, if the type was defined\n-                // within this module.\n-\n-                let mod_name = match ty.node {\n-                    TyPath(ref path, _) if path.segments.len() == 1 => {\n-                        // FIXME(18446) we should distinguish between the name of\n-                        // a trait and the name of an impl of that trait.\n-                        Some(path.segments.last().unwrap().identifier.name)\n-                    }\n-                    TyObjectSum(ref lhs_ty, _) => {\n-                        match lhs_ty.node {\n-                            TyPath(ref path, _) if path.segments.len() == 1 => {\n-                                Some(path.segments.last().unwrap().identifier.name)\n-                            }\n-                            _ => {\n-                                None\n-                            }\n-                        }\n-                    }\n-                    _ => {\n-                        None\n-                    }\n-                };\n-\n-                match mod_name {\n-                    None => {\n-                        self.resolve_error(ty.span,\n-                                           \"inherent implementations may \\\n-                                            only be implemented in the same \\\n-                                            module as the type they are \\\n-                                            implemented for\")\n-                    }\n-                    Some(mod_name) => {\n-                        // Create the module and add all methods.\n-                        let parent_opt = parent.module().children.borrow()\n-                            .get(&mod_name).cloned();\n-                        let new_parent = match parent_opt {\n-                            // It already exists\n-                            Some(ref child) if child.get_module_if_available()\n-                                .is_some() &&\n-                                (child.get_module().kind.get() == ImplModuleKind ||\n-                                 child.get_module().kind.get() == TraitModuleKind) => {\n-                                    ModuleReducedGraphParent(child.get_module())\n-                                }\n-                            Some(ref child) if child.get_module_if_available()\n-                                .is_some() &&\n-                                child.get_module().kind.get() ==\n-                                EnumModuleKind => {\n-                                    ModuleReducedGraphParent(child.get_module())\n-                                }\n-                            // Create the module\n-                            _ => {\n-                                let name_bindings =\n-                                    self.add_child(mod_name,\n-                                                   parent.clone(),\n-                                                   ForbidDuplicateModules,\n-                                                   sp);\n-\n-                                let parent_link =\n-                                    self.get_parent_link(parent.clone(), name);\n-                                let def_id = local_def(item.id);\n-                                let ns = TypeNS;\n-                                let is_public =\n-                                    !name_bindings.defined_in_namespace(ns) ||\n-                                    name_bindings.defined_in_public_namespace(ns);\n-\n-                                name_bindings.define_module(parent_link,\n-                                                            Some(def_id),\n-                                                            ImplModuleKind,\n-                                                            false,\n-                                                            is_public,\n-                                                            sp);\n-\n-                                ModuleReducedGraphParent(\n-                                    name_bindings.get_module())\n-                            }\n-                        };\n-\n-                        // For each implementation item...\n-                        for impl_item in impl_items.iter() {\n-                            match *impl_item {\n-                                MethodImplItem(ref method) => {\n-                                    // Add the method to the module.\n-                                    let name = method.pe_ident().name;\n-                                    let method_name_bindings =\n-                                        self.add_child(name,\n-                                                       new_parent.clone(),\n-                                                       ForbidDuplicateValues,\n-                                                       method.span);\n-                                    let def = match method.pe_explicit_self()\n-                                        .node {\n-                                            SelfStatic => {\n-                                                // Static methods become\n-                                                // `DefStaticMethod`s.\n-                                                DefStaticMethod(local_def(method.id),\n-                                                                FromImpl(local_def(item.id)))\n-                                            }\n-                                            _ => {\n-                                                // Non-static methods become\n-                                                // `DefMethod`s.\n-                                                DefMethod(local_def(method.id),\n-                                                          None,\n-                                                          FromImpl(local_def(item.id)))\n-                                            }\n-                                        };\n-\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if method.pe_vis() == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    method_name_bindings.define_value(\n-                                        def,\n-                                        method.span,\n-                                        modifiers);\n-                                }\n-                                TypeImplItem(ref typedef) => {\n-                                    // Add the typedef to the module.\n-                                    let name = typedef.ident.name;\n-                                    let typedef_name_bindings =\n-                                        self.add_child(\n-                                            name,\n-                                            new_parent.clone(),\n-                                            ForbidDuplicateTypesAndModules,\n-                                            typedef.span);\n-                                    let def = DefAssociatedTy(local_def(\n-                                        typedef.id));\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if typedef.vis == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    typedef_name_bindings.define_type(\n-                                        def,\n-                                        typedef.span,\n-                                        modifiers);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                parent\n-            }\n-\n-            ItemImpl(_, _, Some(_), _, _) => parent,\n-\n-            ItemTrait(_, _, _, ref items) => {\n-                let name_bindings =\n-                    self.add_child(name,\n-                                   parent.clone(),\n-                                   ForbidDuplicateTypesAndModules,\n-                                   sp);\n-\n-                // Add all the items within to a new module.\n-                let parent_link = self.get_parent_link(parent.clone(), name);\n-                name_bindings.define_module(parent_link,\n-                                            Some(local_def(item.id)),\n-                                            TraitModuleKind,\n-                                            false,\n-                                            item.vis == ast::Public,\n-                                            sp);\n-                let module_parent = ModuleReducedGraphParent(name_bindings.\n-                                                             get_module());\n-\n-                let def_id = local_def(item.id);\n-\n-                // Add the names of all the items to the trait info.\n-                for trait_item in items.iter() {\n-                    let (name, kind) = match *trait_item {\n-                        ast::RequiredMethod(_) |\n-                        ast::ProvidedMethod(_) => {\n-                            let ty_m = ast_util::trait_item_to_ty_method(trait_item);\n-\n-                            let name = ty_m.ident.name;\n-\n-                            // Add it as a name in the trait module.\n-                            let (def, static_flag) = match ty_m.explicit_self\n-                                                               .node {\n-                                SelfStatic => {\n-                                    // Static methods become `DefStaticMethod`s.\n-                                    (DefStaticMethod(\n-                                            local_def(ty_m.id),\n-                                            FromTrait(local_def(item.id))),\n-                                     StaticMethodTraitItemKind)\n-                                }\n-                                _ => {\n-                                    // Non-static methods become `DefMethod`s.\n-                                    (DefMethod(local_def(ty_m.id),\n-                                               Some(local_def(item.id)),\n-                                               FromTrait(local_def(item.id))),\n-                                     NonstaticMethodTraitItemKind)\n-                                }\n-                            };\n-\n-                            let method_name_bindings =\n-                                self.add_child(name,\n-                                               module_parent.clone(),\n-                                               ForbidDuplicateTypesAndValues,\n-                                               ty_m.span);\n-                            // NB: not IMPORTABLE\n-                            method_name_bindings.define_value(def,\n-                                                              ty_m.span,\n-                                                              PUBLIC);\n-\n-                            (name, static_flag)\n-                        }\n-                        ast::TypeTraitItem(ref associated_type) => {\n-                            let def = DefAssociatedTy(local_def(\n-                                    associated_type.ty_param.id));\n-\n-                            let name_bindings =\n-                                self.add_child(associated_type.ty_param.ident.name,\n-                                               module_parent.clone(),\n-                                               ForbidDuplicateTypesAndValues,\n-                                               associated_type.ty_param.span);\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_type(def,\n-                                                      associated_type.ty_param.span,\n-                                                      PUBLIC);\n-\n-                            (associated_type.ty_param.ident.name, TypeTraitItemKind)\n-                        }\n-                    };\n-\n-                    self.trait_item_map.insert((name, def_id), kind);\n-                }\n-\n-                name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n-                parent\n-            }\n-            ItemMac(..) => parent\n-        }\n-    }\n-\n-    // Constructs the reduced graph for one variant. Variants exist in the\n-    // type and value namespaces.\n-    fn build_reduced_graph_for_variant(&mut self,\n-                                       variant: &Variant,\n-                                       item_id: DefId,\n-                                       parent: ReducedGraphParent) {\n-        let name = variant.node.name.name;\n-        let is_exported = match variant.node.kind {\n-            TupleVariantKind(_) => false,\n-            StructVariantKind(_) => {\n-                // Not adding fields for variants as they are not accessed with a self receiver\n-                self.structs.insert(local_def(variant.node.id), Vec::new());\n-                true\n-            }\n-        };\n-\n-        let child = self.add_child(name, parent,\n-                                   ForbidDuplicateTypesAndValues,\n-                                   variant.span);\n-        // variants are always treated as importable to allow them to be glob\n-        // used\n-        child.define_value(DefVariant(item_id,\n-                                      local_def(variant.node.id), is_exported),\n-                           variant.span, PUBLIC | IMPORTABLE);\n-        child.define_type(DefVariant(item_id,\n-                                     local_def(variant.node.id), is_exported),\n-                          variant.span, PUBLIC | IMPORTABLE);\n-    }\n-\n-    /// Constructs the reduced graph for one 'view item'. View items consist\n-    /// of imports and use directives.\n-    fn build_reduced_graph_for_view_item(&mut self, view_item: &ViewItem,\n-                                         parent: ReducedGraphParent) {\n-        match view_item.node {\n-            ViewItemUse(ref view_path) => {\n-                // Extract and intern the module part of the path. For\n-                // globs and lists, the path is found directly in the AST;\n-                // for simple paths we have to munge the path a little.\n-                let module_path = match view_path.node {\n-                    ViewPathSimple(_, ref full_path, _) => {\n-                        full_path.segments\n-                            .init()\n-                            .iter().map(|ident| ident.identifier.name)\n-                            .collect()\n-                    }\n-\n-                    ViewPathGlob(ref module_ident_path, _) |\n-                    ViewPathList(ref module_ident_path, _, _) => {\n-                        module_ident_path.segments\n-                            .iter().map(|ident| ident.identifier.name).collect()\n-                    }\n-                };\n-\n-                // Build up the import directives.\n-                let module_ = parent.module();\n-                let is_public = view_item.vis == ast::Public;\n-                let shadowable =\n-                    view_item.attrs\n-                             .iter()\n-                             .any(|attr| {\n-                                 attr.name() == token::get_name(\n-                                    special_idents::prelude_import.name)\n-                             });\n-                let shadowable = if shadowable {\n-                    Shadowable::Always\n-                } else {\n-                    Shadowable::Never\n-                };\n-\n-                match view_path.node {\n-                    ViewPathSimple(binding, ref full_path, id) => {\n-                        let source_name =\n-                            full_path.segments.last().unwrap().identifier.name;\n-                        if token::get_name(source_name).get() == \"mod\" {\n-                            self.resolve_error(view_path.span,\n-                                \"`mod` imports are only allowed within a { } list\");\n-                        }\n-\n-                        let subclass = SingleImport(binding.name,\n-                                                    source_name);\n-                        self.build_import_directive(&*module_,\n-                                                    module_path,\n-                                                    subclass,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                    ViewPathList(_, ref source_items, _) => {\n-                        // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n-                            PathListMod { .. } => Some(item.span),\n-                            _ => None\n-                        }).collect::<Vec<Span>>();\n-                        if mod_spans.len() > 1 {\n-                            self.resolve_error(mod_spans[0],\n-                                \"`mod` import can only appear once in the list\");\n-                            for other_span in mod_spans.iter().skip(1) {\n-                                self.session.span_note(*other_span,\n-                                    \"another `mod` import appears here\");\n-                            }\n-                        }\n-\n-                        for source_item in source_items.iter() {\n-                            let (module_path, name) = match source_item.node {\n-                                PathListIdent { name, .. } =>\n-                                    (module_path.clone(), name.name),\n-                                PathListMod { .. } => {\n-                                    let name = match module_path.last() {\n-                                        Some(name) => *name,\n-                                        None => {\n-                                            self.resolve_error(source_item.span,\n-                                                \"`mod` import can only appear in an import list \\\n-                                                 with a non-empty prefix\");\n-                                            continue;\n-                                        }\n-                                    };\n-                                    let module_path = module_path.init();\n-                                    (module_path.to_vec(), name)\n-                                }\n-                            };\n-                            self.build_import_directive(\n-                                &*module_,\n-                                module_path,\n-                                SingleImport(name, name),\n-                                source_item.span,\n-                                source_item.node.id(),\n-                                is_public,\n-                                shadowable);\n-                        }\n-                    }\n-                    ViewPathGlob(_, id) => {\n-                        self.build_import_directive(&*module_,\n-                                                    module_path,\n-                                                    GlobImport,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                }\n-            }\n-\n-            ViewItemExternCrate(name, _, node_id) => {\n-                // n.b. we don't need to look at the path option here, because cstore already did\n-                for &crate_id in self.session.cstore\n-                                     .find_extern_mod_stmt_cnum(node_id).iter() {\n-                    let def_id = DefId { krate: crate_id, node: 0 };\n-                    self.external_exports.insert(def_id);\n-                    let parent_link =\n-                        ModuleParentLink(parent.module().downgrade(), name.name);\n-                    let external_module = Rc::new(Module::new(parent_link,\n-                                                              Some(def_id),\n-                                                              NormalModuleKind,\n-                                                              false,\n-                                                              true));\n-                    debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            self.module_to_string(&*external_module));\n-                    self.check_for_conflicts_between_external_crates(\n-                        &*parent.module(),\n-                        name.name,\n-                        view_item.span);\n-                    parent.module().external_module_children.borrow_mut()\n-                                   .insert(name.name, external_module.clone());\n-                    self.build_reduced_graph_for_external_crate(external_module);\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item<F>(&mut self,\n-                                               foreign_item: &ForeignItem,\n-                                               parent: ReducedGraphParent,\n-                                               f: F) where\n-        F: FnOnce(&mut Resolver),\n-    {\n-        let name = foreign_item.ident.name;\n-        let is_public = foreign_item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n-        let name_bindings =\n-            self.add_child(name, parent, ForbidDuplicateValues,\n-                           foreign_item.span);\n-\n-        match foreign_item.node {\n-            ForeignItemFn(_, ref generics) => {\n-                let def = DefFn(local_def(foreign_item.id), false);\n-                name_bindings.define_value(def, foreign_item.span, modifiers);\n-\n-                self.with_type_parameter_rib(\n-                    HasTypeParameters(generics,\n-                                      FnSpace,\n-                                      foreign_item.id,\n-                                      NormalRibKind),\n-                    f);\n-            }\n-            ForeignItemStatic(_, m) => {\n-                let def = DefStatic(local_def(foreign_item.id), m);\n-                name_bindings.define_value(def, foreign_item.span, modifiers);\n-\n-                f(self)\n-            }\n-        }\n-    }\n-\n-    fn build_reduced_graph_for_block(&mut self,\n-                                         block: &Block,\n-                                         parent: ReducedGraphParent)\n-                                            -> ReducedGraphParent\n-    {\n-        if self.block_needs_anonymous_module(block) {\n-            let block_id = block.id;\n-\n-            debug!(\"(building reduced graph for block) creating a new \\\n-                    anonymous module for block {}\",\n-                   block_id);\n-\n-            let parent_module = parent.module();\n-            let new_module = Rc::new(Module::new(\n-                BlockParentLink(parent_module.downgrade(), block_id),\n-                None,\n-                AnonymousModuleKind,\n-                false,\n-                false));\n-            parent_module.anonymous_children.borrow_mut()\n-                         .insert(block_id, new_module.clone());\n-            ModuleReducedGraphParent(new_module)\n-        } else {\n-            parent\n-        }\n-    }\n-\n-    fn handle_external_def(&mut self,\n-                           def: Def,\n-                           vis: Visibility,\n-                           child_name_bindings: &NameBindings,\n-                           final_ident: &str,\n-                           name: Name,\n-                           new_parent: ReducedGraphParent) {\n-        debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv {}\",\n-               vis);\n-        let is_public = vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n-        let is_exported = is_public && match new_parent {\n-            ModuleReducedGraphParent(ref module) => {\n-                match module.def_id.get() {\n-                    None => true,\n-                    Some(did) => self.external_exports.contains(&did)\n-                }\n-            }\n-        };\n-        if is_exported {\n-            self.external_exports.insert(def.def_id());\n-        }\n-\n-        let kind = match def {\n-            DefTy(_, true) => EnumModuleKind,\n-            DefStruct(..) | DefTy(..) => ImplModuleKind,\n-            _ => NormalModuleKind\n-        };\n-\n-        match def {\n-          DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n-          DefTy(def_id, _) => {\n-            let type_def = child_name_bindings.type_def.borrow().clone();\n-            match type_def {\n-              Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n-                debug!(\"(building reduced graph for external crate) \\\n-                        already created module\");\n-                module_def.def_id.set(Some(def_id));\n-              }\n-              Some(_) | None => {\n-                debug!(\"(building reduced graph for \\\n-                        external crate) building module \\\n-                        {}\", final_ident);\n-                let parent_link = self.get_parent_link(new_parent.clone(), name);\n-\n-                child_name_bindings.define_module(parent_link,\n-                                                  Some(def_id),\n-                                                  kind,\n-                                                  true,\n-                                                  is_public,\n-                                                  DUMMY_SP);\n-              }\n-            }\n-          }\n-          _ => {}\n-        }\n-\n-        match def {\n-          DefMod(_) | DefForeignMod(_) => {}\n-          DefVariant(_, variant_id, is_struct) => {\n-              debug!(\"(building reduced graph for external crate) building \\\n-                      variant {}\",\n-                      final_ident);\n-              // variants are always treated as importable to allow them to be\n-              // glob used\n-              let modifiers = PUBLIC | IMPORTABLE;\n-              if is_struct {\n-                  child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-                  // Not adding fields for variants as they are not accessed with a self receiver\n-                  self.structs.insert(variant_id, Vec::new());\n-              } else {\n-                  child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n-              }\n-          }\n-          DefFn(ctor_id, true) => {\n-            child_name_bindings.define_value(\n-                csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n-                    .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n-          }\n-          DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building value (fn/static) {}\", final_ident);\n-            // impl methods have already been defined with the correct importability modifier\n-            let mut modifiers = match *child_name_bindings.value_def.borrow() {\n-                Some(ref def) => (modifiers & !IMPORTABLE) | (def.modifiers & IMPORTABLE),\n-                None => modifiers\n-            };\n-            if new_parent.module().kind.get() != NormalModuleKind {\n-                modifiers = modifiers & !IMPORTABLE;\n-            }\n-            child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n-          }\n-          DefTrait(def_id) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type {}\", final_ident);\n-\n-              // If this is a trait, add all the trait item names to the trait\n-              // info.\n-\n-              let trait_item_def_ids =\n-                csearch::get_trait_item_def_ids(&self.session.cstore, def_id);\n-              for trait_item_def_id in trait_item_def_ids.iter() {\n-                  let (trait_item_name, trait_item_kind) =\n-                      csearch::get_trait_item_name_and_kind(\n-                          &self.session.cstore,\n-                          trait_item_def_id.def_id());\n-\n-                  debug!(\"(building reduced graph for external crate) ... \\\n-                          adding trait item '{}'\",\n-                         token::get_name(trait_item_name));\n-\n-                  self.trait_item_map.insert((trait_item_name, def_id), trait_item_kind);\n-\n-                  if is_exported {\n-                      self.external_exports\n-                          .insert(trait_item_def_id.def_id());\n-                  }\n-              }\n-\n-              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-\n-              // Define a module if necessary.\n-              let parent_link = self.get_parent_link(new_parent, name);\n-              child_name_bindings.set_module_kind(parent_link,\n-                                                  Some(def_id),\n-                                                  TraitModuleKind,\n-                                                  true,\n-                                                  is_public,\n-                                                  DUMMY_SP)\n-          }\n-          DefTy(..) | DefAssociatedTy(..) | DefAssociatedPath(..) => {\n-              debug!(\"(building reduced graph for external \\\n-                      crate) building type {}\", final_ident);\n-\n-              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-          }\n-          DefStruct(def_id) => {\n-            debug!(\"(building reduced graph for external \\\n-                    crate) building type and value for {}\",\n-                   final_ident);\n-            child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-            let fields = csearch::get_struct_fields(&self.session.cstore, def_id).iter().map(|f| {\n-                f.name\n-            }).collect::<Vec<_>>();\n-\n-            if fields.len() == 0 {\n-                child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n-            }\n-\n-            // Record the def ID and fields of this struct.\n-            self.structs.insert(def_id, fields);\n-          }\n-          DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n-          DefUse(..) | DefUpvar(..) | DefRegion(..) |\n-          DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n-            panic!(\"didn't expect `{}`\", def);\n-          }\n-        }\n-    }\n-\n-    /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self,\n-                                                  root: Rc<Module>,\n-                                                  def_like: DefLike,\n-                                                  name: Name,\n-                                                  visibility: Visibility) {\n-        match def_like {\n-            DlDef(def) => {\n-                // Add the new child item, if necessary.\n-                match def {\n-                    DefForeignMod(def_id) => {\n-                        // Foreign modules have no names. Recur and populate\n-                        // eagerly.\n-                        csearch::each_child_of_item(&self.session.cstore,\n-                                                    def_id,\n-                                                    |def_like,\n-                                                     child_name,\n-                                                     vis| {\n-                            self.build_reduced_graph_for_external_crate_def(\n-                                root.clone(),\n-                                def_like,\n-                                child_name,\n-                                vis)\n-                        });\n-                    }\n-                    _ => {\n-                        let child_name_bindings =\n-                            self.add_child(name,\n-                                           ModuleReducedGraphParent(root.clone()),\n-                                           OverwriteDuplicates,\n-                                           DUMMY_SP);\n-\n-                        self.handle_external_def(def,\n-                                                 visibility,\n-                                                 &*child_name_bindings,\n-                                                 token::get_name(name).get(),\n-                                                 name,\n-                                                 ModuleReducedGraphParent(root));\n-                    }\n-                }\n-            }\n-            DlImpl(def) => {\n-                match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n-                    None => {}\n-                    Some(final_name) => {\n-                        let methods_opt =\n-                            csearch::get_methods_if_impl(&self.session.cstore, def);\n-                        match methods_opt {\n-                            Some(ref methods) if\n-                                methods.len() >= 1 => {\n-                                debug!(\"(building reduced graph for \\\n-                                        external crate) processing \\\n-                                        static methods for type name {}\",\n-                                        token::get_name(final_name));\n-\n-                                let child_name_bindings =\n-                                    self.add_child(\n-                                        final_name,\n-                                        ModuleReducedGraphParent(root.clone()),\n-                                        OverwriteDuplicates,\n-                                        DUMMY_SP);\n-\n-                                // Process the static methods. First,\n-                                // create the module.\n-                                let type_module;\n-                                let type_def = child_name_bindings.type_def.borrow().clone();\n-                                match type_def {\n-                                    Some(TypeNsDef {\n-                                        module_def: Some(module_def),\n-                                        ..\n-                                    }) => {\n-                                        // We already have a module. This\n-                                        // is OK.\n-                                        type_module = module_def;\n-\n-                                        // Mark it as an impl module if\n-                                        // necessary.\n-                                        type_module.kind.set(ImplModuleKind);\n-                                    }\n-                                    Some(_) | None => {\n-                                        let parent_link =\n-                                            self.get_parent_link(ModuleReducedGraphParent(root),\n-                                                                 final_name);\n-                                        child_name_bindings.define_module(\n-                                            parent_link,\n-                                            Some(def),\n-                                            ImplModuleKind,\n-                                            true,\n-                                            true,\n-                                            DUMMY_SP);\n-                                        type_module =\n-                                            child_name_bindings.\n-                                                get_module();\n-                                    }\n-                                }\n-\n-                                // Add each static method to the module.\n-                                let new_parent =\n-                                    ModuleReducedGraphParent(type_module);\n-                                for method_info in methods.iter() {\n-                                    let name = method_info.name;\n-                                    debug!(\"(building reduced graph for \\\n-                                             external crate) creating \\\n-                                             static method '{}'\",\n-                                           token::get_name(name));\n-\n-                                    let method_name_bindings =\n-                                        self.add_child(name,\n-                                                       new_parent.clone(),\n-                                                       OverwriteDuplicates,\n-                                                       DUMMY_SP);\n-                                    let def = DefFn(method_info.def_id, false);\n-\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if visibility == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    method_name_bindings.define_value(\n-                                        def, DUMMY_SP, modifiers);\n-                                }\n-                            }\n-\n-                            // Otherwise, do nothing.\n-                            Some(_) | None => {}\n-                        }\n-                    }\n-                }\n-            }\n-            DlField => {\n-                debug!(\"(building reduced graph for external crate) \\\n-                        ignoring field\");\n-            }\n-        }\n-    }\n-\n-    /// Builds the reduced graph rooted at the given external module.\n-    fn populate_external_module(&mut self, module: Rc<Module>) {\n-        debug!(\"(populating external module) attempting to populate {}\",\n-               self.module_to_string(&*module));\n-\n-        let def_id = match module.def_id.get() {\n-            None => {\n-                debug!(\"(populating external module) ... no def ID!\");\n-                return\n-            }\n-            Some(def_id) => def_id,\n-        };\n-\n-        csearch::each_child_of_item(&self.session.cstore,\n-                                    def_id,\n-                                    |def_like, child_name, visibility| {\n-            debug!(\"(populating external module) ... found ident: {}\",\n-                   token::get_name(child_name));\n-            self.build_reduced_graph_for_external_crate_def(module.clone(),\n-                                                            def_like,\n-                                                            child_name,\n-                                                            visibility)\n-        });\n-        module.populated.set(true)\n-    }\n-\n-    /// Ensures that the reduced graph rooted at the given external module\n-    /// is built, building it if it is not.\n-    fn populate_module_if_necessary(&mut self, module: &Rc<Module>) {\n-        if !module.populated.get() {\n-            self.populate_external_module(module.clone())\n-        }\n-        assert!(module.populated.get())\n-    }\n-\n-    /// Builds the reduced graph rooted at the 'use' directive for an external\n-    /// crate.\n-    fn build_reduced_graph_for_external_crate(&mut self, root: Rc<Module>) {\n-        csearch::each_top_level_item_of_crate(&self.session.cstore,\n-                                              root.def_id\n-                                                  .get()\n-                                                  .unwrap()\n-                                                  .krate,\n-                                              |def_like, name, visibility| {\n-            self.build_reduced_graph_for_external_crate_def(root.clone(),\n-                                                            def_like,\n-                                                            name,\n-                                                            visibility)\n-        });\n-    }\n-\n-    /// Creates and adds an import directive to the given module.\n-    fn build_import_directive(&mut self,\n-                              module_: &Module,\n-                              module_path: Vec<Name>,\n-                              subclass: ImportDirectiveSubclass,\n-                              span: Span,\n-                              id: NodeId,\n-                              is_public: bool,\n-                              shadowable: Shadowable) {\n-        module_.imports.borrow_mut().push(ImportDirective::new(module_path,\n-                                                               subclass,\n-                                                               span,\n-                                                               id,\n-                                                               is_public,\n-                                                               shadowable));\n-        self.unresolved_imports += 1;\n-        // Bump the reference count on the name. Or, if this is a glob, set\n-        // the appropriate flag.\n-\n-        match subclass {\n-            SingleImport(target, _) => {\n-                debug!(\"(building import directive) building import \\\n-                        directive: {}::{}\",\n-                       self.names_to_string(module_.imports.borrow().last().unwrap()\n-                                                 .module_path[]),\n-                       token::get_name(target));\n-\n-                let mut import_resolutions = module_.import_resolutions\n-                                                    .borrow_mut();\n-                match import_resolutions.get_mut(&target) {\n-                    Some(resolution) => {\n-                        debug!(\"(building import directive) bumping \\\n-                                reference\");\n-                        resolution.outstanding_references += 1;\n-\n-                        // the source of this name is different now\n-                        resolution.type_id = id;\n-                        resolution.value_id = id;\n-                        resolution.is_public = is_public;\n-                        return;\n-                    }\n-                    None => {}\n-                }\n-                debug!(\"(building import directive) creating new\");\n-                let mut resolution = ImportResolution::new(id, is_public);\n-                resolution.outstanding_references = 1;\n-                import_resolutions.insert(target, resolution);\n-            }\n-            GlobImport => {\n-                // Set the glob flag. This tells us that we don't know the\n-                // module's exports ahead of time.\n-\n-                module_.glob_count.set(module_.glob_count.get() + 1);\n-            }\n-        }\n-    }\n-\n     // Import resolution\n     //\n     // This is a fixed-point algorithm. We resolve imports until our efforts\n@@ -2276,7 +1002,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.resolve_imports_for_module(module_.clone());\n         self.current_module = orig_module;\n \n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n         for (_, child_node) in module_.children.borrow().iter() {\n             match child_node.get_module_if_available() {\n                 None => {\n@@ -2542,7 +1268,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut type_result = UnknownResult;\n \n         // Search for direct children of the containing module.\n-        self.populate_module_if_necessary(&containing_module);\n+        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n \n         match containing_module.children.borrow().get(&source) {\n             None => {\n@@ -2902,7 +1628,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Add all children from the containing module.\n-        self.populate_module_if_necessary(&containing_module);\n+        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n \n         for (&name, name_bindings) in containing_module.children.borrow().iter() {\n             self.merge_import_resolution(module_,\n@@ -3422,7 +2148,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         match module_.children.borrow().get(&name) {\n             Some(name_bindings)\n@@ -3687,7 +2413,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                self.module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         match module_.children.borrow().get(&name) {\n             Some(name_bindings)\n@@ -3783,7 +2509,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Descend into children and anonymous children.\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         for (_, child_node) in module_.children.borrow().iter() {\n             match child_node.get_module_if_available() {\n@@ -3830,7 +2556,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // Nothing to do.\n             }\n             Some(name) => {\n-                self.populate_module_if_necessary(&orig_module);\n+                build_reduced_graph::populate_module_if_necessary(self, &orig_module);\n \n                 match orig_module.children.borrow().get(&name) {\n                     None => {\n@@ -5243,7 +3969,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             namespace: Namespace)\n                                             -> NameDefinition {\n         // First, search children.\n-        self.populate_module_if_necessary(&containing_module);\n+        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n \n         match containing_module.children.borrow().get(&name) {\n             Some(child_name_bindings) => {\n@@ -5931,7 +4657,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             // Look for trait children.\n-            self.populate_module_if_necessary(&search_module);\n+            build_reduced_graph::populate_module_if_necessary(self, &search_module);\n \n             {\n                 for (_, child_names) in search_module.children.borrow().iter() {\n@@ -6059,7 +4785,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"Dump of module `{}`:\", self.module_to_string(&*module_));\n \n         debug!(\"Children:\");\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self, &module_);\n         for (&name, _) in module_.children.borrow().iter() {\n             debug!(\"* {}\", token::get_name(name));\n         }\n@@ -6116,7 +4842,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                                -> CrateMap {\n     let mut resolver = Resolver::new(session, ast_map, krate.span, make_glob_map);\n \n-    resolver.build_reduced_graph(krate);\n+    build_reduced_graph::build_reduced_graph(&mut resolver, krate);\n     session.abort_if_errors();\n \n     resolver.resolve_imports();"}, {"sha": "9c2437c376ddd20592d3c8ab1e83ab7297900487", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0362b40e44b52deaa302559ccdf5719c5c8acbec/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0362b40e44b52deaa302559ccdf5719c5c8acbec/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=0362b40e44b52deaa302559ccdf5719c5c8acbec", "patch": "@@ -21,6 +21,8 @@\n use {Module, NameBindings, Resolver};\n use Namespace::{mod, TypeNS, ValueNS};\n \n+use build_reduced_graph;\n+\n use rustc::middle::def::Export;\n use syntax::ast;\n use syntax::parse::token;\n@@ -73,7 +75,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         }\n \n         self.record_exports_for_module(&*module_);\n-        self.populate_module_if_necessary(&module_);\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n \n         for (_, child_name_bindings) in module_.children.borrow().iter() {\n             match child_name_bindings.get_module_if_available() {"}]}