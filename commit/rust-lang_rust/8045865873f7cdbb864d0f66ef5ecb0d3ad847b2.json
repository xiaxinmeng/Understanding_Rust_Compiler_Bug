{"sha": "8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwNDU4NjU4NzNmN2NkYmI4NjRkMGY2NmVmNWVjYjBkM2FkODQ3YjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-29T06:33:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-29T06:33:42Z"}, "message": "Auto merge of #70370 - petrochenkov:nosmatch, r=Centril\n\nRemove attribute `#[structural_match]` and any references to it\n\nA small remaining part of https://github.com/rust-lang/rust/issues/63438.", "tree": {"sha": "be3960d74254f4b099b6969d00c6c84a014dd1ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be3960d74254f4b099b6969d00c6c84a014dd1ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "html_url": "https://github.com/rust-lang/rust/commit/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "150322f86d441752874a8bed603d71119f190b8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/150322f86d441752874a8bed603d71119f190b8b", "html_url": "https://github.com/rust-lang/rust/commit/150322f86d441752874a8bed603d71119f190b8b"}, {"sha": "733230530522d9f535b95d5bc304b11a94e2239c", "url": "https://api.github.com/repos/rust-lang/rust/commits/733230530522d9f535b95d5bc304b11a94e2239c", "html_url": "https://github.com/rust-lang/rust/commit/733230530522d9f535b95d5bc304b11a94e2239c"}], "stats": {"total": 91, "additions": 43, "deletions": 48}, "files": [{"sha": "a04b7162c922bbac15f2ee34c3a98e1076f0713b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -134,7 +134,6 @@\n #![feature(f16c_target_feature)]\n #![feature(hexagon_target_feature)]\n #![feature(const_transmute)]\n-#![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n #![feature(maybe_uninit_slice)]"}, {"sha": "b131cf84e1898d84f97d47663bc2ff95c4ed739f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -660,7 +660,6 @@ macro_rules! impls {\n ///\n /// [drop check]: ../../nomicon/dropck.html\n #[lang = \"phantom_data\"]\n-#[structural_match]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T: ?Sized>;\n "}, {"sha": "5ff77d073d388bd7c7c01306d82fd0be6f397502", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -518,7 +518,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n \n     // Currently, the values that can be unified are primitive types,\n     // and those that derive both `PartialEq` and `Eq`, corresponding\n-    // to `structural_match` types.\n+    // to structural-match types.\n     let new_const_val = match (eagerly_eval(a), eagerly_eval(b)) {\n         (ty::ConstKind::Infer(_), _) | (_, ty::ConstKind::Infer(_)) => {\n             // The caller should handle these cases!"}, {"sha": "0a8650282a3747955b759a9822716f041ca34aca", "filename": "src/librustc_error_codes/error_codes/E0741.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0741.md", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0741.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0741.md?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,4 +1,4 @@\n-Only `structural_match` types (that is, types that derive `PartialEq` and `Eq`)\n+Only structural-match types (that is, types that derive `PartialEq` and `Eq`)\n may be used as the types of const generic parameters.\n \n ```compile_fail,E0741"}, {"sha": "7b3c599e8c7ca79a9a04cf4843366bf2c6e6d7bc", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -173,6 +173,8 @@ declare_features! (\n     // no-tracking-issue-end\n \n     /// Allows using `#[structural_match]` which indicates that a type is structurally matchable.\n+    /// FIXME: Subsumed by trait `StructuralPartialEq`, cannot move to removed until a library\n+    /// feature with the same name exists.\n     (active, structural_match, \"1.8.0\", Some(31434), None),\n \n     /// Allows using the `may_dangle` attribute (RFC 1327)."}, {"sha": "2e89f36fea2ab57c2286c3ef5b706f49c22ee78d", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -376,11 +376,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     gated!(fundamental, Whitelisted, template!(Word), experimental!(fundamental)),\n-    gated!(\n-        // RFC #1445.\n-        structural_match, Whitelisted, template!(Word),\n-        \"the semantics of constant patterns is not yet settled\",\n-    ),\n     gated!(\n         may_dangle, Normal, template!(Word), dropck_eyepatch,\n         \"`may_dangle` has unstable semantics and may be removed in the future\","}, {"sha": "ce09fd299feca27d1ecfb9422a006644019b8f66", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -452,7 +452,7 @@ declare_lint! {\n     pub INDIRECT_STRUCTURAL_MATCH,\n     // defaulting to allow until rust-lang/rust#62614 is fixed.\n     Allow,\n-    \"pattern with const indirectly referencing non-`#[structural_match]` type\",\n+    \"pattern with const indirectly referencing non-structural-match type\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/62411>\",\n         edition: None,"}, {"sha": "42c9c246078b3fdaa486bc91781710f57c3de4b4", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -14,9 +14,9 @@ pub enum NonStructuralMatchTy<'tcx> {\n }\n \n /// This method traverses the structure of `ty`, trying to find an\n-/// instance of an ADT (i.e. struct or enum) that was declared without\n-/// the `#[structural_match]` attribute, or a generic type parameter\n-/// (which cannot be determined to be `structural_match`).\n+/// instance of an ADT (i.e. struct or enum) that doesn't implement\n+/// the structural-match traits, or a generic type parameter\n+/// (which cannot be determined to be structural-match).\n ///\n /// The \"structure of a type\" includes all components that would be\n /// considered when doing a pattern match on a constant of that\n@@ -30,8 +30,8 @@ pub enum NonStructuralMatchTy<'tcx> {\n ///    instantiated generic like `PhantomData<T>`.\n ///\n /// The reason we do this search is Rust currently require all ADTs\n-/// reachable from a constant's type to be annotated with\n-/// `#[structural_match]`, an attribute which essentially says that\n+/// reachable from a constant's type to implement the\n+/// structural-match traits, which essentially say that\n /// the implementation of `PartialEq::eq` behaves *equivalently* to a\n /// comparison against the unfolded structure.\n ///"}, {"sha": "684ccf71082c28ea996ef662d24423e03889ba30", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -2,7 +2,7 @@\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n // Currently, const parameters cannot depend on type parameters, because there is no way to\n-// enforce the `structural_match` property on an arbitrary type parameter. This restriction\n+// enforce the structural-match property on an arbitrary type parameter. This restriction\n // may be relaxed in the future. See https://github.com/rust-lang/rfcs/pull/2000 for more\n // details.\n "}, {"sha": "c663535e533bd162e13f788767676b628eb4db86", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-embedded.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,6 +1,6 @@\n // This is part of a set of tests exploring the different ways a\n-// `#[structural_match]` ADT might try to hold a\n-// non-`#[structural_match]` in hidden manner that lets matches\n+// structural-match ADT might try to hold a\n+// non-structural-match in hidden manner that lets matches\n // through that we had intended to reject.\n //\n // See discussion on rust-lang/rust#62307 and rust-lang/rust#62339"}, {"sha": "872bf5a63fffd957a9c2b142d4203cded5e1ede4", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,6 +1,6 @@\n // This is part of a set of tests exploring the different ways a\n-// `#[structural_match]` ADT might try to hold a\n-// non-`#[structural_match]` in hidden manner that lets matches\n+// structural-match ADT might try to hold a\n+// non-structural-match in hidden manner that lets matches\n // through that we had intended to reject.\n //\n // See discussion on rust-lang/rust#62307 and rust-lang/rust#62339"}, {"sha": "f6947819695a60a895057b8e43b43f046efb85bd", "filename": "src/test/ui/rfc1445/cant-hide-behind-doubly-indirect-embedded.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,6 +1,6 @@\n // This is part of a set of tests exploring the different ways a\n-// `#[structural_match]` ADT might try to hold a\n-// non-`#[structural_match]` in hidden manner that lets matches\n+// structural-match ADT might try to hold a\n+// non-structural-match in hidden manner that lets matches\n // through that we had intended to reject.\n //\n // See discussion on rust-lang/rust#62307 and rust-lang/rust#62339"}, {"sha": "1c29d67b65529dd5b3d2e92589b59a6782f0eb87", "filename": "src/test/ui/rfc1445/cant-hide-behind-doubly-indirect-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,6 +1,6 @@\n // This is part of a set of tests exploring the different ways a\n-// `#[structural_match]` ADT might try to hold a\n-// non-`#[structural_match]` in hidden manner that lets matches\n+// structural-match ADT might try to hold a\n+// non-structural-match in hidden manner that lets matches\n // through that we had intended to reject.\n //\n // See discussion on rust-lang/rust#62307 and rust-lang/rust#62339"}, {"sha": "1a41dbb55c2e97f9c0c457a5078f72541982a7a0", "filename": "src/test/ui/rfc1445/cant-hide-behind-indirect-struct-embedded.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,6 +1,6 @@\n // This is part of a set of tests exploring the different ways a\n-// `#[structural_match]` ADT might try to hold a\n-// non-`#[structural_match]` in hidden manner that lets matches\n+// structural-match ADT might try to hold a\n+// non-structural-match in hidden manner that lets matches\n // through that we had intended to reject.\n //\n // See discussion on rust-lang/rust#62307 and rust-lang/rust#62339"}, {"sha": "46032c4b0ebd434ef9f9f1ec52904d20820ca810", "filename": "src/test/ui/rfc1445/cant-hide-behind-indirect-struct-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,6 +1,6 @@\n // This is part of a set of tests exploring the different ways a\n-// `#[structural_match]` ADT might try to hold a\n-// non-`#[structural_match]` in hidden manner that lets matches\n+// structural-match ADT might try to hold a\n+// non-structural-match in hidden manner that lets matches\n // through that we had intended to reject.\n //\n // See discussion on rust-lang/rust#62307 and rust-lang/rust#62339"}, {"sha": "ee6674097ce2ddcb239fffe31f34dc68ff22b4b3", "filename": "src/test/ui/rfc1445/feature-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,4 +1,4 @@\n-// Test that structural match is only permitted with a feature gate,\n+// Test that use of structural-match traits is only permitted with a feature gate,\n // and that if a feature gate is supplied, it permits the type to be\n // used in a match.\n "}, {"sha": "2b3fbd2a4d28a2ee21ab9dc8278142d76f73df5f", "filename": "src/test/ui/rfc1445/fn-ptr-is-structurally-matchable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -36,79 +36,79 @@ fn main() {\n     // a singleton type of the fn itself that the type inference would\n     // otherwise assign.\n \n-    // Check that fn() is #[structural_match]\n+    // Check that fn() is structural-match\n     const CFN1: Wrap<fn()> = Wrap(trivial);\n     let input: Wrap<fn()> = Wrap(trivial);\n     match Wrap(input) {\n         Wrap(CFN1) => count += 1,\n         Wrap(_) => {}\n     };\n \n-    // Check that fn(T) is #[structural_match] when T is too.\n+    // Check that fn(T) is structural-match when T is too.\n     const CFN2: Wrap<fn(SM)> = Wrap(sm_to);\n     let input: Wrap<fn(SM)> = Wrap(sm_to);\n     match Wrap(input) {\n         Wrap(CFN2) => count += 1,\n         Wrap(_) => {}\n     };\n \n-    // Check that fn() -> T is #[structural_match] when T is too.\n+    // Check that fn() -> T is structural-match when T is too.\n     const CFN3: Wrap<fn() -> SM> = Wrap(to_sm);\n     let input: Wrap<fn() -> SM> = Wrap(to_sm);\n     match Wrap(input) {\n         Wrap(CFN3) => count += 1,\n         Wrap(_) => {}\n     };\n \n-    // Check that fn(T) is #[structural_match] even if T is not.\n+    // Check that fn(T) is structural-match even if T is not.\n     const CFN4: Wrap<fn(NotSM)> = Wrap(not_sm_to);\n     let input: Wrap<fn(NotSM)> = Wrap(not_sm_to);\n     match Wrap(input) {\n         Wrap(CFN4) => count += 1,\n         Wrap(_) => {}\n     };\n \n-    // Check that fn() -> T is #[structural_match] even if T is not.\n+    // Check that fn() -> T is structural-match even if T is not.\n     const CFN5: Wrap<fn() -> NotSM> = Wrap(to_not_sm);\n     let input: Wrap<fn() -> NotSM> = Wrap(to_not_sm);\n     match Wrap(input) {\n         Wrap(CFN5) => count += 1,\n         Wrap(_) => {}\n     };\n \n-    // Check that fn(&T) is #[structural_match] when T is too.\n+    // Check that fn(&T) is structural-match when T is too.\n     const CFN6: Wrap<fn(&SM)> = Wrap(r_sm_to);\n     let input: Wrap<fn(&SM)> = Wrap(r_sm_to);\n     match Wrap(input) {\n         Wrap(CFN6) => count += 1,\n         Wrap(_) => {}\n     };\n \n-    // Check that fn() -> &T is #[structural_match] when T is too.\n+    // Check that fn() -> &T is structural-match when T is too.\n     const CFN7: Wrap<fn(&()) -> &SM> = Wrap(r_to_r_sm);\n     let input: Wrap<fn(&()) -> &SM> = Wrap(r_to_r_sm);\n     match Wrap(input) {\n         Wrap(CFN7) => count += 1,\n         Wrap(_) => {}\n     };\n \n-    // Check that fn(T) is #[structural_match] even if T is not.\n+    // Check that fn(T) is structural-match even if T is not.\n     const CFN8: Wrap<fn(&NotSM)> = Wrap(r_not_sm_to);\n     let input: Wrap<fn(&NotSM)> = Wrap(r_not_sm_to);\n     match Wrap(input) {\n         Wrap(CFN8) => count += 1,\n         Wrap(_) => {}\n     };\n \n-    // Check that fn() -> T is #[structural_match] even if T is not.\n+    // Check that fn() -> T is structural-match even if T is not.\n     const CFN9: Wrap<fn(&()) -> &NotSM> = Wrap(r_to_r_not_sm);\n     let input: Wrap<fn(&()) -> &NotSM> = Wrap(r_to_r_not_sm);\n     match Wrap(input) {\n         Wrap(CFN9) => count += 1,\n         Wrap(_) => {}\n     };\n \n-    // Check that a type which has fn ptrs is `#[structural_match]`.\n+    // Check that a type which has fn ptrs is structural-match.\n     #[derive(PartialEq, Eq)]\n     struct Foo {\n         alpha: fn(NotSM),"}, {"sha": "2a915d61e3d90371b7f0cd160e66d88941518a94", "filename": "src/test/ui/rfc1445/issue-61188-match-slice-forbidden-without-eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fissue-61188-match-slice-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fissue-61188-match-slice-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-61188-match-slice-forbidden-without-eq.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,7 +1,7 @@\n // Issue 61188 pointed out a case where we hit an ICE during code gen:\n // the compiler assumed that `PartialEq` was always implemented on any\n // use of a `const` item in a pattern context, but the pre-existing\n-// checking for the presence of `#[structural_match]` was too shallow\n+// structural-match checking was too shallow\n // (see rust-lang/rust#62307), and so we hit cases where we were\n // trying to dispatch to `PartialEq` on types that did not implement\n // that trait."}, {"sha": "6ebb948d736ec3b389c035ad8d21339ad65c8cf8", "filename": "src/test/ui/rfc1445/issue-62307-match-ref-ref-forbidden-without-eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -8,8 +8,8 @@\n // resolve the question of what semantics is used for such matching.\n // (See RFC 1445 for more details and discussion.)\n \n-// Issue 62307 pointed out a case where the checking for\n-// `#[structural_match]` was too shallow.\n+// Issue 62307 pointed out a case where the structural-match checking\n+// was too shallow.\n #![warn(indirect_structural_match)]\n // run-pass\n "}, {"sha": "4112e8f45179c633a380147dacff76cd096241e5", "filename": "src/test/ui/rfc1445/match-nonempty-array-forbidden-without-eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -1,5 +1,5 @@\n-// Issue 62307 pointed out a case where the checking for\n-// `#[structural_match]` was too shallow.\n+// Issue 62307 pointed out a case where the structural-match checking\n+// was too shallow.\n //\n // Here we check similar behavior for non-empty arrays of types that\n // do not derive `Eq`."}, {"sha": "50f91420ce2f106582b53506100bce5f4a3d13b8", "filename": "src/test/ui/rfc1445/phantom-data-is-structurally-matchable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fphantom-data-is-structurally-matchable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8045865873f7cdbb864d0f66ef5ecb0d3ad847b2/src%2Ftest%2Fui%2Frfc1445%2Fphantom-data-is-structurally-matchable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fphantom-data-is-structurally-matchable.rs?ref=8045865873f7cdbb864d0f66ef5ecb0d3ad847b2", "patch": "@@ -14,25 +14,25 @@ fn main() {\n     #[derive(PartialEq, Eq)]\n     struct SM;\n \n-    // Check that SM is #[structural_match]:\n+    // Check that SM is structural-match:\n     const CSM: SM = SM;\n     match SM {\n         CSM => count += 1,\n     };\n \n-    // Check that PhantomData<T> is #[structural_match] even if T is not.\n+    // Check that PhantomData<T> is structural-match even if T is not.\n     const CPD1: PhantomData<NotSM> = PhantomData;\n     match PhantomData {\n         CPD1 => count += 1,\n     };\n \n-    // Check that PhantomData<T> is #[structural_match] when T is.\n+    // Check that PhantomData<T> is structural-match when T is.\n     const CPD2: PhantomData<SM> = PhantomData;\n     match PhantomData {\n         CPD2 => count += 1,\n     };\n \n-    // Check that a type which has a PhantomData is `#[structural_match]`.\n+    // Check that a type which has a PhantomData is structural-match.\n     #[derive(PartialEq, Eq, Default)]\n     struct Foo {\n         alpha: PhantomData<NotSM>,"}]}