{"sha": "2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMzNiZjYzNDc4MGNhM2UzNmQ4OGUxNGI0YWE3MzUyYjJkOGUyZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T14:35:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T14:35:48Z"}, "message": "Auto merge of #6938 - Y-Nak:refactor-types, r=flip1995\n\nRefactor types\n\nr? `@flip1995`\nThis is the last PR to close #6724 :tada:\nAlso, this fixes #6936.\n\nchangelog: `vec_box`: Fix FN in `const` or `static`\nchangelog: `linkedlist`: Fix FN in `const` or `static`\nchangelog: `option_option`: Fix FN in `const` or `static`", "tree": {"sha": "802c1fa09b01c42b77115a70fd89c560faf212d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/802c1fa09b01c42b77115a70fd89c560faf212d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "html_url": "https://github.com/rust-lang/rust/commit/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b7671963812abc7093e56e3b5c115faf9ac701a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7671963812abc7093e56e3b5c115faf9ac701a", "html_url": "https://github.com/rust-lang/rust/commit/0b7671963812abc7093e56e3b5c115faf9ac701a"}, {"sha": "818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a", "html_url": "https://github.com/rust-lang/rust/commit/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a"}], "stats": {"total": 2077, "additions": 1077, "deletions": 1000}, "files": [{"sha": "33c720c666e432aeb1731f94ee68b2a6d773af9a", "filename": "clippy_lints/src/absurd_extreme_comparisons.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -0,0 +1,173 @@\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::consts::{constant, Constant};\n+\n+use clippy_utils::comparisons::{normalize_comparison, Rel};\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::is_isize_or_usize;\n+use clippy_utils::{clip, int_bits, unsext};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where one side of the relation is\n+    /// either the minimum or maximum value for its type and warns if it involves a\n+    /// case that is always true or always false. Only integer and boolean types are\n+    /// checked.\n+    ///\n+    /// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n+    /// that it is possible for `x` to be less than the minimum. Expressions like\n+    /// `max < x` are probably mistakes.\n+    ///\n+    /// **Known problems:** For `usize` the size of the current compile target will\n+    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n+    /// a comparison to detect target pointer width will trigger this lint. One can\n+    /// use `mem::sizeof` and compare its value or conditional compilation\n+    /// attributes\n+    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let vec: Vec<isize> = Vec::new();\n+    /// if vec.len() <= 0 {}\n+    /// if 100 > i32::MAX {}\n+    /// ```\n+    pub ABSURD_EXTREME_COMPARISONS,\n+    correctness,\n+    \"a comparison with a maximum or minimum value that is always true or false\"\n+}\n+\n+declare_lint_pass!(AbsurdExtremeComparisons => [ABSURD_EXTREME_COMPARISONS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n+            if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n+                if !expr.span.from_expansion() {\n+                    let msg = \"this comparison involving the minimum or maximum element for this \\\n+                               type contains a case that is always true or always false\";\n+\n+                    let conclusion = match result {\n+                        AbsurdComparisonResult::AlwaysFalse => \"this comparison is always false\".to_owned(),\n+                        AbsurdComparisonResult::AlwaysTrue => \"this comparison is always true\".to_owned(),\n+                        AbsurdComparisonResult::InequalityImpossible => format!(\n+                            \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n+                             instead\",\n+                            snippet(cx, lhs.span, \"lhs\"),\n+                            snippet(cx, rhs.span, \"rhs\")\n+                        ),\n+                    };\n+\n+                    let help = format!(\n+                        \"because `{}` is the {} value for this type, {}\",\n+                        snippet(cx, culprit.expr.span, \"x\"),\n+                        match culprit.which {\n+                            ExtremeType::Minimum => \"minimum\",\n+                            ExtremeType::Maximum => \"maximum\",\n+                        },\n+                        conclusion\n+                    );\n+\n+                    span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+enum ExtremeType {\n+    Minimum,\n+    Maximum,\n+}\n+\n+struct ExtremeExpr<'a> {\n+    which: ExtremeType,\n+    expr: &'a Expr<'a>,\n+}\n+\n+enum AbsurdComparisonResult {\n+    AlwaysFalse,\n+    AlwaysTrue,\n+    InequalityImpossible,\n+}\n+\n+fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n+        let precast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n+\n+        return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n+    }\n+\n+    false\n+}\n+\n+fn detect_absurd_comparison<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    op: BinOpKind,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n+    use AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n+    use ExtremeType::{Maximum, Minimum};\n+    // absurd comparison only makes sense on primitive types\n+    // primitive types don't implement comparison operators with each other\n+    if cx.typeck_results().expr_ty(lhs) != cx.typeck_results().expr_ty(rhs) {\n+        return None;\n+    }\n+\n+    // comparisons between fix sized types and target sized types are considered unanalyzable\n+    if is_cast_between_fixed_and_target(cx, lhs) || is_cast_between_fixed_and_target(cx, rhs) {\n+        return None;\n+    }\n+\n+    let (rel, normalized_lhs, normalized_rhs) = normalize_comparison(op, lhs, rhs)?;\n+\n+    let lx = detect_extreme_expr(cx, normalized_lhs);\n+    let rx = detect_extreme_expr(cx, normalized_rhs);\n+\n+    Some(match rel {\n+        Rel::Lt => {\n+            match (lx, rx) {\n+                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n+                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n+                _ => return None,\n+            }\n+        },\n+        Rel::Le => {\n+            match (lx, rx) {\n+                (Some(l @ ExtremeExpr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n+                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, InequalityImpossible), // max <= x\n+                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n+                (_, Some(r @ ExtremeExpr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n+                _ => return None,\n+            }\n+        },\n+        Rel::Ne | Rel::Eq => return None,\n+    })\n+}\n+\n+fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+\n+    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n+\n+    let which = match (ty.kind(), cv) {\n+        (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => ExtremeType::Minimum,\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) => {\n+            ExtremeType::Minimum\n+        },\n+\n+        (&ty::Bool, Constant::Bool(true)) => ExtremeType::Maximum,\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MAX >> (128 - int_bits(cx.tcx, ity)), ity) => {\n+            ExtremeType::Maximum\n+        },\n+        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::MAX, uty) == i => ExtremeType::Maximum,\n+\n+        _ => return None,\n+    };\n+    Some(ExtremeExpr { which, expr })\n+}"}, {"sha": "0b748b4d72decba4aec455833bf03b2e33bfe8b4", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -0,0 +1,377 @@\n+#![allow(rustc::default_hash_types)]\n+\n+use std::borrow::Cow;\n+use std::collections::BTreeMap;\n+\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, NestedVisitorMap, Visitor};\n+use rustc_hir::{Body, Expr, ExprKind, GenericArg, Item, ItemKind, QPath, TyKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{Ty, TyS, TypeckResults};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use if_chain::if_chain;\n+\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::paths;\n+use clippy_utils::source::{snippet, snippet_opt};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{differing_macro_contexts, match_path};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public `impl` or `fn` missing generalization\n+    /// over different hashers and implicitly defaulting to the default hashing\n+    /// algorithm (`SipHash`).\n+    ///\n+    /// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n+    /// used with them.\n+    ///\n+    /// **Known problems:** Suggestions for replacing constructors can contain\n+    /// false-positives. Also applying suggestions can require modification of other\n+    /// pieces of code, possibly including external crates.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// # use std::hash::{Hash, BuildHasher};\n+    /// # trait Serialize {};\n+    /// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n+    ///\n+    /// pub fn foo(map: &mut HashMap<i32, i32>) { }\n+    /// ```\n+    /// could be rewritten as\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// # use std::hash::{Hash, BuildHasher};\n+    /// # trait Serialize {};\n+    /// impl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n+    ///\n+    /// pub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n+    /// ```\n+    pub IMPLICIT_HASHER,\n+    pedantic,\n+    \"missing generalization over different hashers\"\n+}\n+\n+declare_lint_pass!(ImplicitHasher => [IMPLICIT_HASHER]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n+    #[allow(clippy::cast_possible_truncation, clippy::too_many_lines)]\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        use rustc_span::BytePos;\n+\n+        fn suggestion<'tcx>(\n+            cx: &LateContext<'tcx>,\n+            diag: &mut DiagnosticBuilder<'_>,\n+            generics_span: Span,\n+            generics_suggestion_span: Span,\n+            target: &ImplicitHasherType<'_>,\n+            vis: ImplicitHasherConstructorVisitor<'_, '_, '_>,\n+        ) {\n+            let generics_snip = snippet(cx, generics_span, \"\");\n+            // trim `<` `>`\n+            let generics_snip = if generics_snip.is_empty() {\n+                \"\"\n+            } else {\n+                &generics_snip[1..generics_snip.len() - 1]\n+            };\n+\n+            multispan_sugg(\n+                diag,\n+                \"consider adding a type parameter\",\n+                vec![\n+                    (\n+                        generics_suggestion_span,\n+                        format!(\n+                            \"<{}{}S: ::std::hash::BuildHasher{}>\",\n+                            generics_snip,\n+                            if generics_snip.is_empty() { \"\" } else { \", \" },\n+                            if vis.suggestions.is_empty() {\n+                                \"\"\n+                            } else {\n+                                // request users to add `Default` bound so that generic constructors can be used\n+                                \" + Default\"\n+                            },\n+                        ),\n+                    ),\n+                    (\n+                        target.span(),\n+                        format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n+                    ),\n+                ],\n+            );\n+\n+            if !vis.suggestions.is_empty() {\n+                multispan_sugg(diag, \"...and use generic constructor\", vis.suggestions);\n+            }\n+        }\n+\n+        if !cx.access_levels.is_exported(item.hir_id()) {\n+            return;\n+        }\n+\n+        match item.kind {\n+            ItemKind::Impl(ref impl_) => {\n+                let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                vis.visit_ty(impl_.self_ty);\n+\n+                for target in &vis.found {\n+                    if differing_macro_contexts(item.span, target.span()) {\n+                        return;\n+                    }\n+\n+                    let generics_suggestion_span = impl_.generics.span.substitute_dummy({\n+                        let pos = snippet_opt(cx, item.span.until(target.span()))\n+                            .and_then(|snip| Some(item.span.lo() + BytePos(snip.find(\"impl\")? as u32 + 4)));\n+                        if let Some(pos) = pos {\n+                            Span::new(pos, pos, item.span.data().ctxt)\n+                        } else {\n+                            return;\n+                        }\n+                    });\n+\n+                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                    for item in impl_.items.iter().map(|item| cx.tcx.hir().impl_item(item.id)) {\n+                        ctr_vis.visit_impl_item(item);\n+                    }\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        IMPLICIT_HASHER,\n+                        target.span(),\n+                        &format!(\n+                            \"impl for `{}` should be generalized over different hashers\",\n+                            target.type_name()\n+                        ),\n+                        move |diag| {\n+                            suggestion(cx, diag, impl_.generics.span, generics_suggestion_span, target, ctr_vis);\n+                        },\n+                    );\n+                }\n+            },\n+            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+                let body = cx.tcx.hir().body(body_id);\n+\n+                for ty in sig.decl.inputs {\n+                    let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                    vis.visit_ty(ty);\n+\n+                    for target in &vis.found {\n+                        if in_external_macro(cx.sess(), generics.span) {\n+                            continue;\n+                        }\n+                        let generics_suggestion_span = generics.span.substitute_dummy({\n+                            let pos = snippet_opt(cx, item.span.until(body.params[0].pat.span))\n+                                .and_then(|snip| {\n+                                    let i = snip.find(\"fn\")?;\n+                                    Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n+                                })\n+                                .expect(\"failed to create span for type parameters\");\n+                            Span::new(pos, pos, item.span.data().ctxt)\n+                        });\n+\n+                        let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                        ctr_vis.visit_body(body);\n+\n+                        span_lint_and_then(\n+                            cx,\n+                            IMPLICIT_HASHER,\n+                            target.span(),\n+                            &format!(\n+                                \"parameter of type `{}` should be generalized over different hashers\",\n+                                target.type_name()\n+                            ),\n+                            move |diag| {\n+                                suggestion(cx, diag, generics.span, generics_suggestion_span, target, ctr_vis);\n+                            },\n+                        );\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+enum ImplicitHasherType<'tcx> {\n+    HashMap(Span, Ty<'tcx>, Cow<'static, str>, Cow<'static, str>),\n+    HashSet(Span, Ty<'tcx>, Cow<'static, str>),\n+}\n+\n+impl<'tcx> ImplicitHasherType<'tcx> {\n+    /// Checks that `ty` is a target type without a `BuildHasher`.\n+    fn new(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Option<Self> {\n+        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.kind {\n+            let params: Vec<_> = path\n+                .segments\n+                .last()\n+                .as_ref()?\n+                .args\n+                .as_ref()?\n+                .args\n+                .iter()\n+                .filter_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    _ => None,\n+                })\n+                .collect();\n+            let params_len = params.len();\n+\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) && params_len == 2 {\n+                Some(ImplicitHasherType::HashMap(\n+                    hir_ty.span,\n+                    ty,\n+                    snippet(cx, params[0].span, \"K\"),\n+                    snippet(cx, params[1].span, \"V\"),\n+                ))\n+            } else if is_type_diagnostic_item(cx, ty, sym::hashset_type) && params_len == 1 {\n+                Some(ImplicitHasherType::HashSet(\n+                    hir_ty.span,\n+                    ty,\n+                    snippet(cx, params[0].span, \"T\"),\n+                ))\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn type_name(&self) -> &'static str {\n+        match *self {\n+            ImplicitHasherType::HashMap(..) => \"HashMap\",\n+            ImplicitHasherType::HashSet(..) => \"HashSet\",\n+        }\n+    }\n+\n+    fn type_arguments(&self) -> String {\n+        match *self {\n+            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{}, {}\", k, v),\n+            ImplicitHasherType::HashSet(.., ref t) => format!(\"{}\", t),\n+        }\n+    }\n+\n+    fn ty(&self) -> Ty<'tcx> {\n+        match *self {\n+            ImplicitHasherType::HashMap(_, ty, ..) | ImplicitHasherType::HashSet(_, ty, ..) => ty,\n+        }\n+    }\n+\n+    fn span(&self) -> Span {\n+        match *self {\n+            ImplicitHasherType::HashMap(span, ..) | ImplicitHasherType::HashSet(span, ..) => span,\n+        }\n+    }\n+}\n+\n+struct ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    found: Vec<ImplicitHasherType<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self { cx, found: vec![] }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'_>) {\n+        if let Some(target) = ImplicitHasherType::new(self.cx, t) {\n+            self.found.push(target);\n+        }\n+\n+        walk_ty(self, t);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Looks for default-hasher-dependent constructors like `HashMap::new`.\n+struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n+    target: &'b ImplicitHasherType<'tcx>,\n+    suggestions: BTreeMap<Span, String>,\n+}\n+\n+impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            maybe_typeck_results: cx.maybe_typeck_results(),\n+            target,\n+            suggestions: BTreeMap::new(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_body(&mut self, body: &'tcx Body<'_>) {\n+        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body.id()));\n+        walk_body(self, body);\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(ref fun, ref args) = e.kind;\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n+            if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n+            then {\n+                if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n+                    return;\n+                }\n+\n+                if match_path(ty_path, &paths::HASHMAP) {\n+                    if method.ident.name == sym::new {\n+                        self.suggestions\n+                            .insert(e.span, \"HashMap::default()\".to_string());\n+                    } else if method.ident.name == sym!(with_capacity) {\n+                        self.suggestions.insert(\n+                            e.span,\n+                            format!(\n+                                \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n+                                snippet(self.cx, args[0].span, \"capacity\"),\n+                            ),\n+                        );\n+                    }\n+                } else if match_path(ty_path, &paths::HASHSET) {\n+                    if method.ident.name == sym::new {\n+                        self.suggestions\n+                            .insert(e.span, \"HashSet::default()\".to_string());\n+                    } else if method.ident.name == sym!(with_capacity) {\n+                        self.suggestions.insert(\n+                            e.span,\n+                            format!(\n+                                \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n+                                snippet(self.cx, args[0].span, \"capacity\"),\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        walk_expr(self, e);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}"}, {"sha": "d183fc41f315314f549709c7a41131a625d25526", "filename": "clippy_lints/src/invalid_upcast_comparisons.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -0,0 +1,221 @@\n+use std::cmp::Ordering;\n+\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, IntTy, UintTy};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+use rustc_target::abi::LayoutOf;\n+\n+use crate::consts::{constant, Constant};\n+\n+use clippy_utils::comparisons::Rel;\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{comparisons, sext};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where the relation is always either\n+    /// true or false, but where one side has been upcast so that the comparison is\n+    /// necessary. Only integer types are checked.\n+    ///\n+    /// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n+    /// will mistakenly imply that it is possible for `x` to be outside the range of\n+    /// `u8`.\n+    ///\n+    /// **Known problems:**\n+    /// https://github.com/rust-lang/rust-clippy/issues/886\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: u8 = 1;\n+    /// (x as u32) > 300;\n+    /// ```\n+    pub INVALID_UPCAST_COMPARISONS,\n+    pedantic,\n+    \"a comparison involving an upcast which is always true or false\"\n+}\n+\n+declare_lint_pass!(InvalidUpcastComparisons => [INVALID_UPCAST_COMPARISONS]);\n+\n+#[derive(Copy, Clone, Debug, Eq)]\n+enum FullInt {\n+    S(i128),\n+    U(u128),\n+}\n+\n+impl FullInt {\n+    #[allow(clippy::cast_sign_loss)]\n+    #[must_use]\n+    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n+        if s < 0 {\n+            Ordering::Less\n+        } else if u > (i128::MAX as u128) {\n+            Ordering::Greater\n+        } else {\n+            (s as u128).cmp(&u)\n+        }\n+    }\n+}\n+\n+impl PartialEq for FullInt {\n+    #[must_use]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n+    }\n+}\n+\n+impl PartialOrd for FullInt {\n+    #[must_use]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(match (self, other) {\n+            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n+            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n+            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n+            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n+        })\n+    }\n+}\n+\n+impl Ord for FullInt {\n+    #[must_use]\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other)\n+            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n+    }\n+}\n+\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n+        let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n+        // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n+        if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n+            return None;\n+        }\n+        match pre_cast_ty.kind() {\n+            ty::Int(int_ty) => Some(match int_ty {\n+                IntTy::I8 => (FullInt::S(i128::from(i8::MIN)), FullInt::S(i128::from(i8::MAX))),\n+                IntTy::I16 => (FullInt::S(i128::from(i16::MIN)), FullInt::S(i128::from(i16::MAX))),\n+                IntTy::I32 => (FullInt::S(i128::from(i32::MIN)), FullInt::S(i128::from(i32::MAX))),\n+                IntTy::I64 => (FullInt::S(i128::from(i64::MIN)), FullInt::S(i128::from(i64::MAX))),\n+                IntTy::I128 => (FullInt::S(i128::MIN), FullInt::S(i128::MAX)),\n+                IntTy::Isize => (FullInt::S(isize::MIN as i128), FullInt::S(isize::MAX as i128)),\n+            }),\n+            ty::Uint(uint_ty) => Some(match uint_ty {\n+                UintTy::U8 => (FullInt::U(u128::from(u8::MIN)), FullInt::U(u128::from(u8::MAX))),\n+                UintTy::U16 => (FullInt::U(u128::from(u16::MIN)), FullInt::U(u128::from(u16::MAX))),\n+                UintTy::U32 => (FullInt::U(u128::from(u32::MIN)), FullInt::U(u128::from(u32::MAX))),\n+                UintTy::U64 => (FullInt::U(u128::from(u64::MIN)), FullInt::U(u128::from(u64::MAX))),\n+                UintTy::U128 => (FullInt::U(u128::MIN), FullInt::U(u128::MAX)),\n+                UintTy::Usize => (FullInt::U(usize::MIN as u128), FullInt::U(usize::MAX as u128)),\n+            }),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n+    let val = constant(cx, cx.typeck_results(), expr)?.0;\n+    if let Constant::Int(const_int) = val {\n+        match *cx.typeck_results().expr_ty(expr).kind() {\n+            ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n+            ty::Uint(_) => Some(FullInt::U(const_int)),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n+    if let ExprKind::Cast(ref cast_val, _) = expr.kind {\n+        span_lint(\n+            cx,\n+            INVALID_UPCAST_COMPARISONS,\n+            span,\n+            &format!(\n+                \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n+                snippet(cx, cast_val.span, \"the expression\"),\n+                if always { \"true\" } else { \"false\" },\n+            ),\n+        );\n+    }\n+}\n+\n+fn upcast_comparison_bounds_err<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    span: Span,\n+    rel: comparisons::Rel,\n+    lhs_bounds: Option<(FullInt, FullInt)>,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+    invert: bool,\n+) {\n+    if let Some((lb, ub)) = lhs_bounds {\n+        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n+            if rel == Rel::Eq || rel == Rel::Ne {\n+                if norm_rhs_val < lb || norm_rhs_val > ub {\n+                    err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);\n+                }\n+            } else if match rel {\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val < lb\n+                    } else {\n+                        ub < norm_rhs_val\n+                    }\n+                },\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val <= lb\n+                    } else {\n+                        ub <= norm_rhs_val\n+                    }\n+                },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n+                err_upcast_comparison(cx, span, lhs, true)\n+            } else if match rel {\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val >= ub\n+                    } else {\n+                        lb >= norm_rhs_val\n+                    }\n+                },\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val > ub\n+                    } else {\n+                        lb > norm_rhs_val\n+                    }\n+                },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n+                err_upcast_comparison(cx, span, lhs, false)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for InvalidUpcastComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n+            let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n+            let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n+                val\n+            } else {\n+                return;\n+            };\n+\n+            let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n+            let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n+\n+            upcast_comparison_bounds_err(cx, expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n+            upcast_comparison_bounds_err(cx, expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n+        }\n+    }\n+}"}, {"sha": "d37e229fb578edf5a96e2cfd23e007ca41f73213", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -164,6 +164,7 @@ mod consts;\n mod utils;\n \n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n+mod absurd_extreme_comparisons;\n mod approx_const;\n mod arithmetic;\n mod as_conversions;\n@@ -231,6 +232,7 @@ mod if_let_mutex;\n mod if_let_some_result;\n mod if_not_else;\n mod if_then_some_else_none;\n+mod implicit_hasher;\n mod implicit_return;\n mod implicit_saturating_sub;\n mod inconsistent_struct_constructor;\n@@ -241,6 +243,7 @@ mod inherent_to_string;\n mod inline_fn_without_body;\n mod int_plus_one;\n mod integer_division;\n+mod invalid_upcast_comparisons;\n mod items_after_statements;\n mod large_const_arrays;\n mod large_enum_variant;\n@@ -559,6 +562,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::PRODUCE_ICE,\n         #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n+        &absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS,\n         &approx_const::APPROX_CONSTANT,\n         &arithmetic::FLOAT_ARITHMETIC,\n         &arithmetic::INTEGER_ARITHMETIC,\n@@ -683,6 +687,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &if_let_some_result::IF_LET_SOME_RESULT,\n         &if_not_else::IF_NOT_ELSE,\n         &if_then_some_else_none::IF_THEN_SOME_ELSE_NONE,\n+        &implicit_hasher::IMPLICIT_HASHER,\n         &implicit_return::IMPLICIT_RETURN,\n         &implicit_saturating_sub::IMPLICIT_SATURATING_SUB,\n         &inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR,\n@@ -696,6 +701,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &inline_fn_without_body::INLINE_FN_WITHOUT_BODY,\n         &int_plus_one::INT_PLUS_ONE,\n         &integer_division::INTEGER_DIVISION,\n+        &invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS,\n         &items_after_statements::ITEMS_AFTER_STATEMENTS,\n         &large_const_arrays::LARGE_CONST_ARRAYS,\n         &large_enum_variant::LARGE_ENUM_VARIANT,\n@@ -957,11 +963,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &transmute::WRONG_TRANSMUTE,\n         &transmuting_null::TRANSMUTING_NULL,\n         &try_err::TRY_ERR,\n-        &types::ABSURD_EXTREME_COMPARISONS,\n         &types::BORROWED_BOX,\n         &types::BOX_VEC,\n-        &types::IMPLICIT_HASHER,\n-        &types::INVALID_UPCAST_COMPARISONS,\n         &types::LINKEDLIST,\n         &types::OPTION_OPTION,\n         &types::RC_BUFFER,\n@@ -1030,7 +1033,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n     store.register_late_pass(|| box serde_api::SerdeApi);\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n-    store.register_late_pass(move || box types::Types::new(vec_box_size_threshold));\n+    let type_complexity_threshold = conf.type_complexity_threshold;\n+    store.register_late_pass(move || box types::Types::new(vec_box_size_threshold, type_complexity_threshold));\n     store.register_late_pass(|| box booleans::NonminimalBool);\n     store.register_late_pass(|| box eq_op::EqOp);\n     store.register_late_pass(|| box enum_clike::UnportableVariant);\n@@ -1093,8 +1097,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box main_recursion::MainRecursion::default());\n     store.register_late_pass(|| box lifetimes::Lifetimes);\n     store.register_late_pass(|| box entry::HashMapPass);\n-    let type_complexity_threshold = conf.type_complexity_threshold;\n-    store.register_late_pass(move || box types::TypeComplexity::new(type_complexity_threshold));\n     store.register_late_pass(|| box minmax::MinMaxPass);\n     store.register_late_pass(|| box open_options::OpenOptions);\n     store.register_late_pass(|| box zero_div_zero::ZeroDiv);\n@@ -1116,8 +1118,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n     store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n     store.register_late_pass(|| box empty_enum::EmptyEnum);\n-    store.register_late_pass(|| box types::AbsurdExtremeComparisons);\n-    store.register_late_pass(|| box types::InvalidUpcastComparisons);\n+    store.register_late_pass(|| box absurd_extreme_comparisons::AbsurdExtremeComparisons);\n+    store.register_late_pass(|| box invalid_upcast_comparisons::InvalidUpcastComparisons);\n     store.register_late_pass(|| box regex::Regex::default());\n     store.register_late_pass(|| box copies::CopyAndPaste);\n     store.register_late_pass(|| box copy_iterator::CopyIterator);\n@@ -1161,7 +1163,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box infinite_iter::InfiniteIter);\n     store.register_late_pass(|| box inline_fn_without_body::InlineFnWithoutBody);\n     store.register_late_pass(|| box useless_conversion::UselessConversion::default());\n-    store.register_late_pass(|| box types::ImplicitHasher);\n+    store.register_late_pass(|| box implicit_hasher::ImplicitHasher);\n     store.register_late_pass(|| box fallible_impl_from::FallibleImplFrom);\n     store.register_late_pass(|| box double_comparison::DoubleComparisons);\n     store.register_late_pass(|| box question_mark::QuestionMark);\n@@ -1374,8 +1376,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&functions::MUST_USE_CANDIDATE),\n         LintId::of(&functions::TOO_MANY_LINES),\n         LintId::of(&if_not_else::IF_NOT_ELSE),\n+        LintId::of(&implicit_hasher::IMPLICIT_HASHER),\n         LintId::of(&implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n         LintId::of(&infinite_iter::MAYBE_INFINITE_ITER),\n+        LintId::of(&invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS),\n         LintId::of(&items_after_statements::ITEMS_AFTER_STATEMENTS),\n         LintId::of(&large_stack_arrays::LARGE_STACK_ARRAYS),\n         LintId::of(&let_underscore::LET_UNDERSCORE_DROP),\n@@ -1414,8 +1418,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n         LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n-        LintId::of(&types::IMPLICIT_HASHER),\n-        LintId::of(&types::INVALID_UPCAST_COMPARISONS),\n         LintId::of(&types::LINKEDLIST),\n         LintId::of(&types::OPTION_OPTION),\n         LintId::of(&unicode::NON_ASCII_LITERAL),\n@@ -1445,6 +1447,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n \n     store.register_group(true, \"clippy::all\", Some(\"clippy\"), vec![\n+        LintId::of(&absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&approx_const::APPROX_CONSTANT),\n         LintId::of(&assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n         LintId::of(&assign_ops::ASSIGN_OP_PATTERN),\n@@ -1705,7 +1708,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),\n         LintId::of(&try_err::TRY_ERR),\n-        LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&types::BORROWED_BOX),\n         LintId::of(&types::BOX_VEC),\n         LintId::of(&types::REDUNDANT_ALLOCATION),\n@@ -1945,6 +1947,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n \n     store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), vec![\n+        LintId::of(&absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&approx_const::APPROX_CONSTANT),\n         LintId::of(&async_yields_async::ASYNC_YIELDS_ASYNC),\n         LintId::of(&atomic_ordering::INVALID_ATOMIC_ORDERING),\n@@ -2007,7 +2010,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::UNSOUND_COLLECTION_TRANSMUTE),\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),\n-        LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n         LintId::of(&unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),"}, {"sha": "12e1eba2ca6620676d32d88581f911a7a5953042", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 119, "deletions": 944, "changes": 1063, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -1,43 +1,22 @@\n-#![allow(rustc::default_hash_types)]\n-\n mod borrowed_box;\n mod box_vec;\n mod linked_list;\n mod option_option;\n mod rc_buffer;\n mod redundant_allocation;\n+mod type_complexity;\n mod utils;\n mod vec_box;\n \n-use std::borrow::Cow;\n-use std::cmp::Ordering;\n-use std::collections::BTreeMap;\n-\n-use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_help, span_lint_and_then};\n-use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{is_isize_or_usize, is_type_diagnostic_item};\n-use if_chain::if_chain;\n-use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    BinOpKind, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n-    ImplItemKind, Item, ItemKind, Local, MutTy, QPath, TraitFn, TraitItem, TraitItemKind, TyKind,\n+    Body, FnDecl, FnRetTy, GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local, MutTy, QPath, TraitItem,\n+    TraitItemKind, TyKind,\n };\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, IntTy, Ty, TyS, TypeckResults, UintTy};\n-use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::sym;\n-use rustc_target::abi::LayoutOf;\n-use rustc_target::spec::abi::Abi;\n-use rustc_typeck::hir_ty_to_ty;\n-\n-use crate::consts::{constant, Constant};\n-use clippy_utils::paths;\n-use clippy_utils::{clip, comparisons, differing_macro_contexts, int_bits, match_path, sext, unsext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n@@ -250,68 +229,144 @@ declare_clippy_lint! {\n     \"shared ownership of a buffer type\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for types used in structs, parameters and `let`\n+    /// declarations above a certain complexity threshold.\n+    ///\n+    /// **Why is this bad?** Too complex types make the code less readable. Consider\n+    /// using a `type` definition to simplify them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// struct Foo {\n+    ///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n+    /// }\n+    /// ```\n+    pub TYPE_COMPLEXITY,\n+    complexity,\n+    \"usage of very complex types that might be better factored into `type` definitions\"\n+}\n+\n pub struct Types {\n     vec_box_size_threshold: u64,\n+    type_complexity_threshold: u64,\n }\n \n-impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER]);\n+impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER, TYPE_COMPLEXITY]);\n \n impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_fn(&mut self, cx: &LateContext<'_>, _: FnKind<'_>, decl: &FnDecl<'_>, _: &Body<'_>, _: Span, id: HirId) {\n-        // Skip trait implementations; see issue #605.\n-        if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id)) {\n-            if let ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n-                return;\n-            }\n+        let is_in_trait_impl = if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id))\n+        {\n+            matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n+        } else {\n+            false\n+        };\n+\n+        self.check_fn_decl(\n+            cx,\n+            decl,\n+            CheckTyContext {\n+                is_in_trait_impl,\n+                ..CheckTyContext::default()\n+            },\n+        );\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        match item.kind {\n+            ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => {\n+                self.check_ty(cx, ty, CheckTyContext::default())\n+            },\n+            // functions, enums, structs, impls and traits are covered\n+            _ => (),\n         }\n+    }\n \n-        self.check_fn_decl(cx, decl);\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n+        match item.kind {\n+            ImplItemKind::Const(ref ty, _) | ImplItemKind::TyAlias(ref ty) => self.check_ty(\n+                cx,\n+                ty,\n+                CheckTyContext {\n+                    is_in_trait_impl: true,\n+                    ..CheckTyContext::default()\n+                },\n+            ),\n+            // methods are covered by check_fn\n+            ImplItemKind::Fn(..) => (),\n+        }\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        self.check_ty(cx, &field.ty, false);\n+        self.check_ty(cx, &field.ty, CheckTyContext::default());\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n         match item.kind {\n-            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_ty(cx, ty, false),\n-            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, &sig.decl),\n+            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => {\n+                self.check_ty(cx, ty, CheckTyContext::default())\n+            },\n+            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, &sig.decl, CheckTyContext::default()),\n             TraitItemKind::Type(..) => (),\n         }\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'_>, local: &Local<'_>) {\n         if let Some(ref ty) = local.ty {\n-            self.check_ty(cx, ty, true);\n+            self.check_ty(\n+                cx,\n+                ty,\n+                CheckTyContext {\n+                    is_local: true,\n+                    ..CheckTyContext::default()\n+                },\n+            );\n         }\n     }\n }\n \n impl Types {\n-    pub fn new(vec_box_size_threshold: u64) -> Self {\n-        Self { vec_box_size_threshold }\n+    pub fn new(vec_box_size_threshold: u64, type_complexity_threshold: u64) -> Self {\n+        Self {\n+            vec_box_size_threshold,\n+            type_complexity_threshold,\n+        }\n     }\n \n-    fn check_fn_decl(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n+    fn check_fn_decl(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>, context: CheckTyContext) {\n         for input in decl.inputs {\n-            self.check_ty(cx, input, false);\n+            self.check_ty(cx, input, context);\n         }\n \n         if let FnRetTy::Return(ref ty) = decl.output {\n-            self.check_ty(cx, ty, false);\n+            self.check_ty(cx, ty, context);\n         }\n     }\n \n     /// Recursively check for `TypePass` lints in the given type. Stop at the first\n     /// lint found.\n     ///\n     /// The parameter `is_local` distinguishes the context of the type.\n-    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, mut context: CheckTyContext) {\n         if hir_ty.span.from_expansion() {\n             return;\n         }\n+\n+        if !context.is_nested_call && type_complexity::check(cx, hir_ty, self.type_complexity_threshold) {\n+            return;\n+        }\n+\n+        // Skip trait implementations; see issue #605.\n+        if context.is_in_trait_impl {\n+            return;\n+        }\n+\n         match hir_ty.kind {\n-            TyKind::Path(ref qpath) if !is_local => {\n+            TyKind::Path(ref qpath) if !context.is_local => {\n                 let hir_id = hir_ty.hir_id;\n                 let res = cx.qpath_res(qpath, hir_id);\n                 if let Some(def_id) = res.opt_def_id() {\n@@ -329,7 +384,8 @@ impl Types {\n                 }\n                 match *qpath {\n                     QPath::Resolved(Some(ref ty), ref p) => {\n-                        self.check_ty(cx, ty, is_local);\n+                        context.is_nested_call = true;\n+                        self.check_ty(cx, ty, context);\n                         for ty in p.segments.iter().flat_map(|seg| {\n                             seg.args\n                                 .as_ref()\n@@ -339,10 +395,11 @@ impl Types {\n                                     _ => None,\n                                 })\n                         }) {\n-                            self.check_ty(cx, ty, is_local);\n+                            self.check_ty(cx, ty, context);\n                         }\n                     },\n                     QPath::Resolved(None, ref p) => {\n+                        context.is_nested_call = true;\n                         for ty in p.segments.iter().flat_map(|seg| {\n                             seg.args\n                                 .as_ref()\n@@ -352,930 +409,48 @@ impl Types {\n                                     _ => None,\n                                 })\n                         }) {\n-                            self.check_ty(cx, ty, is_local);\n+                            self.check_ty(cx, ty, context);\n                         }\n                     },\n                     QPath::TypeRelative(ref ty, ref seg) => {\n-                        self.check_ty(cx, ty, is_local);\n+                        context.is_nested_call = true;\n+                        self.check_ty(cx, ty, context);\n                         if let Some(ref params) = seg.args {\n                             for ty in params.args.iter().filter_map(|arg| match arg {\n                                 GenericArg::Type(ty) => Some(ty),\n                                 _ => None,\n                             }) {\n-                                self.check_ty(cx, ty, is_local);\n+                                self.check_ty(cx, ty, context);\n                             }\n                         }\n                     },\n                     QPath::LangItem(..) => {},\n                 }\n             },\n             TyKind::Rptr(ref lt, ref mut_ty) => {\n+                context.is_nested_call = true;\n                 if !borrowed_box::check(cx, hir_ty, lt, mut_ty) {\n-                    self.check_ty(cx, &mut_ty.ty, is_local);\n+                    self.check_ty(cx, &mut_ty.ty, context);\n                 }\n             },\n             TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n-                self.check_ty(cx, ty, is_local)\n+                context.is_nested_call = true;\n+                self.check_ty(cx, ty, context)\n             },\n             TyKind::Tup(tys) => {\n+                context.is_nested_call = true;\n                 for ty in tys {\n-                    self.check_ty(cx, ty, is_local);\n-                }\n-            },\n-            _ => {},\n-        }\n-    }\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for types used in structs, parameters and `let`\n-    /// declarations above a certain complexity threshold.\n-    ///\n-    /// **Why is this bad?** Too complex types make the code less readable. Consider\n-    /// using a `type` definition to simplify them.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # use std::rc::Rc;\n-    /// struct Foo {\n-    ///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n-    /// }\n-    /// ```\n-    pub TYPE_COMPLEXITY,\n-    complexity,\n-    \"usage of very complex types that might be better factored into `type` definitions\"\n-}\n-\n-pub struct TypeComplexity {\n-    threshold: u64,\n-}\n-\n-impl TypeComplexity {\n-    #[must_use]\n-    pub fn new(threshold: u64) -> Self {\n-        Self { threshold }\n-    }\n-}\n-\n-impl_lint_pass!(TypeComplexity => [TYPE_COMPLEXITY]);\n-\n-impl<'tcx> LateLintPass<'tcx> for TypeComplexity {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        _: FnKind<'tcx>,\n-        decl: &'tcx FnDecl<'_>,\n-        _: &'tcx Body<'_>,\n-        _: Span,\n-        _: HirId,\n-    ) {\n-        self.check_fndecl(cx, decl);\n-    }\n-\n-    fn check_field_def(&mut self, cx: &LateContext<'tcx>, field: &'tcx hir::FieldDef<'_>) {\n-        // enum variants are also struct fields now\n-        self.check_type(cx, &field.ty);\n-    }\n-\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        match item.kind {\n-            ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => self.check_type(cx, ty),\n-            // functions, enums, structs, impls and traits are covered\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n-        match item.kind {\n-            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n-            TraitItemKind::Fn(FnSig { ref decl, .. }, TraitFn::Required(_)) => self.check_fndecl(cx, decl),\n-            // methods with default impl are covered by check_fn\n-            TraitItemKind::Type(..) | TraitItemKind::Fn(_, TraitFn::Provided(_)) => (),\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n-        match item.kind {\n-            ImplItemKind::Const(ref ty, _) | ImplItemKind::TyAlias(ref ty) => self.check_type(cx, ty),\n-            // methods are covered by check_fn\n-            ImplItemKind::Fn(..) => (),\n-        }\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n-        if let Some(ref ty) = local.ty {\n-            self.check_type(cx, ty);\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeComplexity {\n-    fn check_fndecl(&self, cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'_>) {\n-        for arg in decl.inputs {\n-            self.check_type(cx, arg);\n-        }\n-        if let FnRetTy::Return(ref ty) = decl.output {\n-            self.check_type(cx, ty);\n-        }\n-    }\n-\n-    fn check_type(&self, cx: &LateContext<'_>, ty: &hir::Ty<'_>) {\n-        if ty.span.from_expansion() {\n-            return;\n-        }\n-        let score = {\n-            let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n-            visitor.visit_ty(ty);\n-            visitor.score\n-        };\n-\n-        if score > self.threshold {\n-            span_lint(\n-                cx,\n-                TYPE_COMPLEXITY,\n-                ty.span,\n-                \"very complex type used. Consider factoring parts into `type` definitions\",\n-            );\n-        }\n-    }\n-}\n-\n-/// Walks a type and assigns a complexity score to it.\n-struct TypeComplexityVisitor {\n-    /// total complexity score of the type\n-    score: u64,\n-    /// current nesting level\n-    nest: u64,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'_>) {\n-        let (add_score, sub_nest) = match ty.kind {\n-            // _, &x and *x have only small overhead; don't mess with nesting level\n-            TyKind::Infer | TyKind::Ptr(..) | TyKind::Rptr(..) => (1, 0),\n-\n-            // the \"normal\" components of a type: named types, arrays/tuples\n-            TyKind::Path(..) | TyKind::Slice(..) | TyKind::Tup(..) | TyKind::Array(..) => (10 * self.nest, 1),\n-\n-            // function types bring a lot of overhead\n-            TyKind::BareFn(ref bare) if bare.abi == Abi::Rust => (50 * self.nest, 1),\n-\n-            TyKind::TraitObject(ref param_bounds, _, _) => {\n-                let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n-                    bound\n-                        .bound_generic_params\n-                        .iter()\n-                        .any(|gen| matches!(gen.kind, GenericParamKind::Lifetime { .. }))\n-                });\n-                if has_lifetime_parameters {\n-                    // complex trait bounds like A<'a, 'b>\n-                    (50 * self.nest, 1)\n-                } else {\n-                    // simple trait bounds like A + B\n-                    (20 * self.nest, 0)\n-                }\n-            },\n-\n-            _ => (0, 0),\n-        };\n-        self.score += add_score;\n-        self.nest += sub_nest;\n-        walk_ty(self, ty);\n-        self.nest -= sub_nest;\n-    }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for comparisons where one side of the relation is\n-    /// either the minimum or maximum value for its type and warns if it involves a\n-    /// case that is always true or always false. Only integer and boolean types are\n-    /// checked.\n-    ///\n-    /// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n-    /// that it is possible for `x` to be less than the minimum. Expressions like\n-    /// `max < x` are probably mistakes.\n-    ///\n-    /// **Known problems:** For `usize` the size of the current compile target will\n-    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n-    /// a comparison to detect target pointer width will trigger this lint. One can\n-    /// use `mem::sizeof` and compare its value or conditional compilation\n-    /// attributes\n-    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// let vec: Vec<isize> = Vec::new();\n-    /// if vec.len() <= 0 {}\n-    /// if 100 > i32::MAX {}\n-    /// ```\n-    pub ABSURD_EXTREME_COMPARISONS,\n-    correctness,\n-    \"a comparison with a maximum or minimum value that is always true or false\"\n-}\n-\n-declare_lint_pass!(AbsurdExtremeComparisons => [ABSURD_EXTREME_COMPARISONS]);\n-\n-enum ExtremeType {\n-    Minimum,\n-    Maximum,\n-}\n-\n-struct ExtremeExpr<'a> {\n-    which: ExtremeType,\n-    expr: &'a Expr<'a>,\n-}\n-\n-enum AbsurdComparisonResult {\n-    AlwaysFalse,\n-    AlwaysTrue,\n-    InequalityImpossible,\n-}\n-\n-fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let precast_ty = cx.typeck_results().expr_ty(cast_exp);\n-        let cast_ty = cx.typeck_results().expr_ty(expr);\n-\n-        return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n-    }\n-\n-    false\n-}\n-\n-fn detect_absurd_comparison<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    op: BinOpKind,\n-    lhs: &'tcx Expr<'_>,\n-    rhs: &'tcx Expr<'_>,\n-) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n-    use crate::types::AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n-    use crate::types::ExtremeType::{Maximum, Minimum};\n-    use clippy_utils::comparisons::{normalize_comparison, Rel};\n-\n-    // absurd comparison only makes sense on primitive types\n-    // primitive types don't implement comparison operators with each other\n-    if cx.typeck_results().expr_ty(lhs) != cx.typeck_results().expr_ty(rhs) {\n-        return None;\n-    }\n-\n-    // comparisons between fix sized types and target sized types are considered unanalyzable\n-    if is_cast_between_fixed_and_target(cx, lhs) || is_cast_between_fixed_and_target(cx, rhs) {\n-        return None;\n-    }\n-\n-    let (rel, normalized_lhs, normalized_rhs) = normalize_comparison(op, lhs, rhs)?;\n-\n-    let lx = detect_extreme_expr(cx, normalized_lhs);\n-    let rx = detect_extreme_expr(cx, normalized_rhs);\n-\n-    Some(match rel {\n-        Rel::Lt => {\n-            match (lx, rx) {\n-                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n-                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n-                _ => return None,\n-            }\n-        },\n-        Rel::Le => {\n-            match (lx, rx) {\n-                (Some(l @ ExtremeExpr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n-                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, InequalityImpossible), // max <= x\n-                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n-                (_, Some(r @ ExtremeExpr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n-                _ => return None,\n-            }\n-        },\n-        Rel::Ne | Rel::Eq => return None,\n-    })\n-}\n-\n-fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n-    use crate::types::ExtremeType::{Maximum, Minimum};\n-\n-    let ty = cx.typeck_results().expr_ty(expr);\n-\n-    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n-\n-    let which = match (ty.kind(), cv) {\n-        (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n-        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) => {\n-            Minimum\n-        },\n-\n-        (&ty::Bool, Constant::Bool(true)) => Maximum,\n-        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MAX >> (128 - int_bits(cx.tcx, ity)), ity) => {\n-            Maximum\n-        },\n-        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::MAX, uty) == i => Maximum,\n-\n-        _ => return None,\n-    };\n-    Some(ExtremeExpr { which, expr })\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        use crate::types::AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n-        use crate::types::ExtremeType::{Maximum, Minimum};\n-\n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n-            if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n-                if !expr.span.from_expansion() {\n-                    let msg = \"this comparison involving the minimum or maximum element for this \\\n-                               type contains a case that is always true or always false\";\n-\n-                    let conclusion = match result {\n-                        AlwaysFalse => \"this comparison is always false\".to_owned(),\n-                        AlwaysTrue => \"this comparison is always true\".to_owned(),\n-                        InequalityImpossible => format!(\n-                            \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n-                             instead\",\n-                            snippet(cx, lhs.span, \"lhs\"),\n-                            snippet(cx, rhs.span, \"rhs\")\n-                        ),\n-                    };\n-\n-                    let help = format!(\n-                        \"because `{}` is the {} value for this type, {}\",\n-                        snippet(cx, culprit.expr.span, \"x\"),\n-                        match culprit.which {\n-                            Minimum => \"minimum\",\n-                            Maximum => \"maximum\",\n-                        },\n-                        conclusion\n-                    );\n-\n-                    span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for comparisons where the relation is always either\n-    /// true or false, but where one side has been upcast so that the comparison is\n-    /// necessary. Only integer types are checked.\n-    ///\n-    /// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n-    /// will mistakenly imply that it is possible for `x` to be outside the range of\n-    /// `u8`.\n-    ///\n-    /// **Known problems:**\n-    /// https://github.com/rust-lang/rust-clippy/issues/886\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x: u8 = 1;\n-    /// (x as u32) > 300;\n-    /// ```\n-    pub INVALID_UPCAST_COMPARISONS,\n-    pedantic,\n-    \"a comparison involving an upcast which is always true or false\"\n-}\n-\n-declare_lint_pass!(InvalidUpcastComparisons => [INVALID_UPCAST_COMPARISONS]);\n-\n-#[derive(Copy, Clone, Debug, Eq)]\n-enum FullInt {\n-    S(i128),\n-    U(u128),\n-}\n-\n-impl FullInt {\n-    #[allow(clippy::cast_sign_loss)]\n-    #[must_use]\n-    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n-        if s < 0 {\n-            Ordering::Less\n-        } else if u > (i128::MAX as u128) {\n-            Ordering::Greater\n-        } else {\n-            (s as u128).cmp(&u)\n-        }\n-    }\n-}\n-\n-impl PartialEq for FullInt {\n-    #[must_use]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n-    }\n-}\n-\n-impl PartialOrd for FullInt {\n-    #[must_use]\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(match (self, other) {\n-            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n-            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n-            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n-            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n-        })\n-    }\n-}\n-\n-impl Ord for FullInt {\n-    #[must_use]\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other)\n-            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n-    }\n-}\n-\n-fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n-    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n-        let cast_ty = cx.typeck_results().expr_ty(expr);\n-        // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n-        if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n-            return None;\n-        }\n-        match pre_cast_ty.kind() {\n-            ty::Int(int_ty) => Some(match int_ty {\n-                IntTy::I8 => (FullInt::S(i128::from(i8::MIN)), FullInt::S(i128::from(i8::MAX))),\n-                IntTy::I16 => (FullInt::S(i128::from(i16::MIN)), FullInt::S(i128::from(i16::MAX))),\n-                IntTy::I32 => (FullInt::S(i128::from(i32::MIN)), FullInt::S(i128::from(i32::MAX))),\n-                IntTy::I64 => (FullInt::S(i128::from(i64::MIN)), FullInt::S(i128::from(i64::MAX))),\n-                IntTy::I128 => (FullInt::S(i128::MIN), FullInt::S(i128::MAX)),\n-                IntTy::Isize => (FullInt::S(isize::MIN as i128), FullInt::S(isize::MAX as i128)),\n-            }),\n-            ty::Uint(uint_ty) => Some(match uint_ty {\n-                UintTy::U8 => (FullInt::U(u128::from(u8::MIN)), FullInt::U(u128::from(u8::MAX))),\n-                UintTy::U16 => (FullInt::U(u128::from(u16::MIN)), FullInt::U(u128::from(u16::MAX))),\n-                UintTy::U32 => (FullInt::U(u128::from(u32::MIN)), FullInt::U(u128::from(u32::MAX))),\n-                UintTy::U64 => (FullInt::U(u128::from(u64::MIN)), FullInt::U(u128::from(u64::MAX))),\n-                UintTy::U128 => (FullInt::U(u128::MIN), FullInt::U(u128::MAX)),\n-                UintTy::Usize => (FullInt::U(usize::MIN as u128), FullInt::U(usize::MAX as u128)),\n-            }),\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n-    let val = constant(cx, cx.typeck_results(), expr)?.0;\n-    if let Constant::Int(const_int) = val {\n-        match *cx.typeck_results().expr_ty(expr).kind() {\n-            ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n-            ty::Uint(_) => Some(FullInt::U(const_int)),\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n-    if let ExprKind::Cast(ref cast_val, _) = expr.kind {\n-        span_lint(\n-            cx,\n-            INVALID_UPCAST_COMPARISONS,\n-            span,\n-            &format!(\n-                \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n-                snippet(cx, cast_val.span, \"the expression\"),\n-                if always { \"true\" } else { \"false\" },\n-            ),\n-        );\n-    }\n-}\n-\n-fn upcast_comparison_bounds_err<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    span: Span,\n-    rel: comparisons::Rel,\n-    lhs_bounds: Option<(FullInt, FullInt)>,\n-    lhs: &'tcx Expr<'_>,\n-    rhs: &'tcx Expr<'_>,\n-    invert: bool,\n-) {\n-    use clippy_utils::comparisons::Rel;\n-\n-    if let Some((lb, ub)) = lhs_bounds {\n-        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n-            if rel == Rel::Eq || rel == Rel::Ne {\n-                if norm_rhs_val < lb || norm_rhs_val > ub {\n-                    err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);\n-                }\n-            } else if match rel {\n-                Rel::Lt => {\n-                    if invert {\n-                        norm_rhs_val < lb\n-                    } else {\n-                        ub < norm_rhs_val\n-                    }\n-                },\n-                Rel::Le => {\n-                    if invert {\n-                        norm_rhs_val <= lb\n-                    } else {\n-                        ub <= norm_rhs_val\n-                    }\n-                },\n-                Rel::Eq | Rel::Ne => unreachable!(),\n-            } {\n-                err_upcast_comparison(cx, span, lhs, true)\n-            } else if match rel {\n-                Rel::Lt => {\n-                    if invert {\n-                        norm_rhs_val >= ub\n-                    } else {\n-                        lb >= norm_rhs_val\n-                    }\n-                },\n-                Rel::Le => {\n-                    if invert {\n-                        norm_rhs_val > ub\n-                    } else {\n-                        lb > norm_rhs_val\n-                    }\n-                },\n-                Rel::Eq | Rel::Ne => unreachable!(),\n-            } {\n-                err_upcast_comparison(cx, span, lhs, false)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for InvalidUpcastComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n-            let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n-            let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n-                val\n-            } else {\n-                return;\n-            };\n-\n-            let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n-            let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n-\n-            upcast_comparison_bounds_err(cx, expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n-            upcast_comparison_bounds_err(cx, expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n-        }\n-    }\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for public `impl` or `fn` missing generalization\n-    /// over different hashers and implicitly defaulting to the default hashing\n-    /// algorithm (`SipHash`).\n-    ///\n-    /// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n-    /// used with them.\n-    ///\n-    /// **Known problems:** Suggestions for replacing constructors can contain\n-    /// false-positives. Also applying suggestions can require modification of other\n-    /// pieces of code, possibly including external crates.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # use std::collections::HashMap;\n-    /// # use std::hash::{Hash, BuildHasher};\n-    /// # trait Serialize {};\n-    /// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n-    ///\n-    /// pub fn foo(map: &mut HashMap<i32, i32>) { }\n-    /// ```\n-    /// could be rewritten as\n-    /// ```rust\n-    /// # use std::collections::HashMap;\n-    /// # use std::hash::{Hash, BuildHasher};\n-    /// # trait Serialize {};\n-    /// impl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n-    ///\n-    /// pub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n-    /// ```\n-    pub IMPLICIT_HASHER,\n-    pedantic,\n-    \"missing generalization over different hashers\"\n-}\n-\n-declare_lint_pass!(ImplicitHasher => [IMPLICIT_HASHER]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n-    #[allow(clippy::cast_possible_truncation, clippy::too_many_lines)]\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        use rustc_span::BytePos;\n-\n-        fn suggestion<'tcx>(\n-            cx: &LateContext<'tcx>,\n-            diag: &mut DiagnosticBuilder<'_>,\n-            generics_span: Span,\n-            generics_suggestion_span: Span,\n-            target: &ImplicitHasherType<'_>,\n-            vis: ImplicitHasherConstructorVisitor<'_, '_, '_>,\n-        ) {\n-            let generics_snip = snippet(cx, generics_span, \"\");\n-            // trim `<` `>`\n-            let generics_snip = if generics_snip.is_empty() {\n-                \"\"\n-            } else {\n-                &generics_snip[1..generics_snip.len() - 1]\n-            };\n-\n-            multispan_sugg(\n-                diag,\n-                \"consider adding a type parameter\",\n-                vec![\n-                    (\n-                        generics_suggestion_span,\n-                        format!(\n-                            \"<{}{}S: ::std::hash::BuildHasher{}>\",\n-                            generics_snip,\n-                            if generics_snip.is_empty() { \"\" } else { \", \" },\n-                            if vis.suggestions.is_empty() {\n-                                \"\"\n-                            } else {\n-                                // request users to add `Default` bound so that generic constructors can be used\n-                                \" + Default\"\n-                            },\n-                        ),\n-                    ),\n-                    (\n-                        target.span(),\n-                        format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n-                    ),\n-                ],\n-            );\n-\n-            if !vis.suggestions.is_empty() {\n-                multispan_sugg(diag, \"...and use generic constructor\", vis.suggestions);\n-            }\n-        }\n-\n-        if !cx.access_levels.is_exported(item.hir_id()) {\n-            return;\n-        }\n-\n-        match item.kind {\n-            ItemKind::Impl(ref impl_) => {\n-                let mut vis = ImplicitHasherTypeVisitor::new(cx);\n-                vis.visit_ty(impl_.self_ty);\n-\n-                for target in &vis.found {\n-                    if differing_macro_contexts(item.span, target.span()) {\n-                        return;\n-                    }\n-\n-                    let generics_suggestion_span = impl_.generics.span.substitute_dummy({\n-                        let pos = snippet_opt(cx, item.span.until(target.span()))\n-                            .and_then(|snip| Some(item.span.lo() + BytePos(snip.find(\"impl\")? as u32 + 4)));\n-                        if let Some(pos) = pos {\n-                            Span::new(pos, pos, item.span.data().ctxt)\n-                        } else {\n-                            return;\n-                        }\n-                    });\n-\n-                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n-                    for item in impl_.items.iter().map(|item| cx.tcx.hir().impl_item(item.id)) {\n-                        ctr_vis.visit_impl_item(item);\n-                    }\n-\n-                    span_lint_and_then(\n-                        cx,\n-                        IMPLICIT_HASHER,\n-                        target.span(),\n-                        &format!(\n-                            \"impl for `{}` should be generalized over different hashers\",\n-                            target.type_name()\n-                        ),\n-                        move |diag| {\n-                            suggestion(cx, diag, impl_.generics.span, generics_suggestion_span, target, ctr_vis);\n-                        },\n-                    );\n-                }\n-            },\n-            ItemKind::Fn(ref sig, ref generics, body_id) => {\n-                let body = cx.tcx.hir().body(body_id);\n-\n-                for ty in sig.decl.inputs {\n-                    let mut vis = ImplicitHasherTypeVisitor::new(cx);\n-                    vis.visit_ty(ty);\n-\n-                    for target in &vis.found {\n-                        if in_external_macro(cx.sess(), generics.span) {\n-                            continue;\n-                        }\n-                        let generics_suggestion_span = generics.span.substitute_dummy({\n-                            let pos = snippet_opt(cx, item.span.until(body.params[0].pat.span))\n-                                .and_then(|snip| {\n-                                    let i = snip.find(\"fn\")?;\n-                                    Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n-                                })\n-                                .expect(\"failed to create span for type parameters\");\n-                            Span::new(pos, pos, item.span.data().ctxt)\n-                        });\n-\n-                        let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n-                        ctr_vis.visit_body(body);\n-\n-                        span_lint_and_then(\n-                            cx,\n-                            IMPLICIT_HASHER,\n-                            target.span(),\n-                            &format!(\n-                                \"parameter of type `{}` should be generalized over different hashers\",\n-                                target.type_name()\n-                            ),\n-                            move |diag| {\n-                                suggestion(cx, diag, generics.span, generics_suggestion_span, target, ctr_vis);\n-                            },\n-                        );\n-                    }\n+                    self.check_ty(cx, ty, context);\n                 }\n             },\n             _ => {},\n         }\n     }\n }\n \n-enum ImplicitHasherType<'tcx> {\n-    HashMap(Span, Ty<'tcx>, Cow<'static, str>, Cow<'static, str>),\n-    HashSet(Span, Ty<'tcx>, Cow<'static, str>),\n-}\n-\n-impl<'tcx> ImplicitHasherType<'tcx> {\n-    /// Checks that `ty` is a target type without a `BuildHasher`.\n-    fn new(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Option<Self> {\n-        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.kind {\n-            let params: Vec<_> = path\n-                .segments\n-                .last()\n-                .as_ref()?\n-                .args\n-                .as_ref()?\n-                .args\n-                .iter()\n-                .filter_map(|arg| match arg {\n-                    GenericArg::Type(ty) => Some(ty),\n-                    _ => None,\n-                })\n-                .collect();\n-            let params_len = params.len();\n-\n-            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-\n-            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) && params_len == 2 {\n-                Some(ImplicitHasherType::HashMap(\n-                    hir_ty.span,\n-                    ty,\n-                    snippet(cx, params[0].span, \"K\"),\n-                    snippet(cx, params[1].span, \"V\"),\n-                ))\n-            } else if is_type_diagnostic_item(cx, ty, sym::hashset_type) && params_len == 1 {\n-                Some(ImplicitHasherType::HashSet(\n-                    hir_ty.span,\n-                    ty,\n-                    snippet(cx, params[0].span, \"T\"),\n-                ))\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn type_name(&self) -> &'static str {\n-        match *self {\n-            ImplicitHasherType::HashMap(..) => \"HashMap\",\n-            ImplicitHasherType::HashSet(..) => \"HashSet\",\n-        }\n-    }\n-\n-    fn type_arguments(&self) -> String {\n-        match *self {\n-            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{}, {}\", k, v),\n-            ImplicitHasherType::HashSet(.., ref t) => format!(\"{}\", t),\n-        }\n-    }\n-\n-    fn ty(&self) -> Ty<'tcx> {\n-        match *self {\n-            ImplicitHasherType::HashMap(_, ty, ..) | ImplicitHasherType::HashSet(_, ty, ..) => ty,\n-        }\n-    }\n-\n-    fn span(&self) -> Span {\n-        match *self {\n-            ImplicitHasherType::HashMap(span, ..) | ImplicitHasherType::HashSet(span, ..) => span,\n-        }\n-    }\n-}\n-\n-struct ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    found: Vec<ImplicitHasherType<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>) -> Self {\n-        Self { cx, found: vec![] }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_ty(&mut self, t: &'tcx hir::Ty<'_>) {\n-        if let Some(target) = ImplicitHasherType::new(self.cx, t) {\n-            self.found.push(target);\n-        }\n-\n-        walk_ty(self, t);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-/// Looks for default-hasher-dependent constructors like `HashMap::new`.\n-struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n-    target: &'b ImplicitHasherType<'tcx>,\n-    suggestions: BTreeMap<Span, String>,\n-}\n-\n-impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n-        Self {\n-            cx,\n-            maybe_typeck_results: cx.maybe_typeck_results(),\n-            target,\n-            suggestions: BTreeMap::new(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_body(&mut self, body: &'tcx Body<'_>) {\n-        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body.id()));\n-        walk_body(self, body);\n-        self.maybe_typeck_results = old_maybe_typeck_results;\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(ref fun, ref args) = e.kind;\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n-            if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n-            then {\n-                if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n-                    return;\n-                }\n-\n-                if match_path(ty_path, &paths::HASHMAP) {\n-                    if method.ident.name == sym::new {\n-                        self.suggestions\n-                            .insert(e.span, \"HashMap::default()\".to_string());\n-                    } else if method.ident.name == sym!(with_capacity) {\n-                        self.suggestions.insert(\n-                            e.span,\n-                            format!(\n-                                \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n-                                snippet(self.cx, args[0].span, \"capacity\"),\n-                            ),\n-                        );\n-                    }\n-                } else if match_path(ty_path, &paths::HASHSET) {\n-                    if method.ident.name == sym::new {\n-                        self.suggestions\n-                            .insert(e.span, \"HashSet::default()\".to_string());\n-                    } else if method.ident.name == sym!(with_capacity) {\n-                        self.suggestions.insert(\n-                            e.span,\n-                            format!(\n-                                \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n-                                snippet(self.cx, args[0].span, \"capacity\"),\n-                            ),\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        walk_expr(self, e);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n-    }\n+#[derive(Clone, Copy, Default)]\n+struct CheckTyContext {\n+    is_in_trait_impl: bool,\n+    is_local: bool,\n+    is_nested_call: bool,\n }"}, {"sha": "9a4e9da3e2be4cf87b7d5609146a15801c8bed1d", "filename": "clippy_lints/src/types/type_complexity.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -0,0 +1,79 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_ty, NestedVisitorMap, Visitor};\n+use rustc_hir::{GenericParamKind, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_target::spec::abi::Abi;\n+\n+use super::TYPE_COMPLEXITY;\n+\n+pub(super) fn check(cx: &LateContext<'_>, ty: &hir::Ty<'_>, type_complexity_threshold: u64) -> bool {\n+    let score = {\n+        let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n+        visitor.visit_ty(ty);\n+        visitor.score\n+    };\n+\n+    if score > type_complexity_threshold {\n+        span_lint(\n+            cx,\n+            TYPE_COMPLEXITY,\n+            ty.span,\n+            \"very complex type used. Consider factoring parts into `type` definitions\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Walks a type and assigns a complexity score to it.\n+struct TypeComplexityVisitor {\n+    /// total complexity score of the type\n+    score: u64,\n+    /// current nesting level\n+    nest: u64,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'_>) {\n+        let (add_score, sub_nest) = match ty.kind {\n+            // _, &x and *x have only small overhead; don't mess with nesting level\n+            TyKind::Infer | TyKind::Ptr(..) | TyKind::Rptr(..) => (1, 0),\n+\n+            // the \"normal\" components of a type: named types, arrays/tuples\n+            TyKind::Path(..) | TyKind::Slice(..) | TyKind::Tup(..) | TyKind::Array(..) => (10 * self.nest, 1),\n+\n+            // function types bring a lot of overhead\n+            TyKind::BareFn(ref bare) if bare.abi == Abi::Rust => (50 * self.nest, 1),\n+\n+            TyKind::TraitObject(ref param_bounds, _, _) => {\n+                let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n+                    bound\n+                        .bound_generic_params\n+                        .iter()\n+                        .any(|gen| matches!(gen.kind, GenericParamKind::Lifetime { .. }))\n+                });\n+                if has_lifetime_parameters {\n+                    // complex trait bounds like A<'a, 'b>\n+                    (50 * self.nest, 1)\n+                } else {\n+                    // simple trait bounds like A + B\n+                    (20 * self.nest, 0)\n+                }\n+            },\n+\n+            _ => (0, 0),\n+        };\n+        self.score += add_score;\n+        self.nest += sub_nest;\n+        walk_ty(self, ty);\n+        self.nest -= sub_nest;\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "2c3b25cd45e80552789e3f7c34de5cbf5fd7b43f", "filename": "tests/ui/linkedlist.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Flinkedlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Flinkedlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkedlist.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -5,6 +5,9 @@\n extern crate alloc;\n use alloc::collections::linked_list::LinkedList;\n \n+const C: LinkedList<i32> = LinkedList::new();\n+static S: LinkedList<i32> = LinkedList::new();\n+\n trait Foo {\n     type Baz = LinkedList<u8>;\n     fn foo(_: LinkedList<u8>);", "previous_filename": "tests/ui/dlist.rs"}, {"sha": "38ae71714d6624a638cdfc497e78c20667830e91", "filename": "tests/ui/linkedlist.stderr", "status": "renamed", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Flinkedlist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Flinkedlist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkedlist.stderr?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -1,51 +1,67 @@\n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:9:16\n+  --> $DIR/linkedlist.rs:8:10\n+   |\n+LL | const C: LinkedList<i32> = LinkedList::new();\n+   |          ^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::linkedlist` implied by `-D warnings`\n+   = help: a `VecDeque` might work\n+\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n+  --> $DIR/linkedlist.rs:9:11\n+   |\n+LL | static S: LinkedList<i32> = LinkedList::new();\n+   |           ^^^^^^^^^^^^^^^\n+   |\n+   = help: a `VecDeque` might work\n+\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n+  --> $DIR/linkedlist.rs:12:16\n    |\n LL |     type Baz = LinkedList<u8>;\n    |                ^^^^^^^^^^^^^^\n    |\n-   = note: `-D clippy::linkedlist` implied by `-D warnings`\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:10:15\n+  --> $DIR/linkedlist.rs:13:15\n    |\n LL |     fn foo(_: LinkedList<u8>);\n    |               ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:11:23\n+  --> $DIR/linkedlist.rs:14:23\n    |\n LL |     const BAR: Option<LinkedList<u8>>;\n    |                       ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:22:15\n+  --> $DIR/linkedlist.rs:25:15\n    |\n LL |     fn foo(_: LinkedList<u8>) {}\n    |               ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:25:39\n+  --> $DIR/linkedlist.rs:28:39\n    |\n LL | pub fn test(my_favourite_linked_list: LinkedList<u8>) {\n    |                                       ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:29:29\n+  --> $DIR/linkedlist.rs:32:29\n    |\n LL | pub fn test_ret() -> Option<LinkedList<u8>> {\n    |                             ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n ", "previous_filename": "tests/ui/dlist.stderr"}, {"sha": "2faab9e035d9977ca37ab35bc61743d287e9df14", "filename": "tests/ui/option_option.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Foption_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Foption_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_option.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -1,6 +1,9 @@\n #![deny(clippy::option_option)]\n #![allow(clippy::unnecessary_wraps)]\n \n+const C: Option<Option<i32>> = None;\n+static S: Option<Option<i32>> = None;\n+\n fn input(_: Option<Option<u8>>) {}\n \n fn output() -> Option<Option<u8>> {"}, {"sha": "a925bb35b04d891cea86f688f51ce5c9f8b3a706", "filename": "tests/ui/option_option.stderr", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Foption_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Foption_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_option.stderr?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -1,8 +1,8 @@\n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:4:13\n+  --> $DIR/option_option.rs:4:10\n    |\n-LL | fn input(_: Option<Option<u8>>) {}\n-   |             ^^^^^^^^^^^^^^^^^^\n+LL | const C: Option<Option<i32>> = None;\n+   |          ^^^^^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/option_option.rs:1:9\n@@ -11,58 +11,70 @@ LL | #![deny(clippy::option_option)]\n    |         ^^^^^^^^^^^^^^^^^^^^^\n \n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:6:16\n+  --> $DIR/option_option.rs:5:11\n+   |\n+LL | static S: Option<Option<i32>> = None;\n+   |           ^^^^^^^^^^^^^^^^^^^\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+  --> $DIR/option_option.rs:7:13\n+   |\n+LL | fn input(_: Option<Option<u8>>) {}\n+   |             ^^^^^^^^^^^^^^^^^^\n+\n+error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n+  --> $DIR/option_option.rs:9:16\n    |\n LL | fn output() -> Option<Option<u8>> {\n    |                ^^^^^^^^^^^^^^^^^^\n \n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:10:27\n+  --> $DIR/option_option.rs:13:27\n    |\n LL | fn output_nested() -> Vec<Option<Option<u8>>> {\n    |                           ^^^^^^^^^^^^^^^^^^\n \n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:15:30\n+  --> $DIR/option_option.rs:18:30\n    |\n LL | fn output_nested_nested() -> Option<Option<Option<u8>>> {\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:20:8\n+  --> $DIR/option_option.rs:23:8\n    |\n LL |     x: Option<Option<u8>>,\n    |        ^^^^^^^^^^^^^^^^^^\n \n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:24:23\n+  --> $DIR/option_option.rs:27:23\n    |\n LL |     fn struct_fn() -> Option<Option<u8>> {\n    |                       ^^^^^^^^^^^^^^^^^^\n \n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:30:22\n+  --> $DIR/option_option.rs:33:22\n    |\n LL |     fn trait_fn() -> Option<Option<u8>>;\n    |                      ^^^^^^^^^^^^^^^^^^\n \n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:34:11\n+  --> $DIR/option_option.rs:37:11\n    |\n LL |     Tuple(Option<Option<u8>>),\n    |           ^^^^^^^^^^^^^^^^^^\n \n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:35:17\n+  --> $DIR/option_option.rs:38:17\n    |\n LL |     Struct { x: Option<Option<u8>> },\n    |                 ^^^^^^^^^^^^^^^^^^\n \n error: consider using `Option<T>` instead of `Option<Option<T>>` or a custom enum if you need to distinguish all 3 cases\n-  --> $DIR/option_option.rs:76:14\n+  --> $DIR/option_option.rs:79:14\n    |\n LL |         foo: Option<Option<Cow<'a, str>>>,\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "383bbb49dbe88567b7b271fe7ce6a749b4a2c937", "filename": "tests/ui/type_complexity.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Ftype_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Ftype_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_complexity.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "previous_filename": "tests/ui/complex_types.rs"}, {"sha": "7879233fdf28373f8afb40c6eef9c8548fa94c08", "filename": "tests/ui/type_complexity.stderr", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Ftype_complexity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Ftype_complexity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_complexity.stderr?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -1,91 +1,91 @@\n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:7:12\n+  --> $DIR/type_complexity.rs:7:12\n    |\n LL | const CST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0))));\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::type-complexity` implied by `-D warnings`\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:8:12\n+  --> $DIR/type_complexity.rs:8:12\n    |\n LL | static ST: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0))));\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:11:8\n+  --> $DIR/type_complexity.rs:11:8\n    |\n LL |     f: Vec<Vec<Box<(u32, u32, u32, u32)>>>,\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:14:11\n+  --> $DIR/type_complexity.rs:14:11\n    |\n LL | struct Ts(Vec<Vec<Box<(u32, u32, u32, u32)>>>);\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:17:11\n+  --> $DIR/type_complexity.rs:17:11\n    |\n LL |     Tuple(Vec<Vec<Box<(u32, u32, u32, u32)>>>),\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:18:17\n+  --> $DIR/type_complexity.rs:18:17\n    |\n LL |     Struct { f: Vec<Vec<Box<(u32, u32, u32, u32)>>> },\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:22:14\n+  --> $DIR/type_complexity.rs:22:14\n    |\n LL |     const A: (u32, (u32, (u32, (u32, u32)))) = (0, (0, (0, (0, 0))));\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:23:30\n+  --> $DIR/type_complexity.rs:23:30\n    |\n LL |     fn impl_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:27:14\n+  --> $DIR/type_complexity.rs:27:14\n    |\n LL |     const A: Vec<Vec<Box<(u32, u32, u32, u32)>>>;\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:28:14\n+  --> $DIR/type_complexity.rs:28:14\n    |\n LL |     type B = Vec<Vec<Box<(u32, u32, u32, u32)>>>;\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:29:25\n+  --> $DIR/type_complexity.rs:29:25\n    |\n LL |     fn method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>);\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:30:29\n+  --> $DIR/type_complexity.rs:30:29\n    |\n LL |     fn def_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:33:15\n+  --> $DIR/type_complexity.rs:33:15\n    |\n LL | fn test1() -> Vec<Vec<Box<(u32, u32, u32, u32)>>> {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:37:14\n+  --> $DIR/type_complexity.rs:37:14\n    |\n LL | fn test2(_x: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/complex_types.rs:40:13\n+  --> $DIR/type_complexity.rs:40:13\n    |\n LL |     let _y: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![];\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "tests/ui/complex_types.stderr"}, {"sha": "a40d91fdb18ac15be6445c643c66645d68acbcd1", "filename": "tests/ui/vec_box_sized.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Fvec_box_sized.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Fvec_box_sized.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.fixed?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -9,6 +9,8 @@ struct BigStruct([i32; 10000]);\n /// The following should trigger the lint\n mod should_trigger {\n     use super::SizedStruct;\n+    const C: Vec<i32> = Vec::new();\n+    static S: Vec<i32> = Vec::new();\n \n     struct StructWithVecBox {\n         sized_type: Vec<SizedStruct>,"}, {"sha": "843bbb64e71904c4e121bb996b89be293e40b89d", "filename": "tests/ui/vec_box_sized.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Fvec_box_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Fvec_box_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.rs?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -9,6 +9,8 @@ struct BigStruct([i32; 10000]);\n /// The following should trigger the lint\n mod should_trigger {\n     use super::SizedStruct;\n+    const C: Vec<Box<i32>> = Vec::new();\n+    static S: Vec<Box<i32>> = Vec::new();\n \n     struct StructWithVecBox {\n         sized_type: Vec<Box<SizedStruct>>,"}, {"sha": "c518267f0418917b10b5b16a52624157ff747d9c", "filename": "tests/ui/vec_box_sized.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Fvec_box_sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd/tests%2Fui%2Fvec_box_sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.stderr?ref=2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "patch": "@@ -1,28 +1,40 @@\n error: `Vec<T>` is already on the heap, the boxing is unnecessary\n-  --> $DIR/vec_box_sized.rs:14:21\n+  --> $DIR/vec_box_sized.rs:12:14\n    |\n-LL |         sized_type: Vec<Box<SizedStruct>>,\n-   |                     ^^^^^^^^^^^^^^^^^^^^^ help: try: `Vec<SizedStruct>`\n+LL |     const C: Vec<Box<i32>> = Vec::new();\n+   |              ^^^^^^^^^^^^^ help: try: `Vec<i32>`\n    |\n    = note: `-D clippy::vec-box` implied by `-D warnings`\n \n error: `Vec<T>` is already on the heap, the boxing is unnecessary\n-  --> $DIR/vec_box_sized.rs:17:14\n+  --> $DIR/vec_box_sized.rs:13:15\n+   |\n+LL |     static S: Vec<Box<i32>> = Vec::new();\n+   |               ^^^^^^^^^^^^^ help: try: `Vec<i32>`\n+\n+error: `Vec<T>` is already on the heap, the boxing is unnecessary\n+  --> $DIR/vec_box_sized.rs:16:21\n+   |\n+LL |         sized_type: Vec<Box<SizedStruct>>,\n+   |                     ^^^^^^^^^^^^^^^^^^^^^ help: try: `Vec<SizedStruct>`\n+\n+error: `Vec<T>` is already on the heap, the boxing is unnecessary\n+  --> $DIR/vec_box_sized.rs:19:14\n    |\n LL |     struct A(Vec<Box<SizedStruct>>);\n    |              ^^^^^^^^^^^^^^^^^^^^^ help: try: `Vec<SizedStruct>`\n \n error: `Vec<T>` is already on the heap, the boxing is unnecessary\n-  --> $DIR/vec_box_sized.rs:18:18\n+  --> $DIR/vec_box_sized.rs:20:18\n    |\n LL |     struct B(Vec<Vec<Box<(u32)>>>);\n    |                  ^^^^^^^^^^^^^^^ help: try: `Vec<u32>`\n \n error: `Vec<T>` is already on the heap, the boxing is unnecessary\n-  --> $DIR/vec_box_sized.rs:46:23\n+  --> $DIR/vec_box_sized.rs:48:23\n    |\n LL |         pub fn f() -> Vec<Box<S>> {\n    |                       ^^^^^^^^^^^ help: try: `Vec<S>`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 6 previous errors\n "}]}