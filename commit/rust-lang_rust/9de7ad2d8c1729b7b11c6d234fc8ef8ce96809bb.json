{"sha": "9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZTdhZDJkOGMxNzI5YjdiMTFjNmQyMzRmYzhlZjhjZTk2ODA5YmI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-09-18T02:28:35Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-10-02T14:55:42Z"}, "message": "std: Swap {To,From}Primitive to use the 64bit as the unimplemented version\n\nOne downside with this current implementation is that since BigInt's\ndefault is now 64 bit, we can convert larger BigInt's to a primitive,\nhowever the current implementation on 32 bit architectures does not\ntake advantage of this fact.", "tree": {"sha": "431c955595157f7e0c53a77509f9827fd1bcaaa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/431c955595157f7e0c53a77509f9827fd1bcaaa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb", "html_url": "https://github.com/rust-lang/rust/commit/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a64e1a35a17c7aebd91e0d2fc9003f08fb5fd6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a64e1a35a17c7aebd91e0d2fc9003f08fb5fd6d", "html_url": "https://github.com/rust-lang/rust/commit/5a64e1a35a17c7aebd91e0d2fc9003f08fb5fd6d"}], "stats": {"total": 128, "additions": 66, "deletions": 62}, "files": [{"sha": "dd2acdb2e14ce5c97b45b31019abf96b39be4928", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb", "patch": "@@ -20,13 +20,13 @@ A `BigInt` is a combination of `BigUint` and `Sign`.\n #[allow(non_uppercase_statics)];\n \n use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n-use std::int;\n use std::num;\n use std::num::{Zero, One, ToStrRadix, FromStrRadix, Orderable};\n use std::num::{ToPrimitive, FromPrimitive};\n use std::rand::Rng;\n use std::str;\n use std::uint;\n+use std::{i64, u64};\n use std::vec;\n \n /**\n@@ -503,42 +503,42 @@ impl Integer for BigUint {\n \n impl ToPrimitive for BigUint {\n     #[inline]\n-    fn to_int(&self) -> Option<int> {\n+    fn to_i64(&self) -> Option<i64> {\n         do self.to_uint().and_then |n| {\n-            // If top bit of uint is set, it's too large to convert to\n+            // If top bit of u64 is set, it's too large to convert to\n             // int.\n             if (n >> (2*BigDigit::bits - 1) != 0) {\n                 None\n             } else {\n-                Some(n as int)\n+                Some(n as i64)\n             }\n         }\n     }\n \n     #[inline]\n-    fn to_uint(&self) -> Option<uint> {\n+    fn to_u64(&self) -> Option<u64> {\n         match self.data.len() {\n             0 => Some(0),\n-            1 => Some(self.data[0] as uint),\n-            2 => Some(BigDigit::to_uint(self.data[1], self.data[0])),\n+            1 => Some(self.data[0] as u64),\n+            2 => Some(BigDigit::to_uint(self.data[1], self.data[0]) as u64),\n             _ => None\n         }\n     }\n }\n \n impl FromPrimitive for BigUint {\n     #[inline]\n-    fn from_int(n: int) -> Option<BigUint> {\n+    fn from_i64(n: i64) -> Option<BigUint> {\n         if (n < 0) {\n             Some(Zero::zero())\n         } else {\n-            FromPrimitive::from_uint(n as uint)\n+            FromPrimitive::from_u64(n as u64)\n         }\n     }\n \n     #[inline]\n-    fn from_uint(n: uint) -> Option<BigUint> {\n-        let n = match BigDigit::from_uint(n) {\n+    fn from_u64(n: u64) -> Option<BigUint> {\n+        let n = match BigDigit::from_uint(n as uint) {\n             (0,  0)  => Zero::zero(),\n             (0,  n0) => BigUint::new(~[n0]),\n             (n1, n0) => BigUint::new(~[n0, n1])\n@@ -1083,29 +1083,29 @@ impl Integer for BigInt {\n \n impl ToPrimitive for BigInt {\n     #[inline]\n-    fn to_int(&self) -> Option<int> {\n+    fn to_i64(&self) -> Option<i64> {\n         match self.sign {\n-            Plus  => self.data.to_int(),\n+            Plus  => self.data.to_i64(),\n             Zero  => Some(0),\n             Minus => {\n-                do self.data.to_uint().and_then |n| {\n-                    let m: uint = 1 << (2*BigDigit::bits-1);\n+                do self.data.to_u64().and_then |n| {\n+                    let m: u64 = 1 << (2*BigDigit::bits-1);\n                     if (n > m) {\n                         None\n                     } else if (n == m) {\n-                        Some(int::min_value)\n+                        Some(i64::min_value)\n                     } else {\n-                        Some(-(n as int))\n+                        Some(-(n as i64))\n                     }\n                 }\n             }\n         }\n     }\n \n     #[inline]\n-    fn to_uint(&self) -> Option<uint> {\n+    fn to_u64(&self) -> Option<u64> {\n         match self.sign {\n-            Plus => self.data.to_uint(),\n+            Plus => self.data.to_u64(),\n             Zero => Some(0),\n             Minus => None\n         }\n@@ -1114,13 +1114,13 @@ impl ToPrimitive for BigInt {\n \n impl FromPrimitive for BigInt {\n     #[inline]\n-    fn from_int(n: int) -> Option<BigInt> {\n+    fn from_i64(n: i64) -> Option<BigInt> {\n         if n > 0 {\n-            do FromPrimitive::from_uint(n as uint).and_then |n| {\n+            do FromPrimitive::from_u64(n as u64).and_then |n| {\n                 Some(BigInt::from_biguint(Plus, n))\n             }\n         } else if n < 0 {\n-            do FromPrimitive::from_uint(uint::max_value - (n as uint) + 1).and_then |n| {\n+            do FromPrimitive::from_u64(u64::max_value - (n as u64) + 1).and_then |n| {\n                 Some(BigInt::from_biguint(Minus, n))\n             }\n         } else {\n@@ -1129,11 +1129,11 @@ impl FromPrimitive for BigInt {\n     }\n \n     #[inline]\n-    fn from_uint(n: uint) -> Option<BigInt> {\n+    fn from_u64(n: u64) -> Option<BigInt> {\n         if n == 0 {\n             Some(Zero::zero())\n         } else {\n-            do FromPrimitive::from_uint(n).and_then |n| {\n+            do FromPrimitive::from_u64(n).and_then |n| {\n                 Some(BigInt::from_biguint(Plus, n))\n             }\n         }"}, {"sha": "fffa9b4969946f11f36c2d19d5d22a20bf4722c0", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb", "patch": "@@ -351,65 +351,69 @@ pub trait Float: Real\n /// A generic trait for converting a value to a number.\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`.\n-    fn to_int(&self) -> Option<int>;\n+    #[inline]\n+    fn to_int(&self) -> Option<int> {\n+        // XXX: Check for range.\n+        self.to_i64().and_then(|x| Some(x as int))\n+    }\n \n     /// Converts the value of `self` to an `i8`.\n     #[inline]\n     fn to_i8(&self) -> Option<i8> {\n         // XXX: Check for range.\n-        self.to_int().and_then(|x| Some(x as i8))\n+        self.to_i64().and_then(|x| Some(x as i8))\n     }\n \n     /// Converts the value of `self` to an `i16`.\n     #[inline]\n     fn to_i16(&self) -> Option<i16> {\n         // XXX: Check for range.\n-        self.to_int().and_then(|x| Some(x as i16))\n+        self.to_i64().and_then(|x| Some(x as i16))\n     }\n \n     /// Converts the value of `self` to an `i32`.\n     #[inline]\n     fn to_i32(&self) -> Option<i32> {\n         // XXX: Check for range.\n-        self.to_int().and_then(|x| Some(x as i32))\n+        self.to_i64().and_then(|x| Some(x as i32))\n     }\n \n     /// Converts the value of `self` to an `i64`.\n+    fn to_i64(&self) -> Option<i64>;\n+\n+    /// Converts the value of `self` to an `uint`.\n     #[inline]\n-    fn to_i64(&self) -> Option<i64> {\n+    fn to_uint(&self) -> Option<uint> {\n         // XXX: Check for range.\n-        self.to_int().and_then(|x| Some(x as i64))\n+        self.to_u64().and_then(|x| Some(x as uint))\n     }\n \n-    /// Converts the value of `self` to an `uint`.\n-    fn to_uint(&self) -> Option<uint>;\n-\n     /// Converts the value of `self` to an `u8`.\n     #[inline]\n     fn to_u8(&self) -> Option<u8> {\n         // XXX: Check for range.\n-        self.to_uint().and_then(|x| Some(x as u8))\n+        self.to_u64().and_then(|x| Some(x as u8))\n     }\n \n     /// Converts the value of `self` to an `u16`.\n     #[inline]\n     fn to_u16(&self) -> Option<u16> {\n         // XXX: Check for range.\n-        self.to_uint().and_then(|x| Some(x as u16))\n+        self.to_u64().and_then(|x| Some(x as u16))\n     }\n \n     /// Converts the value of `self` to an `u32`.\n     #[inline]\n     fn to_u32(&self) -> Option<u32> {\n         // XXX: Check for range.\n-        self.to_uint().and_then(|x| Some(x as u32))\n+        self.to_u64().and_then(|x| Some(x as u32))\n     }\n \n     /// Converts the value of `self` to an `u64`.\n     #[inline]\n     fn to_u64(&self) -> Option<u64> {\n         // XXX: Check for range.\n-        self.to_uint().and_then(|x| Some(x as u64))\n+        self.to_u64().and_then(|x| Some(x as u64))\n     }\n \n     /// Converts the value of `self` to an `f32`.\n@@ -423,7 +427,7 @@ pub trait ToPrimitive {\n     #[inline]\n     fn to_f64(&self) -> Option<f64> {\n         // XXX: Check for range.\n-        self.to_float().and_then(|x| Some(x as f64))\n+        self.to_i64().and_then(|x| Some(x as f64))\n     }\n }\n \n@@ -467,80 +471,80 @@ impl_to_primitive!(float)\n pub trait FromPrimitive {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n-    fn from_int(n: int) -> Option<Self>;\n+    #[inline]\n+    fn from_int(n: int) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n \n     /// Convert an `i8` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_i8(n: i8) -> Option<Self> {\n-        FromPrimitive::from_int(n as int)\n+        FromPrimitive::from_i64(n as i64)\n     }\n \n     /// Convert an `i16` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_i16(n: i16) -> Option<Self> {\n-        FromPrimitive::from_int(n as int)\n+        FromPrimitive::from_i64(n as i64)\n     }\n \n     /// Convert an `i32` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_i32(n: i32) -> Option<Self> {\n-        FromPrimitive::from_int(n as int)\n+        FromPrimitive::from_i64(n as i64)\n     }\n \n     /// Convert an `i64` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i64(n: i64) -> Option<Self> {\n-        FromPrimitive::from_int(n as int)\n-    }\n+    fn from_i64(n: i64) -> Option<Self>;\n \n     /// Convert an `uint` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n-    fn from_uint(n: uint) -> Option<Self>;\n+    #[inline]\n+    fn from_uint(n: uint) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n \n     /// Convert an `u8` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_u8(n: u8) -> Option<Self> {\n-        FromPrimitive::from_uint(n as uint)\n+        FromPrimitive::from_u64(n as u64)\n     }\n \n     /// Convert an `u16` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_u16(n: u16) -> Option<Self> {\n-        FromPrimitive::from_uint(n as uint)\n+        FromPrimitive::from_u64(n as u64)\n     }\n \n     /// Convert an `u32` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_u32(n: u32) -> Option<Self> {\n-        FromPrimitive::from_uint(n as uint)\n+        FromPrimitive::from_u64(n as u64)\n     }\n \n     /// Convert an `u64` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u64(n: u64) -> Option<Self> {\n-        FromPrimitive::from_uint(n as uint)\n-    }\n+    fn from_u64(n: u64) -> Option<Self>;\n \n     /// Convert a `f32` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_f32(n: f32) -> Option<Self> {\n-        FromPrimitive::from_float(n as float)\n+        FromPrimitive::from_f64(n as f64)\n     }\n \n     /// Convert a `f64` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_f64(n: f64) -> Option<Self> {\n-        FromPrimitive::from_float(n as float)\n+        FromPrimitive::from_i64(n as i64)\n     }\n }\n "}, {"sha": "38c30def1d19d750c837c5b8d27fac41ce39cacd", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=9de7ad2d8c1729b7b11c6d234fc8ef8ce96809bb", "patch": "@@ -25,32 +25,32 @@ pub fn expand_deriving_from_primitive(cx: @ExtCtxt,\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n             MethodDef {\n-                name: \"from_int\",\n+                name: \"from_i64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n                 args: ~[\n-                    Literal(Path::new(~[\"int\"])),\n+                    Literal(Path::new(~[\"i64\"])),\n                 ],\n                 ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n                                            None,\n                                            ~[~Self],\n                                            true)),\n                 const_nonmatching: false,\n-                combine_substructure: |c, s, sub| cs_from(\"int\", c, s, sub),\n+                combine_substructure: |c, s, sub| cs_from(\"i64\", c, s, sub),\n             },\n             MethodDef {\n-                name: \"from_uint\",\n+                name: \"from_u64\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n                 args: ~[\n-                    Literal(Path::new(~[\"uint\"])),\n+                    Literal(Path::new(~[\"u64\"])),\n                 ],\n                 ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n                                            None,\n                                            ~[~Self],\n                                            true)),\n                 const_nonmatching: false,\n-                combine_substructure: |c, s, sub| cs_from(\"uint\", c, s, sub),\n+                combine_substructure: |c, s, sub| cs_from(\"u64\", c, s, sub),\n             },\n         ]\n     };"}]}