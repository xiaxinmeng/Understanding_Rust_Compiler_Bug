{"sha": "7656fc45cf13ade469661a11f84999b5e43e2e29", "node_id": "C_kwDOAAsO6NoAKDc2NTZmYzQ1Y2YxM2FkZTQ2OTY2MWExMWY4NDk5OWI1ZTQzZTJlMjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-11T15:02:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-11T15:02:55Z"}, "message": "Auto merge of #2222 - InfRandomness:cargo-docs, r=RalfJung\n\nAdd mandatory cargo_doc", "tree": {"sha": "bf20aace65a0e1eb15880a68703b614442cb082d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf20aace65a0e1eb15880a68703b614442cb082d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7656fc45cf13ade469661a11f84999b5e43e2e29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7656fc45cf13ade469661a11f84999b5e43e2e29", "html_url": "https://github.com/rust-lang/rust/commit/7656fc45cf13ade469661a11f84999b5e43e2e29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7656fc45cf13ade469661a11f84999b5e43e2e29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31da2d9f610ea7fc4d0ce8e5e7988b037055ca1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/31da2d9f610ea7fc4d0ce8e5e7988b037055ca1a", "html_url": "https://github.com/rust-lang/rust/commit/31da2d9f610ea7fc4d0ce8e5e7988b037055ca1a"}, {"sha": "eaa1e444eb3efa0bb4e1faf00b0ee2b4e3d8f673", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaa1e444eb3efa0bb4e1faf00b0ee2b4e3d8f673", "html_url": "https://github.com/rust-lang/rust/commit/eaa1e444eb3efa0bb4e1faf00b0ee2b4e3d8f673"}], "stats": {"total": 16, "additions": 9, "deletions": 7}, "files": [{"sha": "55da948f7b7856d497f58daf198e3de6a8846871", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7656fc45cf13ade469661a11f84999b5e43e2e29/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7656fc45cf13ade469661a11f84999b5e43e2e29/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=7656fc45cf13ade469661a11f84999b5e43e2e29", "patch": "@@ -87,7 +87,7 @@ jobs:\n         run: bash ./ci.sh\n \n   clippy:\n-    name: clippy\n+    name: clippy + rustdoc\n     runs-on: ubuntu-latest\n     steps:\n       - uses: actions/checkout@v3\n@@ -102,6 +102,8 @@ jobs:\n       #  run: cargo clippy --manifest-path ui_test/Cargo.toml --all-targets -- -D warnings\n       - name: Clippy (cargo-miri)\n         run: cargo clippy --manifest-path cargo-miri/Cargo.toml --all-targets -- -D warnings\n+      - name: Rustdoc\n+        run: RUSTDOCFLAGS=\"-Dwarnings\" cargo doc --document-private-items\n \n   fmt:\n     name: formatting (ignored by bors)"}, {"sha": "e5f58ee5ddd0bbbb991b5393d8fd56afea0ec472", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7656fc45cf13ade469661a11f84999b5e43e2e29/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7656fc45cf13ade469661a11f84999b5e43e2e29/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=7656fc45cf13ade469661a11f84999b5e43e2e29", "patch": "@@ -1,28 +1,28 @@\n //! Implementation of C++11-consistent weak memory emulation using store buffers\n //! based on Dynamic Race Detection for C++ (\"the paper\"):\n-//! https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf\n+//! <https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf>\n //!\n //! This implementation will never generate weak memory behaviours forbidden by the C++11 model,\n //! but it is incapable of producing all possible weak behaviours allowed by the model. There are\n //! certain weak behaviours observable on real hardware but not while using this.\n //!\n //! Note that this implementation does not take into account of C++20's memory model revision to SC accesses\n-//! and fences introduced by P0668 (https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html).\n+//! and fences introduced by P0668 (<https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html>).\n //! This implementation is not fully correct under the revised C++20 model and may generate behaviours C++20\n //! disallows.\n //!\n //! Rust follows the C++20 memory model (except for the Consume ordering and some operations not performable through C++'s\n //! std::atomic<T> API). It is therefore possible for this implementation to generate behaviours never observable when the\n //! same program is compiled and run natively. Unfortunately, no literature exists at the time of writing which proposes\n //! an implementable and C++20-compatible relaxed memory model that supports all atomic operation existing in Rust. The closest one is\n-//! A Promising Semantics for Relaxed-Memory Concurrency by Jeehoon Kang et al. (https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf)\n+//! A Promising Semantics for Relaxed-Memory Concurrency by Jeehoon Kang et al. (<https://www.cs.tau.ac.il/~orilahav/papers/popl17.pdf>)\n //! However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).\n //!\n //! If you find anything that proposes a relaxed memory model that is C++20-consistent, supports all orderings Rust's atomic accesses\n //! and fences accept, and is implementable (with operational semanitcs), please open a GitHub issue!\n //!\n //! One characteristic of this implementation, in contrast to some other notable operational models such as ones proposed in\n-//! Taming Release-Acquire Consistency by Ori Lahav et al. (https://plv.mpi-sws.org/sra/paper.pdf) or Promising Semantics noted above,\n+//! Taming Release-Acquire Consistency by Ori Lahav et al. (<https://plv.mpi-sws.org/sra/paper.pdf>) or Promising Semantics noted above,\n //! is that this implementation does not require each thread to hold an isolated view of the entire memory. Here, store buffers are per-location\n //! and shared across all threads. This is more memory efficient but does require store elements (representing writes to a location) to record\n //! information about reads, whereas in the other two models it is the other way round: reads points to the write it got its value from.\n@@ -38,7 +38,7 @@\n //! on the next non-atomic or imperfectly overlapping atomic access to that region.\n //! These lazy (de)allocations happen in memory_accessed() on non-atomic accesses, and\n //! get_or_create_store_buffer() on atomic accesses. This mostly works well, but it does\n-//! lead to some issues (https://github.com/rust-lang/miri/issues/2164).\n+//! lead to some issues (<https://github.com/rust-lang/miri/issues/2164>).\n //!\n //! One consequence of this difference is that safe/sound Rust allows for more operations on atomic locations\n //! than the C++20 atomic API was intended to allow, such as non-atomically accessing"}, {"sha": "db843b851e58a810075a4b938674146e78c7140c", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7656fc45cf13ade469661a11f84999b5e43e2e29/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7656fc45cf13ade469661a11f84999b5e43e2e29/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=7656fc45cf13ade469661a11f84999b5e43e2e29", "patch": "@@ -403,7 +403,7 @@ pub fn eval_entry<'tcx>(\n /// The string will be UTF-16 encoded and NUL terminated.\n ///\n /// Panics if the zeroth argument contains the `\"` character because doublequotes\n-/// in argv[0] cannot be encoded using the standard command line parsing rules.\n+/// in `argv[0]` cannot be encoded using the standard command line parsing rules.\n ///\n /// Further reading:\n /// * [Parsing C++ command-line arguments](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-160#parsing-c-command-line-arguments)"}]}