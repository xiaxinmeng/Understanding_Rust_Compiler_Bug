{"sha": "ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNzk4ZTFmN2NmYmM2ZDI3Yzg3YmIyOGUzZjFkNWI2ODAxNzk2YWE=", "commit": {"author": {"name": "Leander Tentrup", "email": "leander.tentrup@gmail.com", "date": "2020-04-17T07:37:18Z"}, "committer": {"name": "Leander Tentrup", "email": "leander.tentrup@gmail.com", "date": "2020-04-20T09:19:15Z"}, "message": "Implement syntax highlighting for format strings\n\nDetailed changes:\n1) Implement a lexer for string literals that divides the string in format specifier `{}` including the format specifier modifier.\n2) Adapt syntax highlighting to add ranges for the detected sequences.\n3) Add a test case for the format string syntax highlighting.", "tree": {"sha": "958ccd22ae5e75047b8189f69cf5878eeb9611ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/958ccd22ae5e75047b8189f69cf5878eeb9611ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa", "html_url": "https://github.com/rust-lang/rust/commit/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa/comments", "author": {"login": "ltentrup", "id": 201808, "node_id": "MDQ6VXNlcjIwMTgwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/201808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ltentrup", "html_url": "https://github.com/ltentrup", "followers_url": "https://api.github.com/users/ltentrup/followers", "following_url": "https://api.github.com/users/ltentrup/following{/other_user}", "gists_url": "https://api.github.com/users/ltentrup/gists{/gist_id}", "starred_url": "https://api.github.com/users/ltentrup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ltentrup/subscriptions", "organizations_url": "https://api.github.com/users/ltentrup/orgs", "repos_url": "https://api.github.com/users/ltentrup/repos", "events_url": "https://api.github.com/users/ltentrup/events{/privacy}", "received_events_url": "https://api.github.com/users/ltentrup/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ltentrup", "id": 201808, "node_id": "MDQ6VXNlcjIwMTgwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/201808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ltentrup", "html_url": "https://github.com/ltentrup", "followers_url": "https://api.github.com/users/ltentrup/followers", "following_url": "https://api.github.com/users/ltentrup/following{/other_user}", "gists_url": "https://api.github.com/users/ltentrup/gists{/gist_id}", "starred_url": "https://api.github.com/users/ltentrup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ltentrup/subscriptions", "organizations_url": "https://api.github.com/users/ltentrup/orgs", "repos_url": "https://api.github.com/users/ltentrup/repos", "events_url": "https://api.github.com/users/ltentrup/events{/privacy}", "received_events_url": "https://api.github.com/users/ltentrup/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29a846464b63259f5152d61a5520bffcc2cb8703", "url": "https://api.github.com/repos/rust-lang/rust/commits/29a846464b63259f5152d61a5520bffcc2cb8703", "html_url": "https://github.com/rust-lang/rust/commit/29a846464b63259f5152d61a5520bffcc2cb8703"}], "stats": {"total": 535, "additions": 532, "deletions": 3}, "files": [{"sha": "d70627da03fa88752e5a076ceef0ca1dd5760e4d", "filename": "crates/ra_ide/src/snapshots/highlight_strings.html", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html?ref=ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa", "patch": "@@ -0,0 +1,77 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.mutable            { text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+</style>\n+<pre><code><span class=\"macro\">macro_rules!</span> println {\n+    ($($arg:tt)*) =&gt; ({\n+        $<span class=\"keyword\">crate</span>::io::_print($<span class=\"keyword\">crate</span>::format_args_nl!($($arg)*));\n+    })\n+}\n+#[rustc_builtin_macro]\n+<span class=\"macro\">macro_rules!</span> format_args_nl {\n+    ($fmt:expr) =&gt; {{ <span class=\"comment\">/* compiler built-in */</span> }};\n+    ($fmt:expr, $($args:tt)*) =&gt; {{ <span class=\"comment\">/* compiler built-in */</span> }};\n+}\n+\n+<span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span>() {\n+    <span class=\"comment\">// from https://doc.rust-lang.org/std/fmt/index.html</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello\"</span>);                 <span class=\"comment\">// =&gt; \"Hello\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello, </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"world\"</span>);   <span class=\"comment\">// =&gt; \"Hello, world!\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"The number is </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>);   <span class=\"comment\">// =&gt; \"The number is 1\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">?</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, (<span class=\"numeric_literal\">3</span>, <span class=\"numeric_literal\">4</span>));          <span class=\"comment\">// =&gt; \"(3, 4)\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">value</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, value=<span class=\"numeric_literal\">4</span>);      <span class=\"comment\">// =&gt; \"4\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>, <span class=\"numeric_literal\">2</span>);           <span class=\"comment\">// =&gt; \"1 2\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">4</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">42</span>);             <span class=\"comment\">// =&gt; \"0042\" with leading zerosV</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>, <span class=\"numeric_literal\">2</span>);   <span class=\"comment\">// =&gt; \"2 1 1 2\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">argument</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, argument = <span class=\"string_literal\">\"test\"</span>);   <span class=\"comment\">// =&gt; \"test\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">name</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>, name = <span class=\"numeric_literal\">2</span>);          <span class=\"comment\">// =&gt; \"2 1\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">a</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"variable\">c</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"variable\">b</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, a=<span class=\"string_literal\">\"a\"</span>, b=<span class=\"char_literal\">'b'</span>, c=<span class=\"numeric_literal\">3</span>);  <span class=\"comment\">// =&gt; \"a 3 b\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"variable\">width</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>, width = <span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">&lt;</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">-</span><span class=\"attribute\">&lt;</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">^</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">&gt;</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">+</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">#</span><span class=\"variable\">x</span><span class=\"string_literal\">}!\"</span>, <span class=\"numeric_literal\">27</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, -<span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">#</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">10</span><span class=\"variable\">x</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">27</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">2</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">2</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>,    <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">2</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>,   <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"variable\">number</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"variable\">prec</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"string_literal\">\"x\"</span>, prec = <span class=\"numeric_literal\">5</span>, number = <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">, `</span><span class=\"attribute\">{</span><span class=\"variable\">name</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">` has 3 fractional digits\"</span>, <span class=\"string_literal\">\"Hello\"</span>, <span class=\"numeric_literal\">3</span>, name=<span class=\"numeric_literal\">1234.56</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">, `</span><span class=\"attribute\">{</span><span class=\"variable\">name</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">` has 3 characters\"</span>, <span class=\"string_literal\">\"Hello\"</span>, <span class=\"numeric_literal\">3</span>, name=<span class=\"string_literal\">\"1234.56\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">, `</span><span class=\"attribute\">{</span><span class=\"variable\">name</span><span class=\"attribute\">:</span><span class=\"attribute\">&gt;</span><span class=\"numeric_literal\">8</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">` has 3 right-aligned characters\"</span>, <span class=\"string_literal\">\"Hello\"</span>, <span class=\"numeric_literal\">3</span>, name=<span class=\"string_literal\">\"1234.56\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello {{}}\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"{{ Hello\"</span>);\n+}</code></pre>\n\\ No newline at end of file"}, {"sha": "e342ca9dfd04603cccbc4150fc14ef2a3302ece2", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa", "patch": "@@ -12,7 +12,7 @@ use ra_ide_db::{\n };\n use ra_prof::profile;\n use ra_syntax::{\n-    ast::{self, HasQuotes, HasStringValue},\n+    ast::{self, HasFormatSpecifier, HasQuotes, HasStringValue},\n     AstNode, AstToken, Direction, NodeOrToken, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxToken, TextRange, WalkEvent, T,\n@@ -21,6 +21,7 @@ use rustc_hash::FxHashMap;\n \n use crate::{call_info::call_info_for_token, Analysis, FileId};\n \n+use ast::FormatSpecifier;\n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n \n@@ -95,7 +96,8 @@ impl HighlightedRangeStack {\n             1,\n             \"after DFS traversal, the stack should only contain a single element\"\n         );\n-        let res = self.stack.pop().unwrap();\n+        let mut res = self.stack.pop().unwrap();\n+        res.sort_by_key(|range| range.range.start());\n         // Check that ranges are sorted and disjoint\n         assert!(res\n             .iter()\n@@ -134,6 +136,7 @@ pub(crate) fn highlight(\n     let mut stack = HighlightedRangeStack::new();\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n+    let mut format_string: Option<SyntaxElement> = None;\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n@@ -169,6 +172,7 @@ pub(crate) fn highlight(\n             WalkEvent::Leave(Some(mc)) => {\n                 assert!(current_macro_call == Some(mc));\n                 current_macro_call = None;\n+                format_string = None;\n                 continue;\n             }\n             _ => (),\n@@ -189,6 +193,30 @@ pub(crate) fn highlight(\n             };\n             let token = sema.descend_into_macros(token.clone());\n             let parent = token.parent();\n+\n+            // Check if macro takes a format string and remeber it for highlighting later.\n+            // The macros that accept a format string expand to a compiler builtin macros\n+            // `format_args` and `format_args_nl`.\n+            if let Some(fmt_macro_call) = parent.parent().and_then(ast::MacroCall::cast) {\n+                if let Some(name) =\n+                    fmt_macro_call.path().and_then(|p| p.segment()).and_then(|s| s.name_ref())\n+                {\n+                    match name.text().as_str() {\n+                        \"format_args\" | \"format_args_nl\" => {\n+                            format_string = parent\n+                                .children_with_tokens()\n+                                .filter(|t| t.kind() != WHITESPACE)\n+                                .nth(1)\n+                                .filter(|e| {\n+                                    ast::String::can_cast(e.kind())\n+                                        || ast::RawString::can_cast(e.kind())\n+                                })\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n             // We only care Name and Name_ref\n             match (token.kind(), parent.kind()) {\n                 (IDENT, NAME) | (IDENT, NAME_REF) => parent.into(),\n@@ -205,10 +233,45 @@ pub(crate) fn highlight(\n             }\n         }\n \n+        let is_format_string =\n+            format_string.as_ref().map(|fs| fs == &element_to_highlight).unwrap_or_default();\n+\n         if let Some((highlight, binding_hash)) =\n-            highlight_element(&sema, &mut bindings_shadow_count, element_to_highlight)\n+            highlight_element(&sema, &mut bindings_shadow_count, element_to_highlight.clone())\n         {\n             stack.add(HighlightedRange { range, highlight, binding_hash });\n+            if let Some(string) =\n+                element_to_highlight.as_token().cloned().and_then(ast::String::cast)\n+            {\n+                stack.push();\n+                if is_format_string {\n+                    string.lex_format_specifier(&mut |piece_range, kind| {\n+                        let highlight = match kind {\n+                            FormatSpecifier::Open\n+                            | FormatSpecifier::Close\n+                            | FormatSpecifier::Colon\n+                            | FormatSpecifier::Fill\n+                            | FormatSpecifier::Align\n+                            | FormatSpecifier::Sign\n+                            | FormatSpecifier::NumberSign\n+                            | FormatSpecifier::DollarSign\n+                            | FormatSpecifier::Dot\n+                            | FormatSpecifier::Asterisk\n+                            | FormatSpecifier::QuestionMark => HighlightTag::Attribute,\n+                            FormatSpecifier::Integer | FormatSpecifier::Zero => {\n+                                HighlightTag::NumericLiteral\n+                            }\n+                            FormatSpecifier::Identifier => HighlightTag::Local,\n+                        };\n+                        stack.add(HighlightedRange {\n+                            range: piece_range + range.start(),\n+                            highlight: highlight.into(),\n+                            binding_hash: None,\n+                        });\n+                    });\n+                }\n+                stack.pop();\n+            }\n         }\n     }\n "}, {"sha": "f198767ce1f6c9b3819136e80a4ee193c49fa44b", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa", "patch": "@@ -168,3 +168,68 @@ macro_rules! test {}\n     );\n     let _ = analysis.highlight(file_id).unwrap();\n }\n+\n+#[test]\n+fn test_string_highlighting() {\n+    // The format string detection is based on macro-expansion,\n+    // thus, we have to copy the macro definition from `std`\n+    let (analysis, file_id) = single_file(\n+        r#\"\n+macro_rules! println {\n+    ($($arg:tt)*) => ({\n+        $crate::io::_print($crate::format_args_nl!($($arg)*));\n+    })\n+}\n+#[rustc_builtin_macro]\n+macro_rules! format_args_nl {\n+    ($fmt:expr) => {{ /* compiler built-in */ }};\n+    ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n+}\n+\n+fn main() {\n+    // from https://doc.rust-lang.org/std/fmt/index.html\n+    println!(\"Hello\");                 // => \"Hello\"\n+    println!(\"Hello, {}!\", \"world\");   // => \"Hello, world!\"\n+    println!(\"The number is {}\", 1);   // => \"The number is 1\"\n+    println!(\"{:?}\", (3, 4));          // => \"(3, 4)\"\n+    println!(\"{value}\", value=4);      // => \"4\"\n+    println!(\"{} {}\", 1, 2);           // => \"1 2\"\n+    println!(\"{:04}\", 42);             // => \"0042\" with leading zerosV\n+    println!(\"{1} {} {0} {}\", 1, 2);   // => \"2 1 1 2\"\n+    println!(\"{argument}\", argument = \"test\");   // => \"test\"\n+    println!(\"{name} {}\", 1, name = 2);          // => \"2 1\"\n+    println!(\"{a} {c} {b}\", a=\"a\", b='b', c=3);  // => \"a 3 b\"\n+    println!(\"Hello {:5}!\", \"x\");\n+    println!(\"Hello {:1$}!\", \"x\", 5);\n+    println!(\"Hello {1:0$}!\", 5, \"x\");\n+    println!(\"Hello {:width$}!\", \"x\", width = 5);\n+    println!(\"Hello {:<5}!\", \"x\");\n+    println!(\"Hello {:-<5}!\", \"x\");\n+    println!(\"Hello {:^5}!\", \"x\");\n+    println!(\"Hello {:>5}!\", \"x\");\n+    println!(\"Hello {:+}!\", 5);\n+    println!(\"{:#x}!\", 27);\n+    println!(\"Hello {:05}!\", 5);\n+    println!(\"Hello {:05}!\", -5);\n+    println!(\"{:#010x}!\", 27);\n+    println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n+    println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n+    println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n+    println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n+    println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+    println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n+    println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n+    println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+    println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n+    println!(\"Hello {{}}\");\n+    println!(\"{{ Hello\");\n+}\"#\n+        .trim(),\n+    );\n+\n+    let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlight_strings.html\");\n+    let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n+    let expected_html = &read_text(&dst_file);\n+    fs::write(dst_file, &actual_html).unwrap();\n+    assert_eq_text!(expected_html, actual_html);\n+}"}, {"sha": "ec3b4e55386c1d7cf89e204af2e1768407beddad", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=ac798e1f7cfbc6d27c87bb28e3f1d5b6801796aa", "patch": "@@ -172,3 +172,327 @@ impl RawString {\n         Some(range + contents_range.start())\n     }\n }\n+\n+#[derive(Debug)]\n+pub enum FormatSpecifier {\n+    Open,\n+    Close,\n+    Integer,\n+    Identifier,\n+    Colon,\n+    Fill,\n+    Align,\n+    Sign,\n+    NumberSign,\n+    Zero,\n+    DollarSign,\n+    Dot,\n+    Asterisk,\n+    QuestionMark,\n+}\n+\n+pub trait HasFormatSpecifier: AstToken {\n+    fn lex_format_specifier<F>(&self, callback: &mut F)\n+    where\n+        F: FnMut(TextRange, FormatSpecifier),\n+    {\n+        let src = self.text().as_str();\n+        let initial_len = src.len();\n+        let mut chars = src.chars();\n+\n+        while let Some(first_char) = chars.next() {\n+            match first_char {\n+                '{' => {\n+                    // Format specifier, see syntax at https://doc.rust-lang.org/std/fmt/index.html#syntax\n+                    if chars.clone().next() == Some('{') {\n+                        // Escaped format specifier, `{{`\n+                        chars.next();\n+                        continue;\n+                    }\n+\n+                    let start = initial_len - chars.as_str().len() - first_char.len_utf8();\n+                    let end = initial_len - chars.as_str().len();\n+                    callback(\n+                        TextRange::from_to(TextUnit::from_usize(start), TextUnit::from_usize(end)),\n+                        FormatSpecifier::Open,\n+                    );\n+\n+                    let next_char = if let Some(c) = chars.clone().next() {\n+                        c\n+                    } else {\n+                        break;\n+                    };\n+\n+                    // check for integer/identifier\n+                    match next_char {\n+                        '0'..='9' => {\n+                            // integer\n+                            read_integer(&mut chars, initial_len, callback);\n+                        }\n+                        'a'..='z' | 'A'..='Z' | '_' => {\n+                            // identifier\n+                            read_identifier(&mut chars, initial_len, callback);\n+                        }\n+                        _ => {}\n+                    }\n+\n+                    if chars.clone().next() == Some(':') {\n+                        skip_char_and_emit(\n+                            &mut chars,\n+                            initial_len,\n+                            FormatSpecifier::Colon,\n+                            callback,\n+                        );\n+\n+                        // check for fill/align\n+                        let mut cloned = chars.clone().take(2);\n+                        let first = cloned.next().unwrap_or_default();\n+                        let second = cloned.next().unwrap_or_default();\n+                        match second {\n+                            '<' | '^' | '>' => {\n+                                // alignment specifier, first char specifies fillment\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    initial_len,\n+                                    FormatSpecifier::Fill,\n+                                    callback,\n+                                );\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    initial_len,\n+                                    FormatSpecifier::Align,\n+                                    callback,\n+                                );\n+                            }\n+                            _ => match first {\n+                                '<' | '^' | '>' => {\n+                                    skip_char_and_emit(\n+                                        &mut chars,\n+                                        initial_len,\n+                                        FormatSpecifier::Align,\n+                                        callback,\n+                                    );\n+                                }\n+                                _ => {}\n+                            },\n+                        }\n+\n+                        // check for sign\n+                        match chars.clone().next().unwrap_or_default() {\n+                            '+' | '-' => {\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    initial_len,\n+                                    FormatSpecifier::Sign,\n+                                    callback,\n+                                );\n+                            }\n+                            _ => {}\n+                        }\n+\n+                        // check for `#`\n+                        if let Some('#') = chars.clone().next() {\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                initial_len,\n+                                FormatSpecifier::NumberSign,\n+                                callback,\n+                            );\n+                        }\n+\n+                        // check for `0`\n+                        let mut cloned = chars.clone().take(2);\n+                        let first = cloned.next();\n+                        let second = cloned.next();\n+\n+                        if first == Some('0') && second != Some('$') {\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                initial_len,\n+                                FormatSpecifier::Zero,\n+                                callback,\n+                            );\n+                        }\n+\n+                        // width\n+                        match chars.clone().next().unwrap_or_default() {\n+                            '0'..='9' => {\n+                                read_integer(&mut chars, initial_len, callback);\n+                                if chars.clone().next() == Some('$') {\n+                                    skip_char_and_emit(\n+                                        &mut chars,\n+                                        initial_len,\n+                                        FormatSpecifier::DollarSign,\n+                                        callback,\n+                                    );\n+                                }\n+                            }\n+                            'a'..='z' | 'A'..='Z' | '_' => {\n+                                read_identifier(&mut chars, initial_len, callback);\n+                                if chars.clone().next() != Some('$') {\n+                                    continue;\n+                                }\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    initial_len,\n+                                    FormatSpecifier::DollarSign,\n+                                    callback,\n+                                );\n+                            }\n+                            _ => {}\n+                        }\n+\n+                        // precision\n+                        if chars.clone().next() == Some('.') {\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                initial_len,\n+                                FormatSpecifier::Dot,\n+                                callback,\n+                            );\n+\n+                            match chars.clone().next().unwrap_or_default() {\n+                                '*' => {\n+                                    skip_char_and_emit(\n+                                        &mut chars,\n+                                        initial_len,\n+                                        FormatSpecifier::Asterisk,\n+                                        callback,\n+                                    );\n+                                }\n+                                '0'..='9' => {\n+                                    read_integer(&mut chars, initial_len, callback);\n+                                    if chars.clone().next() == Some('$') {\n+                                        skip_char_and_emit(\n+                                            &mut chars,\n+                                            initial_len,\n+                                            FormatSpecifier::DollarSign,\n+                                            callback,\n+                                        );\n+                                    }\n+                                }\n+                                'a'..='z' | 'A'..='Z' | '_' => {\n+                                    read_identifier(&mut chars, initial_len, callback);\n+                                    if chars.clone().next() != Some('$') {\n+                                        continue;\n+                                    }\n+                                    skip_char_and_emit(\n+                                        &mut chars,\n+                                        initial_len,\n+                                        FormatSpecifier::DollarSign,\n+                                        callback,\n+                                    );\n+                                }\n+                                _ => {\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+\n+                        // type\n+                        match chars.clone().next().unwrap_or_default() {\n+                            '?' => {\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    initial_len,\n+                                    FormatSpecifier::QuestionMark,\n+                                    callback,\n+                                );\n+                            }\n+                            'a'..='z' | 'A'..='Z' | '_' => {\n+                                read_identifier(&mut chars, initial_len, callback);\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+\n+                    let mut cloned = chars.clone().take(2);\n+                    let first = cloned.next();\n+                    let second = cloned.next();\n+                    if first != Some('}') {\n+                        continue;\n+                    }\n+                    if second == Some('}') {\n+                        // Escaped format end specifier, `}}`\n+                        continue;\n+                    }\n+                    skip_char_and_emit(&mut chars, initial_len, FormatSpecifier::Close, callback);\n+                }\n+                _ => {\n+                    while let Some(next_char) = chars.clone().next() {\n+                        match next_char {\n+                            '{' => break,\n+                            _ => {}\n+                        }\n+                        chars.next();\n+                    }\n+                }\n+            };\n+        }\n+\n+        fn skip_char_and_emit<F>(\n+            chars: &mut std::str::Chars,\n+            initial_len: usize,\n+            emit: FormatSpecifier,\n+            callback: &mut F,\n+        ) where\n+            F: FnMut(TextRange, FormatSpecifier),\n+        {\n+            let start = initial_len - chars.as_str().len();\n+            chars.next();\n+            let end = initial_len - chars.as_str().len();\n+            callback(\n+                TextRange::from_to(TextUnit::from_usize(start), TextUnit::from_usize(end)),\n+                emit,\n+            );\n+        }\n+\n+        fn read_integer<F>(chars: &mut std::str::Chars, initial_len: usize, callback: &mut F)\n+        where\n+            F: FnMut(TextRange, FormatSpecifier),\n+        {\n+            let start = initial_len - chars.as_str().len();\n+            chars.next();\n+            while let Some(next_char) = chars.clone().next() {\n+                match next_char {\n+                    '0'..='9' => {\n+                        chars.next();\n+                    }\n+                    _ => {\n+                        break;\n+                    }\n+                }\n+            }\n+            let end = initial_len - chars.as_str().len();\n+            callback(\n+                TextRange::from_to(TextUnit::from_usize(start), TextUnit::from_usize(end)),\n+                FormatSpecifier::Integer,\n+            );\n+        }\n+        fn read_identifier<F>(chars: &mut std::str::Chars, initial_len: usize, callback: &mut F)\n+        where\n+            F: FnMut(TextRange, FormatSpecifier),\n+        {\n+            let start = initial_len - chars.as_str().len();\n+            chars.next();\n+            while let Some(next_char) = chars.clone().next() {\n+                match next_char {\n+                    'a'..='z' | 'A'..='Z' | '0'..='9' | '_' => {\n+                        chars.next();\n+                    }\n+                    _ => {\n+                        break;\n+                    }\n+                }\n+            }\n+            let end = initial_len - chars.as_str().len();\n+            callback(\n+                TextRange::from_to(TextUnit::from_usize(start), TextUnit::from_usize(end)),\n+                FormatSpecifier::Identifier,\n+            );\n+        }\n+    }\n+}\n+\n+impl HasFormatSpecifier for String {}\n+impl HasFormatSpecifier for RawString {}"}]}