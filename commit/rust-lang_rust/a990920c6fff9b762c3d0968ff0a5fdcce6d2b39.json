{"sha": "a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5OTA5MjBjNmZmZjliNzYyYzNkMDk2OGZmMGE1ZmRjY2U2ZDJiMzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-09T04:01:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-09T04:01:42Z"}, "message": "auto merge of #13963 : kballard/rust/remove_owned_vec_from_iterator, r=pcwalton\n\nWith `~[T]` no longer growable, the `FromIterator` impl for `~[T]` doesn't make\r\nmuch sense. Not only that, but nearly everywhere it is used is to convert from\r\na `Vec<T>` into a `~[T]`, for the sake of maintaining existing APIs. This turns\r\nout to be a performance loss, as it means every API that returns `~[T]`, even a\r\nsupposedly non-copying one, is in fact doing extra allocations and memcpy's.\r\nEven `&[T].to_owned()` is going through `Vec<T>` first.\r\n\r\nRemove the `FromIterator` impl for `~[T]`, and adjust all the APIs that relied\r\non it to start using `Vec<T>` instead. This includes rewriting\r\n`&[T].to_owned()` to be more efficient, among other performance wins.\r\n\r\nAlso add a new mechanism to go from `Vec<T>` -> `~[T]`, just in case anyone\r\ntruly needs that, using the new trait `FromVec`.\r\n\r\n[breaking-change]", "tree": {"sha": "8b4cb2edb2e48660ca6e6c0f6a660951f00c1e02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b4cb2edb2e48660ca6e6c0f6a660951f00c1e02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "html_url": "https://github.com/rust-lang/rust/commit/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0a25e4fdc1fcdde8378b4177a6f06c58001a3be", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a25e4fdc1fcdde8378b4177a6f06c58001a3be", "html_url": "https://github.com/rust-lang/rust/commit/c0a25e4fdc1fcdde8378b4177a6f06c58001a3be"}, {"sha": "dc30c483810ca0ee3641f4bab8e6f2a44a883fee", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc30c483810ca0ee3641f4bab8e6f2a44a883fee", "html_url": "https://github.com/rust-lang/rust/commit/dc30c483810ca0ee3641f4bab8e6f2a44a883fee"}], "stats": {"total": 1556, "additions": 829, "deletions": 727}, "files": [{"sha": "cea440afd9028592d728d41d504e05726f41dc70", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -997,7 +997,7 @@ fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n fn make_exe_name(config: &config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n     if !os::consts::EXE_SUFFIX.is_empty() {\n-        match f.filename().map(|s| s + os::consts::EXE_SUFFIX.as_bytes()) {\n+        match f.filename().map(|s| Vec::from_slice(s).append(os::consts::EXE_SUFFIX.as_bytes())) {\n             Some(v) => f.set_filename(v),\n             None => ()\n         }\n@@ -1091,7 +1091,7 @@ fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n \n fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    match f.filename().map(|s| s + bytes!(\".libaux\")) {\n+    match f.filename().map(|s| Vec::from_slice(s).append(bytes!(\".libaux\"))) {\n         Some(v) => f.set_filename(v),\n         None => ()\n     }\n@@ -1273,7 +1273,7 @@ fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n         (*p).clone()\n     } else {\n         let stem = p.filestem().unwrap();\n-        p.with_filename(stem + bytes!(\"-\") + suffix.as_bytes())\n+        p.with_filename(Vec::from_slice(stem).append(bytes!(\"-\")).append(suffix.as_bytes()))\n     }\n }\n "}, {"sha": "1ab92d453785e41f1fe4f2b80ea3edf801e22408", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -266,8 +266,8 @@ Iterators offer generic conversion to containers with the `collect` adaptor:\n \n ~~~\n let xs = [0, 1, 1, 2, 3, 5, 8];\n-let ys = xs.iter().rev().skip(1).map(|&x| x * 2).collect::<~[int]>();\n-assert_eq!(ys, ~[10, 6, 4, 2, 2, 0]);\n+let ys = xs.iter().rev().skip(1).map(|&x| x * 2).collect::<Vec<int>>();\n+assert_eq!(ys, vec![10, 6, 4, 2, 2, 0]);\n ~~~\n \n The method requires a type hint for the container type, if the surrounding code\n@@ -278,14 +278,14 @@ implementing the `FromIterator` trait. For example, the implementation for\n vectors is as follows:\n \n ~~~ {.ignore}\n-impl<A> FromIterator<A> for ~[A] {\n-    pub fn from_iter<T: Iterator<A>>(iterator: &mut T) -> ~[A] {\n+impl<T> FromIterator<T> for Vec<T> {\n+    fn from_iter<I:Iterator<A>>(mut iterator: I) -> Vec<T> {\n         let (lower, _) = iterator.size_hint();\n-        let mut xs = with_capacity(lower);\n-        for x in iterator {\n-            xs.push(x);\n+        let mut vector = Vec::with_capacity(lower);\n+        for element in iterator {\n+            vector.push(element);\n         }\n-        xs\n+        vector\n     }\n }\n ~~~"}, {"sha": "e4c95538d3012199035ed6530b8f5f212b31539e", "filename": "src/doc/rust.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -3598,18 +3598,18 @@ and the cast expression in `main`.\n Within the body of an item that has type parameter declarations, the names of its type parameters are types:\n \n ~~~~\n-fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> ~[B] {\n+fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n     if xs.len() == 0 {\n-       return ~[];\n+       return vec![];\n     }\n     let first: B = f(xs[0].clone());\n-    let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n-    return ~[first] + rest;\n+    let rest: Vec<B> = map(f, xs.slice(1, xs.len()));\n+    return vec![first].append(rest.as_slice());\n }\n ~~~~\n \n Here, `first` has type `B`, referring to `map`'s `B` type parameter;\n-and `rest` has type `~[B]`, a vector type with element type `B`.\n+and `rest` has type `Vec<B>`, a vector type with element type `B`.\n \n ### Self types\n "}, {"sha": "9b9153fe579462b47a9080e71c2743b9d6ebaa4c", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -1588,8 +1588,8 @@ let mut numbers = vec![1, 2, 3];\n numbers.push(4);\n numbers.push(5);\n \n-// The type of a unique vector is written as `~[int]`\n-let more_numbers: ~[int] = numbers.move_iter().collect();\n+// The type of a unique vector is written as `Vec<int>`\n+let more_numbers: Vec<int> = numbers.move_iter().map(|i| i+1).collect();\n \n // The original `numbers` value can no longer be used, due to move semantics.\n \n@@ -1633,7 +1633,7 @@ view[0] = 5;\n let ys: &mut [int] = &mut [1, 2, 3];\n ~~~\n \n-Square brackets denote indexing into a vector:\n+Square brackets denote indexing into a slice or fixed-size vector:\n \n ~~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n@@ -1647,7 +1647,7 @@ match crayons[0] {\n }\n ~~~~\n \n-A vector can be destructured using pattern matching:\n+A slice or fixed-size vector can be destructured using pattern matching:\n \n ~~~~\n let numbers: &[int] = &[1, 2, 3];\n@@ -1660,9 +1660,10 @@ let score = match numbers {\n ~~~~\n \n Both vectors and strings support a number of useful [methods](#methods),\n-defined in [`std::vec`] and [`std::str`].\n+defined in [`std::vec`], [`std::slice`], and [`std::str`].\n \n [`std::vec`]: std/vec/index.html\n+[`std::slice`]: std/slice/index.html\n [`std::str`]: std/str/index.html\n \n # Ownership escape hatches"}, {"sha": "10ae30cf39d0cc08628657bd80f9269459492071", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -455,8 +455,8 @@ pub trait Iterator<A> {\n     ///\n     /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n-    /// let b: ~[int] = a.iter().map(|&x| x).collect();\n-    /// assert!(a == b);\n+    /// let b: Vec<int> = a.iter().map(|&x| x).collect();\n+    /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n     #[inline]\n     fn collect<B: FromIterator<A>>(&mut self) -> B {\n@@ -2340,8 +2340,8 @@ mod tests {\n     #[test]\n     fn test_counter_from_iter() {\n         let it = count(0, 5).take(10);\n-        let xs: ~[int] = FromIterator::from_iter(it);\n-        assert_eq!(xs, box [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+        let xs: Vec<int> = FromIterator::from_iter(it);\n+        assert_eq!(xs, vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n \n     #[test]\n@@ -2371,7 +2371,7 @@ mod tests {\n     fn test_filter_map() {\n         let mut it = count(0u, 1u).take(10)\n             .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-        assert_eq!(it.collect::<~[uint]>(), box [0*0, 2*2, 4*4, 6*6, 8*8]);\n+        assert_eq!(it.collect::<Vec<uint>>(), vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n \n     #[test]\n@@ -2493,7 +2493,7 @@ mod tests {\n         let ys = xs.iter()\n                    .map(|&x| x)\n                    .inspect(|_| n += 1)\n-                   .collect::<~[uint]>();\n+                   .collect::<Vec<uint>>();\n \n         assert_eq!(n, xs.len());\n         assert_eq!(xs.as_slice(), ys.as_slice());\n@@ -2628,8 +2628,8 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let a = box [1, 2, 3, 4, 5];\n-        let b: ~[int] = a.iter().map(|&x| x).collect();\n+        let a = vec![1, 2, 3, 4, 5];\n+        let b: Vec<int> = a.iter().map(|&x| x).collect();\n         assert_eq!(a, b);\n     }\n \n@@ -2702,7 +2702,7 @@ mod tests {\n         let mut it = xs.iter();\n         it.next();\n         it.next();\n-        assert_eq!(it.rev().map(|&x| x).collect::<~[int]>(), box [16, 14, 12, 10, 8, 6]);\n+        assert_eq!(it.rev().map(|&x| x).collect::<Vec<int>>(), vec![16, 14, 12, 10, 8, 6]);\n     }\n \n     #[test]\n@@ -2940,12 +2940,12 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_range() {\n-        assert_eq!(range(11i, 14).rev().collect::<~[int]>(), box [13i, 12, 11]);\n+        assert_eq!(range(11i, 14).rev().collect::<Vec<int>>(), vec![13i, 12, 11]);\n         for _ in range(10i, 0).rev() {\n             fail!(\"unreachable\");\n         }\n \n-        assert_eq!(range(11u, 14).rev().collect::<~[uint]>(), box [13u, 12, 11]);\n+        assert_eq!(range(11u, 14).rev().collect::<Vec<uint>>(), vec![13u, 12, 11]);\n         for _ in range(10u, 0).rev() {\n             fail!(\"unreachable\");\n         }\n@@ -2997,13 +2997,14 @@ mod tests {\n             }\n         }\n \n-        assert_eq!(range(0i, 5).collect::<~[int]>(), box [0i, 1, 2, 3, 4]);\n-        assert_eq!(range(-10i, -1).collect::<~[int]>(), box [-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-        assert_eq!(range(0i, 5).rev().collect::<~[int]>(), box [4, 3, 2, 1, 0]);\n-        assert_eq!(range(200, -5).collect::<~[int]>(), box []);\n-        assert_eq!(range(200, -5).rev().collect::<~[int]>(), box []);\n-        assert_eq!(range(200, 200).collect::<~[int]>(), box []);\n-        assert_eq!(range(200, 200).rev().collect::<~[int]>(), box []);\n+        assert_eq!(range(0i, 5).collect::<Vec<int>>(), vec![0i, 1, 2, 3, 4]);\n+        assert_eq!(range(-10i, -1).collect::<Vec<int>>(),\n+                   vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n+        assert_eq!(range(0i, 5).rev().collect::<Vec<int>>(), vec![4, 3, 2, 1, 0]);\n+        assert_eq!(range(200, -5).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range(200, -5).rev().collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range(200, 200).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range(200, 200).rev().collect::<Vec<int>>(), vec![]);\n \n         assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n         // this test is only meaningful when sizeof uint < sizeof u64\n@@ -3014,32 +3015,32 @@ mod tests {\n \n     #[test]\n     fn test_range_inclusive() {\n-        assert_eq!(range_inclusive(0i, 5).collect::<~[int]>(), box [0i, 1, 2, 3, 4, 5]);\n-        assert_eq!(range_inclusive(0i, 5).rev().collect::<~[int]>(), box [5i, 4, 3, 2, 1, 0]);\n-        assert_eq!(range_inclusive(200, -5).collect::<~[int]>(), box []);\n-        assert_eq!(range_inclusive(200, -5).rev().collect::<~[int]>(), box []);\n-        assert_eq!(range_inclusive(200, 200).collect::<~[int]>(), box [200]);\n-        assert_eq!(range_inclusive(200, 200).rev().collect::<~[int]>(), box [200]);\n+        assert_eq!(range_inclusive(0i, 5).collect::<Vec<int>>(), vec![0i, 1, 2, 3, 4, 5]);\n+        assert_eq!(range_inclusive(0i, 5).rev().collect::<Vec<int>>(), vec![5i, 4, 3, 2, 1, 0]);\n+        assert_eq!(range_inclusive(200, -5).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range_inclusive(200, -5).rev().collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range_inclusive(200, 200).collect::<Vec<int>>(), vec![200]);\n+        assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<int>>(), vec![200]);\n     }\n \n     #[test]\n     fn test_range_step() {\n-        assert_eq!(range_step(0i, 20, 5).collect::<~[int]>(), box [0, 5, 10, 15]);\n-        assert_eq!(range_step(20i, 0, -5).collect::<~[int]>(), box [20, 15, 10, 5]);\n-        assert_eq!(range_step(20i, 0, -6).collect::<~[int]>(), box [20, 14, 8, 2]);\n-        assert_eq!(range_step(200u8, 255, 50).collect::<~[u8]>(), box [200u8, 250]);\n-        assert_eq!(range_step(200, -5, 1).collect::<~[int]>(), box []);\n-        assert_eq!(range_step(200, 200, 1).collect::<~[int]>(), box []);\n+        assert_eq!(range_step(0i, 20, 5).collect::<Vec<int>>(), vec![0, 5, 10, 15]);\n+        assert_eq!(range_step(20i, 0, -5).collect::<Vec<int>>(), vec![20, 15, 10, 5]);\n+        assert_eq!(range_step(20i, 0, -6).collect::<Vec<int>>(), vec![20, 14, 8, 2]);\n+        assert_eq!(range_step(200u8, 255, 50).collect::<Vec<u8>>(), vec![200u8, 250]);\n+        assert_eq!(range_step(200, -5, 1).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range_step(200, 200, 1).collect::<Vec<int>>(), vec![]);\n     }\n \n     #[test]\n     fn test_range_step_inclusive() {\n-        assert_eq!(range_step_inclusive(0i, 20, 5).collect::<~[int]>(), box [0, 5, 10, 15, 20]);\n-        assert_eq!(range_step_inclusive(20i, 0, -5).collect::<~[int]>(), box [20, 15, 10, 5, 0]);\n-        assert_eq!(range_step_inclusive(20i, 0, -6).collect::<~[int]>(), box [20, 14, 8, 2]);\n-        assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<~[u8]>(), box [200u8, 250]);\n-        assert_eq!(range_step_inclusive(200, -5, 1).collect::<~[int]>(), box []);\n-        assert_eq!(range_step_inclusive(200, 200, 1).collect::<~[int]>(), box [200]);\n+        assert_eq!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>(), vec![0, 5, 10, 15, 20]);\n+        assert_eq!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>(), vec![20, 15, 10, 5, 0]);\n+        assert_eq!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>(), vec![20, 14, 8, 2]);\n+        assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>(), vec![200u8, 250]);\n+        assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>(), vec![200]);\n     }\n \n     #[test]"}, {"sha": "a771f30dfd197aabab3ea2d22c4d1304c9792b90", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -111,4 +111,6 @@ mod std {\n     #[cfg(test)] pub use realstd::rt;     // needed for fail!()\n     #[cfg(test)] pub use realstd::option; // needed for assert!()\n     #[cfg(test)] pub use realstd::os;     // needed for tests\n+    #[cfg(test)] pub use realstd::slice;  // needed for tests\n+    #[cfg(test)] pub use realstd::vec;    // needed for vec![]\n }"}, {"sha": "2f8457e93f671b31725370c3a520c308481ff724", "filename": "src/libcore/option.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -844,22 +844,22 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let v: Option<~[int]> = collect(range(0, 0)\n-                                        .map(|_| Some(0)));\n-        assert_eq!(v, Some(box []));\n+        let v: Option<Vec<int>> = collect(range(0, 0)\n+                                          .map(|_| Some(0)));\n+        assert_eq!(v, Some(vec![]));\n \n-        let v: Option<~[int]> = collect(range(0, 3)\n-                                        .map(|x| Some(x)));\n-        assert_eq!(v, Some(box [0, 1, 2]));\n+        let v: Option<Vec<int>> = collect(range(0, 3)\n+                                          .map(|x| Some(x)));\n+        assert_eq!(v, Some(vec![0, 1, 2]));\n \n-        let v: Option<~[int]> = collect(range(0, 3)\n-                                        .map(|x| if x > 1 { None } else { Some(x) }));\n+        let v: Option<Vec<int>> = collect(range(0, 3)\n+                                          .map(|x| if x > 1 { None } else { Some(x) }));\n         assert_eq!(v, None);\n \n         // test that it does not take more elements than it needs\n         let mut functions = [|| Some(()), || None, || fail!()];\n \n-        let v: Option<~[()]> = collect(functions.mut_iter().map(|f| (*f)()));\n+        let v: Option<Vec<()>> = collect(functions.mut_iter().map(|f| (*f)()));\n \n         assert_eq!(v, None);\n     }"}, {"sha": "27ae2ad9946f5718ae2852e5ee3a69029b9152fe", "filename": "src/libcore/result.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -653,20 +653,20 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let v: Result<~[int], ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n-        assert_eq!(v, Ok(box []));\n+        let v: Result<Vec<int>, ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n+        assert_eq!(v, Ok(vec![]));\n \n-        let v: Result<~[int], ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n-        assert_eq!(v, Ok(box [0, 1, 2]));\n+        let v: Result<Vec<int>, ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n+        assert_eq!(v, Ok(vec![0, 1, 2]));\n \n-        let v: Result<~[int], int> = collect(range(0, 3)\n-                                             .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n+        let v: Result<Vec<int>, int> = collect(range(0, 3)\n+                                               .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n         assert_eq!(v, Err(2));\n \n         // test that it does not take more elements than it needs\n         let mut functions = [|| Ok(()), || Err(1), || fail!()];\n \n-        let v: Result<~[()], int> = collect(functions.mut_iter().map(|f| (*f)()));\n+        let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n         assert_eq!(v, Err(1));\n     }\n "}, {"sha": "0e6baaa518a73e8aa20b1ed51c915949a20ecf70", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 28, "deletions": 50, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -13,8 +13,9 @@ use char::Char;\n use clone::Clone;\n use container::Container;\n use default::Default;\n+use finally::try_finally;\n use intrinsics;\n-use iter::{Iterator, FromIterator};\n+use iter::{range, Iterator, FromIterator};\n use mem;\n use num::{CheckedMul, CheckedAdd};\n use option::{Some, None};\n@@ -25,7 +26,6 @@ use slice::ImmutableVector;\n use str::StrSlice;\n \n #[cfg(not(test))] use ops::Add;\n-#[cfg(not(test))] use slice::Vector;\n \n #[allow(ctypes)]\n extern {\n@@ -147,56 +147,34 @@ impl<'a> Add<&'a str,~str> for &'a str {\n impl<A: Clone> Clone for ~[A] {\n     #[inline]\n     fn clone(&self) -> ~[A] {\n-        self.iter().map(|a| a.clone()).collect()\n-    }\n-}\n-\n-impl<A> FromIterator<A> for ~[A] {\n-    fn from_iter<T: Iterator<A>>(mut iterator: T) -> ~[A] {\n-        let (lower, _) = iterator.size_hint();\n-        let cap = if lower == 0 {16} else {lower};\n-        let mut cap = cap.checked_mul(&mem::size_of::<A>()).unwrap();\n-        let mut len = 0;\n+        let len = self.len();\n+        let data_size = len.checked_mul(&mem::size_of::<A>()).unwrap();\n+        let size = mem::size_of::<Vec<()>>().checked_add(&data_size).unwrap();\n \n         unsafe {\n-            let mut ptr = alloc(cap) as *mut Vec<A>;\n-            let mut ret = cast::transmute(ptr);\n-            for elt in iterator {\n-                if len * mem::size_of::<A>() >= cap {\n-                    cap = cap.checked_mul(&2).unwrap();\n-                    let ptr2 = alloc(cap) as *mut Vec<A>;\n-                    ptr::copy_nonoverlapping_memory(&mut (*ptr2).data,\n-                                                    &(*ptr).data,\n-                                                    len);\n-                    free(ptr as *u8);\n-                    cast::forget(ret);\n-                    ret = cast::transmute(ptr2);\n-                    ptr = ptr2;\n-                }\n-\n-                let base = &mut (*ptr).data as *mut A;\n-                intrinsics::move_val_init(&mut *base.offset(len as int), elt);\n-                len += 1;\n-                (*ptr).fill = len * mem::nonzero_size_of::<A>();\n-            }\n-            ret\n+            let ret = alloc(size) as *mut Vec<A>;\n+\n+            (*ret).fill = len * mem::nonzero_size_of::<A>();\n+            (*ret).alloc = len * mem::nonzero_size_of::<A>();\n+\n+            let mut i = 0;\n+            let p = &mut (*ret).data as *mut _ as *mut A;\n+            try_finally(\n+                &mut i, (),\n+                |i, ()| while *i < len {\n+                    mem::move_val_init(\n+                        &mut(*p.offset(*i as int)),\n+                        self.unsafe_ref(*i).clone());\n+                    *i += 1;\n+                },\n+                |i| if *i < len {\n+                    // we must be failing, clean up after ourselves\n+                    for j in range(0, *i as int) {\n+                        ptr::read(&*p.offset(j));\n+                    }\n+                    free(ret as *u8);\n+                });\n+            cast::transmute(ret)\n         }\n     }\n }\n-\n-#[cfg(not(test))]\n-impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n-    #[inline]\n-    fn add(&self, rhs: &V) -> ~[T] {\n-        let first = self.iter().map(|t| t.clone());\n-        first.chain(rhs.as_slice().iter().map(|t| t.clone())).collect()\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl<T:Clone, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n-    #[inline]\n-    fn add(&self, rhs: &V) -> ~[T] {\n-        self.as_slice() + rhs.as_slice()\n-    }\n-}"}, {"sha": "689f59b471c90402c7ec9298d15d8bc697f8e58d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -621,12 +621,12 @@ impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n ///          0x0073, 0xDD1E, 0x0069, 0x0063,\n ///          0xD834];\n ///\n-/// assert_eq!(str::utf16_items(v).collect::<~[_]>(),\n-///            ~[ScalarValue('\ud834\udd1e'),\n-///              ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n-///              LoneSurrogate(0xDD1E),\n-///              ScalarValue('i'), ScalarValue('c'),\n-///              LoneSurrogate(0xD834)]);\n+/// assert_eq!(str::utf16_items(v).collect::<Vec<_>>(),\n+///            vec![ScalarValue('\ud834\udd1e'),\n+///                 ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n+///                 LoneSurrogate(0xDD1E),\n+///                 ScalarValue('i'), ScalarValue('c'),\n+///                 LoneSurrogate(0xD834)]);\n /// ```\n pub fn utf16_items<'a>(v: &'a [u16]) -> UTF16Items<'a> {\n     UTF16Items { iter : v.iter() }\n@@ -896,8 +896,8 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n-    /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n     fn chars(&self) -> Chars<'a>;\n \n@@ -925,14 +925,14 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n-    /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, ~[\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n     /// ```\n     fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n \n@@ -943,14 +943,14 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lambda\".splitn(' ', 2).collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a little lambda\"]);\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(' ', 2).collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n-    /// assert_eq!(v, ~[\"abc\", \"def2ghi\"]);\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n-    /// assert_eq!(v, ~[\"lion\", \"\", \"tigerXleopard\"]);\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n+    /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n     /// ```\n     fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n \n@@ -963,20 +963,20 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, ~[\"A\", \"B\"]);\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, vec![\"A\", \"B\"]);\n     ///\n-    /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n-    /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n+    /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n     ///\n-    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').rev().collect();\n-    /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n+    /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n-    /// assert_eq!(v, ~[\"ghi\", \"def\", \"abc\"]);\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').rev().collect();\n-    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n+    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n     fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n \n@@ -991,14 +991,14 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n-    /// assert_eq!(v, ~[\"lamb\", \"little\", \"Mary had a\"]);\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n+    /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n-    /// assert_eq!(v, ~[\"ghi\", \"abc1def\"]);\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n-    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"lionX\"]);\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n+    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n     fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n \n@@ -1013,14 +1013,14 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[(uint, uint)] = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, ~[(0,3), (6,9), (12,15)]);\n+    /// let v: Vec<(uint, uint)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n     ///\n-    /// let v: ~[(uint, uint)] = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, ~[(1,4), (4,7)]);\n+    /// let v: Vec<(uint, uint)> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, vec![(1,4), (4,7)]);\n     ///\n-    /// let v: ~[(uint, uint)] = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n+    /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n     fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;\n \n@@ -1029,11 +1029,11 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, ~[\"\", \"XXX\", \"YYY\", \"\"]);\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n     ///\n-    /// let v: ~[&str] = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, ~[\"1\", \"\", \"2\"]);\n+    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n     fn split_str(&self, &'a str) -> StrSplits<'a>;\n \n@@ -1045,8 +1045,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n-    /// let v: ~[&str] = four_lines.lines().collect();\n-    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     fn lines(&self) -> CharSplits<'a, char>;\n \n@@ -1058,8 +1058,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n-    /// let v: ~[&str] = four_lines.lines_any().collect();\n-    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     fn lines_any(&self) -> AnyLines<'a>;\n \n@@ -1071,8 +1071,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n-    /// let v: ~[&str] = some_words.words().collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// let v: Vec<&str> = some_words.words().collect();\n+    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n     fn words(&self) -> Words<'a>;\n \n@@ -1469,7 +1469,8 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// let string = \"a\\nb\\nc\";\n-    /// let lines: ~[&str] = string.lines().collect();\n+    /// let lines: Vec<&str> = string.lines().collect();\n+    /// let lines = lines.as_slice();\n     ///\n     /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\""}, {"sha": "3de1dde240c9722ae81f48d72997bda6f29cffe6", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -51,7 +51,7 @@\n //! fn main() {\n //!     let args = os::args();\n //!\n-//!     let program = args[0].clone();\n+//!     let program = args.get(0).clone();\n //!\n //!     let opts = [\n //!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),"}, {"sha": "57b87f21521e8221844e230b806f2888fcf12f45", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -22,7 +22,7 @@ pub struct GetAddrInfoRequest;\n \n impl GetAddrInfoRequest {\n     pub fn run(host: Option<&str>, servname: Option<&str>,\n-               hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n+               hint: Option<ai::Hint>) -> Result<Vec<ai::Info>, IoError> {\n         assert!(host.is_some() || servname.is_some());\n \n         let c_host = host.map_or(unsafe { CString::new(null(), true) }, |x| x.to_c_str());\n@@ -80,7 +80,7 @@ impl GetAddrInfoRequest {\n \n         unsafe { freeaddrinfo(res); }\n \n-        Ok(addrs.move_iter().collect())\n+        Ok(addrs)\n     }\n }\n "}, {"sha": "42e5ad062ee84b078fc6372c351da52c71f84c85", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -22,7 +22,7 @@ use std::ptr;\n use std::rt::rtio;\n use std::str;\n use std::sync::arc::UnsafeArc;\n-use std::slice;\n+use std::vec;\n \n use io::IoResult;\n \n@@ -368,8 +368,8 @@ pub fn readdir(p: &CString) -> IoResult<Vec<Path>> {\n                 if fp_buf as uint == 0 {\n                     fail!(\"os::list_dir() failure: got null ptr from wfd\");\n                 } else {\n-                    let fp_vec = slice::from_buf(fp_buf, libc::wcslen(fp_buf) as uint);\n-                    let fp_trimmed = str::truncate_utf16_at_nul(fp_vec);\n+                    let fp_vec = vec::raw::from_buf(fp_buf, libc::wcslen(fp_buf) as uint);\n+                    let fp_trimmed = str::truncate_utf16_at_nul(fp_vec.as_slice());\n                     let fp_str = str::from_utf16(fp_trimmed)\n                             .expect(\"rust_list_dir_wfd_fp_buf returned invalid UTF-16\");\n                     paths.push(Path::new(fp_str));"}, {"sha": "f2c2c66e1425fe521be0ff897e2a17c10b98b567", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -194,7 +194,7 @@ impl rtio::IoFactory for IoFactory {\n         })\n     }\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> IoResult<~[ai::Info]> {\n+                          hint: Option<ai::Hint>) -> IoResult<Vec<ai::Info>> {\n         addrinfo::GetAddrInfoRequest::run(host, servname, hint)\n     }\n \n@@ -260,7 +260,7 @@ impl rtio::IoFactory for IoFactory {\n     }\n     fn spawn(&mut self, config: ProcessConfig)\n             -> IoResult<(Box<RtioProcess:Send>,\n-                         ~[Option<Box<RtioPipe:Send>>])> {\n+                         Vec<Option<Box<RtioPipe:Send>>>)> {\n         process::Process::spawn(config).map(|(p, io)| {\n             (box p as Box<RtioProcess:Send>,\n              io.move_iter().map(|p| p.map(|p| {"}, {"sha": "c83af20d1d84eac884ed7dd2b83372f2500f40a8", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -67,7 +67,7 @@ impl Process {\n     ///     os pipe instead. This process takes ownership of these file\n     ///     descriptors, closing them upon destruction of the process.\n     pub fn spawn(config: p::ProcessConfig)\n-        -> Result<(Process, ~[Option<file::FileDesc>]), io::IoError>\n+        -> Result<(Process, Vec<Option<file::FileDesc>>), io::IoError>\n     {\n         // right now we only handle stdin/stdout/stderr.\n         if config.extra_io.len() > 0 {\n@@ -117,7 +117,7 @@ impl Process {\n                         exit_code: None,\n                         exit_signal: None,\n                     },\n-                    ret_io.move_iter().collect()))\n+                    ret_io))\n             }\n             Err(e) => Err(e)\n         }"}, {"sha": "c49adce904a5199b8c8aa6fffaa3bc35f5d4d904", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -45,9 +45,9 @@ pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<~str> {\n     let libs = sess.cstore.get_used_crates(cstore::RequireDynamic);\n     let libs = libs.move_iter().filter_map(|(_, l)| {\n         l.map(|p| p.clone())\n-    }).collect::<~[_]>();\n+    }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(os, sysroot, output, libs,\n+    let rpaths = get_rpaths(os, sysroot, output, libs.as_slice(),\n                             sess.opts.target_triple);\n     flags.push_all(rpaths_to_flags(rpaths.as_slice()).as_slice());\n     flags"}, {"sha": "eaf6527ea829b9264852a17a56d20c98024e2dfd", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -282,7 +282,7 @@ mod __test {\n   #![!resolve_unexported]\n   extern crate test (name = \"test\", vers = \"...\");\n   fn main() {\n-    test::test_main_static(::os::args(), tests)\n+    test::test_main_static(::os::args().as_slice(), tests)\n   }\n \n   static tests : &'static [test::TestDescAndFn] = &[\n@@ -326,8 +326,8 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n     let mainfn = (quote_item!(&cx.ext_cx,\n         pub fn main() {\n             #![main]\n-            #![allow(deprecated_owned_vector)]\n-            test::test_main_static(::std::os::args(), TESTS);\n+            use std::slice::Vector;\n+            test::test_main_static(::std::os::args().as_slice(), TESTS);\n         }\n     )).unwrap();\n "}, {"sha": "0962acd0a2ebf23acf34db153c955d69e708e15e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -434,7 +434,7 @@ pub fn monitor(f: proc():Send) {\n }\n \n pub fn main() {\n-    std::os::set_exit_status(main_args(std::os::args()));\n+    std::os::set_exit_status(main_args(std::os::args().as_slice()));\n }\n \n pub fn main_args(args: &[~str]) -> int {"}, {"sha": "400aa83a615143a04092b8c38428290c468c947c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -226,7 +226,8 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n \n     let f = decl_rust_fn(ccx, false, inputs, output, name);\n     csearch::get_item_attrs(&ccx.sess().cstore, did, |meta_items| {\n-        set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).collect::<~[_]>(), f)\n+        set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x))\n+                                    .collect::<Vec<_>>().as_slice(), f)\n     });\n \n     ccx.externs.borrow_mut().insert(name.to_owned(), f);\n@@ -2109,12 +2110,12 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n-    let compressed = encoder::metadata_encoding_version +\n-                        match flate::deflate_bytes(metadata.as_slice()) {\n-                            Some(compressed) => compressed,\n-                            None => cx.sess().fatal(format!(\"failed to compress metadata\", ))\n-                        }.as_slice();\n-    let llmeta = C_bytes(cx, compressed);\n+    let compressed = Vec::from_slice(encoder::metadata_encoding_version)\n+                     .append(match flate::deflate_bytes(metadata.as_slice()) {\n+                         Some(compressed) => compressed,\n+                         None => cx.sess().fatal(format!(\"failed to compress metadata\"))\n+                     }.as_slice());\n+    let llmeta = C_bytes(cx, compressed.as_slice());\n     let llconst = C_struct(cx, [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.crateid.name,\n                        cx.link_meta.crateid.version_or_default(), cx.link_meta.crate_hash);"}, {"sha": "548746362cf238bb1ff0f8c5d12b77697956650a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -33,7 +33,7 @@ use middle::ty;\n use util::ppaux::{Repr, ty_to_str};\n \n use std::c_str::ToCStr;\n-use std::slice;\n+use std::vec;\n use std::vec::Vec;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n@@ -94,12 +94,12 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let (vs, inlineable) = slice::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n+    let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(cx, vs, false)\n+        C_struct(cx, vs.as_slice(), false)\n     } else {\n-        C_array(llunitty, vs)\n+        C_array(llunitty, vs.as_slice())\n     };\n     (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n }\n@@ -539,7 +539,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n               };\n \n               expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n-                  let (cs, inlineable) = slice::unzip(field_tys.iter().enumerate()\n+                  let (cs, inlineable) = vec::unzip(field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n                           Some(f) => const_expr(cx, (*f).expr, is_local),\n@@ -554,7 +554,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                           }\n                       }\n                   }));\n-                  (adt::trans_const(cx, &*repr, discr, cs),\n+                  (adt::trans_const(cx, &*repr, discr, cs.as_slice()),\n                    inlineable.iter().fold(true, |a, &b| a && b))\n               })\n           }"}, {"sha": "4fd4f2f9d6ef0e635a147e737f71e85984127df1", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -157,12 +157,13 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             // This is a bit unfortunate.\n \n             let idx = real_substs.tps.len() - num_method_ty_params;\n-            let substs = real_substs.tps.slice(0, idx) +\n-            &[real_substs.self_ty.unwrap()] + real_substs.tps.tailn(idx);\n+            let substs = Vec::from_slice(real_substs.tps.slice(0, idx))\n+                         .append([real_substs.self_ty.unwrap()])\n+                         .append(real_substs.tps.tailn(idx));\n             debug!(\"static default: changed substitution to {}\",\n                    substs.repr(ccx.tcx()));\n \n-            ty::subst_tps(ccx.tcx(), substs, None, llitem_ty)\n+            ty::subst_tps(ccx.tcx(), substs.as_slice(), None, llitem_ty)\n         }\n     };\n "}, {"sha": "06996df169254e2dd5d478b767b8963dcc439870", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -380,7 +380,7 @@ impl fmt::Show for clean::Type {\n                            \"\".to_owned()\n                        } else {\n                            let mut m = decl.bounds.iter().map(|s| s.to_str());\n-                           \": \" + m.collect::<~[~str]>().connect(\" + \")\n+                           \": \" + m.collect::<Vec<~str>>().connect(\" + \")\n                        },\n                        arrow = match decl.decl.output { clean::Unit => \"no\", _ => \"yes\" },\n                        ret = decl.decl.output)"}, {"sha": "0bdf0818c8e82ab780d47bc522e69f9747c86936", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -549,7 +549,8 @@ impl<'a> SourceCollector<'a> {\n             root_path.push_str(\"../\");\n         });\n \n-        cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n+        cur.push(Vec::from_slice(p.filename().expect(\"source has no filename\"))\n+                 .append(bytes!(\".html\")));\n         let mut w = BufferedWriter::new(try!(File::create(&cur)));\n \n         let title = format!(\"{} -- source\", cur.filename_display());"}, {"sha": "72b474147335c7002c5fc1f67ca46ea2f01537be", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -85,7 +85,7 @@ local_data_key!(pub analysiskey: core::CrateAnalysis)\n type Output = (clean::Crate, Vec<plugins::PluginJson> );\n \n pub fn main() {\n-    std::os::set_exit_status(main_args(std::os::args()));\n+    std::os::set_exit_status(main_args(std::os::args().as_slice()));\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {"}, {"sha": "4766630b0f421ecd05024a2377a398fa786c9c6a", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -33,7 +33,7 @@ pub struct GetAddrInfoRequest;\n \n impl GetAddrInfoRequest {\n     pub fn run(loop_: &Loop, node: Option<&str>, service: Option<&str>,\n-               hints: Option<ai::Hint>) -> Result<~[ai::Info], UvError> {\n+               hints: Option<ai::Hint>) -> Result<Vec<ai::Info>, UvError> {\n         assert!(node.is_some() || service.is_some());\n         let (_c_node, c_node_ptr) = match node {\n             Some(n) => {\n@@ -134,7 +134,7 @@ fn each_ai_flag(_f: |c_int, ai::Flag|) {\n }\n \n // Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n-pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n+pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<ai::Info> {\n     unsafe {\n         let mut addr = addr.handle;\n \n@@ -180,6 +180,6 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n             }\n         }\n \n-        return addrs.move_iter().collect();\n+        addrs\n     }\n }"}, {"sha": "d671e20868c5c39d64b80193fbad4f416c1f1d57", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -40,7 +40,8 @@ impl Process {\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n     pub fn spawn(io_loop: &mut UvIoFactory, config: process::ProcessConfig)\n-                -> Result<(Box<Process>, ~[Option<PipeWatcher>]), UvError> {\n+                -> Result<(Box<Process>, Vec<Option<PipeWatcher>>), UvError>\n+    {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n         let mut io = vec![config.stdin, config.stdout, config.stderr];\n         for slot in config.extra_io.iter() {\n@@ -102,7 +103,7 @@ impl Process {\n         });\n \n         match ret {\n-            Ok(p) => Ok((p, ret_io.move_iter().collect())),\n+            Ok(p) => Ok((p, ret_io)),\n             Err(e) => Err(e),\n         }\n     }"}, {"sha": "50258c2583c65c33d169e4e31c36e4df8ff62071", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -178,7 +178,7 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n+                          hint: Option<ai::Hint>) -> Result<Vec<ai::Info>, IoError> {\n         let r = GetAddrInfoRequest::run(&self.loop_, host, servname, hint);\n         r.map_err(uv_error_to_io_error)\n     }\n@@ -272,7 +272,7 @@ impl IoFactory for UvIoFactory {\n \n     fn spawn(&mut self, config: ProcessConfig)\n             -> Result<(Box<rtio::RtioProcess:Send>,\n-                       ~[Option<Box<rtio::RtioPipe:Send>>]),\n+                       Vec<Option<Box<rtio::RtioPipe:Send>>>),\n                       IoError>\n     {\n         match Process::spawn(self, config) {"}, {"sha": "4709365ebff533fe7d0647fbfee3f2720c40cb85", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -146,7 +146,7 @@ impl<'a> ToBase64 for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v.move_iter().collect())\n+            str::raw::from_utf8(v.as_slice()).to_owned()\n         }\n     }\n }\n@@ -155,7 +155,7 @@ impl<'a> ToBase64 for &'a [u8] {\n pub trait FromBase64 {\n     /// Converts the value of `self`, interpreted as base64 encoded data, into\n     /// an owned vector of bytes, returning the vector.\n-    fn from_base64(&self) -> Result<~[u8], FromBase64Error>;\n+    fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error>;\n }\n \n /// Errors that can occur when decoding a base64 encoded string\n@@ -192,22 +192,21 @@ impl<'a> FromBase64 for &'a str {\n      * ```rust\n      * extern crate serialize;\n      * use serialize::base64::{ToBase64, FromBase64, STANDARD};\n-     * use std::str;\n      *\n      * fn main () {\n      *     let hello_str = bytes!(\"Hello, World\").to_base64(STANDARD);\n      *     println!(\"base64 output: {}\", hello_str);\n      *     let res = hello_str.from_base64();\n      *     if res.is_ok() {\n-     *       let opt_bytes = str::from_utf8_owned(res.unwrap());\n+     *       let opt_bytes = StrBuf::from_utf8(res.unwrap());\n      *       if opt_bytes.is_some() {\n      *         println!(\"decoded from base64: {}\", opt_bytes.unwrap());\n      *       }\n      *     }\n      * }\n      * ```\n      */\n-    fn from_base64(&self) -> Result<~[u8], FromBase64Error> {\n+    fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n         let mut r = Vec::new();\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n@@ -256,7 +255,7 @@ impl<'a> FromBase64 for &'a str {\n             _ => return Err(InvalidBase64Length),\n         }\n \n-        Ok(r.move_iter().collect())\n+        Ok(r)\n     }\n }\n \n@@ -301,21 +300,21 @@ mod tests {\n \n     #[test]\n     fn test_from_base64_basic() {\n-        assert_eq!(\"\".from_base64().unwrap(), \"\".as_bytes().to_owned());\n-        assert_eq!(\"Zg==\".from_base64().unwrap(), \"f\".as_bytes().to_owned());\n-        assert_eq!(\"Zm8=\".from_base64().unwrap(), \"fo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9v\".from_base64().unwrap(), \"foo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYg==\".from_base64().unwrap(), \"foob\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap(), \"fooba\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap(), \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"\".from_base64().unwrap().as_slice(), \"\".as_bytes());\n+        assert_eq!(\"Zg==\".from_base64().unwrap().as_slice(), \"f\".as_bytes());\n+        assert_eq!(\"Zm8=\".from_base64().unwrap().as_slice(), \"fo\".as_bytes());\n+        assert_eq!(\"Zm9v\".from_base64().unwrap().as_slice(), \"foo\".as_bytes());\n+        assert_eq!(\"Zm9vYg==\".from_base64().unwrap().as_slice(), \"foob\".as_bytes());\n+        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap().as_slice(), \"fooba\".as_bytes());\n+        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap().as_slice(), \"foobar\".as_bytes());\n     }\n \n     #[test]\n     fn test_from_base64_newlines() {\n-        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap(),\n-                   \"foobar\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap(),\n-                   \"foob\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap().as_slice(),\n+                   \"foobar\".as_bytes());\n+        assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap().as_slice(),\n+                   \"foob\".as_bytes());\n     }\n \n     #[test]\n@@ -341,8 +340,8 @@ mod tests {\n         for _ in range(0, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n             let v = Vec::from_fn(times, |_| random::<u8>());\n-            assert_eq!(v.as_slice().to_base64(STANDARD).from_base64().unwrap(),\n-                       v.as_slice().to_owned());\n+            assert_eq!(v.as_slice().to_base64(STANDARD).from_base64().unwrap().as_slice(),\n+                       v.as_slice());\n         }\n     }\n "}, {"sha": "c463d97dba4d48fe960b36f79c1621615de10852", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -45,7 +45,7 @@ impl<'a> ToHex for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v.move_iter().collect())\n+            str::raw::from_utf8(v.as_slice()).to_owned()\n         }\n     }\n }\n@@ -54,7 +54,7 @@ impl<'a> ToHex for &'a [u8] {\n pub trait FromHex {\n     /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n     /// into an owned vector of bytes, returning the vector.\n-    fn from_hex(&self) -> Result<~[u8], FromHexError>;\n+    fn from_hex(&self) -> Result<Vec<u8>, FromHexError>;\n }\n \n /// Errors that can occur when decoding a hex encoded string\n@@ -91,19 +91,18 @@ impl<'a> FromHex for &'a str {\n      * ```rust\n      * extern crate serialize;\n      * use serialize::hex::{FromHex, ToHex};\n-     * use std::str;\n      *\n      * fn main () {\n      *     let hello_str = \"Hello, World\".as_bytes().to_hex();\n      *     println!(\"{}\", hello_str);\n      *     let bytes = hello_str.from_hex().unwrap();\n      *     println!(\"{:?}\", bytes);\n-     *     let result_str = str::from_utf8_owned(bytes).unwrap();\n+     *     let result_str = StrBuf::from_utf8(bytes).unwrap();\n      *     println!(\"{}\", result_str);\n      * }\n      * ```\n      */\n-    fn from_hex(&self) -> Result<~[u8], FromHexError> {\n+    fn from_hex(&self) -> Result<Vec<u8>, FromHexError> {\n         // This may be an overestimate if there is any whitespace\n         let mut b = Vec::with_capacity(self.len() / 2);\n         let mut modulus = 0;\n@@ -150,10 +149,10 @@ mod tests {\n \n     #[test]\n     pub fn test_from_hex_okay() {\n-        assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n-                   \"foobar\".as_bytes().to_owned());\n-        assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n-                   \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"666f6f626172\".from_hex().unwrap().as_slice(),\n+                   \"foobar\".as_bytes());\n+        assert_eq!(\"666F6F626172\".from_hex().unwrap().as_slice(),\n+                   \"foobar\".as_bytes());\n     }\n \n     #[test]\n@@ -169,8 +168,8 @@ mod tests {\n \n     #[test]\n     pub fn test_from_hex_ignores_whitespace() {\n-        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n-                   \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap().as_slice(),\n+                   \"foobar\".as_bytes());\n     }\n \n     #[test]\n@@ -183,8 +182,8 @@ mod tests {\n     #[test]\n     pub fn test_from_hex_all_bytes() {\n         for i in range(0, 256) {\n-            assert_eq!(format!(\"{:02x}\", i as uint).from_hex().unwrap(), ~[i as u8]);\n-            assert_eq!(format!(\"{:02X}\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+            assert_eq!(format!(\"{:02x}\", i as uint).from_hex().unwrap().as_slice(), &[i as u8]);\n+            assert_eq!(format!(\"{:02X}\", i as uint).from_hex().unwrap().as_slice(), &[i as u8]);\n         }\n     }\n "}, {"sha": "2e4d7696c44d0b42a53fea7e5793af7b6adf690b", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -166,14 +166,14 @@ use serialize::{json, Encodable, Decodable};\n  pub struct TestStruct1  {\n     data_int: u8,\n     data_str: ~str,\n-    data_vector: ~[u8],\n+    data_vector: Vec<u8>,\n  }\n \n // To serialize use the `json::str_encode` to encode an object in a string.\n // It calls the generated `Encodable` impl.\n fn main() {\n     let to_encode_object = TestStruct1\n-         {data_int: 1, data_str:\"toto\".to_owned(), data_vector:~[2,3,4,5]};\n+         {data_int: 1, data_str:\"toto\".to_owned(), data_vector:vec![2,3,4,5]};\n     let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n \n     // To deserialize use the `json::from_str` and `json::Decoder`\n@@ -201,7 +201,7 @@ use collections::TreeMap;\n pub struct TestStruct1  {\n     data_int: u8,\n     data_str: ~str,\n-    data_vector: ~[u8],\n+    data_vector: Vec<u8>,\n }\n \n impl ToJson for TestStruct1 {\n@@ -218,7 +218,7 @@ fn main() {\n     // Serialization using our impl of to_json\n \n     let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_owned(),\n-                                          data_vector:~[2,3,4,5]};\n+                                          data_vector:vec![2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n     let json_str: ~str = tjson.to_str();\n \n@@ -258,7 +258,7 @@ pub enum Json {\n     Null,\n }\n \n-pub type List = ~[Json];\n+pub type List = Vec<Json>;\n pub type Object = TreeMap<~str, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n@@ -2211,7 +2211,7 @@ impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n     fn to_json(&self) -> Json {\n         match *self {\n           (ref a, ref b) => {\n-            List(box [a.to_json(), b.to_json()])\n+            List(vec![a.to_json(), b.to_json()])\n           }\n         }\n     }\n@@ -2221,7 +2221,7 @@ impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n     fn to_json(&self) -> Json {\n         match *self {\n           (ref a, ref b, ref c) => {\n-            List(box [a.to_json(), b.to_json(), c.to_json()])\n+            List(vec![a.to_json(), b.to_json(), c.to_json()])\n           }\n         }\n     }\n@@ -2298,12 +2298,12 @@ mod tests {\n     struct Inner {\n         a: (),\n         b: uint,\n-        c: ~[~str],\n+        c: Vec<~str>,\n     }\n \n     #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Outer {\n-        inner: ~[Inner],\n+        inner: Vec<Inner>,\n     }\n \n     fn mk_object(items: &[(~str, Json)]) -> Json {\n@@ -2360,22 +2360,22 @@ mod tests {\n \n     #[test]\n     fn test_write_list() {\n-        assert_eq!(List(~[]).to_str(), \"[]\".to_owned());\n-        assert_eq!(List(~[]).to_pretty_str(), \"[]\".to_owned());\n+        assert_eq!(List(vec![]).to_str(), \"[]\".to_owned());\n+        assert_eq!(List(vec![]).to_pretty_str(), \"[]\".to_owned());\n \n-        assert_eq!(List(~[Boolean(true)]).to_str(), \"[true]\".to_owned());\n+        assert_eq!(List(vec![Boolean(true)]).to_str(), \"[true]\".to_owned());\n         assert_eq!(\n-            List(~[Boolean(true)]).to_pretty_str(),\n+            List(vec![Boolean(true)]).to_pretty_str(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n             ]\".to_owned()\n         );\n \n-        let long_test_list = List(box [\n+        let long_test_list = List(vec![\n             Boolean(false),\n             Null,\n-            List(box [String(\"foo\\nbar\".to_owned()), Number(3.5)])]);\n+            List(vec![String(\"foo\\nbar\".to_owned()), Number(3.5)])]);\n \n         assert_eq!(long_test_list.to_str(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_owned());\n@@ -2411,7 +2411,7 @@ mod tests {\n         );\n \n         let complex_obj = mk_object([\n-                (\"b\".to_owned(), List(box [\n+                (\"b\".to_owned(), List(vec![\n                     mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n                     mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n                 ]))\n@@ -2443,7 +2443,7 @@ mod tests {\n \n         let a = mk_object([\n             (\"a\".to_owned(), Boolean(true)),\n-            (\"b\".to_owned(), List(box [\n+            (\"b\".to_owned(), List(vec![\n                 mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n                 mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n             ]))\n@@ -2678,44 +2678,44 @@ mod tests {\n         assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n         assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n \n-        assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n-        assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n-        assert_eq!(from_str(\"[true]\"), Ok(List(~[Boolean(true)])));\n-        assert_eq!(from_str(\"[ false ]\"), Ok(List(~[Boolean(false)])));\n-        assert_eq!(from_str(\"[null]\"), Ok(List(~[Null])));\n+        assert_eq!(from_str(\"[]\"), Ok(List(vec![])));\n+        assert_eq!(from_str(\"[ ]\"), Ok(List(vec![])));\n+        assert_eq!(from_str(\"[true]\"), Ok(List(vec![Boolean(true)])));\n+        assert_eq!(from_str(\"[ false ]\"), Ok(List(vec![Boolean(false)])));\n+        assert_eq!(from_str(\"[null]\"), Ok(List(vec![Null])));\n         assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(List(~[Number(3.0), Number(1.0)])));\n+                     Ok(List(vec![Number(3.0), Number(1.0)])));\n         assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(List(~[Number(3.0), Number(2.0)])));\n+                     Ok(List(vec![Number(3.0), Number(2.0)])));\n         assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(List(~[Number(2.0), List(~[Number(4.0), Number(1.0)])])));\n+               Ok(List(vec![Number(2.0), List(vec![Number(4.0), Number(1.0)])])));\n     }\n \n     #[test]\n     fn test_decode_list() {\n         let mut decoder = Decoder::new(from_str(\"[]\").unwrap());\n-        let v: ~[()] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[]);\n+        let v: Vec<()> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![]);\n \n         let mut decoder = Decoder::new(from_str(\"[null]\").unwrap());\n-        let v: ~[()] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[()]);\n+        let v: Vec<()> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![()]);\n \n         let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: ~[bool] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[true]);\n+        let v: Vec<bool> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![true]);\n \n         let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: ~[bool] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[true]);\n+        let v: Vec<bool> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![true]);\n \n         let mut decoder = Decoder::new(from_str(\"[3, 1]\").unwrap());\n-        let v: ~[int] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[3, 1]);\n+        let v: Vec<int> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![3, 1]);\n \n         let mut decoder = Decoder::new(from_str(\"[[3], [1, 2]]\").unwrap());\n-        let v: ~[~[uint]] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[~[3], ~[1, 2]]);\n+        let v: Vec<Vec<uint>> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![vec![3], vec![1, 2]]);\n     }\n \n     #[test]\n@@ -2750,7 +2750,7 @@ mod tests {\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n                       (\"a\".to_owned(), Number(1.0)),\n-                      (\"b\".to_owned(), List(~[Boolean(true)]))\n+                      (\"b\".to_owned(), List(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n                       \"{\".to_owned() +\n@@ -2763,7 +2763,7 @@ mod tests {\n                       \"}\").unwrap(),\n                   mk_object([\n                       (\"a\".to_owned(), Number(1.0)),\n-                      (\"b\".to_owned(), List(~[\n+                      (\"b\".to_owned(), List(vec![\n                           Boolean(true),\n                           String(\"foo\\nbar\".to_owned()),\n                           mk_object([\n@@ -2785,8 +2785,8 @@ mod tests {\n         assert_eq!(\n             v,\n             Outer {\n-                inner: ~[\n-                    Inner { a: (), b: 2, c: ~[\"abc\".to_owned(), \"xyz\".to_owned()] }\n+                inner: vec![\n+                    Inner { a: (), b: 2, c: vec![\"abc\".to_owned(), \"xyz\".to_owned()] }\n                 ]\n             }\n         );\n@@ -2837,7 +2837,7 @@ mod tests {\n         x: f64,\n         y: bool,\n         z: ~str,\n-        w: ~[DecodeStruct]\n+        w: Vec<DecodeStruct>\n     }\n     #[deriving(Decodable)]\n     enum DecodeEnum {"}, {"sha": "7914dd8c7d2aaf1269fc8288ae86e2f0aa724ba8", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -453,12 +453,14 @@ impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for ~[T] {\n \n impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for ~[T] {\n     fn decode(d: &mut D) -> Result<~[T], E> {\n+        use std::vec::FromVec;\n+\n         d.read_seq(|d, len| {\n             let mut v: Vec<T> = Vec::with_capacity(len);\n             for i in range(0, len) {\n                 v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n-            let k = v.move_iter().collect::<~[T]>();\n+            let k: ~[T] = FromVec::from_vec(v);\n             Ok(k)\n         })\n     }\n@@ -557,7 +559,7 @@ impl<E, S: Encoder<E>> Encodable<S, E> for path::posix::Path {\n \n impl<E, D: Decoder<E>> Decodable<D, E> for path::posix::Path {\n     fn decode(d: &mut D) -> Result<path::posix::Path, E> {\n-        let bytes: ~[u8] = try!(Decodable::decode(d));\n+        let bytes: Vec<u8> = try!(Decodable::decode(d));\n         Ok(path::posix::Path::new(bytes))\n     }\n }\n@@ -570,7 +572,7 @@ impl<E, S: Encoder<E>> Encodable<S, E> for path::windows::Path {\n \n impl<E, D: Decoder<E>> Decodable<D, E> for path::windows::Path {\n     fn decode(d: &mut D) -> Result<path::windows::Path, E> {\n-        let bytes: ~[u8] = try!(Decodable::decode(d));\n+        let bytes: Vec<u8> = try!(Decodable::decode(d));\n         Ok(path::windows::Path::new(bytes))\n     }\n }\n@@ -600,17 +602,17 @@ impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n }\n \n pub trait DecoderHelpers<E> {\n-    fn read_to_vec<T>(&mut self, f: |&mut Self| -> Result<T, E>) -> Result<~[T], E>;\n+    fn read_to_vec<T>(&mut self, f: |&mut Self| -> Result<T, E>) -> Result<Vec<T>, E>;\n }\n \n impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n-    fn read_to_vec<T>(&mut self, f: |&mut D| -> Result<T, E>) -> Result<~[T], E> {\n+    fn read_to_vec<T>(&mut self, f: |&mut D| -> Result<T, E>) -> Result<Vec<T>, E> {\n         self.read_seq(|this, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in range(0, len) {\n                 v.push(try!(this.read_seq_elt(i, |this| f(this))));\n             }\n-            Ok(v.move_iter().collect())\n+            Ok(v)\n         })\n     }\n }"}, {"sha": "f45ec8a6742a23585695e0f4c21b4d7fba6b0b63", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -13,7 +13,7 @@\n use to_str::{IntoStr};\n use str;\n use str::Str;\n-use str::StrSlice;\n+use str::{StrAllocating, StrSlice};\n use str::OwnedStr;\n use container::Container;\n use cast;\n@@ -217,14 +217,14 @@ pub trait OwnedAsciiCast {\n \n     /// Take ownership and cast to an ascii vector. Fail on non-ASCII input.\n     #[inline]\n-    fn into_ascii(self) -> ~[Ascii] {\n+    fn into_ascii(self) -> Vec<Ascii> {\n         assert!(self.is_ascii());\n         unsafe {self.into_ascii_nocheck()}\n     }\n \n     /// Take ownership and cast to an ascii vector. Return None on non-ASCII input.\n     #[inline]\n-    fn into_ascii_opt(self) -> Option<~[Ascii]> {\n+    fn into_ascii_opt(self) -> Option<Vec<Ascii>> {\n         if self.is_ascii() {\n             Some(unsafe { self.into_ascii_nocheck() })\n         } else {\n@@ -234,7 +234,7 @@ pub trait OwnedAsciiCast {\n \n     /// Take ownership and cast to an ascii vector.\n     /// Does not perform validation checks.\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii];\n+    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii>;\n }\n \n impl OwnedAsciiCast for ~[u8] {\n@@ -244,8 +244,8 @@ impl OwnedAsciiCast for ~[u8] {\n     }\n \n     #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n-        cast::transmute(self)\n+    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n+        cast::transmute(Vec::from_slice(self.as_slice()))\n     }\n }\n \n@@ -256,7 +256,20 @@ impl OwnedAsciiCast for ~str {\n     }\n \n     #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n+    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n+        let v: ~[u8] = cast::transmute(self);\n+        v.into_ascii_nocheck()\n+    }\n+}\n+\n+impl OwnedAsciiCast for Vec<u8> {\n+    #[inline]\n+    fn is_ascii(&self) -> bool {\n+        self.as_slice().is_ascii()\n+    }\n+\n+    #[inline]\n+    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n         cast::transmute(self)\n     }\n }\n@@ -268,10 +281,10 @@ pub trait AsciiStr {\n     fn as_str_ascii<'a>(&'a self) -> &'a str;\n \n     /// Convert to vector representing a lower cased ascii string.\n-    fn to_lower(&self) -> ~[Ascii];\n+    fn to_lower(&self) -> Vec<Ascii>;\n \n     /// Convert to vector representing a upper cased ascii string.\n-    fn to_upper(&self) -> ~[Ascii];\n+    fn to_upper(&self) -> Vec<Ascii>;\n \n     /// Compares two Ascii strings ignoring case.\n     fn eq_ignore_case(self, other: &[Ascii]) -> bool;\n@@ -284,12 +297,12 @@ impl<'a> AsciiStr for &'a [Ascii] {\n     }\n \n     #[inline]\n-    fn to_lower(&self) -> ~[Ascii] {\n+    fn to_lower(&self) -> Vec<Ascii> {\n         self.iter().map(|a| a.to_lower()).collect()\n     }\n \n     #[inline]\n-    fn to_upper(&self) -> ~[Ascii] {\n+    fn to_upper(&self) -> Vec<Ascii> {\n         self.iter().map(|a| a.to_upper()).collect()\n     }\n \n@@ -309,19 +322,21 @@ impl IntoStr for ~[Ascii] {\n impl IntoStr for Vec<Ascii> {\n     #[inline]\n     fn into_str(self) -> ~str {\n-        let v: ~[Ascii] = self.move_iter().collect();\n-        unsafe { cast::transmute(v) }\n+        unsafe {\n+            let s: &str = cast::transmute(self.as_slice());\n+            s.to_owned()\n+        }\n     }\n }\n \n-/// Trait to convert to an owned byte array by consuming self\n+/// Trait to convert to an owned byte vector by consuming self\n pub trait IntoBytes {\n-    /// Converts to an owned byte array by consuming self\n-    fn into_bytes(self) -> ~[u8];\n+    /// Converts to an owned byte vector by consuming self\n+    fn into_bytes(self) -> Vec<u8>;\n }\n \n-impl IntoBytes for ~[Ascii] {\n-    fn into_bytes(self) -> ~[u8] {\n+impl IntoBytes for Vec<Ascii> {\n+    fn into_bytes(self) -> Vec<u8> {\n         unsafe { cast::transmute(self) }\n     }\n }\n@@ -404,9 +419,11 @@ unsafe fn str_map_bytes(string: ~str, map: &'static [u8]) -> ~str {\n \n #[inline]\n unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> ~str {\n-    let bytes = string.bytes().map(|b| map[b as uint]).collect::<~[_]>();\n-\n-    str::raw::from_utf8_owned(bytes)\n+    let mut s = string.to_owned();\n+    for b in str::raw::as_owned_vec(&mut s).mut_iter() {\n+        *b = map[*b as uint];\n+    }\n+    s\n }\n \n static ASCII_LOWER_MAP: &'static [u8] = &[\n@@ -492,7 +509,6 @@ mod tests {\n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n         (&[$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n-        (~[$($e:expr),*]) => (box [$(Ascii{chr:$e}),*]);\n     )\n \n     macro_rules! vec2ascii (\n@@ -556,20 +572,17 @@ mod tests {\n \n     #[test]\n     fn test_ascii_vec_ng() {\n-        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_lower()).into_str(),\n-                   \"abcdef&?#\".to_owned());\n-        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_upper()).into_str(),\n-                   \"ABCDEF&?#\".to_owned());\n-        assert_eq!(Vec::from_slice(\"\".to_ascii().to_lower()).into_str(), \"\".to_owned());\n-        assert_eq!(Vec::from_slice(\"YMCA\".to_ascii().to_lower()).into_str(), \"ymca\".to_owned());\n-        assert_eq!(Vec::from_slice(\"abcDEFxyz:.;\".to_ascii().to_upper()).into_str(),\n-                   \"ABCDEFXYZ:.;\".to_owned());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_owned());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_owned());\n+        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_owned());\n+        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_owned());\n+        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_owned());\n     }\n \n     #[test]\n     fn test_owned_ascii_vec() {\n-        assert_eq!((\"( ;\".to_owned()).into_ascii(), v2ascii!(~[40, 32, 59]));\n-        assert_eq!((box [40u8, 32u8, 59u8]).into_ascii(), v2ascii!(~[40, 32, 59]));\n+        assert_eq!((\"( ;\".to_owned()).into_ascii(), vec2ascii![40, 32, 59]);\n+        assert_eq!((box [40u8, 32u8, 59u8]).into_ascii(), vec2ascii![40, 32, 59]);\n     }\n \n     #[test]\n@@ -580,13 +593,13 @@ mod tests {\n \n     #[test]\n     fn test_ascii_into_str() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).into_str(), \"( ;\".to_owned());\n+        assert_eq!(vec2ascii![40, 32, 59].into_str(), \"( ;\".to_owned());\n         assert_eq!(vec2ascii!(40, 32, 59).into_str(), \"( ;\".to_owned());\n     }\n \n     #[test]\n     fn test_ascii_to_bytes() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).into_bytes(), box [40u8, 32u8, 59u8]);\n+        assert_eq!(vec2ascii![40, 32, 59].into_bytes(), vec![40u8, 32u8, 59u8]);\n     }\n \n     #[test] #[should_fail]\n@@ -625,10 +638,10 @@ mod tests {\n         assert_eq!(v.to_ascii_opt(), Some(v2));\n         assert_eq!(\"zo\u00e4\u534e\".to_ascii_opt(), None);\n \n-        assert_eq!((box [40u8, 32u8, 59u8]).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n-        assert_eq!((box [127u8, 128u8, 255u8]).into_ascii_opt(), None);\n+        assert_eq!((vec![40u8, 32u8, 59u8]).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n+        assert_eq!((vec![127u8, 128u8, 255u8]).into_ascii_opt(), None);\n \n-        assert_eq!((\"( ;\".to_owned()).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n+        assert_eq!((\"( ;\".to_owned()).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n         assert_eq!((\"zo\u00e4\u534e\".to_owned()).into_ascii_opt(), None);\n     }\n "}, {"sha": "4a53a064610cb0e5b8661a283d39cb2d06fb1823", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -76,7 +76,7 @@ Some examples of obvious things you might want to do\n \n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n-    let lines: ~[~str] = file.lines().map(|x| x.unwrap()).collect();\n+    let lines: Vec<~str> = file.lines().map(|x| x.unwrap()).collect();\n     ```\n \n * Make a simple TCP client connection and request"}, {"sha": "879c66e0769d8eaecf80f54ed982df9d26964760", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -24,7 +24,7 @@ use io::IoResult;\n use io::net::ip::{SocketAddr, IpAddr};\n use option::{Option, Some, None};\n use rt::rtio::{IoFactory, LocalIo};\n-use slice::OwnedVector;\n+use vec::Vec;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n pub enum SocketType {\n@@ -73,7 +73,7 @@ pub struct Info {\n \n /// Easy name resolution. Given a hostname, returns the list of IP addresses for\n /// that hostname.\n-pub fn get_host_addresses(host: &str) -> IoResult<~[IpAddr]> {\n+pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n     lookup(Some(host), None, None).map(|a| a.move_iter().map(|i| i.address.ip).collect())\n }\n \n@@ -90,7 +90,7 @@ pub fn get_host_addresses(host: &str) -> IoResult<~[IpAddr]> {\n /// FIXME: this is not public because the `Hint` structure is not ready for public\n ///      consumption just yet.\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n-          -> IoResult<~[Info]> {\n+          -> IoResult<Vec<Info>> {\n     LocalIo::maybe_raise(|io| io.get_host_addresses(hostname, servname, hint))\n }\n "}, {"sha": "3babef6126e8fcc84e3546677803c88b8d1b2486", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -69,7 +69,7 @@ pub struct Process {\n \n     /// Extra I/O handles as configured by the original `ProcessConfig` when\n     /// this process was created. This is by default empty.\n-    pub extra_io: ~[Option<io::PipeStream>],\n+    pub extra_io: Vec<Option<io::PipeStream>>,\n }\n \n /// This configuration describes how a new process should be spawned. A blank\n@@ -418,7 +418,7 @@ impl Drop for Process {\n         drop(self.stdin.take());\n         drop(self.stdout.take());\n         drop(self.stderr.take());\n-        drop(mem::replace(&mut self.extra_io, box []));\n+        drop(mem::replace(&mut self.extra_io, Vec::new()));\n \n         self.wait();\n     }"}, {"sha": "8a783b6f378e2d82a4ffb97d7e97d506f86c7487", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -278,4 +278,7 @@ mod std {\n     pub use ty;\n     pub use unstable;\n     pub use vec;\n+\n+    // The test runner requires std::slice::Vector, so re-export std::slice just for it.\n+    #[cfg(test)] pub use slice;\n }"}, {"sha": "d8f1c108b742d48dd8040b50dba5b578319d7450", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};"}, {"sha": "9cc8981fc13f422c10d231fd413362088f54723d", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};"}, {"sha": "4f7fe32cc7088c9b7d3f171f258840d9e4bad851", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};"}, {"sha": "bea315d86837392e42a3236b646b7d747abfd36e", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};"}, {"sha": "d6a7fd1660b42800eb61a8731d6eb86413ba815a", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for architecture-sized signed integers (`int` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};"}, {"sha": "fcdb63f5ad5eb06564fadbc26af502becd07bc3d", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -77,13 +77,16 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n+        use slice::Vector;\n+        use str::StrAllocating;\n+\n         let mut buf = ::vec::Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg, |i| {\n             buf.push(i);\n         });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n-        unsafe { str::raw::from_utf8_owned(buf.move_iter().collect()) }\n+        unsafe { str::raw::from_utf8(buf.as_slice()).to_owned() }\n     }\n }\n "}, {"sha": "4769b17fb2b84e7d15eb795117fd95311448ef69", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -19,11 +19,10 @@ use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n-use slice::OwnedVector;\n use slice::{CloneableVector, ImmutableVector, MutableVector};\n use std::cmp::{Ord, Eq};\n-use str::{StrSlice};\n-use str;\n+use str::{StrAllocating, StrSlice};\n+use strbuf::StrBuf;\n use vec::Vec;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n@@ -262,7 +261,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n-        ) -> (~[u8], bool) {\n+        ) -> (Vec<u8>, bool) {\n     assert!(2 <= radix && radix <= 36);\n     match exp_format {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n@@ -278,17 +277,17 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n     let _1: T = One::one();\n \n     match num.classify() {\n-        FPNaN => { return (\"NaN\".as_bytes().to_owned(), true); }\n+        FPNaN => { return (Vec::from_slice(\"NaN\".as_bytes()), true); }\n         FPInfinite if num > _0 => {\n             return match sign {\n-                SignAll => (\"+inf\".as_bytes().to_owned(), true),\n-                _       => (\"inf\".as_bytes().to_owned(), true)\n+                SignAll => (Vec::from_slice(\"+inf\".as_bytes()), true),\n+                _       => (Vec::from_slice(\"inf\".as_bytes()), true)\n             };\n         }\n         FPInfinite if num < _0 => {\n             return match sign {\n-                SignNone => (\"inf\".as_bytes().to_owned(), true),\n-                _        => (\"-inf\".as_bytes().to_owned(), true),\n+                SignNone => (Vec::from_slice(\"inf\".as_bytes()), true),\n+                _        => (Vec::from_slice(\"-inf\".as_bytes()), true),\n             };\n         }\n         _ => {}\n@@ -483,7 +482,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n         }\n     }\n \n-    (buf.move_iter().collect(), false)\n+    (buf, false)\n }\n \n /**\n@@ -498,7 +497,7 @@ pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+\n         ) -> (~str, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n                                negative_zero, sign, digits, exp_format, exp_capital);\n-    (str::from_utf8_owned(bytes).unwrap(), special)\n+    (StrBuf::from_utf8(bytes).unwrap().into_owned(), special)\n }\n \n // Some constants for from_str_bytes_common's input validation,"}, {"sha": "5c93ca6c36b79748b8fba3a704eb353d4dd0feaa", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};"}, {"sha": "436eae7cd14d0c839acb9f0a0a617560acaeb478", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};"}, {"sha": "c654d6fbe3133df7e4e6cf36e0d4a58939a36741", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};"}, {"sha": "7051b9191be8158ba668ec23d3b079068383b5ce", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};"}, {"sha": "d1c3e96b2c987d7334b82dd6d3dc0b70d88141e1", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -11,11 +11,10 @@\n //! Operations and constants for architecture-sized unsigned integers (`uint` type)\n \n use from_str::FromStr;\n-use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::{ImmutableVector, OwnedVector};\n+use slice::ImmutableVector;\n use str;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};"}, {"sha": "0795238a49cff9578865f34f431f431575219533", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -78,13 +78,16 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n+        use slice::Vector;\n+        use str::StrAllocating;\n+\n         let mut buf = ::vec::Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone, |i| {\n             buf.push(i);\n         });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n-        unsafe { str::raw::from_utf8_owned(buf.move_iter().collect()) }\n+        unsafe { str::raw::from_utf8(buf.as_slice()).to_owned() }\n     }\n }\n "}, {"sha": "66143b40d52514e3f572a768a64063c3383054af", "filename": "src/libstd/os.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -169,7 +169,7 @@ fn with_env_lock<T>(f: || -> T) -> T {\n ///\n /// Invalid UTF-8 bytes are replaced with \\uFFFD. See `str::from_utf8_lossy()`\n /// for details.\n-pub fn env() -> ~[(~str,~str)] {\n+pub fn env() -> Vec<(~str,~str)> {\n     env_as_bytes().move_iter().map(|(k,v)| {\n         let k = str::from_utf8_lossy(k).into_owned();\n         let v = str::from_utf8_lossy(v).into_owned();\n@@ -179,7 +179,7 @@ pub fn env() -> ~[(~str,~str)] {\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n-pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n+pub fn env_as_bytes() -> Vec<(~[u8],~[u8])> {\n     unsafe {\n         #[cfg(windows)]\n         unsafe fn get_env_pairs() -> Vec<~[u8]> {\n@@ -224,16 +224,16 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n         fn env_convert(input: Vec<~[u8]>) -> Vec<(~[u8], ~[u8])> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n-                let vs: ~[&[u8]] = p.splitn(1, |b| *b == '=' as u8).collect();\n-                let key = vs[0].to_owned();\n-                let val = if vs.len() < 2 { box [] } else { vs[1].to_owned() };\n+                let mut it = p.splitn(1, |b| *b == '=' as u8);\n+                let key = it.next().unwrap().to_owned();\n+                let val = it.next().unwrap_or(&[]).to_owned();\n                 pairs.push((key, val));\n             }\n             pairs\n         }\n         with_env_lock(|| {\n             let unparsed_environ = get_env_pairs();\n-            env_convert(unparsed_environ).move_iter().collect()\n+            env_convert(unparsed_environ)\n         })\n     }\n }\n@@ -416,7 +416,7 @@ pub fn dll_filename(base: &str) -> ~str {\n pub fn self_exe_name() -> Option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n-    fn load_self() -> Option<~[u8]> {\n+    fn load_self() -> Option<Vec<u8>> {\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n@@ -436,23 +436,23 @@ pub fn self_exe_name() -> Option<Path> {\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v.move_iter().collect())\n+            Some(v)\n         }\n     }\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n-    fn load_self() -> Option<~[u8]> {\n+    fn load_self() -> Option<Vec<u8>> {\n         use std::io;\n \n         match io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n-            Ok(path) => Some(path.as_vec().to_owned()),\n+            Ok(path) => Some(path.into_vec()),\n             Err(..) => None\n         }\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    fn load_self() -> Option<~[u8]> {\n+    fn load_self() -> Option<Vec<u8>> {\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n             let mut sz: u32 = 0;\n@@ -462,19 +462,19 @@ pub fn self_exe_name() -> Option<Path> {\n             let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n             if err != 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n-            Some(v.move_iter().collect())\n+            Some(v)\n         }\n     }\n \n     #[cfg(windows)]\n-    fn load_self() -> Option<~[u8]> {\n+    fn load_self() -> Option<Vec<u8>> {\n         use str::OwnedStr;\n \n         unsafe {\n             use os::win32::fill_utf16_buf_and_decode;\n             fill_utf16_buf_and_decode(|buf, sz| {\n                 libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-            }).map(|s| s.into_bytes())\n+            }).map(|s| s.into_strbuf().into_bytes())\n         }\n     }\n \n@@ -789,12 +789,12 @@ pub fn get_exit_status() -> int {\n }\n \n #[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~[u8]] {\n+unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> Vec<~[u8]> {\n     use c_str::CString;\n \n     Vec::from_fn(argc as uint, |i| {\n         CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_owned()\n-    }).move_iter().collect()\n+    })\n }\n \n /**\n@@ -803,7 +803,7 @@ unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~[u8]] {\n  * Returns a list of the command line arguments.\n  */\n #[cfg(target_os = \"macos\")]\n-fn real_args_as_bytes() -> ~[~[u8]] {\n+fn real_args_as_bytes() -> Vec<~[u8]> {\n     unsafe {\n         let (argc, argv) = (*_NSGetArgc() as int,\n                             *_NSGetArgv() as **c_char);\n@@ -814,7 +814,7 @@ fn real_args_as_bytes() -> ~[~[u8]] {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n-fn real_args_as_bytes() -> ~[~[u8]] {\n+fn real_args_as_bytes() -> Vec<~[u8]> {\n     use rt;\n \n     match rt::args::clone() {\n@@ -824,12 +824,12 @@ fn real_args_as_bytes() -> ~[~[u8]] {\n }\n \n #[cfg(not(windows))]\n-fn real_args() -> ~[~str] {\n+fn real_args() -> Vec<~str> {\n     real_args_as_bytes().move_iter().map(|v| str::from_utf8_lossy(v).into_owned()).collect()\n }\n \n #[cfg(windows)]\n-fn real_args() -> ~[~str] {\n+fn real_args() -> Vec<~str> {\n     use slice;\n     use option::Expect;\n \n@@ -855,11 +855,11 @@ fn real_args() -> ~[~str] {\n         LocalFree(szArgList as *c_void);\n     }\n \n-    return args.move_iter().collect();\n+    return args\n }\n \n #[cfg(windows)]\n-fn real_args_as_bytes() -> ~[~[u8]] {\n+fn real_args_as_bytes() -> Vec<~[u8]> {\n     real_args().move_iter().map(|s| s.into_bytes()).collect()\n }\n \n@@ -883,13 +883,13 @@ extern \"system\" {\n ///\n /// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n /// See `str::from_utf8_lossy` for details.\n-pub fn args() -> ~[~str] {\n+pub fn args() -> Vec<~str> {\n     real_args()\n }\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line) as byte vectors.\n-pub fn args_as_bytes() -> ~[~[u8]] {\n+pub fn args_as_bytes() -> Vec<~[u8]> {\n     real_args_as_bytes()\n }\n "}, {"sha": "df0f1d8d449e44f44919b7351a45b0d366eb3ae6", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -21,6 +21,7 @@\n //! FIXME #7756: This has a lot of C glue for lack of globals.\n \n use option::Option;\n+use vec::Vec;\n #[cfg(test)] use option::{Some, None};\n #[cfg(test)] use realstd;\n #[cfg(test)] use realargs = realstd::rt::args;\n@@ -36,25 +37,25 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n #[cfg(test)]      pub unsafe fn cleanup() { realargs::cleanup() }\n \n /// Take the global arguments from global storage.\n-#[cfg(not(test))] pub fn take() -> Option<~[~[u8]]> { imp::take() }\n-#[cfg(test)]      pub fn take() -> Option<~[~[u8]]> {\n+#[cfg(not(test))] pub fn take() -> Option<Vec<~[u8]>> { imp::take() }\n+#[cfg(test)]      pub fn take() -> Option<Vec<~[u8]>> {\n     match realargs::take() {\n-        realstd::option::Some(a) => Some(a),\n+        realstd::option::Some(v) => Some(unsafe{ ::cast::transmute(v) }),\n         realstd::option::None => None,\n     }\n }\n \n /// Give the global arguments to global storage.\n ///\n /// It is an error if the arguments already exist.\n-#[cfg(not(test))] pub fn put(args: ~[~[u8]]) { imp::put(args) }\n-#[cfg(test)]      pub fn put(args: ~[~[u8]]) { realargs::put(args) }\n+#[cfg(not(test))] pub fn put(args: Vec<~[u8]>) { imp::put(args) }\n+#[cfg(test)]      pub fn put(args: Vec<~[u8]>) { realargs::put(unsafe { ::cast::transmute(args) }) }\n \n /// Make a clone of the global arguments.\n-#[cfg(not(test))] pub fn clone() -> Option<~[~[u8]]> { imp::clone() }\n-#[cfg(test)]      pub fn clone() -> Option<~[~[u8]]> {\n+#[cfg(not(test))] pub fn clone() -> Option<Vec<~[u8]>> { imp::clone() }\n+#[cfg(test)]      pub fn clone() -> Option<Vec<~[u8]>> {\n     match realargs::clone() {\n-        realstd::option::Some(a) => Some(a),\n+        realstd::option::Some(v) => Some(unsafe { ::cast::transmute(v) }),\n         realstd::option::None => None,\n     }\n }\n@@ -70,6 +71,7 @@ mod imp {\n     use owned::Box;\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n+    use vec::Vec;\n     #[cfg(not(test))] use ptr::RawPtr;\n \n     static mut global_args_ptr: uint = 0;\n@@ -87,26 +89,26 @@ mod imp {\n         lock.destroy();\n     }\n \n-    pub fn take() -> Option<~[~[u8]]> {\n+    pub fn take() -> Option<Vec<~[u8]>> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             let val = mem::replace(&mut *ptr, None);\n-            val.as_ref().map(|s: &Box<~[~[u8]]>| (**s).clone())\n+            val.as_ref().map(|s: &Box<Vec<~[u8]>>| (**s).clone())\n         })\n     }\n \n-    pub fn put(args: ~[~[u8]]) {\n+    pub fn put(args: Vec<~[u8]>) {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             rtassert!((*ptr).is_none());\n             (*ptr) = Some(box args.clone());\n         })\n     }\n \n-    pub fn clone() -> Option<~[~[u8]]> {\n+    pub fn clone() -> Option<Vec<~[u8]>> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n-            (*ptr).as_ref().map(|s: &Box<~[~[u8]]>| (**s).clone())\n+            (*ptr).as_ref().map(|s: &Box<Vec<~[u8]>>| (**s).clone())\n         })\n     }\n \n@@ -117,13 +119,13 @@ mod imp {\n         }\n     }\n \n-    fn get_global_ptr() -> *mut Option<Box<~[~[u8]]>> {\n+    fn get_global_ptr() -> *mut Option<Box<Vec<~[u8]>>> {\n         unsafe { cast::transmute(&global_args_ptr) }\n     }\n \n     // Copied from `os`.\n     #[cfg(not(test))]\n-    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~[u8]] {\n+    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> Vec<~[u8]> {\n         use c_str::CString;\n         use ptr::RawPtr;\n         use libc;\n@@ -133,7 +135,7 @@ mod imp {\n         Vec::from_fn(argc as uint, |i| {\n             let cs = CString::new(*(argv as **libc::c_char).offset(i as int), false);\n             cs.as_bytes_no_nul().to_owned()\n-        }).move_iter().collect()\n+        })\n     }\n \n     #[cfg(test)]\n@@ -147,7 +149,7 @@ mod imp {\n             // Preserve the actual global state.\n             let saved_value = take();\n \n-            let expected = box [bytes!(\"happy\").to_owned(), bytes!(\"today?\").to_owned()];\n+            let expected = vec![bytes!(\"happy\").to_owned(), bytes!(\"today?\").to_owned()];\n \n             put(expected.clone());\n             assert!(clone() == Some(expected.clone()));\n@@ -170,22 +172,23 @@ mod imp {\n #[cfg(target_os = \"win32\", not(test))]\n mod imp {\n     use option::Option;\n+    use vec::Vec;\n \n     pub unsafe fn init(_argc: int, _argv: **u8) {\n     }\n \n     pub fn cleanup() {\n     }\n \n-    pub fn take() -> Option<~[~[u8]]> {\n+    pub fn take() -> Option<Vec<~[u8]>> {\n         fail!()\n     }\n \n-    pub fn put(_args: ~[~[u8]]) {\n+    pub fn put(_args: Vec<~[u8]>) {\n         fail!()\n     }\n \n-    pub fn clone() -> Option<~[~[u8]]> {\n+    pub fn clone() -> Option<Vec<~[u8]>> {\n         fail!()\n     }\n }"}, {"sha": "ccde8d9c96af08cf15bcc141624531a4d5009aab", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -161,7 +161,7 @@ pub trait IoFactory {\n     fn unix_connect(&mut self, path: &CString,\n                     timeout: Option<u64>) -> IoResult<Box<RtioPipe:Send>>;\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> IoResult<~[ai::Info]>;\n+                          hint: Option<ai::Hint>) -> IoResult<Vec<ai::Info>>;\n \n     // filesystem operations\n     fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n@@ -191,7 +191,7 @@ pub trait IoFactory {\n     fn timer_init(&mut self) -> IoResult<Box<RtioTimer:Send>>;\n     fn spawn(&mut self, config: ProcessConfig)\n             -> IoResult<(Box<RtioProcess:Send>,\n-                         ~[Option<Box<RtioPipe:Send>>])>;\n+                         Vec<Option<Box<RtioPipe:Send>>>)>;\n     fn kill(&mut self, pid: libc::pid_t, signal: int) -> IoResult<()>;\n     fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe:Send>>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)"}, {"sha": "21084407b8d09db070560c5f4a64e06246f86311", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 102, "deletions": 185, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -127,53 +127,34 @@ pub trait VectorVector<T> {\n     // FIXME #5898: calling these .concat and .connect conflicts with\n     // StrVector::con{cat,nect}, since they have generic contents.\n     /// Flattens a vector of vectors of T into a single vector of T.\n-    fn concat_vec(&self) -> ~[T];\n+    fn concat_vec(&self) -> Vec<T>;\n \n     /// Concatenate a vector of vectors, placing a given separator between each.\n-    fn connect_vec(&self, sep: &T) -> ~[T];\n+    fn connect_vec(&self, sep: &T) -> Vec<T>;\n }\n \n impl<'a, T: Clone, V: Vector<T>> VectorVector<T> for &'a [V] {\n-    fn concat_vec(&self) -> ~[T] {\n+    fn concat_vec(&self) -> Vec<T> {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size);\n         for v in self.iter() {\n             result.push_all(v.as_slice())\n         }\n-        result.move_iter().collect()\n+        result\n     }\n \n-    fn connect_vec(&self, sep: &T) -> ~[T] {\n+    fn connect_vec(&self, sep: &T) -> Vec<T> {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self.iter() {\n             if first { first = false } else { result.push(sep.clone()) }\n             result.push_all(v.as_slice())\n         }\n-        result.move_iter().collect()\n+        result\n     }\n }\n \n-/**\n- * Convert an iterator of pairs into a pair of vectors.\n- *\n- * Returns a tuple containing two vectors where the i-th element of the first\n- * vector contains the first element of the i-th tuple of the input iterator,\n- * and the i-th element of the second vector contains the second element\n- * of the i-th tuple of the input iterator.\n- */\n-pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {\n-    let (lo, _) = iter.size_hint();\n-    let mut ts = Vec::with_capacity(lo);\n-    let mut us = Vec::with_capacity(lo);\n-    for (t, u) in iter {\n-        ts.push(t);\n-        us.push(u);\n-    }\n-    (ts.move_iter().collect(), us.move_iter().collect())\n-}\n-\n /// An Iterator that yields the element swaps needed to produce\n /// a sequence of all possible permutations for an indexed sequence of\n /// elements. Each permutation is only a single swap apart.\n@@ -185,7 +166,7 @@ pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n pub struct ElementSwaps {\n-    sdir: ~[SizeDirection],\n+    sdir: Vec<SizeDirection>,\n     /// If true, emit the last swap that returns the sequence to initial state\n     emit_reset: bool,\n     swaps_made : uint,\n@@ -199,9 +180,7 @@ impl ElementSwaps {\n         // element (equal to the original index).\n         ElementSwaps{\n             emit_reset: true,\n-            sdir: range(0, length)\n-                    .map(|i| SizeDirection{ size: i, dir: Neg })\n-                    .collect::<~[_]>(),\n+            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n             swaps_made: 0\n         }\n     }\n@@ -228,12 +207,12 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n         let max = self.sdir.iter().map(|&x| x).enumerate()\n                            .filter(|&(i, sd)|\n                                 new_pos(i, sd.dir) < self.sdir.len() &&\n-                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n+                                self.sdir.get(new_pos(i, sd.dir)).size < sd.size)\n                            .max_by(|&(_, sd)| sd.size);\n         match max {\n             Some((i, sd)) => {\n                 let j = new_pos(i, sd.dir);\n-                self.sdir.swap(i, j);\n+                self.sdir.as_mut_slice().swap(i, j);\n \n                 // Swap the direction of each larger SizeDirection\n                 for x in self.sdir.mut_iter() {\n@@ -314,16 +293,29 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n+        use RawVec = core::raw::Vec;\n+        use rt::global_heap::{malloc_raw, exchange_free};\n+        use num::{CheckedAdd, CheckedMul};\n+        use option::Expect;\n+\n         let len = self.len();\n-        let mut result = Vec::with_capacity(len);\n-        // Unsafe code so this can be optimised to a memcpy (or something\n-        // similarly fast) when T is Copy. LLVM is easily confused, so any\n-        // extra operations during the loop can prevent this optimisation\n+        let data_size = len.checked_mul(&mem::size_of::<T>());\n+        let data_size = data_size.expect(\"overflow in to_owned()\");\n+        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n+        let size = size.expect(\"overflow in to_owned()\");\n+\n         unsafe {\n+            let ret = malloc_raw(size) as *mut RawVec<()>;\n+\n+            (*ret).fill = len * mem::nonzero_size_of::<T>();\n+            (*ret).alloc = len * mem::nonzero_size_of::<T>();\n+\n+            // Be careful with the following loop. We want it to be optimized\n+            // to a memcpy (or something similarly fast) when T is Copy. LLVM\n+            // is easily confused, so any extra operations during the loop can\n+            // prevent this optimization.\n             let mut i = 0;\n-            let p = result.as_mut_ptr();\n-            // Use try_finally here otherwise the write to length\n-            // inside the loop stops LLVM from optimising this.\n+            let p = &mut (*ret).data as *mut _ as *mut T;\n             try_finally(\n                 &mut i, (),\n                 |i, ()| while *i < len {\n@@ -332,9 +324,15 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n                         self.unsafe_ref(*i).clone());\n                     *i += 1;\n                 },\n-                |i| result.set_len(*i));\n+                |i| if *i < len {\n+                    // we must be failing, clean up after ourselves\n+                    for j in range(0, *i as int) {\n+                        ptr::read(&*p.offset(j));\n+                    }\n+                    exchange_free(ret as *u8);\n+                });\n+            cast::transmute(ret)\n         }\n-        result.move_iter().collect()\n     }\n \n     #[inline(always)]\n@@ -354,7 +352,7 @@ impl<T: Clone> CloneableVector<T> for ~[T] {\n pub trait ImmutableCloneableVector<T> {\n     /// Partitions the vector into two vectors `(A,B)`, where all\n     /// elements of `A` satisfy `f` and all elements of `B` do not.\n-    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);\n+    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n \n     /// Create an iterator that yields every possible permutation of the\n     /// vector in succession.\n@@ -363,7 +361,7 @@ pub trait ImmutableCloneableVector<T> {\n \n impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n     #[inline]\n-    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n+    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n \n@@ -375,7 +373,7 @@ impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n             }\n         }\n \n-        (lefts.move_iter().collect(), rights.move_iter().collect())\n+        (lefts, rights)\n     }\n \n     fn permutations(self) -> Permutations<T> {\n@@ -412,7 +410,7 @@ pub trait OwnedVector<T> {\n      * Partitions the vector into two vectors `(A,B)`, where all\n      * elements of `A` satisfy `f` and all elements of `B` do not.\n      */\n-    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n+    fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n@@ -432,7 +430,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]) {\n+    fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n \n@@ -444,7 +442,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             }\n         }\n \n-        (lefts.move_iter().collect(), rights.move_iter().collect())\n+        (lefts, rights)\n     }\n }\n \n@@ -729,45 +727,10 @@ impl<'a, T: TotalOrd> MutableTotalOrdVector<T> for &'a mut [T] {\n     }\n }\n \n-/**\n-* Constructs a vector from an unsafe pointer to a buffer\n-*\n-* # Arguments\n-*\n-* * ptr - An unsafe pointer to a buffer of `T`\n-* * elts - The number of elements in the buffer\n-*/\n-// Wrapper for fn in raw: needs to be called by net_tcp::on_tcp_read_cb\n-pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n-    raw::from_buf_raw(ptr, elts)\n-}\n-\n /// Unsafe operations\n pub mod raw {\n-    use iter::Iterator;\n-    use ptr;\n-    use slice::{MutableVector, OwnedVector};\n-    use vec::Vec;\n-\n     pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};\n     pub use core::slice::raw::{shift_ptr, pop_ptr};\n-\n-    /**\n-    * Constructs a vector from an unsafe pointer to a buffer\n-    *\n-    * # Arguments\n-    *\n-    * * ptr - An unsafe pointer to a buffer of `T`\n-    * * elts - The number of elements in the buffer\n-    */\n-    // Was in raw, but needs to be called by net_tcp::on_tcp_read_cb\n-    #[inline]\n-    pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n-        let mut dst = Vec::with_capacity(elts);\n-        dst.set_len(elts);\n-        ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n-        dst.move_iter().collect()\n-    }\n }\n \n /// An iterator that moves out of a vector.\n@@ -827,31 +790,6 @@ mod tests {\n \n     fn is_odd(n: &uint) -> bool { *n % 2u == 1u }\n \n-    #[test]\n-    fn test_unsafe_ptrs() {\n-        unsafe {\n-            // Test on-stack copy-from-buf.\n-            let a = box [1, 2, 3];\n-            let mut ptr = a.as_ptr();\n-            let b = from_buf(ptr, 3u);\n-            assert_eq!(b.len(), 3u);\n-            assert_eq!(b[0], 1);\n-            assert_eq!(b[1], 2);\n-            assert_eq!(b[2], 3);\n-\n-            // Test on-heap copy-from-buf.\n-            let c = box [1, 2, 3, 4, 5];\n-            ptr = c.as_ptr();\n-            let d = from_buf(ptr, 5u);\n-            assert_eq!(d.len(), 5u);\n-            assert_eq!(d[0], 1);\n-            assert_eq!(d[1], 2);\n-            assert_eq!(d[2], 3);\n-            assert_eq!(d[3], 4);\n-            assert_eq!(d[4], 5);\n-        }\n-    }\n-\n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n@@ -1230,17 +1168,6 @@ mod tests {\n         assert_eq!(v, vec![1, 3, 5]);\n     }\n \n-    #[test]\n-    fn test_zip_unzip() {\n-        let z1 = vec![(1, 4), (2, 5), (3, 6)];\n-\n-        let (left, right) = unzip(z1.iter().map(|&x| x));\n-\n-        assert_eq!((1, 4), (left[0], right[0]));\n-        assert_eq!((2, 5), (left[1], right[1]));\n-        assert_eq!((3, 6), (left[2], right[2]));\n-    }\n-\n     #[test]\n     fn test_element_swaps() {\n         let mut v = [1, 2, 3];\n@@ -1425,7 +1352,7 @@ mod tests {\n                         let n = task_rng().gen::<uint>() % 10;\n                         counts[n] += 1;\n                         (n, counts[n])\n-                    }).collect::<~[(uint, int)]>();\n+                    }).collect::<Vec<(uint, int)>>();\n \n                 // only sort on the first element, so an unstable sort\n                 // may mix up the counts.\n@@ -1436,46 +1363,45 @@ mod tests {\n                 // will need to be ordered with increasing\n                 // counts... i.e. exactly asserting that this sort is\n                 // stable.\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+                assert!(v.as_slice().windows(2).all(|w| w[0] <= w[1]));\n             }\n         }\n     }\n \n     #[test]\n     fn test_partition() {\n-        assert_eq!((box []).partition(|x: &int| *x < 3), (box [], box []));\n-        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 4), (box [1, 2, 3], box []));\n-        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 2), (box [1], box [2, 3]));\n-        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 0), (box [], box [1, 2, 3]));\n+        assert_eq!((box []).partition(|x: &int| *x < 3), (vec![], vec![]));\n+        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n     fn test_partitioned() {\n-        assert_eq!(([]).partitioned(|x: &int| *x < 3), (box [], box []))\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 4), (box [1, 2, 3], box []));\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 2), (box [1], box [2, 3]));\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 0), (box [], box [1, 2, 3]));\n+        assert_eq!(([]).partitioned(|x: &int| *x < 3), (vec![], vec![]));\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n     fn test_concat() {\n         let v: [~[int], ..0] = [];\n-        assert_eq!(v.concat_vec(), box []);\n-        assert_eq!([box [1], box [2,3]].concat_vec(), box [1, 2, 3]);\n+        assert_eq!(v.concat_vec(), vec![]);\n+        assert_eq!([box [1], box [2,3]].concat_vec(), vec![1, 2, 3]);\n \n-        assert_eq!([&[1], &[2,3]].concat_vec(), box [1, 2, 3]);\n+        assert_eq!([&[1], &[2,3]].concat_vec(), vec![1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n         let v: [~[int], ..0] = [];\n-        assert_eq!(v.connect_vec(&0), box []);\n-        assert_eq!([box [1], box [2, 3]].connect_vec(&0), box [1, 0, 2, 3]);\n-        assert_eq!([box [1], box [2], box [3]].connect_vec(&0), box [1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect_vec(&0), vec![]);\n+        assert_eq!([box [1], box [2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([box [1], box [2], box [3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n \n-        assert_eq!(v.connect_vec(&0), box []);\n-        assert_eq!([&[1], &[2, 3]].connect_vec(&0), box [1, 0, 2, 3]);\n-        assert_eq!([&[1], &[2], &[3]].connect_vec(&0), box [1, 0, 2, 0, 3]);\n+        assert_eq!([&[1], &[2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([&[1], &[2], &[3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -1773,74 +1699,74 @@ mod tests {\n     fn test_splitator() {\n         let xs = &[1i,2,3,4,5];\n \n-        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   box [&[1], &[3], &[5]]);\n-        assert_eq!(xs.split(|x| *x == 1).collect::<~[&[int]]>(),\n-                   box [&[], &[2,3,4,5]]);\n-        assert_eq!(xs.split(|x| *x == 5).collect::<~[&[int]]>(),\n-                   box [&[1,2,3,4], &[]]);\n-        assert_eq!(xs.split(|x| *x == 10).collect::<~[&[int]]>(),\n-                   box [&[1,2,3,4,5]]);\n-        assert_eq!(xs.split(|_| true).collect::<~[&[int]]>(),\n-                   box [&[], &[], &[], &[], &[], &[]]);\n+        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[1], &[3], &[5]]);\n+        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[], &[2,3,4,5]]);\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[1,2,3,4], &[]]);\n+        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[1,2,3,4,5]]);\n+        assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[], &[], &[], &[], &[], &[]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<~[&[int]]>(), box [&[]]);\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n     }\n \n     #[test]\n     fn test_splitnator() {\n         let xs = &[1i,2,3,4,5];\n \n-        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   box [&[1,2,3,4,5]]);\n-        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   box [&[1], &[3,4,5]]);\n-        assert_eq!(xs.splitn(3, |_| true).collect::<~[&[int]]>(),\n-                   box [&[], &[], &[], &[4,5]]);\n+        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[1,2,3,4,5]]);\n+        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[1], &[3,4,5]]);\n+        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[], &[], &[], &[4,5]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<~[&[int]]>(), box [&[]]);\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n     }\n \n     #[test]\n     fn test_rsplitator() {\n         let xs = &[1i,2,3,4,5];\n \n-        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<~[&[int]]>(),\n-                   box [&[5], &[3], &[1]]);\n-        assert_eq!(xs.split(|x| *x == 1).rev().collect::<~[&[int]]>(),\n-                   box [&[2,3,4,5], &[]]);\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<~[&[int]]>(),\n-                   box [&[], &[1,2,3,4]]);\n-        assert_eq!(xs.split(|x| *x == 10).rev().collect::<~[&[int]]>(),\n-                   box [&[1,2,3,4,5]]);\n+        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[5], &[3], &[1]]);\n+        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[2,3,4,5], &[]]);\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[], &[1,2,3,4]]);\n+        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[1,2,3,4,5]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<~[&[int]]>(), box [&[]]);\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n     }\n \n     #[test]\n     fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n-        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   box [&[1,2,3,4,5]]);\n-        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   box [&[5], &[1,2,3]]);\n-        assert_eq!(xs.rsplitn(3, |_| true).collect::<~[&[int]]>(),\n-                   box [&[], &[], &[], &[1,2]]);\n+        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[1,2,3,4,5]]);\n+        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[5], &[1,2,3]]);\n+        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n+                   &[&[], &[], &[], &[1,2]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<~[&[int]]>(), box [&[]]);\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), &[&[]]);\n     }\n \n     #[test]\n     fn test_windowsator() {\n         let v = &[1i,2,3,4];\n \n-        assert_eq!(v.windows(2).collect::<~[&[int]]>(), box [&[1,2], &[2,3], &[3,4]]);\n-        assert_eq!(v.windows(3).collect::<~[&[int]]>(), box [&[1i,2,3], &[2,3,4]]);\n+        assert_eq!(v.windows(2).collect::<Vec<&[int]>>().as_slice(), &[&[1,2], &[2,3], &[3,4]]);\n+        assert_eq!(v.windows(3).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2,3], &[2,3,4]]);\n         assert!(v.windows(6).next().is_none());\n     }\n \n@@ -1855,11 +1781,11 @@ mod tests {\n     fn test_chunksator() {\n         let v = &[1i,2,3,4,5];\n \n-        assert_eq!(v.chunks(2).collect::<~[&[int]]>(), box [&[1i,2], &[3,4], &[5]]);\n-        assert_eq!(v.chunks(3).collect::<~[&[int]]>(), box [&[1i,2,3], &[4,5]]);\n-        assert_eq!(v.chunks(6).collect::<~[&[int]]>(), box [&[1i,2,3,4,5]]);\n+        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2], &[3,4], &[5]]);\n+        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2,3], &[4,5]]);\n+        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>().as_slice(), &[&[1i,2,3,4,5]]);\n \n-        assert_eq!(v.chunks(2).rev().collect::<~[&[int]]>(), box [&[5i], &[3,4], &[1,2]]);\n+        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>().as_slice(), &[&[5i], &[3,4], &[1,2]]);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n         assert_eq!(it.idx(0).unwrap(), &[1,2]);\n@@ -2237,15 +2163,6 @@ mod bench {\n         })\n     }\n \n-    #[bench]\n-    fn add(b: &mut Bencher) {\n-        let xs: &[int] = [5, ..10];\n-        let ys: &[int] = [5, ..10];\n-        b.iter(|| {\n-            xs + ys;\n-        });\n-    }\n-\n     #[bench]\n     fn concat(b: &mut Bencher) {\n         let xss: Vec<Vec<uint>> = Vec::from_fn(100, |i| range(0, i).collect());"}, {"sha": "fb3dcc972871d67ac51fb365bd2ad57767e7ea26", "filename": "src/libstd/str.rs", "status": "modified", "additions": 91, "deletions": 98, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -85,10 +85,9 @@ use fmt;\n use io::Writer;\n use iter::{Iterator, range, AdditiveIterator};\n use option::{None, Option, Some};\n-use ptr;\n use from_str::FromStr;\n-use slice::{OwnedVector, ImmutableVector, MutableVector};\n-use slice::{Vector};\n+use slice::{ImmutableVector, MutableVector, CloneableVector};\n+use slice::Vector;\n use vec::Vec;\n use default::Default;\n use strbuf::StrBuf;\n@@ -668,25 +667,22 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n /// Unsafe operations\n pub mod raw {\n     use cast;\n-    use iter::Iterator;\n     use libc;\n     use ptr::RawPtr;\n-    use ptr;\n-    use slice::{MutableVector, OwnedVector, Vector};\n-    use str::{is_utf8};\n-    use vec::Vec;\n+    use raw::Slice;\n+    use slice::CloneableVector;\n+    use str::{is_utf8, StrAllocating};\n \n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n     pub use core::str::raw::{slice_unchecked};\n \n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n-        let mut v = Vec::with_capacity(len);\n-        ptr::copy_memory(v.as_mut_ptr(), buf, len);\n-        v.set_len(len);\n-\n-        assert!(is_utf8(v.as_slice()));\n-        ::cast::transmute(v.move_iter().collect::<~[u8]>())\n+        let v = Slice { data: buf, len: len };\n+        let bytes: &[u8] = ::cast::transmute(v);\n+        assert!(is_utf8(bytes));\n+        let s: &str = ::cast::transmute(bytes);\n+        s.to_owned()\n     }\n \n     #[lang=\"strdup_uniq\"]\n@@ -824,27 +820,23 @@ pub trait StrAllocating: Str {\n     /// Copy a slice into a new owned str.\n     #[inline]\n     fn to_owned(&self) -> ~str {\n-        let me = self.as_slice();\n-        let len = me.len();\n-        unsafe {\n-            let mut v = Vec::with_capacity(len);\n+        use slice::Vector;\n \n-            ptr::copy_memory(v.as_mut_ptr(), me.as_ptr(), len);\n-            v.set_len(len);\n-            ::cast::transmute(v.move_iter().collect::<~[u8]>())\n+        unsafe {\n+            ::cast::transmute(self.as_slice().as_bytes().to_owned())\n         }\n     }\n \n     /// Converts to a vector of `u16` encoded as UTF-16.\n-    fn to_utf16(&self) -> ~[u16] {\n+    fn to_utf16(&self) -> Vec<u16> {\n         let me = self.as_slice();\n-        let mut u = Vec::new();;\n+        let mut u = Vec::new();\n         for ch in me.chars() {\n             let mut buf = [0u16, ..2];\n             let n = ch.encode_utf16(buf /* as mut slice! */);\n             u.push_all(buf.slice_to(n));\n         }\n-        u.move_iter().collect()\n+        u\n     }\n \n     /// Given a string, make a new string with repeated copies of it.\n@@ -1554,7 +1546,8 @@ mod tests {\n         assert_eq!(a.subslice_offset(c), 0);\n \n         let string = \"a\\nb\\nc\";\n-        let lines: ~[&str] = string.lines().collect();\n+        let lines: Vec<&str> = string.lines().collect();\n+        let lines = lines.as_slice();\n         assert_eq!(string.subslice_offset(lines[0]), 0);\n         assert_eq!(string.subslice_offset(lines[1]), 2);\n         assert_eq!(string.subslice_offset(lines[2]), 4);\n@@ -1617,21 +1610,21 @@ mod tests {\n     fn test_utf16() {\n         let pairs =\n             [(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\".to_owned(),\n-              box [0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n+              vec![0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n                 0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n                 0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n                 0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n \n              (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\".to_owned(),\n-              box [0xd801_u16, 0xdc12_u16, 0xd801_u16,\n+              vec![0xd801_u16, 0xdc12_u16, 0xd801_u16,\n                 0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n                 0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n                 0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n                 0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n                 0x000a_u16]),\n \n              (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\".to_owned(),\n-              box [0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n+              vec![0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n                 0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n                 0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n                 0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n@@ -1640,7 +1633,7 @@ mod tests {\n                 0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n \n              (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\".to_owned(),\n-              box [0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n+              vec![0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n                 0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n                 0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n                 0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n@@ -1653,18 +1646,18 @@ mod tests {\n                 0x000a_u16 ]),\n              // Issue #12318, even-numbered non-BMP planes\n              (\"\\U00020000\".to_owned(),\n-              box [0xD840, 0xDC00])];\n+              vec![0xD840, 0xDC00])];\n \n         for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n-            assert!(is_utf16(u));\n+            assert!(is_utf16(u.as_slice()));\n             assert_eq!(s.to_utf16(), u);\n \n-            assert_eq!(from_utf16(u).unwrap(), s);\n-            assert_eq!(from_utf16_lossy(u), s);\n+            assert_eq!(from_utf16(u.as_slice()).unwrap(), s);\n+            assert_eq!(from_utf16_lossy(u.as_slice()), s);\n \n-            assert_eq!(from_utf16(s.to_utf16()).unwrap(), s);\n-            assert_eq!(from_utf16(u).unwrap().to_utf16(), u);\n+            assert_eq!(from_utf16(s.to_utf16().as_slice()).unwrap(), s);\n+            assert_eq!(from_utf16(u.as_slice()).unwrap().to_utf16(), u);\n         }\n     }\n \n@@ -1921,105 +1914,105 @@ mod tests {\n     fn test_split_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.split(' ').collect();\n-        assert_eq!( split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.split(' ').collect();\n+        assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.split(' ').rev().collect();\n+        let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let split: ~[&str] = data.split(|c: char| c == ' ').collect();\n-        assert_eq!( split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n+        assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.split(|c: char| c == ' ').rev().collect();\n+        let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let split: ~[&str] = data.split('\u00e4').collect();\n-        assert_eq!( split, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        let split: Vec<&str> = data.split('\u00e4').collect();\n+        assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.split('\u00e4').rev().collect();\n+        let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let split: ~[&str] = data.split(|c: char| c == '\u00e4').collect();\n-        assert_eq!( split, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n+        assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.split(|c: char| c == '\u00e4').rev().collect();\n+        let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n \n     #[test]\n     fn test_splitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.splitn(' ', 3).collect();\n-        assert_eq!(split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.splitn(' ', 3).collect();\n+        assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: ~[&str] = data.splitn(|c: char| c == ' ', 3).collect();\n-        assert_eq!(split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.splitn(|c: char| c == ' ', 3).collect();\n+        assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let split: ~[&str] = data.splitn('\u00e4', 3).collect();\n-        assert_eq!(split, box [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.splitn('\u00e4', 3).collect();\n+        assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: ~[&str] = data.splitn(|c: char| c == '\u00e4', 3).collect();\n-        assert_eq!(split, box [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.splitn(|c: char| c == '\u00e4', 3).collect();\n+        assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n     #[test]\n     fn test_rsplitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let mut split: ~[&str] = data.rsplitn(' ', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(' ', 3).collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut split: ~[&str] = data.rsplitn(|c: char| c == ' ', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(|c: char| c == ' ', 3).collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let mut split: ~[&str] = data.rsplitn('\u00e4', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn('\u00e4', 3).collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut split: ~[&str] = data.rsplitn(|c: char| c == '\u00e4', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(|c: char| c == '\u00e4', 3).collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n \n     #[test]\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.split('\\n').collect();\n-        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+        let split: Vec<&str> = data.split('\\n').collect();\n+        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n-        let split: ~[&str] = data.split_terminator('\\n').collect();\n-        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+        let split: Vec<&str> = data.split_terminator('\\n').collect();\n+        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_rev_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let mut split: ~[&str] = data.split('\\n').rev().collect();\n+        let mut split: Vec<&str> = data.split('\\n').rev().collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n-        let mut split: ~[&str] = data.split_terminator('\\n').rev().collect();\n+        let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_words() {\n         let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-        let words: ~[&str] = data.words().collect();\n-        assert_eq!(words, box [\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n+        let words: Vec<&str> = data.words().collect();\n+        assert_eq!(words, vec![\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n     }\n \n     #[test]\n@@ -2053,34 +2046,34 @@ mod tests {\n     #[test]\n     fn test_lines() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        let lines: ~[&str] = data.lines().collect();\n-        assert_eq!(lines, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        let lines: Vec<&str> = data.lines().collect();\n+        assert_eq!(lines, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n \n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n-        let lines: ~[&str] = data.lines().collect();\n-        assert_eq!(lines, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        let lines: Vec<&str> = data.lines().collect();\n+        assert_eq!(lines, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_split_strator() {\n-        fn t<'a>(s: &str, sep: &'a str, u: ~[&str]) {\n-            let v: ~[&str] = s.split_str(sep).collect();\n-            assert_eq!(v, u);\n+        fn t(s: &str, sep: &str, u: &[&str]) {\n+            let v: Vec<&str> = s.split_str(sep).collect();\n+            assert_eq!(v.as_slice(), u.as_slice());\n         }\n-        t(\"--1233345--\", \"12345\", box [\"--1233345--\"]);\n-        t(\"abc::hello::there\", \"::\", box [\"abc\", \"hello\", \"there\"]);\n-        t(\"::hello::there\", \"::\", box [\"\", \"hello\", \"there\"]);\n-        t(\"hello::there::\", \"::\", box [\"hello\", \"there\", \"\"]);\n-        t(\"::hello::there::\", \"::\", box [\"\", \"hello\", \"there\", \"\"]);\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", box [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n-        t(\"zzXXXzzYYYzz\", \"zz\", box [\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"zzXXXzYYYz\", \"XXX\", box [\"zz\", \"zYYYz\"]);\n-        t(\".XXX.YYY.\", \".\", box [\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"\", \".\", box [\"\"]);\n-        t(\"zz\", \"zz\", box [\"\",\"\"]);\n-        t(\"ok\", \"z\", box [\"ok\"]);\n-        t(\"zzz\", \"zz\", box [\"\",\"z\"]);\n-        t(\"zzzzz\", \"zz\", box [\"\",\"\",\"z\"]);\n+        t(\"--1233345--\", \"12345\", [\"--1233345--\"]);\n+        t(\"abc::hello::there\", \"::\", [\"abc\", \"hello\", \"there\"]);\n+        t(\"::hello::there\", \"::\", [\"\", \"hello\", \"there\"]);\n+        t(\"hello::there::\", \"::\", [\"hello\", \"there\", \"\"]);\n+        t(\"::hello::there::\", \"::\", [\"\", \"hello\", \"there\", \"\"]);\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n+        t(\"zzXXXzzYYYzz\", \"zz\", [\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"zzXXXzYYYz\", \"XXX\", [\"zz\", \"zYYYz\"]);\n+        t(\".XXX.YYY.\", \".\", [\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"\", \".\", [\"\"]);\n+        t(\"zz\", \"zz\", [\"\",\"\"]);\n+        t(\"ok\", \"z\", [\"ok\"]);\n+        t(\"zzz\", \"zz\", [\"\",\"z\"]);\n+        t(\"zzzzz\", \"zz\", [\"\",\"\",\"z\"]);\n     }\n \n     #[test]"}, {"sha": "8e05b2f527d0830903ad9dead6ec053099906be0", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -19,7 +19,7 @@ use io::Writer;\n use iter::{Extendable, FromIterator, Iterator, range};\n use option::{None, Option, Some};\n use ptr::RawPtr;\n-use slice::{OwnedVector, Vector};\n+use slice::{OwnedVector, Vector, CloneableVector};\n use str::{OwnedStr, Str, StrSlice, StrAllocating};\n use str;\n use vec::Vec;\n@@ -273,11 +273,8 @@ impl Str for StrBuf {\n impl StrAllocating for StrBuf {\n     #[inline]\n     fn into_owned(self) -> ~str {\n-        let StrBuf {\n-            vec: vec\n-        } = self;\n         unsafe {\n-            cast::transmute::<~[u8],~str>(vec.move_iter().collect())\n+            cast::transmute(self.vec.as_slice().to_owned())\n         }\n     }\n "}, {"sha": "676c836c459d72458a6abd468ea213dda1ad628c", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -69,14 +69,14 @@ impl<T: Send> UnsafeArc<T> {\n \n     /// As new(), but returns a vector of as many pre-cloned handles as\n     /// requested.\n-    pub fn newN(data: T, num_handles: uint) -> ~[UnsafeArc<T>] {\n+    pub fn newN(data: T, num_handles: uint) -> Vec<UnsafeArc<T>> {\n         unsafe {\n             if num_handles == 0 {\n-                box [] // need to free data here\n+                vec![] // need to free data here\n             } else {\n                 let ptr = new_inner(data, num_handles);\n                 let v = Vec::from_fn(num_handles, |_| UnsafeArc { data: ptr });\n-                v.move_iter().collect()\n+                v\n             }\n         }\n     }"}, {"sha": "8dfd691e6ffdc09f500af0e84d4d8c26a5aad01f", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -407,7 +407,7 @@ mod tests {\n     use rand::Rng;\n     use sync::atomics::{AtomicBool, INIT_ATOMIC_BOOL, SeqCst,\n                         AtomicUint, INIT_ATOMIC_UINT};\n-    use slice;\n+    use vec;\n \n     #[test]\n     fn smoke() {\n@@ -603,7 +603,7 @@ mod tests {\n         let mut pool = BufferPool::<(int, uint)>::new();\n         let (mut w, s) = pool.deque();\n \n-        let (threads, hits) = slice::unzip(range(0, NTHREADS).map(|_| {\n+        let (threads, hits) = vec::unzip(range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n             let unique_box = box AtomicUint::new(0);\n             let thread_box = unsafe {"}, {"sha": "e2a9f6a5c4821c481ace94816a41577fcdf4c6fa", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -18,13 +18,16 @@ A simple wrapper over the platform's dynamic library facilities\n \n use c_str::ToCStr;\n use cast;\n+use iter::Iterator;\n use ops::*;\n use option::*;\n use os;\n use path::GenericPath;\n use path;\n use result::*;\n+use slice::{Vector,OwnedVector};\n use str;\n+use vec::Vec;\n \n pub struct DynamicLibrary { handle: *u8}\n \n@@ -73,8 +76,10 @@ impl DynamicLibrary {\n             (\"LD_LIBRARY_PATH\", ':' as u8)\n         };\n         let newenv = os::getenv_as_bytes(envvar).unwrap_or(box []);\n-        let newenv = newenv + &[sep] + path.as_vec();\n-        os::setenv(envvar, str::from_utf8(newenv).unwrap());\n+        let mut newenv = newenv.move_iter().collect::<Vec<_>>();\n+        newenv.push_all(&[sep]);\n+        newenv.push_all(path.as_vec());\n+        os::setenv(envvar, str::from_utf8(newenv.as_slice()).unwrap());\n     }\n \n     /// Access the value at the symbol of the dynamic library"}, {"sha": "da01da26709598e95df0ca54dad5ed4fc0964504", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 167, "deletions": 1, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -22,12 +22,13 @@ use mem::{size_of, move_val_init};\n use mem;\n use num;\n use num::{CheckedMul, CheckedAdd};\n-use ops::Drop;\n+use ops::{Add, Drop};\n use option::{None, Option, Some, Expect};\n use ptr::RawPtr;\n use ptr;\n use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n+use RawVec = raw::Vec;\n use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n use slice::{MutableTotalOrdVector, OwnedVector, Vector};\n use slice::{MutableVectorAllocating};\n@@ -1370,6 +1371,16 @@ impl<T> Vector<T> for Vec<T> {\n     }\n }\n \n+impl<T: Clone, V: Vector<T>> Add<V, Vec<T>> for Vec<T> {\n+    #[inline]\n+    fn add(&self, rhs: &V) -> Vec<T> {\n+        let mut res = Vec::with_capacity(self.len() + rhs.as_slice().len());\n+        res.push_all(self.as_slice());\n+        res.push_all(rhs.as_slice());\n+        res\n+    }\n+}\n+\n #[unsafe_destructor]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n@@ -1436,10 +1447,94 @@ impl<T> Drop for MoveItems<T> {\n     }\n }\n \n+/**\n+ * Convert an iterator of pairs into a pair of vectors.\n+ *\n+ * Returns a tuple containing two vectors where the i-th element of the first\n+ * vector contains the first element of the i-th tuple of the input iterator,\n+ * and the i-th element of the second vector contains the second element\n+ * of the i-th tuple of the input iterator.\n+ */\n+pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n+    let (lo, _) = iter.size_hint();\n+    let mut ts = Vec::with_capacity(lo);\n+    let mut us = Vec::with_capacity(lo);\n+    for (t, u) in iter {\n+        ts.push(t);\n+        us.push(u);\n+    }\n+    (ts, us)\n+}\n+\n+/// Mechanism to convert from a `Vec<T>` to a `[T]`.\n+///\n+/// In a post-DST world this will be used to convert to any `Ptr<[T]>`.\n+///\n+/// This could be implemented on more types than just pointers to vectors, but\n+/// the recommended approach for those types is to implement `FromIterator`.\n+// FIXME(#12938): Update doc comment when DST lands\n+pub trait FromVec<T> {\n+    /// Convert a `Vec<T>` into the receiver type.\n+    fn from_vec(v: Vec<T>) -> Self;\n+}\n+\n+impl<T> FromVec<T> for ~[T] {\n+    fn from_vec(mut v: Vec<T>) -> ~[T] {\n+        let len = v.len();\n+        let data_size = len.checked_mul(&mem::size_of::<T>());\n+        let data_size = data_size.expect(\"overflow in from_vec()\");\n+        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n+        let size = size.expect(\"overflow in from_vec()\");\n+\n+        // In a post-DST world, we can attempt to reuse the Vec allocation by calling\n+        // shrink_to_fit() on it. That may involve a reallocation+memcpy, but that's no\n+        // diffrent than what we're doing manually here.\n+\n+        let vp = v.as_mut_ptr();\n+\n+        unsafe {\n+            let ret = malloc_raw(size) as *mut RawVec<()>;\n+\n+            (*ret).fill = len * mem::nonzero_size_of::<T>();\n+            (*ret).alloc = len * mem::nonzero_size_of::<T>();\n+\n+            ptr::copy_nonoverlapping_memory(&mut (*ret).data as *mut _ as *mut u8,\n+                                            vp as *u8, data_size);\n+\n+            // we've transferred ownership of the contents from v, but we can't drop it\n+            // as it still needs to free its own allocation.\n+            v.set_len(0);\n+\n+            transmute(ret)\n+        }\n+    }\n+}\n+\n+/// Unsafe operations\n+pub mod raw {\n+    use super::Vec;\n+    use ptr;\n+\n+    /// Constructs a vector from an unsafe pointer to a buffer.\n+    ///\n+    /// The elements of the buffer are copied into the vector without cloning,\n+    /// as if `ptr::read()` were called on them.\n+    #[inline]\n+    pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> Vec<T> {\n+        let mut dst = Vec::with_capacity(elts);\n+        dst.set_len(elts);\n+        ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n+        dst\n+    }\n+}\n+\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use mem::size_of;\n+    use kinds::marker;\n+    use super::{unzip, raw, FromVec};\n \n     #[test]\n     fn test_small_vec_struct() {\n@@ -1649,4 +1744,75 @@ mod tests {\n         unsafe { v.set_len(0); }\n         assert_eq!(v.mut_iter().len(), 0);\n     }\n+\n+    #[test]\n+    fn test_partition() {\n+        assert_eq!(vec![].partition(|x: &int| *x < 3), (vec![], vec![]));\n+        assert_eq!(vec![1, 2, 3].partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(vec![1, 2, 3].partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(vec![1, 2, 3].partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+    }\n+\n+    #[test]\n+    fn test_partitioned() {\n+        assert_eq!(vec![].partitioned(|x: &int| *x < 3), (vec![], vec![]))\n+        assert_eq!(vec![1, 2, 3].partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(vec![1, 2, 3].partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(vec![1, 2, 3].partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+    }\n+\n+    #[test]\n+    fn test_zip_unzip() {\n+        let z1 = vec![(1, 4), (2, 5), (3, 6)];\n+\n+        let (left, right) = unzip(z1.iter().map(|&x| x));\n+\n+        let (left, right) = (left.as_slice(), right.as_slice());\n+        assert_eq!((1, 4), (left[0], right[0]));\n+        assert_eq!((2, 5), (left[1], right[1]));\n+        assert_eq!((3, 6), (left[2], right[2]));\n+    }\n+\n+    #[test]\n+    fn test_unsafe_ptrs() {\n+        unsafe {\n+            // Test on-stack copy-from-buf.\n+            let a = [1, 2, 3];\n+            let ptr = a.as_ptr();\n+            let b = raw::from_buf(ptr, 3u);\n+            assert_eq!(b, vec![1, 2, 3]);\n+\n+            // Test on-heap copy-from-buf.\n+            let c = box [1, 2, 3, 4, 5];\n+            let ptr = c.as_ptr();\n+            let d = raw::from_buf(ptr, 5u);\n+            assert_eq!(d, vec![1, 2, 3, 4, 5]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let a = vec![1u, 2, 3];\n+        let b: ~[uint] = FromVec::from_vec(a);\n+        assert_eq!(b.as_slice(), &[1u, 2, 3]);\n+\n+        let a = vec![];\n+        let b: ~[u8] = FromVec::from_vec(a);\n+        assert_eq!(b.as_slice(), &[]);\n+\n+        let a = vec![\"one\".to_owned(), \"two\".to_owned()];\n+        let b: ~[~str] = FromVec::from_vec(a);\n+        assert_eq!(b.as_slice(), &[\"one\".to_owned(), \"two\".to_owned()]);\n+\n+        struct Foo {\n+            x: uint,\n+            nocopy: marker::NoCopy\n+        }\n+\n+        let a = vec![Foo{x: 42, nocopy: marker::NoCopy}, Foo{x: 84, nocopy: marker::NoCopy}];\n+        let b: ~[Foo] = FromVec::from_vec(a);\n+        assert_eq!(b.len(), 2);\n+        assert_eq!(b[0].x, 42);\n+        assert_eq!(b[1].x, 84);\n+    }\n }"}, {"sha": "6a8a56b4f1f8a2a4ce036226ef5e37775b7bdc20", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -90,6 +90,7 @@ fn vector<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n \n fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     let n_keys = {\n         if args.len() == 2 {\n             from_str::<uint>(args[1]).unwrap()"}, {"sha": "b1181a3c17c5ad24d8a3666e45043236fbcf8229", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -155,6 +155,7 @@ fn empty_results() -> Results {\n \n fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     let num_keys = {\n         if args.len() == 2 {\n             from_str::<uint>(args[1]).unwrap()"}, {"sha": "7e54198bd3961655e4313fbfe103b942fc55f8c4", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -24,7 +24,7 @@ use std::vec;\n use std::io::File;\n \n macro_rules! bench (\n-    ($argv:expr, $id:ident) => (maybe_run_test($argv, stringify!($id).to_owned(), $id))\n+    ($argv:expr, $id:ident) => (maybe_run_test($argv.as_slice(), stringify!($id).to_owned(), $id))\n )\n \n fn main() {"}, {"sha": "bbe6b6c23f0f97082a618803abc7d7a00887b997", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -61,6 +61,7 @@ fn ping_pong_bench(n: uint, m: uint) {\n fn main() {\n \n     let args = os::args();\n+    let args = args.as_slice();\n     let n = if args.len() == 3 {\n         from_str::<uint>(args[1]).unwrap()\n     } else {"}, {"sha": "29cee668389f873d89d557508625e63f43b6d265", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -31,6 +31,7 @@ fn parfib(n: uint) -> uint {\n fn main() {\n \n     let args = os::args();\n+    let args = args.as_slice();\n     let n = if args.len() == 2 {\n         from_str::<uint>(args[1]).unwrap()\n     } else {"}, {"sha": "48d4a41c1a39aae1f9d7032ffc8d990bccd3a7f4", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -28,6 +28,7 @@ fn start(argc: int, argv: **u8) -> int {\n fn main() {\n \n     let args = os::args();\n+    let args = args.as_slice();\n     let n = if args.len() == 2 {\n         from_str::<uint>(args[1]).unwrap()\n     } else {"}, {"sha": "8914c5b327ecc6f843699269ca576a4684a4e31c", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -40,6 +40,7 @@ fn bottom_up_tree<'r>(arena: &'r TypedArena<Tree<'r>>, item: int, depth: int)\n \n fn main() {\n     let args = std::os::args();\n+    let args = args.as_slice();\n     let n = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         17\n     } else if args.len() <= 1u {"}, {"sha": "07e5b08c37ccb996ce33065e420968f728359b2b", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -194,7 +194,7 @@ fn main() {\n     let nn = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         200000\n     } else {\n-        std::os::args().get(1).and_then(|arg| from_str(*arg)).unwrap_or(600)\n+        std::os::args().as_slice().get(1).and_then(|arg| from_str(*arg)).unwrap_or(600)\n     };\n \n     print_complements();"}, {"sha": "3525b90d3f681c2fddbefa8aefc5aed08cd847a2", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -53,7 +53,7 @@ fn fannkuch(n: uint, i: uint) -> (int, int) {\n }\n \n fn main() {\n-    let n = std::os::args().get(1).and_then(|arg| from_str(*arg)).unwrap_or(2u);\n+    let n = std::os::args().as_slice().get(1).and_then(|arg| from_str(*arg)).unwrap_or(2u);\n \n     let (tx, rx) = channel();\n     for i in range(0, n) {"}, {"sha": "3f8d3275b64f9456c33312b2da515b2b2e0abc3a", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -177,6 +177,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n \n fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     let n = if args.len() > 1 {\n         from_str::<uint>(args[1]).unwrap()\n     } else {"}, {"sha": "c526ef54caff2277c9af923bca84ec485929ca07", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -74,6 +74,7 @@ fn make_fasta<W: Writer, I: Iterator<u8>>(\n \n fn run<W: Writer>(writer: &mut W) {\n     let args = os::args();\n+    let args = args.as_slice();\n     let n = if os::getenv(\"RUST_BENCH\").is_some() {\n         25000000\n     } else if args.len() <= 1u {"}, {"sha": "e2bcc55d139828ca5da5186c4f25b242ce27a17a", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -72,7 +72,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> ~str {\n \n // given a map, search for the frequency of a pattern\n fn find(mm: &HashMap<Vec<u8> , uint>, key: ~str) -> uint {\n-   let key = key.into_ascii().to_lower().into_str();\n+   let key = key.into_ascii().as_slice().to_lower().into_str();\n    match mm.find_equiv(&key.as_bytes()) {\n       option::None      => { return 0u; }\n       option::Some(&num) => { return num; }"}, {"sha": "ee715aecec4fcb9ff1a76ed6658dfdbf372b3bf9", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -65,6 +65,7 @@ fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n \n fn main() {\n     let args = std::os::args();\n+    let args = args.as_slice();\n     let res = if args.len() < 2 {\n         println!(\"Test mode: do not dump the image because it's not utf8, \\\n                   which interferes with the test runner.\");"}, {"sha": "cb46c542f5bc84c03af85f141d9877f5226b301c", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -190,7 +190,7 @@ fn to_utf8(raw_sol: &List<u64>) -> ~str {\n             }\n         }\n     }\n-    std::str::from_utf8_owned(sol.move_iter().collect()).unwrap()\n+    std::str::from_utf8(sol.as_slice()).unwrap().to_owned()\n }\n \n // Prints a solution in ~str form.\n@@ -270,6 +270,7 @@ fn search(\n \n fn main () {\n     let args = std::os::args();\n+    let args = args.as_slice();\n     let stop_after = if args.len() <= 1 {\n         2098\n     } else {"}, {"sha": "49356e6e6458ebaf9a4444910c449ca2c28b6b96", "filename": "src/test/bench/shootout-pidigits.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pidigits.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -88,6 +88,7 @@ fn pidigits(n: int) {\n \n fn main() {\n     let args = std::os::args();\n+    let args = args.as_slice();\n     let n = if args.len() < 2 {\n         512\n     } else {"}, {"sha": "70a0e7a957c6b0aa9aa68f5c425f7eed374e7e45", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -94,6 +94,7 @@ fn mult_AtAv(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>,\n \n fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     let n = if os::getenv(\"RUST_BENCH\").is_some() {\n         5500\n     } else if args.len() < 2 {"}, {"sha": "60485f40ba4e0f064e268b0fe8420082d8c2e151", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -35,6 +35,7 @@ fn roundtrip(id: int, tx: Sender<int>, rx: Receiver<int>) {\n \n fn main() {\n     let args = std::os::args();\n+    let args = args.as_slice();\n     let token = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         2000000\n     } else {"}, {"sha": "a08d6bb0bf87fdb45ea3c309e80a0be2305225bd", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -36,8 +36,8 @@ fn random_char() -> char {\n \n fn main() {\n     let args = os::args();\n-    let rustc = args[1].as_slice();\n-    let tmpdir = Path::new(args[2].as_slice());\n+    let rustc = args.get(1).as_slice();\n+    let tmpdir = Path::new(args.get(2).as_slice());\n \n     let main_file = tmpdir.join(\"unicode_input_multiple_files_main.rs\");\n     let main_file_str = main_file.as_str().unwrap();"}, {"sha": "13f141008b7929775a1a979a8dace1317896b2fd", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -35,8 +35,8 @@ fn random_char() -> char {\n \n fn main() {\n     let args = os::args();\n-    let rustc = args[1].as_slice();\n-    let tmpdir = Path::new(args[2].as_slice());\n+    let rustc = args.get(1).as_slice();\n+    let tmpdir = Path::new(args.get(2).as_slice());\n \n     let main_file = tmpdir.join(\"span_main.rs\");\n     let main_file_str = main_file.as_str().unwrap();"}, {"sha": "989453d8570d169ae14b1dafb3d966dd479261c1", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -100,6 +100,7 @@ fn runtest(me: &str) {\n \n fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     if args.len() >= 2 && args[1].as_slice() == \"fail\" {\n         foo();\n     } else if args.len() >= 2 && args[1].as_slice() == \"double-fail\" {"}, {"sha": "c409852c6736cd63022a2cf9bbe2d4eb8266fede", "filename": "src/test/run-pass/cleanup-shortcircuit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -24,6 +24,7 @@ use std::os;\n \n pub fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n \n     // Here, the rvalue `\"signal\".to_owned()` requires cleanup. Older versions\n     // of the code had a problem that the cleanup scope for this"}, {"sha": "38030eb6c1fdcb72cb0a1c70ffb114795958665f", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -17,6 +17,7 @@ use std::io::process;\n \n pub fn main () {\n     let args = os::args();\n+    let args = args.as_slice();\n     if args.len() > 1 && args[1] == \"child\".to_owned() {\n         for _ in range(0, 1000) {\n             println!(\"hello?\");"}, {"sha": "f66b943d85f64fbedc624ceb0e81923fc4e74b67", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -25,6 +25,7 @@ fn start(argc: int, argv: **u8) -> int {\n \n fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     if args.len() > 1 && args[1].as_slice() == \"child\" {\n         if args[2].as_slice() == \"green\" {\n             child();\n@@ -48,6 +49,7 @@ fn main() {\n \n fn parent(flavor: ~str) {\n     let args = os::args();\n+    let args = args.as_slice();\n     let mut p = io::Process::new(args[0].as_slice(), [\"child\".to_owned(), flavor]).unwrap();\n     p.stdin.get_mut_ref().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output();"}, {"sha": "f05b1932b738dd2916663b7655f628faabef65ec", "filename": "src/test/run-pass/issue-4541.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4541.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -10,6 +10,7 @@\n \n fn parse_args() -> ~str {\n     let args = ::std::os::args();\n+    let args = args.as_slice();\n     let mut n = 0;\n \n     while n < args.len() {"}, {"sha": "a5e632b94a28888c7437d2dae2d2ad10885d0e7c", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -22,6 +22,7 @@ use std::str;\n \n fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     if args.len() > 1 && args[1].as_slice() == \"child\" {\n         debug!(\"foo\");\n         debug!(\"bar\");"}, {"sha": "ac3a9ef2d533089cea13c32ad362136e1f05e3f5", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -34,6 +34,7 @@ fn loud_recurse() {\n \n fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     if args.len() > 1 && args[1].as_slice() == \"silent\" {\n         silent_recurse();\n     } else if args.len() > 1 && args[1].as_slice() == \"loud\" {"}, {"sha": "e4a935eae7f431af3ebd99082bdc74d9ca9a266b", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -62,7 +62,7 @@ pub fn main() {\n \n     assert!(map.pop(&Slice(\"foo\")).is_some());\n     assert_eq!(map.move_iter().map(|(k, v)| k.to_str() + v.to_str())\n-                              .collect::<~[~str]>()\n+                              .collect::<Vec<~str>>()\n                               .concat(),\n                \"abc50bcd51cde52def53\".to_owned());\n }"}, {"sha": "a0459e6e8c1ada7d6d3f9fea5af9c2101b7543d6", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -25,6 +25,7 @@ use std::io::process::{Process, ExitSignal, ExitStatus};\n \n pub fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     if args.len() >= 2 && args[1] == \"signal\".to_owned() {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }"}, {"sha": "34d1f5e66c6782a66f700aad2b67933d8a5a94e5", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -25,6 +25,7 @@ fn test() {\n \n fn main() {\n     let args = os::args();\n+    let args = args.as_slice();\n     if args.len() > 1 && args[1].as_slice() == \"test\" {\n         return test();\n     }"}, {"sha": "794f810165dcb46380f3f1d011ed121ebc45dac7", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990920c6fff9b762c3d0968ff0a5fdcce6d2b39/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=a990920c6fff9b762c3d0968ff0a5fdcce6d2b39", "patch": "@@ -20,7 +20,7 @@ impl to_str for int {\n \n impl<T:to_str> to_str for Vec<T> {\n     fn to_string(&self) -> ~str {\n-        format!(\"[{}]\", self.iter().map(|e| e.to_string()).collect::<~[~str]>().connect(\", \"))\n+        format!(\"[{}]\", self.iter().map(|e| e.to_string()).collect::<Vec<~str>>().connect(\", \"))\n     }\n }\n "}]}