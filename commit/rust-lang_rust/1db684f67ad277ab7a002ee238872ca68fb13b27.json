{"sha": "1db684f67ad277ab7a002ee238872ca68fb13b27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYjY4NGY2N2FkMjc3YWI3YTAwMmVlMjM4ODcyY2E2OGZiMTNiMjc=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-02-23T04:16:46Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-02-23T04:16:46Z"}, "message": "int audit - std::sync", "tree": {"sha": "10efe7339c5ce108ef697775751bf98760fd4380", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10efe7339c5ce108ef697775751bf98760fd4380"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1db684f67ad277ab7a002ee238872ca68fb13b27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1db684f67ad277ab7a002ee238872ca68fb13b27", "html_url": "https://github.com/rust-lang/rust/commit/1db684f67ad277ab7a002ee238872ca68fb13b27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1db684f67ad277ab7a002ee238872ca68fb13b27/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d8c9f5c9976a906c8d2b41f9375df2f735ec23b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8c9f5c9976a906c8d2b41f9375df2f735ec23b", "html_url": "https://github.com/rust-lang/rust/commit/5d8c9f5c9976a906c8d2b41f9375df2f735ec23b"}], "stats": {"total": 354, "additions": 177, "deletions": 177}, "files": [{"sha": "f697d10d5dfab14ad5f85ee1db0a45569f89fc52", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -33,13 +33,13 @@ use sync::{Mutex, Condvar};\n pub struct Barrier {\n     lock: Mutex<BarrierState>,\n     cvar: Condvar,\n-    num_threads: uint,\n+    num_threads: usize,\n }\n \n // The inner state of a double barrier\n struct BarrierState {\n-    count: uint,\n-    generation_id: uint,\n+    count: usize,\n+    generation_id: usize,\n }\n \n /// A result returned from wait.\n@@ -54,7 +54,7 @@ impl Barrier {\n     /// A barrier will block `n`-1 threads which call `wait` and then wake up\n     /// all threads at once when the `n`th thread calls `wait`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(n: uint) -> Barrier {\n+    pub fn new(n: usize) -> Barrier {\n         Barrier {\n             lock: Mutex::new(BarrierState {\n                 count: 0,\n@@ -115,7 +115,7 @@ mod tests {\n \n     #[test]\n     fn test_barrier() {\n-        const N: uint = 10;\n+        const N: usize = 10;\n \n         let barrier = Arc::new(Barrier::new(N));\n         let (tx, rx) = channel();"}, {"sha": "aa87abc6e9aacdecce704f680c08911e2888d780", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -327,7 +327,7 @@ impl StaticCondvar {\n     }\n \n     fn verify(&self, mutex: &sys_mutex::Mutex) {\n-        let addr = mutex as *const _ as uint;\n+        let addr = mutex as *const _ as usize;\n         match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n             // If we got out 0, then we have successfully bound the mutex to\n             // this cvar.\n@@ -388,7 +388,7 @@ mod tests {\n \n     #[test]\n     fn notify_all() {\n-        const N: uint = 10;\n+        const N: usize = 10;\n \n         let data = Arc::new((Mutex::new(0), Condvar::new()));\n         let (tx, rx) = channel();"}, {"sha": "2e4155ea35128d070c7854e304a40b58a30a87ac", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -61,17 +61,17 @@ impl SignalToken {\n         wake\n     }\n \n-    /// Convert to an unsafe uint value. Useful for storing in a pipe's state\n+    /// Convert to an unsafe usize value. Useful for storing in a pipe's state\n     /// flag.\n     #[inline]\n-    pub unsafe fn cast_to_uint(self) -> uint {\n+    pub unsafe fn cast_to_usize(self) -> usize {\n         mem::transmute(self.inner)\n     }\n \n-    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state\n+    /// Convert from an unsafe usize value. Useful for retrieving a pipe's state\n     /// flag.\n     #[inline]\n-    pub unsafe fn cast_from_uint(signal_ptr: uint) -> SignalToken {\n+    pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken {\n         SignalToken { inner: mem::transmute(signal_ptr) }\n     }\n "}, {"sha": "7bd1f3542eb13828ca4a2806e53a623bc8c68e45", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -94,7 +94,7 @@\n //!\n //! // The call to recv() will return an error because the channel has already\n //! // hung up (or been deallocated)\n-//! let (tx, rx) = channel::<int>();\n+//! let (tx, rx) = channel::<i32>();\n //! drop(tx);\n //! assert!(rx.recv().is_err());\n //! ```\n@@ -105,7 +105,7 @@\n //! use std::thread;\n //! use std::sync::mpsc::sync_channel;\n //!\n-//! let (tx, rx) = sync_channel::<int>(0);\n+//! let (tx, rx) = sync_channel::<i32>(0);\n //! thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n //!     tx.send(53).unwrap();\n@@ -123,7 +123,7 @@\n //! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n //!\n-//! let (tx, rx) = channel::<int>();\n+//! let (tx, rx) = channel::<i32>();\n //! let mut timer = Timer::new().unwrap();\n //! let timeout = timer.oneshot(Duration::seconds(10));\n //!\n@@ -147,7 +147,7 @@\n //! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n //!\n-//! let (tx, rx) = channel::<int>();\n+//! let (tx, rx) = channel::<i32>();\n //! let mut timer = Timer::new().unwrap();\n //!\n //! loop {\n@@ -525,7 +525,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// assert_eq!(rx.recv().unwrap(), 2);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n+pub fn sync_channel<T: Send>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n@@ -1028,7 +1028,7 @@ mod test {\n     use super::*;\n     use thread;\n \n-    pub fn stress_factor() -> uint {\n+    pub fn stress_factor() -> usize {\n         match env::var(\"RUST_TEST_STRESS\") {\n             Ok(val) => val.parse().unwrap(),\n             Err(..) => 1,\n@@ -1037,7 +1037,7 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n@@ -1058,7 +1058,7 @@ mod test {\n \n     #[test]\n     fn smoke_shared() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n@@ -1068,7 +1068,7 @@ mod test {\n \n     #[test]\n     fn smoke_threads() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n@@ -1077,21 +1077,21 @@ mod test {\n \n     #[test]\n     fn smoke_port_gone() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn smoke_shared_port_gone() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         assert!(tx.send(1).is_err())\n     }\n \n     #[test]\n     fn smoke_shared_port_gone2() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n@@ -1100,7 +1100,7 @@ mod test {\n \n     #[test]\n     fn port_gone_concurrent() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n@@ -1109,7 +1109,7 @@ mod test {\n \n     #[test]\n     fn port_gone_concurrent_shared() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let tx2 = tx.clone();\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n@@ -1119,7 +1119,7 @@ mod test {\n \n     #[test]\n     fn smoke_chan_gone() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n@@ -1135,7 +1135,7 @@ mod test {\n \n     #[test]\n     fn chan_gone_concurrent() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n@@ -1145,7 +1145,7 @@ mod test {\n \n     #[test]\n     fn stress() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n             for _ in 0..10000 { tx.send(1).unwrap(); }\n         });\n@@ -1157,9 +1157,9 @@ mod test {\n \n     #[test]\n     fn stress_shared() {\n-        static AMT: uint = 10000;\n-        static NTHREADS: uint = 8;\n-        let (tx, rx) = channel::<int>();\n+        static AMT: u32 = 10000;\n+        static NTHREADS: u32 = 8;\n+        let (tx, rx) = channel::<i32>();\n \n         let t = thread::spawn(move|| {\n             for _ in 0..AMT * NTHREADS {\n@@ -1184,7 +1184,7 @@ mod test {\n     #[test]\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx2, rx2) = channel::<i32>();\n         let t1 = thread::spawn(move|| {\n             tx1.send(()).unwrap();\n             for _ in 0..40 {\n@@ -1203,7 +1203,7 @@ mod test {\n \n     #[test]\n     fn recv_from_outside_runtime() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n             for _ in 0..40 {\n                 assert_eq!(rx.recv().unwrap(), 1);\n@@ -1217,8 +1217,8 @@ mod test {\n \n     #[test]\n     fn no_runtime() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         let t1 = thread::spawn(move|| {\n             assert_eq!(rx1.recv().unwrap(), 1);\n             tx2.send(2).unwrap();\n@@ -1234,21 +1234,21 @@ mod test {\n     #[test]\n     fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n-        let (_tx, rx) = channel::<int>();\n+        let (_tx, rx) = channel::<i32>();\n         drop(rx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n-        let (tx, _rx) = channel::<int>();\n+        let (tx, _rx) = channel::<i32>();\n         drop(tx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         drop(rx);\n         assert!(tx.send(box 0).is_err());\n     }\n@@ -1257,7 +1257,7 @@ mod test {\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             drop(tx);\n             rx.recv().unwrap();\n         }).join();\n@@ -1267,64 +1267,64 @@ mod test {\n \n     #[test]\n     fn oneshot_single_thread_send_then_recv() {\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         tx.send(box 10).unwrap();\n         assert!(rx.recv().unwrap() == box 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_open() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         assert!(tx.send(10).is_ok());\n         assert!(rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         assert!(tx.send(10).is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_open() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         tx.send(10).unwrap();\n         assert!(rx.recv() == Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_closed() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_data() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n         tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_close() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(tx);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_open() {\n-        let (_tx, rx) = channel::<int>();\n+        let (_tx, rx) = channel::<i32>();\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n     }\n \n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n@@ -1334,7 +1334,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n@@ -1347,7 +1347,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1358,7 +1358,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1371,7 +1371,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             thread::spawn(move|| {\n                 let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n@@ -1405,7 +1405,7 @@ mod test {\n             send(tx, 0);\n             recv(rx, 0);\n \n-            fn send(tx: Sender<Box<int>>, i: int) {\n+            fn send(tx: Sender<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1414,7 +1414,7 @@ mod test {\n                 });\n             }\n \n-            fn recv(rx: Receiver<Box<int>>, i: int) {\n+            fn recv(rx: Receiver<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1451,8 +1451,8 @@ mod test {\n \n     #[test]\n     fn test_nested_recv_iter() {\n-        let (tx, rx) = channel::<int>();\n-        let (total_tx, total_rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n+        let (total_tx, total_rx) = channel::<i32>();\n \n         let _t = thread::spawn(move|| {\n             let mut acc = 0;\n@@ -1471,7 +1471,7 @@ mod test {\n \n     #[test]\n     fn test_recv_iter_break() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let (count_tx, count_rx) = channel();\n \n         let _t = thread::spawn(move|| {\n@@ -1496,7 +1496,7 @@ mod test {\n \n     #[test]\n     fn try_recv_states() {\n-        let (tx1, rx1) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n         let _t = thread::spawn(move|| {\n@@ -1550,7 +1550,7 @@ mod sync_tests {\n     use thread;\n     use super::*;\n \n-    pub fn stress_factor() -> uint {\n+    pub fn stress_factor() -> usize {\n         match env::var(\"RUST_TEST_STRESS\") {\n             Ok(val) => val.parse().unwrap(),\n             Err(..) => 1,\n@@ -1559,7 +1559,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n@@ -1572,7 +1572,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_shared() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n@@ -1582,7 +1582,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_threads() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n@@ -1591,14 +1591,14 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_port_gone() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn smoke_shared_port_gone2() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n@@ -1607,7 +1607,7 @@ mod sync_tests {\n \n     #[test]\n     fn port_gone_concurrent() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n@@ -1616,7 +1616,7 @@ mod sync_tests {\n \n     #[test]\n     fn port_gone_concurrent_shared() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n@@ -1626,7 +1626,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_chan_gone() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n@@ -1642,7 +1642,7 @@ mod sync_tests {\n \n     #[test]\n     fn chan_gone_concurrent() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n@@ -1652,7 +1652,7 @@ mod sync_tests {\n \n     #[test]\n     fn stress() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n             for _ in 0..10000 { tx.send(1).unwrap(); }\n         });\n@@ -1663,9 +1663,9 @@ mod sync_tests {\n \n     #[test]\n     fn stress_shared() {\n-        static AMT: uint = 1000;\n-        static NTHREADS: uint = 8;\n-        let (tx, rx) = sync_channel::<int>(0);\n+        static AMT: u32 = 1000;\n+        static NTHREADS: u32 = 8;\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n         thread::spawn(move|| {\n@@ -1692,21 +1692,21 @@ mod sync_tests {\n     #[test]\n     fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n-        let (_tx, rx) = sync_channel::<int>(0);\n+        let (_tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n-        let (tx, _rx) = sync_channel::<int>(0);\n+        let (tx, _rx) = sync_channel::<i32>(0);\n         drop(tx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n-        let (tx, rx) = sync_channel::<Box<int>>(0);\n+        let (tx, rx) = sync_channel::<Box<i32>>(0);\n         drop(rx);\n         assert!(tx.send(box 0).is_err());\n     }\n@@ -1715,7 +1715,7 @@ mod sync_tests {\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             drop(tx);\n             rx.recv().unwrap();\n         }).join();\n@@ -1725,70 +1725,70 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_single_thread_send_then_recv() {\n-        let (tx, rx) = sync_channel::<Box<int>>(1);\n+        let (tx, rx) = sync_channel::<Box<i32>>(1);\n         tx.send(box 10).unwrap();\n         assert!(rx.recv().unwrap() == box 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_open() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.try_send(10), Ok(()));\n         assert!(rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n         assert_eq!(tx.try_send(10), Err(TrySendError::Disconnected(10)));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed2() {\n-        let (tx, _rx) = sync_channel::<int>(0);\n+        let (tx, _rx) = sync_channel::<i32>(0);\n         assert_eq!(tx.try_send(10), Err(TrySendError::Full(10)));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_open() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(10).unwrap();\n         assert!(rx.recv() == Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_closed() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_data() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n         tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_close() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(tx);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_open() {\n-        let (_tx, rx) = sync_channel::<int>(0);\n+        let (_tx, rx) = sync_channel::<i32>(0);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n     }\n \n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n-        let (tx, rx) = sync_channel::<Box<int>>(0);\n+        let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n@@ -1798,7 +1798,7 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n-        let (tx, rx) = sync_channel::<Box<int>>(0);\n+        let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n@@ -1811,7 +1811,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1822,7 +1822,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1835,7 +1835,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             let _t = thread::spawn(move|| {\n                 let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n@@ -1853,7 +1853,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<Box<int>>(0);\n+            let (tx, rx) = sync_channel::<Box<i32>>(0);\n             let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n@@ -1864,12 +1864,12 @@ mod sync_tests {\n     #[test]\n     fn stream_send_recv_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<Box<int>>(0);\n+            let (tx, rx) = sync_channel::<Box<i32>>(0);\n \n             send(tx, 0);\n             recv(rx, 0);\n \n-            fn send(tx: SyncSender<Box<int>>, i: int) {\n+            fn send(tx: SyncSender<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1878,7 +1878,7 @@ mod sync_tests {\n                 });\n             }\n \n-            fn recv(rx: Receiver<Box<int>>, i: int) {\n+            fn recv(rx: Receiver<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1915,8 +1915,8 @@ mod sync_tests {\n \n     #[test]\n     fn test_nested_recv_iter() {\n-        let (tx, rx) = sync_channel::<int>(0);\n-        let (total_tx, total_rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n+        let (total_tx, total_rx) = sync_channel::<i32>(0);\n \n         let _t = thread::spawn(move|| {\n             let mut acc = 0;\n@@ -1935,7 +1935,7 @@ mod sync_tests {\n \n     #[test]\n     fn test_recv_iter_break() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n         let _t = thread::spawn(move|| {\n@@ -1960,7 +1960,7 @@ mod sync_tests {\n \n     #[test]\n     fn try_recv_states() {\n-        let (tx1, rx1) = sync_channel::<int>(1);\n+        let (tx1, rx1) = sync_channel::<i32>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n         let _t = thread::spawn(move|| {\n@@ -2007,29 +2007,29 @@ mod sync_tests {\n \n     #[test]\n     fn send1() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { rx.recv().unwrap(); });\n         assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n     fn send2() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send3() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.send(1), Ok(()));\n         let _t =thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send4() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n@@ -2048,20 +2048,20 @@ mod sync_tests {\n \n     #[test]\n     fn try_send1() {\n-        let (tx, _rx) = sync_channel::<int>(0);\n+        let (tx, _rx) = sync_channel::<i32>(0);\n         assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n     }\n \n     #[test]\n     fn try_send2() {\n-        let (tx, _rx) = sync_channel::<int>(1);\n+        let (tx, _rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n     }\n \n     #[test]\n     fn try_send3() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         drop(rx);\n         assert_eq!(tx.try_send(1), Err(TrySendError::Disconnected(1)));"}, {"sha": "f287712d9d45d59bdc2eb7745ed4ddd468092fe0", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -22,7 +22,7 @@\n ///\n /// # Implementation\n ///\n-/// Oneshots are implemented around one atomic uint variable. This variable\n+/// Oneshots are implemented around one atomic usize variable. This variable\n /// indicates both the state of the port/chan but also contains any tasks\n /// blocked on the port. All atomic operations happen on this one word.\n ///\n@@ -45,9 +45,9 @@ use core::mem;\n use sync::atomic::{AtomicUsize, Ordering};\n \n // Various states you can find a port in.\n-const EMPTY: uint = 0;          // initial state: no data, no blocked receiver\n-const DATA: uint = 1;           // data ready for receiver to take\n-const DISCONNECTED: uint = 2;   // channel is disconnected OR upgraded\n+const EMPTY: usize = 0;          // initial state: no data, no blocked receiver\n+const DATA: usize = 1;           // data ready for receiver to take\n+const DISCONNECTED: usize = 2;   // channel is disconnected OR upgraded\n // Any other value represents a pointer to a SignalToken value. The\n // protocol ensures that when the state moves *to* a pointer,\n // ownership of the token is given to the packet, and when the state\n@@ -123,7 +123,7 @@ impl<T: Send> Packet<T> {\n             // There is a thread waiting on the other end. We leave the 'DATA'\n             // state inside so it'll pick it up on the other end.\n             ptr => unsafe {\n-                SignalToken::cast_from_uint(ptr).signal();\n+                SignalToken::cast_from_usize(ptr).signal();\n                 Ok(())\n             }\n         }\n@@ -143,15 +143,15 @@ impl<T: Send> Packet<T> {\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(Ordering::SeqCst) == EMPTY {\n             let (wait_token, signal_token) = blocking::tokens();\n-            let ptr = unsafe { signal_token.cast_to_uint() };\n+            let ptr = unsafe { signal_token.cast_to_usize() };\n \n             // race with senders to enter the blocking state\n             if self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) == EMPTY {\n                 wait_token.wait();\n                 debug_assert!(self.state.load(Ordering::SeqCst) != EMPTY);\n             } else {\n                 // drop the signal token, since we never blocked\n-                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n             }\n         }\n \n@@ -220,7 +220,7 @@ impl<T: Send> Packet<T> {\n             DISCONNECTED => { self.upgrade = prev; UpDisconnected }\n \n             // If someone's waiting, we gotta wake them up\n-            ptr => UpWoke(unsafe { SignalToken::cast_from_uint(ptr) })\n+            ptr => UpWoke(unsafe { SignalToken::cast_from_usize(ptr) })\n         }\n     }\n \n@@ -230,7 +230,7 @@ impl<T: Send> Packet<T> {\n \n             // If someone's waiting, we gotta wake them up\n             ptr => unsafe {\n-                SignalToken::cast_from_uint(ptr).signal();\n+                SignalToken::cast_from_usize(ptr).signal();\n             }\n         }\n     }\n@@ -283,15 +283,15 @@ impl<T: Send> Packet<T> {\n     // Attempts to start selection on this port. This can either succeed, fail\n     // because there is data, or fail because there is an upgrade pending.\n     pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n-        let ptr = unsafe { token.cast_to_uint() };\n+        let ptr = unsafe { token.cast_to_usize() };\n         match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n             EMPTY => SelSuccess,\n             DATA => {\n-                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n                 SelCanceled\n             }\n             DISCONNECTED if self.data.is_some() => {\n-                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n                 SelCanceled\n             }\n             DISCONNECTED => {\n@@ -300,15 +300,15 @@ impl<T: Send> Packet<T> {\n                     // propagate upwards whether the upgrade can receive\n                     // data\n                     GoUp(upgrade) => {\n-                        SelUpgraded(unsafe { SignalToken::cast_from_uint(ptr) }, upgrade)\n+                        SelUpgraded(unsafe { SignalToken::cast_from_usize(ptr) }, upgrade)\n                     }\n \n                     // If the other end disconnected without sending an\n                     // upgrade, then we have data to receive (the channel is\n                     // disconnected).\n                     up => {\n                         self.upgrade = up;\n-                        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n                         SelCanceled\n                     }\n                 }\n@@ -360,7 +360,7 @@ impl<T: Send> Packet<T> {\n \n             // We woke ourselves up from select.\n             ptr => unsafe {\n-                drop(SignalToken::cast_from_uint(ptr));\n+                drop(SignalToken::cast_from_usize(ptr));\n                 Ok(false)\n             }\n         }"}, {"sha": "b6f93b8e0e574ce470608e2e70b6960c36ecb357", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -71,7 +71,7 @@ use sync::mpsc::blocking::{self, SignalToken};\n pub struct Select {\n     head: *mut Handle<'static, ()>,\n     tail: *mut Handle<'static, ()>,\n-    next_id: Cell<uint>,\n+    next_id: Cell<usize>,\n }\n \n impl !marker::Send for Select {}\n@@ -82,7 +82,7 @@ impl !marker::Send for Select {}\n pub struct Handle<'rx, T:'rx> {\n     /// The ID of this handle, used to compare against the return value of\n     /// `Select::wait()`\n-    id: uint,\n+    id: usize,\n     selector: &'rx Select,\n     next: *mut Handle<'static, ()>,\n     prev: *mut Handle<'static, ()>,\n@@ -154,12 +154,12 @@ impl Select {\n     /// the matching `id` will have some sort of event available on it. The\n     /// event could either be that data is available or the corresponding\n     /// channel has been closed.\n-    pub fn wait(&self) -> uint {\n+    pub fn wait(&self) -> usize {\n         self.wait2(true)\n     }\n \n     /// Helper method for skipping the preflight checks during testing\n-    fn wait2(&self, do_preflight_checks: bool) -> uint {\n+    fn wait2(&self, do_preflight_checks: bool) -> usize {\n         // Note that this is currently an inefficient implementation. We in\n         // theory have knowledge about all receivers in the set ahead of time,\n         // so this method shouldn't really have to iterate over all of them yet\n@@ -254,7 +254,7 @@ impl Select {\n impl<'rx, T: Send> Handle<'rx, T> {\n     /// Retrieve the id of this handle.\n     #[inline]\n-    pub fn id(&self) -> uint { self.id }\n+    pub fn id(&self) -> usize { self.id }\n \n     /// Block to receive a value on the underlying receiver, returning `Some` on\n     /// success or `None` if the channel disconnects. This function has the same\n@@ -369,8 +369,8 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         tx1.send(1).unwrap();\n         select! {\n             foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n@@ -394,11 +394,11 @@ mod test {\n \n     #[test]\n     fn smoke2() {\n-        let (_tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n-        let (_tx3, rx3) = channel::<int>();\n-        let (_tx4, rx4) = channel::<int>();\n-        let (tx5, rx5) = channel::<int>();\n+        let (_tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n+        let (_tx3, rx3) = channel::<i32>();\n+        let (_tx4, rx4) = channel::<i32>();\n+        let (tx5, rx5) = channel::<i32>();\n         tx5.send(4).unwrap();\n         select! {\n             _foo = rx1.recv() => { panic!(\"1\") },\n@@ -411,8 +411,8 @@ mod test {\n \n     #[test]\n     fn closed() {\n-        let (_tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (_tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         drop(tx2);\n \n         select! {\n@@ -423,9 +423,9 @@ mod test {\n \n     #[test]\n     fn unblocks() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n-        let (tx3, rx3) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n+        let (tx3, rx3) = channel::<i32>();\n \n         let _t = thread::spawn(move|| {\n             for _ in 0..20 { thread::yield_now(); }\n@@ -447,8 +447,8 @@ mod test {\n \n     #[test]\n     fn both_ready() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -473,9 +473,9 @@ mod test {\n \n     #[test]\n     fn stress() {\n-        static AMT: int = 10000;\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        static AMT: u32 = 10000;\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -500,8 +500,8 @@ mod test {\n \n     #[test]\n     fn cloning() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -522,8 +522,8 @@ mod test {\n \n     #[test]\n     fn cloning2() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -716,7 +716,7 @@ mod test {\n \n     #[test]\n     fn sync1() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(1).unwrap();\n         select! {\n             n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n@@ -725,7 +725,7 @@ mod test {\n \n     #[test]\n     fn sync2() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n             for _ in 0..100 { thread::yield_now() }\n             tx.send(1).unwrap();\n@@ -737,8 +737,8 @@ mod test {\n \n     #[test]\n     fn sync3() {\n-        let (tx1, rx1) = sync_channel::<int>(0);\n-        let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n+        let (tx1, rx1) = sync_channel::<i32>(0);\n+        let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();\n         let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n         let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n         select! {"}, {"sha": "8d14824d37feed09e3e0c9916b2b2431b8897b4b", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -101,7 +101,7 @@ impl<T: Send> Packet<T> {\n         token.map(|token| {\n             assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-            self.to_wake.store(unsafe { token.cast_to_uint() }, Ordering::SeqCst);\n+            self.to_wake.store(unsafe { token.cast_to_usize() }, Ordering::SeqCst);\n             self.cnt.store(-1, Ordering::SeqCst);\n \n             // This store is a little sketchy. What's happening here is that\n@@ -241,7 +241,7 @@ impl<T: Send> Packet<T> {\n     // Returns true if blocking should proceed.\n     fn decrement(&mut self, token: SignalToken) -> StartResult {\n         assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-        let ptr = unsafe { token.cast_to_uint() };\n+        let ptr = unsafe { token.cast_to_usize() };\n         self.to_wake.store(ptr, Ordering::SeqCst);\n \n         let steals = self.steals;\n@@ -258,7 +258,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         self.to_wake.store(0, Ordering::SeqCst);\n-        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n         Abort\n     }\n \n@@ -380,7 +380,7 @@ impl<T: Send> Packet<T> {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n-        unsafe { SignalToken::cast_from_uint(ptr) }\n+        unsafe { SignalToken::cast_from_usize(ptr) }\n     }\n \n     ////////////////////////////////////////////////////////////////////////////"}, {"sha": "ed7190558d8ce93437c39ea47598310a377deeb5", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -69,7 +69,7 @@ pub struct Queue<T> {\n \n     // Cache maintenance fields. Additions and subtractions are stored\n     // separately in order to allow them to use nonatomic addition/subtraction.\n-    cache_bound: uint,\n+    cache_bound: usize,\n     cache_additions: AtomicUsize,\n     cache_subtractions: AtomicUsize,\n }\n@@ -107,7 +107,7 @@ impl<T: Send> Queue<T> {\n     ///               cache (if desired). If the value is 0, then the cache has\n     ///               no bound. Otherwise, the cache will never grow larger than\n     ///               `bound` (although the queue itself could be much larger.\n-    pub unsafe fn new(bound: uint) -> Queue<T> {\n+    pub unsafe fn new(bound: usize) -> Queue<T> {\n         let n1 = Node::new();\n         let n2 = Node::new();\n         (*n1).next.store(n2, Ordering::Relaxed);\n@@ -319,7 +319,7 @@ mod test {\n             stress_bound(1);\n         }\n \n-        unsafe fn stress_bound(bound: uint) {\n+        unsafe fn stress_bound(bound: usize) {\n             let q = Arc::new(Queue::new(bound));\n \n             let (tx, rx) = channel();"}, {"sha": "5a1e05f9c1565e1e28512f51685cc5b59849b20a", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -43,7 +43,7 @@ pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message\n \n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: int, // How many times has a port received without blocking?\n+    steals: isize, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n@@ -146,15 +146,15 @@ impl<T: Send> Packet<T> {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n-        unsafe { SignalToken::cast_from_uint(ptr) }\n+        unsafe { SignalToken::cast_from_usize(ptr) }\n     }\n \n     // Decrements the count on the channel for a sleeper, returning the sleeper\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n     fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> {\n         assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-        let ptr = unsafe { token.cast_to_uint() };\n+        let ptr = unsafe { token.cast_to_usize() };\n         self.to_wake.store(ptr, Ordering::SeqCst);\n \n         let steals = self.steals;\n@@ -171,7 +171,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         self.to_wake.store(0, Ordering::SeqCst);\n-        Err(unsafe { SignalToken::cast_from_uint(ptr) })\n+        Err(unsafe { SignalToken::cast_from_usize(ptr) })\n     }\n \n     pub fn recv(&mut self) -> Result<T, Failure<T>> {\n@@ -350,7 +350,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     // increment the count on the channel (used for selection)\n-    fn bump(&mut self, amt: int) -> int {\n+    fn bump(&mut self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);"}, {"sha": "33c1614e1b297dfe7037782d6533c6c6fe19a943", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -64,7 +64,7 @@ struct State<T> {\n     queue: Queue,       // queue of senders waiting to send data\n     blocker: Blocker,   // currently blocked task on this channel\n     buf: Buffer<T>,     // storage for buffered messages\n-    cap: uint,          // capacity of this channel\n+    cap: usize,         // capacity of this channel\n \n     /// A curious flag used to indicate whether a sender failed or succeeded in\n     /// blocking. This is used to transmit information back to the task that it\n@@ -101,8 +101,8 @@ unsafe impl Send for Node {}\n /// A simple ring-buffer\n struct Buffer<T> {\n     buf: Vec<Option<T>>,\n-    start: uint,\n-    size: uint,\n+    start: usize,\n+    size: usize,\n }\n \n #[derive(Debug)]\n@@ -137,7 +137,7 @@ fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n }\n \n impl<T: Send> Packet<T> {\n-    pub fn new(cap: uint) -> Packet<T> {\n+    pub fn new(cap: usize) -> Packet<T> {\n         Packet {\n             channels: AtomicUsize::new(1),\n             lock: Mutex::new(State {\n@@ -442,8 +442,8 @@ impl<T> Buffer<T> {\n         result.take().unwrap()\n     }\n \n-    fn size(&self) -> uint { self.size }\n-    fn cap(&self) -> uint { self.buf.len() }\n+    fn size(&self) -> usize { self.size }\n+    fn cap(&self) -> usize { self.buf.len() }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "02b2db572ec4fe49be4efa50643560b4638c759d", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -50,7 +50,7 @@ use sys_common::mutex as sys;\n /// use std::thread;\n /// use std::sync::mpsc::channel;\n ///\n-/// const N: uint = 10;\n+/// const N: usize = 10;\n ///\n /// // Spawn a few threads to increment a shared variable (non-atomically), and\n /// // let the main thread know once all increments are done.\n@@ -377,9 +377,9 @@ mod test {\n     #[test]\n     fn lots_and_lots() {\n         static M: StaticMutex = MUTEX_INIT;\n-        static mut CNT: uint = 0;\n-        static J: uint = 1000;\n-        static K: uint = 3;\n+        static mut CNT: u32 = 0;\n+        static J: u32 = 1000;\n+        static K: u32 = 3;\n \n         fn inc() {\n             for _ in 0..J {\n@@ -501,7 +501,7 @@ mod test {\n         let arc2 = arc.clone();\n         let _ = thread::spawn(move|| -> () {\n             struct Unwinder {\n-                i: Arc<Mutex<int>>,\n+                i: Arc<Mutex<i32>>,\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {"}, {"sha": "495a172e2453d4fc5539cf9d905658d1f7c5bf58", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -425,8 +425,8 @@ mod tests {\n     #[test]\n     fn frob() {\n         static R: StaticRwLock = RW_LOCK_INIT;\n-        static N: usize = 10;\n-        static M: usize = 1000;\n+        static N: u32 = 10;\n+        static M: u32 = 1000;\n \n         let (tx, rx) = channel::<()>();\n         for _ in 0..N {"}, {"sha": "738aeccbe7aab1488f001aec3e9838b3f203f9ba", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db684f67ad277ab7a002ee238872ca68fb13b27/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=1db684f67ad277ab7a002ee238872ca68fb13b27", "patch": "@@ -89,7 +89,7 @@ impl TaskPool {\n     /// # Panics\n     ///\n     /// This function will panic if `threads` is 0.\n-    pub fn new(threads: uint) -> TaskPool {\n+    pub fn new(threads: usize) -> TaskPool {\n         assert!(threads >= 1);\n \n         let (tx, rx) = channel::<Thunk>();\n@@ -142,7 +142,7 @@ mod test {\n     use super::*;\n     use sync::mpsc::channel;\n \n-    const TEST_TASKS: uint = 4;\n+    const TEST_TASKS: u32 = 4;\n \n     #[test]\n     fn test_works() {"}]}