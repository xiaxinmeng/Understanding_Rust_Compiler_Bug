{"sha": "c218694cece7c3018b4a809a52a35fcf3716d92e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMTg2OTRjZWNlN2MzMDE4YjRhODA5YTUyYTM1ZmNmMzcxNmQ5MmU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-09-05T01:51:14Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-09-05T21:22:15Z"}, "message": "std::rt: Add libuv bindings for getaddrinfo", "tree": {"sha": "f7abe1b9d5c3f57310718e075590a8cba865e99a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7abe1b9d5c3f57310718e075590a8cba865e99a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c218694cece7c3018b4a809a52a35fcf3716d92e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c218694cece7c3018b4a809a52a35fcf3716d92e", "html_url": "https://github.com/rust-lang/rust/commit/c218694cece7c3018b4a809a52a35fcf3716d92e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c218694cece7c3018b4a809a52a35fcf3716d92e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3f7f758b1f3df8c1d2ded808492b452e4b0e1a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3f7f758b1f3df8c1d2ded808492b452e4b0e1a0", "html_url": "https://github.com/rust-lang/rust/commit/b3f7f758b1f3df8c1d2ded808492b452e4b0e1a0"}], "stats": {"total": 288, "additions": 288, "deletions": 0}, "files": [{"sha": "8f316364d277d81cc6f9e29987e76fa313ba9395", "filename": "src/libstd/rt/io/net/mod.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs?ref=c218694cece7c3018b4a809a52a35fcf3716d92e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rt::io::net::ip::IpAddr;\n+\n+fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n+    /*!\n+     * Get the IP addresses for a given host name.\n+     *\n+     * Raises io_error on failure.\n+     */\n+\n+    fail!()\n+}"}, {"sha": "00d1ab5aa9c697b7ca0d5fbc25fa51ac68bc457b", "filename": "src/libstd/rt/uv/addrinfo.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs?ref=c218694cece7c3018b4a809a52a35fcf3716d92e", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast::transmute;\n+use cell::Cell;\n+use c_str::ToCStr;\n+use libc::{c_int, c_void};\n+use option::{Option, Some, None};\n+use ptr::null;\n+use rt::uv::uvll;\n+use rt::uv::uvll::UV_GETADDRINFO;\n+use rt::uv::{Loop, UvError, NativeHandle};\n+use rt::uv::status_to_maybe_uv_error_with_loop;\n+use rt::uv::net::UvAddrInfo;\n+\n+type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &UvAddrInfo, Option<UvError>);\n+\n+pub struct GetAddrInfoRequest(*uvll::uv_getaddrinfo_t);\n+\n+pub struct RequestData {\n+    getaddrinfo_cb: Option<GetAddrInfoCallback>,\n+}\n+\n+impl GetAddrInfoRequest {\n+    pub fn new() -> GetAddrInfoRequest {\n+        let req = unsafe { uvll::malloc_req(UV_GETADDRINFO) };\n+        assert!(req.is_not_null());\n+        let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n+        req.install_req_data();\n+        return req;\n+    }\n+\n+    pub fn getaddrinfo(&mut self, loop_: &Loop, node: Option<&str>,\n+                       service: Option<&str>, hints: Option<UvAddrInfo>,\n+                       cb: GetAddrInfoCallback) {\n+\n+        assert!(node.is_some() || service.is_some());\n+\n+        let (c_node, c_node_ptr) = match node {\n+            Some(n) => {\n+                let c_node = n.to_c_str();\n+                let c_node_ptr = c_node.with_ref(|r| r);\n+                (Some(c_node), c_node_ptr)\n+            }\n+            None => (None, null())\n+        };\n+\n+        let (c_service, c_service_ptr) = match service {\n+            Some(s) => {\n+                let c_service = s.to_c_str();\n+                let c_service_ptr = c_service.with_ref(|r| r);\n+                (Some(c_service), c_service_ptr)\n+            }\n+            None => (None, null())\n+        };\n+\n+        let cb = Cell::new(cb);\n+        let wrapper_cb: GetAddrInfoCallback = |req, addrinfo, err| {\n+            // Capture some heap values that need to stay alive for the\n+            // getaddrinfo call\n+            let _ = &c_node;\n+            let _ = &c_service;\n+\n+            let cb = cb.take();\n+            cb(req, addrinfo, err)\n+        };\n+\n+        // XXX: Implement hints\n+        assert!(hints.is_none());\n+\n+        self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);\n+\n+        unsafe {\n+            assert!(0 == uvll::getaddrinfo(loop_.native_handle(),\n+                                           self.native_handle(),\n+                                           getaddrinfo_cb,\n+                                           c_node_ptr,\n+                                           c_service_ptr,\n+                                           null()));\n+        }\n+\n+        extern \"C\" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n+                                     status: c_int,\n+                                     res: *uvll::addrinfo) {\n+            let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n+            let loop_ = req.get_loop();\n+            let err = status_to_maybe_uv_error_with_loop(loop_.native_handle(), status);\n+            let addrinfo = UvAddrInfo(res);\n+            let data = req.get_req_data();\n+            (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);\n+            unsafe {\n+                uvll::freeaddrinfo(res);\n+            }\n+        }\n+    }\n+\n+    fn get_loop(&self) -> Loop {\n+        unsafe {\n+            Loop {\n+                handle: uvll::get_loop_from_fs_req(self.native_handle())\n+            }\n+        }\n+    }\n+\n+    fn install_req_data(&mut self) {\n+        let req = self.native_handle() as *uvll::uv_getaddrinfo_t;\n+        let data = ~RequestData {\n+            getaddrinfo_cb: None\n+        };\n+        unsafe {\n+            let data = transmute::<~RequestData, *c_void>(data);\n+            uvll::set_data_for_req(req, data);\n+        }\n+    }\n+\n+    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n+        unsafe {\n+            let data = uvll::get_data_for_req(self.native_handle());\n+            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n+            return &mut **data;\n+        }\n+    }\n+\n+    fn delete(self) {\n+        unsafe {\n+            let data = uvll::get_data_for_req(self.native_handle());\n+            let _data = transmute::<*c_void, ~RequestData>(data);\n+            uvll::set_data_for_req(self.native_handle(), null::<()>());\n+            uvll::free_req(self.native_handle());\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_getaddrinfo_t> for GetAddrInfoRequest {\n+    fn from_native_handle(handle: *uvll::uv_getaddrinfo_t) -> GetAddrInfoRequest {\n+        GetAddrInfoRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_getaddrinfo_t {\n+        match self { &GetAddrInfoRequest(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use option::{Some, None};\n+    use rt::uv::Loop;\n+    use rt::uv::net::accum_sockaddrs;\n+    use rt::io::net::ip::{SocketAddr, Ipv4Addr};\n+    use super::*;\n+\n+    #[test]\n+    fn getaddrinfo_test() {\n+        let mut loop_ = Loop::new();\n+        let mut req = GetAddrInfoRequest::new();\n+        do req.getaddrinfo(&loop_, Some(\"localhost\"), None, None) |_, addrinfo, _| {\n+            let sockaddrs = accum_sockaddrs(addrinfo);\n+            let mut found_local = false;\n+            let local_addr = &SocketAddr {\n+                ip: Ipv4Addr(127, 0, 0, 1),\n+                port: 0\n+            };\n+            for addr in sockaddrs.iter() {\n+                found_local = found_local || addr == local_addr;\n+            }\n+            assert!(found_local);\n+        }\n+        loop_.run();\n+        loop_.close();\n+        req.delete();\n+    }\n+}"}, {"sha": "b85b223468e86e617beb1b81f5099f18c459b8ff", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=c218694cece7c3018b4a809a52a35fcf3716d92e", "patch": "@@ -70,6 +70,7 @@ pub mod net;\n pub mod idle;\n pub mod timer;\n pub mod async;\n+pub mod addrinfo;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,"}, {"sha": "4d54483f47f275d6f36c2720ee8fef369850f68c", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=c218694cece7c3018b4a809a52a35fcf3716d92e", "patch": "@@ -21,6 +21,8 @@ use vec;\n use str;\n use from_str::{FromStr};\n \n+pub struct UvAddrInfo(*uvll::addrinfo);\n+\n pub enum UvSocketAddr {\n     UvIpv4SocketAddr(*sockaddr_in),\n     UvIpv6SocketAddr(*sockaddr_in6),\n@@ -95,6 +97,28 @@ pub fn uv_socket_addr_to_socket_addr(addr: UvSocketAddr) -> SocketAddr {\n     uv_socket_addr_as_socket_addr(addr, util::id)\n }\n \n+// Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n+pub fn accum_sockaddrs(addr: &UvAddrInfo) -> ~[SocketAddr] {\n+    unsafe {\n+        let &UvAddrInfo(addr) = addr;\n+        let mut addr = addr;\n+\n+        let mut addrs = ~[];\n+        loop {\n+            let uvaddr = sockaddr_to_UvSocketAddr((*addr).ai_addr);\n+            let rustaddr = uv_socket_addr_to_socket_addr(uvaddr);\n+            addrs.push(rustaddr);\n+            if (*addr).ai_next.is_not_null() {\n+                addr = (*addr).ai_next;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        return addrs;\n+    }\n+}\n+\n #[cfg(test)]\n #[test]\n fn test_ip4_conversion() {"}, {"sha": "977eae0c269fe95363766d62309dbd108bda27cf", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=c218694cece7c3018b4a809a52a35fcf3716d92e", "patch": "@@ -72,6 +72,7 @@ pub type uv_timer_t = c_void;\n pub type uv_stream_t = c_void;\n pub type uv_fs_t = c_void;\n pub type uv_udp_send_t = c_void;\n+pub type uv_getaddrinfo_t = c_void;\n \n #[cfg(stage0)]\n pub type uv_idle_cb = *u8;\n@@ -97,6 +98,8 @@ pub type uv_connection_cb = *u8;\n pub type uv_timer_cb = *u8;\n #[cfg(stage0)]\n pub type uv_write_cb = *u8;\n+#[cfg(stage0)]\n+pub type uv_getaddrinfo_cb = *u8;\n \n #[cfg(not(stage0))]\n pub type uv_idle_cb = extern \"C\" fn(handle: *uv_idle_t,\n@@ -137,12 +140,44 @@ pub type uv_timer_cb = extern \"C\" fn(handle: *uv_timer_t,\n #[cfg(not(stage0))]\n pub type uv_write_cb = extern \"C\" fn(handle: *uv_write_t,\n                                      status: c_int);\n+#[cfg(not(stage0))]\n+pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n+                                           status: c_int,\n+                                           res: *addrinfo);\n \n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n pub type sockaddr_in6 = c_void;\n pub type sockaddr_storage = c_void;\n \n+#[cfg(unix)]\n+pub type socklen_t = c_int;\n+\n+// XXX: This is a standard C type. Could probably be defined in libc\n+#[cfg(unix)]\n+pub struct addrinfo {\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: socklen_t,\n+    ai_addr: *sockaddr,\n+    ai_canonname: *char,\n+    ai_next: *addrinfo\n+}\n+\n+#[cfg(windows)]\n+pub struct addrinfo {\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: size_t,\n+    ai_canonname: *char,\n+    ai_addr: *sockaddr,\n+    ai_next: *addrinfo\n+}\n+\n #[deriving(Eq)]\n pub enum uv_handle_type {\n     UV_UNKNOWN_HANDLE,\n@@ -666,6 +701,11 @@ pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n \n     rust_uv_get_loop_from_fs_req(req)\n }\n+pub unsafe fn get_loop_from_getaddrinfo_req(req: *uv_getaddrinfo_t) -> *uv_loop_t {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_loop_from_getaddrinfo_req(req)\n+}\n pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -721,6 +761,18 @@ pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n \n     return rust_uv_get_len_from_buf(buf);\n }\n+pub unsafe fn getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n+               getaddrinfo_cb: uv_getaddrinfo_cb,\n+               node: *c_char, service: *c_char,\n+               hints: *addrinfo) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_getaddrinfo(loop_, req, getaddrinfo_cb, node, service, hints);\n+}\n+pub unsafe fn freeaddrinfo(ai: *addrinfo) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_freeaddrinfo(ai);\n+}\n+\n pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n     let err = last_error(uv_loop);\n     let err_ptr = ptr::to_unsafe_ptr(&err);\n@@ -845,6 +897,7 @@ extern {\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n+    fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n \n     fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n     fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n@@ -857,4 +910,9 @@ extern {\n     fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n     fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n     fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n+    fn rust_uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n+                           getaddrinfo_cb: uv_getaddrinfo_cb,\n+                           node: *c_char, service: *c_char,\n+                           hints: *addrinfo) -> c_int;\n+    fn rust_uv_freeaddrinfo(ai: *addrinfo);\n }"}, {"sha": "ac5ea4bb3b36b29d6426043777f5e23a636eec88", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=c218694cece7c3018b4a809a52a35fcf3716d92e", "patch": "@@ -553,3 +553,8 @@ extern \"C\" uv_loop_t*\n rust_uv_get_loop_from_fs_req(uv_fs_t* req) {\n   return req->loop;\n }\n+\n+extern \"C\" uv_loop_t*\n+rust_uv_get_loop_from_getaddrinfo_req(uv_getaddrinfo_t* req) {\n+  return req->loop;\n+}"}, {"sha": "45109443f06142d8964782da4d8b3ad49570f2f2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/c218694cece7c3018b4a809a52a35fcf3716d92e/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=c218694cece7c3018b4a809a52a35fcf3716d92e", "patch": "@@ -192,3 +192,4 @@ rust_take_change_dir_lock\n rust_drop_change_dir_lock\n rust_get_test_int\n rust_get_task\n+rust_uv_get_loop_from_getaddrinfo_req"}]}