{"sha": "25c733360b1cddfc0b129680a9220d1d5097483d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YzczMzM2MGIxY2RkZmMwYjEyOTY4MGE5MjIwZDFkNTA5NzQ4M2Q=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-17T21:20:09Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-27T00:01:04Z"}, "message": "Update spans' `expn_id` during the marking fold", "tree": {"sha": "c170a6fe034fe7f9a9a49c79fd9c47b4857df054", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c170a6fe034fe7f9a9a49c79fd9c47b4857df054"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25c733360b1cddfc0b129680a9220d1d5097483d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25c733360b1cddfc0b129680a9220d1d5097483d", "html_url": "https://github.com/rust-lang/rust/commit/25c733360b1cddfc0b129680a9220d1d5097483d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25c733360b1cddfc0b129680a9220d1d5097483d/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3636ce7875dc71d907789a779c1c1cb5973e021f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3636ce7875dc71d907789a779c1c1cb5973e021f", "html_url": "https://github.com/rust-lang/rust/commit/3636ce7875dc71d907789a779c1c1cb5973e021f"}], "stats": {"total": 101, "additions": 20, "deletions": 81}, "files": [{"sha": "14ab232b92c7e03b96980269c5ed10e1fc409a6e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/25c733360b1cddfc0b129680a9220d1d5097483d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c733360b1cddfc0b129680a9220d1d5097483d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=25c733360b1cddfc0b129680a9220d1d5097483d", "patch": "@@ -1258,31 +1258,6 @@ impl CodeMap {\n         return a;\n     }\n \n-    /// Check if the backtrace `subtrace` contains `suptrace` as a prefix.\n-    pub fn more_specific_trace(&self,\n-                              mut subtrace: ExpnId,\n-                              suptrace: ExpnId)\n-                              -> bool {\n-        loop {\n-            if subtrace == suptrace {\n-                return true;\n-            }\n-\n-            let stop = self.with_expn_info(subtrace, |opt_expn_info| {\n-                if let Some(expn_info) = opt_expn_info {\n-                    subtrace = expn_info.call_site.expn_id;\n-                    false\n-                } else {\n-                    true\n-                }\n-            });\n-\n-            if stop {\n-                return false;\n-            }\n-        }\n-    }\n-\n     pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n         let mut expansions = self.expansions.borrow_mut();\n         expansions.push(expn_info);"}, {"sha": "d66515ed7d68ea55c3d102604f8d19fe6f0f6992", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 56, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/25c733360b1cddfc0b129680a9220d1d5097483d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c733360b1cddfc0b129680a9220d1d5097483d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=25c733360b1cddfc0b129680a9220d1d5097483d", "patch": "@@ -18,7 +18,7 @@ use ext::build::AstBuilder;\n use attr;\n use attr::{AttrMetaMethods, WithAttrs, ThinAttributesExt};\n use codemap;\n-use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{Span, Spanned, ExpnInfo, ExpnId, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n@@ -33,7 +33,6 @@ use visit::Visitor;\n use std_inject;\n \n use std::collections::HashSet;\n-use std::env;\n \n // A trait for AST nodes and AST node lists into which macro invocations may expand.\n trait MacroGenerable: Sized {\n@@ -160,10 +159,10 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let new_node = ast::ExprKind::Closure(capture_clause,\n                                                   rewritten_fn_decl,\n                                                   rewritten_block,\n-                                                  fld.new_span(fn_decl_span));\n+                                                  fn_decl_span);\n             P(ast::Expr{ id:id,\n                          node: new_node,\n-                         span: fld.new_span(span),\n+                         span: span,\n                          attrs: fold_thin_attrs(attrs, fld) })\n         }\n \n@@ -322,7 +321,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n         return T::dummy(span);\n     };\n \n-    let marked = expanded.fold_with(&mut Marker { mark: mark });\n+    let marked = expanded.fold_with(&mut Marker { mark: mark, expn_id: Some(fld.cx.backtrace()) });\n     let fully_expanded = marked.fold_with(fld);\n     fld.cx.bt_pop();\n     fully_expanded\n@@ -699,12 +698,12 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n                                            mtwt::apply_renames(self.renames, ident.ctxt));\n                 let new_node =\n                     PatKind::Ident(binding_mode,\n-                                  Spanned{span: self.new_span(sp), node: new_ident},\n+                                  Spanned{span: sp, node: new_ident},\n                                   sub.map(|p| self.fold_pat(p)));\n                 ast::Pat {\n                     id: id,\n                     node: new_node,\n-                    span: self.new_span(span)\n+                    span: span,\n                 }\n             },\n             _ => unreachable!()\n@@ -774,7 +773,7 @@ fn expand_annotatable(a: Annotatable,\n                         }\n                         _ => unreachable!()\n                     },\n-                    span: fld.new_span(ti.span)\n+                    span: ti.span,\n                 })\n             }\n             _ => fold::noop_fold_trait_item(it.unwrap(), fld)\n@@ -914,7 +913,7 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n                 }\n                 _ => unreachable!()\n             },\n-            span: fld.new_span(ii.span)\n+            span: ii.span,\n         }),\n         ast::ImplItemKind::Macro(mac) => {\n             expand_mac_invoc(mac, None, ii.attrs, ii.span, fld)\n@@ -1060,10 +1059,6 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> {\n         expand_type(ty, self)\n     }\n-\n-    fn new_span(&mut self, span: Span) -> Span {\n-        new_span(self.cx, span)\n-    }\n }\n \n impl<'a, 'b> MacroExpander<'a, 'b> {\n@@ -1081,45 +1076,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n }\n \n-fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n-    debug!(\"new_span(sp={:?})\", sp);\n-\n-    if cx.codemap().more_specific_trace(sp.expn_id, cx.backtrace()) {\n-        // If the span we are looking at has a backtrace that has more\n-        // detail than our current backtrace, then we keep that\n-        // backtrace.  Honestly, I have no idea if this makes sense,\n-        // because I have no idea why we are stripping the backtrace\n-        // below. But the reason I made this change is because, in\n-        // deriving, we were generating attributes with a specific\n-        // backtrace, which was essential for `#[structural_match]` to\n-        // be properly supported, but these backtraces were being\n-        // stripped and replaced with a null backtrace. Sort of\n-        // unclear why this is the case. --nmatsakis\n-        debug!(\"new_span: keeping trace from {:?} because it is more specific\",\n-               sp.expn_id);\n-        sp\n-    } else {\n-        // This discards information in the case of macro-defining macros.\n-        //\n-        // The comment above was originally added in\n-        // b7ec2488ff2f29681fe28691d20fd2c260a9e454 in Feb 2012. I\n-        // *THINK* the reason we are doing this is because we want to\n-        // replace the backtrace of the macro contents with the\n-        // backtrace that contains the macro use. But it's pretty\n-        // unclear to me. --nmatsakis\n-        let sp1 = Span {\n-            lo: sp.lo,\n-            hi: sp.hi,\n-            expn_id: cx.backtrace(),\n-        };\n-        debug!(\"new_span({:?}) = {:?}\", sp, sp1);\n-        if sp.expn_id.into_u32() == 0 && env::var_os(\"NDM\").is_some() {\n-            panic!(\"NDM\");\n-        }\n-        sp1\n-    }\n-}\n-\n pub struct ExpansionConfig<'feat> {\n     pub crate_name: String,\n     pub features: Option<&'feat Features>,\n@@ -1206,8 +1162,9 @@ pub fn expand_crate(mut cx: ExtCtxt,\n // the ones defined here include:\n // Marker - add a mark to a context\n \n-// A Marker adds the given mark to the syntax context\n-struct Marker { mark: Mrk }\n+// A Marker adds the given mark to the syntax context and\n+// sets spans' `expn_id` to the given expn_id (unless it is `None`).\n+struct Marker { mark: Mrk, expn_id: Option<ExpnId> }\n \n impl Folder for Marker {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n@@ -1220,14 +1177,21 @@ impl Folder for Marker {\n                 tts: self.fold_tts(&node.tts),\n                 ctxt: mtwt::apply_mark(self.mark, node.ctxt),\n             },\n-            span: span,\n+            span: self.new_span(span),\n+        }\n+    }\n+\n+    fn new_span(&mut self, mut span: Span) -> Span {\n+        if let Some(expn_id) = self.expn_id {\n+            span.expn_id = expn_id;\n         }\n+        span\n     }\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n-    noop_fold_tts(tts, &mut Marker{mark:m})\n+    noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }\n \n /// Check that there are no macro invocations left in the AST:"}]}