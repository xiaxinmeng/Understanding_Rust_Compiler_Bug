{"sha": "235d77457d80b549dad3ac36d94f235208a1eafb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNWQ3NzQ1N2Q4MGI1NDlkYWQzYWMzNmQ5NGYyMzUyMDhhMWVhZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-18T13:54:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-18T13:54:58Z"}, "message": "Auto merge of #32080 - eddyb:transcendent, r=nikomatsakis\n\nRefactor call & function handling in trans, enable MIR bootstrap.\n\nNon-Rust and Rust ABIs were combined into a common codepath, which means:\n* The ugly `__rust_abi` \"clown shoes\" shim for C->Rust FFI is gone, fixes #10116.\n* Methods, *including virtual ones* support non-Rust ABIs, closes #30235.\n* Non-Rust ABIs also pass fat pointers in two arguments; the result should be identical.\n* Zero-sized types are never passed as arguments; again, behavior shouldn't change.\n\nAdditionally, MIR support for calling intrinsics (through old trans) was implemented.\nAlongside assorted fixes, it enabled MIR to launch :rocket: and do a *complete* bootstrap.\nTo try it yourself, `./configure --enable-orbit` *or* `make RUSTFLAGS=\"-Z orbit\"`.", "tree": {"sha": "3953e3cfb101a5b2738a9a27a0d0faa948662f20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3953e3cfb101a5b2738a9a27a0d0faa948662f20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/235d77457d80b549dad3ac36d94f235208a1eafb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/235d77457d80b549dad3ac36d94f235208a1eafb", "html_url": "https://github.com/rust-lang/rust/commit/235d77457d80b549dad3ac36d94f235208a1eafb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/235d77457d80b549dad3ac36d94f235208a1eafb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2de6ddd75e202acdedfcd05b51a863dcc10459ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/2de6ddd75e202acdedfcd05b51a863dcc10459ca", "html_url": "https://github.com/rust-lang/rust/commit/2de6ddd75e202acdedfcd05b51a863dcc10459ca"}, {"sha": "b12dcdef4fae5e3856e6911fd6cfbeedadcf3821", "url": "https://api.github.com/repos/rust-lang/rust/commits/b12dcdef4fae5e3856e6911fd6cfbeedadcf3821", "html_url": "https://github.com/rust-lang/rust/commit/b12dcdef4fae5e3856e6911fd6cfbeedadcf3821"}], "stats": {"total": 10970, "additions": 4601, "deletions": 6369}, "files": [{"sha": "34132b7e5f5358f7bbbf674c45eb3fac96497131", "filename": "configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/configure", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -607,6 +607,7 @@ opt dist-host-only 0 \"only install bins for the host architecture\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n opt rustbuild 0 \"use the rust and cargo based build system\"\n+opt orbit 0 \"get MIR where it belongs - everywhere; most importantly, in orbit\"\n \n # Optimization and debugging options. These may be overridden by the release channel, etc.\n opt_nosave optimize 1 \"build optimized rust code\"\n@@ -713,6 +714,8 @@ if [ -n \"$CFG_ENABLE_DEBUG_ASSERTIONS\" ]; then putvar CFG_ENABLE_DEBUG_ASSERTION\n if [ -n \"$CFG_ENABLE_DEBUGINFO\" ]; then putvar CFG_ENABLE_DEBUGINFO; fi\n if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi\n \n+if [ -n \"$CFG_ENABLE_ORBIT\" ]; then putvar CFG_ENABLE_ORBIT; fi\n+\n # A magic value that allows the compiler to use unstable features\n # during the bootstrap even when doing so would normally be an error\n # because of feature staging or because the build turns on"}, {"sha": "9df04a6d43eac4c5a7073615604f308d73b7af65", "filename": "mk/main.mk", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -134,6 +134,11 @@ ifdef CFG_ENABLE_DEBUGINFO\n   CFG_RUSTC_FLAGS += -g\n endif\n \n+ifdef CFG_ENABLE_ORBIT\n+  $(info cfg: launching MIR (CFG_ENABLE_ORBIT))\n+  CFG_RUSTC_FLAGS += -Z orbit\n+endif\n+\n ifdef SAVE_TEMPS\n   CFG_RUSTC_FLAGS += --save-temps\n endif"}, {"sha": "ef93fcfa013f89f10b99c00917a462cbe21aea18", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -31,6 +31,8 @@ pub struct TestProps {\n     pub pp_exact: Option<PathBuf>,\n     // Modules from aux directory that should be compiled\n     pub aux_builds: Vec<String> ,\n+    // Environment settings to use for compiling\n+    pub rustc_env: Vec<(String,String)> ,\n     // Environment settings to use during execution\n     pub exec_env: Vec<(String,String)> ,\n     // Lines to check if they appear in the expected debugger output\n@@ -77,6 +79,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         pp_exact: pp_exact,\n         aux_builds: aux_builds,\n         revisions: vec![],\n+        rustc_env: vec![],\n         exec_env: exec_env,\n         check_lines: check_lines,\n         build_aux_docs: build_aux_docs,\n@@ -153,10 +156,14 @@ pub fn load_props_into(props: &mut TestProps, testfile: &Path, cfg: Option<&str>\n             props.aux_builds.push(ab);\n         }\n \n-        if let Some(ee) = parse_exec_env(ln) {\n+        if let Some(ee) = parse_env(ln, \"exec-env\") {\n             props.exec_env.push(ee);\n         }\n \n+        if let Some(ee) = parse_env(ln, \"rustc-env\") {\n+            props.rustc_env.push(ee);\n+        }\n+\n         if let Some(cl) =  parse_check_line(ln) {\n             props.check_lines.push(cl);\n         }\n@@ -372,8 +379,8 @@ fn parse_pretty_compare_only(line: &str) -> bool {\n     parse_name_directive(line, \"pretty-compare-only\")\n }\n \n-fn parse_exec_env(line: &str) -> Option<(String, String)> {\n-    parse_name_value_directive(line, \"exec-env\").map(|nv| {\n+fn parse_env(line: &str, name: &str) -> Option<(String, String)> {\n+    parse_name_value_directive(line, name).map(|nv| {\n         // nv is either FOO or FOO=BAR\n         let mut strs: Vec<String> = nv\n                                       .splitn(2, '=')"}, {"sha": "e3ced9eff3ebb4b5f1e89e55301c27c523e74196", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -863,12 +863,28 @@ fn cleanup_debug_info_options(options: &Option<String>) -> Option<String> {\n         \"-g\".to_owned(),\n         \"--debuginfo\".to_owned()\n     ];\n-    let new_options =\n+    let mut new_options =\n         split_maybe_args(options).into_iter()\n                                  .filter(|x| !options_to_remove.contains(x))\n-                                 .collect::<Vec<String>>()\n-                                 .join(\" \");\n-    Some(new_options)\n+                                 .collect::<Vec<String>>();\n+\n+    let mut i = 0;\n+    while i + 1 < new_options.len() {\n+        if new_options[i] == \"-Z\" {\n+            // FIXME #31005 MIR missing debuginfo currently.\n+            if new_options[i + 1] == \"orbit\" {\n+                // Remove \"-Z\" and \"orbit\".\n+                new_options.remove(i);\n+                new_options.remove(i);\n+                continue;\n+            }\n+            // Always skip over -Z's argument.\n+            i += 1;\n+        }\n+        i += 1;\n+    }\n+\n+    Some(new_options.join(\" \"))\n }\n \n fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String]) {\n@@ -1386,7 +1402,7 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n     compose_and_run(config,\n                     testpaths,\n                     args,\n-                    Vec::new(),\n+                    props.rustc_env.clone(),\n                     &config.compile_lib_path,\n                     Some(aux_dir.to_str().unwrap()),\n                     input)"}, {"sha": "13d3f42ba18968dd53d5dc3db97db3f62db6cacb", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -72,6 +72,7 @@\n #![feature(reflect)]\n #![feature(unwind_attributes)]\n #![feature(repr_simd, platform_intrinsics)]\n+#![feature(rustc_attrs)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n "}, {"sha": "e6f83498ab1e2638dbd90b4cdc56c6c2c33a924d", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -1008,6 +1008,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n+        #[cfg_attr(not(stage0), rustc_no_mir)] // FIXME #29769 MIR overflow checking is TBD.\n         pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n             let mut acc = Self::one();\n@@ -1049,6 +1050,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n+        #[cfg_attr(not(stage0), rustc_no_mir)] // FIXME #29769 MIR overflow checking is TBD.\n         pub fn abs(self) -> Self {\n             if self.is_negative() {\n                 // Note that the #[inline] above means that the overflow\n@@ -2013,6 +2015,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n+        #[cfg_attr(not(stage0), rustc_no_mir)] // FIXME #29769 MIR overflow checking is TBD.\n         pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n             let mut acc = Self::one();"}, {"sha": "dfc8560b58de0268dd3fb09ebf3327e117e6b0e7", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -22,6 +22,7 @@ use middle::def_id::DefId;\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n+use syntax::attr::ThinAttributesExt;\n use syntax::codemap::{Span, Spanned};\n use syntax::parse::token;\n \n@@ -718,6 +719,8 @@ impl<'ast> Map<'ast> {\n             Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n             Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n             Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n+            Some(NodeExpr(ref e)) => Some(e.attrs.as_attr_slice()),\n+            Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n             Some(NodeStructCtor(_)) => {"}, {"sha": "d2ca1cd3f9339ca1a206d2a3dca1b6892bb734be", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -73,7 +73,6 @@ mod macros;\n pub mod diagnostics;\n \n pub mod back {\n-    pub use rustc_back::abi;\n     pub use rustc_back::rpath;\n     pub use rustc_back::svh;\n }"}, {"sha": "dcfa8d1e36a21f39aaac5069bf282f28b074dde8", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -354,19 +354,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n \n-            hir::ExprInlineAsm(ref inline_asm) => {\n-                let inputs = inline_asm.inputs.iter();\n-                let outputs = inline_asm.outputs.iter();\n-                let post_inputs = self.exprs(inputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} input:{:?}\", expr.id, a);\n-                    let &(_, ref expr) = a;\n-                    &**expr\n-                }), pred);\n-                let post_outputs = self.exprs(outputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} output:{:?}\", expr.id, a);\n-                    &*a.expr\n-                }), post_inputs);\n-                self.add_ast_node(expr.id, &[post_outputs])\n+            hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n+                let post_outputs = self.exprs(outputs.iter().map(|e| &**e), pred);\n+                let post_inputs = self.exprs(inputs.iter().map(|e| &**e), post_outputs);\n+                self.add_ast_node(expr.id, &[post_inputs])\n             }\n \n             hir::ExprClosure(..) |"}, {"sha": "16e0a334440ff0f3570e2bde57c64eb69aebbe4b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -475,9 +475,9 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(Def::AssociatedConst(did)) |\n-                    Some(Def::Const(did)) => match lookup_const_by_id(self.tcx, did,\n-                                                                    Some(pat.id), None) {\n-                        Some((const_expr, _const_ty)) => {\n+                    Some(Def::Const(did)) => {\n+                        let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n+                        if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n \n                                 if let Some(ref mut renaming_map) = self.renaming_map {\n@@ -487,14 +487,13 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n \n                                 new_pat\n                             })\n-                        }\n-                        None => {\n+                        } else {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,\n                                 \"statics cannot be referenced in patterns\");\n                             pat\n                         }\n-                    },\n+                    }\n                     _ => noop_fold_pat(pat, self)\n                 }\n             }"}, {"sha": "47b6c49fddb6d69d5b0ad87876aea789d0c8f767", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 25, "deletions": 42, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -19,7 +19,6 @@ use front::map::blocks::FnLikeNode;\n use middle::cstore::{self, CrateStore, InlinedItem};\n use middle::{infer, subst, traits};\n use middle::def::Def;\n-use middle::subst::Subst;\n use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty, TyCtxt};\n@@ -89,16 +88,13 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::TyCtxt,\n }\n \n /// * `def_id` is the id of the constant.\n-/// * `maybe_ref_id` is the id of the expr referencing the constant.\n-/// * `param_substs` is the monomorphization substitution for the expression.\n+/// * `substs` is the monomorphized substitutions for the expression.\n ///\n-/// `maybe_ref_id` and `param_substs` are optional and are used for\n-/// finding substitutions in associated constants. This generally\n-/// happens in late/trans const evaluation.\n+/// `substs` is optional and is used for associated constants.\n+/// This generally happens in late/trans const evaluation.\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                                         def_id: DefId,\n-                                        maybe_ref_id: Option<ast::NodeId>,\n-                                        param_substs: Option<&'tcx subst::Substs<'tcx>>)\n+                                        substs: Option<subst::Substs<'tcx>>)\n                                         -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n@@ -111,28 +107,20 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                 hir::ConstTraitItem(_, _) => {\n-                    match maybe_ref_id {\n-                        // If we have a trait item, and we know the expression\n-                        // that's the source of the obligation to resolve it,\n+                    if let Some(substs) = substs {\n+                        // If we have a trait item and the substitutions for it,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n-                        Some(ref_id) => {\n-                            let trait_id = tcx.trait_of_item(def_id)\n-                                              .unwrap();\n-                            let mut substs = tcx.node_id_item_substs(ref_id)\n-                                                .substs;\n-                            if let Some(param_substs) = param_substs {\n-                                substs = substs.subst(tcx, param_substs);\n-                            }\n-                            resolve_trait_associated_const(tcx, ti, trait_id, substs)\n-                        }\n+                        let trait_id = tcx.trait_of_item(def_id).unwrap();\n+                        resolve_trait_associated_const(tcx, ti, trait_id, substs)\n+                    } else {\n                         // Technically, without knowing anything about the\n                         // expression that generates the obligation, we could\n                         // still return the default if there is one. However,\n                         // it's safer to return `None` than to return some value\n                         // that may differ from what you would get from\n                         // correctly selecting an impl.\n-                        None => None\n+                        None\n                     }\n                 }\n                 _ => None\n@@ -153,7 +141,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             }\n             None => {}\n         }\n-        let mut used_ref_id = false;\n+        let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n             cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n@@ -163,21 +151,15 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             cstore::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n                 hir::ConstTraitItem(_, _) => {\n-                    used_ref_id = true;\n-                    match maybe_ref_id {\n+                    used_substs = true;\n+                    if let Some(substs) = substs {\n                         // As mentioned in the comments above for in-crate\n                         // constants, we only try to find the expression for\n                         // a trait-associated const if the caller gives us\n-                        // the expression that refers to it.\n-                        Some(ref_id) => {\n-                            let mut substs = tcx.node_id_item_substs(ref_id)\n-                                                .substs;\n-                            if let Some(param_substs) = param_substs {\n-                                substs = substs.subst(tcx, param_substs);\n-                            }\n-                            resolve_trait_associated_const(tcx, ti, trait_id, substs)\n-                        }\n-                        None => None\n+                        // the substitutions for the reference to it.\n+                        resolve_trait_associated_const(tcx, ti, trait_id, substs)\n+                    } else {\n+                        None\n                     }\n                 }\n                 _ => None\n@@ -190,10 +172,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             _ => None\n         };\n-        // If we used the reference expression, particularly to choose an impl\n+        // If we used the substitutions, particularly to choose an impl\n         // of a trait-associated const, don't cache that, because the next\n         // lookup with the same def_id may yield a different result.\n-        if !used_ref_id {\n+        if !used_substs {\n             tcx.extern_const_statics\n                .borrow_mut()\n                .insert(def_id, expr_ty.map(|(e, t)| (e.id, t)));\n@@ -389,7 +371,8 @@ pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n                     PatKind::Path(path.clone()),\n                 Some(Def::Const(def_id)) |\n                 Some(Def::AssociatedConst(def_id)) => {\n-                    let (expr, _ty) = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();\n+                    let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n+                    let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, span);\n                 },\n                 _ => unreachable!(),\n@@ -788,12 +771,12 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           match opt_def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n-                  let maybe_ref_id = if let ExprTypeChecked = ty_hint {\n-                      Some(e.id)\n+                  let substs = if let ExprTypeChecked = ty_hint {\n+                      Some(tcx.node_id_item_substs(e.id).substs)\n                   } else {\n                       None\n                   };\n-                  if let Some((e, ty)) = lookup_const_by_id(tcx, def_id, maybe_ref_id, None) {\n+                  if let Some((e, ty)) = lookup_const_by_id(tcx, def_id, substs) {\n                       let item_hint = match ty {\n                           Some(ty) => ty_hint.checked_or(ty),\n                           None => ty_hint,\n@@ -1077,7 +1060,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n         traits::VtableImpl(ref impl_data) => {\n             match tcx.associated_consts(impl_data.impl_def_id)\n                      .iter().find(|ic| ic.name == ti.name) {\n-                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None, None),\n+                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                 None => match ti.node {\n                     hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n                         Some((&*expr, ast_ty_to_prim_ty(tcx, ty)))"}, {"sha": "f85d87413843ec927464fef374f86809e893ec44", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -122,7 +122,7 @@ pub struct ChildItem {\n \n pub enum FoundAst<'ast> {\n     Found(&'ast InlinedItem),\n-    FoundParent(DefId, &'ast InlinedItem),\n+    FoundParent(DefId, &'ast hir::Item),\n     NotFound,\n }\n \n@@ -182,7 +182,7 @@ pub trait CrateStore<'tcx> : Any {\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                      -> Option<DefId>;\n     fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> ty::ImplOrTraitItem<'tcx>;\n+                          -> Option<ty::ImplOrTraitItem<'tcx>>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n@@ -353,7 +353,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                      -> Option<DefId> { unimplemented!() }\n     fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> ty::ImplOrTraitItem<'tcx> { unimplemented!() }\n+                          -> Option<ty::ImplOrTraitItem<'tcx>> { unimplemented!() }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { unimplemented!() }"}, {"sha": "91ffef2aa599d97c4c342b2834c20df87b0e38f1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -449,23 +449,20 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             }\n \n-            hir::ExprInlineAsm(ref ia) => {\n-                for &(_, ref input) in &ia.inputs {\n-                    self.consume_expr(&input);\n-                }\n-\n-                for output in &ia.outputs {\n-                    if output.is_indirect {\n-                        self.consume_expr(&output.expr);\n+            hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n+                for (o, output) in ia.outputs.iter().zip(outputs) {\n+                    if o.is_indirect {\n+                        self.consume_expr(output);\n                     } else {\n-                        self.mutate_expr(expr, &output.expr,\n-                                         if output.is_rw {\n+                        self.mutate_expr(expr, output,\n+                                         if o.is_rw {\n                                              MutateMode::WriteAndRead\n                                          } else {\n                                              MutateMode::JustWrite\n                                          });\n                     }\n                 }\n+                self.consume_exprs(inputs);\n             }\n \n             hir::ExprBreak(..) |"}, {"sha": "d78e0ca79aa82650790190b79a4ae7da37a2dfea", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -1170,25 +1170,21 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprInlineAsm(ref ia) => {\n-\n-            let succ = ia.outputs.iter().rev().fold(succ,\n-                |succ, out| {\n-                    // see comment on lvalues\n-                    // in propagate_through_lvalue_components()\n-                    if out.is_indirect {\n-                        self.propagate_through_expr(&out.expr, succ)\n-                    } else {\n-                        let acc = if out.is_rw { ACC_WRITE|ACC_READ } else { ACC_WRITE };\n-                        let succ = self.write_lvalue(&out.expr, succ, acc);\n-                        self.propagate_through_lvalue_components(&out.expr, succ)\n-                    }\n+          hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n+            let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n+                // see comment on lvalues\n+                // in propagate_through_lvalue_components()\n+                if o.is_indirect {\n+                    self.propagate_through_expr(output, succ)\n+                } else {\n+                    let acc = if o.is_rw { ACC_WRITE|ACC_READ } else { ACC_WRITE };\n+                    let succ = self.write_lvalue(output, succ, acc);\n+                    self.propagate_through_lvalue_components(output, succ)\n                 }\n-            );\n+            });\n+\n             // Inputs are executed first. Propagate last because of rev order\n-            ia.inputs.iter().rev().fold(succ, |succ, &(_, ref expr)| {\n-                self.propagate_through_expr(&expr, succ)\n-            })\n+            self.propagate_through_exprs(inputs, succ)\n           }\n \n           hir::ExprLit(..) => {\n@@ -1425,17 +1421,17 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n         intravisit::walk_expr(this, expr);\n       }\n \n-      hir::ExprInlineAsm(ref ia) => {\n-        for &(_, ref input) in &ia.inputs {\n-          this.visit_expr(&input);\n+      hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n+        for input in inputs {\n+          this.visit_expr(input);\n         }\n \n         // Output operands must be lvalues\n-        for out in &ia.outputs {\n-          if !out.is_indirect {\n-            this.check_lvalue(&out.expr);\n+        for (o, output) in ia.outputs.iter().zip(outputs) {\n+          if !o.is_indirect {\n+            this.check_lvalue(output);\n           }\n-          this.visit_expr(&out.expr);\n+          this.visit_expr(output);\n         }\n \n         intravisit::walk_expr(this, expr);"}, {"sha": "6344553e88bbf09094a8c9fdbd4e478fbf965966", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -2182,7 +2182,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn impl_or_trait_item(&self, id: DefId) -> ImplOrTraitItem<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n-            || self.sess.cstore.impl_or_trait_item(self, id))\n+            || self.sess.cstore.impl_or_trait_item(self, id)\n+                   .expect(\"missing ImplOrTraitItem in metadata\"))\n     }\n \n     pub fn trait_item_def_ids(&self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n@@ -2502,10 +2503,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(&self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return match self.sess.cstore.impl_or_trait_item(self, def_id).container() {\n-                TraitContainer(_) => None,\n-                ImplContainer(def_id) => Some(def_id),\n-            };\n+            return self.sess.cstore.impl_or_trait_item(self, def_id).and_then(|item| {\n+                match item.container() {\n+                    TraitContainer(_) => None,\n+                    ImplContainer(def_id) => Some(def_id),\n+                }\n+            });\n         }\n         match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n             Some(trait_item) => {"}, {"sha": "2d4d4e51ba73fe5d4bbe160821f0228eaeb9ab0e", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -948,7 +948,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    fn is_slice(&self) -> bool {\n+    pub fn is_slice(&self) -> bool {\n         match self.sty {\n             TyRawPtr(mt) | TyRef(_, mt) => match mt.ty.sty {\n                 TySlice(_) | TyStr => true,"}, {"sha": "06d68af8838994aec797c5d3efca6aef22797f68", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -14,6 +14,7 @@ use rustc_const_eval::{ConstUsize, ConstInt};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n+use util::ppaux;\n use rustc_back::slice;\n use rustc_front::hir::InlineAsm;\n use std::ascii;\n@@ -177,6 +178,10 @@ pub struct TempDecl<'tcx> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ArgDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n+\n+    /// If true, this argument is a tuple after monomorphization,\n+    /// and has to be collected from multiple actual arguments.\n+    pub spread: bool\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -675,7 +680,11 @@ pub enum Rvalue<'tcx> {\n         from_end: usize,\n     },\n \n-    InlineAsm(InlineAsm),\n+    InlineAsm {\n+        asm: InlineAsm,\n+        outputs: Vec<Lvalue<'tcx>>,\n+        inputs: Vec<Operand<'tcx>>\n+    }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n@@ -760,7 +769,9 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?}, {:?})\", op, a, b),\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n             Box(ref t) => write!(fmt, \"Box({:?})\", t),\n-            InlineAsm(ref asm) => write!(fmt, \"InlineAsm({:?})\", asm),\n+            InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n+            }\n             Slice { ref input, from_start, from_end } =>\n                 write!(fmt, \"{:?}[{:?}..-{:?}]\", input, from_start, from_end),\n \n@@ -775,8 +786,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             Aggregate(ref kind, ref lvs) => {\n                 use self::AggregateKind::*;\n \n-                fn fmt_tuple(fmt: &mut Formatter, name: &str, lvs: &[Operand]) -> fmt::Result {\n-                    let mut tuple_fmt = fmt.debug_tuple(name);\n+                fn fmt_tuple(fmt: &mut Formatter, lvs: &[Operand]) -> fmt::Result {\n+                    let mut tuple_fmt = fmt.debug_tuple(\"\");\n                     for lv in lvs {\n                         tuple_fmt.field(lv);\n                     }\n@@ -790,19 +801,24 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         match lvs.len() {\n                             0 => write!(fmt, \"()\"),\n                             1 => write!(fmt, \"({:?},)\", lvs[0]),\n-                            _ => fmt_tuple(fmt, \"\", lvs),\n+                            _ => fmt_tuple(fmt, lvs),\n                         }\n                     }\n \n-                    Adt(adt_def, variant, _) => {\n+                    Adt(adt_def, variant, substs) => {\n                         let variant_def = &adt_def.variants[variant];\n-                        let name = ty::tls::with(|tcx| tcx.item_path_str(variant_def.did));\n+\n+                        try!(ppaux::parameterized(fmt, substs, variant_def.did,\n+                                                  ppaux::Ns::Value, &[],\n+                                                  |tcx| {\n+                            tcx.lookup_item_type(variant_def.did).generics\n+                        }));\n \n                         match variant_def.kind() {\n-                            ty::VariantKind::Unit => write!(fmt, \"{}\", name),\n-                            ty::VariantKind::Tuple => fmt_tuple(fmt, &name, lvs),\n+                            ty::VariantKind::Unit => Ok(()),\n+                            ty::VariantKind::Tuple => fmt_tuple(fmt, lvs),\n                             ty::VariantKind::Struct => {\n-                                let mut struct_fmt = fmt.debug_struct(&name);\n+                                let mut struct_fmt = fmt.debug_struct(\"\");\n                                 for (field, lv) in variant_def.fields.iter().zip(lvs) {\n                                     struct_fmt.field(&field.name.as_str(), lv);\n                                 }\n@@ -882,8 +898,10 @@ impl<'tcx> Debug for Literal<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Literal::*;\n         match *self {\n-            Item { def_id, .. } =>\n-                write!(fmt, \"{}\", item_path_str(def_id)),\n+            Item { def_id, substs } => {\n+                ppaux::parameterized(fmt, substs, def_id, ppaux::Ns::Value, &[],\n+                                     |tcx| tcx.lookup_item_type(def_id).generics)\n+            }\n             Value { ref value } => {\n                 try!(write!(fmt, \"const \"));\n                 fmt_const_val(fmt, value)"}, {"sha": "c8a2bc440ce1d79ae5cda6de1021bfcf94c8b35f", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -16,6 +16,7 @@\n use mir::repr::*;\n use middle::subst::{Subst, Substs};\n use middle::ty::{self, AdtDef, Ty, TyCtxt};\n+use middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_front::hir;\n \n #[derive(Copy, Clone, Debug)]\n@@ -77,6 +78,29 @@ impl<'tcx> LvalueTy<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.fold_with(folder) },\n+            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n+                let substs = substs.fold_with(folder);\n+                LvalueTy::Downcast {\n+                    adt_def: adt_def,\n+                    substs: folder.tcx().mk_substs(substs),\n+                    variant_index: variant_index\n+                }\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            LvalueTy::Ty { ty } => ty.visit_with(visitor),\n+            LvalueTy::Downcast { substs, .. } => substs.visit_with(visitor)\n+        }\n+    }\n+}\n+\n impl<'tcx> Mir<'tcx> {\n     pub fn operand_ty(&self,\n                       tcx: &TyCtxt<'tcx>,\n@@ -196,7 +220,7 @@ impl<'tcx> Mir<'tcx> {\n                 }\n             }\n             Rvalue::Slice { .. } => None,\n-            Rvalue::InlineAsm(..) => None\n+            Rvalue::InlineAsm { .. } => None\n         }\n     }\n }"}, {"sha": "36d45f0a51ec22fda19aa31c8ef09a9a0d1e5913", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -261,7 +261,14 @@ macro_rules! make_mir_visitor {\n                         });\n                     }\n \n-                    Rvalue::InlineAsm(_) => {\n+                    Rvalue::InlineAsm { ref $($mutability)* outputs,\n+                                        ref $($mutability)* inputs, .. } => {\n+                        for output in & $($mutability)* outputs[..] {\n+                            self.visit_lvalue(output, LvalueContext::Store);\n+                        }\n+                        for input in & $($mutability)* inputs[..] {\n+                            self.visit_operand(input);\n+                        }\n                     }\n                 }\n             }"}, {"sha": "17f70b2d8dc663ebd7cd01a6b51e48081f74fe62", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -663,6 +663,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"print the result of the translation item collection pass\"),\n     mir_opt_level: Option<usize> = (None, parse_opt_uint,\n           \"set the MIR optimization level (0-3)\"),\n+    orbit: bool = (false, parse_bool,\n+          \"get MIR where it belongs - everywhere; most importantly, in orbit\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "e1690f1a8592a11d1b542d39ce7317c3773f3905", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -60,17 +60,37 @@ fn fn_sig(f: &mut fmt::Formatter,\n     }\n }\n \n-fn parameterized<GG>(f: &mut fmt::Formatter,\n-                     substs: &subst::Substs,\n-                     did: DefId,\n-                     projections: &[ty::ProjectionPredicate],\n-                     get_generics: GG)\n-                     -> fmt::Result\n+/// Namespace of the path given to parameterized to print.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum Ns {\n+    Type,\n+    Value\n+}\n+\n+pub fn parameterized<GG>(f: &mut fmt::Formatter,\n+                         substs: &subst::Substs,\n+                         did: DefId,\n+                         ns: Ns,\n+                         projections: &[ty::ProjectionPredicate],\n+                         get_generics: GG)\n+                         -> fmt::Result\n     where GG: for<'tcx> FnOnce(&TyCtxt<'tcx>) -> ty::Generics<'tcx>\n {\n-    let (fn_trait_kind, verbose) = try!(ty::tls::with(|tcx| {\n+    if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n+        try!(write!(f, \"<{} as \", self_ty));\n+    }\n+\n+    let (fn_trait_kind, verbose, last_name) = try!(ty::tls::with(|tcx| {\n+        let (did, last_name) = if ns == Ns::Value {\n+            // Try to get the impl/trait parent, if this is an\n+            // associated value item (method or constant).\n+            tcx.trait_of_item(did).or_else(|| tcx.impl_of_method(did))\n+               .map_or((did, None), |parent| (parent, Some(tcx.item_name(did))))\n+        } else {\n+            (did, None)\n+        };\n         try!(write!(f, \"{}\", tcx.item_path_str(did)));\n-        Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose()))\n+        Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose(), last_name))\n     }));\n \n     let mut empty = true;\n@@ -185,7 +205,28 @@ fn parameterized<GG>(f: &mut fmt::Formatter,\n                     projection.ty));\n     }\n \n-    start_or_continue(f, \"\", \">\")\n+    try!(start_or_continue(f, \"\", \">\"));\n+\n+    // For values, also print their name and type parameters.\n+    if ns == Ns::Value {\n+        if substs.self_ty().is_some() {\n+            try!(write!(f, \">\"));\n+        }\n+\n+        if let Some(name) = last_name {\n+            try!(write!(f, \"::{}\", name));\n+        }\n+        let tps = substs.types.get_slice(subst::FnSpace);\n+        if !tps.is_empty() {\n+            try!(write!(f, \"::<{}\", tps[0]));\n+            for ty in &tps[1..] {\n+                try!(write!(f, \", {}\", ty));\n+            }\n+            try!(write!(f, \">\"));\n+        }\n+    }\n+\n+    Ok(())\n }\n \n fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n@@ -265,6 +306,7 @@ impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n         let TraitAndProjections(ref trait_ref, ref projection_bounds) = *self;\n         parameterized(f, trait_ref.substs,\n                       trait_ref.def_id,\n+                      Ns::Type,\n                       projection_bounds,\n                       |tcx| tcx.lookup_trait_def(trait_ref.def_id).generics.clone())\n     }\n@@ -769,7 +811,7 @@ impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>>\n \n impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, &[],\n+        parameterized(f, self.substs, self.def_id, Ns::Type, &[],\n                       |tcx| tcx.lookup_trait_def(self.def_id).generics.clone())\n     }\n }\n@@ -821,19 +863,9 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     try!(write!(f, \"extern {} \", bare_fn.abi));\n                 }\n \n-                try!(write!(f, \"{}\", bare_fn.sig.0));\n-                try!(ty::tls::with(|tcx| {\n-                    write!(f, \" {{{}\", tcx.item_path_str(def_id))\n-                }));\n-\n-                let tps = substs.types.get_slice(subst::FnSpace);\n-                if tps.len() >= 1 {\n-                    try!(write!(f, \"::<{}\", tps[0]));\n-                    for &ty in &tps[1..] {\n-                        try!(write!(f, \", {}\", ty));\n-                    }\n-                    try!(write!(f, \">\"));\n-                }\n+                try!(write!(f, \"{} {{\", bare_fn.sig.0));\n+                try!(parameterized(f, substs, def_id, Ns::Value, &[],\n+                                   |tcx| tcx.lookup_item_type(def_id).generics));\n                 write!(f, \"}}\")\n             }\n             TyFnPtr(ref bare_fn) => {\n@@ -856,7 +888,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                           !tcx.tcache.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n-                        parameterized(f, substs, def.did, &[],\n+                        parameterized(f, substs, def.did, Ns::Type, &[],\n                                       |tcx| tcx.lookup_item_type(def.did).generics)\n                     }\n                 })"}, {"sha": "c3a3a8d582aff91f2fc400141e0b57d16d605234", "filename": "src/librustc_back/abi.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=2de6ddd75e202acdedfcd05b51a863dcc10459ca", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub const BOX_FIELD_DROP_GLUE: usize = 1;\n-pub const BOX_FIELD_BODY: usize = 4;\n-\n-/// The first half of a fat pointer.\n-/// - For a closure, this is the code address.\n-/// - For an object or trait instance, this is the address of the box.\n-/// - For a slice, this is the base address.\n-pub const FAT_PTR_ADDR: usize = 0;\n-\n-/// The second half of a fat pointer.\n-/// - For a closure, this is the address of the environment.\n-/// - For an object or trait instance, this is the address of the vtable.\n-/// - For a slice, this is the length.\n-pub const FAT_PTR_EXTRA: usize = 1;"}, {"sha": "3ffc031d621f4a2c5f8282b31035be77578f543b", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -48,7 +48,6 @@ extern crate rustc_llvm;\n extern crate rustc_front;\n #[macro_use] extern crate log;\n \n-pub mod abi;\n pub mod tempdir;\n pub mod rpath;\n pub mod sha2;"}, {"sha": "3507a119e5455ebbf12dc79509b01b063001b170", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -279,7 +279,7 @@ mod svh_visitor {\n             ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.name.as_str())),\n             ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.name.as_str())),\n             ExprRet(..)              => SawExprRet,\n-            ExprInlineAsm(ref asm)   => SawExprInlineAsm(asm),\n+            ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n             ExprStruct(..)           => SawExprStruct,\n             ExprRepeat(..)           => SawExprRepeat,\n         }"}, {"sha": "e65f2fc37debfa813c63f982711ffd7236d4b9e7", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -1107,34 +1107,11 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n                 respan(folder.new_span(label.span), folder.fold_ident(label.node))\n             })),\n             ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n-            ExprInlineAsm(InlineAsm {\n-                inputs,\n-                outputs,\n-                asm,\n-                asm_str_style,\n-                clobbers,\n-                volatile,\n-                alignstack,\n-                dialect,\n-                expn_id,\n-            }) => ExprInlineAsm(InlineAsm {\n-                inputs: inputs.move_map(|(c, input)| (c, folder.fold_expr(input))),\n-                outputs: outputs.move_map(|out| {\n-                    InlineAsmOutput {\n-                        constraint: out.constraint,\n-                        expr: folder.fold_expr(out.expr),\n-                        is_rw: out.is_rw,\n-                        is_indirect: out.is_indirect,\n-                    }\n-                }),\n-                asm: asm,\n-                asm_str_style: asm_str_style,\n-                clobbers: clobbers,\n-                volatile: volatile,\n-                alignstack: alignstack,\n-                dialect: dialect,\n-                expn_id: expn_id,\n-            }),\n+            ExprInlineAsm(asm, outputs, inputs) => {\n+                ExprInlineAsm(asm,\n+                              outputs.move_map(|x| folder.fold_expr(x)),\n+                              inputs.move_map(|x| folder.fold_expr(x)))\n+            }\n             ExprStruct(path, fields, maybe_expr) => {\n                 ExprStruct(folder.fold_path(path),\n                            fields.move_map(|x| folder.fold_field(x)),"}, {"sha": "ee530677b60cd7ffb26dcb858c879156cacc4953", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -39,7 +39,7 @@ use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n-use syntax::attr::ThinAttributes;\n+use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n \n@@ -635,6 +635,16 @@ pub enum Stmt_ {\n     StmtSemi(P<Expr>, NodeId),\n }\n \n+impl Stmt_ {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match *self {\n+            StmtDecl(ref d, _) => d.node.attrs(),\n+            StmtExpr(ref e, _) |\n+            StmtSemi(ref e, _) => e.attrs.as_attr_slice(),\n+        }\n+    }\n+}\n+\n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n@@ -659,6 +669,15 @@ pub enum Decl_ {\n     DeclItem(ItemId),\n }\n \n+impl Decl_ {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match *self {\n+            DeclLocal(ref l) => l.attrs.as_attr_slice(),\n+            DeclItem(_) => &[]\n+        }\n+    }\n+}\n+\n /// represents one arm of a 'match'\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {\n@@ -793,8 +812,8 @@ pub enum Expr_ {\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n-    /// Output of the `asm!()` macro\n-    ExprInlineAsm(InlineAsm),\n+    /// Inline assembly (from `asm!`), with its outputs and inputs.\n+    ExprInlineAsm(InlineAsm, Vec<P<Expr>>, Vec<P<Expr>>),\n \n     /// A struct literal expression.\n     ///\n@@ -978,7 +997,6 @@ pub enum Ty_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n     pub constraint: InternedString,\n-    pub expr: P<Expr>,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n }\n@@ -988,7 +1006,7 @@ pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n     pub outputs: HirVec<InlineAsmOutput>,\n-    pub inputs: HirVec<(InternedString, P<Expr>)>,\n+    pub inputs: HirVec<InternedString>,\n     pub clobbers: HirVec<InternedString>,\n     pub volatile: bool,\n     pub alignstack: bool,"}, {"sha": "e031dfc5b161dd9e4c564350fea5329f20b8542f", "filename": "src/librustc_front/intravisit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fintravisit.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -798,12 +798,12 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprInlineAsm(ref ia) => {\n-            for &(_, ref input) in &ia.inputs {\n-                visitor.visit_expr(&input)\n+        ExprInlineAsm(_, ref outputs, ref inputs) => {\n+            for output in outputs {\n+                visitor.visit_expr(output)\n             }\n-            for output in &ia.outputs {\n-                visitor.visit_expr(&output.expr)\n+            for input in inputs {\n+                visitor.visit_expr(input)\n             }\n         }\n     }"}, {"sha": "8aac6356f9d3bf0f30ffceb50a7493012997e2ea", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -1320,14 +1320,11 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     dialect,\n                     expn_id,\n                 }) => hir::ExprInlineAsm(hir::InlineAsm {\n-                inputs: inputs.iter()\n-                              .map(|&(ref c, ref input)| (c.clone(), lower_expr(lctx, input)))\n-                              .collect(),\n+                inputs: inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n                 outputs: outputs.iter()\n                                 .map(|out| {\n                                     hir::InlineAsmOutput {\n                                         constraint: out.constraint.clone(),\n-                                        expr: lower_expr(lctx, &out.expr),\n                                         is_rw: out.is_rw,\n                                         is_indirect: out.is_indirect,\n                                     }\n@@ -1340,7 +1337,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 alignstack: alignstack,\n                 dialect: dialect,\n                 expn_id: expn_id,\n-            }),\n+            }, outputs.iter().map(|out| lower_expr(lctx, &out.expr)).collect(),\n+               inputs.iter().map(|&(_, ref input)| lower_expr(lctx, input)).collect()),\n             ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n                 hir::ExprStruct(lower_path(lctx, path),\n                                 fields.iter().map(|x| lower_field(lctx, x)).collect(),"}, {"sha": "1ebbbb73e8c994897c2ef09c697341abfd0f03d6", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -1486,12 +1486,13 @@ impl<'a> State<'a> {\n                     _ => (),\n                 }\n             }\n-            hir::ExprInlineAsm(ref a) => {\n+            hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n                 try!(word(&mut self.s, \"asm!\"));\n                 try!(self.popen());\n                 try!(self.print_string(&a.asm, a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n+                let mut out_idx = 0;\n                 try!(self.commasep(Inconsistent, &a.outputs, |s, out| {\n                     match out.constraint.slice_shift_char() {\n                         Some(('=', operand)) if out.is_rw => {\n@@ -1500,18 +1501,21 @@ impl<'a> State<'a> {\n                         _ => try!(s.print_string(&out.constraint, ast::StrStyle::Cooked)),\n                     }\n                     try!(s.popen());\n-                    try!(s.print_expr(&out.expr));\n+                    try!(s.print_expr(&outputs[out_idx]));\n                     try!(s.pclose());\n+                    out_idx += 1;\n                     Ok(())\n                 }));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.inputs, |s, &(ref co, ref o)| {\n+                let mut in_idx = 0;\n+                try!(self.commasep(Inconsistent, &a.inputs, |s, co| {\n                     try!(s.print_string(&co, ast::StrStyle::Cooked));\n                     try!(s.popen());\n-                    try!(s.print_expr(&o));\n+                    try!(s.print_expr(&inputs[in_idx]));\n                     try!(s.pclose());\n+                    in_idx += 1;\n                     Ok(())\n                 }));\n                 try!(space(&mut self.s));"}, {"sha": "a1dca796d9a42db6a7be6e768c0f33aeb9842a48", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 59, "deletions": 103, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -33,8 +33,6 @@\n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n \n-pub use self::OtherAttribute::*;\n-pub use self::SpecialAttribute::*;\n pub use self::AttributeSet::*;\n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;\n@@ -133,6 +131,7 @@ pub enum DLLStorageClassTypes {\n }\n \n bitflags! {\n+    #[derive(Default, Debug)]\n     flags Attribute : u64 {\n         const ZExt            = 1 << 0,\n         const SExt            = 1 << 1,\n@@ -150,138 +149,95 @@ bitflags! {\n         const OptimizeForSize = 1 << 13,\n         const StackProtect    = 1 << 14,\n         const StackProtectReq = 1 << 15,\n-        const Alignment       = 1 << 16,\n         const NoCapture       = 1 << 21,\n         const NoRedZone       = 1 << 22,\n         const NoImplicitFloat = 1 << 23,\n         const Naked           = 1 << 24,\n         const InlineHint      = 1 << 25,\n-        const Stack           = 7 << 26,\n         const ReturnsTwice    = 1 << 29,\n         const UWTable         = 1 << 30,\n         const NonLazyBind     = 1 << 31,\n+\n+        // Some of these are missing from the LLVM C API, the rest are\n+        // present, but commented out, and preceded by the following warning:\n+        // FIXME: These attributes are currently not included in the C API as\n+        // a temporary measure until the API/ABI impact to the C API is understood\n+        // and the path forward agreed upon.\n+        const SanitizeAddress = 1 << 32,\n+        const MinSize         = 1 << 33,\n+        const NoDuplicate     = 1 << 34,\n+        const StackProtectStrong = 1 << 35,\n+        const SanitizeThread  = 1 << 36,\n+        const SanitizeMemory  = 1 << 37,\n+        const NoBuiltin       = 1 << 38,\n+        const Returned        = 1 << 39,\n+        const Cold            = 1 << 40,\n+        const Builtin         = 1 << 41,\n         const OptimizeNone    = 1 << 42,\n+        const InAlloca        = 1 << 43,\n+        const NonNull         = 1 << 44,\n+        const JumpTable       = 1 << 45,\n+        const Convergent      = 1 << 46,\n+        const SafeStack       = 1 << 47,\n+        const NoRecurse       = 1 << 48,\n+        const InaccessibleMemOnly         = 1 << 49,\n+        const InaccessibleMemOrArgMemOnly = 1 << 50,\n     }\n }\n \n-\n-#[repr(u64)]\n-#[derive(Copy, Clone)]\n-pub enum OtherAttribute {\n-    // The following are not really exposed in\n-    // the LLVM C api so instead to add these\n-    // we call a wrapper function in RustWrapper\n-    // that uses the C++ api.\n-    SanitizeAddressAttribute = 1 << 32,\n-    MinSizeAttribute = 1 << 33,\n-    NoDuplicateAttribute = 1 << 34,\n-    StackProtectStrongAttribute = 1 << 35,\n-    SanitizeThreadAttribute = 1 << 36,\n-    SanitizeMemoryAttribute = 1 << 37,\n-    NoBuiltinAttribute = 1 << 38,\n-    ReturnedAttribute = 1 << 39,\n-    ColdAttribute = 1 << 40,\n-    BuiltinAttribute = 1 << 41,\n-    OptimizeNoneAttribute = 1 << 42,\n-    InAllocaAttribute = 1 << 43,\n-    NonNullAttribute = 1 << 44,\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum SpecialAttribute {\n-    DereferenceableAttribute(u64)\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum AttributeSet {\n-    ReturnIndex = 0,\n-    FunctionIndex = !0\n-}\n-\n-pub trait AttrHelper {\n-    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef);\n-    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef);\n+#[derive(Copy, Clone, Default, Debug)]\n+pub struct Attributes {\n+    regular: Attribute,\n+    dereferenceable_bytes: u64\n }\n \n-impl AttrHelper for Attribute {\n-    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n-        unsafe {\n-            LLVMAddFunctionAttribute(llfn, idx, self.bits() as uint64_t);\n-        }\n+impl Attributes {\n+    pub fn set(&mut self, attr: Attribute) -> &mut Self {\n+        self.regular = self.regular | attr;\n+        self\n     }\n \n-    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n-        unsafe {\n-            LLVMAddCallSiteAttribute(callsite, idx, self.bits() as uint64_t);\n-        }\n+    pub fn unset(&mut self, attr: Attribute) -> &mut Self {\n+        self.regular = self.regular - attr;\n+        self\n     }\n-}\n \n-impl AttrHelper for OtherAttribute {\n-    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n-        unsafe {\n-            LLVMAddFunctionAttribute(llfn, idx, *self as uint64_t);\n-        }\n+    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {\n+        self.dereferenceable_bytes = bytes;\n+        self\n     }\n \n-    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n-        unsafe {\n-            LLVMAddCallSiteAttribute(callsite, idx, *self as uint64_t);\n-        }\n+    pub fn unset_dereferenceable(&mut self) -> &mut Self {\n+        self.dereferenceable_bytes = 0;\n+        self\n     }\n-}\n \n-impl AttrHelper for SpecialAttribute {\n-    fn apply_llfn(&self, idx: c_uint, llfn: ValueRef) {\n-        match *self {\n-            DereferenceableAttribute(bytes) => unsafe {\n-                LLVMAddDereferenceableAttr(llfn, idx, bytes as uint64_t);\n+    pub fn apply_llfn(&self, idx: usize, llfn: ValueRef) {\n+        unsafe {\n+            LLVMAddFunctionAttribute(llfn, idx as c_uint, self.regular.bits());\n+            if self.dereferenceable_bytes != 0 {\n+                LLVMAddDereferenceableAttr(llfn, idx as c_uint,\n+                                           self.dereferenceable_bytes);\n             }\n         }\n     }\n \n-    fn apply_callsite(&self, idx: c_uint, callsite: ValueRef) {\n-        match *self {\n-            DereferenceableAttribute(bytes) => unsafe {\n-                LLVMAddDereferenceableCallSiteAttr(callsite, idx, bytes as uint64_t);\n+    pub fn apply_callsite(&self, idx: usize, callsite: ValueRef) {\n+        unsafe {\n+            LLVMAddCallSiteAttribute(callsite, idx as c_uint, self.regular.bits());\n+            if self.dereferenceable_bytes != 0 {\n+                LLVMAddDereferenceableCallSiteAttr(callsite, idx as c_uint,\n+                                                   self.dereferenceable_bytes);\n             }\n         }\n     }\n }\n \n-pub struct AttrBuilder {\n-    attrs: Vec<(usize, Box<AttrHelper+'static>)>\n-}\n-\n-impl AttrBuilder {\n-    pub fn new() -> AttrBuilder {\n-        AttrBuilder {\n-            attrs: Vec::new()\n-        }\n-    }\n-\n-    pub fn arg<T: AttrHelper + 'static>(&mut self, idx: usize, a: T) -> &mut AttrBuilder {\n-        self.attrs.push((idx, box a as Box<AttrHelper+'static>));\n-        self\n-    }\n-\n-    pub fn ret<T: AttrHelper + 'static>(&mut self, a: T) -> &mut AttrBuilder {\n-        self.attrs.push((ReturnIndex as usize, box a as Box<AttrHelper+'static>));\n-        self\n-    }\n-\n-    pub fn apply_llfn(&self, llfn: ValueRef) {\n-        for &(idx, ref attr) in &self.attrs {\n-            attr.apply_llfn(idx as c_uint, llfn);\n-        }\n-    }\n-\n-    pub fn apply_callsite(&self, callsite: ValueRef) {\n-        for &(idx, ref attr) in &self.attrs {\n-            attr.apply_callsite(idx as c_uint, callsite);\n-        }\n-    }\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum AttributeSet {\n+    ReturnIndex = 0,\n+    FunctionIndex = !0\n }\n \n // enum for the LLVM IntPredicate type"}, {"sha": "5c5574c3a8300eeab57e5268dd080766a4e40e7b", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -125,61 +125,51 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &TyCtxt<'tcx>,\n                                  parent_path: Vec<ast_map::PathElem>,\n                                  parent_def_path: ast_map::DefPath,\n-                                 par_doc: rbml::Doc,\n+                                 ast_doc: rbml::Doc,\n                                  orig_did: DefId)\n-                                 -> Result<&'tcx InlinedItem, (Vec<ast_map::PathElem>,\n-                                                               ast_map::DefPath)> {\n-    match par_doc.opt_child(c::tag_ast) {\n-      None => Err((parent_path, parent_def_path)),\n-      Some(ast_doc) => {\n-        let mut path_as_str = None;\n-        debug!(\"> Decoding inlined fn: {:?}::?\",\n-        {\n-            // Do an Option dance to use the path after it is moved below.\n-            let s = ast_map::path_to_string(parent_path.iter().cloned());\n-            path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| &x[..])\n-        });\n-        let mut ast_dsr = reader::Decoder::new(ast_doc);\n-        let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n-        let to_id_range = reserve_id_range(&tcx.sess, from_id_range);\n-        let dcx = &DecodeContext {\n-            cdata: cdata,\n-            tcx: tcx,\n-            from_id_range: from_id_range,\n-            to_id_range: to_id_range,\n-            last_filemap_index: Cell::new(0)\n-        };\n-        let raw_ii = decode_ast(ast_doc);\n-        let ii = ast_map::map_decoded_item(&dcx.tcx.map,\n-                                           parent_path,\n-                                           parent_def_path,\n-                                           raw_ii,\n-                                           dcx);\n-        let name = match *ii {\n-            InlinedItem::Item(ref i) => i.name,\n-            InlinedItem::Foreign(ref i) => i.name,\n-            InlinedItem::TraitItem(_, ref ti) => ti.name,\n-            InlinedItem::ImplItem(_, ref ii) => ii.name\n-        };\n-        debug!(\"Fn named: {}\", name);\n-        debug!(\"< Decoded inlined fn: {}::{}\",\n-               path_as_str.unwrap(),\n-               name);\n-        region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n-        decode_side_tables(dcx, ast_doc);\n-        copy_item_types(dcx, ii, orig_did);\n-        match *ii {\n-          InlinedItem::Item(ref i) => {\n-            debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   ::rustc_front::print::pprust::item_to_string(&i));\n-          }\n-          _ => { }\n-        }\n-\n-        Ok(ii)\n-      }\n-    }\n+                                 -> &'tcx InlinedItem {\n+    let mut path_as_str = None;\n+    debug!(\"> Decoding inlined fn: {:?}::?\",\n+    {\n+        // Do an Option dance to use the path after it is moved below.\n+        let s = ast_map::path_to_string(parent_path.iter().cloned());\n+        path_as_str = Some(s);\n+        path_as_str.as_ref().map(|x| &x[..])\n+    });\n+    let mut ast_dsr = reader::Decoder::new(ast_doc);\n+    let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n+    let to_id_range = reserve_id_range(&tcx.sess, from_id_range);\n+    let dcx = &DecodeContext {\n+        cdata: cdata,\n+        tcx: tcx,\n+        from_id_range: from_id_range,\n+        to_id_range: to_id_range,\n+        last_filemap_index: Cell::new(0)\n+    };\n+    let ii = ast_map::map_decoded_item(&dcx.tcx.map,\n+                                       parent_path,\n+                                       parent_def_path,\n+                                       decode_ast(ast_doc),\n+                                       dcx);\n+    let name = match *ii {\n+        InlinedItem::Item(ref i) => i.name,\n+        InlinedItem::Foreign(ref i) => i.name,\n+        InlinedItem::TraitItem(_, ref ti) => ti.name,\n+        InlinedItem::ImplItem(_, ref ii) => ii.name\n+    };\n+    debug!(\"Fn named: {}\", name);\n+    debug!(\"< Decoded inlined fn: {}::{}\",\n+            path_as_str.unwrap(),\n+            name);\n+    region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n+    decode_side_tables(dcx, ast_doc);\n+    copy_item_types(dcx, ii, orig_did);\n+    if let InlinedItem::Item(ref i) = *ii {\n+        debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n+               ::rustc_front::print::pprust::item_to_string(&i));\n+    }\n+\n+    ii\n }\n \n // ______________________________________________________________________"}, {"sha": "9ac7216165caf7c60e1839b0350747502adb373d", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use astencode;\n use cstore;\n use decoder;\n use encoder;\n@@ -237,7 +236,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     }\n \n     fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> ty::ImplOrTraitItem<'tcx>\n+                          -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_or_trait_item(\n@@ -439,8 +438,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                           -> FoundAst<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        let decode_inlined_item = Box::new(astencode::decode_inlined_item);\n-        decoder::maybe_get_item_ast(&cdata, tcx, def.index, decode_inlined_item)\n+        decoder::maybe_get_item_ast(&cdata, tcx, def.index)\n     }\n \n     fn maybe_get_item_mir(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n@@ -509,21 +507,18 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                        mir_map: &MirMap<'tcx>,\n                        krate: &hir::Crate) -> Vec<u8>\n     {\n-        let encode_inlined_item: encoder::EncodeInlinedItem =\n-            Box::new(|ecx, rbml_w, ii| astencode::encode_inlined_item(ecx, rbml_w, ii));\n-\n-        let encode_params = encoder::EncodeParams {\n+        let ecx = encoder::EncodeContext {\n             diag: tcx.sess.diagnostic(),\n             tcx: tcx,\n             reexports: reexports,\n             item_symbols: item_symbols,\n             link_meta: link_meta,\n             cstore: self,\n-            encode_inlined_item: encode_inlined_item,\n             reachable: reachable,\n             mir_map: mir_map,\n+            type_abbrevs: RefCell::new(FnvHashMap()),\n         };\n-        encoder::encode_metadata(encode_params, krate)\n+        encoder::encode_metadata(ecx, krate)\n \n     }\n "}, {"sha": "1cb5f2b1c3fbcf86b85287c27bb9bb781edeb23d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 35, "deletions": 58, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -14,6 +14,7 @@\n \n use self::Family::*;\n \n+use astencode::decode_inlined_item;\n use cstore::{self, crate_metadata};\n use common::*;\n use encoder::def_to_u64;\n@@ -797,64 +798,36 @@ pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Nam\n     item_name(intr, cdata.lookup_item(id))\n }\n \n-pub type DecodeInlinedItem<'a> =\n-    Box<for<'tcx> FnMut(Cmd,\n-                        &TyCtxt<'tcx>,\n-                        Vec<hir_map::PathElem>, // parent_path\n-                        hir_map::DefPath,       // parent_def_path\n-                        rbml::Doc,\n-                        DefId)\n-                        -> Result<&'tcx InlinedItem, (Vec<hir_map::PathElem>,\n-                                                      hir_map::DefPath)> + 'a>;\n-\n-pub fn maybe_get_item_ast<'tcx>(cdata: Cmd,\n-                                tcx: &TyCtxt<'tcx>,\n-                                id: DefIndex,\n-                                mut decode_inlined_item: DecodeInlinedItem)\n+pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &TyCtxt<'tcx>, id: DefIndex)\n                                 -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n     let item_did = item_def_id(item_doc, cdata);\n-    let parent_path = {\n-        let mut path = item_path(item_doc);\n-        path.pop();\n-        path\n-    };\n-    let parent_def_path = {\n-        let mut def_path = def_path(cdata, id);\n-        def_path.pop();\n-        def_path\n-    };\n-    match decode_inlined_item(cdata,\n-                              tcx,\n-                              parent_path,\n-                              parent_def_path,\n-                              item_doc,\n-                              item_did) {\n-        Ok(ii) => FoundAst::Found(ii),\n-        Err((mut parent_path, mut parent_def_path)) => {\n-            match item_parent_item(cdata, item_doc) {\n-                Some(parent_did) => {\n-                    // Remove the last element from the paths, since we are now\n-                    // trying to inline the parent.\n-                    parent_path.pop();\n-                    parent_def_path.pop();\n-\n-                    let parent_item = cdata.lookup_item(parent_did.index);\n-                    match decode_inlined_item(cdata,\n-                                              tcx,\n-                                              parent_path,\n-                                              parent_def_path,\n-                                              parent_item,\n-                                              parent_did) {\n-                        Ok(ii) => FoundAst::FoundParent(parent_did, ii),\n-                        Err(_) => FoundAst::NotFound\n-                    }\n-                }\n-                None => FoundAst::NotFound\n+    let mut parent_path = item_path(item_doc);\n+    parent_path.pop();\n+    let mut parent_def_path = def_path(cdata, id);\n+    parent_def_path.pop();\n+    if let Some(ast_doc) = reader::maybe_get_doc(item_doc, tag_ast as usize) {\n+        let ii = decode_inlined_item(cdata, tcx, parent_path,\n+                                     parent_def_path,\n+                                     ast_doc, item_did);\n+        return FoundAst::Found(ii);\n+    } else if let Some(parent_did) = item_parent_item(cdata, item_doc) {\n+        // Remove the last element from the paths, since we are now\n+        // trying to inline the parent.\n+        parent_path.pop();\n+        parent_def_path.pop();\n+        let parent_doc = cdata.lookup_item(parent_did.index);\n+        if let Some(ast_doc) = reader::maybe_get_doc(parent_doc, tag_ast as usize) {\n+            let ii = decode_inlined_item(cdata, tcx, parent_path,\n+                                         parent_def_path,\n+                                         ast_doc, parent_did);\n+            if let &InlinedItem::Item(ref i) = ii {\n+                return FoundAst::FoundParent(parent_did, i);\n             }\n         }\n     }\n+    FoundAst::NotFound\n }\n \n pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n@@ -982,12 +955,16 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n                                     id: DefIndex,\n                                     tcx: &TyCtxt<'tcx>)\n-                                    -> ty::ImplOrTraitItem<'tcx> {\n+                                    -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n     let def_id = item_def_id(item_doc, cdata);\n \n-    let container_id = item_require_parent_item(cdata, item_doc);\n+    let container_id = if let Some(id) = item_parent_item(cdata, item_doc) {\n+        id\n+    } else {\n+        return None;\n+    };\n     let container_doc = cdata.lookup_item(container_id.index);\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n@@ -998,7 +975,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     let vis = item_visibility(item_doc);\n     let defaultness = item_defaultness(item_doc);\n \n-    match item_sort(item_doc) {\n+    Some(match item_sort(item_doc) {\n         sort @ Some('C') | sort @ Some('c') => {\n             let ty = doc_type(item_doc, tcx, cdata);\n             ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n@@ -1044,8 +1021,8 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                 container: container,\n             }))\n         }\n-        _ => panic!(\"unknown impl/trait item sort\"),\n-    }\n+        _ => return None\n+    })\n }\n \n pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n@@ -1085,7 +1062,7 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                                     cdata,\n                                                     did.index,\n                                                     tcx);\n-            if let ty::MethodTraitItem(ref method) = trait_item {\n+            if let Some(ty::MethodTraitItem(ref method)) = trait_item {\n                 Some((*method).clone())\n             } else {\n                 None\n@@ -1114,7 +1091,7 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n                                                             cdata,\n                                                             did.index,\n                                                             tcx);\n-                    if let ty::ConstTraitItem(ref ac) = trait_item {\n+                    if let Some(ty::ConstTraitItem(ref ac)) = trait_item {\n                         Some((*ac).clone())\n                     } else {\n                         None"}, {"sha": "e677ea962f9cf2f9bba5858c6fcdb6778e677a54", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 60, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -13,6 +13,7 @@\n #![allow(unused_must_use)] // everything is just a MemWriter, can't fail\n #![allow(non_camel_case_types)]\n \n+use astencode::encode_inlined_item;\n use common::*;\n use cstore;\n use decoder;\n@@ -55,29 +56,13 @@ use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::Visitor;\n use rustc_front::intravisit;\n \n-pub type EncodeInlinedItem<'a> =\n-    Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n-\n-pub struct EncodeParams<'a, 'tcx: 'a> {\n-    pub diag: &'a Handler,\n-    pub tcx: &'a TyCtxt<'tcx>,\n-    pub reexports: &'a def::ExportMap,\n-    pub item_symbols: &'a RefCell<NodeMap<String>>,\n-    pub link_meta: &'a LinkMeta,\n-    pub cstore: &'a cstore::CStore,\n-    pub encode_inlined_item: EncodeInlinedItem<'a>,\n-    pub reachable: &'a NodeSet,\n-    pub mir_map: &'a MirMap<'tcx>,\n-}\n-\n pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n     pub tcx: &'a TyCtxt<'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n-    pub encode_inlined_item: RefCell<EncodeInlinedItem<'a>>,\n     pub type_abbrevs: tyencode::abbrev_map<'tcx>,\n     pub reachable: &'a NodeSet,\n     pub mir_map: &'a MirMap<'tcx>,\n@@ -688,6 +673,7 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             rbml_w,\n                             InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n                                                      ii));\n+        encode_mir(ecx, rbml_w, ii.id);\n     }\n \n     rbml_w.end_tag();\n@@ -733,6 +719,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w,\n                                     InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n                                                              impl_item));\n+                encode_mir(ecx, rbml_w, impl_item.id);\n             }\n             encode_constness(rbml_w, sig.constness);\n             encode_defaultness(rbml_w, impl_item.defaultness);\n@@ -820,23 +807,6 @@ fn encode_repr_attrs(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_inlined_item(ecx: &EncodeContext,\n-                       rbml_w: &mut Encoder,\n-                       ii: InlinedItemRef) {\n-    let mut eii = ecx.encode_inlined_item.borrow_mut();\n-    let eii: &mut EncodeInlinedItem = &mut *eii;\n-    eii(ecx, rbml_w, ii);\n-\n-    let node_id = match ii {\n-        InlinedItemRef::Item(item) => item.id,\n-        InlinedItemRef::TraitItem(_, trait_item) => trait_item.id,\n-        InlinedItemRef::ImplItem(_, impl_item) => impl_item.id,\n-        InlinedItemRef::Foreign(foreign_item) => foreign_item.id\n-    };\n-\n-    encode_mir(ecx, rbml_w, node_id);\n-}\n-\n fn encode_mir(ecx: &EncodeContext, rbml_w: &mut Encoder, node_id: NodeId) {\n     if let Some(mir) = ecx.mir_map.map.get(&node_id) {\n         rbml_w.start_tag(tag_mir as usize);\n@@ -958,6 +928,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_mir(ecx, rbml_w, item.id);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n@@ -976,6 +947,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n         if needs_inline || constness == hir::Constness::Const {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+            encode_mir(ecx, rbml_w, item.id);\n         }\n         if tps_len == 0 {\n             encode_symbol(ecx, rbml_w, item.id);\n@@ -1044,6 +1016,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n         }\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_mir(ecx, rbml_w, item.id);\n         encode_path(rbml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n@@ -1092,6 +1065,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_struct_fields(rbml_w, variant);\n \n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_mir(ecx, rbml_w, item.id);\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n@@ -1374,6 +1348,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n                     encode_inlined_item(ecx, rbml_w,\n                                         InlinedItemRef::TraitItem(def_id, trait_item));\n+                    encode_mir(ecx, rbml_w, trait_item.id);\n                 }\n                 hir::MethodTraitItem(ref sig, ref body) => {\n                     // If this is a static method, we've already\n@@ -1389,6 +1364,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                         encode_item_sort(rbml_w, 'p');\n                         encode_inlined_item(ecx, rbml_w,\n                                             InlinedItemRef::TraitItem(def_id, trait_item));\n+                        encode_mir(ecx, rbml_w, trait_item.id);\n                     } else {\n                         encode_item_sort(rbml_w, 'r');\n                     }\n@@ -1426,13 +1402,15 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_name(rbml_w, nitem.name);\n         if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n+            encode_mir(ecx, rbml_w, nitem.id);\n+        } else {\n+            encode_symbol(ecx, rbml_w, nitem.id);\n         }\n         encode_attributes(rbml_w, &nitem.attrs);\n         let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n-        encode_symbol(ecx, rbml_w, nitem.id);\n         encode_method_argument_names(rbml_w, &fndecl);\n       }\n       hir::ForeignItemStatic(_, mutbl) => {\n@@ -1928,32 +1906,7 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n #[allow(non_upper_case_globals)]\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2 ];\n \n-pub fn encode_metadata(parms: EncodeParams, krate: &hir::Crate) -> Vec<u8> {\n-    let EncodeParams {\n-        item_symbols,\n-        diag,\n-        tcx,\n-        reexports,\n-        cstore,\n-        encode_inlined_item,\n-        link_meta,\n-        reachable,\n-        mir_map,\n-        ..\n-    } = parms;\n-    let ecx = EncodeContext {\n-        diag: diag,\n-        tcx: tcx,\n-        reexports: reexports,\n-        item_symbols: item_symbols,\n-        link_meta: link_meta,\n-        cstore: cstore,\n-        encode_inlined_item: RefCell::new(encode_inlined_item),\n-        type_abbrevs: RefCell::new(FnvHashMap()),\n-        reachable: reachable,\n-        mir_map: mir_map,\n-    };\n-\n+pub fn encode_metadata(ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n \n     {"}, {"sha": "4c0e9b98d9a6e324bebd8e4f9de0a90d0a9a2107", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -39,8 +39,20 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             ExprKind::Scope { extent, value } => {\n                 this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n             }\n-            ExprKind::InlineAsm { asm } => {\n-                block.and(Rvalue::InlineAsm(asm.clone()))\n+            ExprKind::InlineAsm { asm, outputs, inputs } => {\n+                let outputs = outputs.into_iter().map(|output| {\n+                    unpack!(block = this.as_lvalue(block, output))\n+                }).collect();\n+\n+                let inputs = inputs.into_iter().map(|input| {\n+                    unpack!(block = this.as_operand(block, input))\n+                }).collect();\n+\n+                block.and(Rvalue::InlineAsm {\n+                    asm: asm.clone(),\n+                    outputs: outputs,\n+                    inputs: inputs\n+                })\n             }\n             ExprKind::Repeat { value, count } => {\n                 let value_operand = unpack!(block = this.as_operand(block, value));\n@@ -73,8 +85,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 })\n             }\n             ExprKind::Cast { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n-                block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n+                let source = this.hir.mirror(source);\n+                if source.ty == expr.ty {\n+                    this.expr_as_rvalue(block, source)\n+                } else {\n+                    let source = unpack!(block = this.as_operand(block, source));\n+                    block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n+                }\n             }\n             ExprKind::ReifyFnPointer { source } => {\n                 let source = unpack!(block = this.as_operand(block, source));"}, {"sha": "673ff9e86c440e859dff193c3ad9540e903b9176", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -238,6 +238,13 @@ pub struct MatchPair<'pat, 'tcx:'pat> {\n \n     // ... must match this pattern.\n     pattern: &'pat Pattern<'tcx>,\n+\n+    // HACK(eddyb) This is used to toggle whether a Slice pattern\n+    // has had its length checked. This is only necessary because\n+    // the \"rest\" part of the pattern right now has type &[T] and\n+    // as such, it requires an Rvalue::Slice to be generated.\n+    // See RFC 495 / issue #23121 for the eventual (proper) solution.\n+    slice_len_checked: bool\n }\n \n #[derive(Clone, Debug, PartialEq)]"}, {"sha": "a3337badf884b92d9e0533052dc94fd4a5b98975", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -95,7 +95,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+            PatternKind::Range { .. } |\n+            PatternKind::Variant { .. } => {\n+                // cannot simplify, test is required\n+                Err(match_pair)\n+            }\n+\n+            PatternKind::Slice { .. } if !match_pair.slice_len_checked => {\n+                Err(match_pair)\n+            }\n+\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 unpack!(block = self.prefix_suffix_slice(&mut candidate.match_pairs,\n                                                          block,\n                                                          match_pair.lvalue.clone(),\n@@ -105,13 +116,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 Ok(block)\n             }\n \n-            PatternKind::Slice { .. } |\n-            PatternKind::Range { .. } |\n-            PatternKind::Variant { .. } => {\n-                // cannot simplify, test is required\n-                Err(match_pair)\n-            }\n-\n             PatternKind::Leaf { ref subpatterns } => {\n                 // tuple struct, match subpats (if any)\n                 candidate.match_pairs"}, {"sha": "0efa24f3119432af582b4003f374a42d5fa14e9a", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 94, "deletions": 11, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -75,7 +75,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 }\n             }\n \n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix }\n+                    if !match_pair.slice_len_checked => {\n                 let len = prefix.len() + suffix.len();\n                 let op = if slice.is_some() {\n                     BinOp::Ge\n@@ -89,6 +90,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n \n             PatternKind::Array { .. } |\n+            PatternKind::Slice { .. } |\n             PatternKind::Wild |\n             PatternKind::Binding { .. } |\n             PatternKind::Leaf { .. } |\n@@ -174,14 +176,78 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 targets\n             }\n \n-            TestKind::Eq { ref value, ty } => {\n-                let expect = self.literal_operand(test.span, ty.clone(), Literal::Value {\n-                    value: value.clone()\n-                });\n-                let val = Operand::Consume(lvalue.clone());\n+            TestKind::Eq { ref value, mut ty } => {\n+                let mut val = Operand::Consume(lvalue.clone());\n+\n+                // If we're using b\"...\" as a pattern, we need to insert an\n+                // unsizing coercion, as the byte string has the type &[u8; N].\n+                let expect = if let ConstVal::ByteStr(ref bytes) = *value {\n+                    let tcx = self.hir.tcx();\n+\n+                    // Unsize the lvalue to &[u8], too, if necessary.\n+                    if let ty::TyRef(region, mt) = ty.sty {\n+                        if let ty::TyArray(_, _) = mt.ty.sty {\n+                            ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n+                            let val_slice = self.temp(ty);\n+                            self.cfg.push_assign(block, test.span, &val_slice,\n+                                                 Rvalue::Cast(CastKind::Unsize, val, ty));\n+                            val = Operand::Consume(val_slice);\n+                        }\n+                    }\n+\n+                    assert!(ty.is_slice());\n+\n+                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.len());\n+                    let array_ref = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), array_ty);\n+                    let array = self.literal_operand(test.span, array_ref, Literal::Value {\n+                        value: value.clone()\n+                    });\n+\n+                    let slice = self.temp(ty);\n+                    self.cfg.push_assign(block, test.span, &slice,\n+                                         Rvalue::Cast(CastKind::Unsize, array, ty));\n+                    Operand::Consume(slice)\n+                } else {\n+                    self.literal_operand(test.span, ty, Literal::Value {\n+                        value: value.clone()\n+                    })\n+                };\n+\n+                // Use PartialEq::eq for &str and &[u8] slices, instead of BinOp::Eq.\n                 let fail = self.cfg.start_new_block();\n-                let block = self.compare(block, fail, test.span, BinOp::Eq, expect, val.clone());\n-                vec![block, fail]\n+                if let ty::TyRef(_, mt) = ty.sty {\n+                    assert!(ty.is_slice());\n+                    let eq_def_id = self.hir.tcx().lang_items.eq_trait().unwrap();\n+                    let ty = mt.ty;\n+                    let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, vec![ty]);\n+\n+                    let bool_ty = self.hir.bool_ty();\n+                    let eq_result = self.temp(bool_ty);\n+                    let eq_block = self.cfg.start_new_block();\n+                    let cleanup = self.diverge_cleanup();\n+                    self.cfg.terminate(block, Terminator::Call {\n+                        func: Operand::Constant(Constant {\n+                            span: test.span,\n+                            ty: mty,\n+                            literal: method\n+                        }),\n+                        args: vec![val, expect],\n+                        destination: Some((eq_result.clone(), eq_block)),\n+                        cleanup: cleanup,\n+                    });\n+\n+                    // check the result\n+                    let block = self.cfg.start_new_block();\n+                    self.cfg.terminate(eq_block, Terminator::If {\n+                        cond: Operand::Consume(eq_result),\n+                        targets: (block, fail),\n+                    });\n+\n+                    vec![block, fail]\n+                } else {\n+                    let block = self.compare(block, fail, test.span, BinOp::Eq, expect, val);\n+                    vec![block, fail]\n+                }\n             }\n \n             TestKind::Range { ref lo, ref hi, ty } => {\n@@ -349,9 +415,26 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 }\n             }\n \n-            TestKind::Eq { .. } |\n-            TestKind::Range { .. } |\n+            // If we are performing a length check, then this\n+            // informs slice patterns, but nothing else.\n             TestKind::Len { .. } => {\n+                let pattern_test = self.test(&match_pair);\n+                match *match_pair.pattern.kind {\n+                    PatternKind::Slice { .. } if pattern_test.kind == test.kind => {\n+                        let mut new_candidate = candidate.clone();\n+\n+                        // Set up the MatchKind to simplify this like an array.\n+                        new_candidate.match_pairs[match_pair_index]\n+                                     .slice_len_checked = true;\n+                        resulting_candidates[0].push(new_candidate);\n+                        true\n+                    }\n+                    _ => false\n+                }\n+            }\n+\n+            TestKind::Eq { .. } |\n+            TestKind::Range { .. } => {\n                 // These are all binary tests.\n                 //\n                 // FIXME(#29623) we can be more clever here\n@@ -405,7 +488,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                        .map(|subpattern| {\n                            // e.g., `(x as Variant).0`\n                            let lvalue = downcast_lvalue.clone().field(subpattern.field,\n-                                                                      subpattern.field_ty());\n+                                                                      subpattern.pattern.ty);\n                            // e.g., `(x as Variant).0 @ P1`\n                            MatchPair::new(lvalue, &subpattern.pattern)\n                        });"}, {"sha": "b46c3ffb76a1b82dab822db1771059eb88f14089", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -22,7 +22,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         subpatterns.iter()\n                    .map(|fieldpat| {\n                        let lvalue = lvalue.clone().field(fieldpat.field,\n-                                                         fieldpat.field_ty());\n+                                                         fieldpat.pattern.ty);\n                        MatchPair::new(lvalue, &fieldpat.pattern)\n                    })\n                    .collect()\n@@ -118,6 +118,7 @@ impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n         MatchPair {\n             lvalue: lvalue,\n             pattern: pattern,\n+            slice_len_checked: false,\n         }\n     }\n }"}, {"sha": "b40775f939f75a3abb3be55db739b4e1619ab7c4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -141,15 +141,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 .chain(explicits)\n                 .enumerate()\n                 .map(|(index, (ty, pattern))| {\n+                    let lvalue = Lvalue::Arg(index as u32);\n                     if let Some(pattern) = pattern {\n-                        let lvalue = Lvalue::Arg(index as u32);\n                         let pattern = this.hir.irrefutable_pat(pattern);\n                         unpack!(block = this.lvalue_into_pattern(block,\n                                                                  argument_extent,\n                                                                  pattern,\n                                                                  &lvalue));\n                     }\n-                    ArgDecl { ty: ty }\n+                    // Make sure we drop (parts of) the argument even when not matched on.\n+                    this.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n+                                       argument_extent, &lvalue, ty);\n+                    ArgDecl { ty: ty, spread: false }\n                 })\n                 .collect();\n "}, {"sha": "4d87d926e40551a5fa77ccc224b70dbd4b21e346", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -337,8 +337,12 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 convert_path_expr(cx, self)\n             }\n \n-            hir::ExprInlineAsm(ref asm) => {\n-                ExprKind::InlineAsm { asm: asm }\n+            hir::ExprInlineAsm(ref asm, ref outputs, ref inputs) => {\n+                ExprKind::InlineAsm {\n+                    asm: asm,\n+                    outputs: outputs.to_ref(),\n+                    inputs: inputs.to_ref()\n+                }\n             }\n \n             // Now comes the rote stuff:\n@@ -668,11 +672,16 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n         },\n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => {\n-            if let Some(v) = cx.try_const_eval_literal(expr) {\n-                return ExprKind::Literal { literal: v };\n-            } else {\n-                def_id\n+            let substs = Some(cx.tcx.node_id_item_substs(expr.id).substs);\n+            if let Some((e, _)) = const_eval::lookup_const_by_id(cx.tcx, def_id, substs) {\n+                // FIXME ConstVal can't be yet used with adjustments, as they would be lost.\n+                if !cx.tcx.tables.borrow().adjustments.contains_key(&e.id) {\n+                    if let Some(v) = cx.try_const_eval_literal(e) {\n+                        return ExprKind::Literal { literal: v };\n+                    }\n+                }\n             }\n+            def_id\n         }\n \n         Def::Static(node_id, _) => return ExprKind::StaticRef {"}, {"sha": "b97bfaf5aef68edbe73d2c20db41c432a3fe0737", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -19,7 +19,9 @@ use hair::*;\n use rustc::mir::repr::*;\n \n use rustc::middle::const_eval::{self, ConstVal};\n+use rustc::middle::def_id::DefId;\n use rustc::middle::infer::InferCtxt;\n+use rustc::middle::subst::{Subst, Substs};\n use rustc::middle::ty::{self, Ty, TyCtxt};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -84,9 +86,44 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n \n     pub fn try_const_eval_literal(&mut self, e: &hir::Expr) -> Option<Literal<'tcx>> {\n         let hint = const_eval::EvalHint::ExprTypeChecked;\n-        const_eval::eval_const_expr_partial(self.tcx, e, hint, None)\n-            .ok()\n-            .map(|v| Literal::Value { value: v })\n+        const_eval::eval_const_expr_partial(self.tcx, e, hint, None).ok().and_then(|v| {\n+            match v {\n+                // All of these contain local IDs, unsuitable for storing in MIR.\n+                ConstVal::Struct(_) | ConstVal::Tuple(_) |\n+                ConstVal::Array(..) | ConstVal::Repeat(..) |\n+                ConstVal::Function(_) => None,\n+\n+                _ => Some(Literal::Value { value: v })\n+            }\n+        })\n+    }\n+\n+    pub fn trait_method(&mut self,\n+                        trait_def_id: DefId,\n+                        method_name: &str,\n+                        self_ty: Ty<'tcx>,\n+                        params: Vec<Ty<'tcx>>)\n+                        -> (Ty<'tcx>, Literal<'tcx>) {\n+        let method_name = token::intern(method_name);\n+        let substs = Substs::new_trait(params, vec![], self_ty);\n+        for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n+            match *trait_item {\n+                ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n+                    if method.name == method_name {\n+                        let method_ty = self.tcx.lookup_item_type(method.def_id);\n+                        let method_ty = method_ty.ty.subst(self.tcx, &substs);\n+                        return (method_ty, Literal::Item {\n+                            def_id: method.def_id,\n+                            substs: self.tcx.mk_substs(substs),\n+                        });\n+                    }\n+                }\n+                ty::ImplOrTraitItem::ConstTraitItem(..) |\n+                ty::ImplOrTraitItem::TypeTraitItem(..) => {}\n+            }\n+        }\n+\n+        self.tcx.sess.bug(&format!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id));\n     }\n \n     pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {"}, {"sha": "a98737783741710a32c8ce253e8e2e1d28131602", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -63,6 +63,8 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n     }\n \n     fn to_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n+        let mut ty = self.cx.tcx.node_id_to_type(pat.id);\n+\n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n \n@@ -84,9 +86,9 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match def {\n-                    Def::Const(def_id) | Def::AssociatedConst(def_id) =>\n-                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id,\n-                                                             Some(pat.id), None) {\n+                    Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                        let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n+                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id, substs) {\n                             Some((const_expr, _const_ty)) => {\n                                 let pat = const_eval::const_expr_to_pat(self.cx.tcx, const_expr,\n                                                                         pat.span);\n@@ -97,7 +99,8 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                                     pat.span,\n                                     &format!(\"cannot eval constant: {:?}\", def_id))\n                             }\n-                        },\n+                        }\n+                    }\n                     _ =>\n                         self.cx.tcx.sess.span_bug(\n                             pat.span,\n@@ -169,6 +172,17 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                     hir::BindByRef(hir::MutImmutable) =>\n                         (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Shared)),\n                 };\n+\n+                // A ref x pattern is the same node used for x, and as such it has\n+                // x's type, which is &T, where we want T (the type being matched).\n+                if let hir::BindByRef(_) = bm {\n+                    if let ty::TyRef(_, mt) = ty.sty {\n+                        ty = mt.ty;\n+                    } else {\n+                        unreachable!(\"`ref {}` has wrong type {}\", ident.node, ty);\n+                    }\n+                }\n+\n                 PatternKind::Binding {\n                     mutability: mutability,\n                     mode: mode,\n@@ -234,8 +248,6 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             }\n         };\n \n-        let ty = self.cx.tcx.node_id_to_type(pat.id);\n-\n         Pattern {\n             span: pat.span,\n             ty: ty,\n@@ -314,20 +326,3 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n         }\n     }\n }\n-\n-impl<'tcx> FieldPattern<'tcx> {\n-    pub fn field_ty(&self) -> Ty<'tcx> {\n-        debug!(\"field_ty({:?},ty={:?})\", self, self.pattern.ty);\n-        let r = match *self.pattern.kind {\n-            PatternKind::Binding { mode: BindingMode::ByRef(..), ..} => {\n-                match self.pattern.ty.sty {\n-                    ty::TyRef(_, mt) => mt.ty,\n-                    _ => unreachable!()\n-                }\n-            }\n-            _ => self.pattern.ty\n-        };\n-        debug!(\"field_ty -> {:?}\", r);\n-        r\n-    }\n-}"}, {"sha": "78c438df6f87adac858c6e0d93e6c69d3aff42b4", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -230,6 +230,8 @@ pub enum ExprKind<'tcx> {\n     },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsm,\n+        outputs: Vec<ExprRef<'tcx>>,\n+        inputs: Vec<ExprRef<'tcx>>\n     },\n }\n "}, {"sha": "4717c54ca649161e6b692c2031761110c778459c", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -33,6 +33,7 @@ use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor};\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n@@ -181,13 +182,20 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n     let parameter_scope =\n         cx.tcx().region_maps.lookup_code_extent(\n             CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.id });\n-    Ok(build::construct(cx,\n-                        span,\n-                        implicit_arg_tys,\n-                        arguments,\n-                        parameter_scope,\n-                        fn_sig.output,\n-                        body))\n+    let mut mir = build::construct(cx, span, implicit_arg_tys, arguments,\n+                                  parameter_scope, fn_sig.output, body);\n+\n+    match cx.tcx().node_id_to_type(fn_id).sty {\n+        ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n+            // RustCall pseudo-ABI untuples the last argument.\n+            if let Some(arg_decl) = mir.arg_decls.last_mut() {\n+                arg_decl.spread = true;\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    Ok(mir)\n }\n \n fn closure_self_ty<'a, 'tcx>(tcx: &TyCtxt<'tcx>,"}, {"sha": "9ac3749589e90df0a9989ea73ea918afa9524551", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n             Rvalue::BinaryOp(_, _, _) |\n             Rvalue::UnaryOp(_, _) |\n             Rvalue::Slice { input: _, from_start: _, from_end: _ } |\n-            Rvalue::InlineAsm(_) => {},\n+            Rvalue::InlineAsm {..} => {},\n \n             Rvalue::Repeat(_, ref mut value) => value.ty = self.tcx.erase_regions(&value.ty),\n             Rvalue::Ref(ref mut region, _, _) => *region = ty::ReStatic,"}, {"sha": "c964179d4076a2a87d707e2faa4b518b79b47f4b", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -610,9 +610,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 }\n                 Some(Def::Const(did)) |\n                 Some(Def::AssociatedConst(did)) => {\n-                    if let Some((expr, _ty)) = const_eval::lookup_const_by_id(v.tcx, did,\n-                                                                       Some(e.id),\n-                                                                       None) {\n+                    let substs = Some(v.tcx.node_id_item_substs(e.id).substs);\n+                    if let Some((expr, _)) = const_eval::lookup_const_by_id(v.tcx, did, substs) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n                     }\n@@ -756,7 +755,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         // Expressions with side-effects.\n         hir::ExprAssign(..) |\n         hir::ExprAssignOp(..) |\n-        hir::ExprInlineAsm(_) => {\n+        hir::ExprInlineAsm(..) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0019,"}, {"sha": "c8ce09b4d79754d93040182ff98cf2f1b1f41325", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -61,7 +61,6 @@ pub use rustc::lint;\n pub use rustc::util;\n \n pub mod back {\n-    pub use rustc_back::abi;\n     pub use rustc_back::rpath;\n     pub use rustc_back::svh;\n "}, {"sha": "8aea2f1ec4f4a6150c801ba0bbe57756d5c57b03", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -200,12 +200,13 @@ use middle::lang_items::StrEqFnLangItem;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use middle::pat_util::*;\n+use middle::subst::Substs;\n use trans::adt;\n use trans::base::*;\n use trans::build::{AddCase, And, Br, CondBr, GEPi, InBoundsGEP, Load, PointerCast};\n use trans::build::{Not, Store, Sub, add_comment};\n use trans::build;\n-use trans::callee;\n+use trans::callee::{Callee, ArgVals};\n use trans::cleanup::{self, CleanupMethods, DropHintMethods};\n use trans::common::*;\n use trans::consts;\n@@ -216,6 +217,7 @@ use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use trans::Disr;\n+use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::traits::ProjectionMode;\n use session::config::NoDebugInfo;\n@@ -448,6 +450,12 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n     }\n }\n \n+impl fmt::Debug for MatchInput {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&Value(self.val), f)\n+    }\n+}\n+\n impl MatchInput {\n     fn from_val(val: ValueRef) -> MatchInput {\n         MatchInput {\n@@ -466,11 +474,8 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               col: usize,\n                                               val: MatchInput)\n                                               -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"expand_nested_bindings(bcx={}, m={:?}, col={}, val={})\",\n-           bcx.to_str(),\n-           m,\n-           col,\n-           bcx.val_to_string(val.val));\n+    debug!(\"expand_nested_bindings(bcx={}, m={:?}, col={}, val={:?})\",\n+           bcx.to_str(), m, col, val);\n     let _indenter = indenter();\n \n     m.iter().map(|br| {\n@@ -506,11 +511,8 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n     F: FnMut(&[&'p hir::Pat]) -> Option<Vec<&'p hir::Pat>>,\n {\n-    debug!(\"enter_match(bcx={}, m={:?}, col={}, val={})\",\n-           bcx.to_str(),\n-           m,\n-           col,\n-           bcx.val_to_string(val.val));\n+    debug!(\"enter_match(bcx={}, m={:?}, col={}, val={:?})\",\n+           bcx.to_str(), m, col, val);\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n@@ -549,11 +551,8 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      col: usize,\n                                      val: MatchInput)\n                                      -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_default(bcx={}, m={:?}, col={}, val={})\",\n-           bcx.to_str(),\n-           m,\n-           col,\n-           bcx.val_to_string(val.val));\n+    debug!(\"enter_default(bcx={}, m={:?}, col={}, val={:?})\",\n+           bcx.to_str(), m, col, val);\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n@@ -606,12 +605,8 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              variant_size: usize,\n              val: MatchInput)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_opt(bcx={}, m={:?}, opt={:?}, col={}, val={})\",\n-           bcx.to_str(),\n-           m,\n-           *opt,\n-           col,\n-           bcx.val_to_string(val.val));\n+    debug!(\"enter_opt(bcx={}, m={:?}, opt={:?}, col={}, val={:?})\",\n+           bcx.to_str(), m, *opt, col, val);\n     let _indenter = indenter();\n \n     let ctor = match opt {\n@@ -887,19 +882,21 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               rhs_t: Ty<'tcx>,\n                               debug_loc: DebugLoc)\n                               -> Result<'blk, 'tcx> {\n-    fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+    fn compare_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                lhs_data: ValueRef,\n                                lhs_len: ValueRef,\n                                rhs_data: ValueRef,\n                                rhs_len: ValueRef,\n                                rhs_t: Ty<'tcx>,\n                                debug_loc: DebugLoc)\n                                -> Result<'blk, 'tcx> {\n-        let did = langcall(cx,\n+        let did = langcall(bcx,\n                            None,\n                            &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);\n-        callee::trans_lang_call(cx, did, &[lhs_data, lhs_len, rhs_data, rhs_len], None, debug_loc)\n+        let args = [lhs_data, lhs_len, rhs_data, rhs_len];\n+        Callee::def(bcx.ccx(), did, bcx.tcx().mk_substs(Substs::empty()))\n+            .call(bcx, debug_loc, ArgVals(&args), None)\n     }\n \n     let _icx = push_ctxt(\"compare_values\");\n@@ -1032,7 +1029,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty, opt_datum);\n         }\n \n-        debug!(\"binding {} to {}\", binding_info.id, bcx.val_to_string(llval));\n+        debug!(\"binding {} to {:?}\", binding_info.id, Value(llval));\n         bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n         debuginfo::create_match_binding_metadata(bcx, name, binding_info);\n     }\n@@ -1047,11 +1044,8 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      chk: &FailureHandler,\n                                      has_genuine_default: bool)\n                                      -> Block<'blk, 'tcx> {\n-    debug!(\"compile_guard(bcx={}, guard_expr={:?}, m={:?}, vals=[{}])\",\n-           bcx.to_str(),\n-           guard_expr,\n-           m,\n-           vals.iter().map(|v| bcx.val_to_string(v.val)).collect::<Vec<_>>().join(\", \"));\n+    debug!(\"compile_guard(bcx={}, guard_expr={:?}, m={:?}, vals={:?})\",\n+           bcx.to_str(), guard_expr, m, vals);\n     let _indenter = indenter();\n \n     let mut bcx = insert_lllocals(bcx, &data.bindings_map, None);\n@@ -1093,10 +1087,8 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         vals: &[MatchInput],\n                                         chk: &FailureHandler,\n                                         has_genuine_default: bool) {\n-    debug!(\"compile_submatch(bcx={}, m={:?}, vals=[{}])\",\n-           bcx.to_str(),\n-           m,\n-           vals.iter().map(|v| bcx.val_to_string(v.val)).collect::<Vec<_>>().join(\", \"));\n+    debug!(\"compile_submatch(bcx={}, m={:?}, vals=[{:?}])\",\n+           bcx.to_str(), m, vals);\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n@@ -1256,7 +1248,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"options={:?}\", opts);\n     let mut kind = NoBranch;\n     let mut test_val = val.val;\n-    debug!(\"test_val={}\", bcx.val_to_string(test_val));\n+    debug!(\"test_val={:?}\", Value(test_val));\n     if !opts.is_empty() {\n         match opts[0] {\n             ConstantValue(..) | ConstantRange(..) => {\n@@ -1761,8 +1753,8 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let lvalue = Lvalue::new_with_hint(caller_name, bcx, p_id, HintKind::DontZeroJustUse);\n     let datum = Datum::new(llval, var_ty, lvalue);\n \n-    debug!(\"mk_binding_alloca cleanup_scope={:?} llval={} var_ty={:?}\",\n-           cleanup_scope, bcx.ccx().tn().val_to_string(llval), var_ty);\n+    debug!(\"mk_binding_alloca cleanup_scope={:?} llval={:?} var_ty={:?}\",\n+           cleanup_scope, Value(llval), var_ty);\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1794,10 +1786,8 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: MatchInput,\n                                     cleanup_scope: cleanup::ScopeId)\n                                     -> Block<'blk, 'tcx> {\n-    debug!(\"bind_irrefutable_pat(bcx={}, pat={:?}, val={})\",\n-           bcx.to_str(),\n-           pat,\n-           bcx.val_to_string(val.val));\n+    debug!(\"bind_irrefutable_pat(bcx={}, pat={:?}, val={:?})\",\n+           bcx.to_str(), pat, val);\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={:?})\",\n@@ -1923,7 +1913,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // a regular one\n                 if !type_is_sized(tcx, fty) {\n                     let scratch = alloc_ty(bcx, fty, \"__struct_field_fat_ptr\");\n-                    debug!(\"Creating fat pointer {}\", bcx.val_to_string(scratch));\n+                    debug!(\"Creating fat pointer {:?}\", Value(scratch));\n                     Store(bcx, fldptr, expr::get_dataptr(bcx, scratch));\n                     Store(bcx, val.meta, expr::get_meta(bcx, scratch));\n                     fldptr = scratch;"}, {"sha": "fd086522b2ea33c8c5942ebca461a1d5c5c61a7f", "filename": "src/librustc_trans/trans/abi.rs", "status": "added", "additions": 538, "deletions": 0, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -0,0 +1,538 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::{self, ValueRef};\n+use trans::base;\n+use trans::builder::Builder;\n+use trans::common::{type_is_fat_ptr, BlockAndBuilder};\n+use trans::context::CrateContext;\n+use trans::cabi_x86;\n+use trans::cabi_x86_64;\n+use trans::cabi_x86_win64;\n+use trans::cabi_arm;\n+use trans::cabi_aarch64;\n+use trans::cabi_powerpc;\n+use trans::cabi_powerpc64;\n+use trans::cabi_mips;\n+use trans::cabi_asmjs;\n+use trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n+use trans::type_::Type;\n+use trans::type_of;\n+\n+use rustc_front::hir;\n+use middle::ty::{self, Ty};\n+\n+use libc::c_uint;\n+\n+pub use syntax::abi::Abi;\n+\n+/// The first half of a fat pointer.\n+/// - For a closure, this is the code address.\n+/// - For an object or trait instance, this is the address of the box.\n+/// - For a slice, this is the base address.\n+pub const FAT_PTR_ADDR: usize = 0;\n+\n+/// The second half of a fat pointer.\n+/// - For a closure, this is the address of the environment.\n+/// - For an object or trait instance, this is the address of the vtable.\n+/// - For a slice, this is the length.\n+pub const FAT_PTR_EXTRA: usize = 1;\n+\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+enum ArgKind {\n+    /// Pass the argument directly using the normal converted\n+    /// LLVM type or by coercing to another specified type\n+    Direct,\n+    /// Pass the argument indirectly via a hidden pointer\n+    Indirect,\n+    /// Ignore the argument (useful for empty struct)\n+    Ignore,\n+}\n+\n+/// Information about how a specific C type\n+/// should be passed to or returned from a function\n+///\n+/// This is borrowed from clang's ABIInfo.h\n+#[derive(Clone, Copy, Debug)]\n+pub struct ArgType {\n+    kind: ArgKind,\n+    /// Original LLVM type\n+    pub original_ty: Type,\n+    /// Sizing LLVM type (pointers are opaque).\n+    /// Unlike original_ty, this is guaranteed to be complete.\n+    ///\n+    /// For example, while we're computing the function pointer type in\n+    /// `struct Foo(fn(Foo));`, `original_ty` is still LLVM's `%Foo = {}`.\n+    /// The field type will likely end up being `void(%Foo)*`, but we cannot\n+    /// use `%Foo` to compute properties (e.g. size and alignment) of `Foo`,\n+    /// until `%Foo` is completed by having all of its field types inserted,\n+    /// so `ty` holds the \"sizing type\" of `Foo`, which replaces all pointers\n+    /// with opaque ones, resulting in `{i8*}` for `Foo`.\n+    /// ABI-specific logic can then look at the size, alignment and fields of\n+    /// `{i8*}` in order to determine how the argument will be passed.\n+    /// Only later will `original_ty` aka `%Foo` be used in the LLVM function\n+    /// pointer type, without ever having introspected it.\n+    pub ty: Type,\n+    /// Coerced LLVM Type\n+    pub cast: Option<Type>,\n+    /// Dummy argument, which is emitted before the real argument\n+    pub pad: Option<Type>,\n+    /// LLVM attributes of argument\n+    pub attrs: llvm::Attributes\n+}\n+\n+impl ArgType {\n+    fn new(original_ty: Type, ty: Type) -> ArgType {\n+        ArgType {\n+            kind: ArgKind::Direct,\n+            original_ty: original_ty,\n+            ty: ty,\n+            cast: None,\n+            pad: None,\n+            attrs: llvm::Attributes::default()\n+        }\n+    }\n+\n+    pub fn make_indirect(&mut self, ccx: &CrateContext) {\n+        assert_eq!(self.kind, ArgKind::Direct);\n+\n+        // Wipe old attributes, likely not valid through indirection.\n+        self.attrs = llvm::Attributes::default();\n+\n+        let llarg_sz = llsize_of_real(ccx, self.ty);\n+\n+        // For non-immediate arguments the callee gets its own copy of\n+        // the value on the stack, so there are no aliases. It's also\n+        // program-invisible so can't possibly capture\n+        self.attrs.set(llvm::Attribute::NoAlias)\n+                  .set(llvm::Attribute::NoCapture)\n+                  .set_dereferenceable(llarg_sz);\n+\n+        self.kind = ArgKind::Indirect;\n+    }\n+\n+    pub fn ignore(&mut self) {\n+        assert_eq!(self.kind, ArgKind::Direct);\n+        self.kind = ArgKind::Ignore;\n+    }\n+\n+    pub fn is_indirect(&self) -> bool {\n+        self.kind == ArgKind::Indirect\n+    }\n+\n+    pub fn is_ignore(&self) -> bool {\n+        self.kind == ArgKind::Ignore\n+    }\n+\n+    /// Get the LLVM type for an lvalue of the original Rust type of\n+    /// this argument/return, i.e. the result of `type_of::type_of`.\n+    pub fn memory_ty(&self, ccx: &CrateContext) -> Type {\n+        if self.original_ty == Type::i1(ccx) {\n+            Type::i8(ccx)\n+        } else {\n+            self.original_ty\n+        }\n+    }\n+\n+    /// Store a direct/indirect value described by this ArgType into a\n+    /// lvalue for the original Rust type of this argument/return.\n+    /// Can be used for both storing formal arguments into Rust variables\n+    /// or results of call/invoke instructions into their destinations.\n+    pub fn store(&self, b: &Builder, mut val: ValueRef, dst: ValueRef) {\n+        if self.is_ignore() {\n+            return;\n+        }\n+        if self.is_indirect() {\n+            let llsz = llsize_of(b.ccx, self.ty);\n+            let llalign = llalign_of_min(b.ccx, self.ty);\n+            base::call_memcpy(b, dst, val, llsz, llalign as u32);\n+        } else if let Some(ty) = self.cast {\n+            let cast_dst = b.pointercast(dst, ty.ptr_to());\n+            let store = b.store(val, cast_dst);\n+            let llalign = llalign_of_min(b.ccx, self.ty);\n+            unsafe {\n+                llvm::LLVMSetAlignment(store, llalign);\n+            }\n+        } else {\n+            if self.original_ty == Type::i1(b.ccx) {\n+                val = b.zext(val, Type::i8(b.ccx));\n+            }\n+            b.store(val, dst);\n+        }\n+    }\n+\n+    pub fn store_fn_arg(&self, bcx: &BlockAndBuilder, idx: &mut usize, dst: ValueRef) {\n+        if self.pad.is_some() {\n+            *idx += 1;\n+        }\n+        if self.is_ignore() {\n+            return;\n+        }\n+        let val = llvm::get_param(bcx.fcx().llfn, *idx as c_uint);\n+        *idx += 1;\n+        self.store(bcx, val, dst);\n+    }\n+}\n+\n+/// Metadata describing how the arguments to a native function\n+/// should be passed in order to respect the native ABI.\n+///\n+/// I will do my best to describe this structure, but these\n+/// comments are reverse-engineered and may be inaccurate. -NDM\n+pub struct FnType {\n+    /// The LLVM types of each argument.\n+    pub args: Vec<ArgType>,\n+\n+    /// LLVM return type.\n+    pub ret: ArgType,\n+\n+    pub variadic: bool,\n+\n+    pub cconv: llvm::CallConv\n+}\n+\n+impl FnType {\n+    pub fn new<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                         abi: Abi,\n+                         sig: &ty::FnSig<'tcx>,\n+                         extra_args: &[Ty<'tcx>]) -> FnType {\n+        let mut fn_ty = FnType::unadjusted(ccx, abi, sig, extra_args);\n+        fn_ty.adjust_for_abi(ccx, abi, sig);\n+        fn_ty\n+    }\n+\n+    pub fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                abi: Abi,\n+                                sig: &ty::FnSig<'tcx>,\n+                                extra_args: &[Ty<'tcx>]) -> FnType {\n+        use self::Abi::*;\n+        let cconv = match ccx.sess().target.target.adjust_abi(abi) {\n+            RustIntrinsic | PlatformIntrinsic |\n+            Rust | RustCall => llvm::CCallConv,\n+\n+            // It's the ABI's job to select this, not us.\n+            System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n+\n+            Stdcall => llvm::X86StdcallCallConv,\n+            Fastcall => llvm::X86FastcallCallConv,\n+            Vectorcall => llvm::X86_VectorCall,\n+            C => llvm::CCallConv,\n+            Win64 => llvm::X86_64_Win64,\n+\n+            // These API constants ought to be more specific...\n+            Cdecl => llvm::CCallConv,\n+            Aapcs => llvm::CCallConv,\n+        };\n+\n+        let mut inputs = &sig.inputs[..];\n+        let extra_args = if abi == RustCall {\n+            assert!(!sig.variadic && extra_args.is_empty());\n+\n+            match inputs[inputs.len() - 1].sty {\n+                ty::TyTuple(ref tupled_arguments) => {\n+                    inputs = &inputs[..inputs.len() - 1];\n+                    &tupled_arguments[..]\n+                }\n+                _ => {\n+                    unreachable!(\"argument to function with \\\"rust-call\\\" ABI \\\n+                                  is not a tuple\");\n+                }\n+            }\n+        } else {\n+            assert!(sig.variadic || extra_args.is_empty());\n+            extra_args\n+        };\n+\n+        let target = &ccx.sess().target.target;\n+        let win_x64_gnu = target.target_os == \"windows\"\n+                       && target.arch == \"x86_64\"\n+                       && target.target_env == \"gnu\";\n+        let rust_abi = match abi {\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n+            _ => false\n+        };\n+\n+        let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n+            if ty.is_bool() {\n+                let llty = Type::i1(ccx);\n+                let mut arg = ArgType::new(llty, llty);\n+                arg.attrs.set(llvm::Attribute::ZExt);\n+                arg\n+            } else {\n+                let mut arg = ArgType::new(type_of::type_of(ccx, ty),\n+                                           type_of::sizing_type_of(ccx, ty));\n+                if llsize_of_real(ccx, arg.ty) == 0 {\n+                    // For some forsaken reason, x86_64-pc-windows-gnu\n+                    // doesn't ignore zero-sized struct arguments.\n+                    if is_return || rust_abi || !win_x64_gnu {\n+                        arg.ignore();\n+                    }\n+                }\n+                arg\n+            }\n+        };\n+\n+        let ret_ty = match sig.output {\n+            ty::FnConverging(ret_ty) => ret_ty,\n+            ty::FnDiverging => ccx.tcx().mk_nil()\n+        };\n+        let mut ret = arg_of(ret_ty, true);\n+\n+        if !type_is_fat_ptr(ccx.tcx(), ret_ty) {\n+            // The `noalias` attribute on the return value is useful to a\n+            // function ptr caller.\n+            if let ty::TyBox(_) = ret_ty.sty {\n+                // `Box` pointer return values never alias because ownership\n+                // is transferred\n+                ret.attrs.set(llvm::Attribute::NoAlias);\n+            }\n+\n+            // We can also mark the return value as `dereferenceable` in certain cases\n+            match ret_ty.sty {\n+                // These are not really pointers but pairs, (pointer, len)\n+                ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+                ty::TyBox(ty) => {\n+                    let llty = type_of::sizing_type_of(ccx, ty);\n+                    let llsz = llsize_of_real(ccx, llty);\n+                    ret.attrs.set_dereferenceable(llsz);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let mut args = Vec::with_capacity(inputs.len() + extra_args.len());\n+\n+        // Handle safe Rust thin and fat pointers.\n+        let rust_ptr_attrs = |ty: Ty<'tcx>, arg: &mut ArgType| match ty.sty {\n+            // `Box` pointer parameters never alias because ownership is transferred\n+            ty::TyBox(inner) => {\n+                arg.attrs.set(llvm::Attribute::NoAlias);\n+                Some(inner)\n+            }\n+\n+            ty::TyRef(b, mt) => {\n+                use middle::ty::{BrAnon, ReLateBound};\n+\n+                // `&mut` pointer parameters never alias other parameters, or mutable global data\n+                //\n+                // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n+                // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n+                // on memory dependencies rather than pointer equality\n+                let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n+\n+                if mt.mutbl != hir::MutMutable && !interior_unsafe {\n+                    arg.attrs.set(llvm::Attribute::NoAlias);\n+                }\n+\n+                if mt.mutbl == hir::MutImmutable && !interior_unsafe {\n+                    arg.attrs.set(llvm::Attribute::ReadOnly);\n+                }\n+\n+                // When a reference in an argument has no named lifetime, it's\n+                // impossible for that reference to escape this function\n+                // (returned or stored beyond the call by a closure).\n+                if let ReLateBound(_, BrAnon(_)) = *b {\n+                    arg.attrs.set(llvm::Attribute::NoCapture);\n+                }\n+\n+                Some(mt.ty)\n+            }\n+            _ => None\n+        };\n+\n+        for ty in inputs.iter().chain(extra_args.iter()) {\n+            let mut arg = arg_of(ty, false);\n+\n+            if type_is_fat_ptr(ccx.tcx(), ty) {\n+                let original_tys = arg.original_ty.field_types();\n+                let sizing_tys = arg.ty.field_types();\n+                assert_eq!((original_tys.len(), sizing_tys.len()), (2, 2));\n+\n+                let mut data = ArgType::new(original_tys[0], sizing_tys[0]);\n+                let mut info = ArgType::new(original_tys[1], sizing_tys[1]);\n+\n+                if let Some(inner) = rust_ptr_attrs(ty, &mut data) {\n+                    data.attrs.set(llvm::Attribute::NonNull);\n+                    if ccx.tcx().struct_tail(inner).is_trait() {\n+                        info.attrs.set(llvm::Attribute::NonNull);\n+                    }\n+                }\n+                args.push(data);\n+                args.push(info);\n+            } else {\n+                if let Some(inner) = rust_ptr_attrs(ty, &mut arg) {\n+                    let llty = type_of::sizing_type_of(ccx, inner);\n+                    let llsz = llsize_of_real(ccx, llty);\n+                    arg.attrs.set_dereferenceable(llsz);\n+                }\n+                args.push(arg);\n+            }\n+        }\n+\n+        FnType {\n+            args: args,\n+            ret: ret,\n+            variadic: sig.variadic,\n+            cconv: cconv\n+        }\n+    }\n+\n+    pub fn adjust_for_abi<'a, 'tcx>(&mut self,\n+                                    ccx: &CrateContext<'a, 'tcx>,\n+                                    abi: Abi,\n+                                    sig: &ty::FnSig<'tcx>) {\n+        if abi == Abi::Rust || abi == Abi::RustCall ||\n+           abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+            let fixup = |arg: &mut ArgType| {\n+                let mut llty = arg.ty;\n+\n+                // Replace newtypes with their inner-most type.\n+                while llty.kind() == llvm::TypeKind::Struct {\n+                    let inner = llty.field_types();\n+                    if inner.len() != 1 {\n+                        break;\n+                    }\n+                    llty = inner[0];\n+                }\n+\n+                if !llty.is_aggregate() {\n+                    // Scalars and vectors, always immediate.\n+                    if llty != arg.ty {\n+                        // Needs a cast as we've unpacked a newtype.\n+                        arg.cast = Some(llty);\n+                    }\n+                    return;\n+                }\n+\n+                let size = llsize_of_real(ccx, llty);\n+                if size > llsize_of_real(ccx, ccx.int_type()) {\n+                    arg.make_indirect(ccx);\n+                } else if size > 0 {\n+                    // We want to pass small aggregates as immediates, but using\n+                    // a LLVM aggregate type for this leads to bad optimizations,\n+                    // so we pick an appropriately sized integer type instead.\n+                    arg.cast = Some(Type::ix(ccx, size * 8));\n+                }\n+            };\n+            // Fat pointers are returned by-value.\n+            if !self.ret.is_ignore() {\n+                if !type_is_fat_ptr(ccx.tcx(), sig.output.unwrap()) {\n+                    fixup(&mut self.ret);\n+                }\n+            }\n+            for arg in &mut self.args {\n+                if arg.is_ignore() { continue; }\n+                fixup(arg);\n+            }\n+            if self.ret.is_indirect() {\n+                self.ret.attrs.set(llvm::Attribute::StructRet);\n+            }\n+            return;\n+        }\n+\n+        match &ccx.sess().target.target.arch[..] {\n+            \"x86\" => cabi_x86::compute_abi_info(ccx, self),\n+            \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n+                cabi_x86_win64::compute_abi_info(ccx, self);\n+            } else {\n+                cabi_x86_64::compute_abi_info(ccx, self);\n+            },\n+            \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, self),\n+            \"arm\" => {\n+                let flavor = if ccx.sess().target.target.target_os == \"ios\" {\n+                    cabi_arm::Flavor::Ios\n+                } else {\n+                    cabi_arm::Flavor::General\n+                };\n+                cabi_arm::compute_abi_info(ccx, self, flavor);\n+            },\n+            \"mips\" => cabi_mips::compute_abi_info(ccx, self),\n+            \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, self),\n+            \"powerpc64\" => cabi_powerpc64::compute_abi_info(ccx, self),\n+            \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, self),\n+            a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n+        }\n+\n+        if self.ret.is_indirect() {\n+            self.ret.attrs.set(llvm::Attribute::StructRet);\n+        }\n+    }\n+\n+    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+        let mut llargument_tys = Vec::new();\n+\n+        let llreturn_ty = if self.ret.is_ignore() {\n+            Type::void(ccx)\n+        } else if self.ret.is_indirect() {\n+            llargument_tys.push(self.ret.original_ty.ptr_to());\n+            Type::void(ccx)\n+        } else {\n+            self.ret.cast.unwrap_or(self.ret.original_ty)\n+        };\n+\n+        for arg in &self.args {\n+            if arg.is_ignore() {\n+                continue;\n+            }\n+            // add padding\n+            if let Some(ty) = arg.pad {\n+                llargument_tys.push(ty);\n+            }\n+\n+            let llarg_ty = if arg.is_indirect() {\n+                arg.original_ty.ptr_to()\n+            } else {\n+                arg.cast.unwrap_or(arg.original_ty)\n+            };\n+\n+            llargument_tys.push(llarg_ty);\n+        }\n+\n+        if self.variadic {\n+            Type::variadic_func(&llargument_tys, &llreturn_ty)\n+        } else {\n+            Type::func(&llargument_tys, &llreturn_ty)\n+        }\n+    }\n+\n+    pub fn apply_attrs_llfn(&self, llfn: ValueRef) {\n+        let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n+        if !self.ret.is_ignore() {\n+            self.ret.attrs.apply_llfn(i, llfn);\n+        }\n+        i += 1;\n+        for arg in &self.args {\n+            if !arg.is_ignore() {\n+                if arg.pad.is_some() { i += 1; }\n+                arg.attrs.apply_llfn(i, llfn);\n+                i += 1;\n+            }\n+        }\n+    }\n+\n+    pub fn apply_attrs_callsite(&self, callsite: ValueRef) {\n+        let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n+        if !self.ret.is_ignore() {\n+            self.ret.attrs.apply_callsite(i, callsite);\n+        }\n+        i += 1;\n+        for arg in &self.args {\n+            if !arg.is_ignore() {\n+                if arg.pad.is_some() { i += 1; }\n+                arg.attrs.apply_callsite(i, callsite);\n+                i += 1;\n+            }\n+        }\n+\n+        if self.cconv != llvm::CCallConv {\n+            llvm::SetInstructionCallConv(callsite, self.cconv);\n+        }\n+    }\n+}"}, {"sha": "45a1236647e406ff71a74be26ffd286a30c24aa7", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 51, "deletions": 40, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -48,13 +48,13 @@ use std;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n-use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n use middle::ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n use trans::_match;\n+use trans::abi::FAT_PTR_ADDR;\n use trans::base::InitAlloca;\n use trans::build::*;\n use trans::cleanup;\n@@ -67,6 +67,7 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n+use trans::value::Value;\n \n type Hint = attr::ReprAttr;\n \n@@ -88,11 +89,6 @@ impl TypeContext {\n     fn may_need_drop_flag(t: Type, needs_drop_flag: bool) -> TypeContext {\n         TypeContext { prefix: t, needs_drop_flag: needs_drop_flag }\n     }\n-    pub fn to_string(self) -> String {\n-        let TypeContext { prefix, needs_drop_flag } = self;\n-        format!(\"TypeContext {{ prefix: {}, needs_drop_flag: {} }}\",\n-                prefix.to_string(), needs_drop_flag)\n-    }\n }\n \n /// Representations.\n@@ -1069,6 +1065,15 @@ pub fn num_args(r: &Repr, discr: Disr) -> usize {\n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                                    val: MaybeSizedValue, discr: Disr, ix: usize) -> ValueRef {\n+    trans_field_ptr_builder(&bcx.build(), r, val, discr, ix)\n+}\n+\n+/// Access a field, at a point when the value's case is known.\n+pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n+                                           r: &Repr<'tcx>,\n+                                           val: MaybeSizedValue,\n+                                           discr: Disr, ix: usize)\n+                                           -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n@@ -1091,13 +1096,15 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n             // The contents of memory at this pointer can't matter, but use\n             // the value that's \"reasonable\" in case of pointer comparison.\n-            PointerCast(bcx, val.value, ty.ptr_to())\n+            if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n+            bcx.pointercast(val.value, ty.ptr_to())\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             assert_eq!(ix, 0);\n             assert_eq!(discr, nndiscr);\n             let ty = type_of::type_of(bcx.ccx(), nnty);\n-            PointerCast(bcx, val.value, ty.ptr_to())\n+            if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n+            bcx.pointercast(val.value, ty.ptr_to())\n         }\n         StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             assert_eq!(discr, nndiscr);\n@@ -1106,43 +1113,48 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n     }\n }\n \n-pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, val: MaybeSizedValue,\n-                                    ix: usize, needs_cast: bool) -> ValueRef {\n+fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n+                                st: &Struct<'tcx>, val: MaybeSizedValue,\n+                                ix: usize, needs_cast: bool) -> ValueRef {\n     let ccx = bcx.ccx();\n+    let fty = st.fields[ix];\n+    let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n+    if bcx.is_unreachable() {\n+        return C_undef(ll_fty.ptr_to());\n+    }\n+\n     let ptr_val = if needs_cast {\n         let fields = st.fields.iter().map(|&ty| {\n             type_of::in_memory_type_of(ccx, ty)\n         }).collect::<Vec<_>>();\n         let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n-        PointerCast(bcx, val.value, real_ty.ptr_to())\n+        bcx.pointercast(val.value, real_ty.ptr_to())\n     } else {\n         val.value\n     };\n \n-    let fty = st.fields[ix];\n     // Simple case - we can just GEP the field\n     //   * First field - Always aligned properly\n     //   * Packed struct - There is no alignment padding\n     //   * Field is sized - pointer is properly aligned already\n     if ix == 0 || st.packed || type_is_sized(bcx.tcx(), fty) {\n-        return StructGEP(bcx, ptr_val, ix);\n+        return bcx.struct_gep(ptr_val, ix);\n     }\n \n     // If the type of the last field is [T] or str, then we don't need to do\n     // any adjusments\n     match fty.sty {\n         ty::TySlice(..) | ty::TyStr => {\n-            return StructGEP(bcx, ptr_val, ix);\n+            return bcx.struct_gep(ptr_val, ix);\n         }\n         _ => ()\n     }\n \n     // There's no metadata available, log the case and just do the GEP.\n     if !val.has_meta() {\n-        debug!(\"Unsized field `{}`, of `{}` has no metadata for adjustment\",\n-               ix,\n-               bcx.val_to_string(ptr_val));\n-        return StructGEP(bcx, ptr_val, ix);\n+        debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n+               ix, Value(ptr_val));\n+        return bcx.struct_gep(ptr_val, ix);\n     }\n \n     let dbloc = DebugLoc::None;\n@@ -1183,23 +1195,21 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     //   (unaligned offset + (align - 1)) & -align\n \n     // Calculate offset\n-    let align_sub_1 = Sub(bcx, align, C_uint(bcx.ccx(), 1u64), dbloc);\n-    let offset = And(bcx,\n-                     Add(bcx, unaligned_offset, align_sub_1, dbloc),\n-                     Neg(bcx, align, dbloc),\n-                     dbloc);\n+    dbloc.apply(bcx.fcx());\n+    let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx(), 1u64));\n+    let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n+                         bcx.neg(align));\n \n-    debug!(\"struct_field_ptr: DST field offset: {}\",\n-           bcx.val_to_string(offset));\n+    debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n     // Cast and adjust pointer\n-    let byte_ptr = PointerCast(bcx, ptr_val, Type::i8p(bcx.ccx()));\n-    let byte_ptr = GEP(bcx, byte_ptr, &[offset]);\n+    let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx()));\n+    let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n     // Finally, cast back to the type expected\n     let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n-    debug!(\"struct_field_ptr: Field type is {}\", ll_fty.to_string());\n-    PointerCast(bcx, byte_ptr, ll_fty.ptr_to())\n+    debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n+    bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n }\n \n pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n@@ -1283,14 +1293,15 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n                 bcx, tcx.dtor_type(), \"drop_flag\",\n                 InitAlloca::Uninit(\"drop flag itself has no dtor\"),\n-                cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| {\n+                cleanup::CustomScope(custom_cleanup_scope), |bcx, _| {\n                     debug!(\"no-op populate call for trans_drop_flag_ptr on dtor_type={:?}\",\n                            tcx.dtor_type());\n                     bcx\n                 }\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n-                let ptr = struct_field_ptr(variant_cx, st, MaybeSizedValue::sized(value),\n+                let ptr = struct_field_ptr(&variant_cx.build(), st,\n+                                           MaybeSizedValue::sized(value),\n                                            (st.fields.len() - 1), false);\n                 datum::Datum::new(ptr, ptr_ty, datum::Lvalue::new(\"adt::trans_drop_flag_ptr\"))\n                     .store_to(variant_cx, scratch.val)\n@@ -1442,7 +1453,7 @@ fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.\n-pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef) -> Disr {\n+pub fn const_get_discrim(r: &Repr, val: ValueRef) -> Disr {\n     match *r {\n         CEnum(ity, _, _) => {\n             match ity {\n@@ -1452,13 +1463,13 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef) -> Disr {\n         }\n         General(ity, _, _) => {\n             match ity {\n-                attr::SignedInt(..) => Disr(const_to_int(const_get_elt(ccx, val, &[0])) as u64),\n-                attr::UnsignedInt(..) => Disr(const_to_uint(const_get_elt(ccx, val, &[0])))\n+                attr::SignedInt(..) => Disr(const_to_int(const_get_elt(val, &[0])) as u64),\n+                attr::UnsignedInt(..) => Disr(const_to_uint(const_get_elt(val, &[0])))\n             }\n         }\n         Univariant(..) => Disr(0),\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n-            ccx.sess().bug(\"const discrim access of non c-like enum\")\n+            unreachable!(\"const discrim access of non c-like enum\")\n         }\n     }\n }\n@@ -1472,25 +1483,25 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: usize) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n-        Univariant(..) => const_struct_field(ccx, val, ix),\n-        General(..) => const_struct_field(ccx, val, ix + 1),\n+        Univariant(..) => const_struct_field(val, ix),\n+        General(..) => const_struct_field(val, ix + 1),\n         RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);\n             val\n         },\n-        StructWrappedNullablePointer{ .. } => const_struct_field(ccx, val, ix)\n+        StructWrappedNullablePointer{ .. } => const_struct_field(val, ix)\n     }\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: usize) -> ValueRef {\n+fn const_struct_field(val: ValueRef, ix: usize) -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct\n     let mut ix = ix; // logical index relative to real_ix\n     let mut field;\n     loop {\n         loop {\n-            field = const_get_elt(ccx, val, &[real_ix]);\n+            field = const_get_elt(val, &[real_ix]);\n             if !is_undef(field) {\n                 break;\n             }"}, {"sha": "4d0c55131f765c2a26e7f971d5ba82c4536798ef", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 36, "deletions": 74, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -10,13 +10,11 @@\n \n //! # Translation of inline assembly.\n \n-use llvm;\n+use llvm::{self, ValueRef};\n+use trans::base;\n use trans::build::*;\n-use trans::callee;\n use trans::common::*;\n-use trans::cleanup;\n-use trans::cleanup::CleanupMethods;\n-use trans::expr;\n+use trans::datum::{Datum, Lvalue};\n use trans::type_of;\n use trans::type_::Type;\n \n@@ -26,64 +24,35 @@ use syntax::ast::AsmDialect;\n use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n-                                    -> Block<'blk, 'tcx> {\n-    let fcx = bcx.fcx;\n-    let mut bcx = bcx;\n-    let mut constraints = Vec::new();\n-    let mut output_types = Vec::new();\n-\n-    let temp_scope = fcx.push_custom_cleanup_scope();\n-\n-    let mut ext_inputs = Vec::new();\n-    let mut ext_constraints = Vec::new();\n+pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    ia: &ast::InlineAsm,\n+                                    outputs: Vec<Datum<'tcx, Lvalue>>,\n+                                    mut inputs: Vec<ValueRef>) {\n+    let mut ext_constraints = vec![];\n+    let mut output_types = vec![];\n \n     // Prepare the output operands\n-    let mut outputs = Vec::new();\n-    let mut inputs = Vec::new();\n-    for (i, out) in ia.outputs.iter().enumerate() {\n-        constraints.push(out.constraint.clone());\n-\n-        let out_datum = unpack_datum!(bcx, expr::trans(bcx, &out.expr));\n+    let mut indirect_outputs = vec![];\n+    for (i, (out, out_datum)) in ia.outputs.iter().zip(&outputs).enumerate() {\n+        let val = if out.is_rw || out.is_indirect {\n+            Some(base::load_ty(bcx, out_datum.val, out_datum.ty))\n+        } else {\n+            None\n+        };\n+        if out.is_rw {\n+            inputs.push(val.unwrap());\n+            ext_constraints.push(i.to_string());\n+        }\n         if out.is_indirect {\n-            bcx = callee::trans_arg_datum(bcx,\n-                                          expr_ty(bcx, &out.expr),\n-                                          out_datum,\n-                                          cleanup::CustomScope(temp_scope),\n-                                          &mut inputs);\n-            if out.is_rw {\n-                ext_inputs.push(*inputs.last().unwrap());\n-                ext_constraints.push(i.to_string());\n-            }\n+            indirect_outputs.push(val.unwrap());\n         } else {\n             output_types.push(type_of::type_of(bcx.ccx(), out_datum.ty));\n-            outputs.push(out_datum.val);\n-            if out.is_rw {\n-                bcx = callee::trans_arg_datum(bcx,\n-                                              expr_ty(bcx, &out.expr),\n-                                              out_datum,\n-                                              cleanup::CustomScope(temp_scope),\n-                                              &mut ext_inputs);\n-                ext_constraints.push(i.to_string());\n-            }\n         }\n     }\n-\n-    // Now the input operands\n-    for &(ref c, ref input) in &ia.inputs {\n-        constraints.push((*c).clone());\n-\n-        let in_datum = unpack_datum!(bcx, expr::trans(bcx, &input));\n-        bcx = callee::trans_arg_datum(bcx,\n-                                    expr_ty(bcx, &input),\n-                                    in_datum,\n-                                    cleanup::CustomScope(temp_scope),\n-                                    &mut inputs);\n+    if !indirect_outputs.is_empty() {\n+        indirect_outputs.extend_from_slice(&inputs);\n+        inputs = indirect_outputs;\n     }\n-    inputs.extend_from_slice(&ext_inputs[..]);\n-\n-    // no failure occurred preparing operands, no need to cleanup\n-    fcx.pop_custom_cleanup_scope(temp_scope);\n \n     let clobbers = ia.clobbers.iter()\n                               .map(|s| format!(\"~{{{}}}\", &s));\n@@ -95,19 +64,18 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         _                => Vec::new()\n     };\n \n-    let all_constraints= constraints.iter()\n-                                    .map(|s| s.to_string())\n-                                    .chain(ext_constraints)\n-                                    .chain(clobbers)\n-                                    .chain(arch_clobbers.iter()\n-                                               .map(|s| s.to_string()))\n-                                    .collect::<Vec<String>>()\n-                                    .join(\",\");\n+    let all_constraints =\n+        ia.outputs.iter().map(|out| out.constraint.to_string())\n+          .chain(ia.inputs.iter().map(|s| s.to_string()))\n+          .chain(ext_constraints)\n+          .chain(clobbers)\n+          .chain(arch_clobbers.iter().map(|s| s.to_string()))\n+          .collect::<Vec<String>>().join(\",\");\n \n     debug!(\"Asm Constraints: {}\", &all_constraints[..]);\n \n     // Depending on how many outputs we have, the return type is different\n-    let num_outputs = outputs.len();\n+    let num_outputs = output_types.len();\n     let output_type = match num_outputs {\n         0 => Type::void(bcx.ccx()),\n         1 => output_types[0],\n@@ -131,13 +99,10 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                           dialect);\n \n     // Again, based on how many outputs we have\n-    if num_outputs == 1 {\n-        Store(bcx, r, outputs[0]);\n-    } else {\n-        for (i, o) in outputs.iter().enumerate() {\n-            let v = ExtractValue(bcx, r, i);\n-            Store(bcx, v, *o);\n-        }\n+    let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n+    for (i, (_, datum)) in outputs.enumerate() {\n+        let v = if num_outputs == 1 { r } else { ExtractValue(bcx, r, i) };\n+        Store(bcx, v, datum.val);\n     }\n \n     // Store expn_id in a metadata node so we can map LLVM errors\n@@ -152,7 +117,4 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bcx.ccx().llcx(), &val, 1));\n     }\n-\n-    return bcx;\n-\n }"}, {"sha": "99dc3ade823fa7794e24c6edf9891c054521f198", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 5, "deletions": 200, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -10,20 +10,11 @@\n //! Set and unset common attributes on LLVM values.\n \n use libc::{c_uint, c_ulonglong};\n-use llvm::{self, ValueRef, AttrHelper};\n-use middle::ty;\n-use middle::infer;\n-use middle::traits::ProjectionMode;\n+use llvm::{self, ValueRef};\n use session::config::NoDebugInfo;\n-use syntax::abi::Abi;\n pub use syntax::attr::InlineAttr;\n use syntax::ast;\n-use rustc_front::hir;\n-use trans::base;\n-use trans::common;\n use trans::context::CrateContext;\n-use trans::machine;\n-use trans::type_of;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n@@ -112,199 +103,13 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n \n     for attr in attrs {\n         if attr.check_name(\"cold\") {\n-            unsafe {\n-                llvm::LLVMAddFunctionAttribute(llfn,\n-                                               llvm::FunctionIndex as c_uint,\n-                                               llvm::ColdAttribute as u64)\n-            }\n+            llvm::Attributes::default().set(llvm::Attribute::Cold)\n+                .apply_llfn(llvm::FunctionIndex as usize, llfn)\n         } else if attr.check_name(\"allocator\") {\n-            llvm::Attribute::NoAlias.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n+            llvm::Attributes::default().set(llvm::Attribute::NoAlias)\n+                .apply_llfn(llvm::ReturnIndex as usize, llfn)\n         } else if attr.check_name(\"unwind\") {\n             unwind(llfn, true);\n         }\n     }\n }\n-\n-/// Composite function which converts function type into LLVM attributes for the function.\n-pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx>)\n-                              -> llvm::AttrBuilder {\n-    use middle::ty::{BrAnon, ReLateBound};\n-\n-    let function_type;\n-    let (fn_sig, abi, env_ty) = match fn_type.sty {\n-        ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => (&f.sig, f.abi, None),\n-        ty::TyClosure(closure_did, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(),\n-                                                      &ccx.tcx().tables,\n-                                                      ProjectionMode::Any);\n-            function_type = infcx.closure_type(closure_did, substs);\n-            let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n-            (&function_type.sig, Abi::RustCall, Some(self_type))\n-        }\n-        _ => ccx.sess().bug(\"expected closure or function.\")\n-    };\n-\n-    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n-    let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n-\n-    let mut attrs = llvm::AttrBuilder::new();\n-    let ret_ty = fn_sig.output;\n-\n-    // These have an odd calling convention, so we need to manually\n-    // unpack the input ty's\n-    let input_tys = match fn_type.sty {\n-        ty::TyClosure(..) => {\n-            assert!(abi == Abi::RustCall);\n-\n-            match fn_sig.inputs[0].sty {\n-                ty::TyTuple(ref inputs) => {\n-                    let mut full_inputs = vec![env_ty.expect(\"Missing closure environment\")];\n-                    full_inputs.extend_from_slice(inputs);\n-                    full_inputs\n-                }\n-                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n-            }\n-        },\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) if abi == Abi::RustCall => {\n-            let mut inputs = vec![fn_sig.inputs[0]];\n-\n-            match fn_sig.inputs[1].sty {\n-                ty::TyTuple(ref t_in) => {\n-                    inputs.extend_from_slice(&t_in[..]);\n-                    inputs\n-                }\n-                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n-            }\n-        }\n-        _ => fn_sig.inputs.clone()\n-    };\n-\n-    // Index 0 is the return value of the llvm func, so we start at 1\n-    let mut idx = 1;\n-    if let ty::FnConverging(ret_ty) = ret_ty {\n-        // A function pointer is called without the declaration\n-        // available, so we have to apply any attributes with ABI\n-        // implications directly to the call instruction. Right now,\n-        // the only attribute we need to worry about is `sret`.\n-        if type_of::return_uses_outptr(ccx, ret_ty) {\n-            let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n-\n-            // The outptr can be noalias and nocapture because it's entirely\n-            // invisible to the program. We also know it's nonnull as well\n-            // as how many bytes we can dereference\n-            attrs.arg(1, llvm::Attribute::StructRet)\n-                 .arg(1, llvm::Attribute::NoAlias)\n-                 .arg(1, llvm::Attribute::NoCapture)\n-                 .arg(1, llvm::DereferenceableAttribute(llret_sz));\n-\n-            // Add one more since there's an outptr\n-            idx += 1;\n-        } else {\n-            // The `noalias` attribute on the return value is useful to a\n-            // function ptr caller.\n-            match ret_ty.sty {\n-                // `Box` pointer return values never alias because ownership\n-                // is transferred\n-                ty::TyBox(it) if common::type_is_sized(ccx.tcx(), it) => {\n-                    attrs.ret(llvm::Attribute::NoAlias);\n-                }\n-                _ => {}\n-            }\n-\n-            // We can also mark the return value as `dereferenceable` in certain cases\n-            match ret_ty.sty {\n-                // These are not really pointers but pairs, (pointer, len)\n-                ty::TyRef(_, ty::TypeAndMut { ty: inner, .. })\n-                | ty::TyBox(inner) if common::type_is_sized(ccx.tcx(), inner) => {\n-                    let llret_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-                    attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n-                }\n-                _ => {}\n-            }\n-\n-            if let ty::TyBool = ret_ty.sty {\n-                attrs.ret(llvm::Attribute::ZExt);\n-            }\n-        }\n-    }\n-\n-    for &t in input_tys.iter() {\n-        match t.sty {\n-            _ if type_of::arg_is_indirect(ccx, t) => {\n-                let llarg_sz = machine::llsize_of_real(ccx, type_of::type_of(ccx, t));\n-\n-                // For non-immediate arguments the callee gets its own copy of\n-                // the value on the stack, so there are no aliases. It's also\n-                // program-invisible so can't possibly capture\n-                attrs.arg(idx, llvm::Attribute::NoAlias)\n-                     .arg(idx, llvm::Attribute::NoCapture)\n-                     .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n-            }\n-\n-            ty::TyBool => {\n-                attrs.arg(idx, llvm::Attribute::ZExt);\n-            }\n-\n-            // `Box` pointer parameters never alias because ownership is transferred\n-            ty::TyBox(inner) => {\n-                attrs.arg(idx, llvm::Attribute::NoAlias);\n-\n-                if common::type_is_sized(ccx.tcx(), inner) {\n-                    let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-                    attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n-                } else {\n-                    attrs.arg(idx, llvm::NonNullAttribute);\n-                    if inner.is_trait() {\n-                        attrs.arg(idx + 1, llvm::NonNullAttribute);\n-                    }\n-                }\n-            }\n-\n-            ty::TyRef(b, mt) => {\n-                // `&mut` pointer parameters never alias other parameters, or mutable global data\n-                //\n-                // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n-                // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n-                // on memory dependencies rather than pointer equality\n-                let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n-\n-                if mt.mutbl != hir::MutMutable && !interior_unsafe {\n-                    attrs.arg(idx, llvm::Attribute::NoAlias);\n-                }\n-\n-                if mt.mutbl == hir::MutImmutable && !interior_unsafe {\n-                    attrs.arg(idx, llvm::Attribute::ReadOnly);\n-                }\n-\n-                // & pointer parameters are also never null and for sized types we also know\n-                // exactly how many bytes we can dereference\n-                if common::type_is_sized(ccx.tcx(), mt.ty) {\n-                    let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                    attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n-                } else {\n-                    attrs.arg(idx, llvm::NonNullAttribute);\n-                    if mt.ty.is_trait() {\n-                        attrs.arg(idx + 1, llvm::NonNullAttribute);\n-                    }\n-                }\n-\n-                // When a reference in an argument has no named lifetime, it's\n-                // impossible for that reference to escape this function\n-                // (returned or stored beyond the call by a closure).\n-                if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx, llvm::Attribute::NoCapture);\n-                }\n-            }\n-\n-            _ => ()\n-        }\n-\n-        if common::type_is_fat_ptr(ccx.tcx(), t) {\n-            idx += 2;\n-        } else {\n-            idx += 1;\n-        }\n-    }\n-\n-    attrs\n-}"}, {"sha": "93ca306f0b0a2a464bbf18846c6ca94607769e8b", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 554, "deletions": 1012, "changes": 1566, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -10,8 +10,8 @@\n //! Translate the completed AST to the LLVM IR.\n //!\n //! Some functions here, such as trans_block and trans_expr, return a value --\n-//! the result of the translation to LLVM -- while others, such as trans_fn,\n-//! trans_impl, and trans_item, are called only for the side effect of adding a\n+//! the result of the translation to LLVM -- while others, such as trans_fn\n+//! and trans_item, are called only for the side effect of adding a\n //! particular definition to the LLVM IR output we're producing.\n //!\n //! Hopefully useful general knowledge about trans:\n@@ -30,7 +30,7 @@ use super::CrateTranslation;\n use super::ModuleTranslation;\n \n use back::link::mangle_exported_name;\n-use back::{link, abi};\n+use back::link;\n use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n@@ -52,20 +52,21 @@ use rustc::mir::mir_map::MirMap;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n+use trans::abi::{self, Abi, FnType};\n use trans::adt;\n use trans::assert_dep_graph;\n use trans::attributes;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n-use trans::callee;\n+use trans::callee::{Callee, CallArgs, ArgExprs, ArgVals};\n use trans::cleanup::{self, CleanupMethods, DropHint};\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n use trans::collector::{self, TransItem, TransItemState, TransItemCollectionMode};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan, VariantInfo};\n-use trans::common::{node_id_type, return_type_is_void, fulfill_obligation};\n+use trans::common::{node_id_type, fulfill_obligation};\n use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n use trans::common;\n use trans::consts;\n@@ -75,14 +76,14 @@ use trans::datum;\n use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::declare;\n use trans::expr;\n-use trans::foreign;\n use trans::glue;\n+use trans::inline;\n use trans::intrinsic;\n use trans::machine;\n-use trans::machine::{llsize_of, llsize_of_real};\n+use trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n use trans::meth;\n use trans::mir;\n-use trans::monomorphize;\n+use trans::monomorphize::{self, Instance};\n use trans::tvec;\n use trans::type_::Type;\n use trans::type_of;\n@@ -100,7 +101,6 @@ use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n use std::str;\n use std::{i8, i16, i32, i64};\n-use syntax::abi::Abi;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::InternedString;\n use syntax::attr::AttrMetaMethods;\n@@ -192,72 +192,10 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                fn_ty: Ty<'tcx>,\n-                                name: &str,\n-                                attrs: &[ast::Attribute])\n-                                -> ValueRef {\n-    if let Some(n) = ccx.externs().borrow().get(name) {\n-        return *n;\n-    }\n-\n-    let f = declare::declare_rust_fn(ccx, name, fn_ty);\n-    attributes::from_fn_attrs(ccx, &attrs, f);\n-\n-    ccx.externs().borrow_mut().insert(name.to_string(), f);\n-    f\n-}\n-\n-pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       closure_id: DefId,\n-                                       fn_ty: Ty<'tcx>)\n-                                       -> Ty<'tcx> {\n-    let closure_kind = ccx.tcx().closure_kind(closure_id);\n-    match closure_kind {\n-        ty::ClosureKind::Fn => {\n-            ccx.tcx().mk_imm_ref(ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n-        }\n-        ty::ClosureKind::FnMut => {\n-            ccx.tcx().mk_mut_ref(ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n-        }\n-        ty::ClosureKind::FnOnce => fn_ty,\n-    }\n-}\n-\n pub fn kind_for_closure(ccx: &CrateContext, closure_id: DefId) -> ty::ClosureKind {\n     *ccx.tcx().tables.borrow().closure_kinds.get(&closure_id).unwrap()\n }\n \n-pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                  did: DefId,\n-                                  t: Ty<'tcx>)\n-                                  -> ValueRef {\n-    let name = ccx.sess().cstore.item_symbol(did);\n-    let ty = type_of(ccx, t);\n-    if let Some(n) = ccx.externs().borrow_mut().get(&name) {\n-        return *n;\n-    }\n-    // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-    // FIXME(nagisa): investigate whether it can be changed into define_global\n-    let c = declare::declare_global(ccx, &name[..], ty);\n-    // Thread-local statics in some other crate need to *always* be linked\n-    // against in a thread-local fashion, so we need to be sure to apply the\n-    // thread-local attribute locally if it was present remotely. If we\n-    // don't do this then linker errors can be generated where the linker\n-    // complains that one object files has a thread local version of the\n-    // symbol and another one doesn't.\n-    for attr in ccx.tcx().get_attrs(did).iter() {\n-        if attr.check_name(\"thread_local\") {\n-            llvm::set_thread_local(c, true);\n-        }\n-    }\n-    if ccx.use_dll_storage_attrs() {\n-        llvm::SetDLLStorageClass(c, llvm::DLLImportStorageClass);\n-    }\n-    ccx.externs().borrow_mut().insert(name.to_string(), c);\n-    return c;\n-}\n-\n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, info_ty: Ty<'tcx>, it: LangItem) -> DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n@@ -280,11 +218,9 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"malloc_raw_exchange\");\n \n     // Allocate space:\n-    let r = callee::trans_lang_call(bcx,\n-                                    require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem),\n-                                    &[size, align],\n-                                    None,\n-                                    debug_loc);\n+    let def_id = require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem);\n+    let r = Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n+        .call(bcx, debug_loc, ArgVals(&[size, align]), None);\n \n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n@@ -897,47 +833,16 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn get_extern_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               def_id: DefId)\n-                               -> datum::Datum<'tcx, datum::Rvalue> {\n-    let name = ccx.sess().cstore.item_symbol(def_id);\n-    let attrs = ccx.sess().cstore.item_attrs(def_id);\n-    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n-    match ty.sty {\n-        ty::TyFnDef(_, _, fty) => {\n-            let abi = fty.abi;\n-            let fty = infer::normalize_associated_type(ccx.tcx(), fty);\n-            let ty = ccx.tcx().mk_fn_ptr(fty);\n-            let llfn = match ccx.sess().target.target.adjust_abi(abi) {\n-                Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n-                    ccx.sess().bug(\"unexpected intrinsic in get_extern_fn\")\n-                }\n-                Abi::Rust | Abi::RustCall => {\n-                    get_extern_rust_fn(ccx, ty, &name, &attrs)\n-                }\n-                _ => {\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, &name, &attrs)\n-                }\n-            };\n-            datum::immediate_rvalue(llfn, ty)\n-        }\n-        _ => unreachable!(\"get_extern_fn: expected fn item type, found {}\", ty)\n-    }\n-}\n-\n pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: &[ValueRef],\n-                          fn_ty: Ty<'tcx>,\n                           debug_loc: DebugLoc)\n                           -> (ValueRef, Block<'blk, 'tcx>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n-    let attributes = attributes::from_fn_type(bcx.ccx(), fn_ty);\n-\n     match bcx.opt_node_id {\n         None => {\n             debug!(\"invoke at ???\");\n@@ -948,9 +853,9 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     if need_invoke(bcx) {\n-        debug!(\"invoking {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n+        debug!(\"invoking {:?} at {:?}\", Value(llfn), bcx.llbb);\n         for &llarg in llargs {\n-            debug!(\"arg: {}\", bcx.val_to_string(llarg));\n+            debug!(\"arg: {:?}\", Value(llarg));\n         }\n         let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n         let landing_pad = bcx.fcx.get_landing_pad();\n@@ -960,16 +865,15 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               &llargs[..],\n                               normal_bcx.llbb,\n                               landing_pad,\n-                              Some(attributes),\n                               debug_loc);\n         return (llresult, normal_bcx);\n     } else {\n-        debug!(\"calling {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n+        debug!(\"calling {:?} at {:?}\", Value(llfn), bcx.llbb);\n         for &llarg in llargs {\n-            debug!(\"arg: {}\", bcx.val_to_string(llarg));\n+            debug!(\"arg: {:?}\", Value(llarg));\n         }\n \n-        let llresult = Call(bcx, llfn, &llargs[..], Some(attributes), debug_loc);\n+        let llresult = Call(bcx, llfn, &llargs[..], debug_loc);\n         return (llresult, bcx);\n     }\n }\n@@ -1007,48 +911,43 @@ pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, t: Ty<'\n /// differs from the type used for SSA values. Also handles various special cases where the type\n /// gives us better information about what we are loading.\n pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n-    if cx.unreachable.get() || type_is_zero_size(cx.ccx(), t) {\n+    if cx.unreachable.get() {\n         return C_undef(type_of::type_of(cx.ccx(), t));\n     }\n+    load_ty_builder(&B(cx), ptr, t)\n+}\n \n-    let ptr = to_arg_ty_ptr(cx, ptr, t);\n-    let align = type_of::align_of(cx.ccx(), t);\n-\n-    if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n-        let load = Load(cx, ptr);\n-        unsafe {\n-            llvm::LLVMSetAlignment(load, align);\n-        }\n-        return load;\n+pub fn load_ty_builder<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n+    let ccx = b.ccx;\n+    if type_is_zero_size(ccx, t) {\n+        return C_undef(type_of::type_of(ccx, t));\n     }\n \n     unsafe {\n         let global = llvm::LLVMIsAGlobalVariable(ptr);\n         if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n             let val = llvm::LLVMGetInitializer(global);\n             if !val.is_null() {\n-                return to_arg_ty(cx, val, t);\n+                if t.is_bool() {\n+                    return llvm::LLVMConstTrunc(val, Type::i1(ccx).to_ref());\n+                }\n+                return val;\n             }\n         }\n     }\n \n-    let val = if t.is_bool() {\n-        LoadRangeAssert(cx, ptr, 0, 2, llvm::False)\n+    if t.is_bool() {\n+        b.trunc(b.load_range_assert(ptr, 0, 2, llvm::False), Type::i1(ccx))\n     } else if t.is_char() {\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n-        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n-    } else if (t.is_region_ptr() || t.is_unique()) && !common::type_is_fat_ptr(cx.tcx(), t) {\n-        LoadNonNull(cx, ptr)\n+        b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False)\n+    } else if (t.is_region_ptr() || t.is_unique()) &&\n+              !common::type_is_fat_ptr(ccx.tcx(), t) {\n+        b.load_nonnull(ptr)\n     } else {\n-        Load(cx, ptr)\n-    };\n-\n-    unsafe {\n-        llvm::LLVMSetAlignment(val, align);\n+        b.load(ptr)\n     }\n-\n-    to_arg_ty(cx, val, t)\n }\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n@@ -1058,10 +957,7 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n         return;\n     }\n \n-    debug!(\"store_ty: {} : {:?} <- {}\",\n-           cx.val_to_string(dst),\n-           t,\n-           cx.val_to_string(v));\n+    debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.tcx(), t) {\n         Store(cx,\n@@ -1071,10 +967,7 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n               ExtractValue(cx, v, abi::FAT_PTR_EXTRA),\n               expr::get_meta(cx, dst));\n     } else {\n-        let store = Store(cx, from_arg_ty(cx, v, t), to_arg_ty_ptr(cx, dst, t));\n-        unsafe {\n-            llvm::LLVMSetAlignment(store, type_of::align_of(cx.ccx(), t));\n-        }\n+        Store(cx, from_immediate(cx, v), dst);\n     }\n }\n \n@@ -1097,33 +990,22 @@ pub fn load_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n      Load(cx, expr::get_meta(cx, src)))\n }\n \n-pub fn from_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n-    if ty.is_bool() {\n+pub fn from_immediate(bcx: Block, val: ValueRef) -> ValueRef {\n+    if val_ty(val) == Type::i1(bcx.ccx()) {\n         ZExt(bcx, val, Type::i8(bcx.ccx()))\n     } else {\n         val\n     }\n }\n \n-pub fn to_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n+pub fn to_immediate(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n     if ty.is_bool() {\n         Trunc(bcx, val, Type::i1(bcx.ccx()))\n     } else {\n         val\n     }\n }\n \n-pub fn to_arg_ty_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef, ty: Ty<'tcx>) -> ValueRef {\n-    if type_is_immediate(bcx.ccx(), ty) && type_of::type_of(bcx.ccx(), ty).is_aggregate() {\n-        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n-        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n-        // and we have to convert it\n-        BitCast(bcx, ptr, type_of::arg_type_of(bcx.ccx(), ty).ptr_to())\n-    } else {\n-        ptr\n-    }\n-}\n-\n pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &hir::Local) -> Block<'blk, 'tcx> {\n     debug!(\"init_local(bcx={}, local.id={})\", bcx.to_str(), local.id);\n     let _indenter = indenter();\n@@ -1200,7 +1082,6 @@ pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n         Call(cx,\n              lifetime_start,\n              &[C_u64(ccx, size), ptr],\n-             None,\n              DebugLoc::None);\n     })\n }\n@@ -1211,7 +1092,6 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n         Call(cx,\n              lifetime_end,\n              &[C_u64(ccx, size), ptr],\n-             None,\n              DebugLoc::None);\n     })\n }\n@@ -1222,44 +1102,42 @@ pub fn trans_unwind_resume(bcx: Block, lpval: ValueRef) {\n         Resume(bcx, lpval);\n     } else {\n         let exc_ptr = ExtractValue(bcx, lpval, 0);\n-        let llunwresume = bcx.fcx.eh_unwind_resume();\n-        Call(bcx, llunwresume, &[exc_ptr], None, DebugLoc::None);\n-        Unreachable(bcx);\n+        bcx.fcx.eh_unwind_resume()\n+            .call(bcx, DebugLoc::None, ArgVals(&[exc_ptr]), None);\n     }\n }\n \n-\n-pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n+pub fn call_memcpy<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n+                               dst: ValueRef,\n+                               src: ValueRef,\n+                               n_bytes: ValueRef,\n+                               align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n-    let ccx = cx.ccx();\n+    let ccx = b.ccx;\n     let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n     let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n     let memcpy = ccx.get_intrinsic(&key);\n-    let src_ptr = PointerCast(cx, src, Type::i8p(ccx));\n-    let dst_ptr = PointerCast(cx, dst, Type::i8p(ccx));\n-    let size = IntCast(cx, n_bytes, ccx.int_type());\n+    let src_ptr = b.pointercast(src, Type::i8p(ccx));\n+    let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n+    let size = b.intcast(n_bytes, ccx.int_type());\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n-    Call(cx,\n-         memcpy,\n-         &[dst_ptr, src_ptr, size, align, volatile],\n-         None,\n-         DebugLoc::None);\n+    b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, dst: ValueRef, src: ValueRef, t: Ty<'tcx>) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n \n-    if type_is_zero_size(ccx, t) {\n+    if type_is_zero_size(ccx, t) || bcx.unreachable.get() {\n         return;\n     }\n \n     if t.is_structural() {\n         let llty = type_of::type_of(ccx, t);\n         let llsz = llsize_of(ccx, llty);\n         let llalign = type_of::align_of(ccx, t);\n-        call_memcpy(bcx, dst, src, llsz, llalign as u32);\n+        call_memcpy(&B(bcx), dst, src, llsz, llalign as u32);\n     } else if common::type_is_fat_ptr(bcx.tcx(), t) {\n         let (data, extra) = load_fat_ptr(bcx, src, t);\n         store_fat_ptr(bcx, data, extra, dst, t);\n@@ -1313,7 +1191,7 @@ pub fn call_memset<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let volatile = C_bool(ccx, volatile);\n-    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None, None);\n+    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n }\n \n \n@@ -1388,7 +1266,7 @@ pub fn alloca_dropped<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>, name: &st\n     // Block, which we do not have for `alloca_insert_pt`).\n     core_lifetime_emit(cx.ccx(), p, Lifetime::Start, |ccx, size, lifetime_start| {\n         let ptr = b.pointercast(p, Type::i8p(ccx));\n-        b.call(lifetime_start, &[C_u64(ccx, size), ptr], None, None);\n+        b.call(lifetime_start, &[C_u64(ccx, size), ptr], None);\n     });\n     memfill(&b, p, ty, adt::DTOR_DONE);\n     p\n@@ -1412,41 +1290,6 @@ pub fn set_value_name(val: ValueRef, name: &str) {\n     }\n }\n \n-// Creates the alloca slot which holds the pointer to the slot for the final return value\n-pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                                          output_type: Ty<'tcx>)\n-                                          -> ValueRef {\n-    let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-\n-    // We create an alloca to hold a pointer of type `output_type`\n-    // which will hold the pointer to the right alloca which has the\n-    // final ret value\n-    if fcx.needs_ret_allocas {\n-        // Let's create the stack slot\n-        let slot = AllocaFcx(fcx, lloutputtype.ptr_to(), \"llretslotptr\");\n-\n-        // and if we're using an out pointer, then store that in our newly made slot\n-        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n-            let outptr = get_param(fcx.llfn, 0);\n-\n-            let b = fcx.ccx.builder();\n-            b.position_before(fcx.alloca_insert_pt.get().unwrap());\n-            b.store(outptr, slot);\n-        }\n-\n-        slot\n-\n-    // But if there are no nested returns, we skip the indirection and have a single\n-    // retslot\n-    } else {\n-        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n-            get_param(fcx.llfn, 0)\n-        } else {\n-            AllocaFcx(fcx, lloutputtype, \"sret_slot\")\n-        }\n-    }\n-}\n-\n struct FindNestedReturn {\n     found: bool,\n }\n@@ -1553,517 +1396,477 @@ fn has_nested_returns(tcx: &TyCtxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool\n     return false;\n }\n \n-// NB: must keep 4 fns in sync:\n-//\n-//  - type_of_fn\n-//  - create_datums_for_fn_args.\n-//  - new_fn_ctxt\n-//  - trans_args\n-//\n-// Be warned! You must call `init_function` before doing anything with the\n-// returned function context.\n-pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                             llfndecl: ValueRef,\n-                             id: ast::NodeId,\n-                             has_env: bool,\n-                             output_type: ty::FnOutput<'tcx>,\n-                             param_substs: &'tcx Substs<'tcx>,\n-                             sp: Option<Span>,\n-                             block_arena: &'a TypedArena<common::BlockS<'a, 'tcx>>)\n-                             -> FunctionContext<'a, 'tcx> {\n-    common::validate_substs(param_substs);\n-\n-    debug!(\"new_fn_ctxt(path={}, id={}, param_substs={:?})\",\n-           if id == !0 {\n-               \"\".to_string()\n-           } else {\n-               ccx.tcx().map.path_to_string(id).to_string()\n-           },\n-           id,\n-           param_substs);\n-\n-    let uses_outptr = match output_type {\n-        ty::FnConverging(output_type) => {\n-            let substd_output_type = monomorphize::apply_param_substs(ccx.tcx(),\n-                                                                      param_substs,\n-                                                                      &output_type);\n-            type_of::return_uses_outptr(ccx, substd_output_type)\n-        }\n-        ty::FnDiverging => false,\n-    };\n-    let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n-    let (blk_id, cfg) = build_cfg(ccx.tcx(), id);\n-    let nested_returns = if let Some(ref cfg) = cfg {\n-        has_nested_returns(ccx.tcx(), cfg, blk_id)\n-    } else {\n-        false\n-    };\n+impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n+    /// Create a function context for the given function.\n+    /// Beware that you must call `fcx.init` or `fcx.bind_args`\n+    /// before doing anything with the returned function context.\n+    pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n+               llfndecl: ValueRef,\n+               fn_ty: FnType,\n+               def_id: Option<DefId>,\n+               param_substs: &'tcx Substs<'tcx>,\n+               block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n+               -> FunctionContext<'blk, 'tcx> {\n+        common::validate_substs(param_substs);\n+\n+        let inlined_did = def_id.and_then(|def_id| inline::get_local_instance(ccx, def_id));\n+        let inlined_id = inlined_did.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n+        let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n+\n+        debug!(\"FunctionContext::new(path={}, def_id={:?}, param_substs={:?})\",\n+            inlined_id.map_or(String::new(), |id| {\n+                ccx.tcx().map.path_to_string(id).to_string()\n+            }),\n+            def_id,\n+            param_substs);\n+\n+        let debug_context = debuginfo::create_function_debug_context(ccx,\n+            inlined_id.unwrap_or(ast::DUMMY_NODE_ID), param_substs, llfndecl);\n+\n+        let cfg = inlined_id.map(|id| build_cfg(ccx.tcx(), id));\n+        let nested_returns = if let Some((blk_id, Some(ref cfg))) = cfg {\n+            has_nested_returns(ccx.tcx(), cfg, blk_id)\n+        } else {\n+            false\n+        };\n \n-    let mir = ccx.mir_map().map.get(&id);\n-\n-    let mut fcx = FunctionContext {\n-        mir: mir,\n-        llfn: llfndecl,\n-        llenv: None,\n-        llretslotptr: Cell::new(None),\n-        param_env: ccx.tcx().empty_parameter_environment(),\n-        alloca_insert_pt: Cell::new(None),\n-        llreturn: Cell::new(None),\n-        needs_ret_allocas: nested_returns,\n-        landingpad_alloca: Cell::new(None),\n-        caller_expects_out_pointer: uses_outptr,\n-        lllocals: RefCell::new(NodeMap()),\n-        llupvars: RefCell::new(NodeMap()),\n-        lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n-        id: id,\n-        param_substs: param_substs,\n-        span: sp,\n-        block_arena: block_arena,\n-        lpad_arena: TypedArena::new(),\n-        ccx: ccx,\n-        debug_context: debug_context,\n-        scopes: RefCell::new(Vec::new()),\n-        cfg: cfg,\n-    };\n+        let check_attrs = |attrs: &[ast::Attribute]| {\n+            let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n+            let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n+            default_to_mir ^ attrs.iter().any(|item| item.check_name(invert))\n+        };\n \n-    if has_env {\n-        fcx.llenv = Some(get_param(fcx.llfn, fcx.env_arg_pos() as c_uint))\n-    }\n-\n-    fcx\n-}\n-\n-/// Performs setup on a newly created function, creating the entry scope block\n-/// and allocating space for the return pointer.\n-pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n-                               skip_retptr: bool,\n-                               output: ty::FnOutput<'tcx>)\n-                               -> Block<'a, 'tcx> {\n-    let entry_bcx = fcx.new_temp_block(\"entry-block\");\n-\n-    // Use a dummy instruction as the insertion point for all allocas.\n-    // This is later removed in FunctionContext::cleanup.\n-    fcx.alloca_insert_pt.set(Some(unsafe {\n-        Load(entry_bcx, C_null(Type::i8p(fcx.ccx)));\n-        llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n-    }));\n-\n-    if let ty::FnConverging(output_type) = output {\n-        // This shouldn't need to recompute the return type,\n-        // as new_fn_ctxt did it already.\n-        let substd_output_type = fcx.monomorphize(&output_type);\n-        if !return_type_is_void(fcx.ccx, substd_output_type) {\n-            // If the function returns nil/bot, there is no real return\n-            // value, so do not set `llretslotptr`.\n-            if !skip_retptr || fcx.caller_expects_out_pointer {\n-                // Otherwise, we normally allocate the llretslotptr, unless we\n-                // have been instructed to skip it for immediate return\n-                // values.\n-                fcx.llretslotptr.set(Some(make_return_slot_pointer(fcx, substd_output_type)));\n-            }\n+        let use_mir = if let Some(id) = local_id {\n+            check_attrs(ccx.tcx().map.attrs(id))\n+        } else if let Some(def_id) = def_id {\n+            check_attrs(&ccx.sess().cstore.item_attrs(def_id))\n+        } else {\n+            check_attrs(&[])\n+        };\n+\n+        let mir = if use_mir {\n+            def_id.and_then(|id| ccx.get_mir(id))\n+        } else {\n+            None\n+        };\n+\n+        FunctionContext {\n+            needs_ret_allocas: nested_returns && mir.is_none(),\n+            mir: mir,\n+            llfn: llfndecl,\n+            llretslotptr: Cell::new(None),\n+            param_env: ccx.tcx().empty_parameter_environment(),\n+            alloca_insert_pt: Cell::new(None),\n+            llreturn: Cell::new(None),\n+            landingpad_alloca: Cell::new(None),\n+            lllocals: RefCell::new(NodeMap()),\n+            llupvars: RefCell::new(NodeMap()),\n+            lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n+            fn_ty: fn_ty,\n+            param_substs: param_substs,\n+            span: inlined_id.and_then(|id| ccx.tcx().map.opt_span(id)),\n+            block_arena: block_arena,\n+            lpad_arena: TypedArena::new(),\n+            ccx: ccx,\n+            debug_context: debug_context,\n+            scopes: RefCell::new(Vec::new()),\n+            cfg: cfg.and_then(|(_, cfg)| cfg)\n+        }\n+    }\n+\n+    /// Performs setup on a newly created function, creating the entry\n+    /// scope block and allocating space for the return pointer.\n+    pub fn init(&'blk self, skip_retptr: bool, fn_did: Option<DefId>)\n+                -> Block<'blk, 'tcx> {\n+        let entry_bcx = self.new_temp_block(\"entry-block\");\n+\n+        // Use a dummy instruction as the insertion point for all allocas.\n+        // This is later removed in FunctionContext::cleanup.\n+        self.alloca_insert_pt.set(Some(unsafe {\n+            Load(entry_bcx, C_null(Type::i8p(self.ccx)));\n+            llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n+        }));\n+\n+        if !self.fn_ty.ret.is_ignore() && !skip_retptr {\n+            // We normally allocate the llretslotptr, unless we\n+            // have been instructed to skip it for immediate return\n+            // values, or there is nothing to return at all.\n+\n+            // We create an alloca to hold a pointer of type `ret.original_ty`\n+            // which will hold the pointer to the right alloca which has the\n+            // final ret value\n+            let llty = self.fn_ty.ret.memory_ty(self.ccx);\n+            let slot = if self.needs_ret_allocas {\n+                // Let's create the stack slot\n+                let slot = AllocaFcx(self, llty.ptr_to(), \"llretslotptr\");\n+\n+                // and if we're using an out pointer, then store that in our newly made slot\n+                if self.fn_ty.ret.is_indirect() {\n+                    let outptr = get_param(self.llfn, 0);\n+\n+                    let b = self.ccx.builder();\n+                    b.position_before(self.alloca_insert_pt.get().unwrap());\n+                    b.store(outptr, slot);\n+                }\n+\n+                slot\n+            } else {\n+                // But if there are no nested returns, we skip the indirection\n+                // and have a single retslot\n+                if self.fn_ty.ret.is_indirect() {\n+                    get_param(self.llfn, 0)\n+                } else {\n+                    AllocaFcx(self, llty, \"sret_slot\")\n+                }\n+            };\n+\n+            self.llretslotptr.set(Some(slot));\n         }\n-    }\n \n-    // Create the drop-flag hints for every unfragmented path in the function.\n-    let tcx = fcx.ccx.tcx();\n-    let fn_did = tcx.map.local_def_id(fcx.id);\n-    let tables = tcx.tables.borrow();\n-    let mut hints = fcx.lldropflag_hints.borrow_mut();\n-    let fragment_infos = tcx.fragment_infos.borrow();\n+        // Create the drop-flag hints for every unfragmented path in the function.\n+        let tcx = self.ccx.tcx();\n+        let tables = tcx.tables.borrow();\n+        let mut hints = self.lldropflag_hints.borrow_mut();\n+        let fragment_infos = tcx.fragment_infos.borrow();\n \n-    // Intern table for drop-flag hint datums.\n-    let mut seen = HashMap::new();\n+        // Intern table for drop-flag hint datums.\n+        let mut seen = HashMap::new();\n \n-    if let Some(fragment_infos) = fragment_infos.get(&fn_did) {\n-        for &info in fragment_infos {\n+        let fragment_infos = fn_did.and_then(|did| fragment_infos.get(&did));\n+        if let Some(fragment_infos) = fragment_infos {\n+            for &info in fragment_infos {\n \n-            let make_datum = |id| {\n-                let init_val = C_u8(fcx.ccx, adt::DTOR_NEEDED_HINT);\n-                let llname = &format!(\"dropflag_hint_{}\", id);\n-                debug!(\"adding hint {}\", llname);\n-                let ty = tcx.types.u8;\n-                let ptr = alloc_ty(entry_bcx, ty, llname);\n-                Store(entry_bcx, init_val, ptr);\n-                let flag = datum::Lvalue::new_dropflag_hint(\"base::init_function\");\n-                datum::Datum::new(ptr, ty, flag)\n-            };\n+                let make_datum = |id| {\n+                    let init_val = C_u8(self.ccx, adt::DTOR_NEEDED_HINT);\n+                    let llname = &format!(\"dropflag_hint_{}\", id);\n+                    debug!(\"adding hint {}\", llname);\n+                    let ty = tcx.types.u8;\n+                    let ptr = alloc_ty(entry_bcx, ty, llname);\n+                    Store(entry_bcx, init_val, ptr);\n+                    let flag = datum::Lvalue::new_dropflag_hint(\"FunctionContext::init\");\n+                    datum::Datum::new(ptr, ty, flag)\n+                };\n \n-            let (var, datum) = match info {\n-                ty::FragmentInfo::Moved { var, .. } |\n-                ty::FragmentInfo::Assigned { var, .. } => {\n-                    let opt_datum = seen.get(&var).cloned().unwrap_or_else(|| {\n-                        let ty = tables.node_types[&var];\n-                        if fcx.type_needs_drop(ty) {\n-                            let datum = make_datum(var);\n-                            seen.insert(var, Some(datum.clone()));\n-                            Some(datum)\n+                let (var, datum) = match info {\n+                    ty::FragmentInfo::Moved { var, .. } |\n+                    ty::FragmentInfo::Assigned { var, .. } => {\n+                        let opt_datum = seen.get(&var).cloned().unwrap_or_else(|| {\n+                            let ty = tables.node_types[&var];\n+                            if self.type_needs_drop(ty) {\n+                                let datum = make_datum(var);\n+                                seen.insert(var, Some(datum.clone()));\n+                                Some(datum)\n+                            } else {\n+                                // No drop call needed, so we don't need a dropflag hint\n+                                None\n+                            }\n+                        });\n+                        if let Some(datum) = opt_datum {\n+                            (var, datum)\n                         } else {\n-                            // No drop call needed, so we don't need a dropflag hint\n-                            None\n+                            continue\n                         }\n-                    });\n-                    if let Some(datum) = opt_datum {\n-                        (var, datum)\n-                    } else {\n-                        continue\n                     }\n-                }\n-            };\n-            match info {\n-                ty::FragmentInfo::Moved { move_expr: expr_id, .. } => {\n-                    debug!(\"FragmentInfo::Moved insert drop hint for {}\", expr_id);\n-                    hints.insert(expr_id, DropHint::new(var, datum));\n-                }\n-                ty::FragmentInfo::Assigned { assignee_id: expr_id, .. } => {\n-                    debug!(\"FragmentInfo::Assigned insert drop hint for {}\", expr_id);\n-                    hints.insert(expr_id, DropHint::new(var, datum));\n+                };\n+                match info {\n+                    ty::FragmentInfo::Moved { move_expr: expr_id, .. } => {\n+                        debug!(\"FragmentInfo::Moved insert drop hint for {}\", expr_id);\n+                        hints.insert(expr_id, DropHint::new(var, datum));\n+                    }\n+                    ty::FragmentInfo::Assigned { assignee_id: expr_id, .. } => {\n+                        debug!(\"FragmentInfo::Assigned insert drop hint for {}\", expr_id);\n+                        hints.insert(expr_id, DropHint::new(var, datum));\n+                    }\n                 }\n             }\n         }\n-    }\n-\n-    entry_bcx\n-}\n \n-// NB: must keep 4 fns in sync:\n-//\n-//  - type_of_fn\n-//  - create_datums_for_fn_args.\n-//  - new_fn_ctxt\n-//  - trans_args\n-\n-pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>) -> datum::Rvalue {\n-    use trans::datum::{ByRef, ByValue};\n-\n-    datum::Rvalue {\n-        mode: if arg_is_indirect(cx.ccx, t) { ByRef } else { ByValue }\n-    }\n-}\n-\n-// create_datums_for_fn_args: creates lvalue datums for each of the\n-// incoming function arguments.\n-pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n-                                           args: &[hir::Arg],\n-                                           arg_tys: &[Ty<'tcx>],\n-                                           has_tupled_arg: bool,\n-                                           arg_scope: cleanup::CustomScopeIndex)\n-                                           -> Block<'a, 'tcx> {\n-    let _icx = push_ctxt(\"create_datums_for_fn_args\");\n-    let fcx = bcx.fcx;\n-    let arg_scope_id = cleanup::CustomScope(arg_scope);\n-\n-    debug!(\"create_datums_for_fn_args\");\n-\n-    // Return an array wrapping the ValueRefs that we get from `get_param` for\n-    // each argument into datums.\n-    //\n-    // For certain mode/type combinations, the raw llarg values are passed\n-    // by value.  However, within the fn body itself, we want to always\n-    // have all locals and arguments be by-ref so that we can cancel the\n-    // cleanup and for better interaction with LLVM's debug info.  So, if\n-    // the argument would be passed by value, we store it into an alloca.\n-    // This alloca should be optimized away by LLVM's mem-to-reg pass in\n-    // the event it's not truly needed.\n-    let mut idx = fcx.arg_offset() as c_uint;\n-    let uninit_reason = InitAlloca::Uninit(\"fn_arg populate dominates dtor\");\n-    for (i, &arg_ty) in arg_tys.iter().enumerate() {\n-        let arg_datum = if !has_tupled_arg || i < arg_tys.len() - 1 {\n-            if type_of::arg_is_indirect(bcx.ccx(), arg_ty) &&\n-               bcx.sess().opts.debuginfo != FullDebugInfo {\n-                // Don't copy an indirect argument to an alloca, the caller\n-                // already put it in a temporary alloca and gave it up, unless\n-                // we emit extra-debug-info, which requires local allocas :(.\n-                let llarg = get_param(fcx.llfn, idx);\n-                idx += 1;\n-                bcx.fcx.schedule_lifetime_end(arg_scope_id, llarg);\n-                bcx.fcx.schedule_drop_mem(arg_scope_id, llarg, arg_ty, None);\n-\n-                datum::Datum::new(llarg,\n-                                  arg_ty,\n-                                  datum::Lvalue::new(\"create_datum_for_fn_args\"))\n-            } else if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                let data = get_param(fcx.llfn, idx);\n-                let extra = get_param(fcx.llfn, idx + 1);\n-                idx += 2;\n-                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\", uninit_reason,\n-                                                        arg_scope_id, (data, extra),\n-                                                        |(data, extra), bcx, dst| {\n-                    debug!(\"populate call for create_datum_for_fn_args \\\n-                            early fat arg, on arg[{}] ty={:?}\", i, arg_ty);\n-\n-                    Store(bcx, data, expr::get_dataptr(bcx, dst));\n-                    Store(bcx, extra, expr::get_meta(bcx, dst));\n-                    bcx\n-                }))\n-            } else {\n-                let llarg = get_param(fcx.llfn, idx);\n+        entry_bcx\n+    }\n+\n+    /// Creates lvalue datums for each of the incoming function arguments,\n+    /// matches all argument patterns against them to produce bindings,\n+    /// and returns the entry block (see FunctionContext::init).\n+    fn bind_args(&'blk self,\n+                 args: &[hir::Arg],\n+                 abi: Abi,\n+                 id: ast::NodeId,\n+                 closure_env: closure::ClosureEnv,\n+                 arg_scope: cleanup::CustomScopeIndex)\n+                 -> Block<'blk, 'tcx> {\n+        let _icx = push_ctxt(\"FunctionContext::bind_args\");\n+        let fn_did = self.ccx.tcx().map.local_def_id(id);\n+        let mut bcx = self.init(false, Some(fn_did));\n+        let arg_scope_id = cleanup::CustomScope(arg_scope);\n+\n+        let mut idx = 0;\n+        let mut llarg_idx = self.fn_ty.ret.is_indirect() as usize;\n+\n+        let has_tupled_arg = match closure_env {\n+            closure::ClosureEnv::NotClosure => abi == Abi::RustCall,\n+            closure::ClosureEnv::Closure(..) => {\n+                closure_env.load(bcx, arg_scope_id);\n+                let env_arg = &self.fn_ty.args[idx];\n                 idx += 1;\n-                let tmp = datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty));\n-                unpack_datum!(bcx,\n-                              datum::lvalue_scratch_datum(bcx,\n-                                                          arg_ty,\n-                                                          \"\",\n-                                                          uninit_reason,\n-                                                          arg_scope_id,\n-                                                          tmp,\n-                                                          |tmp, bcx, dst| {\n-\n-                        debug!(\"populate call for create_datum_for_fn_args \\\n-                                early thin arg, on arg[{}] ty={:?}\", i, arg_ty);\n-\n-                                                              tmp.store_to(bcx, dst)\n-                                                          }))\n-            }\n-        } else {\n-            // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n-            match arg_ty.sty {\n-                ty::TyTuple(ref tupled_arg_tys) => {\n-                    unpack_datum!(bcx,\n-                                  datum::lvalue_scratch_datum(bcx,\n-                                                              arg_ty,\n-                                                              \"tupled_args\",\n-                                                              uninit_reason,\n-                                                              arg_scope_id,\n-                                                              (),\n-                                                              |(),\n-                                                               mut bcx,\n-                                                              llval| {\n-                        debug!(\"populate call for create_datum_for_fn_args \\\n-                                tupled_args, on arg[{}] ty={:?}\", i, arg_ty);\n-                        for (j, &tupled_arg_ty) in\n-                                    tupled_arg_tys.iter().enumerate() {\n-                            let lldest = StructGEP(bcx, llval, j);\n-                            if common::type_is_fat_ptr(bcx.tcx(), tupled_arg_ty) {\n-                                let data = get_param(bcx.fcx.llfn, idx);\n-                                let extra = get_param(bcx.fcx.llfn, idx + 1);\n-                                Store(bcx, data, expr::get_dataptr(bcx, lldest));\n-                                Store(bcx, extra, expr::get_meta(bcx, lldest));\n-                                idx += 2;\n-                            } else {\n-                                let datum = datum::Datum::new(\n-                                    get_param(bcx.fcx.llfn, idx),\n-                                    tupled_arg_ty,\n-                                    arg_kind(bcx.fcx, tupled_arg_ty));\n-                                idx += 1;\n-                                bcx = datum.store_to(bcx, lldest);\n-                            };\n-                        }\n-                        bcx\n-                    }))\n+                if env_arg.pad.is_some() {\n+                    llarg_idx += 1;\n                 }\n-                _ => {\n-                    bcx.tcx()\n-                       .sess\n-                       .bug(\"last argument of a function with `rust-call` ABI isn't a tuple?!\")\n+                if !env_arg.is_ignore() {\n+                    llarg_idx += 1;\n                 }\n+                false\n             }\n         };\n-\n-        let pat = &*args[i].pat;\n-        bcx = if let Some(name) = simple_name(pat) {\n-            // Generate nicer LLVM for the common case of fn a pattern\n-            // like `x: T`\n-            set_value_name(arg_datum.val, &bcx.name(name));\n-            bcx.fcx.lllocals.borrow_mut().insert(pat.id, arg_datum);\n-            bcx\n+        let tupled_arg_id = if has_tupled_arg {\n+            args[args.len() - 1].id\n         } else {\n-            // General path. Copy out the values that are used in the\n-            // pattern.\n-            _match::bind_irrefutable_pat(bcx, pat, arg_datum.match_input(), arg_scope_id)\n+            ast::DUMMY_NODE_ID\n         };\n-        debuginfo::create_argument_metadata(bcx, &args[i]);\n-    }\n \n-    bcx\n-}\n+        // Return an array wrapping the ValueRefs that we get from `get_param` for\n+        // each argument into datums.\n+        //\n+        // For certain mode/type combinations, the raw llarg values are passed\n+        // by value.  However, within the fn body itself, we want to always\n+        // have all locals and arguments be by-ref so that we can cancel the\n+        // cleanup and for better interaction with LLVM's debug info.  So, if\n+        // the argument would be passed by value, we store it into an alloca.\n+        // This alloca should be optimized away by LLVM's mem-to-reg pass in\n+        // the event it's not truly needed.\n+        let uninit_reason = InitAlloca::Uninit(\"fn_arg populate dominates dtor\");\n+        for hir_arg in args {\n+            let arg_ty = node_id_type(bcx, hir_arg.id);\n+            let arg_datum = if hir_arg.id != tupled_arg_id {\n+                let arg = &self.fn_ty.args[idx];\n+                idx += 1;\n+                if arg.is_indirect() && bcx.sess().opts.debuginfo != FullDebugInfo {\n+                    // Don't copy an indirect argument to an alloca, the caller\n+                    // already put it in a temporary alloca and gave it up, unless\n+                    // we emit extra-debug-info, which requires local allocas :(.\n+                    let llarg = get_param(self.llfn, llarg_idx as c_uint);\n+                    llarg_idx += 1;\n+                    self.schedule_lifetime_end(arg_scope_id, llarg);\n+                    self.schedule_drop_mem(arg_scope_id, llarg, arg_ty, None);\n+\n+                    datum::Datum::new(llarg,\n+                                    arg_ty,\n+                                    datum::Lvalue::new(\"FunctionContext::bind_args\"))\n+                } else {\n+                    unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                                                                   uninit_reason,\n+                                                                   arg_scope_id, |bcx, dst| {\n+                        debug!(\"FunctionContext::bind_args: {:?}: {:?}\", hir_arg, arg_ty);\n+                        let b = &bcx.build();\n+                        if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+                            let meta = &self.fn_ty.args[idx];\n+                            idx += 1;\n+                            arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n+                            meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, dst));\n+                        } else {\n+                            arg.store_fn_arg(b, &mut llarg_idx, dst);\n+                        }\n+                        bcx\n+                    }))\n+                }\n+            } else {\n+                // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n+                let tupled_arg_tys = match arg_ty.sty {\n+                    ty::TyTuple(ref tys) => tys,\n+                    _ => unreachable!(\"last argument of `rust-call` fn isn't a tuple?!\")\n+                };\n \n-// Ties up the llstaticallocas -> llloadenv -> lltop edges,\n-// and builds the return block.\n-pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n-                             last_bcx: Block<'blk, 'tcx>,\n-                             retty: ty::FnOutput<'tcx>,\n-                             ret_debug_loc: DebugLoc) {\n-    let _icx = push_ctxt(\"finish_fn\");\n+                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx,\n+                                                            arg_ty,\n+                                                            \"tupled_args\",\n+                                                            uninit_reason,\n+                                                            arg_scope_id,\n+                                                            |bcx, llval| {\n+                    debug!(\"FunctionContext::bind_args: tupled {:?}: {:?}\", hir_arg, arg_ty);\n+                    for (j, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n+                        let dst = StructGEP(bcx, llval, j);\n+                        let arg = &self.fn_ty.args[idx];\n+                        let b = &bcx.build();\n+                        if common::type_is_fat_ptr(bcx.tcx(), tupled_arg_ty) {\n+                            let meta = &self.fn_ty.args[idx];\n+                            idx += 1;\n+                            arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n+                            meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, dst));\n+                        } else {\n+                            arg.store_fn_arg(b, &mut llarg_idx, dst);\n+                        }\n+                    }\n+                    bcx\n+                }))\n+            };\n \n-    let ret_cx = match fcx.llreturn.get() {\n-        Some(llreturn) => {\n-            if !last_bcx.terminated.get() {\n-                Br(last_bcx, llreturn, DebugLoc::None);\n-            }\n-            raw_block(fcx, llreturn)\n+            let pat = &hir_arg.pat;\n+            bcx = if let Some(name) = simple_name(pat) {\n+                // Generate nicer LLVM for the common case of fn a pattern\n+                // like `x: T`\n+                set_value_name(arg_datum.val, &bcx.name(name));\n+                self.lllocals.borrow_mut().insert(pat.id, arg_datum);\n+                bcx\n+            } else {\n+                // General path. Copy out the values that are used in the\n+                // pattern.\n+                _match::bind_irrefutable_pat(bcx, pat, arg_datum.match_input(), arg_scope_id)\n+            };\n+            debuginfo::create_argument_metadata(bcx, hir_arg);\n         }\n-        None => last_bcx,\n-    };\n \n-    // This shouldn't need to recompute the return type,\n-    // as new_fn_ctxt did it already.\n-    let substd_retty = fcx.monomorphize(&retty);\n-    build_return_block(fcx, ret_cx, substd_retty, ret_debug_loc);\n+        bcx\n+    }\n \n-    debuginfo::clear_source_location(fcx);\n-    fcx.cleanup();\n-}\n+    /// Ties up the llstaticallocas -> llloadenv -> lltop edges,\n+    /// and builds the return block.\n+    pub fn finish(&'blk self, last_bcx: Block<'blk, 'tcx>,\n+                  ret_debug_loc: DebugLoc) {\n+        let _icx = push_ctxt(\"FunctionContext::finish\");\n \n-// Builds the return block for a function.\n-pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n-                                      ret_cx: Block<'blk, 'tcx>,\n-                                      retty: ty::FnOutput<'tcx>,\n-                                      ret_debug_location: DebugLoc) {\n-    if fcx.llretslotptr.get().is_none() ||\n-       (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n-        return RetVoid(ret_cx, ret_debug_location);\n+        let ret_cx = match self.llreturn.get() {\n+            Some(llreturn) => {\n+                if !last_bcx.terminated.get() {\n+                    Br(last_bcx, llreturn, DebugLoc::None);\n+                }\n+                raw_block(self, llreturn)\n+            }\n+            None => last_bcx,\n+        };\n+\n+        self.build_return_block(ret_cx, ret_debug_loc);\n+\n+        debuginfo::clear_source_location(self);\n+        self.cleanup();\n     }\n \n-    let retslot = if fcx.needs_ret_allocas {\n-        Load(ret_cx, fcx.llretslotptr.get().unwrap())\n-    } else {\n-        fcx.llretslotptr.get().unwrap()\n-    };\n-    let retptr = Value(retslot);\n-    match retptr.get_dominating_store(ret_cx) {\n-        // If there's only a single store to the ret slot, we can directly return\n-        // the value that was stored and omit the store and the alloca\n-        Some(s) => {\n-            let retval = s.get_operand(0).unwrap().get();\n-            s.erase_from_parent();\n-\n-            if retptr.has_no_uses() {\n-                retptr.erase_from_parent();\n-            }\n+    // Builds the return block for a function.\n+    pub fn build_return_block(&self, ret_cx: Block<'blk, 'tcx>,\n+                              ret_debug_location: DebugLoc) {\n+        if self.llretslotptr.get().is_none() ||\n+           ret_cx.unreachable.get() ||\n+           (!self.needs_ret_allocas && self.fn_ty.ret.is_indirect()) {\n+            return RetVoid(ret_cx, ret_debug_location);\n+        }\n \n-            let retval = if retty == ty::FnConverging(fcx.ccx.tcx().types.bool) {\n-                Trunc(ret_cx, retval, Type::i1(fcx.ccx))\n-            } else {\n-                retval\n-            };\n+        let retslot = if self.needs_ret_allocas {\n+            Load(ret_cx, self.llretslotptr.get().unwrap())\n+        } else {\n+            self.llretslotptr.get().unwrap()\n+        };\n+        let retptr = Value(retslot);\n+        let llty = self.fn_ty.ret.original_ty;\n+        match (retptr.get_dominating_store(ret_cx), self.fn_ty.ret.cast) {\n+            // If there's only a single store to the ret slot, we can directly return\n+            // the value that was stored and omit the store and the alloca.\n+            // However, we only want to do this when there is no cast needed.\n+            (Some(s), None) => {\n+                let mut retval = s.get_operand(0).unwrap().get();\n+                s.erase_from_parent();\n+\n+                if retptr.has_no_uses() {\n+                    retptr.erase_from_parent();\n+                }\n \n-            if fcx.caller_expects_out_pointer {\n-                if let ty::FnConverging(retty) = retty {\n-                    store_ty(ret_cx, retval, get_param(fcx.llfn, 0), retty);\n+                if self.fn_ty.ret.is_indirect() {\n+                    Store(ret_cx, retval, get_param(self.llfn, 0));\n+                    RetVoid(ret_cx, ret_debug_location)\n+                } else {\n+                    if llty == Type::i1(self.ccx) {\n+                        retval = Trunc(ret_cx, retval, llty);\n+                    }\n+                    Ret(ret_cx, retval, ret_debug_location)\n                 }\n+            }\n+            (_, cast_ty) if self.fn_ty.ret.is_indirect() => {\n+                // Otherwise, copy the return value to the ret slot.\n+                assert_eq!(cast_ty, None);\n+                let llsz = llsize_of(self.ccx, self.fn_ty.ret.ty);\n+                let llalign = llalign_of_min(self.ccx, self.fn_ty.ret.ty);\n+                call_memcpy(&B(ret_cx), get_param(self.llfn, 0),\n+                            retslot, llsz, llalign as u32);\n                 RetVoid(ret_cx, ret_debug_location)\n-            } else {\n-                Ret(ret_cx, retval, ret_debug_location)\n             }\n-        }\n-        // Otherwise, copy the return value to the ret slot\n-        None => match retty {\n-            ty::FnConverging(retty) => {\n-                if fcx.caller_expects_out_pointer {\n-                    memcpy_ty(ret_cx, get_param(fcx.llfn, 0), retslot, retty);\n-                    RetVoid(ret_cx, ret_debug_location)\n-                } else {\n-                    Ret(ret_cx, load_ty(ret_cx, retslot, retty), ret_debug_location)\n+            (_, Some(cast_ty)) => {\n+                let load = Load(ret_cx, PointerCast(ret_cx, retslot, cast_ty.ptr_to()));\n+                let llalign = llalign_of_min(self.ccx, self.fn_ty.ret.ty);\n+                unsafe {\n+                    llvm::LLVMSetAlignment(load, llalign);\n                 }\n+                Ret(ret_cx, load, ret_debug_location)\n             }\n-            ty::FnDiverging => {\n-                if fcx.caller_expects_out_pointer {\n-                    RetVoid(ret_cx, ret_debug_location)\n+            (_, None) => {\n+                let retval = if llty == Type::i1(self.ccx) {\n+                    let val = LoadRangeAssert(ret_cx, retslot, 0, 2, llvm::False);\n+                    Trunc(ret_cx, val, llty)\n                 } else {\n-                    Ret(ret_cx, C_undef(Type::nil(fcx.ccx)), ret_debug_location)\n-                }\n+                    Load(ret_cx, retslot)\n+                };\n+                Ret(ret_cx, retval, ret_debug_location)\n             }\n-        },\n+        }\n     }\n }\n \n /// Builds an LLVM function out of a source function.\n ///\n /// If the function closes over its environment a closure will be returned.\n-pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                   decl: &hir::FnDecl,\n-                                   body: &hir::Block,\n-                                   llfndecl: ValueRef,\n-                                   param_substs: &'tcx Substs<'tcx>,\n-                                   fn_ast_id: ast::NodeId,\n-                                   attributes: &[ast::Attribute],\n-                                   output_type: ty::FnOutput<'tcx>,\n-                                   abi: Abi,\n-                                   closure_env: closure::ClosureEnv<'b>) {\n+pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               decl: &hir::FnDecl,\n+                               body: &hir::Block,\n+                               llfndecl: ValueRef,\n+                               param_substs: &'tcx Substs<'tcx>,\n+                               def_id: DefId,\n+                               inlined_id: ast::NodeId,\n+                               fn_ty: FnType,\n+                               abi: Abi,\n+                               closure_env: closure::ClosureEnv) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n-    record_translation_item_as_generated(ccx, fn_ast_id, param_substs);\n+    if collector::collecting_debug_information(ccx) {\n+        ccx.record_translation_item_as_generated(TransItem::Fn(Instance {\n+            def: def_id,\n+            params: &param_substs.types\n+        }))\n+    }\n \n     let _icx = push_ctxt(\"trans_closure\");\n     attributes::emit_uwtable(llfndecl, true);\n \n     debug!(\"trans_closure(..., param_substs={:?})\", param_substs);\n \n-    let has_env = match closure_env {\n-        closure::ClosureEnv::Closure(..) => true,\n-        closure::ClosureEnv::NotClosure => false,\n-    };\n-\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      llfndecl,\n-                      fn_ast_id,\n-                      has_env,\n-                      output_type,\n-                      param_substs,\n-                      Some(body.span),\n-                      &arena);\n-    let mut bcx = init_function(&fcx, false, output_type);\n-\n-    if attributes.iter().any(|item| item.check_name(\"rustc_mir\")) {\n-        mir::trans_mir(bcx.build());\n-        fcx.cleanup();\n-        return;\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, Some(def_id), param_substs, &arena);\n+\n+    if fcx.mir.is_some() {\n+        return mir::trans_mir(&fcx);\n     }\n \n     // cleanup scope for the incoming arguments\n-    let fn_cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(ccx,\n-                                                                             fn_ast_id,\n-                                                                             body.span,\n-                                                                             true);\n+    let fn_cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(\n+        ccx, inlined_id, body.span, true);\n     let arg_scope = fcx.push_custom_cleanup_scope_with_debug_loc(fn_cleanup_debug_loc);\n \n-    let block_ty = node_id_type(bcx, body.id);\n-\n     // Set up arguments to the function.\n-    let monomorphized_arg_types = decl.inputs\n-                                      .iter()\n-                                      .map(|arg| node_id_type(bcx, arg.id))\n-                                      .collect::<Vec<_>>();\n-    for monomorphized_arg_type in &monomorphized_arg_types {\n-        debug!(\"trans_closure: monomorphized_arg_type: {:?}\",\n-               monomorphized_arg_type);\n-    }\n-    debug!(\"trans_closure: function lltype: {}\",\n-           bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n-\n-    let has_tupled_arg = match closure_env {\n-        closure::ClosureEnv::NotClosure => abi == Abi::RustCall,\n-        _ => false,\n-    };\n-\n-    bcx = create_datums_for_fn_args(bcx,\n-                                    &decl.inputs,\n-                                    &monomorphized_arg_types,\n-                                    has_tupled_arg,\n-                                    arg_scope);\n-\n-    bcx = closure_env.load(bcx, cleanup::CustomScope(arg_scope));\n+    debug!(\"trans_closure: function: {:?}\", Value(fcx.llfn));\n+    let bcx = fcx.bind_args(&decl.inputs, abi, inlined_id, closure_env, arg_scope);\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n     debuginfo::start_emitting_source_locations(&fcx);\n \n-    let dest = match fcx.llretslotptr.get() {\n-        Some(_) => expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(block_ty), \"iret_slot\")),\n-        None => {\n-            assert!(type_is_zero_size(bcx.ccx(), block_ty));\n-            expr::Ignore\n-        }\n+    let dest = if fcx.fn_ty.ret.is_ignore() {\n+        expr::Ignore\n+    } else {\n+        expr::SaveIn(fcx.get_ret_slot(bcx, \"iret_slot\"))\n     };\n \n     // This call to trans_block is the place where we bridge between\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n-    bcx = controlflow::trans_block(bcx, body, dest);\n+    let mut bcx = controlflow::trans_block(bcx, body, dest);\n \n     match dest {\n         expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n@@ -2096,29 +1899,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let ret_debug_loc = DebugLoc::At(fn_cleanup_debug_loc.id, fn_cleanup_debug_loc.span);\n \n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(&fcx, bcx, output_type, ret_debug_loc);\n-\n-    fn record_translation_item_as_generated<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                      node_id: ast::NodeId,\n-                                                      param_substs: &'tcx Substs<'tcx>) {\n-        if !collector::collecting_debug_information(ccx) {\n-            return;\n-        }\n-\n-        let def_id = match ccx.tcx().node_id_to_type(node_id).sty {\n-            ty::TyClosure(def_id, _) => def_id,\n-            _ => ccx.external_srcs()\n-                    .borrow()\n-                    .get(&node_id)\n-                    .map(|did| *did)\n-                    .unwrap_or_else(|| ccx.tcx().map.local_def_id(node_id)),\n-        };\n-\n-        ccx.record_translation_item_as_generated(TransItem::Fn{\n-            def_id: def_id,\n-            substs: ccx.tcx().mk_substs(ccx.tcx().erase_regions(param_substs)),\n-        });\n-    }\n+    fcx.finish(bcx, ret_debug_loc);\n }\n \n /// Creates an LLVM function corresponding to a source language function.\n@@ -2127,44 +1908,37 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           body: &hir::Block,\n                           llfndecl: ValueRef,\n                           param_substs: &'tcx Substs<'tcx>,\n-                          id: ast::NodeId,\n-                          attrs: &[ast::Attribute]) {\n+                          id: ast::NodeId) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ccx.tcx().node_id_to_type(id);\n     let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fn_ty);\n-    let sig = fn_ty.fn_sig();\n-    let sig = ccx.tcx().erase_late_bound_regions(&sig);\n+    let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n-    let output_type = sig.output;\n     let abi = fn_ty.fn_abi();\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n+    let def_id = if let Some(&def_id) = ccx.external_srcs().borrow().get(&id) {\n+        def_id\n+    } else {\n+        ccx.tcx().map.local_def_id(id)\n+    };\n     trans_closure(ccx,\n                   decl,\n                   body,\n                   llfndecl,\n                   param_substs,\n+                  def_id,\n                   id,\n-                  attrs,\n-                  output_type,\n+                  fn_ty,\n                   abi,\n                   closure::ClosureEnv::NotClosure);\n }\n \n-pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    ctor_id: ast::NodeId,\n-                                    disr: Disr,\n-                                    param_substs: &'tcx Substs<'tcx>,\n-                                    llfndecl: ValueRef) {\n-    let _icx = push_ctxt(\"trans_enum_variant\");\n-\n-    trans_enum_variant_or_tuple_like_struct(ccx, ctor_id, disr, param_substs, llfndecl);\n-}\n-\n pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  ctor_ty: Ty<'tcx>,\n                                                  disr: Disr,\n-                                                 args: callee::CallArgs,\n+                                                 args: CallArgs,\n                                                  dest: expr::Dest,\n                                                  debug_loc: DebugLoc)\n                                                  -> Result<'blk, 'tcx> {\n@@ -2192,7 +1966,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     if !type_is_zero_size(ccx, result_ty) {\n         match args {\n-            callee::ArgExprs(exprs) => {\n+            ArgExprs(exprs) => {\n                 let fields = exprs.iter().map(|x| &**x).enumerate().collect::<Vec<_>>();\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n@@ -2208,7 +1982,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // Just eval all the expressions (if any). Since expressions in Rust can have arbitrary\n         // contents, there could be side-effects we need from them.\n         match args {\n-            callee::ArgExprs(exprs) => {\n+            ArgExprs(exprs) => {\n                 for expr in exprs {\n                     bcx = expr::trans_into(bcx, expr, expr::Ignore);\n                 }\n@@ -2233,72 +2007,51 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     Result::new(bcx, llresult)\n }\n \n-pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    ctor_id: ast::NodeId,\n-                                    param_substs: &'tcx Substs<'tcx>,\n-                                    llfndecl: ValueRef) {\n-    let _icx = push_ctxt(\"trans_tuple_struct\");\n-\n-    trans_enum_variant_or_tuple_like_struct(ccx, ctor_id, Disr(0), param_substs, llfndecl);\n-}\n-\n-fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                     ctor_id: ast::NodeId,\n-                                                     disr: Disr,\n-                                                     param_substs: &'tcx Substs<'tcx>,\n-                                                     llfndecl: ValueRef) {\n+pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                 ctor_id: ast::NodeId,\n+                                 disr: Disr,\n+                                 param_substs: &'tcx Substs<'tcx>,\n+                                 llfndecl: ValueRef) {\n     let ctor_ty = ccx.tcx().node_id_to_type(ctor_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_sig());\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n-    let arg_tys = sig.inputs;\n-    let result_ty = sig.output;\n+    let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      llfndecl,\n-                      ctor_id,\n-                      false,\n-                      result_ty,\n-                      param_substs,\n-                      None,\n-                      &arena);\n-    let bcx = init_function(&fcx, false, result_ty);\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty,\n+                               Some(ccx.tcx().map.local_def_id(ctor_id)),\n+                               param_substs, &arena);\n+    let bcx = fcx.init(false, None);\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n-        let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n+    if !fcx.fn_ty.ret.is_ignore() {\n+        let dest = fcx.get_ret_slot(bcx, \"eret_slot\");\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n-        let repr = adt::represent_type(ccx, result_ty.unwrap());\n-        let mut llarg_idx = fcx.arg_offset() as c_uint;\n-        for (i, arg_ty) in arg_tys.into_iter().enumerate() {\n+        let repr = adt::represent_type(ccx, sig.output.unwrap());\n+        let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+        let mut arg_idx = 0;\n+        for (i, arg_ty) in sig.inputs.into_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx, &repr, dest_val, Disr::from(disr), i);\n+            let arg = &fcx.fn_ty.args[arg_idx];\n+            arg_idx += 1;\n+            let b = &bcx.build();\n             if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                Store(bcx,\n-                      get_param(fcx.llfn, llarg_idx),\n-                      expr::get_dataptr(bcx, lldestptr));\n-                Store(bcx,\n-                      get_param(fcx.llfn, llarg_idx + 1),\n-                      expr::get_meta(bcx, lldestptr));\n-                llarg_idx += 2;\n+                let meta = &fcx.fn_ty.args[arg_idx];\n+                arg_idx += 1;\n+                arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, lldestptr));\n+                meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, lldestptr));\n             } else {\n-                let arg = get_param(fcx.llfn, llarg_idx);\n-                llarg_idx += 1;\n-\n-                if arg_is_indirect(ccx, arg_ty) {\n-                    memcpy_ty(bcx, lldestptr, arg, arg_ty);\n-                } else {\n-                    store_ty(bcx, arg, lldestptr, arg_ty);\n-                }\n+                arg.store_fn_arg(b, &mut llarg_idx, lldestptr);\n             }\n         }\n         adt::trans_set_discr(bcx, &repr, dest, disr);\n     }\n \n-    finish_fn(&fcx, bcx, result_ty, DebugLoc::None);\n+    fcx.finish(bcx, DebugLoc::None);\n }\n \n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span, id: ast::NodeId) {\n@@ -2493,37 +2246,22 @@ fn set_global_section(ccx: &CrateContext, llval: ValueRef, i: &hir::Item) {\n pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n \n+    let tcx = ccx.tcx();\n     let from_external = ccx.external_srcs().borrow().contains_key(&item.id);\n \n     match item.node {\n-        hir::ItemFn(ref decl, _, _, abi, ref generics, ref body) => {\n+        hir::ItemFn(ref decl, _, _, _, ref generics, ref body) => {\n             if !generics.is_type_parameterized() {\n                 let trans_everywhere = attr::requests_inline(&item.attrs);\n                 // Ignore `trans_everywhere` for cross-crate inlined items\n                 // (`from_external`).  `trans_item` will be called once for each\n                 // compilation unit that references the item, so it will still get\n                 // translated everywhere it's needed.\n                 for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n-                    let llfn = get_item_val(ccx, item.id);\n-                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    if abi != Abi::Rust {\n-                        foreign::trans_rust_fn_with_foreign_abi(ccx,\n-                                                                &decl,\n-                                                                &body,\n-                                                                &item.attrs,\n-                                                                llfn,\n-                                                                empty_substs,\n-                                                                item.id,\n-                                                                None);\n-                    } else {\n-                        trans_fn(ccx,\n-                                 &decl,\n-                                 &body,\n-                                 llfn,\n-                                 empty_substs,\n-                                 item.id,\n-                                 &item.attrs);\n-                    }\n+                    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+                    let def_id = tcx.map.local_def_id(item.id);\n+                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n+                    trans_fn(ccx, &decl, &body, llfn, empty_substs, item.id);\n                     set_global_section(ccx, llfn, item);\n                     update_linkage(ccx,\n                                    llfn,\n@@ -2540,29 +2278,46 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                         // error in trans. This is used to write compile-fail tests\n                         // that actually test that compilation succeeds without\n                         // reporting an error.\n-                        let item_def_id = ccx.tcx().map.local_def_id(item.id);\n-                        if ccx.tcx().has_attr(item_def_id, \"rustc_error\") {\n-                            ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n+                        if tcx.has_attr(def_id, \"rustc_error\") {\n+                            tcx.sess.span_fatal(item.span, \"compilation successful\");\n                         }\n                     }\n                 }\n             }\n         }\n         hir::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n-            meth::trans_impl(ccx, item.name, impl_items, generics, item.id);\n-        }\n-        hir::ItemMod(_) => {\n-            // modules have no equivalent at runtime, they just affect\n-            // the mangled names of things contained within\n+            // Both here and below with generic methods, be sure to recurse and look for\n+            // items that we need to translate.\n+            if !generics.ty_params.is_empty() {\n+                return;\n+            }\n+\n+            for impl_item in impl_items {\n+                if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n+                    if sig.generics.ty_params.is_empty() {\n+                        let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n+                        for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n+                            let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+                            let def_id = tcx.map.local_def_id(impl_item.id);\n+                            let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n+                            trans_fn(ccx, &sig.decl, body, llfn, empty_substs, impl_item.id);\n+                            update_linkage(ccx, llfn, Some(impl_item.id),\n+                                if is_origin {\n+                                    OriginalTranslation\n+                                } else {\n+                                    InlinedCopy\n+                                });\n+                        }\n+                    }\n+                }\n+            }\n         }\n         hir::ItemEnum(ref enum_definition, ref gens) => {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-\n                 enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n             }\n         }\n-        hir::ItemConst(..) => {}\n         hir::ItemStatic(_, m, ref expr) => {\n             let g = match consts::trans_static(ccx, m, expr, item.id, &item.attrs) {\n                 Ok(g) => g,\n@@ -2571,62 +2326,17 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n             set_global_section(ccx, g, item);\n             update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n         }\n-        hir::ItemForeignMod(ref foreign_mod) => {\n-            foreign::trans_foreign_mod(ccx, foreign_mod);\n-        }\n-        hir::ItemTrait(..) => {}\n-        _ => {\n-            // fall through\n-        }\n-    }\n-}\n-\n-// only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n-pub fn register_fn_llvmty(ccx: &CrateContext,\n-                          sp: Span,\n-                          sym: String,\n-                          node_id: ast::NodeId,\n-                          cc: llvm::CallConv,\n-                          llfty: Type)\n-                          -> ValueRef {\n-    debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n-\n-    let llfn = declare::define_fn(ccx, &sym[..], cc, llfty,\n-                                   ty::FnConverging(ccx.tcx().mk_nil())).unwrap_or_else(||{\n-        ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n-    });\n-    finish_register_fn(ccx, sym, node_id);\n-    llfn\n-}\n-\n-fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId) {\n-    ccx.item_symbols().borrow_mut().insert(node_id, sym);\n-}\n-\n-fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                         sp: Span,\n-                         sym: String,\n-                         node_id: ast::NodeId,\n-                         node_type: Ty<'tcx>)\n-                         -> ValueRef {\n-    if let ty::TyFnDef(_, _, ref f) = node_type.sty {\n-        if f.abi != Abi::Rust && f.abi != Abi::RustCall {\n-            ccx.sess().span_bug(sp,\n-                                &format!(\"only the `{}` or `{}` calling conventions are valid \\\n-                                          for this function; `{}` was specified\",\n-                                         Abi::Rust.name(),\n-                                         Abi::RustCall.name(),\n-                                         f.abi.name()));\n+        hir::ItemForeignMod(ref m) => {\n+            if m.abi == Abi::RustIntrinsic || m.abi == Abi::PlatformIntrinsic {\n+                return;\n+            }\n+            for fi in &m.items {\n+                let lname = imported_name(fi.name, &fi.attrs).to_string();\n+                ccx.item_symbols().borrow_mut().insert(fi.id, lname);\n+            }\n         }\n-    } else {\n-        ccx.sess().span_bug(sp, \"expected bare rust function\")\n+        _ => {}\n     }\n-\n-    let llfn = declare::define_rust_fn(ccx, &sym[..], node_type).unwrap_or_else(|| {\n-        ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n-    });\n-    finish_register_fn(ccx, sym, node_id);\n-    llfn\n }\n \n pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n@@ -2654,14 +2364,15 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n                        use_start_lang_item: bool) {\n         let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()], &ccx.int_type());\n \n-        let llfn = declare::define_cfn(ccx, \"main\", llfty, ccx.tcx().mk_nil()).unwrap_or_else(|| {\n+        if declare::get_defined_value(ccx, \"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here.\n             ccx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n                       .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n                       .emit();\n             ccx.sess().abort_if_errors();\n             panic!();\n-        });\n+        }\n+        let llfn = declare::declare_cfn(ccx, \"main\", llfty);\n \n         let llbb = unsafe {\n             llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, \"top\\0\".as_ptr() as *const _)\n@@ -2675,17 +2386,10 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => {\n-                        ccx.sess().fatal(&s[..]);\n-                    }\n-                };\n-                let start_fn = if let Some(start_node_id) = ccx.tcx()\n-                                                               .map\n-                                                               .as_local_node_id(start_def_id) {\n-                    get_item_val(ccx, start_node_id)\n-                } else {\n-                    get_extern_fn(ccx, start_def_id).val\n+                    Err(s) => ccx.sess().fatal(&s)\n                 };\n+                let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+                let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx).val;\n                 let args = {\n                     let opaque_rust_main =\n                         llvm::LLVMBuildPointerCast(bld,\n@@ -2715,11 +2419,11 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n     }\n }\n \n-fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                           id: ast::NodeId,\n-                           ty: Ty<'tcx>,\n-                           attrs: &[ast::Attribute])\n-                           -> String {\n+pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               id: ast::NodeId,\n+                               ty: Ty<'tcx>,\n+                               attrs: &[ast::Attribute])\n+                               -> String {\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = ccx.sess().cstore.item_symbol(did);\n@@ -2750,180 +2454,18 @@ fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn contains_null(s: &str) -> bool {\n-    s.bytes().any(|b| b == 0)\n-}\n-\n-pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n-    debug!(\"get_item_val(id=`{}`)\", id);\n-\n-    if let Some(v) = ccx.item_vals().borrow().get(&id).cloned() {\n-        return v;\n-    }\n-\n-    let item = ccx.tcx().map.get(id);\n-    debug!(\"get_item_val: id={} item={:?}\", id, item);\n-    let val = match item {\n-        hir_map::NodeItem(i) => {\n-            let ty = ccx.tcx().node_id_to_type(i.id);\n-            let sym = || exported_name(ccx, id, ty, &i.attrs);\n-\n-            let v = match i.node {\n-                hir::ItemStatic(..) => {\n-                    // If this static came from an external crate, then\n-                    // we need to get the symbol from metadata instead of\n-                    // using the current crate's name/version\n-                    // information in the hash of the symbol\n-                    let sym = sym();\n-                    debug!(\"making {}\", sym);\n-\n-                    // Create the global before evaluating the initializer;\n-                    // this is necessary to allow recursive statics.\n-                    let llty = type_of(ccx, ty);\n-                    let g = declare::define_global(ccx, &sym[..], llty).unwrap_or_else(|| {\n-                        ccx.sess()\n-                           .span_fatal(i.span, &format!(\"symbol `{}` is already defined\", sym))\n-                    });\n-\n-                    ccx.item_symbols().borrow_mut().insert(i.id, sym);\n-                    g\n-                }\n-\n-                hir::ItemFn(_, _, _, abi, _, _) => {\n-                    let sym = sym();\n-                    let llfn = if abi == Abi::Rust {\n-                        register_fn(ccx, i.span, sym, i.id, ty)\n-                    } else {\n-                        foreign::register_rust_fn_with_foreign_abi(ccx, i.span, sym, i.id)\n-                    };\n-                    attributes::from_fn_attrs(ccx, &i.attrs, llfn);\n-                    llfn\n-                }\n-\n-                _ => ccx.sess().bug(\"get_item_val: weird result in table\"),\n-            };\n-\n-            v\n-        }\n-\n-        hir_map::NodeTraitItem(trait_item) => {\n-            debug!(\"get_item_val(): processing a NodeTraitItem\");\n-            match trait_item.node {\n-                hir::MethodTraitItem(_, Some(_)) => {\n-                    register_method(ccx, id, &trait_item.attrs, trait_item.span)\n-                }\n-                _ => {\n-                    ccx.sess().span_bug(trait_item.span,\n-                                        \"unexpected variant: trait item other than a provided \\\n-                                         method in get_item_val()\");\n-                }\n-            }\n+pub fn imported_name(name: ast::Name, attrs: &[ast::Attribute]) -> InternedString {\n+    match attr::first_attr_value_str_by_name(attrs, \"link_name\") {\n+        Some(ln) => ln.clone(),\n+        None => match weak_lang_items::link_name(attrs) {\n+            Some(name) => name,\n+            None => name.as_str(),\n         }\n-\n-        hir_map::NodeImplItem(impl_item) => {\n-            match impl_item.node {\n-                hir::ImplItemKind::Method(..) => {\n-                    register_method(ccx, id, &impl_item.attrs, impl_item.span)\n-                }\n-                _ => {\n-                    ccx.sess().span_bug(impl_item.span,\n-                                        \"unexpected variant: non-method impl item in \\\n-                                         get_item_val()\");\n-                }\n-            }\n-        }\n-\n-        hir_map::NodeForeignItem(ni) => {\n-            match ni.node {\n-                hir::ForeignItemFn(..) => {\n-                    let abi = ccx.tcx().map.get_foreign_abi(id);\n-                    let ty = ccx.tcx().node_id_to_type(ni.id);\n-                    let name = foreign::link_name(&ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, &name, &ni.attrs)\n-                }\n-                hir::ForeignItemStatic(..) => {\n-                    foreign::register_static(ccx, &ni)\n-                }\n-            }\n-        }\n-\n-        hir_map::NodeVariant(ref v) => {\n-            let llfn;\n-            let fields = if v.node.data.is_struct() {\n-                ccx.sess().bug(\"struct variant kind unexpected in get_item_val\")\n-            } else {\n-                v.node.data.fields()\n-            };\n-            assert!(!fields.is_empty());\n-            let ty = ccx.tcx().node_id_to_type(id);\n-            let parent = ccx.tcx().map.get_parent(id);\n-            let enm = ccx.tcx().map.expect_item(parent);\n-            let sym = exported_name(ccx, id, ty, &enm.attrs);\n-\n-            llfn = match enm.node {\n-                hir::ItemEnum(_, _) => {\n-                    register_fn(ccx, (*v).span, sym, id, ty)\n-                }\n-                _ => ccx.sess().bug(\"NodeVariant, shouldn't happen\"),\n-            };\n-            attributes::inline(llfn, attributes::InlineAttr::Hint);\n-            llfn\n-        }\n-\n-        hir_map::NodeStructCtor(struct_def) => {\n-            // Only register the constructor if this is a tuple-like struct.\n-            let ctor_id = if struct_def.is_struct() {\n-                ccx.sess().bug(\"attempt to register a constructor of a non-tuple-like struct\")\n-            } else {\n-                struct_def.id()\n-            };\n-            let parent = ccx.tcx().map.get_parent(id);\n-            let struct_item = ccx.tcx().map.expect_item(parent);\n-            let ty = ccx.tcx().node_id_to_type(ctor_id);\n-            let sym = exported_name(ccx, id, ty, &struct_item.attrs);\n-            let llfn = register_fn(ccx, struct_item.span, sym, ctor_id, ty);\n-            attributes::inline(llfn, attributes::InlineAttr::Hint);\n-            llfn\n-        }\n-\n-        ref variant => {\n-            ccx.sess().bug(&format!(\"get_item_val(): unexpected variant: {:?}\", variant))\n-        }\n-    };\n-\n-    // All LLVM globals and functions are initially created as external-linkage\n-    // declarations.  If `trans_item`/`trans_fn` later turns the declaration\n-    // into a definition, it adjusts the linkage then (using `update_linkage`).\n-    //\n-    // The exception is foreign items, which have their linkage set inside the\n-    // call to `foreign::register_*` above.  We don't touch the linkage after\n-    // that (`foreign::trans_foreign_mod` doesn't adjust the linkage like the\n-    // other item translation functions do).\n-\n-    ccx.item_vals().borrow_mut().insert(id, val);\n-    val\n+    }\n }\n \n-fn register_method(ccx: &CrateContext,\n-                   id: ast::NodeId,\n-                   attrs: &[ast::Attribute],\n-                   span: Span)\n-                   -> ValueRef {\n-    let mty = ccx.tcx().node_id_to_type(id);\n-\n-    let sym = exported_name(ccx, id, mty, &attrs);\n-\n-    if let ty::TyFnDef(_, _, ref f) = mty.sty {\n-        let llfn = if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-            register_fn(ccx, span, sym, id, mty)\n-        } else {\n-            foreign::register_rust_fn_with_foreign_abi(ccx, span, sym, id)\n-        };\n-        attributes::from_fn_attrs(ccx, &attrs, llfn);\n-        return llfn;\n-    } else {\n-        ccx.sess().span_bug(span, \"expected bare rust function\");\n-    }\n+fn contains_null(s: &str) -> bool {\n+    s.bytes().any(|b| b == 0)\n }\n \n pub fn write_metadata<'a, 'tcx>(cx: &SharedCrateContext<'a, 'tcx>,"}, {"sha": "22536f2dc434d3ca9c70af6cc4f02b4882a1d045", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -12,14 +12,15 @@\n #![allow(non_snake_case)]\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect, AttrBuilder};\n+use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate};\n use llvm::{ValueRef, BasicBlockRef};\n use trans::common::*;\n use syntax::codemap::Span;\n \n use trans::builder::Builder;\n use trans::type_::Type;\n+use trans::value::Value;\n use trans::debuginfo::DebugLoc;\n \n use libc::{c_uint, c_char};\n@@ -138,20 +139,21 @@ pub fn Invoke(cx: Block,\n               args: &[ValueRef],\n               then: BasicBlockRef,\n               catch: BasicBlockRef,\n-              attributes: Option<AttrBuilder>,\n               debug_loc: DebugLoc)\n               -> ValueRef {\n     if cx.unreachable.get() {\n         return C_null(Type::i8(cx.ccx()));\n     }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n-    debug!(\"Invoke({} with arguments ({}))\",\n-           cx.val_to_string(fn_),\n-           args.iter().map(|a| cx.val_to_string(*a)).collect::<Vec<String>>().join(\", \"));\n+    debug!(\"Invoke({:?} with arguments ({}))\",\n+           Value(fn_),\n+           args.iter().map(|a| {\n+                format!(\"{:?}\", Value(*a))\n+           }).collect::<Vec<String>>().join(\", \"));\n     debug_loc.apply(cx.fcx);\n     let bundle = cx.lpad().and_then(|b| b.bundle());\n-    B(cx).invoke(fn_, args, then, catch, bundle, attributes)\n+    B(cx).invoke(fn_, args, then, catch, bundle)\n }\n \n pub fn Unreachable(cx: Block) {\n@@ -908,30 +910,14 @@ pub fn InlineAsmCall(cx: Block, asm: *const c_char, cons: *const c_char,\n pub fn Call(cx: Block,\n             fn_: ValueRef,\n             args: &[ValueRef],\n-            attributes: Option<AttrBuilder>,\n             debug_loc: DebugLoc)\n             -> ValueRef {\n     if cx.unreachable.get() {\n         return _UndefReturn(cx, fn_);\n     }\n     debug_loc.apply(cx.fcx);\n     let bundle = cx.lpad.get().and_then(|b| b.bundle());\n-    B(cx).call(fn_, args, bundle, attributes)\n-}\n-\n-pub fn CallWithConv(cx: Block,\n-                    fn_: ValueRef,\n-                    args: &[ValueRef],\n-                    conv: CallConv,\n-                    attributes: Option<AttrBuilder>,\n-                    debug_loc: DebugLoc)\n-                    -> ValueRef {\n-    if cx.unreachable.get() {\n-        return _UndefReturn(cx, fn_);\n-    }\n-    debug_loc.apply(cx.fcx);\n-    let bundle = cx.lpad.get().and_then(|b| b.bundle());\n-    B(cx).call_with_conv(fn_, args, conv, bundle, attributes)\n+    B(cx).call(fn_, args, bundle)\n }\n \n pub fn AtomicFence(cx: Block, order: AtomicOrdering, scope: SynchronizationScope) {"}, {"sha": "7f8e8393e8c4e94928d8fd0b01f7b871f2f145d0", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 31, "deletions": 58, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,13 +11,14 @@\n #![allow(dead_code)] // FFI wrappers\n \n use llvm;\n-use llvm::{CallConv, AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect, AttrBuilder};\n+use llvm::{AtomicBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{Opcode, IntPredicate, RealPredicate, False, OperandBundleDef};\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use trans::base;\n use trans::common::*;\n use trans::machine::llalign_of_pref;\n use trans::type_::Type;\n+use trans::value::Value;\n use util::nodemap::FnvHashMap;\n use libc::{c_uint, c_char};\n \n@@ -164,33 +165,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                   args: &[ValueRef],\n                   then: BasicBlockRef,\n                   catch: BasicBlockRef,\n-                  bundle: Option<&OperandBundleDef>,\n-                  attributes: Option<AttrBuilder>)\n+                  bundle: Option<&OperandBundleDef>)\n                   -> ValueRef {\n         self.count_insn(\"invoke\");\n \n-        debug!(\"Invoke {} with args ({})\",\n-               self.ccx.tn().val_to_string(llfn),\n+        debug!(\"Invoke {:?} with args ({})\",\n+               Value(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn().val_to_string(v))\n+                   .map(|&v| format!(\"{:?}\", Value(v)))\n                    .collect::<Vec<String>>()\n                    .join(\", \"));\n \n         let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n \n         unsafe {\n-            let v = llvm::LLVMRustBuildInvoke(self.llbuilder,\n-                                              llfn,\n-                                              args.as_ptr(),\n-                                              args.len() as c_uint,\n-                                              then,\n-                                              catch,\n-                                              bundle,\n-                                              noname());\n-            if let Some(a) = attributes {\n-                a.apply_callsite(v);\n-            }\n-            v\n+            llvm::LLVMRustBuildInvoke(self.llbuilder,\n+                                      llfn,\n+                                      args.as_ptr(),\n+                                      args.len() as c_uint,\n+                                      then,\n+                                      catch,\n+                                      bundle,\n+                                      noname())\n         }\n     }\n \n@@ -497,9 +493,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-        debug!(\"Store {} -> {}\",\n-               self.ccx.tn().val_to_string(val),\n-               self.ccx.tn().val_to_string(ptr));\n+        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         unsafe {\n@@ -508,9 +502,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n-        debug!(\"Store {} -> {}\",\n-               self.ccx.tn().val_to_string(val),\n-               self.ccx.tn().val_to_string(ptr));\n+        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store.volatile\");\n         unsafe {\n@@ -521,9 +513,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n-        debug!(\"Store {} -> {}\",\n-               self.ccx.tn().val_to_string(val),\n-               self.ccx.tn().val_to_string(ptr));\n+        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         self.count_insn(\"store.atomic\");\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(ptr));\n@@ -780,7 +770,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                          comment_text.as_ptr(), noname(), False,\n                                          False)\n             };\n-            self.call(asm, &[], None, None);\n+            self.call(asm, &[], None);\n         }\n     }\n \n@@ -796,28 +786,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                          else          { llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {}\", self.ccx.tn().val_to_string(*v));\n+            debug!(\"Asm Input Type: {:?}\", Value(*v));\n             val_ty(*v)\n         }).collect::<Vec<_>>();\n \n-        debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n+        debug!(\"Asm Output Type: {:?}\", output);\n         let fty = Type::func(&argtys[..], &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n-            self.call(v, inputs, None, None)\n+            self.call(v, inputs, None)\n         }\n     }\n \n     pub fn call(&self, llfn: ValueRef, args: &[ValueRef],\n-                bundle: Option<&OperandBundleDef>,\n-                attributes: Option<AttrBuilder>) -> ValueRef {\n+                bundle: Option<&OperandBundleDef>) -> ValueRef {\n         self.count_insn(\"call\");\n \n-        debug!(\"Call {} with args ({})\",\n-               self.ccx.tn().val_to_string(llfn),\n+        debug!(\"Call {:?} with args ({})\",\n+               Value(llfn),\n                args.iter()\n-                   .map(|&v| self.ccx.tn().val_to_string(v))\n+                   .map(|&v| format!(\"{:?}\", Value(v)))\n                    .collect::<Vec<String>>()\n                    .join(\", \"));\n \n@@ -838,38 +827,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if expected_ty != actual_ty {\n                 self.ccx.sess().bug(\n                     &format!(\n-                        \"Type mismatch in function call of {}.  Expected {} for param {}, got {}\",\n-                        self.ccx.tn().val_to_string(llfn),\n-                        self.ccx.tn().type_to_string(expected_ty),\n-                        i,\n-                        self.ccx.tn().type_to_string(actual_ty)));\n+                        \"Type mismatch in function call of {:?}. \\\n+                         Expected {:?} for param {}, got {:?}\",\n+                        Value(llfn),\n+                        expected_ty, i, actual_ty));\n \n             }\n         }\n \n         let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n \n         unsafe {\n-            let v = llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n-                                            args.len() as c_uint, bundle,\n-                                            noname());\n-            if let Some(a) = attributes {\n-                a.apply_callsite(v);\n-            }\n-            v\n+            llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n+                                    args.len() as c_uint, bundle, noname())\n         }\n     }\n \n-    pub fn call_with_conv(&self, llfn: ValueRef, args: &[ValueRef],\n-                          conv: CallConv,\n-                          bundle: Option<&OperandBundleDef>,\n-                          attributes: Option<AttrBuilder>) -> ValueRef {\n-        self.count_insn(\"callwithconv\");\n-        let v = self.call(llfn, args, bundle, attributes);\n-        llvm::SetInstructionCallConv(v, conv);\n-        v\n-    }\n-\n     pub fn select(&self, cond: ValueRef, then_val: ValueRef, else_val: ValueRef) -> ValueRef {\n         self.count_insn(\"select\");\n         unsafe {"}, {"sha": "8c10be44ffde335b5605bd590d2865e74b1c2509", "filename": "src/librustc_trans/trans/cabi.rs", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=2de6ddd75e202acdedfcd05b51a863dcc10459ca", "patch": "@@ -1,137 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub use self::ArgKind::*;\n-\n-use llvm::Attribute;\n-use std::option;\n-use trans::context::CrateContext;\n-use trans::cabi_x86;\n-use trans::cabi_x86_64;\n-use trans::cabi_x86_win64;\n-use trans::cabi_arm;\n-use trans::cabi_aarch64;\n-use trans::cabi_powerpc;\n-use trans::cabi_powerpc64;\n-use trans::cabi_mips;\n-use trans::cabi_asmjs;\n-use trans::type_::Type;\n-\n-#[derive(Clone, Copy, PartialEq)]\n-pub enum ArgKind {\n-    /// Pass the argument directly using the normal converted\n-    /// LLVM type or by coercing to another specified type\n-    Direct,\n-    /// Pass the argument indirectly via a hidden pointer\n-    Indirect,\n-    /// Ignore the argument (useful for empty struct)\n-    Ignore,\n-}\n-\n-/// Information about how a specific C type\n-/// should be passed to or returned from a function\n-///\n-/// This is borrowed from clang's ABIInfo.h\n-#[derive(Clone, Copy)]\n-pub struct ArgType {\n-    pub kind: ArgKind,\n-    /// Original LLVM type\n-    pub ty: Type,\n-    /// Coerced LLVM Type\n-    pub cast: option::Option<Type>,\n-    /// Dummy argument, which is emitted before the real argument\n-    pub pad: option::Option<Type>,\n-    /// LLVM attribute of argument\n-    pub attr: option::Option<Attribute>\n-}\n-\n-impl ArgType {\n-    pub fn direct(ty: Type, cast: option::Option<Type>,\n-                            pad: option::Option<Type>,\n-                            attr: option::Option<Attribute>) -> ArgType {\n-        ArgType {\n-            kind: Direct,\n-            ty: ty,\n-            cast: cast,\n-            pad: pad,\n-            attr: attr\n-        }\n-    }\n-\n-    pub fn indirect(ty: Type, attr: option::Option<Attribute>) -> ArgType {\n-        ArgType {\n-            kind: Indirect,\n-            ty: ty,\n-            cast: option::Option::None,\n-            pad: option::Option::None,\n-            attr: attr\n-        }\n-    }\n-\n-    pub fn ignore(ty: Type) -> ArgType {\n-        ArgType {\n-            kind: Ignore,\n-            ty: ty,\n-            cast: None,\n-            pad: None,\n-            attr: None,\n-        }\n-    }\n-\n-    pub fn is_indirect(&self) -> bool {\n-        return self.kind == Indirect;\n-    }\n-\n-    pub fn is_ignore(&self) -> bool {\n-        return self.kind == Ignore;\n-    }\n-}\n-\n-/// Metadata describing how the arguments to a native function\n-/// should be passed in order to respect the native ABI.\n-///\n-/// I will do my best to describe this structure, but these\n-/// comments are reverse-engineered and may be inaccurate. -NDM\n-pub struct FnType {\n-    /// The LLVM types of each argument.\n-    pub arg_tys: Vec<ArgType> ,\n-\n-    /// LLVM return type.\n-    pub ret_ty: ArgType,\n-}\n-\n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    match &ccx.sess().target.target.arch[..] {\n-        \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n-            cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n-        } else {\n-            cabi_x86_64::compute_abi_info(ccx, atys, rty, ret_def)\n-        },\n-        \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"arm\" => {\n-            let flavor = if ccx.sess().target.target.target_os == \"ios\" {\n-                cabi_arm::Flavor::Ios\n-            } else {\n-                cabi_arm::Flavor::General\n-            };\n-            cabi_arm::compute_abi_info(ccx, atys, rty, ret_def, flavor)\n-        },\n-        \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"powerpc64\" => cabi_powerpc64::compute_abi_info(ccx, atys, rty, ret_def),\n-        \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, atys, rty, ret_def),\n-        a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)\n-                              ),\n-    }\n-}"}, {"sha": "6eea8d472ba554adb73a4c4d6c3696c6739205e3", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 29, "deletions": 40, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n-use trans::cabi::{FnType, ArgType};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n+use trans::abi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -161,16 +161,15 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n-        let llty = Type::array(&base_ty, members);\n-        return ArgType::direct(ty, Some(llty), None, None);\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n+        ret.cast = Some(Type::array(&base_ty, members));\n+        return;\n     }\n-    let size = ty_size(ty);\n+    let size = ty_size(ret.ty);\n     if size <= 16 {\n         let llty = if size <= 1 {\n             Type::i8(ccx)\n@@ -183,21 +182,21 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         } else {\n             Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n         };\n-        return ArgType::direct(ty, Some(llty), None, None);\n+        ret.cast = Some(llty);\n+        return;\n     }\n-    ArgType::indirect(ty, Some(Attribute::StructRet))\n+    ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if is_reg_ty(arg.ty) {\n+        return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n-        let llty = Type::array(&base_ty, members);\n-        return ArgType::direct(ty, Some(llty), None, None);\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n+        arg.cast = Some(Type::array(&base_ty, members));\n+        return;\n     }\n-    let size = ty_size(ty);\n+    let size = ty_size(arg.ty);\n     if size <= 16 {\n         let llty = if size == 0 {\n             Type::array(&Type::i64(ccx), 0)\n@@ -212,9 +211,10 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         } else {\n             Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n         };\n-        return ArgType::direct(ty, Some(llty), None, None);\n+        arg.cast = Some(llty);\n+        return;\n     }\n-    ArgType::indirect(ty, None)\n+    arg.make_indirect(ccx);\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n@@ -228,24 +228,13 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let mut arg_tys = Vec::new();\n-    for &aty in atys {\n-        let ty = classify_arg_ty(ccx, aty);\n-        arg_tys.push(ty);\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        classify_arg_ty(ccx, arg);\n+    }\n }"}, {"sha": "14ca77836c28f4f9d06a2358028a47715a7d3dda", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n-use trans::cabi::{FnType, ArgType};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n+use trans::abi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -129,12 +129,11 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n     }\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n+    if is_reg_ty(ret.ty) {\n+        return;\n     }\n-    let size = ty_size(ty, align_fn);\n+    let size = ty_size(ret.ty, align_fn);\n     if size <= 4 {\n         let llty = if size <= 1 {\n             Type::i8(ccx)\n@@ -143,24 +142,24 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType\n         } else {\n             Type::i32(ccx)\n         };\n-        return ArgType::direct(ty, Some(llty), None, None);\n+        ret.cast = Some(llty);\n+        return;\n     }\n-    ArgType::indirect(ty, Some(Attribute::StructRet))\n+    ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, align_fn: TyAlignFn) {\n+    if is_reg_ty(arg.ty) {\n+        return;\n     }\n-    let align = align_fn(ty);\n-    let size = ty_size(ty, align_fn);\n+    let align = align_fn(arg.ty);\n+    let size = ty_size(arg.ty, align_fn);\n     let llty = if align <= 4 {\n         Type::array(&Type::i32(ccx), ((size + 3) / 4) as u64)\n     } else {\n         Type::array(&Type::i64(ccx), ((size + 7) / 8) as u64)\n     };\n-    ArgType::direct(ty, Some(llty), None, None)\n+    arg.cast = Some(llty);\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n@@ -174,30 +173,18 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool,\n-                        flavor: Flavor) -> FnType {\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n     let align_fn = match flavor {\n         Flavor::General => general_ty_align as TyAlignFn,\n         Flavor::Ios => ios_ty_align as TyAlignFn,\n     };\n \n-    let mut arg_tys = Vec::new();\n-    for &aty in atys {\n-        let ty = classify_arg_ty(ccx, aty, align_fn);\n-        arg_tys.push(ty);\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret, align_fn);\n     }\n \n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty, align_fn)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        classify_arg_ty(ccx, arg, align_fn);\n+    }\n }"}, {"sha": "c901442f4854898129d9d605f50861f27ba27310", "filename": "src/librustc_trans/trans/cabi_asmjs.rs", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_asmjs.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,62 +11,45 @@\n #![allow(non_upper_case_globals)]\n \n use llvm::{Struct, Array, Attribute};\n-use trans::cabi::{FnType, ArgType};\n+use trans::abi::{FnType, ArgType};\n use trans::context::CrateContext;\n-use trans::type_::Type;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n \n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    match ty.kind() {\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    match ret.ty.kind() {\n         Struct => {\n-            let field_types = ty.field_types();\n+            let field_types = ret.ty.field_types();\n             if field_types.len() == 1 {\n-                ArgType::direct(ty, Some(field_types[0]), None, None)\n+                ret.cast = Some(field_types[0]);\n             } else {\n-                ArgType::indirect(ty, Some(Attribute::StructRet))\n+                ret.make_indirect(ccx);\n             }\n-        },\n+        }\n         Array => {\n-            ArgType::indirect(ty, Some(Attribute::StructRet))\n-        },\n-        _ => {\n-            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-            ArgType::direct(ty, None, None, attr)\n+            ret.make_indirect(ccx);\n         }\n+        _ => {}\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if ty.is_aggregate() {\n-        ArgType::indirect(ty, Some(Attribute::ByVal))\n-    } else {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if arg.ty.is_aggregate() {\n+        arg.make_indirect(ccx);\n+        arg.attrs.set(Attribute::ByVal);\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let mut arg_tys = Vec::new();\n-    for &aty in atys {\n-        let ty = classify_arg_ty(ccx, aty);\n-        arg_tys.push(ty);\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        classify_arg_ty(ccx, arg);\n+    }\n }"}, {"sha": "0d5e81be92142745c977bca82e83f1616f08abfc", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 17, "deletions": 46, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -13,8 +13,8 @@\n use libc::c_uint;\n use std::cmp;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n-use trans::cabi::{ArgType, FnType};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n+use trans::abi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -86,34 +86,18 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n-    } else {\n-        ArgType::indirect(ty, Some(Attribute::StructRet))\n-    }\n-}\n-\n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n-    let size = ty_size(ty) * 8;\n-    let mut align = ty_align(ty);\n+    let size = ty_size(arg.ty) * 8;\n+    let mut align = ty_align(arg.ty);\n \n     align = cmp::min(cmp::max(align, 4), 8);\n     *offset = align_up_to(*offset, align);\n     *offset += align_up_to(size, align * 8) / 8;\n \n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n-    } else {\n-        ArgType::direct(\n-            ty,\n-            Some(struct_ty(ccx, ty)),\n-            padding_ty(ccx, align, orig_offset),\n-            None\n-        )\n+    if !is_reg_ty(arg.ty) {\n+        arg.cast = Some(struct_ty(ccx, arg.ty));\n+        arg.pad = padding_ty(ccx, align, orig_offset);\n     }\n }\n \n@@ -161,27 +145,14 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    let sret = ret_ty.is_indirect();\n-    let mut arg_tys = Vec::new();\n-    let mut offset = if sret { 4 } else { 0 };\n-\n-    for aty in atys {\n-        let ty = classify_arg_ty(ccx, *aty, &mut offset);\n-        arg_tys.push(ty);\n-    };\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() && !is_reg_ty(fty.ret.ty) {\n+        fty.ret.make_indirect(ccx);\n+    }\n \n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        classify_arg_ty(ccx, arg, &mut offset);\n+    }\n }"}, {"sha": "9aa89a04d0a9ad02f0781eb8ade142c7c170f5d0", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 17, "deletions": 46, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -10,8 +10,8 @@\n \n use libc::c_uint;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Attribute};\n-use trans::cabi::{FnType, ArgType};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n+use trans::abi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -82,34 +82,18 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n-    } else {\n-        ArgType::indirect(ty, Some(Attribute::StructRet))\n-    }\n-}\n-\n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n-    let size = ty_size(ty) * 8;\n-    let mut align = ty_align(ty);\n+    let size = ty_size(arg.ty) * 8;\n+    let mut align = ty_align(arg.ty);\n \n     align = cmp::min(cmp::max(align, 4), 8);\n     *offset = align_up_to(*offset, align);\n     *offset += align_up_to(size, align * 8) / 8;\n \n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ArgType::direct(ty, None, None, attr)\n-    } else {\n-        ArgType::direct(\n-            ty,\n-            Some(struct_ty(ccx, ty)),\n-            padding_ty(ccx, align, orig_offset),\n-            None\n-        )\n+    if !is_reg_ty(arg.ty) {\n+        arg.cast = Some(struct_ty(ccx, arg.ty));\n+        arg.pad = padding_ty(ccx, align, orig_offset);\n     }\n }\n \n@@ -156,27 +140,14 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    let sret = ret_ty.is_indirect();\n-    let mut arg_tys = Vec::new();\n-    let mut offset = if sret { 4 } else { 0 };\n-\n-    for aty in atys {\n-        let ty = classify_arg_ty(ccx, *aty, &mut offset);\n-        arg_tys.push(ty);\n-    };\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() && !is_reg_ty(fty.ret.ty) {\n+        fty.ret.make_indirect(ccx);\n+    }\n \n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        classify_arg_ty(ccx, arg, &mut offset);\n+    }\n }"}, {"sha": "340de235732f920498fc8bca01ae0d19385eae37", "filename": "src/librustc_trans/trans/cabi_powerpc64.rs", "status": "modified", "additions": 29, "deletions": 45, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc64.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -15,8 +15,8 @@\n // Alignment of 128 bit types is not currently handled, this will\n // need to be fixed when PowerPC vector support is added.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Attribute};\n-use trans::cabi::{FnType, ArgType};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n+use trans::abi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -151,22 +151,21 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        return;\n     }\n \n     // The PowerPC64 big endian ABI doesn't return aggregates in registers\n     if ccx.sess().target.target.target_endian == \"big\" {\n-        return ArgType::indirect(ty, Some(Attribute::StructRet))\n+        ret.make_indirect(ccx);\n     }\n \n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n-        let llty = Type::array(&base_ty, members);\n-        return ArgType::direct(ty, Some(llty), None, None);\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n+        ret.cast = Some(Type::array(&base_ty, members));\n+        return;\n     }\n-    let size = ty_size(ty);\n+    let size = ty_size(ret.ty);\n     if size <= 16 {\n         let llty = if size <= 1 {\n             Type::i8(ccx)\n@@ -179,28 +178,24 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         } else {\n             Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n         };\n-        return ArgType::direct(ty, Some(llty), None, None);\n+        ret.cast = Some(llty);\n+        return;\n     }\n \n-    ArgType::indirect(ty, Some(Attribute::StructRet))\n+    ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n-    if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        return ArgType::direct(ty, None, None, attr);\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if is_reg_ty(arg.ty) {\n+        return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n-        let llty = Type::array(&base_ty, members);\n-        return ArgType::direct(ty, Some(llty), None, None);\n+\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n+        arg.cast = Some(Type::array(&base_ty, members));\n+        return;\n     }\n \n-    ArgType::direct(\n-        ty,\n-        Some(struct_ty(ccx, ty)),\n-        None,\n-        None\n-    )\n+    arg.cast = Some(struct_ty(ccx, arg.ty));\n }\n \n fn is_reg_ty(ty: Type) -> bool {\n@@ -236,24 +231,13 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     Type::struct_(ccx, &coerce_to_long(ccx, size), false)\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let ret_ty = if ret_def {\n-        classify_ret_ty(ccx, rty)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n-\n-    let mut arg_tys = Vec::new();\n-    for &aty in atys {\n-        let ty = classify_arg_ty(ccx, aty);\n-        arg_tys.push(ty);\n-    };\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n \n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        classify_arg_ty(ccx, arg);\n+    }\n }"}, {"sha": "9e6c4d9af42ee4446873a32414a053368cb9de35", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,78 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::Strategy::*;\n use llvm::*;\n-use trans::cabi::{ArgType, FnType};\n+use trans::abi::FnType;\n use trans::type_::Type;\n use super::common::*;\n use super::machine::*;\n \n-enum Strategy { RetValue(Type), RetPointer }\n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n-    let mut arg_tys = Vec::new();\n-\n-    let ret_ty;\n-    if !ret_def {\n-        ret_ty = ArgType::direct(Type::void(ccx), None, None, None);\n-    } else if rty.kind() == Struct {\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() && fty.ret.ty.kind() == Struct {\n         // Returning a structure. Most often, this will use\n         // a hidden first argument. On some platforms, though,\n         // small structs are returned as integers.\n         //\n         // Some links:\n         // http://www.angelcode.com/dev/callconv/callconv.html\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n-\n         let t = &ccx.sess().target.target;\n-        let strategy = if t.options.is_like_osx || t.options.is_like_windows {\n-            match llsize_of_alloc(ccx, rty) {\n-                1 => RetValue(Type::i8(ccx)),\n-                2 => RetValue(Type::i16(ccx)),\n-                4 => RetValue(Type::i32(ccx)),\n-                8 => RetValue(Type::i64(ccx)),\n-                _ => RetPointer\n+        if t.options.is_like_osx || t.options.is_like_windows {\n+            match llsize_of_alloc(ccx, fty.ret.ty) {\n+                1 => fty.ret.cast = Some(Type::i8(ccx)),\n+                2 => fty.ret.cast = Some(Type::i16(ccx)),\n+                4 => fty.ret.cast = Some(Type::i32(ccx)),\n+                8 => fty.ret.cast = Some(Type::i64(ccx)),\n+                _ => fty.ret.make_indirect(ccx)\n             }\n         } else {\n-            RetPointer\n-        };\n-\n-        match strategy {\n-            RetValue(t) => {\n-                ret_ty = ArgType::direct(rty, Some(t), None, None);\n-            }\n-            RetPointer => {\n-                ret_ty = ArgType::indirect(rty, Some(Attribute::StructRet));\n-            }\n+            fty.ret.make_indirect(ccx);\n         }\n-    } else {\n-        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n-    for &t in atys {\n-        let ty = match t.kind() {\n-            Struct => {\n-                let size = llsize_of_alloc(ccx, t);\n-                if size == 0 {\n-                    ArgType::ignore(t)\n-                } else {\n-                    ArgType::indirect(t, Some(Attribute::ByVal))\n-                }\n-            }\n-            _ => {\n-                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-                ArgType::direct(t, None, None, attr)\n-            }\n-        };\n-        arg_tys.push(ty);\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        if arg.ty.kind() == Struct {\n+            arg.make_indirect(ccx);\n+            arg.attrs.set(Attribute::ByVal);\n+        }\n     }\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n }"}, {"sha": "47d373f90431ec515101712f0811105478d8aa1e", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -16,7 +16,7 @@ use self::RegClass::*;\n \n use llvm::{Integer, Pointer, Float, Double};\n use llvm::{Struct, Array, Attribute, Vector};\n-use trans::cabi::{ArgType, FnType};\n+use trans::abi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n@@ -383,53 +383,44 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                        atys: &[Type],\n-                        rty: Type,\n-                        ret_def: bool) -> FnType {\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     fn x86_64_ty<F>(ccx: &CrateContext,\n-                    ty: Type,\n+                    arg: &mut ArgType,\n                     is_mem_cls: F,\n-                    ind_attr: Attribute)\n-                    -> ArgType where\n-        F: FnOnce(&[RegClass]) -> bool,\n+                    ind_attr: Option<Attribute>)\n+        where F: FnOnce(&[RegClass]) -> bool\n     {\n-        if !ty.is_reg_ty() {\n-            let cls = classify_ty(ty);\n+        if !arg.ty.is_reg_ty() {\n+            let cls = classify_ty(arg.ty);\n             if is_mem_cls(&cls) {\n-                ArgType::indirect(ty, Some(ind_attr))\n+                arg.make_indirect(ccx);\n+                if let Some(attr) = ind_attr {\n+                    arg.attrs.set(attr);\n+                }\n             } else {\n-                ArgType::direct(ty,\n-                                Some(llreg_ty(ccx, &cls)),\n-                                None,\n-                                None)\n+                arg.cast = Some(llreg_ty(ccx, &cls));\n             }\n-        } else {\n-            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-            ArgType::direct(ty, None, None, attr)\n         }\n     }\n \n     let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n     let mut sse_regs = 8; // XMM0-7\n \n-    let ret_ty = if ret_def {\n-        x86_64_ty(ccx, rty, |cls| {\n+    if !fty.ret.is_ignore() {\n+        x86_64_ty(ccx, &mut fty.ret, |cls| {\n             if cls.is_ret_bysret() {\n                 // `sret` parameter thus one less register available\n                 int_regs -= 1;\n                 true\n             } else {\n                 false\n             }\n-        }, Attribute::StructRet)\n-    } else {\n-        ArgType::direct(Type::void(ccx), None, None, None)\n-    };\n+        }, None);\n+    }\n \n-    let mut arg_tys = Vec::new();\n-    for t in atys {\n-        let ty = x86_64_ty(ccx, *t, |cls| {\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        x86_64_ty(ccx, arg, |cls| {\n             let needed_int = cls.iter().filter(|&&c| c == Int).count() as isize;\n             let needed_sse = cls.iter().filter(|c| c.is_sse()).count() as isize;\n             let in_mem = cls.is_pass_byval() ||\n@@ -444,21 +435,15 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 sse_regs -= needed_sse;\n             }\n             in_mem\n-        }, Attribute::ByVal);\n-        arg_tys.push(ty);\n+        }, Some(Attribute::ByVal));\n \n         // An integer, pointer, double or float parameter\n         // thus the above closure passed to `x86_64_ty` won't\n         // get called.\n-        if t.kind() == Integer || t.kind() == Pointer {\n-            int_regs -= 1;\n-        } else if t.kind() == Double || t.kind() == Float {\n-            sse_regs -= 1;\n+        match arg.ty.kind() {\n+            Integer | Pointer => int_regs -= 1,\n+            Double | Float => sse_regs -= 1,\n+            _ => {}\n         }\n     }\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n }"}, {"sha": "43f72c454cf02fb625cc8e08522285821c651839", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 18, "deletions": 43, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,54 +11,29 @@\n use llvm::*;\n use super::common::*;\n use super::machine::*;\n-use trans::cabi::{ArgType, FnType};\n+use trans::abi::{ArgType, FnType};\n use trans::type_::Type;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n-pub fn compute_abi_info(ccx: &CrateContext,\n-                          atys: &[Type],\n-                          rty: Type,\n-                          ret_def: bool) -> FnType {\n-    let mut arg_tys = Vec::new();\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    let fixup = |a: &mut ArgType| {\n+        if a.ty.kind() == Struct {\n+            match llsize_of_alloc(ccx, a.ty) {\n+                1 => a.cast = Some(Type::i8(ccx)),\n+                2 => a.cast = Some(Type::i16(ccx)),\n+                4 => a.cast = Some(Type::i32(ccx)),\n+                8 => a.cast = Some(Type::i64(ccx)),\n+                _ => a.make_indirect(ccx)\n+            }\n+        }\n+    };\n \n-    let ret_ty;\n-    if !ret_def {\n-        ret_ty = ArgType::direct(Type::void(ccx), None, None, None);\n-    } else if rty.kind() == Struct {\n-        ret_ty = match llsize_of_alloc(ccx, rty) {\n-            1 => ArgType::direct(rty, Some(Type::i8(ccx)), None, None),\n-            2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n-            4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n-            8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-            _ => ArgType::indirect(rty, Some(Attribute::StructRet))\n-        };\n-    } else {\n-        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-        ret_ty = ArgType::direct(rty, None, None, attr);\n+    if !fty.ret.is_ignore() {\n+        fixup(&mut fty.ret);\n     }\n-\n-    for &t in atys {\n-        let ty = match t.kind() {\n-            Struct => {\n-                match llsize_of_alloc(ccx, t) {\n-                    1 => ArgType::direct(t, Some(Type::i8(ccx)), None, None),\n-                    2 => ArgType::direct(t, Some(Type::i16(ccx)), None, None),\n-                    4 => ArgType::direct(t, Some(Type::i32(ccx)), None, None),\n-                    8 => ArgType::direct(t, Some(Type::i64(ccx)), None, None),\n-                    _ => ArgType::indirect(t, None)\n-                }\n-            }\n-            _ => {\n-                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n-                ArgType::direct(t, None, None, attr)\n-            }\n-        };\n-        arg_tys.push(ty);\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() { continue; }\n+        fixup(arg);\n     }\n-\n-    return FnType {\n-        arg_tys: arg_tys,\n-        ret_ty: ret_ty,\n-    };\n }"}, {"sha": "17d08cd6c2f292a756cebdd5799d9846fab995dc", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 448, "deletions": 404, "changes": 852, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -25,53 +25,60 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n use middle::subst::{Substs};\n+use middle::traits;\n use rustc::front::map as hir_map;\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n+use trans::attributes;\n use trans::base;\n use trans::base::*;\n use trans::build::*;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n-use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n-                    ExprOrMethodCall, FunctionContext, MethodCallKey};\n+use trans::closure;\n+use trans::common::{self, Block, Result, CrateContext, FunctionContext};\n+use trans::common::{C_uint, C_undef};\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n use trans::glue;\n use trans::inline;\n-use trans::foreign;\n use trans::intrinsic;\n+use trans::machine::{llalign_of_min, llsize_of_store};\n use trans::meth;\n-use trans::monomorphize;\n+use trans::monomorphize::{self, Instance};\n use trans::type_::Type;\n use trans::type_of;\n+use trans::value::Value;\n use trans::Disr;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_front::hir;\n \n-use syntax::abi::Abi;\n-use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n use syntax::errors;\n use syntax::ptr::P;\n \n-pub enum CalleeData<'tcx> {\n+use std::cmp;\n+\n+#[derive(Debug)]\n+pub enum CalleeData {\n     /// Constructor for enum variant/tuple-like-struct.\n     NamedTupleConstructor(Disr),\n \n     /// Function pointer.\n     Fn(ValueRef),\n \n-    Intrinsic(ast::NodeId, &'tcx subst::Substs<'tcx>),\n+    Intrinsic,\n \n     /// Trait object found in the vtable at that index.\n     Virtual(usize)\n }\n \n+#[derive(Debug)]\n pub struct Callee<'tcx> {\n-    pub data: CalleeData<'tcx>,\n+    pub data: CalleeData,\n     pub ty: Ty<'tcx>\n }\n \n@@ -96,61 +103,132 @@ impl<'tcx> Callee<'tcx> {\n     pub fn method<'blk>(bcx: Block<'blk, 'tcx>,\n                         method: ty::MethodCallee<'tcx>) -> Callee<'tcx> {\n         let substs = bcx.tcx().mk_substs(bcx.fcx.monomorphize(&method.substs));\n-        let ty = bcx.fcx.monomorphize(&method.ty);\n-        Callee::def(bcx.ccx(), method.def_id, substs, ty)\n+        Callee::def(bcx.ccx(), method.def_id, substs)\n     }\n \n     /// Function or method definition.\n     pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>,\n                    def_id: DefId,\n-                   substs: &'tcx subst::Substs<'tcx>,\n-                   ty: Ty<'tcx>)\n+                   substs: &'tcx subst::Substs<'tcx>)\n                    -> Callee<'tcx> {\n         let tcx = ccx.tcx();\n \n         if substs.self_ty().is_some() {\n             // Only trait methods can have a Self parameter.\n-            let method_item = tcx.impl_or_trait_item(def_id);\n-            let trait_id = method_item.container().id();\n-            let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n-            let vtbl = common::fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n-            return meth::callee_for_trait_impl(ccx, def_id, substs,\n-                                               trait_id, ty, vtbl);\n+            return Callee::trait_method(ccx, def_id, substs);\n         }\n \n         let maybe_node_id = inline::get_local_instance(ccx, def_id)\n             .and_then(|def_id| tcx.map.as_local_node_id(def_id));\n         let maybe_ast_node = maybe_node_id.and_then(|node_id| {\n             tcx.map.find(node_id)\n         });\n-        match maybe_ast_node {\n+\n+        let data = match maybe_ast_node {\n             Some(hir_map::NodeStructCtor(_)) => {\n-                return Callee {\n-                    data: NamedTupleConstructor(Disr(0)),\n-                    ty: ty\n-                };\n+                NamedTupleConstructor(Disr(0))\n             }\n             Some(hir_map::NodeVariant(_)) => {\n                 let vinfo = common::inlined_variant_def(ccx, maybe_node_id.unwrap());\n-                assert_eq!(vinfo.kind(), ty::VariantKind::Tuple);\n+                NamedTupleConstructor(Disr::from(vinfo.disr_val))\n+            }\n+            Some(hir_map::NodeForeignItem(fi)) if {\n+                let abi = tcx.map.get_foreign_abi(fi.id);\n+                abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic\n+            } => Intrinsic,\n \n-                return Callee {\n-                    data: NamedTupleConstructor(Disr::from(vinfo.disr_val)),\n-                    ty: ty\n+            _ => return Callee::ptr(get_fn(ccx, def_id, substs))\n+        };\n+\n+        Callee {\n+            data: data,\n+            ty: def_ty(tcx, def_id, substs)\n+        }\n+    }\n+\n+    /// Trait method, which has to be resolved to an impl method.\n+    pub fn trait_method<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                            def_id: DefId,\n+                            substs: &'tcx subst::Substs<'tcx>)\n+                            -> Callee<'tcx> {\n+        let tcx = ccx.tcx();\n+\n+        let method_item = tcx.impl_or_trait_item(def_id);\n+        let trait_id = method_item.container().id();\n+        let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n+        match common::fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+            traits::VtableImpl(vtable_impl) => {\n+                let impl_did = vtable_impl.impl_def_id;\n+                let mname = tcx.item_name(def_id);\n+                // create a concatenated set of substitutions which includes\n+                // those from the impl and those from the method:\n+                let impl_substs = vtable_impl.substs.with_method_from(&substs);\n+                let substs = tcx.mk_substs(impl_substs);\n+                let mth = meth::get_impl_method(tcx, impl_did, substs, mname);\n+\n+                // Translate the function, bypassing Callee::def.\n+                // That is because default methods have the same ID as the\n+                // trait method used to look up the impl method that ended\n+                // up here, so calling Callee::def would infinitely recurse.\n+                Callee::ptr(get_fn(ccx, mth.method.def_id, mth.substs))\n+            }\n+            traits::VtableClosure(vtable_closure) => {\n+                // The substitutions should have no type parameters remaining\n+                // after passing through fulfill_obligation\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                let llfn = closure::trans_closure_method(ccx,\n+                                                         vtable_closure.closure_def_id,\n+                                                         vtable_closure.substs,\n+                                                         trait_closure_kind);\n+\n+                let method_ty = def_ty(tcx, def_id, substs);\n+                let fn_ptr_ty = match method_ty.sty {\n+                    ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                    _ => unreachable!(\"expected fn item type, found {}\",\n+                                      method_ty)\n                 };\n+                Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n-            Some(hir_map::NodeForeignItem(fi)) => {\n-                let abi = tcx.map.get_foreign_abi(fi.id);\n-                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                    return Callee {\n-                        data: Intrinsic(fi.id, substs),\n-                        ty: ty\n-                    };\n+            traits::VtableFnPointer(fn_ty) => {\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+\n+                let method_ty = def_ty(tcx, def_id, substs);\n+                let fn_ptr_ty = match method_ty.sty {\n+                    ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                    _ => unreachable!(\"expected fn item type, found {}\",\n+                                      method_ty)\n+                };\n+                Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+            }\n+            traits::VtableObject(ref data) => {\n+                Callee {\n+                    data: Virtual(traits::get_vtable_index_of_object_method(\n+                        tcx, data, def_id)),\n+                    ty: def_ty(tcx, def_id, substs)\n                 }\n             }\n-            _ => {}\n+            vtable => {\n+                unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable);\n+            }\n+        }\n+    }\n+\n+    /// Get the abi::FnType for a direct call. Mainly deals with the fact\n+    /// that a Virtual call doesn't take the vtable, like its shim does.\n+    /// The extra argument types are for variadic (extern \"C\") functions.\n+    pub fn direct_fn_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+                              extra_args: &[Ty<'tcx>]) -> FnType {\n+        let abi = self.ty.fn_abi();\n+        let sig = ccx.tcx().erase_late_bound_regions(self.ty.fn_sig());\n+        let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n+        let mut fn_ty = FnType::unadjusted(ccx, abi, &sig, extra_args);\n+        if let Virtual(_) = self.data {\n+            // Don't pass the vtable, it's not an argument of the virtual fn.\n+            fn_ty.args[1].ignore();\n         }\n-        Callee::ptr(trans_fn_ref_with_substs(ccx, def_id, Some(ty), substs))\n+        fn_ty.adjust_for_abi(ccx, abi, &sig);\n+        fn_ty\n     }\n \n     /// This behemoth of a function translates function calls. Unfortunately, in\n@@ -175,51 +253,36 @@ impl<'tcx> Callee<'tcx> {\n     /// Turn the callee into a function pointer.\n     pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>)\n                      -> Datum<'tcx, Rvalue> {\n+        let fn_ptr_ty = match self.ty.sty {\n+            ty::TyFnDef(_, _, f) => ccx.tcx().mk_ty(ty::TyFnPtr(f)),\n+            _ => self.ty\n+        };\n         match self.data {\n             Fn(llfn) => {\n-                let fn_ptr_ty = match self.ty.sty {\n-                    ty::TyFnDef(_, _, f) => ccx.tcx().mk_ty(ty::TyFnPtr(f)),\n-                    _ => self.ty\n-                };\n                 immediate_rvalue(llfn, fn_ptr_ty)\n             }\n-            Virtual(idx) => meth::trans_object_shim(ccx, self.ty, idx),\n+            Virtual(idx) => {\n+                let llfn = meth::trans_object_shim(ccx, self.ty, idx);\n+                immediate_rvalue(llfn, fn_ptr_ty)\n+            }\n             NamedTupleConstructor(_) => match self.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n-                    return trans_fn_ref_with_substs(ccx, def_id, Some(self.ty), substs);\n+                    return get_fn(ccx, def_id, substs);\n                 }\n                 _ => unreachable!(\"expected fn item type, found {}\", self.ty)\n             },\n-            Intrinsic(..) => unreachable!(\"intrinsic {} getting reified\", self.ty)\n+            Intrinsic => unreachable!(\"intrinsic {} getting reified\", self.ty)\n         }\n     }\n }\n \n-/// Translates a reference (with id `ref_id`) to the fn/method with id `def_id` into a function\n-/// pointer. This may require monomorphization or inlining.\n-pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              def_id: DefId,\n-                              node: ExprOrMethodCall,\n-                              param_substs: &'tcx subst::Substs<'tcx>)\n-                              -> Datum<'tcx, Rvalue> {\n-    let _icx = push_ctxt(\"trans_fn_ref\");\n-\n-    let substs = common::node_id_substs(ccx, node, param_substs);\n-    debug!(\"trans_fn_ref(def_id={:?}, node={:?}, substs={:?})\",\n-           def_id,\n-           node,\n-           substs);\n-    let ref_ty = match node {\n-        ExprId(0) => return trans_fn_ref_with_substs(ccx, def_id, None, substs),\n-        ExprId(id) => ccx.tcx().node_id_to_type(id),\n-        MethodCallKey(method_call) => {\n-            ccx.tcx().tables.borrow().method_map[&method_call].ty\n-        }\n-    };\n-    let ref_ty = monomorphize::apply_param_substs(ccx.tcx(),\n-                                                  param_substs,\n-                                                  &ref_ty);\n-    trans_fn_ref_with_substs(ccx, def_id, Some(ref_ty), substs)\n+/// Given a DefId and some Substs, produces the monomorphic item type.\n+fn def_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n+                def_id: DefId,\n+                substs: &'tcx subst::Substs<'tcx>)\n+                -> Ty<'tcx> {\n+    let ty = tcx.lookup_item_type(def_id).ty;\n+    monomorphize::apply_param_substs(tcx, substs, &ty)\n }\n \n /// Translates an adapter that implements the `Fn` trait for a fn\n@@ -251,6 +314,21 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         ty::ClosureKind::Fn | ty::ClosureKind::FnMut => true,\n         ty::ClosureKind::FnOnce => false,\n     };\n+\n+    let llfnpointer = match bare_fn_ty.sty {\n+        ty::TyFnDef(def_id, substs, _) => {\n+            // Function definitions have to be turned into a pointer.\n+            let llfn = Callee::def(ccx, def_id, substs).reify(ccx).val;\n+            if !is_by_ref {\n+                // A by-value fn item is ignored, so the shim has\n+                // the same signature as the original function.\n+                return llfn;\n+            }\n+            Some(llfn)\n+        }\n+        _ => None\n+    };\n+\n     let bare_fn_ty_maybe_ref = if is_by_ref {\n         tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), bare_fn_ty)\n     } else {\n@@ -285,58 +363,48 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let sig = tcx.erase_late_bound_regions(sig);\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     let tuple_input_ty = tcx.mk_tup(sig.inputs.to_vec());\n+    let sig = ty::FnSig {\n+        inputs: vec![bare_fn_ty_maybe_ref,\n+                     tuple_input_ty],\n+        output: sig.output,\n+        variadic: false\n+    };\n+    let fn_ty = FnType::new(ccx, Abi::RustCall, &sig, &[]);\n     let tuple_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n         unsafety: hir::Unsafety::Normal,\n         abi: Abi::RustCall,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: vec![bare_fn_ty_maybe_ref,\n-                         tuple_input_ty],\n-            output: sig.output,\n-            variadic: false\n-        })\n+        sig: ty::Binder(sig)\n     });\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n                                                                    \"fn_pointer_shim\");\n-    let llfn = declare::declare_internal_rust_fn(ccx, &function_name[..], tuple_fn_ty);\n+    let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n \n     //\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      llfn,\n-                      ast::DUMMY_NODE_ID,\n-                      false,\n-                      sig.output,\n-                      empty_substs,\n-                      None,\n-                      &block_arena);\n-    let mut bcx = init_function(&fcx, false, sig.output);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n+    let mut bcx = fcx.init(false, None);\n \n     let llargs = get_params(fcx.llfn);\n \n-    let self_idx = fcx.arg_offset();\n-    let llfnpointer = match bare_fn_ty.sty {\n-        ty::TyFnDef(def_id, substs, _) => {\n-            // Function definitions have to be turned into a pointer.\n-            Callee::def(ccx, def_id, substs, bare_fn_ty).reify(ccx).val\n-        }\n-\n+    let self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    let llfnpointer = llfnpointer.unwrap_or_else(|| {\n         // the first argument (`self`) will be ptr to the fn pointer\n-        _ => if is_by_ref {\n+        if is_by_ref {\n             Load(bcx, llargs[self_idx])\n         } else {\n             llargs[self_idx]\n         }\n-    };\n+    });\n \n     assert!(!fcx.needs_ret_allocas);\n \n     let dest = fcx.llretslotptr.get().map(|_|\n-        expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\"))\n+        expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\"))\n     );\n \n     let callee = Callee {\n@@ -345,7 +413,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     };\n     bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n \n-    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n+    fcx.finish(bcx, DebugLoc::None);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n \n@@ -359,25 +427,14 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n ///\n /// - `ccx`: the crate context\n /// - `def_id`: def id of the fn or method item being referenced\n-/// - `node`: node id of the reference to the fn/method, if applicable.\n-///   This parameter may be zero; but, if so, the resulting value may not\n-///   have the right type, so it must be cast before being used.\n-/// - `ref_ty`: monotype of the reference to the fn/method, if applicable.\n-///   This parameter may be None; but, if so, the resulting value may not\n-///   have the right type, so it must be cast before being used.\n /// - `substs`: values for each of the fn/method's parameters\n-pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n-    def_id: DefId,\n-    ref_ty: Option<Ty<'tcx>>,\n-    substs: &'tcx subst::Substs<'tcx>)\n-    -> Datum<'tcx, Rvalue>\n-{\n-    let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n+fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                    def_id: DefId,\n+                    substs: &'tcx subst::Substs<'tcx>)\n+                    -> Datum<'tcx, Rvalue> {\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(def_id={:?}, ref_ty={:?}, substs={:?})\",\n-           def_id, ref_ty, substs);\n+    debug!(\"get_fn(def_id={:?}, substs={:?})\", def_id, substs);\n \n     assert!(!substs.types.needs_infer());\n     assert!(!substs.types.has_escaping_regions());\n@@ -407,7 +464,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let must_monomorphise =\n         !substs.types.is_empty() || is_named_tuple_constructor(tcx, def_id);\n \n-    debug!(\"trans_fn_ref_with_substs({:?}) must_monomorphise: {}\",\n+    debug!(\"get_fn({:?}) must_monomorphise: {}\",\n            def_id, must_monomorphise);\n \n     // Create a monomorphic version of generic functions\n@@ -416,46 +473,80 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         assert_eq!(def_id.krate, LOCAL_CRATE);\n \n         let substs = tcx.mk_substs(substs.clone().erase_regions());\n-        let (mut val, fn_ty, must_cast) =\n-            monomorphize::monomorphic_fn(ccx, def_id, substs);\n-        let fn_ty = ref_ty.unwrap_or(fn_ty);\n+        let (val, fn_ty) = monomorphize::monomorphic_fn(ccx, def_id, substs);\n         let fn_ptr_ty = match fn_ty.sty {\n             ty::TyFnDef(_, _, fty) => {\n                 // Create a fn pointer with the substituted signature.\n                 tcx.mk_ty(ty::TyFnPtr(fty))\n             }\n             _ => unreachable!(\"expected fn item type, found {}\", fn_ty)\n         };\n-        if must_cast && ref_ty.is_some() {\n-            let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n-            if llptrty != common::val_ty(val) {\n-                val = consts::ptrcast(val, llptrty);\n-            }\n-        }\n+        assert_eq!(type_of::type_of(ccx, fn_ptr_ty), common::val_ty(val));\n         return immediate_rvalue(val, fn_ptr_ty);\n     }\n \n     // Find the actual function pointer.\n-    let local_node = ccx.tcx().map.as_local_node_id(def_id);\n-    let mut datum = if let Some(node_id) = local_node {\n-        // Type scheme of the function item (may have type params)\n-        let fn_type_scheme = tcx.lookup_item_type(def_id);\n-        let fn_type = match fn_type_scheme.ty.sty {\n-            ty::TyFnDef(_, _, fty) => {\n-                // Create a fn pointer with the normalized signature.\n-                tcx.mk_fn_ptr(infer::normalize_associated_type(tcx, fty))\n+    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let fn_ptr_ty = match ty.sty {\n+        ty::TyFnDef(_, _, fty) => {\n+            // Create a fn pointer with the normalized signature.\n+            tcx.mk_fn_ptr(infer::normalize_associated_type(tcx, fty))\n+        }\n+        _ => unreachable!(\"expected fn item type, found {}\", ty)\n+    };\n+\n+    let instance = Instance::mono(ccx.tcx(), def_id);\n+    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n+        return immediate_rvalue(llfn, fn_ptr_ty);\n+    }\n+\n+    let attrs;\n+    let local_id = ccx.tcx().map.as_local_node_id(def_id);\n+    let maybe_node = local_id.and_then(|id| tcx.map.find(id));\n+    let (sym, attrs, local_item) = match maybe_node {\n+        Some(hir_map::NodeItem(&hir::Item {\n+            ref attrs, id, span, node: hir::ItemFn(..), ..\n+        })) |\n+        Some(hir_map::NodeTraitItem(&hir::TraitItem {\n+            ref attrs, id, span, node: hir::MethodTraitItem(_, Some(_)), ..\n+        })) |\n+        Some(hir_map::NodeImplItem(&hir::ImplItem {\n+            ref attrs, id, span, node: hir::ImplItemKind::Method(..), ..\n+        })) => {\n+            let sym = exported_name(ccx, id, ty, attrs);\n+\n+            if declare::get_defined_value(ccx, &sym).is_some() {\n+                ccx.sess().span_fatal(span,\n+                    &format!(\"symbol `{}` is already defined\", sym));\n             }\n-            _ => unreachable!(\"expected fn item type, found {}\",\n-                              fn_type_scheme.ty)\n-        };\n \n-        // Internal reference.\n-        immediate_rvalue(get_item_val(ccx, node_id), fn_type)\n-    } else {\n-        // External reference.\n-        get_extern_fn(ccx, def_id)\n+            (sym, &attrs[..], Some(id))\n+        }\n+\n+        Some(hir_map::NodeForeignItem(&hir::ForeignItem {\n+            ref attrs, name, node: hir::ForeignItemFn(..), ..\n+        })) => {\n+            (imported_name(name, attrs).to_string(), &attrs[..], None)\n+        }\n+\n+        None => {\n+            attrs = ccx.sess().cstore.item_attrs(def_id);\n+            (ccx.sess().cstore.item_symbol(def_id), &attrs[..], None)\n+        }\n+\n+        ref variant => {\n+            ccx.sess().bug(&format!(\"get_fn: unexpected variant: {:?}\", variant))\n+        }\n     };\n \n+    let llfn = declare::declare_fn(ccx, &sym, ty);\n+    attributes::from_fn_attrs(ccx, attrs, llfn);\n+    if let Some(id) = local_item {\n+        // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n+        attributes::unwind(llfn, true);\n+        ccx.item_symbols().borrow_mut().insert(id, sym);\n+    }\n+\n     // This is subtle and surprising, but sometimes we have to bitcast\n     // the resulting fn pointer.  The reason has to do with external\n     // functions.  If you have two crates that both bind the same C\n@@ -479,30 +570,23 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llptrty = type_of::type_of(ccx, datum.ty);\n-    if common::val_ty(datum.val) != llptrty {\n-        debug!(\"trans_fn_ref_with_substs(): casting pointer!\");\n-        datum.val = consts::ptrcast(datum.val, llptrty);\n+    let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n+    let llfn = if common::val_ty(llfn) != llptrty {\n+        debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n+        consts::ptrcast(llfn, llptrty)\n     } else {\n-        debug!(\"trans_fn_ref_with_substs(): not casting pointer!\");\n-    }\n+        debug!(\"get_fn: not casting pointer!\");\n+        llfn\n+    };\n+\n+    ccx.instances().borrow_mut().insert(instance, llfn);\n \n-    datum\n+    immediate_rvalue(llfn, fn_ptr_ty)\n }\n \n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   did: DefId,\n-                                   args: &[ValueRef],\n-                                   dest: Option<expr::Dest>,\n-                                   debug_loc: DebugLoc)\n-                                   -> Result<'blk, 'tcx> {\n-    let datum = trans_fn_ref(bcx.ccx(), did, ExprId(0), bcx.fcx.param_substs);\n-    Callee::ptr(datum).call(bcx, debug_loc, ArgVals(args), dest)\n-}\n-\n fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                     debug_loc: DebugLoc,\n                                     callee: Callee<'tcx>,\n@@ -519,33 +603,29 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n-    let (abi, ret_ty) = match callee.ty.sty {\n-        ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n-            let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n-            let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-            (f.abi, sig.output)\n+    let abi = callee.ty.fn_abi();\n+    let sig = callee.ty.fn_sig();\n+    let output = bcx.tcx().erase_late_bound_regions(&sig.output());\n+    let output = infer::normalize_associated_type(bcx.tcx(), &output);\n+\n+    let extra_args = match args {\n+        ArgExprs(args) if abi != Abi::RustCall => {\n+            args[sig.0.inputs.len()..].iter().map(|expr| {\n+                common::expr_ty_adjusted(bcx, expr)\n+            }).collect()\n         }\n-        _ => panic!(\"expected fn item or ptr in Callee::call\")\n+        _ => vec![]\n     };\n+    let fn_ty = callee.direct_fn_type(ccx, &extra_args);\n \n-    match callee.data {\n-        Intrinsic(node, substs) => {\n+    let mut callee = match callee.data {\n+        Intrinsic => {\n             assert!(abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic);\n             assert!(dest.is_some());\n \n-            let call_info = match debug_loc {\n-                DebugLoc::At(id, span) => NodeIdAndSpan { id: id, span: span },\n-                DebugLoc::None => {\n-                    bcx.sess().bug(\"No call info for intrinsic call?\")\n-                }\n-            };\n-\n-            let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n-            return intrinsic::trans_intrinsic_call(bcx, node, callee.ty,\n-                                                   arg_cleanup_scope, args,\n-                                                   dest.unwrap(),\n-                                                   substs,\n-                                                   call_info);\n+            return intrinsic::trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n+                                                   args, dest.unwrap(),\n+                                                   debug_loc);\n         }\n         NamedTupleConstructor(disr) => {\n             assert!(dest.is_some());\n@@ -557,34 +637,25 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                        dest.unwrap(),\n                                                        debug_loc);\n         }\n-        _ => {}\n-    }\n-\n-    // Intrinsics should not become actual functions.\n-    // We trans them in place in `trans_intrinsic_call`\n-    assert!(abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic);\n-\n-    let is_rust_fn = abi == Abi::Rust || abi == Abi::RustCall;\n+        f => f\n+    };\n \n     // Generate a location to store the result. If the user does\n     // not care about the result, just make a stack slot.\n     let opt_llretslot = dest.and_then(|dest| match dest {\n         expr::SaveIn(dst) => Some(dst),\n         expr::Ignore => {\n-            let ret_ty = match ret_ty {\n-                ty::FnConverging(ret_ty) => ret_ty,\n-                ty::FnDiverging => ccx.tcx().mk_nil()\n+            let needs_drop = || match output {\n+                ty::FnConverging(ret_ty) => bcx.fcx.type_needs_drop(ret_ty),\n+                ty::FnDiverging => false\n             };\n-            if !is_rust_fn ||\n-              type_of::return_uses_outptr(ccx, ret_ty) ||\n-              bcx.fcx.type_needs_drop(ret_ty) {\n+            if fn_ty.ret.is_indirect() || fn_ty.ret.cast.is_some() || needs_drop() {\n                 // Push the out-pointer if we use an out-pointer for this\n                 // return type, otherwise push \"undef\".\n-                if common::type_is_zero_size(ccx, ret_ty) {\n-                    let llty = type_of::type_of(ccx, ret_ty);\n-                    Some(common::C_undef(llty.ptr_to()))\n+                if fn_ty.ret.is_ignore() {\n+                    Some(C_undef(fn_ty.ret.original_ty.ptr_to()))\n                 } else {\n-                    let llresult = alloc_ty(bcx, ret_ty, \"__llret\");\n+                    let llresult = alloca(bcx, fn_ty.ret.original_ty, \"__llret\");\n                     call_lifetime_start(bcx, llresult);\n                     Some(llresult)\n                 }\n@@ -594,128 +665,98 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     });\n \n-    let mut llresult = unsafe {\n-        llvm::LLVMGetUndef(Type::nil(ccx).ptr_to().to_ref())\n-    };\n+    // If there no destination, return must be direct, with no cast.\n+    if opt_llretslot.is_none() {\n+        assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n+    }\n \n-    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n+    let mut llargs = Vec::new();\n \n-    // The code below invokes the function, using either the Rust\n-    // conventions (if it is a rust fn) or the native conventions\n-    // (otherwise).  The important part is that, when all is said\n-    // and done, either the return value of the function will have been\n-    // written in opt_llretslot (if it is Some) or `llresult` will be\n-    // set appropriately (otherwise).\n-    if is_rust_fn {\n-        let mut llargs = Vec::new();\n-\n-        if let (ty::FnConverging(ret_ty), Some(mut llretslot)) = (ret_ty, opt_llretslot) {\n-            if type_of::return_uses_outptr(ccx, ret_ty) {\n-                let llformal_ret_ty = type_of::type_of(ccx, ret_ty).ptr_to();\n-                let llret_ty = common::val_ty(llretslot);\n-                if llformal_ret_ty != llret_ty {\n-                    // this could happen due to e.g. subtyping\n-                    debug!(\"casting actual return type ({}) to match formal ({})\",\n-                        bcx.llty_str(llret_ty), bcx.llty_str(llformal_ret_ty));\n-                    llretslot = PointerCast(bcx, llretslot, llformal_ret_ty);\n-                }\n-                llargs.push(llretslot);\n-            }\n+    if fn_ty.ret.is_indirect() {\n+        let mut llretslot = opt_llretslot.unwrap();\n+        if let Some(ty) = fn_ty.ret.cast {\n+            llretslot = PointerCast(bcx, llretslot, ty.ptr_to());\n         }\n+        llargs.push(llretslot);\n+    }\n \n-        let arg_start = llargs.len();\n-\n-        // Push the arguments.\n-        bcx = trans_args(bcx,\n-                         args,\n-                         callee.ty,\n-                         &mut llargs,\n-                         cleanup::CustomScope(arg_cleanup_scope),\n-                         abi);\n+    let arg_cleanup_scope = fcx.push_custom_cleanup_scope();\n+    bcx = trans_args(bcx, abi, &fn_ty, &mut callee, args, &mut llargs,\n+                     cleanup::CustomScope(arg_cleanup_scope));\n+    fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n-        fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n+    let llfn = match callee {\n+        Fn(f) => f,\n+        _ => unreachable!(\"expected fn pointer callee, found {:?}\", callee)\n+    };\n \n-        let datum = match callee.data {\n-            Fn(f) => immediate_rvalue(f, callee.ty),\n-            Virtual(idx) => {\n-                // The data and vtable pointers were split by trans_arg_datum.\n-                let vtable = llargs.remove(arg_start + 1);\n-                meth::get_virtual_method(bcx, vtable, idx, callee.ty)\n-            }\n-            _ => unreachable!()\n-        };\n+    let (llret, mut bcx) = base::invoke(bcx, llfn, &llargs, debug_loc);\n+    if !bcx.unreachable.get() {\n+        fn_ty.apply_attrs_callsite(llret);\n+    }\n \n-        // Invoke the actual rust fn and update bcx/llresult.\n-        let (llret, b) = base::invoke(bcx,\n-                                      datum.val,\n-                                      &llargs[..],\n-                                      datum.ty,\n-                                      debug_loc);\n-        bcx = b;\n-        llresult = llret;\n-\n-        // If the Rust convention for this type is return via\n-        // the return value, copy it into llretslot.\n-        match (opt_llretslot, ret_ty) {\n-            (Some(llretslot), ty::FnConverging(ret_ty)) => {\n-                if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n-                    !common::type_is_zero_size(bcx.ccx(), ret_ty)\n-                {\n-                    store_ty(bcx, llret, llretslot, ret_ty)\n-                }\n+    // If the function we just called does not use an outpointer,\n+    // store the result into the rust outpointer. Cast the outpointer\n+    // type to match because some ABIs will use a different type than\n+    // the Rust type. e.g., a {u32,u32} struct could be returned as\n+    // u64.\n+    if !fn_ty.ret.is_ignore() && !fn_ty.ret.is_indirect() {\n+        if let Some(llforeign_ret_ty) = fn_ty.ret.cast {\n+            let llrust_ret_ty = fn_ty.ret.original_ty;\n+            let llretslot = opt_llretslot.unwrap();\n+\n+            // The actual return type is a struct, but the ABI\n+            // adaptation code has cast it into some scalar type.  The\n+            // code that follows is the only reliable way I have\n+            // found to do a transform like i64 -> {i32,i32}.\n+            // Basically we dump the data onto the stack then memcpy it.\n+            //\n+            // Other approaches I tried:\n+            // - Casting rust ret pointer to the foreign type and using Store\n+            //   is (a) unsafe if size of foreign type > size of rust type and\n+            //   (b) runs afoul of strict aliasing rules, yielding invalid\n+            //   assembly under -O (specifically, the store gets removed).\n+            // - Truncating foreign type to correct integral type and then\n+            //   bitcasting to the struct type yields invalid cast errors.\n+            let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n+            base::call_lifetime_start(bcx, llscratch);\n+            Store(bcx, llret, llscratch);\n+            let llscratch_i8 = PointerCast(bcx, llscratch, Type::i8(ccx).ptr_to());\n+            let llretptr_i8 = PointerCast(bcx, llretslot, Type::i8(ccx).ptr_to());\n+            let llrust_size = llsize_of_store(ccx, llrust_ret_ty);\n+            let llforeign_align = llalign_of_min(ccx, llforeign_ret_ty);\n+            let llrust_align = llalign_of_min(ccx, llrust_ret_ty);\n+            let llalign = cmp::min(llforeign_align, llrust_align);\n+            debug!(\"llrust_size={}\", llrust_size);\n+\n+            if !bcx.unreachable.get() {\n+                base::call_memcpy(&B(bcx), llretptr_i8, llscratch_i8,\n+                                  C_uint(ccx, llrust_size), llalign as u32);\n             }\n-            (_, _) => {}\n+            base::call_lifetime_end(bcx, llscratch);\n+        } else if let Some(llretslot) = opt_llretslot {\n+            base::store_ty(bcx, llret, llretslot, output.unwrap());\n         }\n-    } else {\n-        // Lang items are the only case where dest is None, and\n-        // they are always Rust fns.\n-        assert!(dest.is_some());\n-\n-        let mut llargs = Vec::new();\n-        let (llfn, arg_tys) = match (callee.data, &args) {\n-            (Fn(f), &ArgExprs(a)) => {\n-                (f, a.iter().map(|x| common::expr_ty_adjusted(bcx, &x)).collect())\n-            }\n-            _ => panic!(\"expected fn ptr and arg exprs.\")\n-        };\n-        bcx = trans_args(bcx,\n-                         args,\n-                         callee.ty,\n-                         &mut llargs,\n-                         cleanup::CustomScope(arg_cleanup_scope),\n-                         abi);\n-        fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n-\n-        bcx = foreign::trans_native_call(bcx,\n-                                         callee.ty,\n-                                         llfn,\n-                                         opt_llretslot.unwrap(),\n-                                         &llargs[..],\n-                                         arg_tys,\n-                                         debug_loc);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);\n \n     // If the caller doesn't care about the result of this fn call,\n     // drop the temporary slot we made.\n-    match (dest, opt_llretslot, ret_ty) {\n+    match (dest, opt_llretslot, output) {\n         (Some(expr::Ignore), Some(llretslot), ty::FnConverging(ret_ty)) => {\n             // drop the value if it is not being saved.\n-            bcx = glue::drop_ty(bcx,\n-                                llretslot,\n-                                ret_ty,\n-                                debug_loc);\n+            bcx = glue::drop_ty(bcx, llretslot, ret_ty, debug_loc);\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}\n     }\n \n-    if ret_ty == ty::FnDiverging {\n+    if output == ty::FnDiverging {\n         Unreachable(bcx);\n     }\n \n-    Result::new(bcx, llresult)\n+    Result::new(bcx, llret)\n }\n \n pub enum CallArgs<'a, 'tcx> {\n@@ -741,20 +782,19 @@ pub enum CallArgs<'a, 'tcx> {\n fn trans_args_under_call_abi<'blk, 'tcx>(\n                              mut bcx: Block<'blk, 'tcx>,\n                              arg_exprs: &[P<hir::Expr>],\n-                             fn_ty: Ty<'tcx>,\n+                             callee: &mut CalleeData,\n+                             fn_ty: &FnType,\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId)\n                              -> Block<'blk, 'tcx>\n {\n-    let sig = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n-    let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-    let args = sig.inputs;\n+    let mut arg_idx = 0;\n \n     // Translate the `self` argument first.\n     let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n     bcx = trans_arg_datum(bcx,\n-                          args[0],\n                           arg_datum,\n+                          callee, fn_ty, &mut arg_idx,\n                           arg_cleanup_scope,\n                           llargs);\n \n@@ -781,8 +821,8 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                         adt::trans_field_ptr(bcx, repr_ptr, srcval, Disr(0), i)\n                     }).to_expr_datum();\n                 bcx = trans_arg_datum(bcx,\n-                                      field_type,\n                                       arg_datum,\n+                                      callee, fn_ty, &mut arg_idx,\n                                       arg_cleanup_scope,\n                                       llargs);\n             }\n@@ -796,64 +836,20 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     bcx\n }\n \n-fn trans_overloaded_call_args<'blk, 'tcx>(\n-                              mut bcx: Block<'blk, 'tcx>,\n-                              arg_exprs: Vec<&hir::Expr>,\n-                              fn_ty: Ty<'tcx>,\n-                              llargs: &mut Vec<ValueRef>,\n-                              arg_cleanup_scope: cleanup::ScopeId)\n-                              -> Block<'blk, 'tcx> {\n-    // Translate the `self` argument first.\n-    let sig = bcx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n-    let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n-    let arg_tys = sig.inputs;\n-\n-    let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n-    bcx = trans_arg_datum(bcx,\n-                          arg_tys[0],\n-                          arg_datum,\n-                          arg_cleanup_scope,\n-                          llargs);\n-\n-    // Now untuple the rest of the arguments.\n-    let tuple_type = arg_tys[1];\n-    match tuple_type.sty {\n-        ty::TyTuple(ref field_types) => {\n-            for (i, &field_type) in field_types.iter().enumerate() {\n-                let arg_datum =\n-                    unpack_datum!(bcx, expr::trans(bcx, arg_exprs[i + 1]));\n-                bcx = trans_arg_datum(bcx,\n-                                      field_type,\n-                                      arg_datum,\n-                                      arg_cleanup_scope,\n-                                      llargs);\n-            }\n-        }\n-        _ => {\n-            bcx.sess().span_bug(arg_exprs[0].span,\n-                                \"argument to `.call()` wasn't a tuple?!\")\n-        }\n-    };\n-\n-    bcx\n-}\n-\n-pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+pub fn trans_args<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  abi: Abi,\n+                                  fn_ty: &FnType,\n+                                  callee: &mut CalleeData,\n                                   args: CallArgs<'a, 'tcx>,\n-                                  fn_ty: Ty<'tcx>,\n                                   llargs: &mut Vec<ValueRef>,\n-                                  arg_cleanup_scope: cleanup::ScopeId,\n-                                  abi: Abi)\n+                                  arg_cleanup_scope: cleanup::ScopeId)\n                                   -> Block<'blk, 'tcx> {\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n-    let sig = cx.tcx().erase_late_bound_regions(&fn_ty.fn_sig());\n-    let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-    let arg_tys = sig.inputs;\n-    let variadic = sig.variadic;\n \n-    let mut bcx = cx;\n+    let mut bcx = bcx;\n+    let mut arg_idx = 0;\n \n     // First we figure out the caller's view of the types of the arguments.\n     // This will be needed if this is a generic call, because the callee has\n@@ -863,79 +859,90 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             if abi == Abi::RustCall {\n                 // This is only used for direct calls to the `call`,\n                 // `call_mut` or `call_once` functions.\n-                return trans_args_under_call_abi(cx,\n-                                                 arg_exprs,\n-                                                 fn_ty,\n+                return trans_args_under_call_abi(bcx,\n+                                                 arg_exprs, callee, fn_ty,\n                                                  llargs,\n                                                  arg_cleanup_scope)\n             }\n \n-            let num_formal_args = arg_tys.len();\n-            for (i, arg_expr) in arg_exprs.iter().enumerate() {\n-                let arg_ty = if i >= num_formal_args {\n-                    assert!(variadic);\n-                    common::expr_ty_adjusted(cx, &arg_expr)\n-                } else {\n-                    arg_tys[i]\n-                };\n-\n+            for arg_expr in arg_exprs {\n                 let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_expr));\n-                bcx = trans_arg_datum(bcx, arg_ty, arg_datum,\n+                bcx = trans_arg_datum(bcx,\n+                                      arg_datum,\n+                                      callee, fn_ty, &mut arg_idx,\n                                       arg_cleanup_scope,\n                                       llargs);\n             }\n         }\n         ArgOverloadedCall(arg_exprs) => {\n-            return trans_overloaded_call_args(cx,\n-                                              arg_exprs,\n-                                              fn_ty,\n-                                              llargs,\n-                                              arg_cleanup_scope)\n+            for expr in arg_exprs {\n+                let arg_datum =\n+                    unpack_datum!(bcx, expr::trans(bcx, expr));\n+                bcx = trans_arg_datum(bcx,\n+                                      arg_datum,\n+                                      callee, fn_ty, &mut arg_idx,\n+                                      arg_cleanup_scope,\n+                                      llargs);\n+            }\n         }\n         ArgOverloadedOp(lhs, rhs) => {\n-            assert!(!variadic);\n-\n-            bcx = trans_arg_datum(bcx, arg_tys[0], lhs,\n+            bcx = trans_arg_datum(bcx, lhs,\n+                                  callee, fn_ty, &mut arg_idx,\n                                   arg_cleanup_scope,\n                                   llargs);\n \n             if let Some(rhs) = rhs {\n-                assert_eq!(arg_tys.len(), 2);\n-                bcx = trans_arg_datum(bcx, arg_tys[1], rhs,\n+                bcx = trans_arg_datum(bcx, rhs,\n+                                      callee, fn_ty, &mut arg_idx,\n                                       arg_cleanup_scope,\n                                       llargs);\n-            } else {\n-                assert_eq!(arg_tys.len(), 1);\n             }\n         }\n         ArgVals(vs) => {\n-            llargs.extend_from_slice(vs);\n+            match *callee {\n+                Virtual(idx) => {\n+                    llargs.push(vs[0]);\n+\n+                    let fn_ptr = meth::get_virtual_method(bcx, vs[1], idx);\n+                    let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+                    *callee = Fn(PointerCast(bcx, fn_ptr, llty));\n+                    llargs.extend_from_slice(&vs[2..]);\n+                }\n+                _ => llargs.extend_from_slice(vs)\n+            }\n         }\n     }\n \n     bcx\n }\n \n-pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   formal_arg_ty: Ty<'tcx>,\n-                                   arg_datum: Datum<'tcx, Expr>,\n-                                   arg_cleanup_scope: cleanup::ScopeId,\n-                                   llargs: &mut Vec<ValueRef>)\n-                                   -> Block<'blk, 'tcx> {\n+fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               arg_datum: Datum<'tcx, Expr>,\n+                               callee: &mut CalleeData,\n+                               fn_ty: &FnType,\n+                               next_idx: &mut usize,\n+                               arg_cleanup_scope: cleanup::ScopeId,\n+                               llargs: &mut Vec<ValueRef>)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_arg_datum\");\n     let mut bcx = bcx;\n-    let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_datum({:?})\",\n-           formal_arg_ty);\n+    debug!(\"trans_arg_datum({:?})\", arg_datum);\n \n-    let arg_datum_ty = arg_datum.ty;\n+    let arg = &fn_ty.args[*next_idx];\n+    *next_idx += 1;\n+\n+    // Fill padding with undef value, where applicable.\n+    if let Some(ty) = arg.pad {\n+        llargs.push(C_undef(ty));\n+    }\n \n-    debug!(\"   arg datum: {}\", arg_datum.to_string(bcx.ccx()));\n+    // Determine whether we want a by-ref datum even if not appropriate.\n+    let want_by_ref = arg.is_indirect() || arg.cast.is_some();\n \n-    let mut val = if common::type_is_fat_ptr(bcx.tcx(), arg_datum_ty) &&\n-                     !bcx.fcx.type_needs_drop(arg_datum_ty) {\n-        arg_datum.val\n+    let fat_ptr = common::type_is_fat_ptr(bcx.tcx(), arg_datum.ty);\n+    let (by_ref, val) = if fat_ptr && !bcx.fcx.type_needs_drop(arg_datum.ty) {\n+        (true, arg_datum.val)\n     } else {\n         // Make this an rvalue, since we are going to be\n         // passing ownership.\n@@ -944,33 +951,70 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         // Now that arg_datum is owned, get it into the appropriate\n         // mode (ref vs value).\n-        let arg_datum = unpack_datum!(\n-            bcx, arg_datum.to_appropriate_datum(bcx));\n+        let arg_datum = unpack_datum!(bcx, if want_by_ref {\n+            arg_datum.to_ref_datum(bcx)\n+        } else {\n+            arg_datum.to_appropriate_datum(bcx)\n+        });\n \n         // Technically, ownership of val passes to the callee.\n         // However, we must cleanup should we panic before the\n         // callee is actually invoked.\n-        arg_datum.add_clean(bcx.fcx, arg_cleanup_scope)\n+        (arg_datum.kind.is_by_ref(),\n+         arg_datum.add_clean(bcx.fcx, arg_cleanup_scope))\n     };\n \n-    if type_of::arg_is_indirect(ccx, formal_arg_ty) && formal_arg_ty != arg_datum_ty {\n-        // this could happen due to e.g. subtyping\n-        let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n-        debug!(\"casting actual type ({}) to match formal ({})\",\n-               bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n-        debug!(\"Rust types: {:?}; {:?}\", arg_datum_ty,\n-                                     formal_arg_ty);\n-        val = PointerCast(bcx, val, llformal_arg_ty);\n+    if arg.is_ignore() {\n+        return bcx;\n     }\n \n-    debug!(\"--- trans_arg_datum passing {}\", bcx.val_to_string(val));\n+    debug!(\"--- trans_arg_datum passing {:?}\", Value(val));\n \n-    if common::type_is_fat_ptr(bcx.tcx(), formal_arg_ty) {\n+    if fat_ptr {\n+        // Fat pointers should be passed without any transformations.\n+        assert!(!arg.is_indirect() && arg.cast.is_none());\n         llargs.push(Load(bcx, expr::get_dataptr(bcx, val)));\n-        llargs.push(Load(bcx, expr::get_meta(bcx, val)));\n-    } else {\n-        llargs.push(val);\n+\n+        let info_arg = &fn_ty.args[*next_idx];\n+        *next_idx += 1;\n+        assert!(!info_arg.is_indirect() && info_arg.cast.is_none());\n+        let info = Load(bcx, expr::get_meta(bcx, val));\n+\n+        if let Virtual(idx) = *callee {\n+            // We have to grab the fn pointer from the vtable when\n+            // handling the first argument, ensure that here.\n+            assert_eq!(*next_idx, 2);\n+            assert!(info_arg.is_ignore());\n+            let fn_ptr = meth::get_virtual_method(bcx, info, idx);\n+            let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+            *callee = Fn(PointerCast(bcx, fn_ptr, llty));\n+        } else {\n+            assert!(!info_arg.is_ignore());\n+            llargs.push(info);\n+        }\n+        return bcx;\n+    }\n+\n+    let mut val = val;\n+    if by_ref && !arg.is_indirect() {\n+        // Have to load the argument, maybe while casting it.\n+        if arg.original_ty == Type::i1(bcx.ccx()) {\n+            // We store bools as i8 so we need to truncate to i1.\n+            val = LoadRangeAssert(bcx, val, 0, 2, llvm::False);\n+            val = Trunc(bcx, val, arg.original_ty);\n+        } else if let Some(ty) = arg.cast {\n+            val = Load(bcx, PointerCast(bcx, val, ty.ptr_to()));\n+            if !bcx.unreachable.get() {\n+                let llalign = llalign_of_min(bcx.ccx(), arg.ty);\n+                unsafe {\n+                    llvm::LLVMSetAlignment(val, llalign);\n+                }\n+            }\n+        } else {\n+            val = Load(bcx, val);\n+        }\n     }\n \n+    llargs.push(val);\n     bcx\n }"}, {"sha": "89a126e79321be2ab76c15d574b3b5e77c677dcd", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -129,7 +129,9 @@ use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::glue;\n use middle::region;\n use trans::type_::Type;\n+use trans::value::Value;\n use middle::ty::{Ty, TyCtxt};\n+\n use std::fmt;\n use syntax::ast;\n \n@@ -401,9 +403,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             ptr: val,\n         };\n \n-        debug!(\"schedule_lifetime_end({:?}, val={})\",\n-               cleanup_scope,\n-               self.ccx.tn().val_to_string(val));\n+        debug!(\"schedule_lifetime_end({:?}, val={:?})\",\n+               cleanup_scope, Value(val));\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -426,9 +427,9 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             drop_hint: drop_hint,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_mem({:?}, val={:?}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n+               Value(val),\n                ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n@@ -454,10 +455,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             drop_hint: drop_hint,\n         };\n \n-        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={:?},\n+        debug!(\"schedule_drop_and_fill_mem({:?}, val={:?}, ty={:?},\n                 fill_on_drop={}, skip_dtor={}, has_drop_hint={})\",\n                cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n+               Value(val),\n                ty,\n                drop.fill_on_drop,\n                drop.skip_dtor,\n@@ -488,9 +489,9 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             drop_hint: None,\n         };\n \n-        debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_adt_contents({:?}, val={:?}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n+               Value(val),\n                ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n@@ -514,9 +515,9 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             drop_hint: None,\n         });\n \n-        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n+        debug!(\"schedule_drop_immediate({:?}, val={:?}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n+               Value(val),\n                ty,\n                drop.fill_on_drop,\n                drop.skip_dtor);\n@@ -532,10 +533,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                            content_ty: Ty<'tcx>) {\n         let drop = box FreeValue { ptr: val, heap: heap, content_ty: content_ty };\n \n-        debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n-               cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n-               heap);\n+        debug!(\"schedule_free_value({:?}, val={:?}, heap={:?})\",\n+               cleanup_scope, Value(val), heap);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }"}, {"sha": "2036feb31a25bcd84975e46c6a7bb73c6099f46a", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 179, "deletions": 144, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -10,55 +10,53 @@\n \n use arena::TypedArena;\n use back::link::{self, mangle_internal_name_by_path_and_seq};\n-use llvm::{ValueRef, get_params};\n+use llvm::{ValueRef, get_param, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n use middle::traits::ProjectionMode;\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n use trans::build::*;\n use trans::callee::{self, ArgVals, Callee};\n use trans::cleanup::{CleanupMethods, CustomScope, ScopeId};\n use trans::common::*;\n-use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue};\n+use trans::datum::{ByRef, Datum, lvalue_scratch_datum};\n+use trans::datum::{rvalue_scratch_datum, Rvalue};\n use trans::debuginfo::{self, DebugLoc};\n use trans::declare;\n use trans::expr;\n-use trans::monomorphize::{MonoId};\n-use trans::type_of::*;\n+use trans::monomorphize::{Instance};\n+use trans::value::Value;\n use trans::Disr;\n-use middle::ty;\n+use middle::ty::{self, Ty, TyCtxt};\n use session::config::FullDebugInfo;\n \n-use syntax::abi::Abi::RustCall;\n use syntax::ast;\n-use syntax::attr::{ThinAttributes, ThinAttributesExt};\n \n use rustc_front::hir;\n \n+use libc::c_uint;\n \n fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         closure_def_id: DefId,\n                                         arg_scope_id: ScopeId,\n-                                        freevars: &[ty::Freevar])\n-                                        -> Block<'blk, 'tcx>\n-{\n+                                        id: ast::NodeId) {\n     let _icx = push_ctxt(\"closure::load_closure_environment\");\n+    let kind = kind_for_closure(bcx.ccx(), closure_def_id);\n+\n+    let env_arg = &bcx.fcx.fn_ty.args[0];\n+    let mut env_idx = bcx.fcx.fn_ty.ret.is_indirect() as usize;\n \n     // Special case for small by-value selfs.\n-    let closure_ty = node_id_type(bcx, bcx.fcx.id);\n-    let self_type = self_type_for_closure(bcx.ccx(), closure_def_id, closure_ty);\n-    let kind = kind_for_closure(bcx.ccx(), closure_def_id);\n-    let llenv = if kind == ty::ClosureKind::FnOnce &&\n-            !arg_is_indirect(bcx.ccx(), self_type) {\n-        let datum = rvalue_scratch_datum(bcx,\n-                                         self_type,\n-                                         \"closure_env\");\n-        store_ty(bcx, bcx.fcx.llenv.unwrap(), datum.val, self_type);\n-        datum.val\n+    let llenv = if kind == ty::ClosureKind::FnOnce && !env_arg.is_indirect() {\n+        let closure_ty = node_id_type(bcx, id);\n+        let llenv = rvalue_scratch_datum(bcx, closure_ty, \"closure_env\").val;\n+        env_arg.store_fn_arg(&bcx.build(), &mut env_idx, llenv);\n+        llenv\n     } else {\n-        bcx.fcx.llenv.unwrap()\n+        get_param(bcx.fcx.llfn, env_idx as c_uint)\n     };\n \n     // Store the pointer to closure data in an alloca for debug info because that's what the\n@@ -71,100 +69,120 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None\n     };\n \n-    for (i, freevar) in freevars.iter().enumerate() {\n-        let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n-                                     closure_expr_id: bcx.fcx.id };\n-        let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n-        let mut upvar_ptr = StructGEP(bcx, llenv, i);\n-        let captured_by_ref = match upvar_capture {\n-            ty::UpvarCapture::ByValue => false,\n-            ty::UpvarCapture::ByRef(..) => {\n-                upvar_ptr = Load(bcx, upvar_ptr);\n-                true\n+    bcx.tcx().with_freevars(id, |fv| {\n+        for (i, freevar) in fv.iter().enumerate() {\n+            let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n+                                        closure_expr_id: id };\n+            let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n+            let mut upvar_ptr = StructGEP(bcx, llenv, i);\n+            let captured_by_ref = match upvar_capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => {\n+                    upvar_ptr = Load(bcx, upvar_ptr);\n+                    true\n+                }\n+            };\n+            let node_id = freevar.def.var_id();\n+            bcx.fcx.llupvars.borrow_mut().insert(node_id, upvar_ptr);\n+\n+            if kind == ty::ClosureKind::FnOnce && !captured_by_ref {\n+                let hint = bcx.fcx.lldropflag_hints.borrow().hint_datum(upvar_id.var_id);\n+                bcx.fcx.schedule_drop_mem(arg_scope_id,\n+                                        upvar_ptr,\n+                                        node_id_type(bcx, node_id),\n+                                        hint)\n             }\n-        };\n-        let node_id = freevar.def.var_id();\n-        bcx.fcx.llupvars.borrow_mut().insert(node_id, upvar_ptr);\n-\n-        if kind == ty::ClosureKind::FnOnce && !captured_by_ref {\n-            let hint = bcx.fcx.lldropflag_hints.borrow().hint_datum(upvar_id.var_id);\n-            bcx.fcx.schedule_drop_mem(arg_scope_id,\n-                                      upvar_ptr,\n-                                      node_id_type(bcx, node_id),\n-                                      hint)\n-        }\n \n-        if let Some(env_pointer_alloca) = env_pointer_alloca {\n-            debuginfo::create_captured_var_metadata(\n-                bcx,\n-                node_id,\n-                env_pointer_alloca,\n-                i,\n-                captured_by_ref,\n-                freevar.span);\n+            if let Some(env_pointer_alloca) = env_pointer_alloca {\n+                debuginfo::create_captured_var_metadata(\n+                    bcx,\n+                    node_id,\n+                    env_pointer_alloca,\n+                    i,\n+                    captured_by_ref,\n+                    freevar.span);\n+            }\n         }\n-    }\n-\n-    bcx\n+    })\n }\n \n-pub enum ClosureEnv<'a> {\n+pub enum ClosureEnv {\n     NotClosure,\n-    Closure(DefId, &'a [ty::Freevar]),\n+    Closure(DefId, ast::NodeId),\n }\n \n-impl<'a> ClosureEnv<'a> {\n-    pub fn load<'blk,'tcx>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId)\n-                           -> Block<'blk, 'tcx>\n-    {\n-        match self {\n-            ClosureEnv::NotClosure => bcx,\n-            ClosureEnv::Closure(def_id, freevars) => {\n-                if freevars.is_empty() {\n-                    bcx\n-                } else {\n-                    load_closure_environment(bcx, def_id, arg_scope, freevars)\n-                }\n-            }\n+impl ClosureEnv {\n+    pub fn load<'blk,'tcx>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId) {\n+        if let ClosureEnv::Closure(def_id, id) = self {\n+            load_closure_environment(bcx, def_id, arg_scope, id);\n         }\n     }\n }\n \n+fn get_self_type<'tcx>(tcx: &TyCtxt<'tcx>,\n+                       closure_id: DefId,\n+                       fn_ty: Ty<'tcx>)\n+                       -> Ty<'tcx> {\n+    match tcx.closure_kind(closure_id) {\n+        ty::ClosureKind::Fn => {\n+            tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), fn_ty)\n+        }\n+        ty::ClosureKind::FnMut => {\n+            tcx.mk_mut_ref(tcx.mk_region(ty::ReStatic), fn_ty)\n+        }\n+        ty::ClosureKind::FnOnce => fn_ty,\n+    }\n+}\n+\n /// Returns the LLVM function declaration for a closure, creating it if\n /// necessary. If the ID does not correspond to a closure ID, returns None.\n-pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                   closure_id: DefId,\n-                                                   substs: &ty::ClosureSubsts<'tcx>)\n-                                                   -> ValueRef {\n+fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                               closure_id: DefId,\n+                                               substs: &ty::ClosureSubsts<'tcx>)\n+                                               -> ValueRef {\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let substs = ccx.tcx().erase_regions(substs);\n-    let mono_id = MonoId {\n+    let tcx = ccx.tcx();\n+    let substs = tcx.erase_regions(substs);\n+    let instance = Instance {\n         def: closure_id,\n         params: &substs.func_substs.types\n     };\n \n-    if let Some(&llfn) = ccx.closure_vals().borrow().get(&mono_id) {\n+    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         debug!(\"get_or_create_closure_declaration(): found closure {:?}: {:?}\",\n-               mono_id, ccx.tn().val_to_string(llfn));\n+               instance, Value(llfn));\n         return llfn;\n     }\n \n-    let path = ccx.tcx().def_path(closure_id);\n+    let path = tcx.def_path(closure_id);\n     let symbol = mangle_internal_name_by_path_and_seq(path, \"closure\");\n \n-    let function_type = ccx.tcx().mk_closure_from_closure_substs(closure_id, Box::new(substs));\n-    let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type);\n+    // Compute the rust-call form of the closure call method.\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n+    let sig = &infcx.closure_type(closure_id, &substs).sig;\n+    let sig = tcx.erase_late_bound_regions(sig);\n+    let sig = infer::normalize_associated_type(tcx, &sig);\n+    let closure_type = tcx.mk_closure_from_closure_substs(closure_id, Box::new(substs));\n+    let function_type = tcx.mk_fn_ptr(ty::BareFnTy {\n+        unsafety: hir::Unsafety::Normal,\n+        abi: Abi::RustCall,\n+        sig: ty::Binder(ty::FnSig {\n+            inputs: Some(get_self_type(tcx, closure_id, closure_type))\n+                        .into_iter().chain(sig.inputs).collect(),\n+            output: sig.output,\n+            variadic: false\n+        })\n+    });\n+    let llfn = declare::define_internal_fn(ccx, &symbol, function_type);\n \n     // set an inline hint for all closures\n     attributes::inline(llfn, attributes::InlineAttr::Hint);\n \n     debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n-            closure {:?} (type {}): {:?}\",\n-           mono_id,\n-           ccx.tn().type_to_string(val_ty(llfn)),\n-           ccx.tn().val_to_string(llfn));\n-    ccx.closure_vals().borrow_mut().insert(mono_id, llfn);\n+            closure {:?}: {:?}\",\n+           instance, Value(llfn));\n+    ccx.instances().borrow_mut().insert(instance, llfn);\n \n     llfn\n }\n@@ -179,8 +197,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                                     body: &hir::Block,\n                                     id: ast::NodeId,\n                                     closure_def_id: DefId, // (*)\n-                                    closure_substs: &'tcx ty::ClosureSubsts<'tcx>,\n-                                    closure_expr_attrs: &ThinAttributes)\n+                                    closure_substs: &ty::ClosureSubsts<'tcx>)\n                                     -> Option<Block<'a, 'tcx>>\n {\n     // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n@@ -210,22 +227,29 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n     let function_type = infcx.closure_type(closure_def_id, closure_substs);\n \n-    let freevars: Vec<ty::Freevar> =\n-        tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n-\n     let sig = tcx.erase_late_bound_regions(&function_type.sig);\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n \n+    let closure_type = tcx.mk_closure_from_closure_substs(closure_def_id,\n+        Box::new(closure_substs.clone()));\n+    let sig = ty::FnSig {\n+        inputs: Some(get_self_type(tcx, closure_def_id, closure_type))\n+                    .into_iter().chain(sig.inputs).collect(),\n+        output: sig.output,\n+        variadic: false\n+    };\n+    let fn_ty = FnType::new(ccx, Abi::RustCall, &sig, &[]);\n+\n     trans_closure(ccx,\n                   decl,\n                   body,\n                   llfn,\n                   param_substs,\n+                  closure_def_id,\n                   id,\n-                  closure_expr_attrs.as_attr_slice(),\n-                  sig.output,\n-                  function_type.abi,\n-                  ClosureEnv::Closure(closure_def_id, &freevars));\n+                  fn_ty,\n+                  Abi::RustCall,\n+                  ClosureEnv::Closure(closure_def_id, id));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and\n@@ -241,21 +265,23 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let repr = adt::represent_type(ccx, node_id_type(bcx, id));\n \n     // Create the closure.\n-    for (i, freevar) in freevars.iter().enumerate() {\n-        let datum = expr::trans_local_var(bcx, freevar.def);\n-        let upvar_slot_dest = adt::trans_field_ptr(\n-            bcx, &repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n-        let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n-                                     closure_expr_id: id };\n-        match tcx.upvar_capture(upvar_id).unwrap() {\n-            ty::UpvarCapture::ByValue => {\n-                bcx = datum.store_to(bcx, upvar_slot_dest);\n-            }\n-            ty::UpvarCapture::ByRef(..) => {\n-                Store(bcx, datum.to_llref(), upvar_slot_dest);\n+    tcx.with_freevars(id, |fv| {\n+        for (i, freevar) in fv.iter().enumerate() {\n+            let datum = expr::trans_var(bcx, freevar.def);\n+            let upvar_slot_dest = adt::trans_field_ptr(\n+                bcx, &repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n+            let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n+                                        closure_expr_id: id };\n+            match tcx.upvar_capture(upvar_id).unwrap() {\n+                ty::UpvarCapture::ByValue => {\n+                    bcx = datum.store_to(bcx, upvar_slot_dest);\n+                }\n+                ty::UpvarCapture::ByRef(..) => {\n+                    Store(bcx, datum.to_llref(), upvar_slot_dest);\n+                }\n             }\n         }\n-    }\n+    });\n     adt::trans_set_discr(bcx, &repr, dest_addr, Disr(0));\n \n     Some(bcx)\n@@ -278,11 +304,8 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n \n     debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n-           trait_closure_kind={:?}, \\\n-           llfn={})\",\n-           llfn_closure_kind,\n-           trait_closure_kind,\n-           ccx.tn().val_to_string(llfn));\n+           trait_closure_kind={:?}, llfn={:?})\",\n+           llfn_closure_kind, trait_closure_kind, Value(llfn));\n \n     match (llfn_closure_kind, trait_closure_kind) {\n         (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n@@ -324,10 +347,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     llreffn: ValueRef)\n     -> ValueRef\n {\n-    debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={})\",\n-           closure_def_id,\n-           substs,\n-           ccx.tn().val_to_string(llreffn));\n+    debug!(\"trans_fn_once_adapter_shim(closure_def_id={:?}, substs={:?}, llreffn={:?})\",\n+           closure_def_id, substs, Value(llreffn));\n \n     let tcx = ccx.tcx();\n     let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n@@ -348,56 +369,70 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n            llref_fn_ty);\n \n-    let ret_ty = tcx.erase_late_bound_regions(&sig.output());\n-    let ret_ty = infer::normalize_associated_type(ccx.tcx(), &ret_ty);\n \n     // Make a version of the closure type with the same arguments, but\n     // with argument #0 being by value.\n-    assert_eq!(abi, RustCall);\n+    assert_eq!(abi, Abi::RustCall);\n     sig.0.inputs[0] = closure_ty;\n+\n+    let sig = tcx.erase_late_bound_regions(&sig);\n+    let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n+\n     let llonce_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n-        sig: sig\n+        sig: ty::Binder(sig)\n     });\n \n     // Create the by-value helper.\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n-    let lloncefn = declare::define_internal_rust_fn(ccx, &function_name,\n-                                                    llonce_fn_ty);\n+    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      lloncefn,\n-                      ast::DUMMY_NODE_ID,\n-                      false,\n-                      ret_ty,\n-                      substs.func_substs,\n-                      None,\n-                      &block_arena);\n-    let mut bcx = init_function(&fcx, false, ret_ty);\n+    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, substs.func_substs, &block_arena);\n+    let mut bcx = fcx.init(false, None);\n \n-    let mut llargs = get_params(fcx.llfn);\n \n     // the first argument (`self`) will be the (by value) closure env.\n     let self_scope = fcx.push_custom_cleanup_scope();\n     let self_scope_id = CustomScope(self_scope);\n-    let rvalue_mode = datum::appropriate_rvalue_mode(ccx, closure_ty);\n-    let self_idx = fcx.arg_offset();\n-    let llself = llargs[self_idx];\n-    let env_datum = Datum::new(llself, closure_ty, Rvalue::new(rvalue_mode));\n-    let env_datum = unpack_datum!(bcx,\n-                                  env_datum.to_lvalue_datum_in_scope(bcx, \"self\",\n-                                                                     self_scope_id));\n-\n-    debug!(\"trans_fn_once_adapter_shim: env_datum={}\",\n-           bcx.val_to_string(env_datum.val));\n-    llargs[self_idx] = env_datum.val;\n+\n+    let mut llargs = get_params(fcx.llfn);\n+    let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    let env_arg = &fcx.fn_ty.args[0];\n+    let llenv = if env_arg.is_indirect() {\n+        Datum::new(llargs[self_idx], closure_ty, Rvalue::new(ByRef))\n+            .add_clean(&fcx, self_scope_id)\n+    } else {\n+        unpack_datum!(bcx, lvalue_scratch_datum(bcx, closure_ty, \"self\",\n+                                                InitAlloca::Dropped,\n+                                                self_scope_id, |bcx, llval| {\n+            let mut llarg_idx = self_idx;\n+            env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, llval);\n+            bcx.fcx.schedule_lifetime_end(self_scope_id, llval);\n+            bcx\n+        })).val\n+    };\n+\n+    debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n+    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n+    // For zero-sized closures that means sneaking in a new argument.\n+    if env_arg.is_ignore() {\n+        if self_idx > 0 {\n+            self_idx -= 1;\n+            llargs[self_idx] = llenv;\n+        } else {\n+            llargs.insert(0, llenv);\n+        }\n+    } else {\n+        llargs[self_idx] = llenv;\n+    }\n \n     let dest =\n         fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\")));\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\")));\n \n     let callee = Callee {\n         data: callee::Fn(llreffn),\n@@ -407,7 +442,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n \n-    finish_fn(&fcx, bcx, ret_ty, DebugLoc::None);\n+    fcx.finish(bcx, DebugLoc::None);\n \n     lloncefn\n }"}, {"sha": "2c996c032ca90eedab2b94092626834e3877b51f", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 72, "deletions": 155, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -194,10 +194,10 @@ use rustc_front::intravisit as hir_visit;\n use rustc::front::map as hir_map;\n use rustc::middle::def_id::DefId;\n use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n-use rustc::middle::{ty, traits};\n+use rustc::middle::traits;\n use rustc::middle::subst::{self, Substs, Subst};\n+use rustc::middle::ty::{self, Ty, TypeFoldable};\n use rustc::middle::ty::adjustment::CustomCoerceUnsized;\n-use rustc::middle::ty::fold::TypeFoldable;\n use rustc::mir::repr as mir;\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n@@ -213,25 +213,21 @@ use trans::common::{fulfill_obligation, normalize_and_test_predicates,\n                     type_is_sized};\n use trans::glue;\n use trans::meth;\n-use trans::monomorphize;\n+use trans::monomorphize::{self, Instance};\n use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n \n use std::hash::{Hash, Hasher};\n-use std::rc::Rc;\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n     Eager,\n     Lazy\n }\n \n-#[derive(Eq, Clone, Copy, Debug)]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub enum TransItem<'tcx> {\n-    DropGlue(ty::Ty<'tcx>),\n-    Fn {\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>\n-    },\n+    DropGlue(Ty<'tcx>),\n+    Fn(Instance<'tcx>),\n     Static(NodeId)\n }\n \n@@ -242,35 +238,19 @@ impl<'tcx> Hash for TransItem<'tcx> {\n                 0u8.hash(s);\n                 t.hash(s);\n             },\n-            TransItem::Fn { def_id, substs } => {\n+            TransItem::Fn(instance) => {\n                 1u8.hash(s);\n-                def_id.hash(s);\n-                (substs as *const Substs<'tcx> as usize).hash(s);\n+                instance.def.hash(s);\n+                (instance.params as *const _ as usize).hash(s);\n             }\n             TransItem::Static(node_id) => {\n-                3u8.hash(s);\n+                2u8.hash(s);\n                 node_id.hash(s);\n             }\n         };\n     }\n }\n \n-impl<'tcx> PartialEq for TransItem<'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (*self, *other) {\n-            (TransItem::DropGlue(t1), TransItem::DropGlue(t2)) => t1 == t2,\n-            (TransItem::Fn { def_id: def_id1, substs: substs1 },\n-             TransItem::Fn { def_id: def_id2, substs: substs2 }) => {\n-                def_id1 == def_id2 && substs1 == substs2\n-            },\n-            (TransItem::Static(node_id1), TransItem::Static(node_id2)) => {\n-                node_id1 == node_id2\n-            },\n-            _ => false\n-        }\n-    }\n-}\n-\n pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> FnvHashSet<TransItem<'tcx>> {\n@@ -282,14 +262,9 @@ pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n-        let mut mir_cache = DefIdMap();\n \n         for root in roots {\n-            collect_items_rec(ccx,\n-                              root,\n-                              &mut visited,\n-                              &mut recursion_depths,\n-                              &mut mir_cache);\n+            collect_items_rec(ccx, root, &mut visited, &mut recursion_depths);\n         }\n \n         visited\n@@ -319,27 +294,11 @@ fn collect_roots<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     roots\n }\n \n-#[derive(Clone)]\n-enum CachedMir<'mir, 'tcx: 'mir> {\n-    Ref(&'mir mir::Mir<'tcx>),\n-    Owned(Rc<mir::Mir<'tcx>>)\n-}\n-\n-impl<'mir, 'tcx: 'mir> CachedMir<'mir, 'tcx> {\n-    fn get_ref<'a>(&'a self) -> &'a mir::Mir<'tcx> {\n-        match *self {\n-            CachedMir::Ref(r) => r,\n-            CachedMir::Owned(ref rc) => &rc,\n-        }\n-    }\n-}\n-\n // Collect all monomorphized translation items reachable from `starting_point`\n fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n-                                   recursion_depths: &mut DefIdMap<usize>,\n-                                   mir_cache: &mut DefIdMap<CachedMir<'a, 'tcx>>) {\n+                                   recursion_depths: &mut DefIdMap<usize>) {\n     if !visited.insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -357,29 +316,33 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         TransItem::Static(_) => {\n             recursion_depth_reset = None;\n         }\n-        TransItem::Fn { def_id, substs: ref param_substs } => {\n+        TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n             recursion_depth_reset = Some(check_recursion_limit(ccx,\n-                                                               def_id,\n+                                                               instance,\n                                                                recursion_depths));\n \n             // Scan the MIR in order to find function calls, closures, and\n             // drop-glue\n-            let mir = load_mir(ccx, def_id, mir_cache);\n+            let mir = errors::expect(ccx.sess().diagnostic(), ccx.get_mir(instance.def),\n+                || format!(\"Could not find MIR for function: {}\", instance));\n \n             let mut visitor = MirNeighborCollector {\n                 ccx: ccx,\n-                mir: mir.get_ref(),\n+                mir: &mir,\n                 output: &mut neighbors,\n-                param_substs: param_substs\n+                param_substs: ccx.tcx().mk_substs(Substs {\n+                    types: instance.params.clone(),\n+                    regions: subst::ErasedRegions\n+                })\n             };\n \n-            visitor.visit_mir(mir.get_ref());\n+            visitor.visit_mir(&mir);\n         }\n     }\n \n     for neighbour in neighbors {\n-        collect_items_rec(ccx, neighbour, visited, recursion_depths, mir_cache);\n+        collect_items_rec(ccx, neighbour, visited, recursion_depths);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -389,42 +352,11 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx));\n }\n \n-fn load_mir<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n-                          def_id: DefId,\n-                          mir_cache: &mut DefIdMap<CachedMir<'a, 'tcx>>)\n-                          -> CachedMir<'a, 'tcx> {\n-    let mir_not_found_error_message = || {\n-        format!(\"Could not find MIR for function: {}\",\n-                ccx.tcx().item_path_str(def_id))\n-    };\n-\n-    if def_id.is_local() {\n-        let node_id = ccx.tcx().map.as_local_node_id(def_id).unwrap();\n-        let mir_opt = ccx.mir_map().map.get(&node_id);\n-        let mir = errors::expect(ccx.sess().diagnostic(),\n-                             mir_opt,\n-                             mir_not_found_error_message);\n-        CachedMir::Ref(mir)\n-    } else {\n-        if let Some(mir) = mir_cache.get(&def_id) {\n-            return mir.clone();\n-        }\n-\n-        let mir_opt = ccx.sess().cstore.maybe_get_item_mir(ccx.tcx(), def_id);\n-        let mir = errors::expect(ccx.sess().diagnostic(),\n-                                 mir_opt,\n-                                 mir_not_found_error_message);\n-        let cached = CachedMir::Owned(Rc::new(mir));\n-        mir_cache.insert(def_id, cached.clone());\n-        cached\n-    }\n-}\n-\n fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n-                                       def_id: DefId,\n+                                       instance: Instance<'tcx>,\n                                        recursion_depths: &mut DefIdMap<usize>)\n                                        -> (DefId, usize) {\n-    let recursion_depth = recursion_depths.get(&def_id)\n+    let recursion_depth = recursion_depths.get(&instance.def)\n                                           .map(|x| *x)\n                                           .unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n@@ -433,20 +365,18 @@ fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n     if recursion_depth > ccx.sess().recursion_limit.get() {\n-        if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n-            ccx.sess().span_fatal(ccx.tcx().map.span(node_id),\n-                \"reached the recursion limit during monomorphization\");\n+        let error = format!(\"reached the recursion limit while instantiating `{}`\",\n+                            instance);\n+        if let Some(node_id) = ccx.tcx().map.as_local_node_id(instance.def) {\n+            ccx.sess().span_fatal(ccx.tcx().map.span(node_id), &error);\n         } else {\n-            let error = format!(\"reached the recursion limit during \\\n-                                monomorphization of '{}'\",\n-                                ccx.tcx().item_path_str(def_id));\n-            ccx.sess().fatal(&error[..]);\n+            ccx.sess().fatal(&error);\n         }\n     }\n \n-    recursion_depths.insert(def_id, recursion_depth + 1);\n+    recursion_depths.insert(instance.def, recursion_depth + 1);\n \n-    (def_id, recursion_depth)\n+    (instance.def, recursion_depth)\n }\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n@@ -750,7 +680,7 @@ fn do_static_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> Option<(DefId, &'tcx Substs<'tcx>)> {\n     debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n-           def_id_to_string(ccx, fn_def_id, None),\n+           def_id_to_string(ccx, fn_def_id),\n            fn_substs,\n            param_substs);\n \n@@ -798,8 +728,8 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                             trait_id={}, \\\n                                             callee_substs={:?}, \\\n                                             param_substs={:?}\",\n-           def_id_to_string(ccx, trait_method.def_id, None),\n-           def_id_to_string(ccx, trait_id, None),\n+           def_id_to_string(ccx, trait_method.def_id),\n+           def_id_to_string(ccx, trait_id),\n            callee_substs,\n            param_substs);\n \n@@ -933,7 +863,7 @@ fn create_fn_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   -> TransItem<'tcx>\n {\n     debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n-            def_id_to_string(ccx, def_id, None),\n+            def_id_to_string(ccx, def_id),\n             fn_substs,\n             param_substs);\n \n@@ -945,10 +875,10 @@ fn create_fn_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                            fn_substs);\n     let concrete_substs = ccx.tcx().erase_regions(&concrete_substs);\n \n-    let trans_item = TransItem::Fn {\n-        def_id: def_id,\n-        substs: ccx.tcx().mk_substs(concrete_substs),\n-    };\n+    let trans_item = TransItem::Fn(Instance {\n+        def: def_id,\n+        params: &ccx.tcx().mk_substs(concrete_substs).types,\n+    });\n \n     return trans_item;\n }\n@@ -1048,8 +978,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     if self.mode == TransItemCollectionMode::Eager {\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n                                def_id_to_string(self.ccx,\n-                                                self.ccx.tcx().map.local_def_id(item.id),\n-                                                None));\n+                                                self.ccx.tcx().map.local_def_id(item.id)));\n \n                         let ty = glue::get_drop_glue_type(self.ccx, ty);\n                         self.output.push(TransItem::DropGlue(ty));\n@@ -1059,8 +988,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n                        def_id_to_string(self.ccx,\n-                                        self.ccx.tcx().map.local_def_id(item.id),\n-                                        None));\n+                                        self.ccx.tcx().map.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n             hir::ItemFn(_, _, constness, _, ref generics, _) => {\n@@ -1069,12 +997,10 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     let def_id = self.ccx.tcx().map.local_def_id(item.id);\n \n                     debug!(\"RootCollector: ItemFn({})\",\n-                           def_id_to_string(self.ccx, def_id, None));\n+                           def_id_to_string(self.ccx, def_id));\n \n-                    self.output.push(TransItem::Fn {\n-                        def_id: def_id,\n-                        substs: self.trans_empty_substs\n-                    });\n+                    let instance = Instance::mono(self.ccx.tcx(), def_id);\n+                    self.output.push(TransItem::Fn(instance));\n                 }\n             }\n         }\n@@ -1108,12 +1034,10 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     let def_id = self.ccx.tcx().map.local_def_id(ii.id);\n \n                     debug!(\"RootCollector: MethodImplItem({})\",\n-                           def_id_to_string(self.ccx, def_id, None));\n+                           def_id_to_string(self.ccx, def_id));\n \n-                    self.output.push(TransItem::Fn {\n-                        def_id: def_id,\n-                        substs: self.trans_empty_substs\n-                    });\n+                    let instance = Instance::mono(self.ccx.tcx(), def_id);\n+                    self.output.push(TransItem::Fn(instance));\n                 }\n             }\n             _ => { /* Nothing to do here */ }\n@@ -1142,7 +1066,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let impl_def_id = tcx.map.local_def_id(item.id);\n \n             debug!(\"create_trans_items_for_default_impls(item={})\",\n-                   def_id_to_string(ccx, impl_def_id, None));\n+                   def_id_to_string(ccx, impl_def_id));\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let default_impls = tcx.provided_trait_methods(trait_ref.def_id);\n@@ -1225,7 +1149,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyStruct(adt_def, substs) |\n         ty::TyEnum(adt_def, substs) => {\n             push_item_name(cx, adt_def.did, output);\n-            push_type_params(cx, substs, &[], output);\n+            push_type_params(cx, &substs.types, &[], output);\n         },\n         ty::TyTuple(ref component_types) => {\n             output.push('(');\n@@ -1275,7 +1199,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTrait(ref trait_data) => {\n             push_item_name(cx, trait_data.principal.skip_binder().def_id, output);\n             push_type_params(cx,\n-                             &trait_data.principal.skip_binder().substs,\n+                             &trait_data.principal.skip_binder().substs.types,\n                              &trait_data.bounds.projection_bounds,\n                              output);\n         },\n@@ -1285,7 +1209,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 output.push_str(\"unsafe \");\n             }\n \n-            if abi != ::syntax::abi::Abi::Rust {\n+            if abi != ::trans::abi::Abi::Rust {\n                 output.push_str(\"extern \\\"\");\n                 output.push_str(abi.name());\n                 output.push_str(\"\\\" \");\n@@ -1329,7 +1253,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push_str(\"{\");\n             output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n             output.push_str(\"}\");\n-            push_type_params(cx, closure_substs.func_substs, &[], output);\n+            push_type_params(cx, &closure_substs.func_substs.types, &[], output);\n         }\n         ty::TyError |\n         ty::TyInfer(_) |\n@@ -1371,16 +1295,16 @@ fn push_item_name(ccx: &CrateContext,\n }\n \n fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                              substs: &Substs<'tcx>,\n+                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n                               projections: &[ty::PolyProjectionPredicate<'tcx>],\n                               output: &mut String) {\n-    if substs.types.is_empty() && projections.is_empty() {\n+    if types.is_empty() && projections.is_empty() {\n         return;\n     }\n \n     output.push('<');\n \n-    for &type_parameter in &substs.types {\n+    for &type_parameter in types {\n         push_unique_type_name(cx, type_parameter, output);\n         output.push_str(\", \");\n     }\n@@ -1400,23 +1324,16 @@ fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     output.push('>');\n }\n \n-fn push_def_id_as_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              def_id: DefId,\n-                              substs: Option<&Substs<'tcx>>,\n-                              output: &mut String) {\n-    push_item_name(ccx, def_id, output);\n-\n-    if let Some(substs) = substs {\n-        push_type_params(ccx, substs, &[], output);\n-    }\n+fn push_instance_as_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     instance: Instance<'tcx>,\n+                                     output: &mut String) {\n+    push_item_name(ccx, instance.def, output);\n+    push_type_params(ccx, instance.params, &[], output);\n }\n \n-fn def_id_to_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              def_id: DefId,\n-                              substs: Option<&Substs<'tcx>>)\n-                              -> String {\n+fn def_id_to_string(ccx: &CrateContext, def_id: DefId) -> String {\n     let mut output = String::new();\n-    push_def_id_as_string(ccx, def_id, substs, &mut output);\n+    push_item_name(ccx, def_id, &mut output);\n     output\n }\n \n@@ -1440,23 +1357,23 @@ impl<'tcx> TransItem<'tcx> {\n                 push_unique_type_name(ccx, t, &mut s);\n                 s\n             }\n-            TransItem::Fn { def_id, ref substs } => {\n-                to_string_internal(ccx, \"fn \", def_id, Some(substs))\n+            TransItem::Fn(instance) => {\n+                to_string_internal(ccx, \"fn \", instance)\n             },\n             TransItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n-                to_string_internal(ccx, \"static \", def_id, None)\n+                let instance = Instance::mono(ccx.tcx(), def_id);\n+                to_string_internal(ccx, \"static \", instance)\n             },\n         };\n \n         fn to_string_internal<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                         prefix: &str,\n-                                        def_id: DefId,\n-                                        substs: Option<&Substs<'tcx>>)\n+                                        instance: Instance<'tcx>)\n                                         -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n-            push_def_id_as_string(ccx, def_id, substs, &mut result);\n+            push_instance_as_string(ccx, instance, &mut result);\n             result\n         }\n     }\n@@ -1466,10 +1383,10 @@ impl<'tcx> TransItem<'tcx> {\n             TransItem::DropGlue(t) => {\n                 format!(\"DropGlue({})\", t as *const _ as usize)\n             }\n-            TransItem::Fn { def_id, substs } => {\n+            TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n-                         def_id,\n-                         substs as *const _ as usize)\n+                         instance.def,\n+                         instance.params as *const _ as usize)\n             }\n             TransItem::Static(id) => {\n                 format!(\"Static({:?})\", id)"}, {"sha": "db06b2352fd359c37fb31773a14519c3d7e40055", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 69, "deletions": 173, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -12,8 +12,6 @@\n \n //! Code that is useful in various trans modules.\n \n-pub use self::ExprOrMethodCall::*;\n-\n use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n@@ -23,33 +21,34 @@ use middle::def::Def;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::lang_items::LangItem;\n-use middle::subst::{self, Substs};\n+use middle::subst::Substs;\n+use trans::abi::{Abi, FnType};\n use trans::base;\n use trans::build;\n use trans::builder::Builder;\n-use trans::callee;\n+use trans::callee::Callee;\n use trans::cleanup;\n use trans::consts;\n use trans::datum;\n use trans::debuginfo::{self, DebugLoc};\n use trans::declare;\n use trans::machine;\n+use trans::mir::CachedMir;\n use trans::monomorphize;\n use trans::type_::Type;\n-use trans::type_of;\n+use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::traits::{self, SelectionContext, ProjectionMode};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use rustc_front::hir;\n-use rustc::mir::repr::Mir;\n-use util::nodemap::{FnvHashMap, NodeMap};\n+use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ops::Deref;\n use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n-use std::vec::Vec;\n+\n use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n@@ -75,26 +74,13 @@ pub fn type_is_fat_ptr<'tcx>(cx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty::TyStruct(def, substs) => {\n-            let fields = &def.struct_variant().fields;\n-            fields.len() == 1 && {\n-                type_is_immediate(ccx, monomorphize::field_ty(ccx.tcx(), substs, &fields[0]))\n-            }\n-        }\n-        _ => false\n-    }\n-}\n-\n pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     use trans::machine::llsize_of_alloc;\n     use trans::type_of::sizing_type_of;\n \n     let tcx = ccx.tcx();\n     let simple = ty.is_scalar() ||\n         ty.is_unique() || ty.is_region_ptr() ||\n-        type_is_newtype_immediate(ccx, ty) ||\n         ty.is_simd();\n     if simple && !type_is_fat_ptr(tcx, ty) {\n         return true;\n@@ -120,12 +106,6 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     llsize_of_alloc(ccx, llty) == 0\n }\n \n-/// Identifies types which we declare to be equivalent to `void` in C for the purpose of function\n-/// return types. These are `()`, bot, uninhabited enums and all other zero-sized types.\n-pub fn return_type_is_void<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_nil() || ty.is_empty(ccx.tcx()) || type_is_zero_size(ccx, ty)\n-}\n-\n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n pub fn gensym_name(name: &str) -> ast::Name {\n@@ -252,8 +232,6 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = FnvHashMap<String, ValueRef>;\n-\n pub fn validate_substs(substs: &Substs) {\n     assert!(!substs.types.needs_infer());\n }\n@@ -295,7 +273,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // The MIR for this function. At present, this is optional because\n     // we only have MIR available for things that are local to the\n     // crate.\n-    pub mir: Option<&'a Mir<'tcx>>,\n+    pub mir: Option<CachedMir<'a, 'tcx>>,\n \n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n@@ -306,9 +284,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // always an empty parameter-environment NOTE: @jroesch another use of ParamEnv\n     pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n-    // The environment argument in a closure.\n-    pub llenv: Option<ValueRef>,\n-\n     // A pointer to where to store the return value. If the return type is\n     // immediate, this points to an alloca in the function. Otherwise, it's a\n     // pointer to the hidden first parameter of the function. After function\n@@ -336,11 +311,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // Note that for cleanuppad-based exceptions this is not used.\n     pub landingpad_alloca: Cell<Option<ValueRef>>,\n \n-    // True if the caller expects this fn to use the out pointer to\n-    // return. Either way, your code should write into the slot llretslotptr\n-    // points to, but if this value is false, that slot will be a local alloca.\n-    pub caller_expects_out_pointer: bool,\n-\n     // Maps the DefId's for local variables to the allocas created for\n     // them in llallocas.\n     pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n@@ -352,9 +322,8 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // paths) for the code being compiled.\n     pub lldropflag_hints: RefCell<DropFlagHintsMap<'tcx>>,\n \n-    // The NodeId of the function, or -1 if it doesn't correspond to\n-    // a user-defined function.\n-    pub id: ast::NodeId,\n+    // Describes the return/argument LLVM types and their ABI handling.\n+    pub fn_ty: FnType,\n \n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n@@ -383,20 +352,8 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    pub fn mir(&self) -> &'a Mir<'tcx> {\n-        self.mir.unwrap()\n-    }\n-\n-    pub fn arg_offset(&self) -> usize {\n-        self.env_arg_pos() + if self.llenv.is_some() { 1 } else { 0 }\n-    }\n-\n-    pub fn env_arg_pos(&self) -> usize {\n-        if self.caller_expects_out_pointer {\n-            1\n-        } else {\n-            0\n-        }\n+    pub fn mir(&self) -> CachedMir<'a, 'tcx> {\n+        self.mir.clone().expect(\"fcx.mir was empty\")\n     }\n \n     pub fn cleanup(&self) {\n@@ -419,14 +376,9 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         self.llreturn.get().unwrap()\n     }\n \n-    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n-                        output: ty::FnOutput<'tcx>,\n-                        name: &str) -> ValueRef {\n+    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>, name: &str) -> ValueRef {\n         if self.needs_ret_allocas {\n-            base::alloca(bcx, match output {\n-                ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n-                ty::FnDiverging => Type::void(bcx.ccx())\n-            }, name)\n+            base::alloca(bcx, self.fn_ty.ret.memory_ty(self.ccx), name)\n         } else {\n             self.llretslotptr.get().unwrap()\n         }\n@@ -511,62 +463,60 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         // `rust_eh_personality` function, but rather we wired it up to the\n         // CRT's custom personality function, which forces LLVM to consider\n         // landing pads as \"landing pads for SEH\".\n-        let target = &self.ccx.sess().target.target;\n-        match self.ccx.tcx().lang_items.eh_personality() {\n-            Some(def_id) if !base::wants_msvc_seh(self.ccx.sess()) => {\n-                callee::trans_fn_ref(self.ccx, def_id, ExprId(0),\n-                                     self.param_substs).val\n+        let ccx = self.ccx;\n+        let tcx = ccx.tcx();\n+        let target = &ccx.sess().target.target;\n+        match tcx.lang_items.eh_personality() {\n+            Some(def_id) if !base::wants_msvc_seh(ccx.sess()) => {\n+                Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty())).reify(ccx).val\n             }\n-            _ => {\n-                let mut personality = self.ccx.eh_personality().borrow_mut();\n-                match *personality {\n-                    Some(llpersonality) => llpersonality,\n-                    None => {\n-                        let name = if !base::wants_msvc_seh(self.ccx.sess()) {\n-                            \"rust_eh_personality\"\n-                        } else if target.arch == \"x86\" {\n-                            \"_except_handler3\"\n-                        } else {\n-                            \"__C_specific_handler\"\n-                        };\n-                        let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n-                        let f = declare::declare_cfn(self.ccx, name, fty,\n-                                                     self.ccx.tcx().types.i32);\n-                        *personality = Some(f);\n-                        f\n-                    }\n-                }\n+            _ => if let Some(llpersonality) = ccx.eh_personality().get() {\n+                llpersonality\n+            } else {\n+                let name = if !base::wants_msvc_seh(ccx.sess()) {\n+                    \"rust_eh_personality\"\n+                } else if target.arch == \"x86\" {\n+                    \"_except_handler3\"\n+                } else {\n+                    \"__C_specific_handler\"\n+                };\n+                let fty = Type::variadic_func(&[], &Type::i32(ccx));\n+                let f = declare::declare_cfn(ccx, name, fty);\n+                ccx.eh_personality().set(Some(f));\n+                f\n             }\n         }\n     }\n \n     // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n     // otherwise declares it as an external function.\n-    pub fn eh_unwind_resume(&self) -> ValueRef {\n+    pub fn eh_unwind_resume(&self) -> Callee<'tcx> {\n         use trans::attributes;\n-        assert!(self.ccx.sess().target.target.options.custom_unwind_resume);\n-        match self.ccx.tcx().lang_items.eh_unwind_resume() {\n-            Some(def_id) => {\n-                callee::trans_fn_ref(self.ccx, def_id, ExprId(0),\n-                                     self.param_substs).val\n-            }\n-            None => {\n-                let mut unwresume = self.ccx.eh_unwind_resume().borrow_mut();\n-                match *unwresume {\n-                    Some(llfn) => llfn,\n-                    None => {\n-                        let fty = Type::func(&[Type::i8p(self.ccx)], &Type::void(self.ccx));\n-                        let llfn = declare::declare_fn(self.ccx,\n-                                                       \"rust_eh_unwind_resume\",\n-                                                       llvm::CCallConv,\n-                                                       fty, ty::FnDiverging);\n-                        attributes::unwind(llfn, true);\n-                        *unwresume = Some(llfn);\n-                        llfn\n-                    }\n-                }\n-            }\n+        let ccx = self.ccx;\n+        let tcx = ccx.tcx();\n+        assert!(ccx.sess().target.target.options.custom_unwind_resume);\n+        if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n+            return Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty()));\n         }\n+\n+        let ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+            unsafety: hir::Unsafety::Unsafe,\n+            abi: Abi::C,\n+            sig: ty::Binder(ty::FnSig {\n+                inputs: vec![tcx.mk_mut_ptr(tcx.types.u8)],\n+                output: ty::FnDiverging,\n+                variadic: false\n+            }),\n+        });\n+\n+        let unwresume = ccx.eh_unwind_resume();\n+        if let Some(llfn) = unwresume.get() {\n+            return Callee::ptr(datum::immediate_rvalue(llfn, ty));\n+        }\n+        let llfn = declare::declare_fn(ccx, \"rust_eh_unwind_resume\", ty);\n+        attributes::unwind(llfn, true);\n+        unwresume.set(Some(llfn));\n+        Callee::ptr(datum::immediate_rvalue(llfn, ty))\n     }\n }\n \n@@ -630,7 +580,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.lpad.get()\n     }\n \n-    pub fn mir(&self) -> &'blk Mir<'tcx> {\n+    pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n         self.fcx.mir()\n     }\n \n@@ -652,14 +602,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         }\n     }\n \n-    pub fn val_to_string(&self, val: ValueRef) -> String {\n-        self.ccx().tn().val_to_string(val)\n-    }\n-\n-    pub fn llty_str(&self, ty: Type) -> String {\n-        self.ccx().tn().type_to_string(ty)\n-    }\n-\n     pub fn to_str(&self) -> String {\n         format!(\"[block {:p}]\", self)\n     }\n@@ -746,6 +688,10 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n \n     // Methods delegated to bcx\n \n+    pub fn is_unreachable(&self) -> bool {\n+        self.bcx.unreachable.get()\n+    }\n+\n     pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n         self.bcx.ccx()\n     }\n@@ -763,14 +709,10 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         self.bcx.llbb\n     }\n \n-    pub fn mir(&self) -> &'blk Mir<'tcx> {\n+    pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n         self.bcx.mir()\n     }\n \n-    pub fn val_to_string(&self, val: ValueRef) -> String {\n-        self.bcx.val_to_string(val)\n-    }\n-\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n@@ -1028,15 +970,15 @@ pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n+pub fn const_get_elt(v: ValueRef, us: &[c_uint])\n               -> ValueRef {\n     unsafe {\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-        debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n-               cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n+        debug!(\"const_get_elt(v={:?}, us={:?}, r={:?})\",\n+               Value(v), us, Value(r));\n \n-        return r;\n+        r\n     }\n }\n \n@@ -1215,41 +1157,6 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n }\n \n-// Key used to lookup values supplied for type parameters in an expr.\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum ExprOrMethodCall {\n-    // Type parameters for a path like `None::<int>`\n-    ExprId(ast::NodeId),\n-\n-    // Type parameters for a method call like `a.foo::<int>()`\n-    MethodCallKey(ty::MethodCall)\n-}\n-\n-pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                node: ExprOrMethodCall,\n-                                param_substs: &subst::Substs<'tcx>)\n-                                -> &'tcx subst::Substs<'tcx> {\n-    let tcx = ccx.tcx();\n-\n-    let substs = match node {\n-        ExprId(id) => {\n-            tcx.node_id_item_substs(id).substs\n-        }\n-        MethodCallKey(method_call) => {\n-            tcx.tables.borrow().method_map[&method_call].substs.clone()\n-        }\n-    };\n-\n-    if substs.types.needs_infer() {\n-        tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                              node, substs));\n-    }\n-\n-    ccx.tcx().mk_substs(monomorphize::apply_param_substs(tcx,\n-                                                         param_substs,\n-                                                         &substs.erase_regions()))\n-}\n-\n pub fn langcall(bcx: Block,\n                 span: Option<Span>,\n                 msg: &str,\n@@ -1351,14 +1258,3 @@ pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => panic!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n-\n-pub fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            did: DefId,\n-                            ty: Ty<'tcx>)\n-                            -> ValueRef {\n-    if let Some(node_id) = ccx.tcx().map.as_local_node_id(did) {\n-        base::get_item_val(ccx, node_id)\n-    } else {\n-        base::get_extern_const(ccx, did, ty)\n-    }\n-}"}, {"sha": "82cd6aace0a35063c0825baf34c05c6f0cd96cb4", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 179, "deletions": 63, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -9,27 +9,28 @@\n // except according to those terms.\n \n \n-use back::abi;\n use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n-use middle::cstore::LOCAL_CRATE;\n use middle::const_eval::{self, ConstEvalErr};\n use middle::def::Def;\n use middle::def_id::DefId;\n-use trans::{adt, closure, debuginfo, expr, inline, machine};\n-use trans::base::{self, push_ctxt};\n+use rustc::front::map as hir_map;\n+use trans::{abi, adt, closure, debuginfo, expr, machine};\n+use trans::base::{self, exported_name, imported_name, push_ctxt};\n use trans::callee::Callee;\n use trans::collector::{self, TransItem};\n-use trans::common::{self, type_is_sized, ExprOrMethodCall, node_id_substs, C_nil, const_get_elt};\n+use trans::common::{type_is_sized, C_nil, const_get_elt};\n use trans::common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n use trans::common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, VariantInfo, C_uint};\n-use trans::common::{type_is_fat_ptr, Field, C_vector, C_array, C_null, ExprId, MethodCallKey};\n+use trans::common::{type_is_fat_ptr, Field, C_vector, C_array, C_null};\n+use trans::datum::{Datum, Lvalue};\n use trans::declare;\n-use trans::monomorphize;\n+use trans::monomorphize::{self, Instance};\n use trans::type_::Type;\n use trans::type_of;\n+use trans::value::Value;\n use trans::Disr;\n use middle::subst::Substs;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n@@ -45,7 +46,7 @@ use std::ffi::{CStr, CString};\n use std::borrow::Cow;\n use libc::c_uint;\n use syntax::ast::{self, LitKind};\n-use syntax::attr;\n+use syntax::attr::{self, AttrMetaMethods};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n@@ -191,42 +192,43 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n }\n \n fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                           node: ExprOrMethodCall,\n                            def_id: DefId,\n+                           substs: Substs<'tcx>,\n                            arg_vals: &[ValueRef],\n                            param_substs: &'tcx Substs<'tcx>,\n                            trueconst: TrueConst) -> Result<ValueRef, ConstEvalFailure> {\n     let fn_like = const_eval::lookup_const_fn_by_id(ccx.tcx(), def_id);\n     let fn_like = fn_like.expect(\"lookup_const_fn_by_id failed in const_fn_call\");\n \n+    let body = match fn_like.body().expr {\n+        Some(ref expr) => expr,\n+        None => return Ok(C_nil(ccx))\n+    };\n+\n     let args = &fn_like.decl().inputs;\n     assert_eq!(args.len(), arg_vals.len());\n \n     let arg_ids = args.iter().map(|arg| arg.pat.id);\n     let fn_args = arg_ids.zip(arg_vals.iter().cloned()).collect();\n \n-    let substs = node_id_substs(ccx, node, param_substs);\n-    match fn_like.body().expr {\n-        Some(ref expr) => {\n-            const_expr(ccx, &expr, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n-        },\n-        None => Ok(C_nil(ccx)),\n-    }\n+    let substs = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                  param_substs,\n+                                                  &substs.erase_regions());\n+    let substs = ccx.tcx().mk_substs(substs);\n+\n+    const_expr(ccx, body, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n }\n \n pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 def_id: DefId,\n                                 ref_expr: &hir::Expr,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> &'tcx hir::Expr {\n-    let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n-\n-    if def_id.krate != LOCAL_CRATE {\n-        ccx.sess().span_bug(ref_expr.span,\n-                            \"cross crate constant could not be inlined\");\n-    }\n-\n-    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(ref_expr.id), Some(param_substs)) {\n+    let substs = ccx.tcx().node_id_item_substs(ref_expr.id).substs;\n+    let substs = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                  param_substs,\n+                                                  &substs.erase_regions());\n+    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(substs)) {\n         Some((ref expr, _ty)) => expr,\n         None => {\n             ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n@@ -351,9 +353,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Some(AdjustReifyFnPointer) => {\n             match ety.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n-                    let datum = Callee::def(cx, def_id, substs, ety).reify(cx);\n-                    llconst = datum.val;\n-                    ety_adjusted = datum.ty;\n+                    llconst = Callee::def(cx, def_id, substs).reify(cx).val;\n                 }\n                 _ => {\n                     unreachable!(\"{} cannot be reified to a fn ptr\", ety)\n@@ -405,8 +405,8 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     // to use a different vtable. In that case, we want to\n                     // load out the original data pointer so we can repackage\n                     // it.\n-                    (const_get_elt(cx, llconst, &[abi::FAT_PTR_ADDR as u32]),\n-                     Some(const_get_elt(cx, llconst, &[abi::FAT_PTR_EXTRA as u32])))\n+                    (const_get_elt(llconst, &[abi::FAT_PTR_ADDR as u32]),\n+                     Some(const_get_elt(llconst, &[abi::FAT_PTR_EXTRA as u32])))\n                 } else {\n                     (llconst, None)\n                 };\n@@ -595,17 +595,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n             let (te1, ty) = try!(const_expr(cx, &e1, param_substs, fn_args, trueconst));\n-            debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n-                   cx.tn().val_to_string(te1),\n-                   ty);\n+            debug!(\"const_expr_unadjusted: te1={:?}, ty={:?}\",\n+                   Value(te1), ty);\n             assert!(!ty.is_simd());\n             let is_float = ty.is_fp();\n             let signed = ty.is_signed();\n \n             let (te2, ty2) = try!(const_expr(cx, &e2, param_substs, fn_args, trueconst));\n-            debug!(\"const_expr_unadjusted: te2={}, ty={:?}\",\n-                   cx.tn().val_to_string(te2),\n-                   ty2);\n+            debug!(\"const_expr_unadjusted: te2={:?}, ty={:?}\",\n+                   Value(te2), ty2);\n \n             try!(check_binary_expr_validity(cx, e, ty, te1, te2, trueconst));\n \n@@ -689,8 +687,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let (arr, len) = match bt.sty {\n                 ty::TyArray(_, u) => (bv, C_uint(cx, u)),\n                 ty::TySlice(..) | ty::TyStr => {\n-                    let e1 = const_get_elt(cx, bv, &[0]);\n-                    (load_const(cx, e1, bt), const_get_elt(cx, bv, &[1]))\n+                    let e1 = const_get_elt(bv, &[0]);\n+                    (load_const(cx, e1, bt), const_get_elt(bv, &[1]))\n                 },\n                 ty::TyRef(_, mt) => match mt.ty.sty {\n                     ty::TyArray(_, u) => {\n@@ -725,7 +723,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           \"const index-expr is out of bounds\");\n                 C_undef(val_ty(arr).element_type())\n             } else {\n-                const_get_elt(cx, arr, &[iv as c_uint])\n+                const_get_elt(arr, &[iv as c_uint])\n             }\n         },\n         hir::ExprCast(ref base, _) => {\n@@ -741,10 +739,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let t_cast_inner =\n                     t_cast.builtin_deref(true, ty::NoPreference).expect(\"cast to non-pointer\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, t_cast_inner).ptr_to();\n-                let addr = ptrcast(const_get_elt(cx, v, &[abi::FAT_PTR_ADDR as u32]),\n+                let addr = ptrcast(const_get_elt(v, &[abi::FAT_PTR_ADDR as u32]),\n                                    ptr_ty);\n                 if type_is_fat_ptr(cx.tcx(), t_cast) {\n-                    let info = const_get_elt(cx, v, &[abi::FAT_PTR_EXTRA as u32]);\n+                    let info = const_get_elt(v, &[abi::FAT_PTR_EXTRA as u32]);\n                     return Ok(C_struct(cx, &[addr, info], false))\n                 } else {\n                     return Ok(addr);\n@@ -756,7 +754,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ) {\n                 (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n                     let repr = adt::represent_type(cx, t_expr);\n-                    let discr = adt::const_get_discrim(cx, &repr, v);\n+                    let discr = adt::const_get_discrim(&repr, v);\n                     let iv = C_integral(cx.int_type(), discr.0, false);\n                     let s = adt::is_discr_signed(&repr) as Bool;\n                     llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n@@ -809,7 +807,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n             let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n             if let Some(Def::Static(def_id, _)) = opt_def {\n-                common::get_static_val(cx, def_id, ety)\n+                get_static(cx, def_id).val\n             } else {\n                 // If this isn't the address of a static, then keep going through\n                 // normal constant evaluation.\n@@ -947,8 +945,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 Def::Fn(did) | Def::Method(did) => {\n                     try!(const_fn_call(\n                         cx,\n-                        ExprId(callee.id),\n                         did,\n+                        cx.tcx().node_id_item_substs(callee.id).substs,\n                         &arg_vals,\n                         param_substs,\n                         trueconst,\n@@ -976,9 +974,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprMethodCall(_, _, ref args) => {\n             let arg_vals = try!(map_list(args));\n             let method_call = ty::MethodCall::expr(e.id);\n-            let method_did = cx.tcx().tables.borrow().method_map[&method_call].def_id;\n-            try!(const_fn_call(cx, MethodCallKey(method_call),\n-                               method_did, &arg_vals, param_substs, trueconst))\n+            let method = cx.tcx().tables.borrow().method_map[&method_call];\n+            try!(const_fn_call(cx, method.def_id, method.substs.clone(),\n+                               &arg_vals, param_substs, trueconst))\n         },\n         hir::ExprType(ref e, _) => try!(const_expr(cx, &e, param_substs, fn_args, trueconst)).0,\n         hir::ExprBlock(ref block) => {\n@@ -1001,8 +999,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                 body,\n                                                 e.id,\n                                                 def_id,\n-                                                substs,\n-                                                &e.attrs);\n+                                                substs);\n                 }\n                 _ =>\n                     cx.sess().span_bug(\n@@ -1016,6 +1013,125 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     })\n }\n \n+pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n+                            -> Datum<'tcx, Lvalue> {\n+    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+\n+    let instance = Instance::mono(ccx.tcx(), def_id);\n+    if let Some(&g) = ccx.instances().borrow().get(&instance) {\n+        return Datum::new(g, ty, Lvalue::new(\"static\"));\n+    }\n+\n+    let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n+        let llty = type_of::type_of(ccx, ty);\n+        match ccx.tcx().map.get(id) {\n+            hir_map::NodeItem(&hir::Item {\n+                ref attrs, span, node: hir::ItemStatic(..), ..\n+            }) => {\n+                // If this static came from an external crate, then\n+                // we need to get the symbol from metadata instead of\n+                // using the current crate's name/version\n+                // information in the hash of the symbol\n+                let sym = exported_name(ccx, id, ty, attrs);\n+                debug!(\"making {}\", sym);\n+\n+                // Create the global before evaluating the initializer;\n+                // this is necessary to allow recursive statics.\n+                let g = declare::define_global(ccx, &sym, llty).unwrap_or_else(|| {\n+                    ccx.sess().span_fatal(span,\n+                        &format!(\"symbol `{}` is already defined\", sym))\n+                });\n+\n+                ccx.item_symbols().borrow_mut().insert(id, sym);\n+                g\n+            }\n+\n+            hir_map::NodeForeignItem(&hir::ForeignItem {\n+                ref attrs, name, span, node: hir::ForeignItemStatic(..), ..\n+            }) => {\n+                let ident = imported_name(name, attrs);\n+                let g = if let Some(name) =\n+                        attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n+                    // If this is a static with a linkage specified, then we need to handle\n+                    // it a little specially. The typesystem prevents things like &T and\n+                    // extern \"C\" fn() from being non-null, so we can't just declare a\n+                    // static and call it a day. Some linkages (like weak) will make it such\n+                    // that the static actually has a null value.\n+                    let linkage = match base::llvm_linkage_by_name(&name) {\n+                        Some(linkage) => linkage,\n+                        None => {\n+                            ccx.sess().span_fatal(span, \"invalid linkage specified\");\n+                        }\n+                    };\n+                    let llty2 = match ty.sty {\n+                        ty::TyRawPtr(ref mt) => type_of::type_of(ccx, mt.ty),\n+                        _ => {\n+                            ccx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n+                        }\n+                    };\n+                    unsafe {\n+                        // Declare a symbol `foo` with the desired linkage.\n+                        let g1 = declare::declare_global(ccx, &ident, llty2);\n+                        llvm::SetLinkage(g1, linkage);\n+\n+                        // Declare an internal global `extern_with_linkage_foo` which\n+                        // is initialized with the address of `foo`.  If `foo` is\n+                        // discarded during linking (for example, if `foo` has weak\n+                        // linkage and there are no definitions), then\n+                        // `extern_with_linkage_foo` will instead be initialized to\n+                        // zero.\n+                        let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n+                        real_name.push_str(&ident);\n+                        let g2 = declare::define_global(ccx, &real_name, llty).unwrap_or_else(||{\n+                            ccx.sess().span_fatal(span,\n+                                &format!(\"symbol `{}` is already defined\", ident))\n+                        });\n+                        llvm::SetLinkage(g2, llvm::InternalLinkage);\n+                        llvm::LLVMSetInitializer(g2, g1);\n+                        g2\n+                    }\n+                } else {\n+                    // Generate an external declaration.\n+                    declare::declare_global(ccx, &ident, llty)\n+                };\n+\n+                for attr in attrs {\n+                    if attr.check_name(\"thread_local\") {\n+                        llvm::set_thread_local(g, true);\n+                    }\n+                }\n+\n+                g\n+            }\n+\n+            item => unreachable!(\"get_static: expected static, found {:?}\", item)\n+        }\n+    } else {\n+        // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n+        // FIXME(nagisa): investigate whether it can be changed into define_global\n+        let name = ccx.sess().cstore.item_symbol(def_id);\n+        let g = declare::declare_global(ccx, &name, type_of::type_of(ccx, ty));\n+        // Thread-local statics in some other crate need to *always* be linked\n+        // against in a thread-local fashion, so we need to be sure to apply the\n+        // thread-local attribute locally if it was present remotely. If we\n+        // don't do this then linker errors can be generated where the linker\n+        // complains that one object files has a thread local version of the\n+        // symbol and another one doesn't.\n+        for attr in ccx.tcx().get_attrs(def_id).iter() {\n+            if attr.check_name(\"thread_local\") {\n+                llvm::set_thread_local(g, true);\n+            }\n+        }\n+        if ccx.use_dll_storage_attrs() {\n+            llvm::SetDLLStorageClass(g, llvm::DLLImportStorageClass);\n+        }\n+        g\n+    };\n+\n+    ccx.instances().borrow_mut().insert(instance, g);\n+    Datum::new(g, ty, Lvalue::new(\"static\"))\n+}\n+\n pub fn trans_static(ccx: &CrateContext,\n                     m: hir::Mutability,\n                     expr: &hir::Expr,\n@@ -1029,7 +1145,8 @@ pub fn trans_static(ccx: &CrateContext,\n \n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n-        let g = base::get_item_val(ccx, id);\n+        let def_id = ccx.tcx().map.local_def_id(id);\n+        let datum = get_static(ccx, def_id);\n \n         let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n         let (v, _) = try!(const_expr(\n@@ -1042,40 +1159,39 @@ pub fn trans_static(ccx: &CrateContext,\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n-        let mut val_llty = llvm::LLVMTypeOf(v);\n-        let v = if val_llty == Type::i1(ccx).to_ref() {\n-            val_llty = Type::i8(ccx).to_ref();\n-            llvm::LLVMConstZExt(v, val_llty)\n+        let mut val_llty = val_ty(v);\n+        let v = if val_llty == Type::i1(ccx) {\n+            val_llty = Type::i8(ccx);\n+            llvm::LLVMConstZExt(v, val_llty.to_ref())\n         } else {\n             v\n         };\n \n-        let ty = ccx.tcx().node_id_to_type(id);\n-        let llty = type_of::type_of(ccx, ty);\n-        let g = if val_llty == llty.to_ref() {\n-            g\n+        let llty = type_of::type_of(ccx, datum.ty);\n+        let g = if val_llty == llty {\n+            datum.val\n         } else {\n             // If we created the global with the wrong type,\n             // correct the type.\n             let empty_string = CString::new(\"\").unwrap();\n-            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n+            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(datum.val));\n             let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n-            llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+            llvm::LLVMSetValueName(datum.val, empty_string.as_ptr());\n             let new_g = llvm::LLVMGetOrInsertGlobal(\n-                ccx.llmod(), name_string.as_ptr(), val_llty);\n+                ccx.llmod(), name_string.as_ptr(), val_llty.to_ref());\n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it\n             // with the new global later. (See base::trans_crate.)\n-            ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n+            ccx.statics_to_rauw().borrow_mut().push((datum.val, new_g));\n             new_g\n         };\n-        llvm::LLVMSetAlignment(g, type_of::align_of(ccx, ty));\n+        llvm::LLVMSetAlignment(g, type_of::align_of(ccx, datum.ty));\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != hir::MutMutable {\n-            let tcontents = ty.type_contents(ccx.tcx());\n+            let tcontents = datum.ty.type_contents(ccx.tcx());\n             if !tcontents.interior_unsafe() {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }"}, {"sha": "8f5572f5c4e0ed904f805c623e02017edf352598", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -16,14 +16,16 @@ use middle::def::ExportMap;\n use middle::def_id::DefId;\n use middle::traits;\n use rustc::mir::mir_map::MirMap;\n+use rustc::mir::repr as mir;\n use trans::adt;\n use trans::base;\n use trans::builder::Builder;\n-use trans::common::{ExternMap,BuilderRef_res};\n+use trans::common::BuilderRef_res;\n use trans::debuginfo;\n use trans::declare;\n use trans::glue::DropGlueKind;\n-use trans::monomorphize::MonoId;\n+use trans::mir::CachedMir;\n+use trans::monomorphize::Instance;\n use trans::collector::{TransItem, TransItemState};\n use trans::type_::{Type, TypeNames};\n use middle::subst::Substs;\n@@ -75,6 +77,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     check_overflow: bool,\n     check_drop_flag_for_sanity: bool,\n     mir_map: &'a MirMap<'tcx>,\n+    mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n     available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n     use_dll_storage_attrs: bool,\n@@ -90,8 +93,6 @@ pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     tn: TypeNames,\n-    externs: RefCell<ExternMap>,\n-    item_vals: RefCell<NodeMap<ValueRef>>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>>,\n@@ -100,8 +101,8 @@ pub struct LocalCrateContext<'tcx> {\n     /// Backwards version of the `external` map (inlined items to where they\n     /// came from)\n     external_srcs: RefCell<NodeMap<DefId>>,\n-    /// Cache instances of monomorphized functions\n-    monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n+    /// Cache instances of monomorphic and polymorphic items\n+    instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<usize>>,\n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n     /// Cache generated vtables\n@@ -148,13 +149,13 @@ pub struct LocalCrateContext<'tcx> {\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    closure_vals: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n+    closure_vals: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n-    eh_personality: RefCell<Option<ValueRef>>,\n-    eh_unwind_resume: RefCell<Option<ValueRef>>,\n-    rust_try_fn: RefCell<Option<ValueRef>>,\n+    eh_personality: Cell<Option<ValueRef>>,\n+    eh_unwind_resume: Cell<Option<ValueRef>>,\n+    rust_try_fn: Cell<Option<ValueRef>>,\n \n     intrinsics: RefCell<FnvHashMap<&'static str, ValueRef>>,\n \n@@ -340,6 +341,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n             mir_map: mir_map,\n+            mir_cache: RefCell::new(DefIdMap()),\n             stats: Stats {\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n@@ -464,14 +466,12 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 llmod: llmod,\n                 llcx: llcx,\n                 tn: TypeNames::new(),\n-                externs: RefCell::new(FnvHashMap()),\n-                item_vals: RefCell::new(NodeMap()),\n                 needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n                 fn_pointer_shims: RefCell::new(FnvHashMap()),\n                 drop_glues: RefCell::new(FnvHashMap()),\n                 external: RefCell::new(DefIdMap()),\n                 external_srcs: RefCell::new(NodeMap()),\n-                monomorphized: RefCell::new(FnvHashMap()),\n+                instances: RefCell::new(FnvHashMap()),\n                 monomorphizing: RefCell::new(DefIdMap()),\n                 available_monomorphizations: RefCell::new(FnvHashSet()),\n                 vtables: RefCell::new(FnvHashMap()),\n@@ -492,9 +492,9 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                 closure_vals: RefCell::new(FnvHashMap()),\n                 dbg_cx: dbg_cx,\n-                eh_personality: RefCell::new(None),\n-                eh_unwind_resume: RefCell::new(None),\n-                rust_try_fn: RefCell::new(None),\n+                eh_personality: Cell::new(None),\n+                eh_unwind_resume: Cell::new(None),\n+                rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n@@ -616,14 +616,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.tn\n     }\n \n-    pub fn externs<'a>(&'a self) -> &'a RefCell<ExternMap> {\n-        &self.local.externs\n-    }\n-\n-    pub fn item_vals<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n-        &self.local.item_vals\n-    }\n-\n     pub fn export_map<'a>(&'a self) -> &'a ExportMap {\n         &self.shared.export_map\n     }\n@@ -660,8 +652,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.external_srcs\n     }\n \n-    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>> {\n-        &self.local.monomorphized\n+    pub fn instances<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n+        &self.local.instances\n     }\n \n     pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<usize>> {\n@@ -746,23 +738,23 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.opaque_vec_type\n     }\n \n-    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>> {\n+    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local.closure_vals\n     }\n \n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n         &self.local.dbg_cx\n     }\n \n-    pub fn eh_personality<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n+    pub fn eh_personality<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n         &self.local.eh_personality\n     }\n \n-    pub fn eh_unwind_resume<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n+    pub fn eh_unwind_resume<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n         &self.local.eh_unwind_resume\n     }\n \n-    pub fn rust_try_fn<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n+    pub fn rust_try_fn<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n         &self.local.rust_try_fn\n     }\n \n@@ -829,8 +821,22 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    pub fn mir_map(&self) -> &'b MirMap<'tcx> {\n-        self.shared.mir_map\n+    pub fn get_mir(&self, def_id: DefId) -> Option<CachedMir<'b, 'tcx>> {\n+        if def_id.is_local() {\n+            let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n+            self.shared.mir_map.map.get(&node_id).map(CachedMir::Ref)\n+        } else {\n+            if let Some(mir) = self.shared.mir_cache.borrow().get(&def_id).cloned() {\n+                return Some(CachedMir::Owned(mir));\n+            }\n+\n+            let mir = self.sess().cstore.maybe_get_item_mir(self.tcx(), def_id);\n+            let cached = mir.map(Rc::new);\n+            if let Some(ref mir) = cached {\n+                self.shared.mir_cache.borrow_mut().insert(def_id, mir.clone());\n+            }\n+            cached.map(CachedMir::Owned)\n+        }\n     }\n \n     pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {\n@@ -865,27 +871,23 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret),\n-                                             ccx.tcx().mk_nil());\n+                let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(ccx, $name,\n-                                             Type::variadic_func(&[], &$ret),\n-                                             ccx.tcx().mk_nil());\n+                let f = declare::declare_cfn(ccx, $name, Type::variadic_func(&[], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret),\n-                                             ccx.tcx().mk_nil());\n+                let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n@@ -1032,8 +1034,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n                 ifn!($name, fn($($arg),*) -> void);\n             } else if key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n-                                             Type::func(&[$($arg),*], &void),\n-                                             ccx.tcx().mk_nil());\n+                                             Type::func(&[$($arg),*], &void));\n                 llvm::SetLinkage(f, llvm::InternalLinkage);\n \n                 let bld = ccx.builder();\n@@ -1055,8 +1056,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n                 ifn!($name, fn($($arg),*) -> $ret);\n             } else if key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n-                                             Type::func(&[$($arg),*], &$ret),\n-                                             ccx.tcx().mk_nil());\n+                                             Type::func(&[$($arg),*], &$ret));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }"}, {"sha": "91454df156655b4b149d5f3792d2acd41dda8b88", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,10 +11,11 @@\n use llvm::ValueRef;\n use middle::def::Def;\n use middle::lang_items::{PanicFnLangItem, PanicBoundsCheckFnLangItem};\n+use middle::subst::Substs;\n use trans::base::*;\n use trans::basic_block::BasicBlock;\n use trans::build::*;\n-use trans::callee;\n+use trans::callee::{Callee, ArgVals};\n use trans::cleanup::CleanupMethods;\n use trans::cleanup;\n use trans::common::*;\n@@ -24,7 +25,6 @@ use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::machine;\n use trans;\n-use middle::ty;\n \n use rustc_front::hir;\n use rustc_front::util as ast_util;\n@@ -152,9 +152,8 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             els: Option<&hir::Expr>,\n                             dest: expr::Dest)\n                             -> Block<'blk, 'tcx> {\n-    debug!(\"trans_if(bcx={}, if_id={}, cond={:?}, thn={}, dest={})\",\n-           bcx.to_str(), if_id, cond, thn.id,\n-           dest.to_string(bcx.ccx()));\n+    debug!(\"trans_if(bcx={}, if_id={}, cond={:?}, thn={}, dest={:?})\",\n+           bcx.to_str(), if_id, cond, thn.id, dest);\n     let _icx = push_ctxt(\"trans_if\");\n \n     if bcx.unreachable.get() {\n@@ -363,14 +362,12 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n-    let dest = match (fcx.llretslotptr.get(), retval_expr) {\n-        (Some(_), Some(retval_expr)) => {\n-            let ret_ty = expr_ty_adjusted(bcx, &retval_expr);\n-            expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(ret_ty), \"ret_slot\"))\n-        }\n-        _ => expr::Ignore,\n-    };\n     if let Some(x) = retval_expr {\n+        let dest = if fcx.llretslotptr.get().is_some() {\n+            expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\"))\n+        } else {\n+            expr::Ignore\n+        };\n         bcx = expr::trans_into(bcx, &x, dest);\n         match dest {\n             expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n@@ -406,13 +403,8 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let expr_file_line = consts::addr_of(ccx, expr_file_line_const, align, \"panic_loc\");\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n-    let bcx = callee::trans_lang_call(bcx,\n-                                      did,\n-                                      &args[..],\n-                                      Some(expr::Ignore),\n-                                      call_info.debug_loc()).bcx;\n-    Unreachable(bcx);\n-    return bcx;\n+    Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n+        .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }\n \n pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -439,11 +431,6 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let file_line = consts::addr_of(ccx, file_line_const, align, \"panic_bounds_check_loc\");\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n-    let bcx = callee::trans_lang_call(bcx,\n-                                      did,\n-                                      &args[..],\n-                                      Some(expr::Ignore),\n-                                      call_info.debug_loc()).bcx;\n-    Unreachable(bcx);\n-    return bcx;\n+    Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n+        .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }"}, {"sha": "649f6180de20b01a794ed007f746aa17558e6420", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -101,6 +101,7 @@ use trans::cleanup;\n use trans::cleanup::{CleanupMethods, DropHintDatum, DropHintMethods};\n use trans::expr;\n use trans::tvec;\n+use trans::value::Value;\n use middle::ty::Ty;\n \n use std::fmt;\n@@ -111,7 +112,7 @@ use syntax::codemap::DUMMY_SP;\n /// describes where the value is stored, what Rust type the value has,\n /// whether it is addressed by reference, and so forth. Please refer\n /// the section on datums in `README.md` for more details.\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy)]\n pub struct Datum<'tcx, K> {\n     /// The llvm value.  This is either a pointer to the Rust value or\n     /// the value itself, depending on `kind` below.\n@@ -124,6 +125,13 @@ pub struct Datum<'tcx, K> {\n     pub kind: K,\n }\n \n+impl<'tcx, K: fmt::Debug> fmt::Debug for Datum<'tcx, K> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Datum({:?}, {:?}, {:?})\",\n+               Value(self.val), self.ty, self.kind)\n+    }\n+}\n+\n pub struct DatumBlock<'blk, 'tcx: 'blk, K> {\n     pub bcx: Block<'blk, 'tcx>,\n     pub datum: Datum<'tcx, K>,\n@@ -298,24 +306,23 @@ pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// caller can prove that either (1.) the code injected by `populate`\n /// onto `bcx` always dominates the end of `scope`, or (2.) the data\n /// being allocated has no associated destructor.\n-pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n-                                              ty: Ty<'tcx>,\n-                                              name: &str,\n-                                              zero: InitAlloca,\n-                                              scope: cleanup::ScopeId,\n-                                              arg: A,\n-                                              populate: F)\n-                                              -> DatumBlock<'blk, 'tcx, Lvalue> where\n-    F: FnOnce(A, Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n+pub fn lvalue_scratch_datum<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                           ty: Ty<'tcx>,\n+                                           name: &str,\n+                                           zero: InitAlloca,\n+                                           scope: cleanup::ScopeId,\n+                                           populate: F)\n+                                           -> DatumBlock<'blk, 'tcx, Lvalue> where\n+    F: FnOnce(Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n {\n     // Very subtle: potentially initialize the scratch memory at point where it is alloca'ed.\n     // (See discussion at Issue 30530.)\n     let scratch = alloc_ty_init(bcx, ty, zero, name);\n-    debug!(\"lvalue_scratch_datum scope={:?} scratch={} ty={:?}\",\n-           scope, bcx.ccx().tn().val_to_string(scratch), ty);\n+    debug!(\"lvalue_scratch_datum scope={:?} scratch={:?} ty={:?}\",\n+           scope, Value(scratch), ty);\n \n     // Subtle. Populate the scratch memory *before* scheduling cleanup.\n-    let bcx = populate(arg, bcx, scratch);\n+    let bcx = populate(bcx, scratch);\n     bcx.fcx.schedule_drop_mem(scope, scratch, ty, None);\n \n     DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue::new(\"datum::lvalue_scratch_datum\")))\n@@ -351,8 +358,8 @@ fn add_rvalue_clean<'a, 'tcx>(mode: RvalueMode,\n                               scope: cleanup::ScopeId,\n                               val: ValueRef,\n                               ty: Ty<'tcx>) {\n-    debug!(\"add_rvalue_clean scope={:?} val={} ty={:?}\",\n-           scope, fcx.ccx.tn().val_to_string(val), ty);\n+    debug!(\"add_rvalue_clean scope={:?} val={:?} ty={:?}\",\n+           scope, Value(val), ty);\n     match mode {\n         ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n         ByRef => {\n@@ -509,14 +516,14 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n \n             ByValue => {\n                 lvalue_scratch_datum(\n-                    bcx, self.ty, name, InitAlloca::Dropped, scope, self,\n-                    |this, bcx, llval| {\n+                    bcx, self.ty, name, InitAlloca::Dropped, scope,\n+                    |bcx, llval| {\n                         debug!(\"populate call for Datum::to_lvalue_datum_in_scope \\\n-                                self.ty={:?}\", this.ty);\n+                                self.ty={:?}\", self.ty);\n                         // do not call_lifetime_start here; the\n                         // `InitAlloc::Dropped` will start scratch\n                         // value's lifetime at open of function body.\n-                        let bcx = this.store_to(bcx, llval);\n+                        let bcx = self.store_to(bcx, llval);\n                         bcx.fcx.schedule_lifetime_end(scope, llval);\n                         bcx\n                     })\n@@ -617,7 +624,7 @@ impl<'tcx> Datum<'tcx, Expr> {\n                                  name: &str,\n                                  expr_id: ast::NodeId)\n                                  -> DatumBlock<'blk, 'tcx, Lvalue> {\n-        debug!(\"to_lvalue_datum self: {}\", self.to_string(bcx.ccx()));\n+        debug!(\"to_lvalue_datum self: {:?}\", self);\n \n         self.match_kind(\n             |l| DatumBlock::new(bcx, l),\n@@ -767,14 +774,6 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n         self.shallow_copy_raw(bcx, dst)\n     }\n \n-    #[allow(dead_code)] // useful for debugging\n-    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"Datum({}, {:?}, {:?})\",\n-                ccx.tn().val_to_string(self.val),\n-                self.ty,\n-                self.kind)\n-    }\n-\n     /// See the `appropriate_rvalue_mode()` function\n     pub fn appropriate_rvalue_mode<'a>(&self, ccx: &CrateContext<'a, 'tcx>)\n                                        -> RvalueMode {"}, {"sha": "41fed12e7bf3cc7bd847434ab206041f5875c5fe", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -468,16 +468,13 @@ fn walk_expr(cx: &CrateContext,\n             }\n         }\n \n-        hir::ExprInlineAsm(hir::InlineAsm { ref inputs,\n-                                            ref outputs,\n-                                            .. }) => {\n-            // inputs, outputs: Vec<(String, P<Expr>)>\n-            for &(_, ref exp) in inputs {\n-                walk_expr(cx, &exp, scope_stack, scope_map);\n+        hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n+            for output in outputs {\n+                walk_expr(cx, output, scope_stack, scope_map);\n             }\n \n-            for out in outputs {\n-                walk_expr(cx, &out.expr, scope_stack, scope_map);\n+            for input in inputs {\n+                walk_expr(cx, input, scope_stack, scope_map);\n             }\n         }\n     }"}, {"sha": "40eb29ed250506d7ef4351603ba3e5acb164ad08", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -32,9 +32,10 @@ use middle::subst::{self, Substs};\n use rustc_front;\n use rustc_front::hir;\n \n+use trans::abi::Abi;\n use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n use trans;\n-use trans::{monomorphize, type_of};\n+use trans::monomorphize;\n use middle::infer;\n use middle::ty::{self, Ty};\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n@@ -49,7 +50,6 @@ use std::rc::Rc;\n \n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n-use syntax::abi::Abi;\n use syntax::attr::IntType;\n use syntax::parse::token::{self, special_idents};\n \n@@ -456,17 +456,25 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ty::FnDiverging => diverging_type_metadata(cx)\n         });\n \n-        let inputs = &if abi == Abi::RustCall {\n-            type_of::untuple_arguments(cx, &sig.inputs)\n+        let inputs = if abi == Abi::RustCall {\n+            &sig.inputs[..sig.inputs.len()-1]\n         } else {\n-            sig.inputs\n+            &sig.inputs[..]\n         };\n \n         // Arguments types\n         for &argument_type in inputs {\n             signature.push(type_metadata(cx, argument_type, codemap::DUMMY_SP));\n         }\n \n+        if abi == Abi::RustCall && !sig.inputs.is_empty() {\n+            if let ty::TyTuple(ref args) = sig.inputs[sig.inputs.len() - 1].sty {\n+                for &argument_type in args {\n+                    signature.push(type_metadata(cx, argument_type, codemap::DUMMY_SP));\n+                }\n+            }\n+        }\n+\n         return create_DIArray(DIB(cx), &signature[..]);\n     }\n "}, {"sha": "b71b7789affe2f87575160b5f61aa1372f87bc3b", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -107,7 +107,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 output.push_str(\"unsafe \");\n             }\n \n-            if abi != ::syntax::abi::Abi::Rust {\n+            if abi != ::trans::abi::Abi::Rust {\n                 output.push_str(\"extern \\\"\");\n                 output.push_str(abi.name());\n                 output.push_str(\"\\\" \");"}, {"sha": "e63f17770bcecc3c2f1c94a0797faca457b263f9", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 29, "deletions": 117, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -22,13 +22,10 @@\n use llvm::{self, ValueRef};\n use middle::ty;\n use middle::infer;\n-use middle::traits::ProjectionMode;\n-use syntax::abi::Abi;\n+use trans::abi::{Abi, FnType};\n use trans::attributes;\n-use trans::base;\n use trans::context::CrateContext;\n use trans::type_::Type;\n-use trans::type_of;\n \n use std::ffi::CString;\n use libc::c_uint;\n@@ -51,13 +48,10 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n \n /// Declare a function.\n ///\n-/// For rust functions use `declare_rust_fn` instead.\n-///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv,\n-                  ty: Type, output: ty::FnOutput) -> ValueRef {\n-    debug!(\"declare_fn(name={:?})\", name);\n+fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n+    debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n     });\n@@ -70,10 +64,6 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv,\n     // be merged.\n     llvm::SetUnnamedAddr(llfn, true);\n \n-    if output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n-    }\n-\n     if ccx.tcx().sess.opts.cg.no_redzone\n         .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n         llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZone)\n@@ -86,67 +76,40 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv,\n /// Declare a C ABI function.\n ///\n /// Only use this for foreign function ABIs and glue. For Rust functions use\n-/// `declare_rust_fn` instead.\n+/// `declare_fn` instead.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n-                   output: ty::Ty) -> ValueRef {\n-    declare_fn(ccx, name, llvm::CCallConv, fn_type, ty::FnConverging(output))\n+pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n+    declare_raw_fn(ccx, name, llvm::CCallConv, fn_type)\n }\n \n \n /// Declare a Rust function.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n-                                 fn_type: ty::Ty<'tcx>) -> ValueRef {\n-    debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name,\n-           fn_type);\n-\n-    let function_type; // placeholder so that the memory ownership works out ok\n-    let (sig, abi, env) = match fn_type.sty {\n-        ty::TyFnDef(_, _, f) |\n-        ty::TyFnPtr(f) => {\n-            (&f.sig, f.abi, None)\n-        }\n-        ty::TyClosure(closure_did, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(),\n-                                                      &ccx.tcx().tables,\n-                                                      ProjectionMode::Any);\n-            function_type = infcx.closure_type(closure_did, substs);\n-            let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n-            let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);\n-            debug!(\"declare_rust_fn function_type={:?} self_type={:?}\",\n-                   function_type, self_type);\n-            (&function_type.sig, Abi::RustCall, Some(llenvironment_type))\n-        }\n-        _ => ccx.sess().bug(\"expected closure or fn\")\n-    };\n-\n-    let sig = ccx.tcx().erase_late_bound_regions(sig);\n+pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                            fn_type: ty::Ty<'tcx>) -> ValueRef {\n+    debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n+    let abi = fn_type.fn_abi();\n+    let sig = ccx.tcx().erase_late_bound_regions(fn_type.fn_sig());\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n-    let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n-    debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));\n \n-    // it is ok to directly access sig.0.output because we erased all\n-    // late-bound-regions above\n-    let llfn = declare_fn(ccx, name, llvm::CCallConv, llfty, sig.output);\n-    attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n-    llfn\n-}\n+    let fty = FnType::new(ccx, abi, &sig, &[]);\n+    let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n \n+    if sig.output == ty::FnDiverging {\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n+    }\n+\n+    if abi != Abi::Rust && abi != Abi::RustCall {\n+        attributes::unwind(llfn, false);\n+    }\n+\n+    fty.apply_attrs_llfn(llfn);\n \n-/// Declare a Rust function with internal linkage.\n-///\n-/// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing ValueRef instead.\n-pub fn declare_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n-                                          fn_type: ty::Ty<'tcx>) -> ValueRef {\n-    let llfn = declare_rust_fn(ccx, name, fn_type);\n-    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n     llfn\n }\n \n@@ -166,78 +129,27 @@ pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRe\n }\n \n \n-/// Declare a function with an intention to define it.\n-///\n-/// For rust functions use `define_rust_fn` instead.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return None if the name already has a definition associated with it. In that\n-/// case an error should be reported to the user, because it usually happens due\n-/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv,\n-                 fn_type: Type, output: ty::FnOutput) -> Option<ValueRef> {\n-    if get_defined_value(ccx, name).is_some() {\n-        None\n-    } else {\n-        Some(declare_fn(ccx, name, callconv, fn_type, output))\n-    }\n-}\n-\n-\n-/// Declare a C ABI function with an intention to define it.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return None if the name already has a definition associated with it. In that\n-/// case an error should be reported to the user, because it usually happens due\n-/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-///\n-/// Only use this for foreign function ABIs and glue. For Rust functions use\n-/// `declare_rust_fn` instead.\n-pub fn define_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n-                  output: ty::Ty) -> Option<ValueRef> {\n-    if get_defined_value(ccx, name).is_some() {\n-        None\n-    } else {\n-        Some(declare_cfn(ccx, name, fn_type, output))\n-    }\n-}\n-\n-\n-/// Declare a Rust function with an intention to define it.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return None if the name already has a definition associated with it. In that\n-/// case an error should be reported to the user, because it usually happens due\n-/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n-                                fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n-    if get_defined_value(ccx, name).is_some() {\n-        None\n-    } else {\n-        Some(declare_rust_fn(ccx, name, fn_type))\n-    }\n-}\n-\n-\n /// Declare a Rust function with an intention to define it.\n ///\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                         name: &str,\n-                                         fn_type: ty::Ty<'tcx>) -> ValueRef {\n+pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    name: &str,\n+                                    fn_type: ty::Ty<'tcx>) -> ValueRef {\n     if get_defined_value(ccx, name).is_some() {\n         ccx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n     } else {\n-        declare_internal_rust_fn(ccx, name, fn_type)\n+        let llfn = declare_fn(ccx, name, fn_type);\n+        llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+        llfn\n     }\n }\n \n \n /// Get defined or externally defined (AvailableExternally linkage) value by\n /// name.\n-fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+pub fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     debug!(\"get_defined_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))"}, {"sha": "abcd703f33ba39f626de0e780e328c899e5dc96b", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 74, "deletions": 102, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -44,19 +44,18 @@\n //!   expression and ensures that the result has a cleanup associated with it,\n //!   creating a temporary stack slot if necessary.\n //!\n-//! - `trans_local_var -> Datum`: looks up a local variable or upvar.\n+//! - `trans_var -> Datum`: looks up a local variable, upvar or static.\n \n #![allow(non_camel_case_types)]\n \n pub use self::Dest::*;\n use self::lazy_binop_ty::*;\n \n-use back::abi;\n use llvm::{self, ValueRef, TypeKind};\n use middle::const_qualif::ConstQualif;\n use middle::def::Def;\n use middle::subst::Substs;\n-use trans::{_match, adt, asm, base, closure, consts, controlflow};\n+use trans::{_match, abi, adt, asm, base, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n use trans::callee::{Callee, ArgExprs, ArgOverloadedCall, ArgOverloadedOp};\n@@ -69,6 +68,7 @@ use trans::glue;\n use trans::machine;\n use trans::tvec;\n use trans::type_of;\n+use trans::value::Value;\n use trans::Disr;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n@@ -85,6 +85,7 @@ use rustc_front::hir;\n \n use syntax::{ast, codemap};\n use syntax::parse::token::InternedString;\n+use std::fmt;\n use std::mem;\n \n // Destinations\n@@ -98,11 +99,11 @@ pub enum Dest {\n     Ignore,\n }\n \n-impl Dest {\n-    pub fn to_string(&self, ccx: &CrateContext) -> String {\n+impl fmt::Debug for Dest {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            SaveIn(v) => format!(\"SaveIn({})\", ccx.tn().val_to_string(v)),\n-            Ignore => \"Ignore\".to_string()\n+            SaveIn(v) => write!(f, \"SaveIn({:?})\", Value(v)),\n+            Ignore => f.write_str(\"Ignore\")\n         }\n     }\n }\n@@ -377,15 +378,13 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         Some(adj) => { adj }\n     };\n-    debug!(\"unadjusted datum for expr {:?}: {} adjustment={:?}\",\n-           expr,\n-           datum.to_string(bcx.ccx()),\n-           adjustment);\n+    debug!(\"unadjusted datum for expr {:?}: {:?} adjustment={:?}\",\n+           expr, datum, adjustment);\n     match adjustment {\n         AdjustReifyFnPointer => {\n             match datum.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n-                    datum = Callee::def(bcx.ccx(), def_id, substs, datum.ty)\n+                    datum = Callee::def(bcx.ccx(), def_id, substs)\n                         .reify(bcx.ccx()).to_expr_datum();\n                 }\n                 _ => {\n@@ -452,7 +451,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n     }\n-    debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n+    debug!(\"after adjustments, datum={:?}\", datum);\n     DatumBlock::new(bcx, datum)\n }\n \n@@ -462,9 +461,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               target: Datum<'tcx, Rvalue>)\n                               -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;\n-    debug!(\"coerce_unsized({} -> {})\",\n-           source.to_string(bcx.ccx()),\n-           target.to_string(bcx.ccx()));\n+    debug!(\"coerce_unsized({:?} -> {:?})\", source, target);\n \n     match (&source.ty.sty, &target.ty.sty) {\n         (&ty::TyBox(a), &ty::TyBox(b)) |\n@@ -654,7 +651,8 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans(bcx, &e)\n         }\n         hir::ExprPath(..) => {\n-            trans_def(bcx, expr, bcx.def(expr.id))\n+            let var = trans_var(bcx, bcx.def(expr.id));\n+            DatumBlock::new(bcx, var.to_expr_datum())\n         }\n         hir::ExprField(ref base, name) => {\n             trans_rec_field(bcx, &base, name.node)\n@@ -854,8 +852,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let (base, len) = base_datum.get_vec_base_and_len(bcx);\n \n-            debug!(\"trans_index: base {}\", bcx.val_to_string(base));\n-            debug!(\"trans_index: len {}\", bcx.val_to_string(len));\n+            debug!(\"trans_index: base {:?}\", Value(base));\n+            debug!(\"trans_index: len {:?}\", Value(len));\n \n             let bounds_check = ICmp(bcx,\n                                     llvm::IntUGE,\n@@ -866,7 +864,6 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let expected = Call(bcx,\n                                 expect,\n                                 &[bounds_check, C_bool(ccx, false)],\n-                                None,\n                                 index_expr_debug_loc);\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n@@ -884,27 +881,40 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     DatumBlock::new(bcx, elt_datum)\n }\n \n-fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                         ref_expr: &hir::Expr,\n-                         def: Def)\n-                         -> DatumBlock<'blk, 'tcx, Expr> {\n-    //! Translates a reference to a path.\n+/// Translates a reference to a variable.\n+pub fn trans_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, def: Def)\n+                             -> Datum<'tcx, Lvalue> {\n \n-    let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        Def::Static(did, _) => {\n-            let const_ty = expr_ty(bcx, ref_expr);\n-            let val = get_static_val(bcx.ccx(), did, const_ty);\n-            let lval = Lvalue::new(\"expr::trans_def\");\n-            DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr(lval)))\n-        }\n-        Def::Local(..) | Def::Upvar(..) => {\n-            DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n+        Def::Static(did, _) => consts::get_static(bcx.ccx(), did),\n+        Def::Upvar(_, nid, _, _) => {\n+            // Can't move upvars, so this is never a ZeroMemLastUse.\n+            let local_ty = node_id_type(bcx, nid);\n+            let lval = Lvalue::new_with_hint(\"expr::trans_var (upvar)\",\n+                                             bcx, nid, HintKind::ZeroAndMaintain);\n+            match bcx.fcx.llupvars.borrow().get(&nid) {\n+                Some(&val) => Datum::new(val, local_ty, lval),\n+                None => {\n+                    bcx.sess().bug(&format!(\n+                        \"trans_var: no llval for upvar {} found\",\n+                        nid));\n+                }\n+            }\n         }\n-        _ => {\n-            bcx.sess().span_bug(ref_expr.span,\n-                &format!(\"{:?} should not reach expr::trans_def\", def))\n+        Def::Local(_, nid) => {\n+            let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n+                Some(&v) => v,\n+                None => {\n+                    bcx.sess().bug(&format!(\n+                        \"trans_var: no datum for local/arg {} found\",\n+                        nid));\n+                }\n+            };\n+            debug!(\"take_local(nid={}, v={:?}, ty={})\",\n+                   nid, Value(datum.val), datum.ty);\n+            datum\n         }\n+        _ => unreachable!(\"{:?} should not reach expr::trans_var\", def)\n     }\n }\n \n@@ -1027,8 +1037,18 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_assign_op(bcx, expr, op, &dst, &src)\n             }\n         }\n-        hir::ExprInlineAsm(ref a) => {\n-            asm::trans_inline_asm(bcx, a)\n+        hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n+            let outputs = outputs.iter().map(|output| {\n+                let out_datum = unpack_datum!(bcx, trans(bcx, output));\n+                unpack_datum!(bcx, out_datum.to_lvalue_datum(bcx, \"out\", expr.id))\n+            }).collect();\n+            let inputs = inputs.iter().map(|input| {\n+                let input = unpack_datum!(bcx, trans(bcx, input));\n+                let input = unpack_datum!(bcx, input.to_rvalue_datum(bcx, \"in\"));\n+                input.to_llscalarish(bcx)\n+            }).collect();\n+            asm::trans_inline_asm(bcx, a, outputs, inputs);\n+            bcx\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -1131,8 +1151,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         body,\n                                         expr.id,\n                                         def_id,\n-                                        substs,\n-                                        &expr.attrs).unwrap_or(bcx)\n+                                        substs).unwrap_or(bcx)\n         }\n         hir::ExprCall(ref f, ref args) => {\n             let method = bcx.tcx().tables.borrow().method_map.get(&method_call).cloned();\n@@ -1145,7 +1164,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let f = unpack_datum!(bcx, trans(bcx, f));\n                 (match f.ty.sty {\n                     ty::TyFnDef(def_id, substs, _) => {\n-                        Callee::def(bcx.ccx(), def_id, substs, f.ty)\n+                        Callee::def(bcx.ccx(), def_id, substs)\n                     }\n                     ty::TyFnPtr(_) => {\n                         let f = unpack_datum!(bcx,\n@@ -1249,48 +1268,6 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-/// Translates a reference to a local variable or argument. This always results in an lvalue datum.\n-pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   def: Def)\n-                                   -> Datum<'tcx, Lvalue> {\n-    let _icx = push_ctxt(\"trans_local_var\");\n-\n-    match def {\n-        Def::Upvar(_, nid, _, _) => {\n-            // Can't move upvars, so this is never a ZeroMemLastUse.\n-            let local_ty = node_id_type(bcx, nid);\n-            let lval = Lvalue::new_with_hint(\"expr::trans_local_var (upvar)\",\n-                                             bcx, nid, HintKind::ZeroAndMaintain);\n-            match bcx.fcx.llupvars.borrow().get(&nid) {\n-                Some(&val) => Datum::new(val, local_ty, lval),\n-                None => {\n-                    bcx.sess().bug(&format!(\n-                        \"trans_local_var: no llval for upvar {} found\",\n-                        nid));\n-                }\n-            }\n-        }\n-        Def::Local(_, nid) => {\n-            let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n-                Some(&v) => v,\n-                None => {\n-                    bcx.sess().bug(&format!(\n-                        \"trans_local_var: no datum for local/arg {} found\",\n-                        nid));\n-                }\n-            };\n-            debug!(\"take_local(nid={}, v={}, ty={})\",\n-                   nid, bcx.val_to_string(datum.val), datum.ty);\n-            datum\n-        }\n-        _ => {\n-            bcx.sess().unimpl(&format!(\n-                \"unsupported def type in trans_local_var: {:?}\",\n-                def));\n-        }\n-    }\n-}\n-\n fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             fields: &[hir::Field],\n                             base: Option<&hir::Expr>,\n@@ -1708,15 +1685,14 @@ fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if use_fmod {\n                 let f64t = Type::f64(bcx.ccx());\n                 let fty = Type::func(&[f64t, f64t], &f64t);\n-                let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n-                                                tcx.types.f64);\n+                let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty);\n                 if lhs_t == tcx.types.f32 {\n                     let lhs = FPExt(bcx, lhs, f64t);\n                     let rhs = FPExt(bcx, rhs, f64t);\n-                    let res = Call(bcx, llfn, &[lhs, rhs], None, binop_debug_loc);\n+                    let res = Call(bcx, llfn, &[lhs, rhs], binop_debug_loc);\n                     FPTrunc(bcx, res, Type::f32(bcx.ccx()))\n                 } else {\n-                    Call(bcx, llfn, &[lhs, rhs], None, binop_debug_loc)\n+                    Call(bcx, llfn, &[lhs, rhs], binop_debug_loc)\n                 }\n             } else {\n                 FRem(bcx, lhs, rhs, binop_debug_loc)\n@@ -1829,12 +1805,10 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let lhs = unpack_datum!(bcx, trans(bcx, lhs));\n             let lhs = unpack_datum!(bcx, lhs.to_rvalue_datum(bcx, \"binop_lhs\"));\n-            debug!(\"trans_binary (expr {}): lhs={}\",\n-                   expr.id, lhs.to_string(ccx));\n+            debug!(\"trans_binary (expr {}): lhs={:?}\", expr.id, lhs);\n             let rhs = unpack_datum!(bcx, trans(bcx, rhs));\n             let rhs = unpack_datum!(bcx, rhs.to_rvalue_datum(bcx, \"binop_rhs\"));\n-            debug!(\"trans_binary (expr {}): rhs={}\",\n-                   expr.id, rhs.to_string(ccx));\n+            debug!(\"trans_binary (expr {}): rhs={:?}\", expr.id, rhs);\n \n             if type_is_fat_ptr(ccx.tcx(), lhs.ty) {\n                 assert!(type_is_fat_ptr(ccx.tcx(), rhs.ty),\n@@ -1933,8 +1907,8 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let t_out = node_id_type(bcx, id);\n \n     debug!(\"trans_cast({:?} as {:?})\", t_in, t_out);\n-    let mut ll_t_in = type_of::arg_type_of(ccx, t_in);\n-    let ll_t_out = type_of::arg_type_of(ccx, t_out);\n+    let mut ll_t_in = type_of::immediate_type_of(ccx, t_in);\n+    let ll_t_out = type_of::immediate_type_of(ccx, t_out);\n     // Convert the value to be cast into a ValueRef, either by-ref or\n     // by-value as appropriate given its type:\n     let mut datum = unpack_datum!(bcx, trans(bcx, expr));\n@@ -2085,10 +2059,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n \n-    debug!(\"deref_once(expr={:?}, datum={}, method_call={:?})\",\n-           expr,\n-           datum.to_string(ccx),\n-           method_call);\n+    debug!(\"deref_once(expr={:?}, datum={:?}, method_call={:?})\",\n+           expr, datum, method_call);\n \n     let mut bcx = bcx;\n \n@@ -2175,8 +2147,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    debug!(\"deref_once(expr={}, method_call={:?}, result={})\",\n-           expr.id, method_call, r.datum.to_string(ccx));\n+    debug!(\"deref_once(expr={}, method_call={:?}, result={:?})\",\n+           expr.id, method_call, r.datum);\n \n     return r;\n }\n@@ -2291,7 +2263,7 @@ impl OverflowOpViaIntrinsic {\n                                         -> (Block<'blk, 'tcx>, ValueRef) {\n         let llfn = self.to_intrinsic(bcx, lhs_t);\n \n-        let val = Call(bcx, llfn, &[lhs, rhs], None, binop_debug_loc);\n+        let val = Call(bcx, llfn, &[lhs, rhs], binop_debug_loc);\n         let result = ExtractValue(bcx, val, 0); // iN operation result\n         let overflow = ExtractValue(bcx, val, 1); // i1 \"did it overflow?\"\n \n@@ -2300,7 +2272,7 @@ impl OverflowOpViaIntrinsic {\n \n         let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n         Call(bcx, expect, &[cond, C_integral(Type::i1(bcx.ccx()), 0, false)],\n-             None, binop_debug_loc);\n+             binop_debug_loc);\n \n         let bcx =\n             base::with_cond(bcx, cond, |bcx|"}, {"sha": "cace98a230f61a00c406b13c3e4f94d989abd597", "filename": "src/librustc_trans/trans/foreign.rs", "status": "removed", "additions": 0, "deletions": 1072, "changes": 1072, "blob_url": "https://github.com/rust-lang/rust/blob/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=2de6ddd75e202acdedfcd05b51a863dcc10459ca", "patch": "@@ -1,1072 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use back::{abi, link};\n-use llvm::{ValueRef, CallConv, get_param};\n-use llvm;\n-use middle::weak_lang_items;\n-use trans::attributes;\n-use trans::base::{llvm_linkage_by_name, push_ctxt};\n-use trans::base;\n-use trans::build::*;\n-use trans::cabi;\n-use trans::common::*;\n-use trans::debuginfo::DebugLoc;\n-use trans::declare;\n-use trans::expr;\n-use trans::machine;\n-use trans::monomorphize;\n-use trans::type_::Type;\n-use trans::type_of::*;\n-use trans::type_of;\n-use middle::infer;\n-use middle::ty::{self, Ty, TyCtxt};\n-use middle::subst::Substs;\n-\n-use std::cmp;\n-use std::iter::once;\n-use libc::c_uint;\n-use syntax::abi::Abi;\n-use syntax::attr;\n-use syntax::codemap::Span;\n-use syntax::parse::token::{InternedString, special_idents};\n-use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n-\n-use rustc_front::print::pprust;\n-use rustc_front::hir;\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Type definitions\n-\n-struct ForeignTypes<'tcx> {\n-    /// Rust signature of the function\n-    fn_sig: ty::FnSig<'tcx>,\n-\n-    /// Adapter object for handling native ABI rules (trust me, you\n-    /// don't want to know)\n-    fn_ty: cabi::FnType,\n-\n-    /// LLVM types that will appear on the foreign function\n-    llsig: LlvmSignature,\n-}\n-\n-struct LlvmSignature {\n-    // LLVM versions of the types of this function's arguments.\n-    llarg_tys: Vec<Type> ,\n-\n-    // LLVM version of the type that this function returns.  Note that\n-    // this *may not be* the declared return type of the foreign\n-    // function, because the foreign function may opt to return via an\n-    // out pointer.\n-    llret_ty: Type,\n-\n-    /// True if there is a return value (not bottom, not unit)\n-    ret_def: bool,\n-}\n-\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Calls to external functions\n-\n-pub fn llvm_calling_convention(ccx: &CrateContext,\n-                               abi: Abi) -> CallConv {\n-    use syntax::abi::Abi::*;\n-    match ccx.sess().target.target.adjust_abi(abi) {\n-        RustIntrinsic => {\n-            // Intrinsics are emitted at the call site\n-            ccx.sess().bug(\"asked to register intrinsic fn\");\n-        }\n-        PlatformIntrinsic => {\n-            // Intrinsics are emitted at the call site\n-            ccx.sess().bug(\"asked to register platform intrinsic fn\");\n-        }\n-\n-        Rust => {\n-            // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-            ccx.sess().unimpl(\"foreign functions with Rust ABI\");\n-        }\n-\n-        RustCall => {\n-            // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-            ccx.sess().unimpl(\"foreign functions with RustCall ABI\");\n-        }\n-\n-        // It's the ABI's job to select this, not us.\n-        System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n-\n-        Stdcall => llvm::X86StdcallCallConv,\n-        Fastcall => llvm::X86FastcallCallConv,\n-        Vectorcall => llvm::X86_VectorCall,\n-        C => llvm::CCallConv,\n-        Win64 => llvm::X86_64_Win64,\n-\n-        // These API constants ought to be more specific...\n-        Cdecl => llvm::CCallConv,\n-        Aapcs => llvm::CCallConv,\n-    }\n-}\n-\n-pub fn register_static(ccx: &CrateContext,\n-                       foreign_item: &hir::ForeignItem) -> ValueRef {\n-    let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n-    let llty = type_of::type_of(ccx, ty);\n-\n-    let ident = link_name(foreign_item);\n-    let c = match attr::first_attr_value_str_by_name(&foreign_item.attrs,\n-                                                     \"linkage\") {\n-        // If this is a static with a linkage specified, then we need to handle\n-        // it a little specially. The typesystem prevents things like &T and\n-        // extern \"C\" fn() from being non-null, so we can't just declare a\n-        // static and call it a day. Some linkages (like weak) will make it such\n-        // that the static actually has a null value.\n-        Some(name) => {\n-            let linkage = match llvm_linkage_by_name(&name) {\n-                Some(linkage) => linkage,\n-                None => {\n-                    ccx.sess().span_fatal(foreign_item.span,\n-                                          \"invalid linkage specified\");\n-                }\n-            };\n-            let llty2 = match ty.sty {\n-                ty::TyRawPtr(ref mt) => type_of::type_of(ccx, mt.ty),\n-                _ => {\n-                    ccx.sess().span_fatal(foreign_item.span,\n-                                          \"must have type `*T` or `*mut T`\");\n-                }\n-            };\n-            unsafe {\n-                // Declare a symbol `foo` with the desired linkage.\n-                let g1 = declare::declare_global(ccx, &ident[..], llty2);\n-                llvm::SetLinkage(g1, linkage);\n-\n-                // Declare an internal global `extern_with_linkage_foo` which\n-                // is initialized with the address of `foo`.  If `foo` is\n-                // discarded during linking (for example, if `foo` has weak\n-                // linkage and there are no definitions), then\n-                // `extern_with_linkage_foo` will instead be initialized to\n-                // zero.\n-                let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n-                real_name.push_str(&ident);\n-                let g2 = declare::define_global(ccx, &real_name[..], llty).unwrap_or_else(||{\n-                    ccx.sess().span_fatal(foreign_item.span,\n-                                          &format!(\"symbol `{}` is already defined\", ident))\n-                });\n-                llvm::SetLinkage(g2, llvm::InternalLinkage);\n-                llvm::LLVMSetInitializer(g2, g1);\n-                g2\n-            }\n-        }\n-        None => // Generate an external declaration.\n-            declare::declare_global(ccx, &ident[..], llty),\n-    };\n-\n-    // Handle thread-local external statics.\n-    for attr in foreign_item.attrs.iter() {\n-        if attr.check_name(\"thread_local\") {\n-            llvm::set_thread_local(c, true);\n-        }\n-    }\n-\n-    return c;\n-}\n-\n-// only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n-pub fn get_extern_fn(ccx: &CrateContext,\n-                     externs: &mut ExternMap,\n-                     name: &str,\n-                     cc: llvm::CallConv,\n-                     ty: Type,\n-                     output: Ty)\n-                     -> ValueRef {\n-    match externs.get(name) {\n-        Some(n) => return *n,\n-        None => {}\n-    }\n-    let f = declare::declare_fn(ccx, name, cc, ty, ty::FnConverging(output));\n-    externs.insert(name.to_string(), f);\n-    f\n-}\n-\n-/// Registers a foreign function found in a library. Just adds a LLVM global.\n-pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                          abi: Abi, fty: Ty<'tcx>,\n-                                          name: &str,\n-                                          attrs: &[ast::Attribute])-> ValueRef {\n-    debug!(\"register_foreign_item_fn(abi={:?}, \\\n-            ty={:?}, \\\n-            name={})\",\n-           abi,\n-           fty,\n-           name);\n-\n-    let cc = llvm_calling_convention(ccx, abi);\n-\n-    // Register the function as a C extern fn\n-    let tys = foreign_types_for_fn_ty(ccx, fty);\n-\n-    // Make sure the calling convention is right for variadic functions\n-    // (should've been caught if not in typeck)\n-    if tys.fn_sig.variadic {\n-        assert!(cc == llvm::CCallConv);\n-    }\n-\n-    // Create the LLVM value for the C extern fn\n-    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n-\n-    let llfn = get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), name, cc, llfn_ty, fty);\n-    attributes::unwind(llfn, false);\n-    add_argument_attributes(&tys, llfn);\n-    attributes::from_fn_attrs(ccx, attrs, llfn);\n-    llfn\n-}\n-\n-/// Prepares a call to a native function. This requires adapting\n-/// from the Rust argument passing rules to the native rules.\n-///\n-/// # Parameters\n-///\n-/// - `callee_ty`: Rust type for the function we are calling\n-/// - `llfn`: the function pointer we are calling\n-/// - `llretptr`: where to store the return value of the function\n-/// - `llargs_rust`: a list of the argument values, prepared\n-///   as they would be if calling a Rust function\n-/// - `passed_arg_tys`: Rust type for the arguments. Normally we\n-///   can derive these from callee_ty but in the case of variadic\n-///   functions passed_arg_tys will include the Rust type of all\n-///   the arguments including the ones not specified in the fn's signature.\n-pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     callee_ty: Ty<'tcx>,\n-                                     llfn: ValueRef,\n-                                     llretptr: ValueRef,\n-                                     llargs_rust: &[ValueRef],\n-                                     passed_arg_tys: Vec<Ty<'tcx>>,\n-                                     call_debug_loc: DebugLoc)\n-                                     -> Block<'blk, 'tcx>\n-{\n-    let ccx = bcx.ccx();\n-\n-    debug!(\"trans_native_call(callee_ty={:?}, \\\n-            llfn={}, \\\n-            llretptr={})\",\n-           callee_ty,\n-           ccx.tn().val_to_string(llfn),\n-           ccx.tn().val_to_string(llretptr));\n-\n-    let (fn_abi, fn_sig) = match callee_ty.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) |\n-        ty::TyFnPtr(ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n-        _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n-    };\n-    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n-    let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n-    let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[..]);\n-    let fn_type = cabi::compute_abi_info(ccx,\n-                                         &llsig.llarg_tys,\n-                                         llsig.llret_ty,\n-                                         llsig.ret_def);\n-\n-    let arg_tys: &[cabi::ArgType] = &fn_type.arg_tys;\n-\n-    let mut llargs_foreign = Vec::new();\n-\n-    // If the foreign ABI expects return value by pointer, supply the\n-    // pointer that Rust gave us. Sometimes we have to bitcast\n-    // because foreign fns return slightly different (but equivalent)\n-    // views on the same type (e.g., i64 in place of {i32,i32}).\n-    if fn_type.ret_ty.is_indirect() {\n-        match fn_type.ret_ty.cast {\n-            Some(ty) => {\n-                let llcastedretptr =\n-                    BitCast(bcx, llretptr, ty.ptr_to());\n-                llargs_foreign.push(llcastedretptr);\n-            }\n-            None => {\n-                llargs_foreign.push(llretptr);\n-            }\n-        }\n-    }\n-\n-    let mut offset = 0;\n-    for (i, arg_ty) in arg_tys.iter().enumerate() {\n-        let mut llarg_rust = llargs_rust[i + offset];\n-\n-        if arg_ty.is_ignore() {\n-            continue;\n-        }\n-\n-        // Does Rust pass this argument by pointer?\n-        let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_tys[i]);\n-\n-        debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n-               i,\n-               ccx.tn().val_to_string(llarg_rust),\n-               rust_indirect,\n-               ccx.tn().type_to_string(arg_ty.ty));\n-\n-        // Ensure that we always have the Rust value indirectly,\n-        // because it makes bitcasting easier.\n-        if !rust_indirect {\n-            let scratch = base::alloc_ty(bcx, passed_arg_tys[i], \"__arg\");\n-            if type_is_fat_ptr(ccx.tcx(), passed_arg_tys[i]) {\n-                Store(bcx, llargs_rust[i + offset], expr::get_dataptr(bcx, scratch));\n-                Store(bcx, llargs_rust[i + offset + 1], expr::get_meta(bcx, scratch));\n-                offset += 1;\n-            } else {\n-                base::store_ty(bcx, llarg_rust, scratch, passed_arg_tys[i]);\n-            }\n-            llarg_rust = scratch;\n-        }\n-\n-        debug!(\"llarg_rust={} (after indirection)\",\n-               ccx.tn().val_to_string(llarg_rust));\n-\n-        // Check whether we need to do any casting\n-        match arg_ty.cast {\n-            Some(ty) => llarg_rust = BitCast(bcx, llarg_rust, ty.ptr_to()),\n-            None => ()\n-        }\n-\n-        debug!(\"llarg_rust={} (after casting)\",\n-               ccx.tn().val_to_string(llarg_rust));\n-\n-        // Finally, load the value if needed for the foreign ABI\n-        let foreign_indirect = arg_ty.is_indirect();\n-        let llarg_foreign = if foreign_indirect {\n-            llarg_rust\n-        } else {\n-            if passed_arg_tys[i].is_bool() {\n-                let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n-                Trunc(bcx, val, Type::i1(bcx.ccx()))\n-            } else {\n-                Load(bcx, llarg_rust)\n-            }\n-        };\n-\n-        debug!(\"argument {}, llarg_foreign={}\",\n-               i, ccx.tn().val_to_string(llarg_foreign));\n-\n-        // fill padding with undef value\n-        match arg_ty.pad {\n-            Some(ty) => llargs_foreign.push(C_undef(ty)),\n-            None => ()\n-        }\n-        llargs_foreign.push(llarg_foreign);\n-    }\n-\n-    let cc = llvm_calling_convention(ccx, fn_abi);\n-\n-    // A function pointer is called without the declaration available, so we have to apply\n-    // any attributes with ABI implications directly to the call instruction.\n-    let mut attrs = llvm::AttrBuilder::new();\n-\n-    // Add attributes that are always applicable, independent of the concrete foreign ABI\n-    if fn_type.ret_ty.is_indirect() {\n-        let llret_sz = machine::llsize_of_real(ccx, fn_type.ret_ty.ty);\n-\n-        // The outptr can be noalias and nocapture because it's entirely\n-        // invisible to the program. We also know it's nonnull as well\n-        // as how many bytes we can dereference\n-        attrs.arg(1, llvm::Attribute::NoAlias)\n-             .arg(1, llvm::Attribute::NoCapture)\n-             .arg(1, llvm::DereferenceableAttribute(llret_sz));\n-    };\n-\n-    // Add attributes that depend on the concrete foreign ABI\n-    let mut arg_idx = if fn_type.ret_ty.is_indirect() { 1 } else { 0 };\n-    match fn_type.ret_ty.attr {\n-        Some(attr) => { attrs.arg(arg_idx, attr); },\n-        _ => ()\n-    }\n-\n-    arg_idx += 1;\n-    for arg_ty in &fn_type.arg_tys {\n-        if arg_ty.is_ignore() {\n-            continue;\n-        }\n-        // skip padding\n-        if arg_ty.pad.is_some() { arg_idx += 1; }\n-\n-        if let Some(attr) = arg_ty.attr {\n-            attrs.arg(arg_idx, attr);\n-        }\n-\n-        arg_idx += 1;\n-    }\n-\n-    let llforeign_retval = CallWithConv(bcx,\n-                                        llfn,\n-                                        &llargs_foreign[..],\n-                                        cc,\n-                                        Some(attrs),\n-                                        call_debug_loc);\n-\n-    // If the function we just called does not use an outpointer,\n-    // store the result into the rust outpointer. Cast the outpointer\n-    // type to match because some ABIs will use a different type than\n-    // the Rust type. e.g., a {u32,u32} struct could be returned as\n-    // u64.\n-    if llsig.ret_def && !fn_type.ret_ty.is_indirect() {\n-        let llrust_ret_ty = llsig.llret_ty;\n-        let llforeign_ret_ty = match fn_type.ret_ty.cast {\n-            Some(ty) => ty,\n-            None => fn_type.ret_ty.ty\n-        };\n-\n-        debug!(\"llretptr={}\", ccx.tn().val_to_string(llretptr));\n-        debug!(\"llforeign_retval={}\", ccx.tn().val_to_string(llforeign_retval));\n-        debug!(\"llrust_ret_ty={}\", ccx.tn().type_to_string(llrust_ret_ty));\n-        debug!(\"llforeign_ret_ty={}\", ccx.tn().type_to_string(llforeign_ret_ty));\n-\n-        if llrust_ret_ty == llforeign_ret_ty {\n-            match fn_sig.output {\n-                ty::FnConverging(result_ty) => {\n-                    base::store_ty(bcx, llforeign_retval, llretptr, result_ty)\n-                }\n-                ty::FnDiverging => {}\n-            }\n-        } else {\n-            // The actual return type is a struct, but the ABI\n-            // adaptation code has cast it into some scalar type.  The\n-            // code that follows is the only reliable way I have\n-            // found to do a transform like i64 -> {i32,i32}.\n-            // Basically we dump the data onto the stack then memcpy it.\n-            //\n-            // Other approaches I tried:\n-            // - Casting rust ret pointer to the foreign type and using Store\n-            //   is (a) unsafe if size of foreign type > size of rust type and\n-            //   (b) runs afoul of strict aliasing rules, yielding invalid\n-            //   assembly under -O (specifically, the store gets removed).\n-            // - Truncating foreign type to correct integral type and then\n-            //   bitcasting to the struct type yields invalid cast errors.\n-            let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n-            base::call_lifetime_start(bcx, llscratch);\n-            Store(bcx, llforeign_retval, llscratch);\n-            let llscratch_i8 = BitCast(bcx, llscratch, Type::i8(ccx).ptr_to());\n-            let llretptr_i8 = BitCast(bcx, llretptr, Type::i8(ccx).ptr_to());\n-            let llrust_size = machine::llsize_of_store(ccx, llrust_ret_ty);\n-            let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n-            let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n-            let llalign = cmp::min(llforeign_align, llrust_align);\n-            debug!(\"llrust_size={}\", llrust_size);\n-            base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n-                              C_uint(ccx, llrust_size), llalign as u32);\n-            base::call_lifetime_end(bcx, llscratch);\n-        }\n-    }\n-\n-    return bcx;\n-}\n-\n-// feature gate SIMD types in FFI, since I (huonw) am not sure the\n-// ABIs are handled at all correctly.\n-fn gate_simd_ffi(tcx: &TyCtxt, decl: &hir::FnDecl, ty: &ty::BareFnTy) {\n-    if !tcx.sess.features.borrow().simd_ffi {\n-        let check = |ast_ty: &hir::Ty, ty: ty::Ty| {\n-            if ty.is_simd() {\n-                tcx.sess.struct_span_err(ast_ty.span,\n-                              &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n-                                        may result in invalid code\",\n-                                       pprust::ty_to_string(ast_ty)))\n-                    .fileline_help(ast_ty.span,\n-                                   \"add #![feature(simd_ffi)] to the crate attributes to enable\")\n-                    .emit();\n-            }\n-        };\n-        let sig = &ty.sig.0;\n-        for (input, ty) in decl.inputs.iter().zip(&sig.inputs) {\n-            check(&input.ty, *ty)\n-        }\n-        if let hir::Return(ref ty) = decl.output {\n-            check(&ty, sig.output.unwrap())\n-        }\n-    }\n-}\n-\n-pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &hir::ForeignMod) {\n-    let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n-    for foreign_item in &foreign_mod.items {\n-        let lname = link_name(foreign_item);\n-\n-        if let hir::ForeignItemFn(ref decl, _) = foreign_item.node {\n-            match foreign_mod.abi {\n-                Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic => {}\n-                abi => {\n-                    let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n-                    match ty.sty {\n-                        ty::TyFnDef(_, _, bft) |\n-                        ty::TyFnPtr(bft) => gate_simd_ffi(ccx.tcx(), &decl, bft),\n-                        _ => ccx.tcx().sess.span_bug(foreign_item.span,\n-                                                     \"foreign fn's sty isn't a bare_fn_ty?\")\n-                    }\n-\n-                    register_foreign_item_fn(ccx, abi, ty, &lname, &foreign_item.attrs);\n-                    // Unlike for other items, we shouldn't call\n-                    // `base::update_linkage` here.  Foreign items have\n-                    // special linkage requirements, which are handled\n-                    // inside `foreign::register_*`.\n-                }\n-            }\n-        }\n-\n-        ccx.item_symbols().borrow_mut().insert(foreign_item.id,\n-                                             lname.to_string());\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Rust functions with foreign ABIs\n-//\n-// These are normal Rust functions defined with foreign ABIs.  For\n-// now, and perhaps forever, we translate these using a \"layer of\n-// indirection\". That is, given a Rust declaration like:\n-//\n-//     extern \"C\" fn foo(i: u32) -> u32 { ... }\n-//\n-// we will generate a function like:\n-//\n-//     S foo(T i) {\n-//         S r;\n-//         foo0(&r, NULL, i);\n-//         return r;\n-//     }\n-//\n-//     #[inline_always]\n-//     void foo0(uint32_t *r, void *env, uint32_t i) { ... }\n-//\n-// Here the (internal) `foo0` function follows the Rust ABI as normal,\n-// where the `foo` function follows the C ABI. We rely on LLVM to\n-// inline the one into the other. Of course we could just generate the\n-// correct code in the first place, but this is much simpler.\n-\n-pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               t: Ty<'tcx>,\n-                                               name: &str)\n-                                               -> ValueRef {\n-    let tys = foreign_types_for_fn_ty(ccx, t);\n-    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n-    let cconv = match t.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) | ty::TyFnPtr(ref fn_ty) => {\n-            llvm_calling_convention(ccx, fn_ty.abi)\n-        }\n-        _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n-    };\n-    let llfn = declare::declare_fn(ccx, name, cconv, llfn_ty,\n-                                   ty::FnConverging(ccx.tcx().mk_nil()));\n-    add_argument_attributes(&tys, llfn);\n-    debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n-           ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n-    llfn\n-}\n-\n-pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n-                                         sp: Span,\n-                                         sym: String,\n-                                         node_id: ast::NodeId)\n-                                         -> ValueRef {\n-    let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n-\n-    let t = ccx.tcx().node_id_to_type(node_id);\n-    let cconv = match t.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) | ty::TyFnPtr(ref fn_ty) => {\n-            llvm_calling_convention(ccx, fn_ty.abi)\n-        }\n-        _ => panic!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n-    };\n-    let tys = foreign_types_for_fn_ty(ccx, t);\n-    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n-    let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n-    add_argument_attributes(&tys, llfn);\n-    debug!(\"register_rust_fn_with_foreign_abi(node_id={}, llfn_ty={}, llfn={})\",\n-           node_id, ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n-    llfn\n-}\n-\n-pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                decl: &hir::FnDecl,\n-                                                body: &hir::Block,\n-                                                attrs: &[ast::Attribute],\n-                                                llwrapfn: ValueRef,\n-                                                param_substs: &'tcx Substs<'tcx>,\n-                                                id: ast::NodeId,\n-                                                hash: Option<&str>) {\n-    let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n-\n-    let fnty = ccx.tcx().node_id_to_type(id);\n-    let mty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fnty);\n-    let tys = foreign_types_for_fn_ty(ccx, mty);\n-\n-    unsafe { // unsafe because we call LLVM operations\n-        // Build up the Rust function (`foo0` above).\n-        let llrustfn = build_rust_fn(ccx, decl, body, param_substs, attrs, id, hash);\n-\n-        // Build up the foreign wrapper (`foo` above).\n-        return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys, mty);\n-    }\n-\n-    fn build_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               decl: &hir::FnDecl,\n-                               body: &hir::Block,\n-                               param_substs: &'tcx Substs<'tcx>,\n-                               attrs: &[ast::Attribute],\n-                               id: ast::NodeId,\n-                               hash: Option<&str>)\n-                               -> ValueRef\n-    {\n-        let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n-        let tcx = ccx.tcx();\n-        let t = tcx.node_id_to_type(id);\n-        let t = monomorphize::apply_param_substs(tcx, param_substs, &t);\n-\n-        let path =\n-            tcx.map.def_path_from_id(id)\n-                   .into_iter()\n-                   .map(|e| e.data.as_interned_str())\n-                   .chain(once(special_idents::clownshoe_abi.name.as_str()));\n-        let ps = link::mangle(path, hash);\n-\n-        // Compute the type that the function would have if it were just a\n-        // normal Rust function. This will be the type of the wrappee fn.\n-        match t.sty {\n-            ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f)=> {\n-                assert!(f.abi != Abi::Rust);\n-                assert!(f.abi != Abi::RustIntrinsic);\n-                assert!(f.abi != Abi::PlatformIntrinsic);\n-            }\n-            _ => {\n-                ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {:?}, \\\n-                                        expected a bare fn ty\",\n-                                       ccx.tcx().map.path_to_string(id),\n-                                       t));\n-            }\n-        };\n-\n-        debug!(\"build_rust_fn: path={} id={} t={:?}\",\n-               ccx.tcx().map.path_to_string(id),\n-               id, t);\n-\n-        let llfn = declare::define_internal_rust_fn(ccx, &ps, t);\n-        attributes::from_fn_attrs(ccx, attrs, llfn);\n-        base::trans_fn(ccx, decl, body, llfn, param_substs, id, attrs);\n-        llfn\n-    }\n-\n-    unsafe fn build_wrap_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                      llrustfn: ValueRef,\n-                                      llwrapfn: ValueRef,\n-                                      tys: &ForeignTypes<'tcx>,\n-                                      t: Ty<'tcx>) {\n-        let _icx = push_ctxt(\n-            \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n-\n-        debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={:?})\",\n-               ccx.tn().val_to_string(llrustfn),\n-               ccx.tn().val_to_string(llwrapfn),\n-               t);\n-\n-        // Avoid all the Rust generation stuff and just generate raw\n-        // LLVM here.\n-        //\n-        // We want to generate code like this:\n-        //\n-        //     S foo(T i) {\n-        //         S r;\n-        //         foo0(&r, NULL, i);\n-        //         return r;\n-        //     }\n-\n-        if llvm::LLVMCountBasicBlocks(llwrapfn) != 0 {\n-            ccx.sess().bug(\"wrapping a function inside non-empty wrapper, most likely cause is \\\n-                           multiple functions being wrapped\");\n-        }\n-\n-        let ptr = \"the block\\0\".as_ptr();\n-        let the_block = llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llwrapfn,\n-                                                            ptr as *const _);\n-\n-        let builder = ccx.builder();\n-        builder.position_at_end(the_block);\n-\n-        // Array for the arguments we will pass to the rust function.\n-        let mut llrust_args = Vec::new();\n-        let mut next_foreign_arg_counter: c_uint = 0;\n-        let mut next_foreign_arg = |pad: bool| -> c_uint {\n-            next_foreign_arg_counter += if pad {\n-                2\n-            } else {\n-                1\n-            };\n-            next_foreign_arg_counter - 1\n-        };\n-\n-        // If there is an out pointer on the foreign function\n-        let foreign_outptr = {\n-            if tys.fn_ty.ret_ty.is_indirect() {\n-                Some(get_param(llwrapfn, next_foreign_arg(false)))\n-            } else {\n-                None\n-            }\n-        };\n-\n-        let rustfn_ty = Type::from_ref(llvm::LLVMTypeOf(llrustfn)).element_type();\n-        let mut rust_param_tys = rustfn_ty.func_params().into_iter();\n-        // Push Rust return pointer, using null if it will be unused.\n-        let rust_uses_outptr = match tys.fn_sig.output {\n-            ty::FnConverging(ret_ty) => type_of::return_uses_outptr(ccx, ret_ty),\n-            ty::FnDiverging => false\n-        };\n-        let return_alloca: Option<ValueRef>;\n-        let llrust_ret_ty = if rust_uses_outptr {\n-            rust_param_tys.next().expect(\"Missing return type!\").element_type()\n-        } else {\n-            rustfn_ty.return_type()\n-        };\n-        if rust_uses_outptr {\n-            // Rust expects to use an outpointer. If the foreign fn\n-            // also uses an outpointer, we can reuse it, but the types\n-            // may vary, so cast first to the Rust type. If the\n-            // foreign fn does NOT use an outpointer, we will have to\n-            // alloca some scratch space on the stack.\n-            match foreign_outptr {\n-                Some(llforeign_outptr) => {\n-                    debug!(\"out pointer, foreign={}\",\n-                           ccx.tn().val_to_string(llforeign_outptr));\n-                    let llrust_retptr =\n-                        builder.bitcast(llforeign_outptr, llrust_ret_ty.ptr_to());\n-                    debug!(\"out pointer, foreign={} (casted)\",\n-                           ccx.tn().val_to_string(llrust_retptr));\n-                    llrust_args.push(llrust_retptr);\n-                    return_alloca = None;\n-                }\n-\n-                None => {\n-                    let slot = builder.alloca(llrust_ret_ty, \"return_alloca\");\n-                    debug!(\"out pointer, \\\n-                            allocad={}, \\\n-                            llrust_ret_ty={}, \\\n-                            return_ty={:?}\",\n-                           ccx.tn().val_to_string(slot),\n-                           ccx.tn().type_to_string(llrust_ret_ty),\n-                           tys.fn_sig.output);\n-                    llrust_args.push(slot);\n-                    return_alloca = Some(slot);\n-                }\n-            }\n-        } else {\n-            // Rust does not expect an outpointer. If the foreign fn\n-            // does use an outpointer, then we will do a store of the\n-            // value that the Rust fn returns.\n-            return_alloca = None;\n-        };\n-\n-        // Build up the arguments to the call to the rust function.\n-        // Careful to adapt for cases where the native convention uses\n-        // a pointer and Rust does not or vice versa.\n-        for i in 0..tys.fn_sig.inputs.len() {\n-            let rust_ty = tys.fn_sig.inputs[i];\n-            let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n-            let llty = rust_param_tys.next().expect(\"Not enough parameter types!\");\n-            let llrust_ty = if rust_indirect {\n-                llty.element_type()\n-            } else {\n-                llty\n-            };\n-            let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n-            let foreign_indirect = llforeign_arg_ty.is_indirect();\n-\n-            if llforeign_arg_ty.is_ignore() {\n-                debug!(\"skipping ignored arg #{}\", i);\n-                llrust_args.push(C_undef(llrust_ty));\n-                continue;\n-            }\n-\n-            // skip padding\n-            let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n-            let mut llforeign_arg = get_param(llwrapfn, foreign_index);\n-\n-            debug!(\"llforeign_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn().val_to_string(llforeign_arg));\n-            debug!(\"rust_indirect = {}, foreign_indirect = {}\",\n-                   rust_indirect, foreign_indirect);\n-\n-            // Ensure that the foreign argument is indirect (by\n-            // pointer).  It makes adapting types easier, since we can\n-            // always just bitcast pointers.\n-            if !foreign_indirect {\n-                llforeign_arg = if rust_ty.is_bool() {\n-                    let lltemp = builder.alloca(Type::bool(ccx), \"\");\n-                    builder.store(builder.zext(llforeign_arg, Type::bool(ccx)), lltemp);\n-                    lltemp\n-                } else {\n-                    let lltemp = builder.alloca(val_ty(llforeign_arg), \"\");\n-                    builder.store(llforeign_arg, lltemp);\n-                    lltemp\n-                }\n-            }\n-\n-            // If the types in the ABI and the Rust types don't match,\n-            // bitcast the llforeign_arg pointer so it matches the types\n-            // Rust expects.\n-            if llforeign_arg_ty.cast.is_some() && !type_is_fat_ptr(ccx.tcx(), rust_ty){\n-                assert!(!foreign_indirect);\n-                llforeign_arg = builder.bitcast(llforeign_arg, llrust_ty.ptr_to());\n-            }\n-\n-            let llrust_arg = if rust_indirect || type_is_fat_ptr(ccx.tcx(), rust_ty) {\n-                llforeign_arg\n-            } else {\n-                if rust_ty.is_bool() {\n-                    let tmp = builder.load_range_assert(llforeign_arg, 0, 2, llvm::False);\n-                    builder.trunc(tmp, Type::i1(ccx))\n-                } else if type_of::type_of(ccx, rust_ty).is_aggregate() {\n-                    // We want to pass small aggregates as immediate values, but using an aggregate\n-                    // LLVM type for this leads to bad optimizations, so its arg type is an\n-                    // appropriately sized integer and we have to convert it\n-                    let tmp = builder.bitcast(llforeign_arg,\n-                                              type_of::arg_type_of(ccx, rust_ty).ptr_to());\n-                    let load = builder.load(tmp);\n-                    llvm::LLVMSetAlignment(load, type_of::align_of(ccx, rust_ty));\n-                    load\n-                } else {\n-                    builder.load(llforeign_arg)\n-                }\n-            };\n-\n-            debug!(\"llrust_arg {}{}: {}\", \"#\",\n-                   i, ccx.tn().val_to_string(llrust_arg));\n-            if type_is_fat_ptr(ccx.tcx(), rust_ty) {\n-                let next_llrust_ty = rust_param_tys.next().expect(\"Not enough parameter types!\");\n-                llrust_args.push(builder.load(builder.bitcast(builder.struct_gep(\n-                                llrust_arg, abi::FAT_PTR_ADDR), llrust_ty.ptr_to())));\n-                llrust_args.push(builder.load(builder.bitcast(builder.struct_gep(\n-                                llrust_arg, abi::FAT_PTR_EXTRA), next_llrust_ty.ptr_to())));\n-            } else {\n-                llrust_args.push(llrust_arg);\n-            }\n-        }\n-\n-        // Perform the call itself\n-        debug!(\"calling llrustfn = {}, t = {:?}\",\n-               ccx.tn().val_to_string(llrustfn), t);\n-        let attributes = attributes::from_fn_type(ccx, t);\n-        let llrust_ret_val = builder.call(llrustfn, &llrust_args,\n-                                          None, Some(attributes));\n-\n-        // Get the return value where the foreign fn expects it.\n-        let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {\n-            Some(ty) => ty,\n-            None => tys.fn_ty.ret_ty.ty\n-        };\n-        match foreign_outptr {\n-            None if !tys.llsig.ret_def => {\n-                // Function returns `()` or `bot`, which in Rust is the LLVM\n-                // type \"{}\" but in foreign ABIs is \"Void\".\n-                builder.ret_void();\n-            }\n-\n-            None if rust_uses_outptr => {\n-                // Rust uses an outpointer, but the foreign ABI does not. Load.\n-                let llrust_outptr = return_alloca.unwrap();\n-                let llforeign_outptr_casted =\n-                    builder.bitcast(llrust_outptr, llforeign_ret_ty.ptr_to());\n-                let llforeign_retval = builder.load(llforeign_outptr_casted);\n-                builder.ret(llforeign_retval);\n-            }\n-\n-            None if llforeign_ret_ty != llrust_ret_ty => {\n-                // Neither ABI uses an outpointer, but the types don't\n-                // quite match. Must cast. Probably we should try and\n-                // examine the types and use a concrete llvm cast, but\n-                // right now we just use a temp memory location and\n-                // bitcast the pointer, which is the same thing the\n-                // old wrappers used to do.\n-                let lltemp = builder.alloca(llforeign_ret_ty, \"\");\n-                let lltemp_casted = builder.bitcast(lltemp, llrust_ret_ty.ptr_to());\n-                builder.store(llrust_ret_val, lltemp_casted);\n-                let llforeign_retval = builder.load(lltemp);\n-                builder.ret(llforeign_retval);\n-            }\n-\n-            None => {\n-                // Neither ABI uses an outpointer, and the types\n-                // match. Easy peasy.\n-                builder.ret(llrust_ret_val);\n-            }\n-\n-            Some(llforeign_outptr) if !rust_uses_outptr => {\n-                // Foreign ABI requires an out pointer, but Rust doesn't.\n-                // Store Rust return value.\n-                let llforeign_outptr_casted =\n-                    builder.bitcast(llforeign_outptr, llrust_ret_ty.ptr_to());\n-                builder.store(llrust_ret_val, llforeign_outptr_casted);\n-                builder.ret_void();\n-            }\n-\n-            Some(_) => {\n-                // Both ABIs use outpointers. Easy peasy.\n-                builder.ret_void();\n-            }\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// General ABI Support\n-//\n-// This code is kind of a confused mess and needs to be reworked given\n-// the massive simplifications that have occurred.\n-\n-pub fn link_name(i: &hir::ForeignItem) -> InternedString {\n-    match attr::first_attr_value_str_by_name(&i.attrs, \"link_name\") {\n-        Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(&i.attrs) {\n-            Some(name) => name,\n-            None => i.name.as_str(),\n-        }\n-    }\n-}\n-\n-/// The ForeignSignature is the LLVM types of the arguments/return type of a function. Note that\n-/// these LLVM types are not quite the same as the LLVM types would be for a native Rust function\n-/// because foreign functions just plain ignore modes. They also don't pass aggregate values by\n-/// pointer like we do.\n-fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               fn_sig: &ty::FnSig<'tcx>,\n-                               arg_tys: &[Ty<'tcx>])\n-                               -> LlvmSignature {\n-    let llarg_tys = arg_tys.iter().map(|&arg| foreign_arg_type_of(ccx, arg)).collect();\n-    let (llret_ty, ret_def) = match fn_sig.output {\n-        ty::FnConverging(ret_ty) =>\n-            (type_of::foreign_arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n-        ty::FnDiverging =>\n-            (Type::nil(ccx), false)\n-    };\n-    LlvmSignature {\n-        llarg_tys: llarg_tys,\n-        llret_ty: llret_ty,\n-        ret_def: ret_def\n-    }\n-}\n-\n-fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n-    let fn_sig = match ty.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) | ty::TyFnPtr(ref fn_ty) => &fn_ty.sig,\n-        _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n-    };\n-    let fn_sig = ccx.tcx().erase_late_bound_regions(fn_sig);\n-    let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n-    let llsig = foreign_signature(ccx, &fn_sig, &fn_sig.inputs);\n-    let fn_ty = cabi::compute_abi_info(ccx,\n-                                       &llsig.llarg_tys,\n-                                       llsig.llret_ty,\n-                                       llsig.ret_def);\n-    debug!(\"foreign_types_for_fn_ty(\\\n-           ty={:?}, \\\n-           llsig={} -> {}, \\\n-           fn_ty={} -> {}, \\\n-           ret_def={}\",\n-           ty,\n-           ccx.tn().types_to_str(&llsig.llarg_tys),\n-           ccx.tn().type_to_string(llsig.llret_ty),\n-           ccx.tn().types_to_str(&fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()),\n-           ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n-           llsig.ret_def);\n-\n-    ForeignTypes {\n-        fn_sig: fn_sig,\n-        llsig: llsig,\n-        fn_ty: fn_ty\n-    }\n-}\n-\n-fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> Type {\n-    let mut llargument_tys = Vec::new();\n-\n-    let ret_ty = tys.fn_ty.ret_ty;\n-    let llreturn_ty = if ret_ty.is_indirect() {\n-        llargument_tys.push(ret_ty.ty.ptr_to());\n-        Type::void(ccx)\n-    } else {\n-        match ret_ty.cast {\n-            Some(ty) => ty,\n-            None => ret_ty.ty\n-        }\n-    };\n-\n-    for &arg_ty in &tys.fn_ty.arg_tys {\n-        if arg_ty.is_ignore() {\n-            continue;\n-        }\n-        // add padding\n-        match arg_ty.pad {\n-            Some(ty) => llargument_tys.push(ty),\n-            None => ()\n-        }\n-\n-        let llarg_ty = if arg_ty.is_indirect() {\n-            arg_ty.ty.ptr_to()\n-        } else {\n-            match arg_ty.cast {\n-                Some(ty) => ty,\n-                None => arg_ty.ty\n-            }\n-        };\n-\n-        llargument_tys.push(llarg_ty);\n-    }\n-\n-    if tys.fn_sig.variadic {\n-        Type::variadic_func(&llargument_tys, &llreturn_ty)\n-    } else {\n-        Type::func(&llargument_tys[..], &llreturn_ty)\n-    }\n-}\n-\n-pub fn lltype_for_foreign_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       ty: Ty<'tcx>) -> Type {\n-    lltype_for_fn_from_foreign_types(ccx, &foreign_types_for_fn_ty(ccx, ty))\n-}\n-\n-fn add_argument_attributes(tys: &ForeignTypes,\n-                           llfn: ValueRef) {\n-    let mut i = if tys.fn_ty.ret_ty.is_indirect() {\n-        1\n-    } else {\n-        0\n-    };\n-\n-    match tys.fn_ty.ret_ty.attr {\n-        Some(attr) => unsafe {\n-            llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr.bits() as u64);\n-        },\n-        None => {}\n-    }\n-\n-    i += 1;\n-\n-    for &arg_ty in &tys.fn_ty.arg_tys {\n-        if arg_ty.is_ignore() {\n-            continue;\n-        }\n-        // skip padding\n-        if arg_ty.pad.is_some() { i += 1; }\n-\n-        match arg_ty.attr {\n-            Some(attr) => unsafe {\n-                llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr.bits() as u64);\n-            },\n-            None => ()\n-        }\n-\n-        i += 1;\n-    }\n-}"}, {"sha": "4ca5fb07c98259a68237af43b58b4fda4dbc782d", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 60, "deletions": 64, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -14,18 +14,19 @@\n \n use std;\n \n-use back::link::*;\n+use back::link;\n use llvm;\n use llvm::{ValueRef, get_param};\n use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst::{Substs};\n use middle::traits;\n use middle::ty::{self, Ty, TyCtxt};\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n use trans::adt::GetDtorType; // for tcx.dtor_type()\n use trans::base::*;\n use trans::build::*;\n-use trans::callee;\n+use trans::callee::{Callee, ArgVals};\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::collector::{self, TransItem};\n@@ -37,25 +38,23 @@ use trans::machine::*;\n use trans::monomorphize;\n use trans::type_of::{type_of, sizing_type_of, align_of};\n use trans::type_::Type;\n+use trans::value::Value;\n \n use arena::TypedArena;\n-use libc::c_uint;\n-use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n \n-pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            v: ValueRef,\n                                            size: ValueRef,\n                                            align: ValueRef,\n                                            debug_loc: DebugLoc)\n                                            -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n-    let ccx = cx.ccx();\n-    callee::trans_lang_call(cx,\n-        langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n-        &[PointerCast(cx, v, Type::i8p(ccx)), size, align],\n-        Some(expr::Ignore),\n-        debug_loc).bcx\n+\n+    let def_id = langcall(bcx, None, \"\", ExchangeFreeFnLangItem);\n+    let args = [PointerCast(bcx, v, Type::i8p(bcx.ccx())), size, align];\n+    Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n+        .call(bcx, debug_loc, ArgVals(&args), None).bcx\n }\n \n pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n@@ -170,13 +169,13 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let may_need_drop =\n                     ICmp(bcx, llvm::IntNE, hint_val, moved_val, DebugLoc::None);\n                 bcx = with_cond(bcx, may_need_drop, |cx| {\n-                    Call(cx, glue, &[ptr], None, debug_loc);\n+                    Call(cx, glue, &[ptr], debug_loc);\n                     cx\n                 })\n             }\n             None => {\n                 // No drop-hint ==> call standard drop glue\n-                Call(bcx, glue, &[ptr], None, debug_loc);\n+                Call(bcx, glue, &[ptr], debug_loc);\n             }\n         }\n     }\n@@ -240,38 +239,40 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n     let t = g.ty();\n \n-    let llty = if type_is_sized(ccx.tcx(), t) {\n-        type_of(ccx, t).ptr_to()\n-    } else {\n-        type_of(ccx, ccx.tcx().mk_box(t)).ptr_to()\n+    let tcx = ccx.tcx();\n+    let sig = ty::FnSig {\n+        inputs: vec![tcx.mk_mut_ptr(tcx.types.i8)],\n+        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+        variadic: false,\n     };\n-\n-    let llfnty = Type::glue_fn(ccx, llty);\n+    // Create a FnType for fn(*mut i8) and substitute the real type in\n+    // later - that prevents FnType from splitting fat pointers up.\n+    let mut fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n+    fn_ty.args[0].original_ty = type_of(ccx, t).ptr_to();\n+    let llfnty = fn_ty.llvm_type(ccx);\n \n     // To avoid infinite recursion, don't `make_drop_glue` until after we've\n     // added the entry to the `drop_glues` cache.\n     if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&g) {\n-        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ccx.tcx().mk_nil());\n+        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty);\n         ccx.drop_glues().borrow_mut().insert(g, llfn);\n         return llfn;\n     };\n \n-    let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n-    let llfn = declare::define_cfn(ccx, &fn_nm, llfnty, ccx.tcx().mk_nil()).unwrap_or_else(||{\n-       ccx.sess().bug(&format!(\"symbol `{}` already defined\", fn_nm));\n-    });\n+    let fn_nm = link::mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n+    assert!(declare::get_defined_value(ccx, &fn_nm).is_none());\n+    let llfn = declare::declare_cfn(ccx, &fn_nm, llfnty);\n     ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n+    ccx.drop_glues().borrow_mut().insert(g, llfn);\n \n     let _s = StatRecorder::new(ccx, format!(\"drop {:?}\", t));\n \n-    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                      ty::FnConverging(ccx.tcx().mk_nil()),\n-                      empty_substs, None, &arena);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &arena);\n \n-    let bcx = init_function(&fcx, false, ty::FnConverging(ccx.tcx().mk_nil()));\n+    let bcx = fcx.init(false, None);\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n \n@@ -284,9 +285,8 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let llrawptr0 = get_param(llfn, fcx.arg_offset() as c_uint);\n-    let bcx = make_drop_glue(bcx, llrawptr0, g);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ccx.tcx().mk_nil()), DebugLoc::None);\n+    let bcx = make_drop_glue(bcx, get_param(llfn, 0), g);\n+    fcx.finish(bcx, DebugLoc::None);\n \n     llfn\n }\n@@ -314,7 +314,7 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             And(bcx, not_init, not_done, DebugLoc::None);\n         with_cond(bcx, drop_flag_neither_initialized_nor_cleared, |cx| {\n             let llfn = cx.ccx().get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(cx, llfn, &[], None, DebugLoc::None);\n+            Call(cx, llfn, &[], DebugLoc::None);\n             cx\n         })\n     };\n@@ -365,27 +365,31 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n     };\n     let dtor_did = def.destructor().unwrap();\n-    bcx = callee::Callee::ptr(callee::trans_fn_ref_with_substs(\n-            bcx.ccx(), dtor_did, None, vtbl.substs))\n-        .call(bcx, DebugLoc::None, callee::ArgVals(args), Some(expr::Ignore)).bcx;\n+    bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs)\n+        .call(bcx, DebugLoc::None, ArgVals(args), None).bcx;\n \n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n \n-pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n+pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n+                                         t: Ty<'tcx>, info: ValueRef)\n                                          -> (ValueRef, ValueRef) {\n-    debug!(\"calculate size of DST: {}; with lost info: {}\",\n-           t, bcx.val_to_string(info));\n+    debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n+           t, Value(info));\n     if type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n         let size = llsize_of_alloc(bcx.ccx(), sizing_type);\n         let align = align_of(bcx.ccx(), t);\n-        debug!(\"size_and_align_of_dst t={} info={} size: {} align: {}\",\n-               t, bcx.val_to_string(info), size, align);\n+        debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n+               t, Value(info), size, align);\n         let size = C_uint(bcx.ccx(), size);\n         let align = C_uint(bcx.ccx(), align);\n         return (size, align);\n     }\n+    if bcx.is_unreachable() {\n+        let llty = Type::int(bcx.ccx());\n+        return (C_undef(llty), C_undef(llty));\n+    }\n     match t.sty {\n         ty::TyStruct(def, substs) => {\n             let ccx = bcx.ccx();\n@@ -394,7 +398,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             assert!(!t.is_simd());\n             let repr = adt::represent_type(ccx, t);\n             let sizing_type = adt::sizing_type_context_of(ccx, &repr, true);\n-            debug!(\"DST {} sizing_type: {}\", t, sizing_type.to_string());\n+            debug!(\"DST {} sizing_type: {:?}\", t, sizing_type);\n             let sized_size = llsize_of_alloc(ccx, sizing_type.prefix());\n             let sized_align = llalign_of_min(ccx, sizing_type.prefix());\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n@@ -408,8 +412,6 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             let field_ty = monomorphize::field_ty(bcx.tcx(), substs, last_field);\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n-            let dbloc = DebugLoc::None;\n-\n             // FIXME (#26403, #27023): We should be adding padding\n             // to `sized_size` (to accommodate the `unsized_align`\n             // required of the unsized field that follows) before\n@@ -418,14 +420,14 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             // here. But this is where the add would go.)\n \n             // Return the sum of sizes and max of aligns.\n-            let mut size = Add(bcx, sized_size, unsized_size, dbloc);\n+            let mut size = bcx.add(sized_size, unsized_size);\n \n             // Issue #27023: If there is a drop flag, *now* we add 1\n             // to the size.  (We can do this without adding any\n             // padding because drop flags do not have any alignment\n             // constraints.)\n             if sizing_type.needs_drop_flag() {\n-                size = Add(bcx, size, C_uint(bcx.ccx(), 1_u64), dbloc);\n+                size = bcx.add(size, C_uint(bcx.ccx(), 1_u64));\n             }\n \n             // Choose max of two known alignments (combined value must\n@@ -436,14 +438,9 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n                     // pick the correct alignment statically.\n                     C_uint(ccx, std::cmp::max(sized_align, unsized_align))\n                 }\n-                _ => Select(bcx,\n-                            ICmp(bcx,\n-                                 llvm::IntUGT,\n-                                 sized_align,\n-                                 unsized_align,\n-                                 dbloc),\n-                            sized_align,\n-                            unsized_align)\n+                _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n+                                sized_align,\n+                                unsized_align)\n             };\n \n             // Issue #27023: must add any necessary padding to `size`\n@@ -457,19 +454,18 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = Sub(bcx, align, C_uint(bcx.ccx(), 1_u64), dbloc);\n-            let size = And(\n-                bcx, Add(bcx, size, addend, dbloc), Neg(bcx, align, dbloc), dbloc);\n+            let addend = bcx.sub(align, C_uint(bcx.ccx(), 1_u64));\n+            let size = bcx.and(bcx.add(size, addend), bcx.neg(align));\n \n             (size, align)\n         }\n         ty::TyTrait(..) => {\n             // info points to the vtable and the second entry in the vtable is the\n             // dynamic size of the object.\n-            let info = PointerCast(bcx, info, Type::int(bcx.ccx()).ptr_to());\n-            let size_ptr = GEPi(bcx, info, &[1]);\n-            let align_ptr = GEPi(bcx, info, &[2]);\n-            (Load(bcx, size_ptr), Load(bcx, align_ptr))\n+            let info = bcx.pointercast(info, Type::int(bcx.ccx()).ptr_to());\n+            let size_ptr = bcx.gepi(info, &[1]);\n+            let align_ptr = bcx.gepi(info, &[2]);\n+            (bcx.load(size_ptr), bcx.load(align_ptr))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(bcx.tcx());\n@@ -478,7 +474,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n             let unit_align = llalign_of_min(bcx.ccx(), llunit_ty);\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size), DebugLoc::None),\n+            (bcx.mul(info, C_uint(bcx.ccx(), unit_size)),\n              C_uint(bcx.ccx(), unit_align))\n         }\n         _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\", t))\n@@ -523,7 +519,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                     let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n                     let info = expr::get_meta(bcx, v0);\n                     let info = Load(bcx, info);\n-                    let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n+                    let (llsize, llalign) =\n+                        size_and_align_of_dst(&bcx.build(), content_ty, info);\n \n                     // `Box<ZeroSizeType>` does not allocate.\n                     let needs_free = ICmp(bcx,\n@@ -585,7 +582,6 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n             Call(bcx,\n                  dtor,\n                  &[PointerCast(bcx, Load(bcx, data_ptr), Type::i8p(bcx.ccx()))],\n-                 None,\n                  DebugLoc::None);\n             bcx\n         }"}, {"sha": "ad32870444a22d0804ee0125739631ce73077fd3", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 38, "deletions": 52, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -12,7 +12,8 @@ use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n use middle::cstore::{CrateStore, FoundAst, InlinedItem};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n-use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n+use trans::base::{push_ctxt, trans_item, trans_fn};\n+use trans::callee::Callee;\n use trans::common::*;\n \n use rustc::dep_graph::DepNode;\n@@ -21,14 +22,15 @@ use rustc_front::hir;\n fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n     debug!(\"instantiate_inline({:?})\", fn_id);\n     let _icx = push_ctxt(\"instantiate_inline\");\n-    let _task = ccx.tcx().dep_graph.in_task(DepNode::TransInlinedItem(fn_id));\n+    let tcx = ccx.tcx();\n+    let _task = tcx.dep_graph.in_task(DepNode::TransInlinedItem(fn_id));\n \n     match ccx.external().borrow().get(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline\n             debug!(\"instantiate_inline({}): already inline as node id {}\",\n-                   ccx.tcx().item_path_str(fn_id), node_id);\n-            let node_def_id = ccx.tcx().map.local_def_id(node_id);\n+                   tcx.item_path_str(fn_id), node_id);\n+            let node_def_id = tcx.map.local_def_id(node_id);\n             return Some(node_def_id);\n         }\n         Some(&None) => {\n@@ -39,7 +41,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n         }\n     }\n \n-    let inlined = ccx.tcx().sess.cstore.maybe_get_item_ast(ccx.tcx(), fn_id);\n+    let inlined = tcx.sess.cstore.maybe_get_item_ast(tcx, fn_id);\n     let inline_id = match inlined {\n         FoundAst::NotFound => {\n             ccx.external().borrow_mut().insert(fn_id, None);\n@@ -52,38 +54,27 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n             trans_item(ccx, item);\n \n-            let linkage = match item.node {\n-                hir::ItemFn(_, _, _, _, ref generics, _) => {\n-                    if generics.is_type_parameterized() {\n-                        // Generics have no symbol, so they can't be given any\n-                        // linkage.\n-                        None\n+            if let hir::ItemFn(_, _, _, _, ref generics, _) = item.node {\n+                // Generics have no symbol, so they can't be given any linkage.\n+                if !generics.is_type_parameterized() {\n+                    let linkage = if ccx.sess().opts.cg.codegen_units == 1 {\n+                        // We could use AvailableExternallyLinkage here,\n+                        // but InternalLinkage allows LLVM to optimize more\n+                        // aggressively (at the cost of sometimes\n+                        // duplicating code).\n+                        InternalLinkage\n                     } else {\n-                        if ccx.sess().opts.cg.codegen_units == 1 {\n-                            // We could use AvailableExternallyLinkage here,\n-                            // but InternalLinkage allows LLVM to optimize more\n-                            // aggressively (at the cost of sometimes\n-                            // duplicating code).\n-                            Some(InternalLinkage)\n-                        } else {\n-                            // With multiple compilation units, duplicated code\n-                            // is more of a problem.  Also, `codegen_units > 1`\n-                            // means the user is okay with losing some\n-                            // performance.\n-                            Some(AvailableExternallyLinkage)\n-                        }\n-                    }\n-                }\n-                hir::ItemConst(..) => None,\n-                _ => unreachable!(),\n-            };\n-\n-            match linkage {\n-                Some(linkage) => {\n-                    let g = get_item_val(ccx, item.id);\n-                    SetLinkage(g, linkage);\n+                        // With multiple compilation units, duplicated code\n+                        // is more of a problem.  Also, `codegen_units > 1`\n+                        // means the user is okay with losing some\n+                        // performance.\n+                        AvailableExternallyLinkage\n+                    };\n+                    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+                    let def_id = tcx.map.local_def_id(item.id);\n+                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n+                    SetLinkage(llfn, linkage);\n                 }\n-                None => {}\n             }\n \n             item.id\n@@ -93,15 +84,15 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             item.id\n         }\n-        FoundAst::FoundParent(parent_id, &InlinedItem::Item(ref item)) => {\n+        FoundAst::FoundParent(parent_id, item) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n             let mut my_id = 0;\n             match item.node {\n                 hir::ItemEnum(ref ast_def, _) => {\n                     let ast_vs = &ast_def.variants;\n-                    let ty_vs = &ccx.tcx().lookup_adt_def(parent_id).variants;\n+                    let ty_vs = &tcx.lookup_adt_def(parent_id).variants;\n                     assert_eq!(ast_vs.len(), ty_vs.len());\n                     for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n                         if ty_v.did == fn_id { my_id = ast_v.node.data.id(); }\n@@ -120,13 +111,8 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                 _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n             }\n-            trans_item(ccx, &item);\n             my_id\n         }\n-        FoundAst::FoundParent(_, _) => {\n-            ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\\n-                            with a non-item parent\");\n-        }\n         FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(trait_item.id));\n             ccx.external_srcs().borrow_mut().insert(trait_item.id, fn_id);\n@@ -137,10 +123,10 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             // the logic to do that already exists in `middle`. In order to\n             // reuse that code, it needs to be able to look up the traits for\n             // inlined items.\n-            let ty_trait_item = ccx.tcx().impl_or_trait_item(fn_id).clone();\n-            let trait_item_def_id = ccx.tcx().map.local_def_id(trait_item.id);\n-            ccx.tcx().impl_or_trait_items.borrow_mut()\n-                     .insert(trait_item_def_id, ty_trait_item);\n+            let ty_trait_item = tcx.impl_or_trait_item(fn_id).clone();\n+            let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n+            tcx.impl_or_trait_items.borrow_mut()\n+               .insert(trait_item_def_id, ty_trait_item);\n \n             // If this is a default method, we can't look up the\n             // impl type. But we aren't going to translate anyways, so\n@@ -155,18 +141,18 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n \n             // Translate monomorphic impl methods immediately.\n             if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n-                let impl_tpt = ccx.tcx().lookup_item_type(impl_did);\n+                let impl_tpt = tcx.lookup_item_type(impl_did);\n                 if impl_tpt.generics.types.is_empty() &&\n                         sig.generics.ty_params.is_empty() {\n-                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    let llfn = get_item_val(ccx, impl_item.id);\n+                    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+                    let def_id = tcx.map.local_def_id(impl_item.id);\n+                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n                     trans_fn(ccx,\n                              &sig.decl,\n                              body,\n                              llfn,\n                              empty_substs,\n-                             impl_item.id,\n-                             &impl_item.attrs);\n+                             impl_item.id);\n                     // See linkage comments on items.\n                     if ccx.sess().opts.cg.codegen_units == 1 {\n                         SetLinkage(llfn, InternalLinkage);\n@@ -180,7 +166,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n         }\n     };\n \n-    let inline_def_id = ccx.tcx().map.local_def_id(inline_id);\n+    let inline_def_id = tcx.map.local_def_id(inline_id);\n     Some(inline_def_id)\n }\n "}, {"sha": "43976f8233bcefa5979b7c63b363a1ae0a7d6861", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 150, "deletions": 177, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -18,6 +18,7 @@ use llvm::{ValueRef, TypeKind};\n use middle::infer;\n use middle::subst;\n use middle::subst::FnSpace;\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n@@ -40,19 +41,18 @@ use trans::Disr;\n use middle::subst::Substs;\n use rustc::dep_graph::DepNode;\n use rustc_front::hir;\n-use syntax::abi::Abi;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::parse::token;\n \n use rustc::lint;\n use rustc::session::Session;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n \n-pub fn get_simple_intrinsic(ccx: &CrateContext, item: &hir::ForeignItem) -> Option<ValueRef> {\n-    let name = match &*item.name.as_str() {\n+fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+    let llvm_name = match name {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n         \"powif32\" => \"llvm.powi.f32\",\n@@ -94,7 +94,7 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &hir::ForeignItem) -> Opti\n         \"assume\" => \"llvm.assume\",\n         _ => return None\n     };\n-    Some(ccx.get_intrinsic(&name))\n+    Some(ccx.get_intrinsic(&llvm_name))\n }\n \n pub fn span_transmute_size_error(a: &Session, b: Span, msg: &str) {\n@@ -171,28 +171,35 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_trans/trans/context.rs\n pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                            node: ast::NodeId,\n                                             callee_ty: Ty<'tcx>,\n-                                            cleanup_scope: cleanup::CustomScopeIndex,\n+                                            fn_ty: &FnType,\n                                             args: callee::CallArgs<'a, 'tcx>,\n                                             dest: expr::Dest,\n-                                            substs: &'tcx subst::Substs<'tcx>,\n-                                            call_info: NodeIdAndSpan)\n+                                            call_debug_location: DebugLoc)\n                                             -> Result<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n \n     let _icx = push_ctxt(\"trans_intrinsic_call\");\n \n-    let sig = ccx.tcx().erase_late_bound_regions(callee_ty.fn_sig());\n-    let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n+    let (def_id, substs, sig) = match callee_ty.sty {\n+        ty::TyFnDef(def_id, substs, fty) => {\n+            let sig = tcx.erase_late_bound_regions(&fty.sig);\n+            (def_id, substs, infer::normalize_associated_type(tcx, &sig))\n+        }\n+        _ => unreachable!(\"expected fn item type, found {}\", callee_ty)\n+    };\n     let arg_tys = sig.inputs;\n     let ret_ty = sig.output;\n-    let foreign_item = tcx.map.expect_foreign_item(node);\n-    let name = foreign_item.name.as_str();\n+    let name = tcx.item_name(def_id).as_str();\n+\n+    let span = match call_debug_location {\n+        DebugLoc::At(_, span) => span,\n+        DebugLoc::None => fcx.span.unwrap_or(DUMMY_SP)\n+    };\n \n-    let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n+    let cleanup_scope = fcx.push_custom_cleanup_scope();\n \n     // For `transmute` we can just trans the input expr directly into dest\n     if name == \"transmute\" {\n@@ -213,7 +220,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     if out_type_size != 0 {\n                         // FIXME #19925 Remove this hack after a release cycle.\n                         let _ = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n-                        let llfn = Callee::def(ccx, def_id, substs, in_type).reify(ccx).val;\n+                        let llfn = Callee::def(ccx, def_id, substs).reify(ccx).val;\n                         let llfnty = val_ty(llfn);\n                         let llresult = match dest {\n                             expr::SaveIn(d) => d,\n@@ -267,7 +274,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let val = if datum.kind.is_by_ref() {\n                         load_ty(bcx, datum.val, datum.ty)\n                     } else {\n-                        from_arg_ty(bcx, datum.val, datum.ty)\n+                        from_immediate(bcx, datum.val)\n                     };\n \n                     let cast_val = BitCast(bcx, val, llret_ty);\n@@ -347,43 +354,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    // For `try` we need some custom control flow\n-    if &name[..] == \"try\" {\n-        if let callee::ArgExprs(ref exprs) = args {\n-            let (func, data, local_ptr) = if exprs.len() != 3 {\n-                ccx.sess().bug(\"expected three exprs as arguments for \\\n-                                `try` intrinsic\");\n-            } else {\n-                (&exprs[0], &exprs[1], &exprs[2])\n-            };\n-\n-            // translate arguments\n-            let func = unpack_datum!(bcx, expr::trans(bcx, func));\n-            let func = unpack_datum!(bcx, func.to_rvalue_datum(bcx, \"func\"));\n-            let data = unpack_datum!(bcx, expr::trans(bcx, data));\n-            let data = unpack_datum!(bcx, data.to_rvalue_datum(bcx, \"data\"));\n-            let local_ptr = unpack_datum!(bcx, expr::trans(bcx, local_ptr));\n-            let local_ptr = local_ptr.to_rvalue_datum(bcx, \"local_ptr\");\n-            let local_ptr = unpack_datum!(bcx, local_ptr);\n-\n-            let dest = match dest {\n-                expr::SaveIn(d) => d,\n-                expr::Ignore => alloc_ty(bcx, tcx.mk_mut_ptr(tcx.types.i8),\n-                                         \"try_result\"),\n-            };\n-\n-            // do the invoke\n-            bcx = try_intrinsic(bcx, func.val, data.val, local_ptr.val, dest,\n-                                call_debug_location);\n-\n-            fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n-            return Result::new(bcx, dest);\n-        } else {\n-            ccx.sess().bug(\"expected two exprs as arguments for \\\n-                            `try` intrinsic\");\n-        }\n-    }\n-\n     // save the actual AST arguments for later (some places need to do\n     // const-evaluation on them)\n     let expr_arguments = match args {\n@@ -394,18 +364,19 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // Push the arguments.\n     let mut llargs = Vec::new();\n     bcx = callee::trans_args(bcx,\n+                             Abi::RustIntrinsic,\n+                             fn_ty,\n+                             &mut callee::Intrinsic,\n                              args,\n-                             callee_ty,\n                              &mut llargs,\n-                             cleanup::CustomScope(cleanup_scope),\n-                             Abi::RustIntrinsic);\n+                             cleanup::CustomScope(cleanup_scope));\n \n     fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n     // These are the only intrinsic functions that diverge.\n     if name == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n-        Call(bcx, llfn, &[], None, call_debug_location);\n+        Call(bcx, llfn, &[], call_debug_location);\n         fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n@@ -437,14 +408,19 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    let simple = get_simple_intrinsic(ccx, &foreign_item);\n-    let llval = match (simple, &*name) {\n+    let simple = get_simple_intrinsic(ccx, &name);\n+    let llval = match (simple, &name[..]) {\n         (Some(llfn), _) => {\n-            Call(bcx, llfn, &llargs, None, call_debug_location)\n+            Call(bcx, llfn, &llargs, call_debug_location)\n+        }\n+        (_, \"try\") => {\n+            bcx = try_intrinsic(bcx, llargs[0], llargs[1], llargs[2], llresult,\n+                                call_debug_location);\n+            C_nil(ccx)\n         }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(bcx, llfn, &[], None, call_debug_location)\n+            Call(bcx, llfn, &[], call_debug_location)\n         }\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -454,7 +430,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"size_of_val\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !type_is_sized(tcx, tp_ty) {\n-                let (llsize, _) = glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n+                let (llsize, _) =\n+                    glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n                 llsize\n             } else {\n                 let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -468,7 +445,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"min_align_of_val\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !type_is_sized(tcx, tp_ty) {\n-                let (_, llalign) = glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n+                let (_, llalign) =\n+                    glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n                 llalign\n             } else {\n                 C_uint(ccx, type_of::align_of(ccx, tp_ty))\n@@ -505,14 +483,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"init_dropped\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            if !return_type_is_void(ccx, tp_ty) {\n+            if !type_is_zero_size(ccx, tp_ty) {\n                 drop_done_fill_mem(bcx, llresult, tp_ty);\n             }\n             C_nil(ccx)\n         }\n         (_, \"init\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            if !return_type_is_void(ccx, tp_ty) {\n+            if !type_is_zero_size(ccx, tp_ty) {\n                 // Just zero out the stack slot. (See comment on base::memzero for explanation)\n                 init_zero_mem(bcx, llresult, tp_ty);\n             }\n@@ -599,21 +577,24 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"volatile_load\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+            let mut ptr = llargs[0];\n+            if let Some(ty) = fn_ty.ret.cast {\n+                ptr = PointerCast(bcx, ptr, ty.ptr_to());\n+            }\n             let load = VolatileLoad(bcx, ptr);\n             unsafe {\n                 llvm::LLVMSetAlignment(load, type_of::align_of(ccx, tp_ty));\n             }\n-            to_arg_ty(bcx, load, tp_ty)\n+            to_immediate(bcx, load, tp_ty)\n         },\n         (_, \"volatile_store\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-            let val = if type_is_immediate(bcx.ccx(), tp_ty) {\n-                from_arg_ty(bcx, llargs[1], tp_ty)\n-            } else {\n+            let val = if fn_ty.args[1].is_indirect() {\n                 Load(bcx, llargs[1])\n+            } else {\n+                from_immediate(bcx, llargs[1])\n             };\n+            let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n             let store = VolatileStore(bcx, val, ptr);\n             unsafe {\n                 llvm::LLVMSetAlignment(store, type_of::align_of(ccx, tp_ty));\n@@ -634,13 +615,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         \"cttz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.cttz.i{}\", width),\n                                                         llargs[0], call_debug_location),\n                         \"ctpop\" => Call(bcx, ccx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n-                                        &llargs, None, call_debug_location),\n+                                        &llargs, call_debug_location),\n                         \"bswap\" => {\n                             if width == 8 {\n                                 llargs[0] // byte swap a u8/i8 is just a no-op\n                             } else {\n                                 Call(bcx, ccx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n-                                        &llargs, None, call_debug_location)\n+                                        &llargs, call_debug_location)\n                             }\n                         }\n                         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n@@ -669,7 +650,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     },\n                 None => {\n                     span_invalid_monomorphization_error(\n-                        tcx.sess, call_info.span,\n+                        tcx.sess, span,\n                         &format!(\"invalid monomorphization of `{}` intrinsic: \\\n                                   expected basic integer type, found `{}`\", name, sty));\n                         C_null(llret_ty)\n@@ -680,8 +661,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n \n         (_, \"return_address\") => {\n-            if !fcx.caller_expects_out_pointer {\n-                span_err!(tcx.sess, call_info.span, E0510,\n+            if !fcx.fn_ty.ret.is_indirect() {\n+                span_err!(tcx.sess, span, E0510,\n                           \"invalid use of `return_address` intrinsic: function \\\n                            does not use out pointer\");\n                 C_null(Type::i8p(ccx))\n@@ -709,7 +690,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                    &llargs,\n                                    ret_ty, llret_ty,\n                                    call_debug_location,\n-                                   call_info)\n+                                   span)\n         }\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n@@ -742,19 +723,17 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             match split[1] {\n                 \"cxchg\" => {\n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    let cmp = from_arg_ty(bcx, llargs[1], tp_ty);\n-                    let src = from_arg_ty(bcx, llargs[2], tp_ty);\n+                    let cmp = from_immediate(bcx, llargs[1]);\n+                    let src = from_immediate(bcx, llargs[2]);\n+                    let ptr = PointerCast(bcx, llargs[0], val_ty(src).ptr_to());\n                     let res = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, llvm::False);\n                     ExtractValue(bcx, res, 0)\n                 }\n \n                 \"cxchgweak\" => {\n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    let cmp = from_arg_ty(bcx, llargs[1], tp_ty);\n-                    let src = from_arg_ty(bcx, llargs[2], tp_ty);\n+                    let cmp = from_immediate(bcx, llargs[1]);\n+                    let src = from_immediate(bcx, llargs[2]);\n+                    let ptr = PointerCast(bcx, llargs[0], val_ty(src).ptr_to());\n                     let val = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, llvm::True);\n                     let result = ExtractValue(bcx, val, 0);\n                     let success = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n@@ -765,13 +744,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n                 \"load\" => {\n                     let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    to_arg_ty(bcx, AtomicLoad(bcx, ptr, order), tp_ty)\n+                    let mut ptr = llargs[0];\n+                    if let Some(ty) = fn_ty.ret.cast {\n+                        ptr = PointerCast(bcx, ptr, ty.ptr_to());\n+                    }\n+                    to_immediate(bcx, AtomicLoad(bcx, ptr, order), tp_ty)\n                 }\n                 \"store\" => {\n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    let val = from_arg_ty(bcx, llargs[1], tp_ty);\n+                    let val = from_immediate(bcx, llargs[1]);\n+                    let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n                     AtomicStore(bcx, val, ptr, order);\n                     C_nil(ccx)\n                 }\n@@ -803,9 +784,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    let val = from_arg_ty(bcx, llargs[1], tp_ty);\n+                    let val = from_immediate(bcx, llargs[1]);\n+                    let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n                     AtomicRMW(bcx, atom_op, ptr, val, order)\n                 }\n             }\n@@ -815,8 +795,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, _) => {\n             let intr = match Intrinsic::find(tcx, &name) {\n                 Some(intr) => intr,\n-                None => ccx.sess().span_bug(foreign_item.span,\n-                                            &format!(\"unknown intrinsic '{}'\", name)),\n+                None => unreachable!(\"unknown intrinsic '{}'\", name),\n             };\n             fn one<T>(x: Vec<T>) -> T {\n                 assert_eq!(x.len(), 1);\n@@ -949,9 +928,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 intrinsics::IntrinsicDef::Named(name) => {\n                     let f = declare::declare_cfn(ccx,\n                                                  name,\n-                                                 Type::func(&inputs, &outputs),\n-                                                 tcx.mk_nil());\n-                    Call(bcx, f, &llargs, None, call_debug_location)\n+                                                 Type::func(&inputs, &outputs));\n+                    Call(bcx, f, &llargs, call_debug_location)\n                 }\n             };\n \n@@ -973,7 +951,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     if val_ty(llval) != Type::void(ccx) &&\n        machine::llsize_of_alloc(ccx, val_ty(llval)) != 0 {\n-        store_ty(bcx, llval, llresult, ret_ty);\n+        if let Some(ty) = fn_ty.ret.cast {\n+            let ptr = PointerCast(bcx, llresult, ty.ptr_to());\n+            let store = Store(bcx, llval, ptr);\n+            unsafe {\n+                llvm::LLVMSetAlignment(store, type_of::align_of(ccx, ret_ty));\n+            }\n+        } else {\n+            store_ty(bcx, llval, llresult, ret_ty);\n+        }\n     }\n \n     // If we made a temporary stack slot, let's clean it up\n@@ -1024,7 +1010,6 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            Mul(bcx, size, count, DebugLoc::None),\n            align,\n            C_bool(ccx, volatile)],\n-         None,\n          call_debug_location)\n }\n \n@@ -1054,7 +1039,6 @@ fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            Mul(bcx, size, count, DebugLoc::None),\n            align,\n            C_bool(ccx, volatile)],\n-         None,\n          call_debug_location)\n }\n \n@@ -1065,7 +1049,7 @@ fn count_zeros_intrinsic(bcx: Block,\n                          -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n-    Call(bcx, llfn, &[val, y], None, call_debug_location)\n+    Call(bcx, llfn, &[val, y], call_debug_location)\n }\n \n fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -1078,7 +1062,7 @@ fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let llfn = bcx.ccx().get_intrinsic(&name);\n \n     // Convert `i1` to a `bool`, and write it to the out parameter\n-    let val = Call(bcx, llfn, &[a, b], None, call_debug_location);\n+    let val = Call(bcx, llfn, &[a, b], call_debug_location);\n     let result = ExtractValue(bcx, val, 0);\n     let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n     Store(bcx, result, StructGEP(bcx, out, 0));\n@@ -1094,7 +1078,7 @@ fn try_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              dest: ValueRef,\n                              dloc: DebugLoc) -> Block<'blk, 'tcx> {\n     if bcx.sess().no_landing_pads() {\n-        Call(bcx, func, &[data], None, dloc);\n+        Call(bcx, func, &[data], dloc);\n         Store(bcx, C_null(Type::i8p(bcx.ccx())), dest);\n         bcx\n     } else if wants_msvc_seh(bcx.sess()) {\n@@ -1165,9 +1149,9 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // More information can be found in libstd's seh.rs implementation.\n         let slot = Alloca(bcx, Type::i8p(ccx), \"slot\");\n         let localescape = ccx.get_intrinsic(&\"llvm.localescape\");\n-        Call(bcx, localescape, &[slot], None, dloc);\n+        Call(bcx, localescape, &[slot], dloc);\n         Store(bcx, local_ptr, slot);\n-        Invoke(bcx, func, &[data], normal.llbb, catchswitch.llbb, None, dloc);\n+        Invoke(bcx, func, &[data], normal.llbb, catchswitch.llbb, dloc);\n \n         Ret(normal, C_i32(ccx, 0), dloc);\n \n@@ -1184,7 +1168,7 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = Call(bcx, llfn, &[func, data, local_ptr], None, dloc);\n+    let ret = Call(bcx, llfn, &[func, data, local_ptr], dloc);\n     Store(bcx, ret, dest);\n     return bcx\n }\n@@ -1208,6 +1192,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              dloc: DebugLoc) -> Block<'blk, 'tcx> {\n     let llfn = get_rust_try_fn(bcx.fcx, &mut |bcx| {\n         let ccx = bcx.ccx();\n+        let tcx = ccx.tcx();\n         let dloc = DebugLoc::None;\n \n         // Translates the shims described above:\n@@ -1228,10 +1213,11 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // managed by the standard library.\n \n         attributes::emit_uwtable(bcx.fcx.llfn, true);\n-        let catch_pers = match bcx.tcx().lang_items.eh_personality_catch() {\n-            Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n-                                              bcx.fcx.param_substs).val,\n-            None => bcx.tcx().sess.bug(\"eh_personality_catch not defined\"),\n+        let catch_pers = match tcx.lang_items.eh_personality_catch() {\n+            Some(did) => {\n+                Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n+            }\n+            None => ccx.sess().bug(\"eh_personality_catch not defined\"),\n         };\n \n         let then = bcx.fcx.new_temp_block(\"then\");\n@@ -1240,7 +1226,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let func = llvm::get_param(bcx.fcx.llfn, 0);\n         let data = llvm::get_param(bcx.fcx.llfn, 1);\n         let local_ptr = llvm::get_param(bcx.fcx.llfn, 2);\n-        Invoke(bcx, func, &[data], then.llbb, catch.llbb, None, dloc);\n+        Invoke(bcx, func, &[data], then.llbb, catch.llbb, dloc);\n         Ret(then, C_i32(ccx, 0), dloc);\n \n         // Type indicator for the exception being thrown.\n@@ -1260,7 +1246,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = Call(bcx, llfn, &[func, data, local_ptr], None, dloc);\n+    let ret = Call(bcx, llfn, &[func, data, local_ptr], dloc);\n     Store(bcx, ret, dest);\n     return bcx;\n }\n@@ -1269,21 +1255,32 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // This is currently primarily used for the `try` intrinsic functions above.\n fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                     name: &str,\n-                    ty: Ty<'tcx>,\n+                    inputs: Vec<Ty<'tcx>>,\n                     output: ty::FnOutput<'tcx>,\n                     trans: &mut for<'b> FnMut(Block<'b, 'tcx>))\n                     -> ValueRef {\n     let ccx = fcx.ccx;\n-    let llfn = declare::define_internal_rust_fn(ccx, name, ty);\n+    let sig = ty::FnSig {\n+        inputs: inputs,\n+        output: output,\n+        variadic: false,\n+    };\n+    let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n+\n+    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ty::BareFnTy {\n+        unsafety: hir::Unsafety::Unsafe,\n+        abi: Abi::Rust,\n+        sig: ty::Binder(sig)\n+    });\n+    let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n+    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n     let (fcx, block_arena);\n     block_arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                      output, ccx.tcx().mk_substs(Substs::trans_empty()),\n-                      None, &block_arena);\n-    let bcx = init_function(&fcx, true, output);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n+    let bcx = fcx.init(true, None);\n     trans(bcx);\n     fcx.cleanup();\n-    return llfn\n+    llfn\n }\n \n // Helper function used to get a handle to the `__rust_try` function used to\n@@ -1294,8 +1291,8 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                              trans: &mut for<'b> FnMut(Block<'b, 'tcx>))\n                              -> ValueRef {\n     let ccx = fcx.ccx;\n-    if let Some(llfn) = *ccx.rust_try_fn().borrow() {\n-        return llfn\n+    if let Some(llfn) = ccx.rust_try_fn().get() {\n+        return llfn;\n     }\n \n     // Define the type up front for the signature of the rust_try function.\n@@ -1311,18 +1308,8 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         }),\n     });\n     let output = ty::FnOutput::FnConverging(tcx.types.i32);\n-    let try_fn_ty  = ty::BareFnTy {\n-        unsafety: hir::Unsafety::Unsafe,\n-        abi: Abi::Rust,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: vec![fn_ty, i8p, i8p],\n-            output: output,\n-            variadic: false,\n-        }),\n-    };\n-    let rust_try = gen_fn(fcx, \"__rust_try\", tcx.mk_fn_ptr(try_fn_ty), output,\n-                          trans);\n-    *ccx.rust_try_fn().borrow_mut() = Some(rust_try);\n+    let rust_try = gen_fn(fcx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n+    ccx.rust_try_fn().set(Some(rust_try));\n     return rust_try\n }\n \n@@ -1341,9 +1328,10 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     let dloc = DebugLoc::None;\n \n-    let rust_try_filter = match ccx.tcx().lang_items.msvc_try_filter() {\n-        Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n-                                          fcx.param_substs).val,\n+    let rust_try_filter = match tcx.lang_items.msvc_try_filter() {\n+        Some(did) => {\n+            Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n+        }\n         None => ccx.sess().bug(\"msvc_try_filter not defined\"),\n     };\n \n@@ -1373,11 +1361,10 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     // For more info, see seh.rs in the standard library.\n     let do_trans = |bcx: Block, ehptrs, base_pointer| {\n         let rust_try_fn = BitCast(bcx, rust_try_fn, Type::i8p(ccx));\n-        let parentfp = Call(bcx, recoverfp, &[rust_try_fn, base_pointer],\n-                            None, dloc);\n+        let parentfp = Call(bcx, recoverfp, &[rust_try_fn, base_pointer], dloc);\n         let arg = Call(bcx, localrecover,\n-                       &[rust_try_fn, parentfp, C_i32(ccx, 0)], None, dloc);\n-        let ret = Call(bcx, rust_try_filter, &[ehptrs, arg], None, dloc);\n+                       &[rust_try_fn, parentfp, C_i32(ccx, 0)], dloc);\n+        let ret = Call(bcx, rust_try_filter, &[ehptrs, arg], dloc);\n         Ret(bcx, ret, dloc);\n     };\n \n@@ -1389,17 +1376,8 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         // going on here, all I can say is that there's a few tests cases in\n         // LLVM's test suite which follow this pattern of instructions, so we\n         // just do the same.\n-        let filter_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n-            unsafety: hir::Unsafety::Unsafe,\n-            abi: Abi::Rust,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: vec![],\n-                output: output,\n-                variadic: false,\n-            }),\n-        });\n-        gen_fn(fcx, \"__rustc_try_filter\", filter_fn_ty, output, &mut |bcx| {\n-            let ebp = Call(bcx, frameaddress, &[C_i32(ccx, 1)], None, dloc);\n+        gen_fn(fcx, \"__rustc_try_filter\", vec![], output, &mut |bcx| {\n+            let ebp = Call(bcx, frameaddress, &[C_i32(ccx, 1)], dloc);\n             let exn = InBoundsGEP(bcx, ebp, &[C_i32(ccx, -20)]);\n             let exn = Load(bcx, BitCast(bcx, exn, Type::i8p(ccx).ptr_to()));\n             do_trans(bcx, exn, ebp);\n@@ -1408,16 +1386,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         // Conveniently on x86_64 the EXCEPTION_POINTERS handle and base pointer\n         // are passed in as arguments to the filter function, so we just pass\n         // those along.\n-        let filter_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n-            unsafety: hir::Unsafety::Unsafe,\n-            abi: Abi::Rust,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: vec![i8p, i8p],\n-                output: output,\n-                variadic: false,\n-            }),\n-        });\n-        gen_fn(fcx, \"__rustc_try_filter\", filter_fn_ty, output, &mut |bcx| {\n+        gen_fn(fcx, \"__rustc_try_filter\", vec![i8p, i8p], output, &mut |bcx| {\n             let exn = llvm::get_param(bcx.fcx.llfn, 0);\n             let rbp = llvm::get_param(bcx.fcx.llfn, 1);\n             do_trans(bcx, exn, rbp);\n@@ -1441,7 +1410,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n      ret_ty: Ty<'tcx>,\n      llret_ty: Type,\n      call_debug_location: DebugLoc,\n-     call_info: NodeIdAndSpan) -> ValueRef\n+     span: Span) -> ValueRef\n {\n     // macros for error handling:\n     macro_rules! emit_error {\n@@ -1450,7 +1419,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n         };\n         ($msg: tt, $($fmt: tt)*) => {\n             span_invalid_monomorphization_error(\n-                bcx.sess(), call_info.span,\n+                bcx.sess(), span,\n                 &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n                                  $msg),\n                          name, $($fmt)*));\n@@ -1519,7 +1488,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     if name.starts_with(\"simd_shuffle\") {\n         let n: usize = match name[\"simd_shuffle\".len()..].parse() {\n             Ok(n) => n,\n-            Err(_) => tcx.sess.span_bug(call_info.span,\n+            Err(_) => tcx.sess.span_bug(span,\n                                         \"bad `simd_shuffle` instruction only caught in trans?\")\n         };\n \n@@ -1537,22 +1506,26 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n \n         let total_len = in_len as u64 * 2;\n \n-        let vector = match args {\n-            Some(args) => &args[2],\n-            None => bcx.sess().span_bug(call_info.span,\n-                                        \"intrinsic call with unexpected argument shape\"),\n-        };\n-        let vector = match consts::const_expr(bcx.ccx(), vector, substs, None,\n-            consts::TrueConst::Yes, // this should probably help simd error reporting\n-        ) {\n-            Ok((vector, _)) => vector,\n-            Err(err) => bcx.sess().span_fatal(call_info.span, &err.description()),\n+        let (vector, indirect) = match args {\n+            Some(args) => {\n+                match consts::const_expr(bcx.ccx(), &args[2], substs, None,\n+                                         // this should probably help simd error reporting\n+                                         consts::TrueConst::Yes) {\n+                    Ok((vector, _)) => (vector, false),\n+                    Err(err) => bcx.sess().span_fatal(span, &err.description()),\n+                }\n+            }\n+            None => (llargs[2], !type_is_immediate(bcx.ccx(), arg_tys[2]))\n         };\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = const_get_elt(bcx.ccx(), vector, &[i as libc::c_uint]);\n+                let val = if indirect {\n+                    Load(bcx, StructGEP(bcx, vector, i))\n+                } else {\n+                    const_get_elt(vector, &[i as libc::c_uint])\n+                };\n                 let c = const_to_opt_uint(val);\n                 match c {\n                     None => {\n@@ -1689,7 +1662,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n         simd_or: TyUint, TyInt => Or;\n         simd_xor: TyUint, TyInt => Xor;\n     }\n-    bcx.sess().span_bug(call_info.span, \"unknown SIMD intrinsic\");\n+    bcx.sess().span_bug(span, \"unknown SIMD intrinsic\");\n }\n \n // Returns the width of an int TypeVariant, and if it's signed or not"}, {"sha": "6b785e7edfd6a1568a38e2b589089f91e129b831", "filename": "src/librustc_trans/trans/llrepr.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs?ref=2de6ddd75e202acdedfcd05b51a863dcc10459ca", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use trans::context::CrateContext;\n-use trans::type_::Type;\n-use llvm::ValueRef;\n-\n-pub trait LlvmRepr {\n-    fn llrepr(&self, ccx: &CrateContext) -> String;\n-}\n-\n-impl<T:LlvmRepr> LlvmRepr for [T] {\n-    fn llrepr(&self, ccx: &CrateContext) -> String {\n-        let reprs: Vec<String> = self.iter().map(|t| t.llrepr(ccx)).collect();\n-        format!(\"[{}]\", reprs.join(\",\"))\n-    }\n-}\n-\n-impl LlvmRepr for Type {\n-    fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn().type_to_string(*self)\n-    }\n-}\n-\n-impl LlvmRepr for ValueRef {\n-    fn llrepr(&self, ccx: &CrateContext) -> String {\n-        ccx.tn().val_to_string(*self)\n-    }\n-}"}, {"sha": "30560ec05c46946851b60f15a64fb230207aac50", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 29, "deletions": 206, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -18,173 +18,39 @@ use middle::infer;\n use middle::subst::{Subst, Substs};\n use middle::subst;\n use middle::traits::{self, ProjectionMode};\n+use trans::abi::FnType;\n use trans::base::*;\n use trans::build::*;\n-use trans::callee::{Callee, Virtual, ArgVals,\n-                    trans_fn_pointer_shim, trans_fn_ref_with_substs};\n+use trans::callee::{Callee, Virtual, ArgVals, trans_fn_pointer_shim};\n use trans::closure;\n use trans::common::*;\n use trans::consts;\n-use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n use trans::glue;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of::*;\n+use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n-use syntax::ast::{self, Name};\n-use syntax::attr;\n+use syntax::ast::Name;\n use syntax::codemap::DUMMY_SP;\n \n-use rustc_front::hir;\n-\n // drop_glue pointer, size, align.\n const VTABLE_OFFSET: usize = 3;\n \n-/// The main \"translation\" pass for methods.  Generates code\n-/// for non-monomorphized methods only.  Other methods will\n-/// be generated once they are invoked with specific type parameters,\n-/// see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n-pub fn trans_impl(ccx: &CrateContext,\n-                  name: ast::Name,\n-                  impl_items: &[hir::ImplItem],\n-                  generics: &hir::Generics,\n-                  id: ast::NodeId) {\n-    let _icx = push_ctxt(\"meth::trans_impl\");\n-    let tcx = ccx.tcx();\n-\n-    debug!(\"trans_impl(name={}, id={})\", name, id);\n-\n-    // Both here and below with generic methods, be sure to recurse and look for\n-    // items that we need to translate.\n-    if !generics.ty_params.is_empty() {\n-        return;\n-    }\n-\n-    for impl_item in impl_items {\n-        match impl_item.node {\n-            hir::ImplItemKind::Method(ref sig, ref body) => {\n-                if sig.generics.ty_params.is_empty() {\n-                    let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n-                    for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n-                        let llfn = get_item_val(ccx, impl_item.id);\n-                        let empty_substs = tcx.mk_substs(Substs::trans_empty());\n-                        trans_fn(ccx,\n-                                 &sig.decl,\n-                                 body,\n-                                 llfn,\n-                                 empty_substs,\n-                                 impl_item.id,\n-                                 &impl_item.attrs);\n-                        update_linkage(ccx,\n-                                       llfn,\n-                                       Some(impl_item.id),\n-                                       if is_origin { OriginalTranslation } else { InlinedCopy });\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-/// Compute the appropriate callee, give na method's ID, trait ID,\n-/// substitutions and a Vtable for that trait.\n-pub fn callee_for_trait_impl<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       method_id: DefId,\n-                                       substs: &'tcx subst::Substs<'tcx>,\n-                                       trait_id: DefId,\n-                                       method_ty: Ty<'tcx>,\n-                                       vtable: traits::Vtable<'tcx, ()>)\n-                                       -> Callee<'tcx> {\n-    let _icx = push_ctxt(\"meth::callee_for_trait_impl\");\n-    match vtable {\n-        traits::VtableImpl(vtable_impl) => {\n-            let impl_did = vtable_impl.impl_def_id;\n-            let mname = ccx.tcx().item_name(method_id);\n-            // create a concatenated set of substitutions which includes\n-            // those from the impl and those from the method:\n-            let impl_substs = vtable_impl.substs.with_method_from(&substs);\n-            let substs = ccx.tcx().mk_substs(impl_substs);\n-            let mth = get_impl_method(ccx.tcx(), impl_did, substs, mname);\n-\n-            // Translate the function, bypassing Callee::def.\n-            // That is because default methods have the same ID as the\n-            // trait method used to look up the impl method that ended\n-            // up here, so calling Callee::def would infinitely recurse.\n-            Callee::ptr(trans_fn_ref_with_substs(ccx, mth.method.def_id,\n-                                                 Some(method_ty), mth.substs))\n-        }\n-        traits::VtableClosure(vtable_closure) => {\n-            // The substitutions should have no type parameters remaining\n-            // after passing through fulfill_obligation\n-            let trait_closure_kind = ccx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-            let llfn = closure::trans_closure_method(ccx,\n-                                                     vtable_closure.closure_def_id,\n-                                                     vtable_closure.substs,\n-                                                     trait_closure_kind);\n-            let fn_ptr_ty = match method_ty.sty {\n-                ty::TyFnDef(_, _, fty) => ccx.tcx().mk_ty(ty::TyFnPtr(fty)),\n-                _ => unreachable!(\"expected fn item type, found {}\",\n-                                  method_ty)\n-            };\n-            Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n-        }\n-        traits::VtableFnPointer(fn_ty) => {\n-            let trait_closure_kind = ccx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n-            let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n-            let fn_ptr_ty = match method_ty.sty {\n-                ty::TyFnDef(_, _, fty) => ccx.tcx().mk_ty(ty::TyFnPtr(fty)),\n-                _ => unreachable!(\"expected fn item type, found {}\",\n-                                  method_ty)\n-            };\n-            Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n-        }\n-        traits::VtableObject(ref data) => {\n-            Callee {\n-                data: Virtual(traits::get_vtable_index_of_object_method(\n-                    ccx.tcx(), data, method_id)),\n-                ty: method_ty\n-            }\n-        }\n-        traits::VtableBuiltin(..) |\n-        traits::VtableDefaultImpl(..) |\n-        traits::VtableParam(..) => {\n-            ccx.sess().bug(\n-                &format!(\"resolved vtable bad vtable {:?} in trans\",\n-                        vtable));\n-        }\n-    }\n-}\n-\n-/// Extracts a method from a trait object's vtable, at the\n-/// specified index, and casts it to the given type.\n+/// Extracts a method from a trait object's vtable, at the specified index.\n pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       llvtable: ValueRef,\n-                                      vtable_index: usize,\n-                                      method_ty: Ty<'tcx>)\n-                                      -> Datum<'tcx, Rvalue> {\n-    let _icx = push_ctxt(\"meth::get_virtual_method\");\n-    let ccx = bcx.ccx();\n-\n+                                      vtable_index: usize)\n+                                      -> ValueRef {\n     // Load the data pointer from the object.\n-    debug!(\"get_virtual_method(callee_ty={}, vtable_index={}, llvtable={})\",\n-           method_ty,\n-           vtable_index,\n-           bcx.val_to_string(llvtable));\n+    debug!(\"get_virtual_method(vtable_index={}, llvtable={:?})\",\n+           vtable_index, Value(llvtable));\n \n-    let mptr = Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]));\n-\n-    // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n-    if let ty::TyFnDef(_, _, fty) = method_ty.sty {\n-        let opaque_ty = opaque_method_ty(ccx.tcx(), fty);\n-        immediate_rvalue(PointerCast(bcx, mptr, type_of(ccx, opaque_ty)), opaque_ty)\n-    } else {\n-        immediate_rvalue(mptr, method_ty)\n-    }\n+    Load(bcx, GEPi(bcx, llvtable, &[vtable_index + VTABLE_OFFSET]))\n }\n \n /// Generate a shim function that allows an object type like `SomeTrait` to\n@@ -211,66 +77,48 @@ pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                    method_ty: Ty<'tcx>,\n                                    vtable_index: usize)\n-                                   -> Datum<'tcx, Rvalue> {\n+                                   -> ValueRef {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n     debug!(\"trans_object_shim(vtable_index={}, method_ty={:?})\",\n            vtable_index,\n            method_ty);\n \n-    let ret_ty = tcx.erase_late_bound_regions(&method_ty.fn_ret());\n-    let ret_ty = infer::normalize_associated_type(tcx, &ret_ty);\n+    let sig = tcx.erase_late_bound_regions(&method_ty.fn_sig());\n+    let sig = infer::normalize_associated_type(tcx, &sig);\n+    let fn_ty = FnType::new(ccx, method_ty.fn_abi(), &sig, &[]);\n \n-    let shim_fn_ty = match method_ty.sty {\n-        ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-        _ => unreachable!(\"expected fn item type, found {}\", method_ty)\n-    };\n-\n-    //\n-    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n-    let llfn = declare::define_internal_rust_fn(ccx, &function_name, shim_fn_ty);\n+    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, method_ty, \"object_shim\");\n+    let llfn = declare::define_internal_fn(ccx, &function_name, method_ty);\n \n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      llfn,\n-                      ast::DUMMY_NODE_ID,\n-                      false,\n-                      ret_ty,\n-                      empty_substs,\n-                      None,\n-                      &block_arena);\n-    let mut bcx = init_function(&fcx, false, ret_ty);\n-\n-    let llargs = get_params(fcx.llfn);\n-\n-    let self_idx = fcx.arg_offset();\n-    let llself = llargs[self_idx];\n-    let llvtable = llargs[self_idx + 1];\n-\n-    debug!(\"trans_object_shim: llself={}, llvtable={}\",\n-           bcx.val_to_string(llself), bcx.val_to_string(llvtable));\n-\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, empty_substs, &block_arena);\n+    let mut bcx = fcx.init(false, None);\n     assert!(!fcx.needs_ret_allocas);\n \n+\n     let dest =\n         fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\")));\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\")));\n \n     debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n            vtable_index);\n \n+    let llargs = get_params(fcx.llfn);\n+    let args = ArgVals(&llargs[fcx.fn_ty.ret.is_indirect() as usize..]);\n+\n     let callee = Callee {\n         data: Virtual(vtable_index),\n         ty: method_ty\n     };\n-    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[self_idx..]), dest).bcx;\n+    bcx = callee.call(bcx, DebugLoc::None, args, dest).bcx;\n \n-    finish_fn(&fcx, bcx, ret_ty, DebugLoc::None);\n+    fcx.finish(bcx, DebugLoc::None);\n \n-    immediate_rvalue(llfn, shim_fn_ty)\n+    llfn\n }\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n@@ -311,17 +159,9 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 let nullptr = C_null(Type::nil(ccx).ptr_to());\n                 get_vtable_methods(ccx, id, substs)\n                     .into_iter()\n-                    .map(|opt_mth| {\n-                        match opt_mth {\n-                            Some(mth) => {\n-                                trans_fn_ref_with_substs(ccx,\n-                                                         mth.method.def_id,\n-                                                         None,\n-                                                         &mth.substs).val\n-                            }\n-                            None => nullptr\n-                        }\n-                    })\n+                    .map(|opt_mth| opt_mth.map_or(nullptr, |mth| {\n+                        Callee::def(ccx, mth.method.def_id, &mth.substs).reify(ccx).val\n+                    }))\n                     .collect::<Vec<_>>()\n                     .into_iter()\n             }\n@@ -452,23 +292,6 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         .collect()\n }\n \n-/// Replace the self type (&Self or Box<Self>) with an opaque pointer.\n-fn opaque_method_ty<'tcx>(tcx: &TyCtxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n-                          -> Ty<'tcx> {\n-    let mut inputs = method_ty.sig.0.inputs.clone();\n-    inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::IntTy::I8));\n-\n-    tcx.mk_fn_ptr(ty::BareFnTy {\n-        unsafety: method_ty.unsafety,\n-        abi: method_ty.abi,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: inputs,\n-            output: method_ty.sig.0.output,\n-            variadic: method_ty.sig.0.variadic,\n-        }),\n-    })\n-}\n-\n #[derive(Debug)]\n pub struct ImplMethod<'tcx> {\n     pub method: Rc<ty::Method<'tcx>>,"}, {"sha": "080547952a5ceae34b0891990e9d67a3ccb40bf9", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 303, "deletions": 151, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,33 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{BasicBlockRef, ValueRef, OperandBundleDef};\n+use llvm::{self, BasicBlockRef, ValueRef, OperandBundleDef};\n use rustc::middle::ty;\n use rustc::mir::repr as mir;\n-use syntax::abi::Abi;\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n-use trans::attributes;\n use trans::base;\n use trans::build;\n-use trans::callee::{Callee, Fn, Virtual};\n-use trans::common::{self, Block, BlockAndBuilder};\n+use trans::callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n+use trans::common::{self, Block, BlockAndBuilder, C_undef};\n use trans::debuginfo::DebugLoc;\n use trans::Disr;\n-use trans::foreign;\n+use trans::machine::{llalign_of_min, llbitsize_of_real};\n use trans::meth;\n use trans::type_of;\n use trans::glue;\n use trans::type_::Type;\n \n use super::{MirContext, drop};\n-use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n+use super::lvalue::{LvalueRef, load_fat_ptr};\n+use super::operand::OperandRef;\n+use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         debug!(\"trans_block({:?})\", bb);\n \n         let mut bcx = self.bcx(bb);\n-        let data = self.mir.basic_block_data(bb);\n+        let mir = self.mir.clone();\n+        let data = mir.basic_block_data(bb);\n \n         // MSVC SEH bits\n         let (cleanup_pad, cleanup_bundle) = if let Some((cp, cb)) = self.make_cleanup_pad(bb) {\n@@ -104,6 +106,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Terminator::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n                 let (otherwise, targets) = targets.split_last().unwrap();\n                 let discr = bcx.load(self.trans_lvalue(&bcx, discr).llval);\n+                let discr = bcx.with_block(|bcx| base::to_immediate(bcx, discr, switch_ty));\n                 let switch = bcx.switch(discr, self.llblock(*otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n                     let llval = self.trans_constval(&bcx, value, switch_ty).immediate();\n@@ -113,9 +116,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Terminator::Return => {\n-                let return_ty = bcx.monomorphize(&self.mir.return_ty);\n                 bcx.with_block(|bcx| {\n-                    base::build_return_block(self.fcx, bcx, return_ty, DebugLoc::None);\n+                    self.fcx.build_return_block(bcx, DebugLoc::None);\n                 })\n             }\n \n@@ -141,11 +143,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                &[llvalue],\n                                self.llblock(target),\n                                unwind.llbb(),\n-                               cleanup_bundle.as_ref(),\n-                               None);\n+                               cleanup_bundle.as_ref());\n                     self.bcx(target).at_start(|bcx| drop::drop_fill(bcx, lvalue.llval, ty));\n                 } else {\n-                    bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref(), None);\n+                    bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref());\n                     drop::drop_fill(&bcx, lvalue.llval, ty);\n                     funclet_br(bcx, self.llblock(target));\n                 }\n@@ -154,190 +155,341 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Terminator::Call { ref func, ref args, ref destination, ref cleanup } => {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n-                let debugloc = DebugLoc::None;\n-                // The arguments we'll be passing. Plus one to account for outptr, if used.\n-                let mut llargs = Vec::with_capacity(args.len() + 1);\n-                // Types of the arguments. We do not preallocate, because this vector is only\n-                // filled when `is_foreign` is `true` and foreign calls are minority of the cases.\n-                let mut arg_tys = Vec::new();\n \n-                let (callee, fty) = match callee.ty.sty {\n+                let (mut callee, abi, sig) = match callee.ty.sty {\n                     ty::TyFnDef(def_id, substs, f) => {\n-                        (Callee::def(bcx.ccx(), def_id, substs, callee.ty), f)\n+                        (Callee::def(bcx.ccx(), def_id, substs), f.abi, &f.sig)\n                     }\n                     ty::TyFnPtr(f) => {\n                         (Callee {\n                             data: Fn(callee.immediate()),\n                             ty: callee.ty\n-                        }, f)\n+                        }, f.abi, &f.sig)\n                     }\n                     _ => unreachable!(\"{} is not callable\", callee.ty)\n                 };\n \n-                // We do not translate intrinsics here (they shouldn\u2019t be functions)\n-                assert!(fty.abi != Abi::RustIntrinsic && fty.abi != Abi::PlatformIntrinsic);\n-                // Foreign-ABI functions are translated differently\n-                let is_foreign = fty.abi != Abi::Rust && fty.abi != Abi::RustCall;\n+                // Handle intrinsics old trans wants Expr's for, ourselves.\n+                let intrinsic = match (&callee.ty.sty, &callee.data) {\n+                    (&ty::TyFnDef(def_id, _, _), &Intrinsic) => {\n+                        Some(bcx.tcx().item_name(def_id).as_str())\n+                    }\n+                    _ => None\n+                };\n+                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n+\n+                if intrinsic == Some(\"move_val_init\") {\n+                    let &(_, target) = destination.as_ref().unwrap();\n+                    // The first argument is a thin destination pointer.\n+                    let llptr = self.trans_operand(&bcx, &args[0]).immediate();\n+                    let val = self.trans_operand(&bcx, &args[1]);\n+                    self.store_operand(&bcx, llptr, val);\n+                    self.set_operand_dropped(&bcx, &args[1]);\n+                    funclet_br(bcx, self.llblock(target));\n+                    return;\n+                }\n+\n+                if intrinsic == Some(\"transmute\") {\n+                    let &(ref dest, target) = destination.as_ref().unwrap();\n+                    let dst = self.trans_lvalue(&bcx, dest);\n+                    let mut val = self.trans_operand(&bcx, &args[0]);\n+                    if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n+                        let llouttype = type_of::type_of(bcx.ccx(), dst.ty.to_ty(bcx.tcx()));\n+                        let out_type_size = llbitsize_of_real(bcx.ccx(), llouttype);\n+                        if out_type_size != 0 {\n+                            // FIXME #19925 Remove this hack after a release cycle.\n+                            let f = Callee::def(bcx.ccx(), def_id, substs);\n+                            let datum = f.reify(bcx.ccx());\n+                            val = OperandRef {\n+                                val: OperandValue::Immediate(datum.val),\n+                                ty: datum.ty\n+                            };\n+                        }\n+                    }\n+\n+                    let llty = type_of::type_of(bcx.ccx(), val.ty);\n+                    let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n+                    self.store_operand(&bcx, cast_ptr, val);\n+                    self.set_operand_dropped(&bcx, &args[0]);\n+                    funclet_br(bcx, self.llblock(target));\n+                    return;\n+                }\n+\n+                let extra_args = &args[sig.0.inputs.len()..];\n+                let extra_args = extra_args.iter().map(|op_arg| {\n+                    self.mir.operand_ty(bcx.tcx(), op_arg)\n+                }).collect::<Vec<_>>();\n+                let fn_ty = callee.direct_fn_type(bcx.ccx(), &extra_args);\n+\n+                // The arguments we'll be passing. Plus one to account for outptr, if used.\n+                let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n+                let mut llargs = Vec::with_capacity(arg_count);\n \n                 // Prepare the return value destination\n-                let (ret_dest_ty, must_copy_dest) = if let Some((ref d, _)) = *destination {\n+                let ret_dest = if let Some((ref d, _)) = *destination {\n                     let dest = self.trans_lvalue(&bcx, d);\n-                    let ret_ty = dest.ty.to_ty(bcx.tcx());\n-                    if !is_foreign && type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n+                    if fn_ty.ret.is_indirect() {\n                         llargs.push(dest.llval);\n-                        (Some((dest, ret_ty)), false)\n+                        None\n+                    } else if fn_ty.ret.is_ignore() {\n+                        None\n                     } else {\n-                        (Some((dest, ret_ty)), !common::type_is_zero_size(bcx.ccx(), ret_ty))\n+                        Some(dest)\n                     }\n                 } else {\n-                    (None, false)\n+                    None\n                 };\n \n                 // Split the rust-call tupled arguments off.\n-                let (args, rest) = if fty.abi == Abi::RustCall && !args.is_empty() {\n+                let (first_args, untuple) = if abi == Abi::RustCall && !args.is_empty() {\n                     let (tup, args) = args.split_last().unwrap();\n-                    // we can reorder safely because of MIR\n-                    (args, self.trans_operand_untupled(&bcx, tup))\n+                    (args, Some(tup))\n                 } else {\n-                    (&args[..], vec![])\n+                    (&args[..], None)\n                 };\n \n-                let datum = {\n-                    let mut arg_ops = args.iter().map(|arg| {\n-                        self.trans_operand(&bcx, arg)\n-                    }).chain(rest.into_iter());\n-\n-                    // Get the actual pointer we can call.\n-                    // This can involve vtable accesses or reification.\n-                    let datum = if let Virtual(idx) = callee.data {\n-                        assert!(!is_foreign);\n-\n-                        // Grab the first argument which is a trait object.\n-                        let vtable = match arg_ops.next().unwrap().val {\n-                            FatPtr(data, vtable) => {\n-                                llargs.push(data);\n-                                vtable\n-                            }\n-                            _ => unreachable!(\"expected FatPtr for Virtual call\")\n+                let mut idx = 0;\n+                for arg in first_args {\n+                    let val = self.trans_operand(&bcx, arg).val;\n+                    self.trans_argument(&bcx, val, &mut llargs, &fn_ty,\n+                                        &mut idx, &mut callee.data);\n+                }\n+                if let Some(tup) = untuple {\n+                    self.trans_arguments_untupled(&bcx, tup, &mut llargs, &fn_ty,\n+                                                  &mut idx, &mut callee.data)\n+                }\n+\n+                let fn_ptr = match callee.data {\n+                    NamedTupleConstructor(_) => {\n+                        // FIXME translate this like mir::Rvalue::Aggregate.\n+                        callee.reify(bcx.ccx()).val\n+                    }\n+                    Intrinsic => {\n+                        use trans::callee::ArgVals;\n+                        use trans::expr::{Ignore, SaveIn};\n+                        use trans::intrinsic::trans_intrinsic_call;\n+\n+                        let (dest, llargs) = if fn_ty.ret.is_indirect() {\n+                            (SaveIn(llargs[0]), &llargs[1..])\n+                        } else if let Some(dest) = ret_dest {\n+                            (SaveIn(dest.llval), &llargs[..])\n+                        } else {\n+                            (Ignore, &llargs[..])\n                         };\n \n                         bcx.with_block(|bcx| {\n-                            meth::get_virtual_method(bcx, vtable, idx, callee.ty)\n-                        })\n-                    } else {\n-                        callee.reify(bcx.ccx())\n-                    };\n-\n-                    // Process the rest of the args.\n-                    for operand in arg_ops {\n-                        match operand.val {\n-                            Ref(llval) | Immediate(llval) => llargs.push(llval),\n-                            FatPtr(b, e) => {\n-                                llargs.push(b);\n-                                llargs.push(e);\n+                            let res = trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n+                                                           ArgVals(llargs), dest,\n+                                                           DebugLoc::None);\n+                            let bcx = res.bcx.build();\n+                            if let Some((_, target)) = *destination {\n+                                for op in args {\n+                                    self.set_operand_dropped(&bcx, op);\n+                                }\n+                                funclet_br(bcx, self.llblock(target));\n+                            } else {\n+                                // trans_intrinsic_call already used Unreachable.\n+                                // bcx.unreachable();\n                             }\n-                        }\n-                        if is_foreign {\n-                            arg_tys.push(operand.ty);\n-                        }\n+                        });\n+                        return;\n                     }\n-\n-                    datum\n+                    Fn(f) => f,\n+                    Virtual(_) => unreachable!(\"Virtual fn ptr not extracted\")\n                 };\n-                let attrs = attributes::from_fn_type(bcx.ccx(), datum.ty);\n \n                 // Many different ways to call a function handled here\n-                match (is_foreign, cleanup, destination) {\n-                    // The two cases below are the only ones to use LLVM\u2019s `invoke`.\n-                    (false, &Some(cleanup), &None) => {\n-                        let cleanup = self.bcx(cleanup);\n-                        let landingpad = self.make_landing_pad(cleanup);\n-                        let unreachable_blk = self.unreachable_block();\n-                        bcx.invoke(datum.val,\n-                                   &llargs[..],\n-                                   unreachable_blk.llbb,\n-                                   landingpad.llbb(),\n-                                   cleanup_bundle.as_ref(),\n-                                   Some(attrs));\n-                        landingpad.at_start(|bcx| for op in args {\n-                            self.set_operand_dropped(bcx, op);\n-                        });\n-                    },\n-                    (false, &Some(cleanup), &Some((_, success))) => {\n-                        let cleanup = self.bcx(cleanup);\n-                        let landingpad = self.make_landing_pad(cleanup);\n-                        let invokeret = bcx.invoke(datum.val,\n-                                                   &llargs[..],\n-                                                   self.llblock(success),\n-                                                   landingpad.llbb(),\n-                                                   cleanup_bundle.as_ref(),\n-                                                   Some(attrs));\n-                        if must_copy_dest {\n-                            let (ret_dest, ret_ty) = ret_dest_ty\n-                                .expect(\"return destination and type not set\");\n-                            // We translate the copy straight into the beginning of the target\n-                            // block.\n-                            self.bcx(success).at_start(|bcx| bcx.with_block( |bcx| {\n-                                base::store_ty(bcx, invokeret, ret_dest.llval, ret_ty);\n-                            }));\n+                if let Some(cleanup) = cleanup.map(|bb| self.bcx(bb)) {\n+                    // We translate the copy into a temporary block. The temporary block is\n+                    // necessary because the current block has already been terminated (by\n+                    // `invoke`) and we cannot really translate into the target block\n+                    // because:\n+                    //  * The target block may have more than a single precedesor;\n+                    //  * Some LLVM insns cannot have a preceeding store insn (phi,\n+                    //    cleanuppad), and adding/prepending the store now may render\n+                    //    those other instructions invalid.\n+                    //\n+                    // NB: This approach still may break some LLVM code. For example if the\n+                    // target block starts with a `phi` (which may only match on immediate\n+                    // precedesors), it cannot know about this temporary block thus\n+                    // resulting in an invalid code:\n+                    //\n+                    // this:\n+                    //     \u2026\n+                    //     %0 = \u2026\n+                    //     %1 = invoke to label %temp \u2026\n+                    // temp:\n+                    //     store ty %1, ty* %dest\n+                    //     br label %actualtargetblock\n+                    // actualtargetblock:            ; preds: %temp, \u2026\n+                    //     phi \u2026 [%this, \u2026], [%0, \u2026] ; ERROR: phi requires to match only on\n+                    //                               ; immediate precedesors\n+\n+                    let ret_bcx = if destination.is_some() {\n+                        self.fcx.new_block(\"\", None)\n+                    } else {\n+                        self.unreachable_block()\n+                    };\n+                    let landingpad = self.make_landing_pad(cleanup);\n+\n+                    let invokeret = bcx.invoke(fn_ptr,\n+                                               &llargs,\n+                                               ret_bcx.llbb,\n+                                               landingpad.llbb(),\n+                                               cleanup_bundle.as_ref());\n+                    fn_ty.apply_attrs_callsite(invokeret);\n+\n+                    landingpad.at_start(|bcx| for op in args {\n+                        self.set_operand_dropped(bcx, op);\n+                    });\n+\n+                    if let Some((_, target)) = *destination {\n+                        let ret_bcx = ret_bcx.build();\n+                        if let Some(ret_dest) = ret_dest {\n+                            fn_ty.ret.store(&ret_bcx, invokeret, ret_dest.llval);\n                         }\n-                        self.bcx(success).at_start(|bcx| for op in args {\n-                            self.set_operand_dropped(bcx, op);\n-                        });\n-                        landingpad.at_start(|bcx| for op in args {\n-                            self.set_operand_dropped(bcx, op);\n-                        });\n-                    },\n-                    (false, _, &None) => {\n-                        bcx.call(datum.val,\n-                                 &llargs[..],\n-                                 cleanup_bundle.as_ref(),\n-                                 Some(attrs));\n-                        // no need to drop args, because the call never returns\n-                        bcx.unreachable();\n+                        for op in args {\n+                            self.set_operand_dropped(&ret_bcx, op);\n+                        }\n+                        ret_bcx.br(self.llblock(target));\n                     }\n-                    (false, _, &Some((_, target))) => {\n-                        let llret = bcx.call(datum.val,\n-                                             &llargs[..],\n-                                             cleanup_bundle.as_ref(),\n-                                             Some(attrs));\n-                        if must_copy_dest {\n-                            let (ret_dest, ret_ty) = ret_dest_ty\n-                                .expect(\"return destination and type not set\");\n-                            bcx.with_block(|bcx| {\n-                                base::store_ty(bcx, llret, ret_dest.llval, ret_ty);\n-                            });\n+                } else {\n+                    let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n+                    fn_ty.apply_attrs_callsite(llret);\n+                    if let Some((_, target)) = *destination {\n+                        if let Some(ret_dest) = ret_dest {\n+                            fn_ty.ret.store(&bcx, llret, ret_dest.llval);\n                         }\n                         for op in args {\n                             self.set_operand_dropped(&bcx, op);\n                         }\n                         funclet_br(bcx, self.llblock(target));\n+                    } else {\n+                        // no need to drop args, because the call never returns\n+                        bcx.unreachable();\n                     }\n-                    // Foreign functions\n-                    (true, _, destination) => {\n-                        let (dest, _) = ret_dest_ty\n-                            .expect(\"return destination is not set\");\n-                        bcx = bcx.map_block(|bcx| {\n-                            foreign::trans_native_call(bcx,\n-                                                       datum.ty,\n-                                                       datum.val,\n-                                                       dest.llval,\n-                                                       &llargs[..],\n-                                                       arg_tys,\n-                                                       debugloc)\n-                        });\n-                        if let Some((_, target)) = *destination {\n-                            for op in args {\n-                                self.set_operand_dropped(&bcx, op);\n-                            }\n-                            funclet_br(bcx, self.llblock(target));\n-                        }\n-                    },\n                 }\n             }\n         }\n     }\n \n+    fn trans_argument(&mut self,\n+                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                      val: OperandValue,\n+                      llargs: &mut Vec<ValueRef>,\n+                      fn_ty: &FnType,\n+                      next_idx: &mut usize,\n+                      callee: &mut CalleeData) {\n+        // Treat the values in a fat pointer separately.\n+        if let FatPtr(ptr, meta) = val {\n+            if *next_idx == 0 {\n+                if let Virtual(idx) = *callee {\n+                    let llfn = bcx.with_block(|bcx| {\n+                        meth::get_virtual_method(bcx, meta, idx)\n+                    });\n+                    let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+                    *callee = Fn(bcx.pointercast(llfn, llty));\n+                }\n+            }\n+            self.trans_argument(bcx, Immediate(ptr), llargs, fn_ty, next_idx, callee);\n+            self.trans_argument(bcx, Immediate(meta), llargs, fn_ty, next_idx, callee);\n+            return;\n+        }\n+\n+        let arg = &fn_ty.args[*next_idx];\n+        *next_idx += 1;\n+\n+        // Fill padding with undef value, where applicable.\n+        if let Some(ty) = arg.pad {\n+            llargs.push(C_undef(ty));\n+        }\n+\n+        if arg.is_ignore() {\n+            return;\n+        }\n+\n+        // Force by-ref if we have to load through a cast pointer.\n+        let (mut llval, by_ref) = match val {\n+            Immediate(llval) if arg.is_indirect() || arg.cast.is_some() => {\n+                let llscratch = build::AllocaFcx(bcx.fcx(), arg.original_ty, \"arg\");\n+                bcx.store(llval, llscratch);\n+                (llscratch, true)\n+            }\n+            Immediate(llval) => (llval, false),\n+            Ref(llval) => (llval, true),\n+            FatPtr(_, _) => unreachable!(\"fat pointers handled above\")\n+        };\n+\n+        if by_ref && !arg.is_indirect() {\n+            // Have to load the argument, maybe while casting it.\n+            if arg.original_ty == Type::i1(bcx.ccx()) {\n+                // We store bools as i8 so we need to truncate to i1.\n+                llval = bcx.load_range_assert(llval, 0, 2, llvm::False);\n+                llval = bcx.trunc(llval, arg.original_ty);\n+            } else if let Some(ty) = arg.cast {\n+                llval = bcx.load(bcx.pointercast(llval, ty.ptr_to()));\n+                let llalign = llalign_of_min(bcx.ccx(), arg.ty);\n+                unsafe {\n+                    llvm::LLVMSetAlignment(llval, llalign);\n+                }\n+            } else {\n+                llval = bcx.load(llval);\n+            }\n+        }\n+\n+        llargs.push(llval);\n+    }\n+\n+    fn trans_arguments_untupled(&mut self,\n+                                bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                operand: &mir::Operand<'tcx>,\n+                                llargs: &mut Vec<ValueRef>,\n+                                fn_ty: &FnType,\n+                                next_idx: &mut usize,\n+                                callee: &mut CalleeData) {\n+        // FIXME: consider having some optimization to avoid tupling/untupling\n+        // (and storing/loading in the case of immediates)\n+\n+        // avoid trans_operand for pointless copying\n+        let lv = match *operand {\n+            mir::Operand::Consume(ref lvalue) => self.trans_lvalue(bcx, lvalue),\n+            mir::Operand::Constant(ref constant) => {\n+                // FIXME: consider being less pessimized\n+                if constant.ty.is_nil() {\n+                    return;\n+                }\n+\n+                let ty = bcx.monomorphize(&constant.ty);\n+                let lv = LvalueRef::alloca(bcx, ty, \"__untuple_alloca\");\n+                let constant = self.trans_constant(bcx, constant);\n+                self.store_operand(bcx, lv.llval, constant);\n+                lv\n+           }\n+        };\n+\n+        let lv_ty = lv.ty.to_ty(bcx.tcx());\n+        let result_types = match lv_ty.sty {\n+            ty::TyTuple(ref tys) => tys,\n+            _ => bcx.tcx().sess.span_bug(\n+                self.mir.span,\n+                &format!(\"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty))\n+        };\n+\n+        let base_repr = adt::represent_type(bcx.ccx(), lv_ty);\n+        let base = adt::MaybeSizedValue::sized(lv.llval);\n+        for (n, &ty) in result_types.iter().enumerate() {\n+            let ptr = adt::trans_field_ptr_builder(bcx, &base_repr, base, Disr(0), n);\n+            let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n+                let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n+                FatPtr(lldata, llextra)\n+            } else {\n+                // Don't bother loading the value, trans_argument will.\n+                Ref(ptr)\n+            };\n+            self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+        }\n+    }\n+\n     fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>) -> ValueRef {\n         let ccx = bcx.ccx();\n         if let Some(slot) = self.llpersonalityslot {"}, {"sha": "d4934718d75ed7f671e2843319bebaa208255f4b", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::abi;\n use llvm::ValueRef;\n use middle::ty::{Ty, TypeFoldable};\n use rustc::middle::const_eval::{self, ConstVal};\n use rustc_const_eval::ConstInt::*;\n use rustc::mir::repr as mir;\n+use trans::abi;\n use trans::common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_integral,\n-                    C_str_slice, C_nil, C_undef};\n+                    C_str_slice, C_undef};\n use trans::consts;\n+use trans::datum;\n use trans::expr;\n-use trans::inline;\n use trans::type_of;\n use trans::type_::Type;\n \n@@ -38,8 +38,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let val = if common::type_is_immediate(ccx, ty) {\n             OperandValue::Immediate(val)\n         } else if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-            let data = common::const_get_elt(ccx, val, &[abi::FAT_PTR_ADDR as u32]);\n-            let extra = common::const_get_elt(ccx, val, &[abi::FAT_PTR_EXTRA as u32]);\n+            let data = common::const_get_elt(val, &[abi::FAT_PTR_ADDR as u32]);\n+            let extra = common::const_get_elt(val, &[abi::FAT_PTR_EXTRA as u32]);\n             OperandValue::FatPtr(data, extra)\n         } else {\n             OperandValue::Ref(val)\n@@ -85,16 +85,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             ConstVal::Integral(InferSigned(v)) => C_integral(llty, v as u64, true),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n-            ConstVal::Struct(id) | ConstVal::Tuple(id) |\n-            ConstVal::Array(id, _) | ConstVal::Repeat(id, _) => {\n-                let expr = bcx.tcx().map.expect_expr(id);\n-                bcx.with_block(|bcx| {\n-                    expr::trans(bcx, expr).datum.val\n-                })\n-            },\n+            ConstVal::Struct(_) | ConstVal::Tuple(_) |\n+            ConstVal::Array(..) | ConstVal::Repeat(..) |\n+            ConstVal::Function(_) => {\n+                unreachable!(\"MIR must not use {:?} (which refers to a local ID)\", cv)\n+            }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n             ConstVal::Dummy => unreachable!(),\n-            ConstVal::Function(_) => C_nil(ccx)\n         }\n     }\n \n@@ -116,16 +113,26 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     };\n                 }\n \n-                let substs = bcx.tcx().mk_substs(bcx.monomorphize(&substs));\n-                let def_id = inline::maybe_instantiate_inline(bcx.ccx(), def_id);\n-                let expr = const_eval::lookup_const_by_id(bcx.tcx(), def_id, None, Some(substs))\n+                let substs = Some(bcx.monomorphize(substs));\n+                let expr = const_eval::lookup_const_by_id(bcx.tcx(), def_id, substs)\n                             .expect(\"def was const, but lookup_const_by_id failed\").0;\n                 // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n                 // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n                 let d = bcx.with_block(|bcx| {\n                     expr::trans(bcx, expr)\n                 });\n-                OperandRef::from_rvalue_datum(d.datum.to_rvalue_datum(d.bcx, \"\").datum)\n+\n+                let datum = d.datum.to_rvalue_datum(d.bcx, \"\").datum;\n+\n+                match datum.kind.mode {\n+                    datum::RvalueMode::ByValue => {\n+                        OperandRef {\n+                            ty: datum.ty,\n+                            val: OperandValue::Immediate(datum.val)\n+                        }\n+                    }\n+                    datum::RvalueMode::ByRef => self.trans_load(bcx, datum.val, datum.ty)\n+                }\n             }\n             mir::Literal::Value { ref value } => {\n                 self.trans_constval(bcx, value, ty)"}, {"sha": "ffc3b1206746ebe710df6e98c0d5a80585f6038d", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -12,11 +12,13 @@ use llvm::ValueRef;\n use rustc::middle::ty::{self, Ty, TypeFoldable};\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n+use trans::abi;\n use trans::adt;\n use trans::base;\n-use trans::common::{self, BlockAndBuilder};\n+use trans::builder::Builder;\n+use trans::common::{self, BlockAndBuilder, C_uint};\n+use trans::consts;\n use trans::machine;\n-use trans::type_of;\n use trans::mir::drop;\n use llvm;\n use trans::Disr;\n@@ -49,11 +51,25 @@ impl<'tcx> LvalueRef<'tcx> {\n     {\n         assert!(!ty.has_erasable_regions());\n         let lltemp = bcx.with_block(|bcx| base::alloc_ty(bcx, ty, name));\n-        drop::drop_fill(bcx, lltemp, ty);\n+        if bcx.fcx().type_needs_drop(ty) {\n+            drop::drop_fill(bcx, lltemp, ty);\n+        }\n         LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n     }\n }\n \n+pub fn get_meta(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    b.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n+}\n+\n+pub fn get_dataptr(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    b.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n+}\n+\n+pub fn load_fat_ptr(b: &Builder, fat_ptr: ValueRef) -> (ValueRef, ValueRef) {\n+    (b.load(get_dataptr(b, fat_ptr)), b.load(get_meta(b, fat_ptr)))\n+}\n+\n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn lvalue_len(&mut self,\n                       bcx: &BlockAndBuilder<'bcx, 'tcx>,\n@@ -89,44 +105,53 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Lvalue::Arg(index) => self.args[index as usize],\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.mir.lvalue_ty(tcx, lvalue);\n-                LvalueRef::new_sized(\n-                    common::get_static_val(ccx, def_id, const_ty.to_ty(tcx)),\n-                    const_ty)\n+                LvalueRef::new_sized(consts::get_static(ccx, def_id).val, const_ty)\n             },\n             mir::Lvalue::ReturnPointer => {\n-                let fn_return_ty = bcx.monomorphize(&self.mir.return_ty);\n-                let return_ty = fn_return_ty.unwrap();\n-                let llval = if !common::return_type_is_void(bcx.ccx(), return_ty) {\n+                let llval = if !fcx.fn_ty.ret.is_ignore() {\n                     bcx.with_block(|bcx| {\n-                        fcx.get_ret_slot(bcx, fn_return_ty, \"\")\n+                        fcx.get_ret_slot(bcx, \"\")\n                     })\n                 } else {\n                     // This is a void return; that is, there\u2019s no place to store the value and\n                     // there cannot really be one (or storing into it doesn\u2019t make sense, anyway).\n                     // Ergo, we return an undef ValueRef, so we do not have to special-case every\n                     // place using lvalues, and could use it the same way you use a regular\n                     // ReturnPointer LValue (i.e. store into it, load from it etc).\n-                    let llty = type_of::type_of(bcx.ccx(), return_ty).ptr_to();\n+                    let llty = fcx.fn_ty.ret.original_ty.ptr_to();\n                     unsafe {\n                         llvm::LLVMGetUndef(llty.to_ref())\n                     }\n                 };\n+                let fn_return_ty = bcx.monomorphize(&self.mir.return_ty);\n+                let return_ty = fn_return_ty.unwrap();\n                 LvalueRef::new_sized(llval, LvalueTy::from_ty(return_ty))\n             },\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n                 let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n+                let projected_ty = bcx.monomorphize(&projected_ty);\n+\n+                let project_index = |llindex| {\n+                    let element = if let ty::TySlice(_) = tr_base.ty.to_ty(tcx).sty {\n+                        // Slices already point to the array element type.\n+                        bcx.inbounds_gep(tr_base.llval, &[llindex])\n+                    } else {\n+                        let zero = common::C_uint(bcx.ccx(), 0u64);\n+                        bcx.inbounds_gep(tr_base.llval, &[zero, llindex])\n+                    };\n+                    (element, ptr::null_mut())\n+                };\n+\n                 let (llprojected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n-                        bcx.with_block(|bcx| {\n-                            if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n-                                (base::load_ty(bcx, tr_base.llval, base_ty),\n-                                 ptr::null_mut())\n-                            } else {\n-                                base::load_fat_ptr(bcx, tr_base.llval, base_ty)\n-                            }\n-                        })\n+                        if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n+                            (base::load_ty_builder(bcx, tr_base.llval, base_ty),\n+                             ptr::null_mut())\n+                        } else {\n+                            load_fat_ptr(bcx, tr_base.llval)\n+                        }\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n@@ -142,9 +167,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         } else {\n                             adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n                         };\n-                        let llprojected = bcx.with_block(|bcx| {\n-                            adt::trans_field_ptr(bcx, &base_repr, base, Disr(discr), field.index())\n-                        });\n+                        let llprojected = adt::trans_field_ptr_builder(bcx, &base_repr, base,\n+                                                                       Disr(discr), field.index());\n                         let llextra = if is_sized {\n                             ptr::null_mut()\n                         } else {\n@@ -154,30 +178,21 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n                         let index = self.trans_operand(bcx, index);\n-                        let llindex = self.prepare_index(bcx, index.immediate());\n-                        let zero = common::C_uint(bcx.ccx(), 0u64);\n-                        (bcx.inbounds_gep(tr_base.llval, &[zero, llindex]),\n-                         ptr::null_mut())\n+                        project_index(self.prepare_index(bcx, index.immediate()))\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = common::C_u32(bcx.ccx(), offset);\n-                        let llindex = self.prepare_index(bcx, lloffset);\n-                        let zero = common::C_uint(bcx.ccx(), 0u64);\n-                        (bcx.inbounds_gep(tr_base.llval, &[zero, llindex]),\n-                         ptr::null_mut())\n+                        let lloffset = C_uint(bcx.ccx(), offset);\n+                        project_index(self.prepare_index(bcx, lloffset))\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = common::C_u32(bcx.ccx(), offset);\n+                        let lloffset = C_uint(bcx.ccx(), offset);\n                         let lllen = self.lvalue_len(bcx, tr_base);\n                         let llindex = bcx.sub(lllen, lloffset);\n-                        let llindex = self.prepare_index(bcx, llindex);\n-                        let zero = common::C_uint(bcx.ccx(), 0u64);\n-                        (bcx.inbounds_gep(tr_base.llval, &[zero, llindex]),\n-                         ptr::null_mut())\n+                        project_index(self.prepare_index(bcx, llindex))\n                     }\n                     mir::ProjectionElem::Downcast(..) => {\n                         (tr_base.llval, tr_base.llextra)"}, {"sha": "9df2cb712b14fb2c4356197c52c47a4741d51487", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 98, "deletions": 54, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -10,21 +10,39 @@\n \n use libc::c_uint;\n use llvm::{self, ValueRef};\n+use middle::ty;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use trans::base;\n-use trans::common::{self, Block, BlockAndBuilder};\n-use trans::expr;\n-use trans::type_of;\n+use trans::common::{self, Block, BlockAndBuilder, FunctionContext};\n \n-use self::lvalue::LvalueRef;\n+use std::ops::Deref;\n+use std::rc::Rc;\n+\n+use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n use self::operand::OperandRef;\n \n+#[derive(Clone)]\n+pub enum CachedMir<'mir, 'tcx: 'mir> {\n+    Ref(&'mir mir::Mir<'tcx>),\n+    Owned(Rc<mir::Mir<'tcx>>)\n+}\n+\n+impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n+    type Target = mir::Mir<'tcx>;\n+    fn deref(&self) -> &mir::Mir<'tcx> {\n+        match *self {\n+            CachedMir::Ref(r) => r,\n+            CachedMir::Owned(ref rc) => rc\n+        }\n+    }\n+}\n+\n // FIXME DebugLoc is always None right now\n \n /// Master context for translating MIR.\n pub struct MirContext<'bcx, 'tcx:'bcx> {\n-    mir: &'bcx mir::Mir<'tcx>,\n+    mir: CachedMir<'bcx, 'tcx>,\n \n     /// Function context\n     fcx: &'bcx common::FunctionContext<'bcx, 'tcx>,\n@@ -77,16 +95,16 @@ enum TempRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn trans_mir<'bcx, 'tcx>(bcx: BlockAndBuilder<'bcx, 'tcx>) {\n-    let fcx = bcx.fcx();\n+pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n+    let bcx = fcx.init(false, None).build();\n     let mir = bcx.mir();\n \n-    let mir_blocks = bcx.mir().all_basic_blocks();\n+    let mir_blocks = mir.all_basic_blocks();\n \n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n     let lvalue_temps = bcx.with_block(|bcx| {\n-      analyze::lvalue_temps(bcx, mir)\n+      analyze::lvalue_temps(bcx, &mir)\n     });\n \n     // Allocate variable and temp allocas\n@@ -108,10 +126,10 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: BlockAndBuilder<'bcx, 'tcx>) {\n                                   TempRef::Operand(None)\n                               })\n                               .collect();\n-    let args = arg_value_refs(&bcx, mir);\n+    let args = arg_value_refs(&bcx, &mir);\n \n     // Allocate a `Block` for every basic block\n-    let block_bcxs: Vec<Block<'bcx,'tcx>> =\n+    let block_bcxs: Vec<Block<'blk,'tcx>> =\n         mir_blocks.iter()\n                   .map(|&bb|{\n                       // FIXME(#30941) this doesn't handle msvc-style exceptions\n@@ -138,6 +156,8 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: BlockAndBuilder<'bcx, 'tcx>) {\n     for &bb in &mir_blocks {\n         mircx.trans_block(bb);\n     }\n+\n+    fcx.cleanup();\n }\n \n /// Produce, for each argument, a `ValueRef` pointing at the\n@@ -146,51 +166,75 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: BlockAndBuilder<'bcx, 'tcx>) {\n fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               mir: &mir::Mir<'tcx>)\n                               -> Vec<LvalueRef<'tcx>> {\n-    // FIXME tupled_args? I think I'd rather that mapping is done in MIR land though\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n-    let mut idx = fcx.arg_offset() as c_uint;\n-    mir.arg_decls\n-       .iter()\n-       .enumerate()\n-       .map(|(arg_index, arg_decl)| {\n-           let arg_ty = bcx.monomorphize(&arg_decl.ty);\n-           let llval = if type_of::arg_is_indirect(bcx.ccx(), arg_ty) {\n-               // Don't copy an indirect argument to an alloca, the caller\n-               // already put it in a temporary alloca and gave it up, unless\n-               // we emit extra-debug-info, which requires local allocas :(.\n-               // FIXME: lifetimes, debug info\n-               let llarg = llvm::get_param(fcx.llfn, idx);\n-               idx += 1;\n-               llarg\n-           } else if common::type_is_fat_ptr(tcx, arg_ty) {\n-               // we pass fat pointers as two words, but we want to\n-               // represent them internally as a pointer to two words,\n-               // so make an alloca to store them in.\n-               let lldata = llvm::get_param(fcx.llfn, idx);\n-               let llextra = llvm::get_param(fcx.llfn, idx + 1);\n-               idx += 2;\n-               let (lltemp, dataptr, meta) = bcx.with_block(|bcx| {\n-                   let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-                   (lltemp, expr::get_dataptr(bcx, lltemp), expr::get_meta(bcx, lltemp))\n-               });\n-               bcx.store(lldata, dataptr);\n-               bcx.store(llextra, meta);\n-               lltemp\n-           } else {\n-               // otherwise, arg is passed by value, so make a\n-               // temporary and store it there\n-               let llarg = llvm::get_param(fcx.llfn, idx);\n-               idx += 1;\n-               bcx.with_block(|bcx| {\n-                   let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-                   base::store_ty(bcx, llarg, lltemp, arg_ty);\n-                   lltemp\n-               })\n-           };\n-           LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n-       })\n-       .collect()\n+    let mut idx = 0;\n+    let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    mir.arg_decls.iter().enumerate().map(|(arg_index, arg_decl)| {\n+        let arg_ty = bcx.monomorphize(&arg_decl.ty);\n+        if arg_decl.spread {\n+            // This argument (e.g. the last argument in the \"rust-call\" ABI)\n+            // is a tuple that was spread at the ABI level and now we have\n+            // to reconstruct it into a tuple local variable, from multiple\n+            // individual LLVM function arguments.\n+\n+            let tupled_arg_tys = match arg_ty.sty {\n+                ty::TyTuple(ref tys) => tys,\n+                _ => unreachable!(\"spread argument isn't a tuple?!\")\n+            };\n+\n+            let lltemp = bcx.with_block(|bcx| {\n+                base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n+            });\n+            for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n+                let dst = bcx.struct_gep(lltemp, i);\n+                let arg = &fcx.fn_ty.args[idx];\n+                    idx += 1;\n+                if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n+                        // We pass fat pointers as two words, but inside the tuple\n+                        // they are the two sub-fields of a single aggregate field.\n+                    let meta = &fcx.fn_ty.args[idx];\n+                    idx += 1;\n+                    arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, dst));\n+                    meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, dst));\n+                } else {\n+                    arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n+                }\n+            }\n+            return LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty));\n+        }\n+\n+        let arg = &fcx.fn_ty.args[idx];\n+        idx += 1;\n+        let llval = if arg.is_indirect() {\n+            // Don't copy an indirect argument to an alloca, the caller\n+            // already put it in a temporary alloca and gave it up, unless\n+            // we emit extra-debug-info, which requires local allocas :(.\n+            // FIXME: lifetimes, debug info\n+            let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+            llarg_idx += 1;\n+            llarg\n+        } else {\n+            let lltemp = bcx.with_block(|bcx| {\n+                base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n+            });\n+            if common::type_is_fat_ptr(tcx, arg_ty) {\n+                // we pass fat pointers as two words, but we want to\n+                // represent them internally as a pointer to two words,\n+                // so make an alloca to store them in.\n+                let meta = &fcx.fn_ty.args[idx];\n+                idx += 1;\n+                arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, lltemp));\n+                meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, lltemp));\n+            } else  {\n+                // otherwise, arg is passed by value, so make a\n+                // temporary and store it there\n+                arg.store_fn_arg(bcx, &mut llarg_idx, lltemp);\n+            }\n+            lltemp\n+        };\n+        LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n+    }).collect()\n }\n \n mod analyze;"}, {"sha": "6df4502fbc827503282185651626baf413e1c650", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 25, "deletions": 80, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -9,17 +9,18 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::middle::ty::{self, Ty};\n+use rustc::middle::ty::Ty;\n use rustc::mir::repr as mir;\n-use trans::adt;\n use trans::base;\n use trans::common::{self, Block, BlockAndBuilder};\n use trans::datum;\n-use trans::Disr;\n+use trans::value::Value;\n use trans::glue;\n \n+use std::fmt;\n+\n+use super::lvalue::load_fat_ptr;\n use super::{MirContext, TempRef, drop};\n-use super::lvalue::LvalueRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -53,42 +54,32 @@ pub struct OperandRef<'tcx> {\n     pub ty: Ty<'tcx>\n }\n \n-impl<'tcx> OperandRef<'tcx> {\n-    /// Asserts that this operand refers to a scalar and returns\n-    /// a reference to its value.\n-    pub fn immediate(self) -> ValueRef {\n-        match self.val {\n-            OperandValue::Immediate(s) => s,\n-            _ => unreachable!()\n-        }\n-    }\n-\n-    pub fn repr<'bcx>(self, bcx: &BlockAndBuilder<'bcx, 'tcx>) -> String {\n+impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.val {\n             OperandValue::Ref(r) => {\n-                format!(\"OperandRef(Ref({}) @ {:?})\",\n-                        bcx.val_to_string(r), self.ty)\n+                write!(f, \"OperandRef(Ref({:?}) @ {:?})\",\n+                       Value(r), self.ty)\n             }\n             OperandValue::Immediate(i) => {\n-                format!(\"OperandRef(Immediate({}) @ {:?})\",\n-                        bcx.val_to_string(i), self.ty)\n+                write!(f, \"OperandRef(Immediate({:?}) @ {:?})\",\n+                       Value(i), self.ty)\n             }\n             OperandValue::FatPtr(a, d) => {\n-                format!(\"OperandRef(FatPtr({}, {}) @ {:?})\",\n-                        bcx.val_to_string(a),\n-                        bcx.val_to_string(d),\n-                        self.ty)\n+                write!(f, \"OperandRef(FatPtr({:?}, {:?}) @ {:?})\",\n+                       Value(a), Value(d), self.ty)\n             }\n         }\n     }\n+}\n \n-    pub fn from_rvalue_datum(datum: datum::Datum<'tcx, datum::Rvalue>) -> OperandRef {\n-        OperandRef {\n-            ty: datum.ty,\n-            val: match datum.kind.mode {\n-                datum::RvalueMode::ByRef => OperandValue::Ref(datum.val),\n-                datum::RvalueMode::ByValue => OperandValue::Immediate(datum.val),\n-            }\n+impl<'tcx> OperandRef<'tcx> {\n+    /// Asserts that this operand refers to a scalar and returns\n+    /// a reference to its value.\n+    pub fn immediate(self) -> ValueRef {\n+        match self.val {\n+            OperandValue::Immediate(s) => s,\n+            _ => unreachable!()\n         }\n     }\n }\n@@ -100,18 +91,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                       ty: Ty<'tcx>)\n                       -> OperandRef<'tcx>\n     {\n-        debug!(\"trans_load: {} @ {:?}\", bcx.val_to_string(llval), ty);\n+        debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n         let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n             datum::ByValue => {\n-                bcx.with_block(|bcx| {\n-                    OperandValue::Immediate(base::load_ty(bcx, llval, ty))\n-                })\n+                OperandValue::Immediate(base::load_ty_builder(bcx, llval, ty))\n             }\n             datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n-                let (lldata, llextra) = bcx.with_block(|bcx| {\n-                    base::load_fat_ptr(bcx, llval, ty)\n-                });\n+                let (lldata, llextra) = load_fat_ptr(bcx, llval);\n                 OperandValue::FatPtr(lldata, llextra)\n             }\n             datum::ByRef => OperandValue::Ref(llval)\n@@ -164,7 +151,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                          lldest: ValueRef,\n                          operand: OperandRef<'tcx>)\n     {\n-        debug!(\"store_operand: operand={}\", operand.repr(bcx));\n+        debug!(\"store_operand: operand={:?}\", operand);\n         bcx.with_block(|bcx| self.store_operand_direct(bcx, lldest, operand))\n     }\n \n@@ -187,48 +174,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    pub fn trans_operand_untupled(&mut self,\n-                                  bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                                  operand: &mir::Operand<'tcx>)\n-                                  -> Vec<OperandRef<'tcx>>\n-    {\n-        // FIXME: consider having some optimization to avoid tupling/untupling\n-        // (and storing/loading in the case of immediates)\n-\n-        // avoid trans_operand for pointless copying\n-        let lv = match *operand {\n-            mir::Operand::Consume(ref lvalue) => self.trans_lvalue(bcx, lvalue),\n-            mir::Operand::Constant(ref constant) => {\n-                // FIXME: consider being less pessimized\n-                if constant.ty.is_nil() {\n-                    return vec![];\n-                }\n-\n-                let ty = bcx.monomorphize(&constant.ty);\n-                let lv = LvalueRef::alloca(bcx, ty, \"__untuple_alloca\");\n-                let constant = self.trans_constant(bcx, constant);\n-                self.store_operand(bcx, lv.llval, constant);\n-                lv\n-           }\n-        };\n-\n-        let lv_ty = lv.ty.to_ty(bcx.tcx());\n-        let result_types = match lv_ty.sty {\n-            ty::TyTuple(ref tys) => tys,\n-            _ => bcx.tcx().sess.span_bug(\n-                self.mir.span,\n-                &format!(\"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty))\n-        };\n-\n-        let base_repr = adt::represent_type(bcx.ccx(), lv_ty);\n-        let base = adt::MaybeSizedValue::sized(lv.llval);\n-        result_types.iter().enumerate().map(|(n, &ty)| {\n-            self.trans_load(bcx, bcx.with_block(|bcx| {\n-                adt::trans_field_ptr(bcx, &base_repr, base, Disr(0), n)\n-            }), ty)\n-        }).collect()\n-    }\n-\n     pub fn set_operand_dropped(&mut self,\n                                bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                                operand: &mir::Operand<'tcx>) {"}, {"sha": "17c8aef244bb95c04a8c6d2d3505864698bda25d", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 93, "deletions": 54, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -18,20 +18,21 @@ use rustc::mir::repr as mir;\n use trans::asm;\n use trans::base;\n use trans::callee::Callee;\n-use trans::common::{self, BlockAndBuilder, Result};\n+use trans::common::{self, C_uint, BlockAndBuilder, Result};\n+use trans::datum::{Datum, Lvalue};\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n-use trans::expr;\n use trans::adt;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n use trans::tvec;\n+use trans::value::Value;\n use trans::Disr;\n \n use super::MirContext;\n use super::operand::{OperandRef, OperandValue};\n-use super::lvalue::LvalueRef;\n+use super::lvalue::{LvalueRef, get_dataptr, get_meta};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -40,9 +41,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         rvalue: &mir::Rvalue<'tcx>)\n                         -> BlockAndBuilder<'bcx, 'tcx>\n     {\n-        debug!(\"trans_rvalue(dest.llval={}, rvalue={:?})\",\n-               bcx.val_to_string(dest.llval),\n-               rvalue);\n+        debug!(\"trans_rvalue(dest.llval={:?}, rvalue={:?})\",\n+               Value(dest.llval), rvalue);\n \n         match *rvalue {\n            mir::Rvalue::Use(ref operand) => {\n@@ -54,7 +54,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                bcx\n            }\n \n-            mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, cast_ty) => {\n+            mir::Rvalue::Cast(mir::CastKind::Unsize, ref source, cast_ty) => {\n                 if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n@@ -67,7 +67,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // this to be eliminated by MIR translation, but\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n-                let operand = self.trans_operand(&bcx, operand);\n+                let operand = self.trans_operand(&bcx, source);\n                 bcx.with_block(|bcx| {\n                     match operand.val {\n                         OperandValue::FatPtr(..) => unreachable!(),\n@@ -92,15 +92,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     }\n                 });\n+                self.set_operand_dropped(&bcx, source);\n                 bcx\n             }\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n                 let count = ConstVal::Integral(ConstInt::Usize(count.value));\n                 let size = self.trans_constval(&bcx, &count, bcx.tcx().types.usize).immediate();\n+                let base = get_dataptr(&bcx, dest.llval);\n                 let bcx = bcx.map_block(|block| {\n-                    let base = expr::get_dataptr(block, dest.llval);\n                     tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {\n                         self.store_operand_direct(block, llslot, tr_elem);\n                         block\n@@ -123,15 +124,39 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 let val = adt::MaybeSizedValue::sized(dest.llval);\n-                                let lldest_i = bcx.with_block(|bcx| {\n-                                    adt::trans_field_ptr(bcx, &repr, val, disr, i)\n-                                });\n+                                let lldest_i = adt::trans_field_ptr_builder(&bcx, &repr,\n+                                                                            val, disr, i);\n                                 self.store_operand(&bcx, lldest_i, op);\n-                                self.set_operand_dropped(&bcx, operand);\n                             }\n+                            self.set_operand_dropped(&bcx, operand);\n                         }\n                     },\n                     _ => {\n+                        // FIXME Shouldn't need to manually trigger closure instantiations.\n+                        if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n+                            use rustc_front::hir;\n+                            use syntax::ast::DUMMY_NODE_ID;\n+                            use syntax::codemap::DUMMY_SP;\n+                            use syntax::ptr::P;\n+                            use trans::closure;\n+\n+                            closure::trans_closure_expr(closure::Dest::Ignore(bcx.ccx()),\n+                                                        &hir::FnDecl {\n+                                                            inputs: P::new(),\n+                                                            output: hir::NoReturn(DUMMY_SP),\n+                                                            variadic: false\n+                                                        },\n+                                                        &hir::Block {\n+                                                            stmts: P::new(),\n+                                                            expr: None,\n+                                                            id: DUMMY_NODE_ID,\n+                                                            rules: hir::DefaultBlock,\n+                                                            span: DUMMY_SP\n+                                                        },\n+                                                        DUMMY_NODE_ID, def_id,\n+                                                        &bcx.monomorphize(substs));\n+                        }\n+\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n@@ -141,8 +166,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 // not be structs but arrays.\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n                                 self.store_operand(&bcx, dest, op);\n-                                self.set_operand_dropped(&bcx, operand);\n                             }\n+                            self.set_operand_dropped(&bcx, operand);\n                         }\n                     }\n                 }\n@@ -152,26 +177,42 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Slice { ref input, from_start, from_end } => {\n                 let ccx = bcx.ccx();\n                 let input = self.trans_lvalue(&bcx, input);\n-                let (llbase, lllen) = bcx.with_block(|bcx| {\n-                    tvec::get_base_and_len(bcx,\n-                                           input.llval,\n-                                           input.ty.to_ty(bcx.tcx()))\n-                });\n-                let llbase1 = bcx.gepi(llbase, &[from_start]);\n-                let adj = common::C_uint(ccx, from_start + from_end);\n+                let ty = input.ty.to_ty(bcx.tcx());\n+                let (llbase1, lllen) = match ty.sty {\n+                    ty::TyArray(_, n) => {\n+                        (bcx.gepi(input.llval, &[0, from_start]), C_uint(ccx, n))\n+                    }\n+                    ty::TySlice(_) | ty::TyStr => {\n+                        (bcx.gepi(input.llval, &[from_start]), input.llextra)\n+                    }\n+                    _ => unreachable!(\"cannot slice {}\", ty)\n+                };\n+                let adj = C_uint(ccx, from_start + from_end);\n                 let lllen1 = bcx.sub(lllen, adj);\n-                let (lladdrdest, llmetadest) = bcx.with_block(|bcx| {\n-                    (expr::get_dataptr(bcx, dest.llval), expr::get_meta(bcx, dest.llval))\n-                });\n-                bcx.store(llbase1, lladdrdest);\n-                bcx.store(lllen1, llmetadest);\n+                bcx.store(llbase1, get_dataptr(&bcx, dest.llval));\n+                bcx.store(lllen1, get_meta(&bcx, dest.llval));\n                 bcx\n             }\n \n-            mir::Rvalue::InlineAsm(ref inline_asm) => {\n-                bcx.map_block(|bcx| {\n-                    asm::trans_inline_asm(bcx, inline_asm)\n-                })\n+            mir::Rvalue::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                let outputs = outputs.iter().map(|output| {\n+                    let lvalue = self.trans_lvalue(&bcx, output);\n+                    Datum::new(lvalue.llval, lvalue.ty.to_ty(bcx.tcx()),\n+                               Lvalue::new(\"out\"))\n+                }).collect();\n+\n+                let input_vals = inputs.iter().map(|input| {\n+                    self.trans_operand(&bcx, input).immediate()\n+                }).collect();\n+\n+                bcx.with_block(|bcx| {\n+                    asm::trans_inline_asm(bcx, asm, outputs, input_vals);\n+                });\n+\n+                for input in inputs {\n+                    self.set_operand_dropped(&bcx, input);\n+                }\n+                bcx\n             }\n \n             _ => {\n@@ -191,17 +232,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Cast(ref kind, ref operand, cast_ty) => {\n-                let operand = self.trans_operand(&bcx, operand);\n-                debug!(\"cast operand is {}\", operand.repr(&bcx));\n+            mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n+                let operand = self.trans_operand(&bcx, source);\n+                debug!(\"cast operand is {:?}\", operand);\n                 let cast_ty = bcx.monomorphize(&cast_ty);\n \n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs, _) => {\n                                 OperandValue::Immediate(\n-                                    Callee::def(bcx.ccx(), def_id, substs, operand.ty)\n+                                    Callee::def(bcx.ccx(), def_id, substs)\n                                         .reify(bcx.ccx()).val)\n                             }\n                             _ => {\n@@ -225,6 +266,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 // example,\n                                 //   &'a fmt::Debug+Send => &'a fmt::Debug,\n                                 // and is a no-op at the LLVM level\n+                                self.set_operand_dropped(&bcx, source);\n                                 operand.val\n                             }\n                             OperandValue::Immediate(lldata) => {\n@@ -233,30 +275,28 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                     base::unsize_thin_ptr(bcx, lldata,\n                                                           operand.ty, cast_ty)\n                                 });\n+                                self.set_operand_dropped(&bcx, source);\n                                 OperandValue::FatPtr(lldata, llextra)\n                             }\n                             OperandValue::Ref(_) => {\n                                 bcx.sess().bug(\n-                                    &format!(\"by-ref operand {} in trans_rvalue_operand\",\n-                                             operand.repr(&bcx)));\n+                                    &format!(\"by-ref operand {:?} in trans_rvalue_operand\",\n+                                             operand));\n                             }\n                         }\n                     }\n                     mir::CastKind::Misc if common::type_is_immediate(bcx.ccx(), operand.ty) => {\n                         debug_assert!(common::type_is_immediate(bcx.ccx(), cast_ty));\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = type_of::arg_type_of(bcx.ccx(), operand.ty);\n-                        let ll_t_out = type_of::arg_type_of(bcx.ccx(), cast_ty);\n-                        let (llval, ll_t_in, signed) = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n+                        let ll_t_in = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n+                        let ll_t_out = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n+                        let llval = operand.immediate();\n+                        let signed = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n                             let repr = adt::represent_type(bcx.ccx(), operand.ty);\n-                            let llval = operand.immediate();\n-                            let discr = bcx.with_block(|bcx| {\n-                                adt::trans_get_discr(bcx, &repr, llval, None, true)\n-                            });\n-                            (discr, common::val_ty(discr), adt::is_discr_signed(&repr))\n+                            adt::is_discr_signed(&repr)\n                         } else {\n-                            (operand.immediate(), ll_t_in, operand.ty.is_signed())\n+                            operand.ty.is_signed()\n                         };\n \n                         let newval = match (r_t_in, r_t_out) {\n@@ -308,8 +348,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         OperandValue::Immediate(newval)\n                     }\n                     mir::CastKind::Misc => { // Casts from a fat-ptr.\n-                        let ll_cast_ty = type_of::arg_type_of(bcx.ccx(), cast_ty);\n-                        let ll_from_ty = type_of::arg_type_of(bcx.ccx(), operand.ty);\n+                        let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n+                        let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n                         if let OperandValue::FatPtr(data_ptr, meta_ptr) = operand.val {\n                             if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n                                 let ll_cft = ll_cast_ty.field_types();\n@@ -423,7 +463,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let llty = type_of::type_of(bcx.ccx(), content_ty);\n                 let llsize = machine::llsize_of(bcx.ccx(), llty);\n                 let align = type_of::align_of(bcx.ccx(), content_ty);\n-                let llalign = common::C_uint(bcx.ccx(), align);\n+                let llalign = C_uint(bcx.ccx(), align);\n                 let llty_ptr = llty.ptr_to();\n                 let box_ty = bcx.tcx().mk_box(content_ty);\n                 let mut llval = None;\n@@ -448,7 +488,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) |\n             mir::Rvalue::Slice { .. } |\n-            mir::Rvalue::InlineAsm(..) => {\n+            mir::Rvalue::InlineAsm { .. } => {\n                 bcx.tcx().sess.bug(&format!(\"cannot generate operand from rvalue {:?}\", rvalue));\n             }\n         }\n@@ -511,15 +551,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if use_fmod {\n                     let f64t = Type::f64(bcx.ccx());\n                     let fty = Type::func(&[f64t, f64t], &f64t);\n-                    let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n-                                                    tcx.types.f64);\n+                    let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty);\n                     if input_ty == tcx.types.f32 {\n                         let lllhs = bcx.fpext(lhs, f64t);\n                         let llrhs = bcx.fpext(rhs, f64t);\n-                        let llres = bcx.call(llfn, &[lllhs, llrhs], None, None);\n+                        let llres = bcx.call(llfn, &[lllhs, llrhs], None);\n                         bcx.fptrunc(llres, Type::f32(bcx.ccx()))\n                     } else {\n-                        bcx.call(llfn, &[lhs, rhs], None, None)\n+                        bcx.call(llfn, &[lhs, rhs], None)\n                     }\n                 } else {\n                     bcx.frem(lhs, rhs)\n@@ -573,7 +612,7 @@ pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) |\n         mir::Rvalue::Slice { .. } |\n-        mir::Rvalue::InlineAsm(..) =>\n+        mir::Rvalue::InlineAsm { .. } =>\n             false,\n     }\n "}, {"sha": "c5ab0d4e74421b2fca47f8cb07d4e6a33e6ed495", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -19,6 +19,7 @@ pub use self::disr::Disr;\n #[macro_use]\n mod macros;\n \n+mod abi;\n mod adt;\n mod asm;\n mod assert_dep_graph;\n@@ -27,7 +28,6 @@ mod base;\n mod basic_block;\n mod build;\n mod builder;\n-mod cabi;\n mod cabi_aarch64;\n mod cabi_arm;\n mod cabi_asmjs;\n@@ -49,11 +49,9 @@ mod debuginfo;\n mod declare;\n mod disr;\n mod expr;\n-mod foreign;\n mod glue;\n mod inline;\n mod intrinsic;\n-mod llrepr;\n mod machine;\n mod _match;\n mod meth;"}, {"sha": "2e75439ffc3292ed75668a717a4e19e861f23ebe", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 95, "deletions": 180, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -17,38 +17,35 @@ use middle::subst;\n use middle::subst::{Subst, Substs};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use trans::attributes;\n-use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n+use trans::base::{push_ctxt};\n use trans::base::trans_fn;\n use trans::base;\n use trans::common::*;\n use trans::declare;\n-use trans::foreign;\n use middle::ty::{self, Ty, TyCtxt};\n use trans::Disr;\n use rustc::front::map as hir_map;\n+use rustc::util::ppaux;\n \n use rustc_front::hir;\n \n-use syntax::abi::Abi;\n-use syntax::ast;\n use syntax::attr;\n use syntax::errors;\n+\n+use std::fmt;\n use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n                                 psubsts: &'tcx subst::Substs<'tcx>)\n-                                -> (ValueRef, Ty<'tcx>, bool) {\n+                                -> (ValueRef, Ty<'tcx>) {\n     debug!(\"monomorphic_fn(fn_id={:?}, real_substs={:?})\", fn_id, psubsts);\n \n     assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n \n-    // we can only monomorphize things in this crate (or inlined into it)\n-    let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n-\n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n-    let hash_id = MonoId {\n+    let instance = Instance {\n         def: fn_id,\n         params: &psubsts.types\n     };\n@@ -59,41 +56,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mono_ty = apply_param_substs(ccx.tcx(), psubsts, &item_ty);\n     debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n \n-    match ccx.monomorphized().borrow().get(&hash_id) {\n+    match ccx.instances().borrow().get(&instance) {\n         Some(&val) => {\n-            debug!(\"leaving monomorphic fn {}\",\n-            ccx.tcx().item_path_str(fn_id));\n-            return (val, mono_ty, false);\n+            debug!(\"leaving monomorphic fn {:?}\", instance);\n+            return (val, mono_ty);\n         }\n         None => ()\n     }\n \n-    debug!(\"monomorphic_fn(\\\n-            fn_id={:?}, \\\n-            psubsts={:?}, \\\n-            hash_id={:?})\",\n-           fn_id,\n-           psubsts,\n-           hash_id);\n-\n-\n-    let map_node = errors::expect(\n-        ccx.sess().diagnostic(),\n-        ccx.tcx().map.find(fn_node_id),\n-        || {\n-            format!(\"while monomorphizing {:?}, couldn't find it in \\\n-                     the item map (may have attempted to monomorphize \\\n-                     an item defined in a different crate?)\",\n-                    fn_id)\n-        });\n-\n-    if let hir_map::NodeForeignItem(_) = map_node {\n-        let abi = ccx.tcx().map.get_foreign_abi(fn_node_id);\n-        if abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic {\n-            // Foreign externs don't have to be monomorphized.\n-            return (get_item_val(ccx, fn_node_id), mono_ty, true);\n-        }\n-    }\n+    debug!(\"monomorphic_fn({:?})\", instance);\n \n     ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n@@ -110,8 +81,13 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n         if depth > ccx.sess().recursion_limit.get() {\n-            ccx.sess().span_fatal(ccx.tcx().map.span(fn_node_id),\n-                \"reached the recursion limit during monomorphization\");\n+            let error = format!(\"reached the recursion limit while instantiating `{}`\",\n+                                instance);\n+            if let Some(id) = ccx.tcx().map.as_local_node_id(fn_id) {\n+                ccx.sess().span_fatal(ccx.tcx().map.span(id), &error);\n+            } else {\n+                ccx.sess().fatal(&error);\n+            }\n         }\n \n         monomorphizing.insert(fn_id, depth + 1);\n@@ -120,173 +96,112 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let hash;\n     let s = {\n         let mut state = SipHasher::new();\n-        hash_id.hash(&mut state);\n+        instance.hash(&mut state);\n         mono_ty.hash(&mut state);\n \n         hash = format!(\"h{}\", state.finish());\n-        let path = ccx.tcx().map.def_path_from_id(fn_node_id);\n+        let path = ccx.tcx().map.def_path(fn_id);\n         exported_name(path, &hash[..])\n     };\n \n     debug!(\"monomorphize_fn mangled to {}\", s);\n+    assert!(declare::get_defined_value(ccx, &s).is_none());\n \n-    // This shouldn't need to option dance.\n-    let mut hash_id = Some(hash_id);\n-    let mut mk_lldecl = |abi: Abi| {\n-        let lldecl = if abi != Abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s)\n-        } else {\n-            // FIXME(nagisa): perhaps needs a more fine grained selection? See\n-            // setup_lldecl below.\n-            declare::define_internal_rust_fn(ccx, &s, mono_ty)\n-        };\n+    // FIXME(nagisa): perhaps needs a more fine grained selection?\n+    let lldecl = declare::define_internal_fn(ccx, &s, mono_ty);\n+    // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n+    attributes::unwind(lldecl, true);\n \n-        ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n-        lldecl\n-    };\n-    let setup_lldecl = |lldecl, attrs: &[ast::Attribute]| {\n-        base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n-        attributes::from_fn_attrs(ccx, attrs, lldecl);\n-\n-        let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n-        if is_first {\n-            ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n-        }\n+    ccx.instances().borrow_mut().insert(instance, lldecl);\n \n-        let trans_everywhere = attr::requests_inline(attrs);\n-        if trans_everywhere && !is_first {\n-            llvm::SetLinkage(lldecl, llvm::AvailableExternallyLinkage);\n-        }\n-\n-        // If `true`, then `lldecl` should be given a function body.\n-        // Otherwise, it should be left as a declaration of an external\n-        // function, with no definition in the current compilation unit.\n-        trans_everywhere || is_first\n-    };\n+    // we can only monomorphize things in this crate (or inlined into it)\n+    let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n+    let map_node = errors::expect(\n+        ccx.sess().diagnostic(),\n+        ccx.tcx().map.find(fn_node_id),\n+        || {\n+            format!(\"while instantiating `{}`, couldn't find it in \\\n+                     the item map (may have attempted to monomorphize \\\n+                     an item defined in a different crate?)\",\n+                    instance)\n+        });\n+    match map_node {\n+        hir_map::NodeItem(&hir::Item {\n+            ref attrs, node: hir::ItemFn(ref decl, _, _, _, _, ref body), ..\n+        }) |\n+        hir_map::NodeTraitItem(&hir::TraitItem {\n+            ref attrs, node: hir::MethodTraitItem(\n+                hir::MethodSig { ref decl, .. }, Some(ref body)), ..\n+        }) |\n+        hir_map::NodeImplItem(&hir::ImplItem {\n+            ref attrs, node: hir::ImplItemKind::Method(\n+                hir::MethodSig { ref decl, .. }, ref body), ..\n+        }) => {\n+            base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n+            attributes::from_fn_attrs(ccx, attrs, lldecl);\n+\n+            let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n+            if is_first {\n+                ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n+            }\n \n-    let lldecl = match map_node {\n-        hir_map::NodeItem(i) => {\n-            match *i {\n-              hir::Item {\n-                  node: hir::ItemFn(ref decl, _, _, abi, _, ref body),\n-                  ..\n-              } => {\n-                  let d = mk_lldecl(abi);\n-                  let needs_body = setup_lldecl(d, &i.attrs);\n-                  if needs_body {\n-                      if abi != Abi::Rust {\n-                          foreign::trans_rust_fn_with_foreign_abi(\n-                              ccx, &decl, &body, &[], d, psubsts, fn_node_id,\n-                              Some(&hash[..]));\n-                      } else {\n-                          trans_fn(ccx,\n-                                   &decl,\n-                                   &body,\n-                                   d,\n-                                   psubsts,\n-                                   fn_node_id,\n-                                   &i.attrs);\n-                      }\n-                  }\n-\n-                  d\n-              }\n-              _ => {\n-                ccx.sess().bug(\"Can't monomorphize this kind of item\")\n-              }\n+            let trans_everywhere = attr::requests_inline(attrs);\n+            if trans_everywhere && !is_first {\n+                llvm::SetLinkage(lldecl, llvm::AvailableExternallyLinkage);\n             }\n-        }\n-        hir_map::NodeVariant(v) => {\n-            let variant = inlined_variant_def(ccx, fn_node_id);\n-            assert_eq!(v.node.name, variant.name);\n-            let d = mk_lldecl(Abi::Rust);\n-            attributes::inline(d, attributes::InlineAttr::Hint);\n-            trans_enum_variant(ccx, fn_node_id, Disr::from(variant.disr_val), psubsts, d);\n-            d\n-        }\n-        hir_map::NodeImplItem(impl_item) => {\n-            match impl_item.node {\n-                hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    let d = mk_lldecl(Abi::Rust);\n-                    let needs_body = setup_lldecl(d, &impl_item.attrs);\n-                    if needs_body {\n-                        trans_fn(ccx,\n-                                 &sig.decl,\n-                                 body,\n-                                 d,\n-                                 psubsts,\n-                                 impl_item.id,\n-                                 &impl_item.attrs);\n-                    }\n-                    d\n-                }\n-                _ => {\n-                    ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                           map_node))\n-                }\n+\n+            if trans_everywhere || is_first {\n+                trans_fn(ccx, decl, body, lldecl, psubsts, fn_node_id);\n             }\n         }\n-        hir_map::NodeTraitItem(trait_item) => {\n-            match trait_item.node {\n-                hir::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    let d = mk_lldecl(Abi::Rust);\n-                    let needs_body = setup_lldecl(d, &trait_item.attrs);\n-                    if needs_body {\n-                        trans_fn(ccx,\n-                                 &sig.decl,\n-                                 body,\n-                                 d,\n-                                 psubsts,\n-                                 trait_item.id,\n-                                 &trait_item.attrs);\n-                    }\n-                    d\n-                }\n-                _ => {\n-                    ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                           map_node))\n+\n+        hir_map::NodeVariant(_) | hir_map::NodeStructCtor(_) => {\n+            let disr = match map_node {\n+                hir_map::NodeVariant(_) => {\n+                    Disr::from(inlined_variant_def(ccx, fn_node_id).disr_val)\n                 }\n-            }\n-        }\n-        hir_map::NodeStructCtor(struct_def) => {\n-            let d = mk_lldecl(Abi::Rust);\n-            attributes::inline(d, attributes::InlineAttr::Hint);\n-            if struct_def.is_struct() {\n-                panic!(\"ast-mapped struct didn't have a ctor id\")\n-            }\n-            base::trans_tuple_struct(ccx,\n-                                     struct_def.id(),\n-                                     psubsts,\n-                                     d);\n-            d\n+                hir_map::NodeStructCtor(_) => Disr(0),\n+                _ => unreachable!()\n+            };\n+            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n+            base::trans_ctor_shim(ccx, fn_node_id, disr, psubsts, lldecl);\n         }\n \n-        // Ugh -- but this ensures any new variants won't be forgotten\n-        hir_map::NodeForeignItem(..) |\n-        hir_map::NodeLifetime(..) |\n-        hir_map::NodeTyParam(..) |\n-        hir_map::NodeExpr(..) |\n-        hir_map::NodeStmt(..) |\n-        hir_map::NodeBlock(..) |\n-        hir_map::NodePat(..) |\n-        hir_map::NodeLocal(..) => {\n-            ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                   map_node))\n-        }\n+        _ => unreachable!(\"can't monomorphize a {:?}\", map_node)\n     };\n \n     ccx.monomorphizing().borrow_mut().insert(fn_id, depth);\n \n     debug!(\"leaving monomorphic fn {}\", ccx.tcx().item_path_str(fn_id));\n-    (lldecl, mono_ty, true)\n+    (lldecl, mono_ty)\n }\n \n-#[derive(PartialEq, Eq, Hash, Debug)]\n-pub struct MonoId<'tcx> {\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Instance<'tcx> {\n     pub def: DefId,\n     pub params: &'tcx subst::VecPerParamSpace<Ty<'tcx>>\n }\n \n+impl<'tcx> fmt::Display for Instance<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let substs = Substs {\n+            types: self.params.clone(),\n+            regions: subst::ErasedRegions\n+        };\n+        ppaux::parameterized(f, &substs, self.def, ppaux::Ns::Value, &[],\n+                             |tcx| tcx.lookup_item_type(self.def).generics)\n+    }\n+}\n+\n+impl<'tcx> Instance<'tcx> {\n+    pub fn mono(tcx: &TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n+        Instance {\n+            def: def_id,\n+            params: &tcx.mk_substs(Substs::trans_empty()).types\n+        }\n+    }\n+}\n+\n /// Monomorphizes a type from the AST by first applying the in-scope\n /// substitutions and then normalizing any associated types.\n pub fn apply_param_substs<'tcx,T>(tcx: &TyCtxt<'tcx>,"}, {"sha": "7a0ca86f5a27087656df902e288232868287dbbd", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -26,27 +26,20 @@ use trans::expr;\n use trans::machine::llsize_of_alloc;\n use trans::type_::Type;\n use trans::type_of;\n+use trans::value::Value;\n use middle::ty::{self, Ty};\n \n use rustc_front::hir;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n struct VecTypes<'tcx> {\n     unit_ty: Ty<'tcx>,\n     llunit_ty: Type\n }\n \n-impl<'tcx> VecTypes<'tcx> {\n-    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"VecTypes {{unit_ty={}, llunit_ty={}}}\",\n-                self.unit_ty,\n-                ccx.tn().type_to_string(self.llunit_ty))\n-    }\n-}\n-\n pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       expr: &hir::Expr,\n                                       dest: expr::Dest)\n@@ -58,8 +51,7 @@ pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(expr={:?}, dest={})\",\n-           expr, dest.to_string(bcx.ccx()));\n+    debug!(\"trans_fixed_vstore(expr={:?}, dest={:?})\", expr, dest);\n \n     let vt = vec_types_from_expr(bcx, expr);\n \n@@ -82,7 +74,6 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    content_expr: &hir::Expr)\n                                    -> DatumBlock<'blk, 'tcx, Expr> {\n     let fcx = bcx.fcx;\n-    let ccx = fcx.ccx;\n     let mut bcx = bcx;\n \n     debug!(\"trans_slice_vec(slice_expr={:?})\",\n@@ -105,7 +96,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"    vt={}, count={}\", vt.to_string(ccx), count);\n+    debug!(\"    vt={:?}, count={}\", vt, count);\n \n     let fixed_ty = bcx.tcx().mk_array(vt.unit_ty, count);\n \n@@ -144,9 +135,7 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  str_lit: InternedString,\n                                  dest: Dest)\n                                  -> Block<'blk, 'tcx> {\n-    debug!(\"trans_lit_str(lit_expr={:?}, dest={})\",\n-           lit_expr,\n-           dest.to_string(bcx.ccx()));\n+    debug!(\"trans_lit_str(lit_expr={:?}, dest={:?})\", lit_expr, dest);\n \n     match dest {\n         Ignore => bcx,\n@@ -172,10 +161,8 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n \n-    debug!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n-           vt.to_string(bcx.ccx()),\n-           dest.to_string(bcx.ccx()),\n-           vstore_expr);\n+    debug!(\"write_content(vt={:?}, dest={:?}, vstore_expr={:?})\",\n+           vt, dest, vstore_expr);\n \n     match content_expr.node {\n         hir::ExprLit(ref lit) => {\n@@ -187,11 +174,9 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             let bytes = s.len();\n                             let llbytes = C_uint(bcx.ccx(), bytes);\n                             let llcstr = C_cstr(bcx.ccx(), (*s).clone(), false);\n-                            base::call_memcpy(bcx,\n-                                              lldest,\n-                                              llcstr,\n-                                              llbytes,\n-                                              1);\n+                            if !bcx.unreachable.get() {\n+                                base::call_memcpy(&B(bcx), lldest, llcstr, llbytes, 1);\n+                            }\n                             return bcx;\n                         }\n                     }\n@@ -214,8 +199,8 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let temp_scope = fcx.push_custom_cleanup_scope();\n                     for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, &[i]);\n-                        debug!(\"writing index {} with lleltptr={}\",\n-                               i, bcx.val_to_string(lleltptr));\n+                        debug!(\"writing index {} with lleltptr={:?}\",\n+                               i, Value(lleltptr));\n                         bcx = expr::trans_into(bcx, &element,\n                                                SaveIn(lleltptr));\n                         let scope = cleanup::CustomScope(temp_scope);"}, {"sha": "57bd0ba81581642b1d2d0961bac97354548b9dc4", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm;\n-use llvm::{TypeRef, Bool, False, True, TypeKind, ValueRef};\n+use llvm::{TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use trans::context::CrateContext;\n@@ -20,18 +20,27 @@ use util::nodemap::FnvHashMap;\n use syntax::ast;\n \n use std::ffi::CString;\n+use std::fmt;\n use std::mem;\n use std::ptr;\n use std::cell::RefCell;\n \n use libc::c_uint;\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n+#[derive(Clone, Copy, PartialEq)]\n #[repr(C)]\n pub struct Type {\n     rf: TypeRef\n }\n \n+impl fmt::Debug for Type {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(&llvm::build_string(|s| unsafe {\n+            llvm::LLVMWriteTypeToString(self.to_ref(), s);\n+        }).expect(\"non-UTF8 type description from LLVM\"))\n+    }\n+}\n+\n macro_rules! ty {\n     ($e:expr) => ( Type::from_ref(unsafe { $e }))\n }\n@@ -50,12 +59,6 @@ impl Type {\n         self.rf\n     }\n \n-    pub fn to_string(self: Type) -> String {\n-        llvm::build_string(|s| unsafe {\n-            llvm::LLVMWriteTypeToString(self.to_ref(), s);\n-        }).expect(\"non-UTF8 type description from LLVM\")\n-    }\n-\n     pub fn to_ref_slice(slice: &[Type]) -> &[TypeRef] {\n         unsafe { mem::transmute(slice) }\n     }\n@@ -180,10 +183,6 @@ impl Type {\n         Type::struct_(ccx, &[], false)\n     }\n \n-    pub fn glue_fn(ccx: &CrateContext, t: Type) -> Type {\n-        Type::func(&[t], &Type::void(ccx))\n-    }\n-\n     pub fn array(ty: &Type, len: u64) -> Type {\n         ty!(llvm::LLVMRustArrayType(ty.to_ref(), len))\n     }\n@@ -203,7 +202,7 @@ impl Type {\n     }\n \n     pub fn vtable_ptr(ccx: &CrateContext) -> Type {\n-        Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to()\n+        Type::func(&[Type::i8p(ccx)], &Type::void(ccx)).ptr_to().ptr_to()\n     }\n \n     pub fn kind(&self) -> TypeKind {\n@@ -301,7 +300,6 @@ impl Type {\n     }\n }\n \n-\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n@@ -323,19 +321,4 @@ impl TypeNames {\n     pub fn find_type(&self, s: &str) -> Option<Type> {\n         self.named_types.borrow().get(s).map(|x| Type::from_ref(*x))\n     }\n-\n-    pub fn type_to_string(&self, ty: Type) -> String {\n-        ty.to_string()\n-    }\n-\n-    pub fn types_to_str(&self, tys: &[Type]) -> String {\n-        let strs: Vec<String> = tys.iter().map(|t| self.type_to_string(*t)).collect();\n-        format!(\"[{}]\", strs.join(\",\"))\n-    }\n-\n-    pub fn val_to_string(&self, val: ValueRef) -> String {\n-        llvm::build_string(|s| unsafe {\n-                llvm::LLVMWriteValueToString(val, s);\n-            }).expect(\"nun-UTF8 value description from LLVM\")\n-    }\n }"}, {"sha": "7d5218d84dafe780f7ce92a0091de2e2f7b681e0", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 20, "deletions": 160, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -13,15 +13,14 @@\n use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n+use trans::abi::FnType;\n use trans::adt;\n use trans::common::*;\n-use trans::foreign;\n use trans::machine;\n use middle::ty::{self, Ty, TypeFoldable};\n \n use trans::type_::Type;\n \n-use syntax::abi::Abi;\n use syntax::ast;\n \n // LLVM doesn't like objects that are too big. Issue #17913\n@@ -36,120 +35,6 @@ fn ensure_array_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn arg_is_indirect<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 arg_ty: Ty<'tcx>) -> bool {\n-    !type_is_immediate(ccx, arg_ty) && !type_is_fat_ptr(ccx.tcx(), arg_ty)\n-}\n-\n-pub fn return_uses_outptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    ty: Ty<'tcx>) -> bool {\n-    arg_is_indirect(ccx, ty)\n-}\n-\n-pub fn type_of_explicit_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                      arg_ty: Ty<'tcx>) -> Type {\n-    let llty = arg_type_of(ccx, arg_ty);\n-    if arg_is_indirect(ccx, arg_ty) {\n-        llty.ptr_to()\n-    } else {\n-        llty\n-    }\n-}\n-\n-/// Yields the types of the \"real\" arguments for a function using the `RustCall`\n-/// ABI by untupling the arguments of the function.\n-pub fn untuple_arguments<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                   inputs: &[Ty<'tcx>])\n-                                   -> Vec<Ty<'tcx>> {\n-    if inputs.is_empty() {\n-        return Vec::new()\n-    }\n-\n-    let mut result = Vec::new();\n-    for (i, &arg_prior_to_tuple) in inputs.iter().enumerate() {\n-        if i < inputs.len() - 1 {\n-            result.push(arg_prior_to_tuple);\n-        }\n-    }\n-\n-    match inputs[inputs.len() - 1].sty {\n-        ty::TyTuple(ref tupled_arguments) => {\n-            debug!(\"untuple_arguments(): untupling arguments\");\n-            for &tupled_argument in tupled_arguments {\n-                result.push(tupled_argument);\n-            }\n-        }\n-        _ => {\n-            ccx.tcx().sess.bug(\"argument to function with \\\"rust-call\\\" ABI \\\n-                                is neither a tuple nor unit\")\n-        }\n-    }\n-\n-    result\n-}\n-\n-pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                 llenvironment_type: Option<Type>,\n-                                 sig: &ty::FnSig<'tcx>,\n-                                 abi: Abi)\n-                                 -> Type\n-{\n-    debug!(\"type_of_rust_fn(sig={:?},abi={:?})\",\n-           sig,\n-           abi);\n-\n-    assert!(!sig.variadic); // rust fns are never variadic\n-\n-    let mut atys: Vec<Type> = Vec::new();\n-\n-    // First, munge the inputs, if this has the `rust-call` ABI.\n-    let inputs_temp;\n-    let inputs = if abi == Abi::RustCall {\n-        inputs_temp = untuple_arguments(cx, &sig.inputs);\n-        &inputs_temp\n-    } else {\n-        &sig.inputs\n-    };\n-\n-    // Arg 0: Output pointer.\n-    // (if the output type is non-immediate)\n-    let lloutputtype = match sig.output {\n-        ty::FnConverging(output) => {\n-            let use_out_pointer = return_uses_outptr(cx, output);\n-            let lloutputtype = arg_type_of(cx, output);\n-            // Use the output as the actual return value if it's immediate.\n-            if use_out_pointer {\n-                atys.push(lloutputtype.ptr_to());\n-                Type::void(cx)\n-            } else if return_type_is_void(cx, output) {\n-                Type::void(cx)\n-            } else {\n-                lloutputtype\n-            }\n-        }\n-        ty::FnDiverging => Type::void(cx)\n-    };\n-\n-    // Arg 1: Environment\n-    match llenvironment_type {\n-        None => {}\n-        Some(llenvironment_type) => atys.push(llenvironment_type),\n-    }\n-\n-    // ... then explicit args.\n-    for input in inputs {\n-        let arg_ty = type_of_explicit_arg(cx, input);\n-\n-        if type_is_fat_ptr(cx.tcx(), input) {\n-            atys.extend(arg_ty.field_types());\n-        } else {\n-            atys.push(arg_ty);\n-        }\n-    }\n-\n-    Type::func(&atys[..], &lloutputtype)\n-}\n-\n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n // guaranteed to be equivalent to what you would get out of `type_of()`. It's\n // useful because:\n@@ -171,7 +56,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n     let llsizingty = match t.sty {\n         _ if !type_is_sized(cx.tcx(), t) => {\n-            Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n+            Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, t)], false)\n         }\n \n         ty::TyBool => Type::bool(cx),\n@@ -186,7 +71,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             if type_is_sized(cx.tcx(), ty) {\n                 Type::i8p(cx)\n             } else {\n-                Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n+                Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, ty)], false)\n             }\n         }\n \n@@ -234,32 +119,27 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => unreachable!()\n     };\n \n-    debug!(\"--> mapped t={:?} to llsizingty={}\",\n-            t,\n-            cx.tn().type_to_string(llsizingty));\n+    debug!(\"--> mapped t={:?} to llsizingty={:?}\", t, llsizingty);\n \n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n     llsizingty\n }\n \n-pub fn foreign_arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if t.is_bool() {\n-        Type::i1(cx)\n-    } else {\n-        type_of(cx, t)\n+fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n+    let unsized_part = ccx.tcx().struct_tail(ty);\n+    match unsized_part.sty {\n+        ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n+            Type::uint_from_ty(ccx, ast::UintTy::Us)\n+        }\n+        ty::TyTrait(_) => Type::vtable_ptr(ccx),\n+        _ => unreachable!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n+                          unsized_part, ty)\n     }\n }\n \n-pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n+pub fn immediate_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     if t.is_bool() {\n         Type::i1(cx)\n-    } else if type_is_immediate(cx, t) && type_of(cx, t).is_aggregate() {\n-        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n-        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n-        match machine::llsize_of_alloc(cx, sizing_type_of(cx, t)) {\n-            0 => type_of(cx, t),\n-            n => Type::ix(cx, n * 8),\n-        }\n     } else {\n         type_of(cx, t)\n     }\n@@ -314,12 +194,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     if t != t_norm {\n         let llty = in_memory_type_of(cx, t_norm);\n-        debug!(\"--> normalized {:?} {:?} to {:?} {:?} llty={}\",\n-                t,\n-                t,\n-                t_norm,\n-                t_norm,\n-                cx.tn().type_to_string(llty));\n+        debug!(\"--> normalized {:?} to {:?} llty={:?}\", t, t_norm, llty);\n         cx.lltypes().borrow_mut().insert(t, llty);\n         return llty;\n     }\n@@ -361,16 +236,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                   cx.tn().find_type(\"str_slice\").unwrap()\n               } else {\n                   let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n-                  let unsized_part = cx.tcx().struct_tail(ty);\n-                  let info_ty = match unsized_part.sty {\n-                      ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n-                          Type::uint_from_ty(cx, ast::UintTy::Us)\n-                      }\n-                      ty::TyTrait(_) => Type::vtable_ptr(cx),\n-                      _ => panic!(\"Unexpected type returned from \\\n-                                   struct_tail: {:?} for ty={:?}\",\n-                                  unsized_part, ty)\n-                  };\n+                  let info_ty = unsized_info_ty(cx, ty);\n                   Type::struct_(cx, &[ptr_ty, info_ty], false)\n               }\n           } else {\n@@ -398,13 +264,9 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n       ty::TyFnDef(..) => Type::nil(cx),\n       ty::TyFnPtr(f) => {\n-        if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-            let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n-            let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-            type_of_rust_fn(cx, None, &sig, f.abi).ptr_to()\n-        } else {\n-            foreign::lltype_for_foreign_fn(cx, t).ptr_to()\n-        }\n+        let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n+        let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n+        FnType::new(cx, f.abi, &sig, &[]).llvm_type(cx).ptr_to()\n       }\n       ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::TyTuple(..) => {\n@@ -440,9 +302,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyError => cx.sess().bug(\"type_of with TyError\"),\n     };\n \n-    debug!(\"--> mapped t={:?} to llty={}\",\n-            t,\n-            cx.tn().type_to_string(llty));\n+    debug!(\"--> mapped t={:?} to llty={:?}\", t, llty);\n \n     cx.lltypes().borrow_mut().insert(t, llty);\n "}, {"sha": "a33b7d62d2dcefd17efaa3263ff3cddc9ffeaa13", "filename": "src/librustc_trans/trans/value.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -12,11 +12,22 @@ use llvm;\n use llvm::{UseRef, ValueRef};\n use trans::basic_block::BasicBlock;\n use trans::common::Block;\n+\n+use std::fmt;\n+\n use libc::c_uint;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq)]\n pub struct Value(pub ValueRef);\n \n+impl fmt::Debug for Value {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(&llvm::build_string(|s| unsafe {\n+            llvm::LLVMWriteValueToString(self.0, s);\n+        }).expect(\"nun-UTF8 value description from LLVM\"))\n+    }\n+}\n+\n macro_rules! opt_val { ($e:expr) => (\n     unsafe {\n         match $e {"}, {"sha": "903fc458d818564c891688938095021698c30b94", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -3416,12 +3416,12 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n               fcx.add_wf_bounds(&item_substs.substs, expr);\n           });\n       }\n-      hir::ExprInlineAsm(ref ia) => {\n-          for &(_, ref input) in &ia.inputs {\n-              check_expr(fcx, &input);\n+      hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n+          for output in outputs {\n+              check_expr(fcx, output);\n           }\n-          for out in &ia.outputs {\n-              check_expr(fcx, &out.expr);\n+          for input in inputs {\n+              check_expr(fcx, input);\n           }\n           fcx.write_nil(id);\n       }"}, {"sha": "258c7af1316eb1b9d5bf72466840fc1bda1c5029", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -2155,7 +2155,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     let input_tys = decl.inputs\n                         .iter()\n                         .map(|a| ty_of_arg(&ccx.icx(ast_generics), &rb, a, None))\n-                        .collect();\n+                        .collect::<Vec<_>>();\n \n     let output = match decl.output {\n         hir::Return(ref ty) =>\n@@ -2166,6 +2166,29 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n             ty::FnDiverging\n     };\n \n+    // feature gate SIMD types in FFI, since I (huonw) am not sure the\n+    // ABIs are handled at all correctly.\n+    if abi != abi::Abi::RustIntrinsic && abi != abi::Abi::PlatformIntrinsic\n+            && !ccx.tcx.sess.features.borrow().simd_ffi {\n+        let check = |ast_ty: &hir::Ty, ty: ty::Ty| {\n+            if ty.is_simd() {\n+                ccx.tcx.sess.struct_span_err(ast_ty.span,\n+                              &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n+                                        may result in invalid code\",\n+                                       pprust::ty_to_string(ast_ty)))\n+                    .fileline_help(ast_ty.span,\n+                                   \"add #![feature(simd_ffi)] to the crate attributes to enable\")\n+                    .emit();\n+            }\n+        };\n+        for (input, ty) in decl.inputs.iter().zip(&input_tys) {\n+            check(&input.ty, ty)\n+        }\n+        if let hir::Return(ref ty) = decl.output {\n+            check(&ty, output.unwrap())\n+        }\n+    }\n+\n     let substs = ccx.tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n     let t_fn = ccx.tcx.mk_fn_def(id, substs, ty::BareFnTy {\n         abi: abi,"}, {"sha": "49091a6c2bcfc9ea87d1686a3bcc6bc2791240ef", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -336,7 +336,7 @@ pub fn build_impl(cx: &DocContext,\n                 let did = assoc_const.def_id;\n                 let type_scheme = tcx.lookup_item_type(did);\n                 let default = if assoc_const.has_value {\n-                    Some(const_eval::lookup_const_by_id(tcx, did, None, None)\n+                    Some(const_eval::lookup_const_by_id(tcx, did, None)\n                          .unwrap().0.span.to_src(cx))\n                 } else {\n                     None\n@@ -479,7 +479,7 @@ fn build_const(cx: &DocContext, tcx: &TyCtxt,\n     use rustc::middle::const_eval;\n     use rustc_front::print::pprust;\n \n-    let (expr, ty) = const_eval::lookup_const_by_id(tcx, did, None, None).unwrap_or_else(|| {\n+    let (expr, ty) = const_eval::lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);"}, {"sha": "85e48f85d3d901591e24d2e52930799c781e97d4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -251,6 +251,7 @@\n #![feature(raw)]\n #![feature(repr_simd)]\n #![feature(reflect_marker)]\n+#![feature(rustc_attrs)]\n #![feature(shared)]\n #![feature(slice_bytes)]\n #![feature(slice_concat_ext)]"}, {"sha": "e78d46b22e9409ac2332d9281745544705bfd022", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -1371,6 +1371,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[rustc_no_mir] // FIXME #27840 MIR NAN ends up negative.\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n         assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));"}, {"sha": "cea5a9edd680be281b3ea09f5428549fda74ec94", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -1264,6 +1264,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[rustc_no_mir] // FIXME #27840 MIR NAN ends up negative.\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n         assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));"}, {"sha": "a017e62d546319518e325dfbe2e13f86167ccd3d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -350,10 +350,14 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                            \"the `#[rustc_move_fragments]` attribute \\\n                                             is just used for rustc unit tests \\\n                                             and will never be stable\")),\n-    (\"rustc_mir\", Normal, Gated(\"rustc_attrs\",\n-                                \"the `#[rustc_mir]` attribute \\\n-                                 is just used for rustc unit tests \\\n-                                 and will never be stable\")),\n+    (\"rustc_mir\", Whitelisted, Gated(\"rustc_attrs\",\n+                                     \"the `#[rustc_mir]` attribute \\\n+                                      is just used for rustc unit tests \\\n+                                      and will never be stable\")),\n+    (\"rustc_no_mir\", Whitelisted, Gated(\"rustc_attrs\",\n+                                        \"the `#[rustc_no_mir]` attribute \\\n+                                         is just used to make tests pass \\\n+                                         and will never be stable\")),\n \n     (\"allow_internal_unstable\", Normal, Gated(\"allow_internal_unstable\",\n                                               EXPLAIN_ALLOW_INTERNAL_UNSTABLE)),"}, {"sha": "20d049394345256dad72cc965d5d1c670b1f0f12", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,6 +11,7 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n \n // Hack to get the correct size for the length part in slices\n // CHECK: @helper([[USIZE:i[0-9]+]])\n@@ -20,6 +21,7 @@ fn helper(_: usize) {\n \n // CHECK-LABEL: @no_op_slice_adjustment\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn no_op_slice_adjustment(x: &[u8]) -> &[u8] {\n     // We used to generate an extra alloca and memcpy for the block's trailing expression value, so\n     // check that we copy directly to the return value slot"}, {"sha": "74c7192259ac4044108f287b39fb09114773b5eb", "filename": "src/test/codegen/coercions.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fcoercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fcoercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcoercions.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,19 +11,22 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n \n static X: i32 = 5;\n \n // CHECK-LABEL: @raw_ptr_to_raw_ptr_noop\n // CHECK-NOT: alloca\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn raw_ptr_to_raw_ptr_noop() -> *const i32{\n     &X as *const i32\n }\n \n // CHECK-LABEL: @reference_to_raw_ptr_noop\n // CHECK-NOT: alloca\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn reference_to_raw_ptr_noop() -> *const i32 {\n     &X\n }"}, {"sha": "ea4c932d43549ce74efb7c6204950922d473e01a", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,6 +11,7 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n \n // Below, these constants are defined as enum variants that by itself would\n // have a lower alignment than the enum type. Ensure that we mark them\n@@ -39,18 +40,21 @@ pub static STATIC: E<i16, i32> = E::A(0);\n \n // CHECK-LABEL: @static_enum_const\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn static_enum_const() -> E<i16, i32> {\n    STATIC\n }\n \n // CHECK-LABEL: @inline_enum_const\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn inline_enum_const() -> E<i8, i16> {\n     E::A(0)\n }\n \n // CHECK-LABEL: @low_align_const\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n // Check that low_align_const and high_align_const use the same constant\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{[0-9]+}}, i8* {{.*}} [[LOW_HIGH:@const[0-9]+]]\n@@ -59,6 +63,7 @@ pub fn low_align_const() -> E<i16, [i16; 3]> {\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn high_align_const() -> E<i16, i32> {\n // Check that low_align_const and high_align_const use the same constant\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{[0-9]}}, i8* {{.*}} [[LOW_HIGH]]"}, {"sha": "83dd6a3b00258ec5ee4af95d2ff11877cf98cc73", "filename": "src/test/codegen/drop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,6 +11,7 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n \n struct SomeUniqueName;\n \n@@ -24,6 +25,7 @@ pub fn possibly_unwinding() {\n \n // CHECK-LABEL: @droppy\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn droppy() {\n // Check that there are exactly 6 drop calls. The cleanups for the unwinding should be reused, so\n // that's one new drop call per call to possibly_unwinding(), and finally 3 drop calls for the"}, {"sha": "7ee31070b2635ea3895e5a5966c87b79a7345b8d", "filename": "src/test/codegen/extern-functions.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fextern-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fextern-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fextern-functions.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -22,3 +22,8 @@ extern {\n     #[unwind]\n     fn unwinding_extern_fn();\n }\n+\n+pub unsafe fn force_declare() {\n+    extern_fn();\n+    unwinding_extern_fn();\n+}"}, {"sha": "36c83412e4f0f4775d73e65356841c27b6f86aa4", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,6 +11,7 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n \n // Hack to get the correct size for the length part in slices\n // CHECK: @helper([[USIZE:i[0-9]+]])\n@@ -20,6 +21,7 @@ fn helper(_: usize) {\n \n // CHECK-LABEL: @ref_dst\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\""}, {"sha": "f849a6c9b18b847b0ec491c51331484e8feccb5c", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,6 +11,7 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n \n pub struct Bytes {\n   a: u8,\n@@ -23,25 +24,20 @@ pub struct Bytes {\n // The array is stored as i32, but its alignment is lower, go with 1 byte to avoid target\n // dependent alignment\n #[no_mangle]\n-pub fn small_array_alignment(x: &mut [i8; 4]) {\n-// CHECK: [[VAR:%[0-9]+]] = load {{(\\[4 x i8\\]\\*, )?}}[4 x i8]** %x\n-// CHECK: [[VAR2:%[0-9]+]] = bitcast [4 x i8]* [[VAR]] to i32*\n-// CHECK: store i32 %{{.*}}, i32* [[VAR2]], align 1\n-    *x = [0; 4];\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n+pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n+// CHECK: [[VAR:%[0-9]+]] = bitcast [4 x i8]* %y to i32*\n+// CHECK: store i32 %{{.*}}, i32* [[VAR]], align 1\n+    *x = y;\n }\n \n // CHECK-LABEL: small_struct_alignment\n // The struct is stored as i32, but its alignment is lower, go with 1 byte to avoid target\n // dependent alignment\n #[no_mangle]\n-pub fn small_struct_alignment(x: &mut Bytes) {\n-// CHECK: [[VAR:%[0-9]+]] = load {{(%Bytes\\*, )?}}%Bytes** %x\n-// CHECK: [[VAR2:%[0-9]+]] = bitcast %Bytes* [[VAR]] to i32*\n-// CHECK: store i32 %{{.*}}, i32* [[VAR2]], align 1\n-    *x = Bytes {\n-        a: 0,\n-        b: 0,\n-        c: 0,\n-        d: 0,\n-    };\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n+pub fn small_struct_alignment(x: &mut Bytes, y: Bytes) {\n+// CHECK: [[VAR:%[0-9]+]] = bitcast %Bytes* %y to i32*\n+// CHECK: store i32 %{{.*}}, i32* [[VAR]], align 1\n+    *x = y;\n }"}, {"sha": "882e4cb2d47e29e99d25056cd82bcdcf4f980c20", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(exceeding_bitshifts)]\n-#[deny(const_err)]\n+#![feature(rustc_attrs)]\n+#![allow(exceeding_bitshifts)]\n+#![deny(const_err)]\n \n fn black_box<T>(_: T) {\n     unimplemented!()\n@@ -18,6 +19,7 @@ fn black_box<T>(_: T) {\n const BLA: u8 = 200u8 + 200u8;\n //~^ ERROR attempted to add with overflow\n \n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let a = -std::i8::MIN;\n     //~^ WARN attempted to negate with overflow"}, {"sha": "96013551ef4927ea17028eaa21e2ae96b31dafde", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n #![allow(unused_imports)]\n \n // Note: the relevant lint pass here runs before some of the constant\n@@ -103,6 +104,7 @@ const VALS_U64: (u64, u64, u64, u64) =\n      //~^ ERROR attempted to multiply with overflow\n      );\n \n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     foo(VALS_I8);\n     foo(VALS_I16);"}, {"sha": "3c0e545e19335d1d7b2e27b9f2f40c15c5ed47cc", "filename": "src/test/compile-fail/dupe-symbols-8.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdupe-symbols-8.rs?ref=2de6ddd75e202acdedfcd05b51a863dcc10459ca", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// error-pattern:already defined\n-\n-\n-#![allow(warnings)]\n-\n-fn main() {\n-    {\n-        extern fn fail() {}\n-    }\n-    {\n-        extern fn fail() {}\n-    }\n-}"}, {"sha": "949000dfed6ace36d779db53888756fabd7f0de6", "filename": "src/test/compile-fail/fn-item-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -42,6 +42,6 @@ fn main() {\n     // Make sure we distinguish between trait methods correctly.\n     eq(<u8 as Foo>::foo, <u16 as Foo>::foo);\n     //~^ ERROR mismatched types\n-    //~|  expected `fn() {Foo::foo}`\n-    //~|  found `fn() {Foo::foo}`\n+    //~|  expected `fn() {<u8 as Foo>::foo}`\n+    //~|  found `fn() {<u16 as Foo>::foo}`\n }"}, {"sha": "d293a1816d89e01c0d2f471df0d041ad87f6cbab", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -31,7 +31,7 @@ impl<T:Clone> ToOpt for Option<T> {\n }\n \n fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n-//~^ ERROR reached the recursion limit during monomorphization\n+//~^ ERROR reached the recursion limit while instantiating `function::<core::option::Option<\n     if counter > 0 {\n         function(counter - 1, t.to_option());\n         // FIXME(#4287) Error message should be here. It should be"}, {"sha": "906056896be1e6eb3810283737655a019d6e4ee9", "filename": "src/test/compile-fail/intrinsic-return-address.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -15,15 +15,10 @@ extern \"rust-intrinsic\" {\n     fn return_address() -> *const u8;\n }\n \n-unsafe fn f() {\n-    let _ = return_address();\n-    //~^ ERROR invalid use of `return_address` intrinsic: function does not use out pointer\n-}\n+unsafe fn f() { let _ = return_address(); }\n+//~^ ERROR invalid use of `return_address` intrinsic: function does not use out pointer\n \n-unsafe fn g() -> isize {\n-    let _ = return_address();\n-    //~^ ERROR invalid use of `return_address` intrinsic: function does not use out pointer\n-    0\n-}\n+unsafe fn g() -> isize { let _ = return_address(); 0 }\n+//~^ ERROR invalid use of `return_address` intrinsic: function does not use out pointer\n \n fn main() {}"}, {"sha": "0c8c2311dcaa583eb662b00dda4ce4bdadea8f8a", "filename": "src/test/compile-fail/issue-22638.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -17,7 +17,7 @@ struct A (B);\n \n impl A {\n     pub fn matches<F: Fn()>(&self, f: &F) {\n-        //~^ ERROR reached the recursion limit during monomorphization\n+        //~^ ERROR reached the recursion limit while instantiating `A::matches::<[closure\n         let &A(ref term) = self;\n         term.matches(f);\n     }"}, {"sha": "525ec855762840a4100d41822a27ccdceaf539a5", "filename": "src/test/compile-fail/issue-8727.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:reached the recursion limit during monomorphization\n+// error-pattern:reached the recursion limit while instantiating `generic::<core::option::Option<\n \n // Verify the compiler fails with an error on infinite function\n // recursions."}, {"sha": "2a127d937eaaafb39d7e2d4fdf7eca760bf36bb1", "filename": "src/test/compile-fail/linkage2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Flinkage2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Flinkage2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage2.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -12,7 +12,7 @@\n \n extern {\n     #[linkage = \"extern_weak\"] static foo: i32;\n-    //~^ ERROR: must have type `*T`\n+    //~^ ERROR: must have type `*const T` or `*mut T`\n }\n \n fn main() {"}, {"sha": "33954d23b19cbb0bf59bfa200be86d019a4a13b2", "filename": "src/test/compile-fail/simd-intrinsic-generic-arithmetic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-arithmetic.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics)]\n+#![feature(repr_simd, platform_intrinsics, rustc_attrs)]\n #![allow(non_camel_case_types)]\n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -34,6 +34,7 @@ extern \"platform-intrinsic\" {\n     fn simd_xor<T>(x: T, y: T) -> T;\n }\n \n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n fn main() {\n     let x = i32x4(0, 0, 0, 0);\n     let y = u32x4(0, 0, 0, 0);"}, {"sha": "cb3bed7209e2d6596eb219221254d46c695e88fb", "filename": "src/test/compile-fail/simd-intrinsic-generic-cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-cast.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics)]\n+#![feature(repr_simd, platform_intrinsics, rustc_attrs)]\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -35,6 +35,7 @@ extern \"platform-intrinsic\" {\n     fn simd_cast<T, U>(x: T) -> U;\n }\n \n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n fn main() {\n     let x = i32x4(0, 0, 0, 0);\n "}, {"sha": "0e7b2bd490470832fe7e61a6a786d7cf172ed20a", "filename": "src/test/compile-fail/simd-intrinsic-generic-comparison.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-comparison.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics)]\n+#![feature(repr_simd, platform_intrinsics, rustc_attrs)]\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -29,6 +29,7 @@ extern \"platform-intrinsic\" {\n     fn simd_ge<T, U>(x: T, y: T) -> U;\n }\n \n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n fn main() {\n     let x = i32x4(0, 0, 0, 0);\n "}, {"sha": "1f4cc72ffe717c2031de22da23096302aec09426", "filename": "src/test/compile-fail/simd-intrinsic-generic-elements.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-elements.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics)]\n+#![feature(repr_simd, platform_intrinsics, rustc_attrs)]\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -56,6 +56,7 @@ extern \"platform-intrinsic\" {\n     fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n }\n \n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n fn main() {\n     let x = i32x4(0, 0, 0, 0);\n "}, {"sha": "fedb68a26afc928296698379e40547bc5b200191", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -41,37 +41,37 @@\n     ((::std::fmt::format as\n          fn(core::fmt::Arguments<'_>) -> collections::string::String {collections::fmt::format})(((::std::fmt::Arguments::new_v1\n                                                                                                       as\n-                                                                                                      fn(&[&str], &[core::fmt::ArgumentV1<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new_v1})(({\n-                                                                                                                                                                                                                     static __STATIC_FMTSTR:\n-                                                                                                                                                                                                                            &'static [&'static str]\n-                                                                                                                                                                                                                            =\n-                                                                                                                                                                                                                         (&([(\"test\"\n+                                                                                                      fn(&[&str], &[core::fmt::ArgumentV1<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a><'_>::new_v1})(({\n+                                                                                                                                                                                                                         static __STATIC_FMTSTR:\n+                                                                                                                                                                                                                                &'static [&'static str]\n+                                                                                                                                                                                                                                =\n+                                                                                                                                                                                                                             (&([(\"test\"\n+                                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                                     &'static str)]\n+                                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                                   [&'static str; 1])\n                                                                                                                                                                                                                                  as\n-                                                                                                                                                                                                                                 &'static str)]\n-                                                                                                                                                                                                                               as\n-                                                                                                                                                                                                                               [&'static str; 1])\n-                                                                                                                                                                                                                             as\n-                                                                                                                                                                                                                             &'static [&'static str; 1]);\n-                                                                                                                                                                                                                     (__STATIC_FMTSTR\n-                                                                                                                                                                                                                         as\n-                                                                                                                                                                                                                         &'static [&'static str])\n-                                                                                                                                                                                                                 }\n-                                                                                                                                                                                                                    as\n-                                                                                                                                                                                                                    &[&str]),\n-                                                                                                                                                                                                                (&(match (()\n+                                                                                                                                                                                                                                 &'static [&'static str; 1]);\n+                                                                                                                                                                                                                         (__STATIC_FMTSTR\n                                                                                                                                                                                                                              as\n-                                                                                                                                                                                                                             ())\n-                                                                                                                                                                                                                       {\n-                                                                                                                                                                                                                       ()\n-                                                                                                                                                                                                                       =>\n-                                                                                                                                                                                                                       ([]\n-                                                                                                                                                                                                                           as\n-                                                                                                                                                                                                                           [core::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                                                   }\n-                                                                                                                                                                                                                      as\n-                                                                                                                                                                                                                      [core::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                                    as\n-                                                                                                                                                                                                                    &[core::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                                                                                                                                             &'static [&'static str])\n+                                                                                                                                                                                                                     }\n+                                                                                                                                                                                                                        as\n+                                                                                                                                                                                                                        &[&str]),\n+                                                                                                                                                                                                                    (&(match (()\n+                                                                                                                                                                                                                                 as\n+                                                                                                                                                                                                                                 ())\n+                                                                                                                                                                                                                           {\n+                                                                                                                                                                                                                           ()\n+                                                                                                                                                                                                                           =>\n+                                                                                                                                                                                                                           ([]\n+                                                                                                                                                                                                                               as\n+                                                                                                                                                                                                                               [core::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                                       }\n+                                                                                                                                                                                                                          as\n+                                                                                                                                                                                                                          [core::fmt::ArgumentV1<'_>; 0])\n+                                                                                                                                                                                                                        as\n+                                                                                                                                                                                                                        &[core::fmt::ArgumentV1<'_>; 0]))\n                                                                                                      as\n                                                                                                      core::fmt::Arguments<'_>))\n         as collections::string::String);"}, {"sha": "d3817b25d6100f6d364ec3515c20102ad0e7b665", "filename": "src/test/run-fail/divide-by-zero.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:attempted to divide by zero\n+\n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let y = 0;\n     let _z = 1 / y;"}, {"sha": "7a151c8c572f6dfe7db13bf5576f34e1c9a1acb5", "filename": "src/test/run-fail/mod-zero.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmod-zero.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:attempted remainder with a divisor of zero\n+\n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let y = 0;\n     let _z = 1 % y;"}, {"sha": "c989cc594536ba11c02a1a65a218eef1dc01929c", "filename": "src/test/run-fail/overflowing-add.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-add.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,10 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'arithmetic operation overflowed'\n // compile-flags: -C debug-assertions\n \n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 200u8 + 200u8 + 200u8;\n }"}, {"sha": "a27210112982a6a76f932f21264f2d757ce8efe8", "filename": "src/test/run-fail/overflowing-lsh-1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,11 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 1_i32 << 32;\n }"}, {"sha": "fe0bcc5b98545f62ec02fae195cd229d648a4437", "filename": "src/test/run-fail/overflowing-lsh-2.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,11 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 1 << -1;\n }"}, {"sha": "aac220d32d9ce4dfa51e12670fb866914d31d5b7", "filename": "src/test/run-fail/overflowing-lsh-3.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,11 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 1_u64 << 64;\n }"}, {"sha": "7e8b266da49bee83dcbd81e26ba980107861a028", "filename": "src/test/run-fail/overflowing-lsh-4.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n@@ -16,6 +18,8 @@\n \n #![warn(exceeding_bitshifts)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     // this signals overflow when checking is on\n     let x = 1_i8 << 17;"}, {"sha": "8cba700bbf9a3e0b59faa56765dadaf25407a4b4", "filename": "src/test/run-fail/overflowing-mul.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'arithmetic operation overflowed'\n // compile-flags: -C debug-assertions\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let x = 200u8 * 4;\n }"}, {"sha": "2d9d746bef324517277816ca0a88064601a8ea48", "filename": "src/test/run-fail/overflowing-neg.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-neg.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'attempted to negate with overflow'\n // compile-flags: -C debug-assertions\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = -std::i8::MIN;\n }"}, {"sha": "63c808dc80a4ecebe1b0caa986d2f519d70d0b57", "filename": "src/test/run-fail/overflowing-rsh-1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,11 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = -1_i32 >> 32;\n }"}, {"sha": "8b89e57c85bb5e33e254d83c4ae244e271dc4347", "filename": "src/test/run-fail/overflowing-rsh-2.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,11 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = -1_i32 >> -1;\n }"}, {"sha": "8874587064c35ec26f45bf7cc1e4ebdc09f565ba", "filename": "src/test/run-fail/overflowing-rsh-3.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,11 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = -1_i64 >> 64;\n }"}, {"sha": "d74fd8a6b8e417abcd3d87c568668898dbea34c0", "filename": "src/test/run-fail/overflowing-rsh-4.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n@@ -16,6 +18,8 @@\n \n #![warn(exceeding_bitshifts)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     // this signals overflow when checking is on\n     let x = 2_i8 >> 17;"}, {"sha": "249b952a5dca2643fec1d751066561c8327a3e64", "filename": "src/test/run-fail/overflowing-rsh-5.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-5.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,11 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _n = 1i64 >> [64][0];\n }"}, {"sha": "1227f35444a60399a1f60125f405c1e3079fbf6c", "filename": "src/test/run-fail/overflowing-rsh-6.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-6.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n #![feature(const_indexing)]\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _n = 1i64 >> [64][0];\n }"}, {"sha": "ce243a50e0b66f2065b84c038af2279041d09404", "filename": "src/test/run-fail/overflowing-sub.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // error-pattern:thread '<main>' panicked at 'arithmetic operation overflowed'\n // compile-flags: -C debug-assertions\n \n+#![feature(rustc_attrs)]\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let _x = 42u8 - (42u8 + 1);\n }"}, {"sha": "fb54161c2c127db8dafd85cd069a9905bc173a89", "filename": "src/test/run-make/debug-assertions/debug.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-make%2Fdebug-assertions%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-make%2Fdebug-assertions%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdebug-assertions%2Fdebug.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n #![deny(warnings)]\n \n use std::env;\n@@ -36,6 +37,7 @@ fn debug_assert() {\n }\n \n fn overflow() {\n+    #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n     fn add(a: u8, b: u8) -> u8 { a + b }\n \n     add(200u8, 200u8);"}, {"sha": "ab85d2bb13fb16b9519475a1a8aadbf86f5161b0", "filename": "src/test/run-make/issue-25581/test.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-make%2Fissue-25581%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-make%2Fissue-25581%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-25581%2Ftest.c?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -2,15 +2,10 @@\n #include <stddef.h>\n #include <stdint.h>\n \n-struct ByteSlice {\n-        uint8_t *data;\n-        size_t len;\n-};\n-\n-size_t slice_len(struct ByteSlice bs) {\n-        return bs.len;\n+size_t slice_len(uint8_t *data, size_t len) {\n+    return len;\n }\n \n-uint8_t slice_elem(struct ByteSlice bs, size_t idx) {\n-        return bs.data[idx];\n+uint8_t slice_elem(uint8_t *data, size_t len, size_t idx) {\n+    return data[idx];\n }"}, {"sha": "0de949471c68407cf66129e7aaa16d494d473d6d", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // no-prefer-dynamic\n \n #![allow(dead_code)]\n-#![feature(const_fn)]\n+#![feature(const_fn, rustc_attrs)]\n \n // check dtor calling order when casting enums.\n \n@@ -36,6 +38,7 @@ impl Drop for E {\n     }\n }\n \n+#[rustc_no_mir] // FIXME #27840 MIR miscompiles this.\n fn main() {\n     assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n     {"}, {"sha": "b80c938fed5d42bb0c6fe3651c9195dee985f4e4", "filename": "src/test/run-pass/backtrace-debuginfo-aux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,6 +11,7 @@\n // ignore-test: not a test, used by backtrace-debuginfo.rs to test file!()\n \n #[inline(never)]\n+#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n pub fn callback<F>(f: F) where F: FnOnce((&'static str, u32)) {\n     f((file!(), line!()))\n }\n@@ -20,6 +21,7 @@ pub fn callback<F>(f: F) where F: FnOnce((&'static str, u32)) {\n // this case.\n #[cfg_attr(not(target_env = \"msvc\"), inline(always))]\n #[cfg_attr(target_env = \"msvc\", inline(never))]\n+#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n pub fn callback_inlined<F>(f: F) where F: FnOnce((&'static str, u32)) {\n     f((file!(), line!()))\n }"}, {"sha": "fd1c01723395d3182d6d3a48f9d0c586fc240a98", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n+\n // We disable tail merging here because it can't preserve debuginfo and thus\n // potentially breaks the backtraces. Also, subtle changes can decide whether\n // tail merging suceeds, so the test might work today but fail tomorrow due to a\n@@ -72,6 +74,7 @@ fn dump_filelines(filelines: &[Pos]) {\n }\n \n #[inline(never)]\n+#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n fn inner(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n     check!(counter; main_pos, outer_pos);\n     check!(counter; main_pos, outer_pos);\n@@ -88,6 +91,7 @@ fn inner(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n // this case.\n #[cfg_attr(not(target_env = \"msvc\"), inline(always))]\n #[cfg_attr(target_env = \"msvc\", inline(never))]\n+#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n fn inner_inlined(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n     check!(counter; main_pos, outer_pos);\n     check!(counter; main_pos, outer_pos);\n@@ -113,6 +117,7 @@ fn inner_inlined(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n }\n \n #[inline(never)]\n+#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n fn outer(mut counter: i32, main_pos: Pos) {\n     inner(&mut counter, main_pos, pos!());\n     inner_inlined(&mut counter, main_pos, pos!());\n@@ -157,6 +162,7 @@ fn run_test(me: &str) {\n }\n \n #[inline(never)]\n+#[rustc_no_mir] // FIXME #31005 MIR missing debuginfo currently.\n fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() >= 2 {"}, {"sha": "1736ab5bb82c81510e98cc4d80e3564a3e5639b8", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n+\n+// ignore-pretty : (#23623) problems when  ending with // comments\n \n use std::{str, string};\n \n const A: [u8; 2] = ['h' as u8, 'i' as u8];\n const B: &'static [u8; 2] = &A;\n const C: *const u8 = B as *const u8;\n \n+#[rustc_no_mir] // FIXME #27840 MIR can't do rvalue promotion yet.\n pub fn main() {\n     unsafe {\n         let foo = &A as *const u8;"}, {"sha": "73c52a0843cfbd870c383fa30123b0343d1c239a", "filename": "src/test/run-pass/issue-23338-ensure-param-drop-order.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fissue-23338-ensure-param-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fissue-23338-ensure-param-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23338-ensure-param-drop-order.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n+\n // ignore-pretty : (#23623) problems when  ending with // comments\n \n // This test is ensuring that parameters are indeed dropped after\n@@ -64,6 +66,7 @@ fn test<'a>(log: d::Log<'a>) {\n     d::println(&format!(\"result {}\", result));\n }\n \n+#[rustc_no_mir] // FIXME #29855 MIR doesn't handle all drops correctly.\n fn foo<'a>(da0: D<'a>, de1: D<'a>) -> D<'a> {\n     d::println(\"entered foo\");\n     let de2 = de1.incr();      // creates D(de_2, 2)"}, {"sha": "7589bce31f480ca7faeb98051748ee4878a82777", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -9,31 +9,44 @@\n // except according to those terms.\n \n // ignore-emscripten no threads support\n+// ignore-pretty : (#23623) problems when  ending with // comments\n \n-#![feature(zero_one)]\n+#![feature(rustc_attrs, stmt_expr_attributes, zero_one)]\n \n use std::num::Zero;\n use std::thread;\n \n+macro_rules! check {\n+    ($($e:expr),*) => {\n+        $(assert!(thread::spawn({\n+            #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n+            move|| { $e; }\n+        }).join().is_err());)*\n+    }\n+}\n+\n+#[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n-    assert!(thread::spawn(move|| { isize::min_value() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { i8::min_value() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { i16::min_value() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { i32::min_value() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { i64::min_value() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { 1isize / isize::zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i8 / i8::zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i16 / i16::zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i32 / i32::zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i64 / i64::zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { isize::min_value() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { i8::min_value() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { i16::min_value() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { i32::min_value() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { i64::min_value() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { 1isize % isize::zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i8 % i8::zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i16 % i16::zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i32 % i32::zero(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i64 % i64::zero(); }).join().is_err());\n+    check![\n+        isize::min_value() / -1,\n+        i8::min_value() / -1,\n+        i16::min_value() / -1,\n+        i32::min_value() / -1,\n+        i64::min_value() / -1,\n+        1isize / isize::zero(),\n+        1i8 / i8::zero(),\n+        1i16 / i16::zero(),\n+        1i32 / i32::zero(),\n+        1i64 / i64::zero(),\n+        isize::min_value() % -1,\n+        i8::min_value() % -1,\n+        i16::min_value() % -1,\n+        i32::min_value() % -1,\n+        i64::min_value() % -1,\n+        1isize % isize::zero(),\n+        1i8 % i8::zero(),\n+        1i16 % i16::zero(),\n+        1i32 % i32::zero(),\n+        1i64 % i64::zero()\n+    ];\n }"}, {"sha": "c0ba7a76dba480515e42dc683236966c922bc06b", "filename": "src/test/run-pass/mir_raw_fat_ptr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -10,6 +10,8 @@\n \n #![feature(rustc_attrs)]\n \n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n // check raw fat pointer ops in mir\n // FIXME: please improve this when we get monomorphization support\n \n@@ -119,6 +121,7 @@ impl<T> Foo for T {\n \n struct S<T:?Sized>(u32, T);\n \n+#[rustc_no_mir] // FIXME #27840 MIR can't do rvalue promotion yet.\n fn main() {\n     let array = [0,1,2,3,4];\n     let array2 = [5,6,7,8,9];"}, {"sha": "ffb9e6072dfe3cd488a5dd85e557c2448c00aa89", "filename": "src/test/run-pass/simd-intrinsic-generic-elements.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, platform_intrinsics)]\n+#![feature(repr_simd, rustc_attrs, platform_intrinsics)]\n+\n+// ignore-pretty : (#23623) problems when  ending with // comments\n \n #[repr(simd)]\n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -50,6 +52,7 @@ macro_rules! all_eq {\n     }}\n }\n \n+#[rustc_no_mir] // FIXME #27840 MIR doesn't handle shuffle constants.\n fn main() {\n     let x2 = i32x2(20, 21);\n     let x3 = i32x3(30, 31, 32);"}, {"sha": "b764a983a0c0960aa872a4c00c0982f5cc7f0456", "filename": "src/test/run-pass/super-fast-paren-parsing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -11,6 +11,7 @@\n // ignore-pretty\n //\n // exec-env:RUST_MIN_STACK=16000000\n+// rustc-env:RUST_MIN_STACK=16000000\n //\n // Big stack is needed for pretty printing, a little sad...\n "}, {"sha": "81563f40e94bb2b94fe3c8760dd9afa1337ec503", "filename": "src/test/run-pass/unique-ffi-symbols.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Funique-ffi-symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Funique-ffi-symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-ffi-symbols.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// We used to have a __rust_abi shim that resulted in duplicated symbols\n+// whenever the item path wasn't enough to disambiguate between them.\n+fn main() {\n+    let a = {\n+        extern fn good() -> i32 { return 0; }\n+        good as extern fn() -> i32\n+    };\n+    let b = {\n+        extern fn good() -> i32 { return 5; }\n+        good as extern fn() -> i32\n+    };\n+\n+    assert!(a != b);\n+    assert_eq!((a(), b()), (0, 5));\n+}"}, {"sha": "a663ae650c087574611c8156d098a3b5674abc22", "filename": "src/test/run-pass/zero-size-type-destructors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/235d77457d80b549dad3ac36d94f235208a1eafb/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs?ref=235d77457d80b549dad3ac36d94f235208a1eafb", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs, unsafe_no_drop_flag)]\n \n-#![feature(unsafe_no_drop_flag)]\n+// ignore-pretty : (#23623) problems when  ending with // comments\n \n static mut destructions : isize = 3;\n \n+#[rustc_no_mir] // FIXME #29855 MIR doesn't handle all drops correctly.\n pub fn foo() {\n     #[unsafe_no_drop_flag]\n     struct Foo;"}]}