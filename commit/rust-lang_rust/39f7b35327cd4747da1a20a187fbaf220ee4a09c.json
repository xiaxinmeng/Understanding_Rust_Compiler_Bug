{"sha": "39f7b35327cd4747da1a20a187fbaf220ee4a09c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZjdiMzUzMjdjZDQ3NDdkYTFhMjBhMTg3ZmJhZjIyMGVlNGEwOWM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-28T11:04:39Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-28T11:04:39Z"}, "message": "Stacked Borrows: print affected memory location on errors", "tree": {"sha": "fbc751bbc1a20c9c97f3b4135d89ce61c738f644", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbc751bbc1a20c9c97f3b4135d89ce61c738f644"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39f7b35327cd4747da1a20a187fbaf220ee4a09c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39f7b35327cd4747da1a20a187fbaf220ee4a09c", "html_url": "https://github.com/rust-lang/rust/commit/39f7b35327cd4747da1a20a187fbaf220ee4a09c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39f7b35327cd4747da1a20a187fbaf220ee4a09c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecf330f39eaed1f798445ae018cfb645517078bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecf330f39eaed1f798445ae018cfb645517078bc", "html_url": "https://github.com/rust-lang/rust/commit/ecf330f39eaed1f798445ae018cfb645517078bc"}], "stats": {"total": 86, "additions": 43, "deletions": 43}, "files": [{"sha": "607c830530e1f15f63fb6a093c6b01fe8466f34d", "filename": "src/range_map.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/39f7b35327cd4747da1a20a187fbaf220ee4a09c/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f7b35327cd4747da1a20a187fbaf220ee4a09c/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=39f7b35327cd4747da1a20a187fbaf220ee4a09c", "patch": "@@ -61,7 +61,9 @@ impl<T> RangeMap<T> {\n     /// Provides read-only iteration over everything in the given range. This does\n     /// *not* split items if they overlap with the edges. Do not use this to mutate\n     /// through interior mutability.\n-    pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = &'a T> + 'a {\n+    ///\n+    /// The iterator also provides the offset of the given element.\n+    pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = (Size, &'a T)> + 'a {\n         let offset = offset.bytes();\n         let len = len.bytes();\n         // Compute a slice starting with the elements we care about.\n@@ -75,7 +77,7 @@ impl<T> RangeMap<T> {\n         };\n         // The first offset that is not included any more.\n         let end = offset + len;\n-        slice.iter().take_while(move |elem| elem.range.start < end).map(|elem| &elem.data)\n+        slice.iter().take_while(move |elem| elem.range.start < end).map(|elem| (Size::from_bytes(elem.range.start), &elem.data))\n     }\n \n     pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n@@ -112,11 +114,13 @@ impl<T> RangeMap<T> {\n     /// this will split entries in the map that are only partially hit by the given range,\n     /// to make sure that when they are mutated, the effect is constrained to the given range.\n     /// Moreover, this will opportunistically merge neighbouring equal blocks.\n+    ///\n+    /// The iterator also provides the offset of the given element.\n     pub fn iter_mut<'a>(\n         &'a mut self,\n         offset: Size,\n         len: Size,\n-    ) -> impl Iterator<Item = &'a mut T> + 'a\n+    ) -> impl Iterator<Item = (Size, &'a mut T)> + 'a\n     where\n         T: Clone + PartialEq,\n     {\n@@ -197,7 +201,7 @@ impl<T> RangeMap<T> {\n             // Now we yield the slice. `end` is inclusive.\n             &mut self.v[first_idx..=end_idx]\n         };\n-        slice.iter_mut().map(|elem| &mut elem.data)\n+        slice.iter_mut().map(|elem| (Size::from_bytes(elem.range.start), &mut elem.data))\n     }\n }\n \n@@ -209,26 +213,26 @@ mod tests {\n     fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n         (offset..offset + len)\n             .into_iter()\n-            .map(|i| map.iter(Size::from_bytes(i), Size::from_bytes(1)).next().map(|&t| t).unwrap())\n+            .map(|i| map.iter(Size::from_bytes(i), Size::from_bytes(1)).next().map(|(_, &t)| t).unwrap())\n             .collect()\n     }\n \n     #[test]\n     fn basic_insert() {\n         let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n         // Insert.\n-        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(1)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(10), Size::from_bytes(1)) {\n             *x = 42;\n         }\n         // Check.\n         assert_eq!(to_vec(&map, 10, 1), vec![42]);\n         assert_eq!(map.v.len(), 3);\n \n         // Insert with size 0.\n-        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n             *x = 19;\n         }\n-        for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(0)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(11), Size::from_bytes(0)) {\n             *x = 19;\n         }\n         assert_eq!(to_vec(&map, 10, 2), vec![42, -1]);\n@@ -238,16 +242,16 @@ mod tests {\n     #[test]\n     fn gaps() {\n         let mut map = RangeMap::<i32>::new(Size::from_bytes(20), -1);\n-        for x in map.iter_mut(Size::from_bytes(11), Size::from_bytes(1)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(11), Size::from_bytes(1)) {\n             *x = 42;\n         }\n-        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n             *x = 43;\n         }\n         assert_eq!(map.v.len(), 5);\n         assert_eq!(to_vec(&map, 10, 10), vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]);\n \n-        for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(10)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(10), Size::from_bytes(10)) {\n             if *x < 42 {\n                 *x = 23;\n             }\n@@ -256,14 +260,14 @@ mod tests {\n         assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]);\n         assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 43, 23, 23]);\n \n-        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {\n+        for (_, x) in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {\n             *x = 19;\n         }\n         assert_eq!(map.v.len(), 6);\n         assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]);\n         // Should be seeing two blocks with 19.\n         assert_eq!(\n-            map.iter(Size::from_bytes(15), Size::from_bytes(2)).map(|&t| t).collect::<Vec<_>>(),\n+            map.iter(Size::from_bytes(15), Size::from_bytes(2)).map(|(_, &t)| t).collect::<Vec<_>>(),\n             vec![19, 19]\n         );\n "}, {"sha": "cf5b31597daa73e818d29a56cdd1948e585835e9", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/39f7b35327cd4747da1a20a187fbaf220ee4a09c/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f7b35327cd4747da1a20a187fbaf220ee4a09c/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=39f7b35327cd4747da1a20a187fbaf220ee4a09c", "patch": "@@ -309,14 +309,14 @@ impl<'tcx> Stack {\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n     /// If yes, return the index of the item that granted it.\n-    fn access(&mut self, access: AccessKind, tag: Tag, global: &GlobalState) -> InterpResult<'tcx> {\n+    fn access(&mut self, access: AccessKind, ptr: Pointer<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n+        let granting_idx = self.find_granting(access, ptr.tag).ok_or_else(|| {\n             err_sb_ub(format!(\n-                \"no item granting {} to tag {:?} found in borrow stack.\",\n-                access, tag\n+                \"no item granting {} to tag {:?} at {} found in borrow stack.\",\n+                access, ptr.tag, ptr.erase_tag(),\n             ))\n         })?;\n \n@@ -328,7 +328,7 @@ impl<'tcx> Stack {\n             let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(&item, Some(tag), global)?;\n+                Stack::check_protector(&item, Some(ptr.tag), global)?;\n             }\n         } else {\n             // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n@@ -343,7 +343,7 @@ impl<'tcx> Stack {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n-                    Stack::check_protector(item, Some(tag), global)?;\n+                    Stack::check_protector(item, Some(ptr.tag), global)?;\n                     item.perm = Permission::Disabled;\n                 }\n             }\n@@ -355,12 +355,12 @@ impl<'tcx> Stack {\n \n     /// Deallocate a location: Like a write access, but also there must be no\n     /// active protectors at all because we will remove all items.\n-    fn dealloc(&mut self, tag: Tag, global: &GlobalState) -> InterpResult<'tcx> {\n+    fn dealloc(&mut self, ptr: Pointer<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n-        self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n+        self.find_granting(AccessKind::Write, ptr.tag).ok_or_else(|| {\n             err_sb_ub(format!(\n-                \"no item granting write access for deallocation to tag {:?} found in borrow stack\",\n-                tag,\n+                \"no item granting write access for deallocation to tag {:?} at {} found in borrow stack\",\n+                ptr.tag, ptr.erase_tag(),\n             ))\n         })?;\n \n@@ -372,20 +372,20 @@ impl<'tcx> Stack {\n         Ok(())\n     }\n \n-    /// Derived a new pointer from one with the given tag.\n+    /// Derive a new pointer from one with the given tag.\n     /// `weak` controls whether this operation is weak or strong: weak granting does not act as\n     /// an access, and they add the new item directly on top of the one it is derived\n     /// from instead of all the way at the top of the stack.\n-    fn grant(&mut self, derived_from: Tag, new: Item, global: &GlobalState) -> InterpResult<'tcx> {\n+    fn grant(&mut self, derived_from: Pointer<Tag>, new: Item, global: &GlobalState) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let granting_idx = self.find_granting(access, derived_from)\n+        let granting_idx = self.find_granting(access, derived_from.tag)\n             .ok_or_else(|| err_sb_ub(format!(\n-                \"trying to reborrow for {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\",\n-                new.perm, derived_from,\n+                \"trying to reborrow for {:?} at {}, but parent tag {:?} does not have an appropriate item in the borrow stack\",\n+                new.perm, derived_from.erase_tag(), derived_from.tag,\n             )))?;\n \n         // Compute where to put the new item.\n@@ -443,12 +443,14 @@ impl<'tcx> Stacks {\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        f: impl Fn(&mut Stack, &GlobalState) -> InterpResult<'tcx>,\n+        f: impl Fn(Pointer<Tag>, &mut Stack, &GlobalState) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            f(stack, &*global)?;\n+        for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n+            let mut cur_ptr = ptr;\n+            cur_ptr.offset = offset;\n+            f(cur_ptr, stack, &*global)?;\n         }\n         Ok(())\n     }\n@@ -487,19 +489,13 @@ impl Stacks {\n     #[inline(always)]\n     pub fn memory_read<'tcx>(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |stack, global| {\n-            stack.access(AccessKind::Read, ptr.tag, global)?;\n-            Ok(())\n-        })\n+        self.for_each(ptr, size, |ptr, stack, global| stack.access(AccessKind::Read, ptr, global))\n     }\n \n     #[inline(always)]\n     pub fn memory_written<'tcx>(&mut self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |stack, global| {\n-            stack.access(AccessKind::Write, ptr.tag, global)?;\n-            Ok(())\n-        })\n+        self.for_each(ptr, size, |ptr, stack, global| stack.access(AccessKind::Write, ptr, global))\n     }\n \n     #[inline(always)]\n@@ -509,7 +505,7 @@ impl Stacks {\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |stack, global| stack.dealloc(ptr.tag, global))\n+        self.for_each(ptr, size, |ptr, stack, global| stack.dealloc(ptr, global))\n     }\n }\n \n@@ -561,14 +557,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Permission::SharedReadWrite\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n-                        stack.grant(cur_ptr.tag, item, global)\n+                    stacked_borrows.for_each(cur_ptr, size, |cur_ptr, stack, global| {\n+                        stack.grant(cur_ptr, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        stacked_borrows.for_each(ptr, size, |stack, global| stack.grant(ptr.tag, item, global))\n+        stacked_borrows.for_each(ptr, size, |ptr, stack, global| stack.grant(ptr, item, global))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version."}]}