{"sha": "33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYWEyZjhlNGYyYjljN2MzYTZiMjg0MjdjYjZkNmYyYWVmN2I4MDI=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-01-31T14:57:44Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-07T17:28:10Z"}, "message": "Fix assoc type selection", "tree": {"sha": "4d6186c81d4d99ca610d52ce9abf62bd0bed4f75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d6186c81d4d99ca610d52ce9abf62bd0bed4f75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802", "html_url": "https://github.com/rust-lang/rust/commit/33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a8279a21ad75ae2cb6d96746b8a880038ec0455", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8279a21ad75ae2cb6d96746b8a880038ec0455", "html_url": "https://github.com/rust-lang/rust/commit/4a8279a21ad75ae2cb6d96746b8a880038ec0455"}], "stats": {"total": 75, "additions": 43, "deletions": 32}, "files": [{"sha": "5138019c73f23c545ef87ba52d5ec85c9b6f3a88", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802", "patch": "@@ -10,7 +10,7 @@ use std::sync::Arc;\n \n use hir_def::{\n     builtin_type::BuiltinType,\n-    generics::{WherePredicateTarget, WherePredicate},\n+    generics::{WherePredicate, WherePredicateTarget},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n@@ -27,8 +27,8 @@ use crate::{\n         all_super_traits, associated_type_by_name_including_super_traits, generics, make_mut_slice,\n         variant_data,\n     },\n-    FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef,\n-    Ty, TypeCtor, PolyFnSig, Binders,\n+    Binders, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate, ProjectionTy, Substs,\n+    TraitEnvironment, TraitRef, Ty, TypeCtor,\n };\n \n #[derive(Debug)]\n@@ -62,7 +62,7 @@ impl<'a, DB: HirDatabase> TyLoweringContext<'a, DB> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum ImplTraitLoweringMode {\n     /// `impl Trait` gets lowered into an opaque type that doesn't unify with\n     /// anything except itself. This is used in places where values flow 'out',\n@@ -78,7 +78,7 @@ pub enum ImplTraitLoweringMode {\n     Disallowed,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum TypeParamLoweringMode {\n     Placeholder,\n     Variable,\n@@ -140,12 +140,13 @@ impl Ty {\n                     ImplTraitLoweringMode::Variable => {\n                         let idx = ctx.impl_trait_counter.get();\n                         ctx.impl_trait_counter.set(idx + 1);\n-                        let (self_params, list_params, _impl_trait_params) = if let Some(def) = ctx.resolver.generic_def() {\n-                            let generics = generics(ctx.db, def);\n-                            generics.provenance_split()\n-                        } else {\n-                            (0, 0, 0)\n-                        };\n+                        let (self_params, list_params, _impl_trait_params) =\n+                            if let Some(def) = ctx.resolver.generic_def() {\n+                                let generics = generics(ctx.db, def);\n+                                generics.provenance_split()\n+                            } else {\n+                                (0, 0, 0)\n+                            };\n                         // assert!((idx as usize) < impl_trait_params); // TODO return position impl trait\n                         Ty::Bound(idx as u32 + self_params as u32 + list_params as u32)\n                     }\n@@ -251,7 +252,7 @@ impl Ty {\n                         // FIXME: maybe return name in resolution?\n                         let name = generics.param_name(param_id);\n                         Ty::Param { idx, name }\n-                    },\n+                    }\n                     TypeParamLoweringMode::Variable => Ty::Bound(idx),\n                 }\n             }\n@@ -262,15 +263,15 @@ impl Ty {\n                     TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n                 };\n                 ctx.db.impl_self_ty(impl_id).subst(&substs)\n-            },\n+            }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(ctx.db, adt.into());\n                 let substs = match ctx.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => Substs::identity(&generics),\n                     TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n                 };\n                 ctx.db.ty(adt.into()).subst(&substs)\n-            },\n+            }\n \n             TypeNs::AdtId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n             TypeNs::BuiltinType(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n@@ -309,7 +310,8 @@ impl Ty {\n         segment: PathSegment<'_>,\n     ) -> Ty {\n         let param_idx = match self_ty {\n-            Ty::Param { idx, .. } => idx,\n+            Ty::Param { idx, .. } if ctx.type_param_mode == TypeParamLoweringMode::Placeholder => idx,\n+            Ty::Bound(idx) if ctx.type_param_mode == TypeParamLoweringMode::Variable => idx,\n             _ => return Ty::Unknown, // Error: Ambiguous associated type\n         };\n         let def = match ctx.resolver.generic_def() {\n@@ -318,7 +320,14 @@ impl Ty {\n         };\n         let predicates = ctx.db.generic_predicates_for_param(def.into(), param_idx);\n         let traits_from_env = predicates.iter().filter_map(|pred| match pred {\n-            GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n+            GenericPredicate::Implemented(tr) => {\n+                if let Ty::Param { idx, .. } = tr.self_ty() {\n+                    if *idx == param_idx {\n+                        return Some(tr.trait_);\n+                    }\n+                }\n+                None\n+            }\n             _ => None,\n         });\n         let traits = traits_from_env.flat_map(|t| all_super_traits(ctx.db, t));\n@@ -516,10 +525,10 @@ impl GenericPredicate {\n                     TypeParamLoweringMode::Placeholder => {\n                         let name = generics.param_name(param_id);\n                         Ty::Param { idx, name }\n-                    },\n+                    }\n                     TypeParamLoweringMode::Variable => Ty::Bound(idx),\n                 }\n-            },\n+            }\n         };\n         GenericPredicate::from_type_bound(ctx, &where_predicate.bound, self_ty)\n     }\n@@ -615,7 +624,9 @@ pub(crate) fn generic_predicates_for_param_query(\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n         .filter(|pred| match &pred.target {\n-            WherePredicateTarget::TypeRef(type_ref) => Ty::from_hir_only_param(&ctx, type_ref) == Some(param_idx),\n+            WherePredicateTarget::TypeRef(type_ref) => {\n+                Ty::from_hir_only_param(&ctx, type_ref) == Some(param_idx)\n+            }\n             WherePredicateTarget::TypeParam(local_id) => {\n                 let param_id = hir_def::TypeParamId { parent: def, local_id: *local_id };\n                 let idx = generics.param_idx(param_id);\n@@ -701,8 +712,8 @@ fn type_for_const(db: &impl HirDatabase, def: ConstId) -> Binders<Ty> {\n     let data = db.const_data(def);\n     let generics = generics(db, def.into());\n     let resolver = def.resolver(db);\n-    let ctx = TyLoweringContext::new(db, &resolver)\n-        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n \n     Binders::new(generics.len(), Ty::from_hir(&ctx, &data.type_ref))\n }\n@@ -731,8 +742,8 @@ fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> PolyFn\n     let struct_data = db.struct_data(def.into());\n     let fields = struct_data.variant_data.fields();\n     let resolver = def.resolver(db);\n-    let ctx = TyLoweringContext::new(db, &resolver)\n-        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params =\n         fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n     let ret = type_for_adt(db, def.into());\n@@ -755,8 +766,8 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId\n     let var_data = &enum_data.variants[def.local_id];\n     let fields = var_data.variant_data.fields();\n     let resolver = def.parent.resolver(db);\n-    let ctx = TyLoweringContext::new(db, &resolver)\n-        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params =\n         fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n     let ret = type_for_adt(db, def.parent.into());\n@@ -784,8 +795,8 @@ fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Binders<Ty> {\n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     let generics = generics(db, t.into());\n     let resolver = t.resolver(db);\n-    let ctx = TyLoweringContext::new(db, &resolver)\n-        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let type_ref = &db.type_alias_data(t).type_ref;\n     let substs = Substs::bound_vars(&generics);\n     let inner = Ty::from_hir(&ctx, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n@@ -870,8 +881,8 @@ pub(crate) fn impl_self_ty_query(db: &impl HirDatabase, impl_id: ImplId) -> Bind\n     let impl_data = db.impl_data(impl_id);\n     let resolver = impl_id.resolver(db);\n     let generics = generics(db, impl_id.into());\n-    let ctx = TyLoweringContext::new(db, &resolver)\n-        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let ctx =\n+        TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     Binders::new(generics.len(), Ty::from_hir(&ctx, &impl_data.target_type))\n }\n "}, {"sha": "e2351ca983eff23feba7ef2793b0c71867aabfa4", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=33aa2f8e4f2b9c7c3a6b28427cb6d6f2aef7b802", "patch": "@@ -358,15 +358,15 @@ fn test() {\n     [221; 223) '{}': ()\n     [234; 300) '{     ...(S); }': ()\n     [244; 245) 'x': u32\n-    [248; 252) 'foo1': fn foo1<S>(T) -> <T as Iterable>::Item\n+    [248; 252) 'foo1': fn foo1<S>(S) -> <S as Iterable>::Item\n     [248; 255) 'foo1(S)': u32\n     [253; 254) 'S': S\n     [265; 266) 'y': u32\n-    [269; 273) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n+    [269; 273) 'foo2': fn foo2<S>(S) -> <S as Iterable>::Item\n     [269; 276) 'foo2(S)': u32\n     [274; 275) 'S': S\n     [286; 287) 'z': u32\n-    [290; 294) 'foo3': fn foo3<S>(T) -> <T as Iterable>::Item\n+    [290; 294) 'foo3': fn foo3<S>(S) -> <S as Iterable>::Item\n     [290; 297) 'foo3(S)': u32\n     [295; 296) 'S': S\n     \"###"}]}